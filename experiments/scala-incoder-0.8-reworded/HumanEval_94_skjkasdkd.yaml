name: HumanEval_94_skjkasdkd
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of integers.\n    // You need to find the largest prime\
  \ value and return the sum of its digits.\n    // Examples:\n    // >>> skjkasdkd((List[Long](0l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong,\
  \ 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong,\
  \ 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong)))\n    //\
  \ (10l)\n    // >>> skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong,\
  \ 2l.toLong, 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong,\
  \ 2l.toLong, 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong)))\n\
  \    // (25l)\n    // >>> skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong,\
  \ 32l.toLong, 5107l.toLong, 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong,\
  \ 23l.toLong, 2323l.toLong, 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong)))\n\
  \    // (13l)\n    // >>> skjkasdkd((List[Long](0l.toLong, 724l.toLong, 32l.toLong,\
  \ 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong, 5l.toLong, 91l.toLong,\
  \ 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong)))\n    // (11l)\n    // >>> skjkasdkd((List[Long](0l.toLong,\
  \ 81l.toLong, 12l.toLong, 3l.toLong, 1l.toLong, 21l.toLong)))\n    // (3l)\n   \
  \ // >>> skjkasdkd((List[Long](0l.toLong, 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
  \ 7l.toLong)))\n    // (7l)\n    def skjkasdkd(lst : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(skjkasdkd((List[Long](0l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 4l.toLong, 5l.toLong,\
  \ 5l.toLong, 5l.toLong, 2l.toLong, 181l.toLong, 32l.toLong, 4l.toLong, 32l.toLong,\
  \ 3l.toLong, 2l.toLong, 32l.toLong, 324l.toLong, 4l.toLong, 3l.toLong))) == (10l));\n\
  \    assert(skjkasdkd((List[Long](1l.toLong, 0l.toLong, 1l.toLong, 8l.toLong, 2l.toLong,\
  \ 4597l.toLong, 2l.toLong, 1l.toLong, 3l.toLong, 40l.toLong, 1l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong, 4l.toLong, 2l.toLong, 5l.toLong, 1l.toLong))) == (25l));\n\
  \    assert(skjkasdkd((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 32l.toLong, 5107l.toLong,\
  \ 34l.toLong, 83278l.toLong, 109l.toLong, 163l.toLong, 23l.toLong, 2323l.toLong,\
  \ 32l.toLong, 30l.toLong, 1l.toLong, 9l.toLong, 3l.toLong))) == (13l));\n    assert(skjkasdkd((List[Long](0l.toLong,\
  \ 724l.toLong, 32l.toLong, 71l.toLong, 99l.toLong, 32l.toLong, 6l.toLong, 0l.toLong,\
  \ 5l.toLong, 91l.toLong, 83l.toLong, 0l.toLong, 5l.toLong, 6l.toLong))) == (11l));\n\
  \    assert(skjkasdkd((List[Long](0l.toLong, 81l.toLong, 12l.toLong, 3l.toLong,\
  \ 1l.toLong, 21l.toLong))) == (3l));\n    assert(skjkasdkd((List[Long](0l.toLong,\
  \ 8l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 7l.toLong))) == (7l));\n    assert(skjkasdkd((List[Long](8191l.toLong)))\
  \ == (19l));\n    assert(skjkasdkd((List[Long](8191l.toLong, 123456l.toLong, 127l.toLong,\
  \ 7l.toLong))) == (19l));\n    assert(skjkasdkd((List[Long](127l.toLong, 97l.toLong,\
  \ 8192l.toLong))) == (10l));\n    }\n\n}\n"
completions: ["        def helper(acc: Int, prime: Int, num: Long) : Long = num match\
    \ {\n            case 0 => acc\n            case i => helper(acc + (prime * i),\
    \ prime * i, num / i)\n        }\n        val result = helper(0, 0, lst.reduceLeft(_\
    \ + _))\n        result match {\n            case i if i % 2 == 0 => i * 3\n \
    \           case i => i * 2\n        }", "        def isPrime(n: Long) : Boolean\
    \ = n match {\n            case 0      => false\n            case 1      => true\n\
    \            case _ =>\n                val d = scala.math.sqrt(n)\n         \
    \       val m = scala.math.scalalen(n)\n                if (n % 2 == 0) false\
    \ else if (m == 2) true else if (d <= 1) false else {\n                    val\
    \ roots = scala.collection.mutable.ArrayBuffer.empty[Long]\n                 \
    \   for (x <- 2L until (n + 1)) {\n                        if ((x % 2) == 0) roots\
    \ += x\n                        if ((x / 2) == 0) roots += (x * x)\n         \
    \           }\n                    roots.takeWhile(x => x > n).isEmpty\n     \
    \           }\n        }\n\n        var largestPrime = 0l\n        var largestSum\
    \ = 0l\n        for (i <- 1 to lst.size) {\n            val n = lst(i).toLong\n\
    \            if (isPrime(n)) {\n                if (n > largestPrime) {\n    \
    \                largestPrime = n\n                }\n                largestSum\
    \ += n\n            }\n        }\n        return largestSum.toLong", "       \
    \ //var max_prime = 0\n        var max_prime = 0L\n        var max_sum = 0L\n\
    \        for (i <- 0 until lst.length) {\n            val prime = 1\n        \
    \    var sum = 0\n            while (prime <= i) {\n                if (lst.dropWhile(!_\
    \ % prime).forall(x => x != i) && prime < i) {\n                    val d = lst.takeWhile(x\
    \ => x != i).sum\n                    sum += d\n                    i = prime\n\
    \                    break\n                }\n                prime += 1\n  \
    \          }\n            if (sum > max_sum) {\n                max_sum = sum\n\
    \                max_prime = i\n            }\n        }\n        max_sum", " \
    \       var max = List[Long]()\n        var maxPrime = 0\n        var maxSum =\
    \ 0\n        for( i <- 0 to lst.length-1 ) {\n            if( lst(i) > maxSum+maxPrime\
    \ ) {\n                max += lst(i)\n                maxPrime = lst(i)\n    \
    \        }\n        }\n        maxSum", "        val l1 = lst.takeWhile(_ > 0).toList\n\
    \        val l2 = lst.dropWhile(_ > 0).takeWhile(_ > 0).toList\n        val n\
    \ = new scala.collection.mutable.ListBuffer[Long]()\n        val temp = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        var max = l1(0)\n        var i = 0\n        for (i <- 0 until l1.length)\
    \ {\n            val m = l2(l1.length - i)\n            n += m.toLong\n      \
    \      if (m > max)\n                max = m\n        }\n        n.foreach(m =>\
    \ temp += m.toLong)\n        val primes = primes(temp)\n        val sum = primes.map(p\
    \ => n % p).sum\n        sum", "        var max = 0l\n        var sum = 0l\n \
    \       var largest = 0l\n        val prime = PrimeChecker.primeCheck(lst.toArray.toList)\n\
    \        prime foreach { n =>\n            largest = n\n            sum += n.toString.toLong\n\
    \        }\n        return (sum + largest).toLong", "        val primes = lst.filter(_\
    \ % 2 != 0).toSet\n        val maxPrime = lst.filter(_ > 1).map(_ % 2).toSet.max\n\
    \        val primesSet = primes.toSet\n        val sumDigits = lst.filter( x =>\
    \ primesSet.contains(x))\n        .foldLeft(0)((acc, x) => acc + x.toString.toLong)\n\
    \        (sumDigits + maxPrime)", "        var ans = 0\n        for( i <- 0 until\
    \ lst.size ) {\n            if( isPrime(lst(i)) ) {\n                ans = ans\
    \ + lst(i).toString.toLong\n            }\n        }\n        ans", "        val\
    \ r = new scala.collection.mutable.ListBuffer[Long]()\n        var sum = 0\n\n\
    \        for (i <- lst.indices) {\n            val tmp = 0\n            val n\
    \ = lst(i)\n\n            if (n % 2 == 0) {\n                val n1 = n + 1\n\
    \                for (j <- 1 to n1) {\n                    if (n % j == 0) {\n\
    \                        tmp += 1\n                    }\n                }\n\
    \            } else {\n                val n2 = n - 1\n                for (j\
    \ <- 1 to n2) {\n                    if (n % j == 0) {\n                     \
    \   tmp += 1\n                    }\n                }\n            }\n\n    \
    \        if (tmp > r.length) {\n                r.resize(r.size + tmp)\n     \
    \       }\n            r(tmp) = tmp.toLong\n\n            if (tmp > sum) {\n \
    \               sum = tmp\n            }\n        }\n\n        val max = r.max\n\
    \        for (i <- 0 until max) {\n            if (r(i) > 0) sum += r(i)\n   \
    \     }\n\n        sum", "        // write your logic here\n        var max =\
    \ lst.max\n        val primes = mutable.MutableList[Long]()\n        var sum =\
    \ 0\n\n        while(primes.contains(max))\n        {\n            primes ++=\
    \ lst filter (x => x % max != 0) filter (x => x % max == 0)\n            max +=\
    \ 1\n        }\n        primes foreach {x => sum += x}\n        return sum", " \
    \       val primes = lst.filter( prime => lst.size % prime != 0L)\n        if\
    \ (primes.isEmpty) 0\n        else primes.max( prime => lst.sum % prime ).sum.toLong",
  "        val map = (lst.map(x => x % 2 == 0).toList.toMap + (lst.map(x => x % 2\
    \ != 0).toList.toMap))\n        val prime = lst.filter(x => map.get(x)).last\n\
    \        prime match {\n            case n : Long => lst.filter(x => map.get(x)).sum\n\
    \            case _ => 0\n        }", "        var primes : mutable.HashSet[Long]\
    \ = mutable.HashSet[Long]()\n        for (i <- lst.indices) {\n            primes\
    \ += lst(i)\n        }\n        var prime : Long = 0\n        for (i<-primes)\
    \ {\n            prime += i.toLong % 10\n        }\n        return prime", " \
    \       def isPrime(n: Long) : Boolean = n <= 1 || !(n % 2l).exists(x => x ==\
    \ 0l)\n        def getPrimes(n: Long) : List[Long] = List(n) ++ List(n.toLong\
    \ - n / 2l) ++ List(n.toLong * 3l - n % 2l)\n        val primes = lst.filter(isPrime).distinct\n\
    \        val n = primes.head\n        val sum = lst.filter(n => n % n).map(_.toLong).sum\n\
    \        sum", "        val n = lst.size\n        val largest = lst(0)\n     \
    \   val prime = primes(largest)\n        var sum = 0\n        for(i <- 1 until\
    \ n) {\n            val j = i * prime\n            val m = lst(i)\n          \
    \  if(j > m) sum = sum + j % prime\n        }\n        sum", "        val primes\
    \ = List(3, 7)\n        val maxPrime = lst.max\n\n        for (i <- primes.reverse.takeWhile(n\
    \ => n <= maxPrime)) {\n            val l = lst.filter(_ % i ==0).sum\n      \
    \      if (l > 0) return l\n        }\n        return 0", "        def findNextPrime(curr\
    \ : Long) : Long = {\n            val upperBound : Long = curr + (lst - 1).filter(_\
    \ > curr).max\n            for(prime <- 2 until upperBound ; n <- curr + 1 until\
    \ upperBound ; m <- 2 until n) {\n                if(!(n + m) %in% curr) {\n \
    \                   return (n + m)\n                }\n            }\n       \
    \     return 0L\n        }\n        val primes: mutable.ListBuffer[Long] = mutable.ListBuffer()\n\
    \        var maxSum = 0L\n        for(i<- lst) {\n            if(primes.contains(i))\
    \ {\n                maxSum += i.toLong\n            }\n            else if(primes.isEmpty)\
    \ {\n                maxSum = i.toLong\n            }\n            else {\n  \
    \              primes += i.toLong\n            }\n        }\n        if(primes.nonEmpty)\
    \ {\n            val largestPrime = primes.max\n            maxSum += largestPrime\n\
    \            for(i<- primes) {\n                primes.delete(i)\n           \
    \ }\n            findNextPrime(largestPrime)\n        }\n        else {\n    \
    \        val sumOfDigits = lst.filter(_ < maxSum).sum\n            sumOfDigits\n\
    \        }", "        var primes = mutable.ArrayBuffer.empty[Long]\n        val\
    \ maxPrime = lst.max(lst => lst.toLong)\n        prime lst lst lst primes\n  \
    \      val sum : Long = primes.toList.map(_.toLong).sum\n        return sum",
  "        // Create a map for keeping track of the already seen primes.\n       \
    \ // Key is prime number, value is a boolean indicating if it is seen before.\n\
    \        val seen = scala.collection.mutable.HashMap.empty[Long, Boolean]\n\n\
    \        // Create a set for keeping track of the already seen digits.\n     \
    \   // Value is 0 if digit is not yet seen, 1 otherwise.\n        val seenDigits\
    \ = scala.collection.mutable.HashMap.empty[Long, Int]\n\n        // Set up starting\
    \ values.\n        val totalSum = 0\n        val largestPrime = 0\n        val\
    \ largestPrimeIndex = -1\n\n        // Loop from smallest number to the largest.\n\
    \        for (i <- lst.min.toLong to lst.max.toLong) {\n            // Get the\
    \ current number, but don't add it yet.\n            val currentNumber = lst(i)\n\
    \n            // Check to see if the current number is a prime.\n            //\
    \ If it is, add it to the largest prime and add its digits to the total sum.\n\
    \            // Otherwise, check to see if it is already in the seen set.\n  \
    \          if (isPrime(currentNumber)) {\n                largestPrime = currentNumber\n\
    \                largestPrimeIndex = i\n                seen(currentNumber) =\
    \ true\n            }\n            else if (seen.contains(currentNumber)) {\n\
    \                // If it is already in the seen set, check to see if the digit\
    \ already exists.\n                val seenIndex = seenDigits(currentNumber)\n\
    \                if (seenIndex == 0) {\n                    // If digit is not\
    \ yet seen, add it to the total sum.\n                    totalSum += currentNumber\n\
    \                }\n                else {\n                    // If digit is\
    \ already seen, add it to the total sum.\n                    totalSum -= currentNumber\n\
    \                }\n            }\n            else {\n                // If it\
    \ is not already a prime, check to see if it is already in the seen set and add\
    \ its digits to the total sum.\n                seenDigits(currentNumber) += 1\n\
    \                totalSum += currentNumber\n            }\n        }\n       \
    \ largestPrime", "        val map = new mutable.LinkedHashMap[Long,Long]\n   \
    \     val max = lst.foldLeft(0l)((ac,b) => if (b<ac) b else ac)\n        for(i\
    \ <- 1 to max) map(i.toLong) += lst.head\n        val maxKey = map.keys.max\n\
    \        val maxValue = 0\n        for(key <- map.keys) if(key.toLong==maxKey)\
    \ maxValue += map.get(key)\n        max(maxValue,max)", "        var max_sum =\
    \ 0l\n        var max_prime = 0l\n        var max_index = 0l\n        var sum\
    \ = 0l\n\n        for (i <- 0 until lst.length)\n        {\n            val current\
    \ = lst(i)\n            if (isPrime(current))\n            {\n               \
    \ max_index = i\n                max_prime = current\n                sum = i\n\
    \            }\n            else\n            {\n                sum += (current\
    \ % max_prime)\n            }\n        }\n        max_sum += sum\n\n        max_index",
  "        // For each element in the list, go through the list again and check to\
    \ see if it is prime or not.\n        // If it is prime, sum up the digits of\
    \ the number\n        // If it isn't prime, continue with the next number\n  \
    \      val primes = lst.reverse.flatMap(n => isPrime(n)).distinct\n        val\
    \ m = primes.max\n        primes.find(n => n == m).map(n => sumDigits(lst, n)).getOrElse(\"\
    No prime found for numbers in the list\")", "        val primes = Primes(lst).distinct\n\
    \        val maxPrime = primes.max\n        val largestPrimeNumbers = primes.filter(_\
    \ < maxPrime)\n        val sumDigitsOfPrimes = largestPrimeNumbers.map(x => BigInt(x).digitSum)\n\
    \        val sum = sumDigitsOfPrimes.reduceLeft(_ + _)\n        sum", "      \
    \  val max = -1000\n        var maxPrime = 0\n        var maxSum = 0\n       \
    \ for (i <- 0 until lst.length)\n        {\n            val sum = lst(i).toString.toLong\
    \ + maxPrime.toString.toLong\n            if (sum > max)\n            {\n    \
    \            max = sum\n                maxPrime = lst(i)\n            }\n   \
    \     }\n        maxPrime", "        val primes = ListBuffer[Long]()\n       \
    \ val l = lst.size\n        if(l <= 0) 1\n        else if(l < 30) l\n        else\
    \ {\n            var m = 0\n            var p = 31\n            val divs = mutable.ListBuffer[Long]()\n\
    \            val divsPrimes = mutable.ListBuffer[Long]()\n            var divsSum\
    \ = 0\n            var divsSumPrimes = 0\n            var primesSum = 0\n    \
    \        var primesSumPrimes = 0\n            while(p <= l) {\n              \
    \  val div = p / m\n                divs += div\n                divsPrimes +=\
    \ div\n                if(primes.contains(div)) divsSum = divsSum * div + divsSum\n\
    \                else {\n                    primes += div\n                 \
    \   primesSumPrimes += div\n                    if(primes.contains(div)) primesSum\
    \ = primesSum * div + primesSum\n                }\n                divsSum +=\
    \ p\n                p = 31 * p + 2\n                m++\n            }\n    \
    \        val result = (primes.filter(_ % 2 == 0).sum + primes.filter(_ % 3 ==\
    \ 0).sum + primes.filter(_ % 5 == 0).sum + primes.filter(_ % 7 == 0).sum + primes.filter(_\
    \ % 11 == 0).sum + primes.filter(_ % 13 == 0).sum + primes.filter(_ % 17 == 0).sum\
    \ + primes.filter(_ % 19 == 0).sum + primes.filter(_ % 23 == 0).sum + primes.filter(_\
    \ % 29 == 0).sum + primes.filter(_ % 31 == 0).sum + primes.filter(_ % 37 == 0).sum\
    \ + primes.filter(_ % 41) == (primesSum + primesSumPrimes).asInstanceOf[Long])\
    \ * lst.head.toLong\n            divs.clear()\n            divsPrimes.clear()\n\
    \            return result\n        }", "        // Find the first element of\
    \ the list\n        def next(lst : List[Long], i : Long) : Long = {\n        \
    \    if (i < lst.length)\n                lst(i) + next(lst, i+1)\n          \
    \  else\n                0\n        }\n        var max = -1L\n        var i =\
    \ 0L\n        while (lst != null) {\n            if (lst(i) > max) {\n       \
    \         max = lst(i)\n                i = 0\n            }\n            i +=\
    \ 1\n        }\n        next(lst, 0L)", "        val isPrime = lst.sliding(2).map(a\
    \ => isPrime(a._1, a._2))\n        val largestPrime: Option[Long] = isPrime.maxBy(a\
    \ => a._2)\n        largestPrime.getOrElse(0)", "        var sum = 0\n       \
    \ var max = -1\n        var nextMax = -1\n        val num = new mutable.HashMap[Long,\
    \ Boolean]()\n        val prime = new mutable.HashSet[Long]()\n        for ( i\
    \ <- lst ) {\n            if (num.contains(i)) {\n                sum += i.toString.toLong\n\
    \            }\n            if (num.contains(i - 1)) {\n                sum +=\
    \ i.toString.toLong\n            }\n            if (num.contains(i + 1)) {\n \
    \               sum += i.toString.toLong\n            }\n            if (num.contains(i\
    \ - 2)) {\n                sum += i.toString.toLong\n            }\n         \
    \   if (num.contains(i + 2)) {\n                sum += i.toString.toLong\n   \
    \         }\n            if (num.contains(i - 3)) {\n                sum += i.toString.toLong\n\
    \            }\n            if (num.contains(i + 3)) {\n                sum +=\
    \ i.toString.toLong\n            }\n            if (num.contains(i - 4)) {\n \
    \               sum += i.toString.toLong\n            }\n            if (num.contains(i\
    \ + 4)) {\n                sum += i.toString.toLong\n            }\n         \
    \   if (num.contains(i - 5)) {\n                sum += i.toString.toLong\n   \
    \         }\n            if (num.contains(i + 5)) {\n                sum += i.toString.toLong\n\
    \            }\n            if (num.contains(i - 6)) {\n                sum +=\
    \ i.toString.toLong\n            }\n            if (num.contains(i + 6)) {\n \
    \               sum += i.toString.toLong\n            }\n            if (num.contains(i\
    \ - 7)) {\n                sum += i.toString.toLong\n            }\n         \
    \   if (num.contains(i + 7)) {\n                sum += i.toString.toLong\n   \
    \         }\n            if (num.contains(i - 8)) {\n                sum += i.toString.toLong\n\
    \            }\n            if (num.contains(i + 8)) {\n                sum +=\
    \ i.toString.toLong\n            }\n            if (num.contains(i - 9)) {\n \
    \               sum += i.toString.toLong\n            }\n            if (num.contains(i\
    \ + 9)) {\n                sum += i.toString.toLong\n            }\n         \
    \   if (num.contains(i - 10)) {\n                sum += i.toString.toLong\n  \
    \          }\n            if (num.contains(i + 10)) {\n                sum +=\
    \ i.toString.toLong\n            }\n            if (num.contains(i - 11)) {\n\
    \                sum += i.toString.toLong\n            }\n            if (num.contains(i\
    \ + 11)) {\n                sum += i.toString.toLong\n            }\n        \
    \    if (num.contains(i - 12)) {\n                sum += i.toString.toLong\n \
    \           }\n            if (num.contains(i + 12)) {\n                sum +=\
    \ i.toString.toLong\n            }\n            if (num.contains(i - 13)) {\n\
    \                sum += i.toString.toLong\n            }", "        // You will\
    \ need to create a list of all prime numbers, from 0 to list.last - 1.\n     \
    \   // For each element of list, record the number of times it occurs.\n     \
    \   // The number 1 will never appear in the list.\n        val primes = List(1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong,\
    \ 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong,\
    \ 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong,\
    \ 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong, 101l.toLong, 103l.toLong, 107l.toLong,\
    \ 109l.toLong, 113l.toLong, 127l.toLong, 131l.toLong, 137l.toLong, 139l.toLong,\
    \ 149l.toLong, 151l.toLong, 157l.toLong, 163l.toLong, 167l.toLong, 173l.toLong,\
    \ 179l.toLong, 181l.toLong, 191l.toLong, 193l.toLong, 197l.toLong, 199l.toLong,\
    \ 211l.toLong, 223l.toLong, 227l.toLong, 229l.toLong, 233l.toLong, 239l.toLong,\
    \ 241l.toLong, 251l.toLong, 257l.toLong, 263l.toLong, 269l.toLong, 271l.toLong,\
    \ 277l.toLong, 281l.toLong, 283l.toLong, 293l.toLong, 307l.toLong, 311l.toLong,\
    \ 313l.toLong, 317l.toLong, 331l.toLong, 337l.toLong, 347l.toLong, 349l.toLong,\
    \ 353l.toLong, 359l.toLong, 367l.toLong, 373l.toLong, 379l.toLong, 383l.toLong,\
    \ 389l.toLong, 397l.toLong, 401l.toLong, 409l.toLong, 419l.toLong, 421l.toLong,\
    \ 431l.toLong, 433l.toLong, 439l.toLong, 443l.toLong, 449l.toLong, ", "      \
    \  var sum : Long = 0\n        var maxPrime : Long = 0\n        var lastPrime\
    \ : Long = 0\n        var lastPrimeIsPrime : Boolean = false\n        var isPrimeIteration\
    \ : Long = 0\n        var isPrime : Long = 1\n        var listIsPrimeIteration\
    \ : Long = 0\n        var listIsPrime : Boolean = false\n        var listPrimeIteration\
    \ : Long = 0\n        var listPrime : Long = 1\n        var listPrimeIsPrime :\
    \ Boolean = false\n        val primes = mutable.Queue(2l)\n        for (elem <-\
    \ lst) {\n            if (primes.isEmpty) {\n                primes += elem\n\
    \                if (elem == lastPrime && !lastPrimeIsPrime)\n               \
    \     sum += lastPrime\n                else if (elem == lastPrime && lastPrimeIsPrime)\n\
    \                    sum += lastPrime\n                else\n                \
    \    sum -= lastPrime\n                lastPrimeIsPrime = false\n            \
    \    lastPrime = elem\n                isPrimeIteration = 0\n                isPrime\
    \ = 1\n                listIsPrimeIteration = 0\n                listIsPrime =\
    \ false\n                listPrimeIteration = 0\n                listPrime = 1\n\
    \                listPrimeIsPrime = false\n            } else\n            if\
    \ (isPrime != elem || listIsPrime) {\n                primes += elem\n       \
    \         if (elem == lastPrime && !lastPrimeIsPrime)\n                    sum\
    \ += lastPrime\n                else if (elem == lastPrime && lastPrimeIsPrime)\n\
    \                    sum += lastPrime\n                else\n                \
    \    sum -= lastPrime\n                lastPrimeIsPrime = false\n            \
    \    lastPrime = elem\n                isPrimeIteration = 0\n                isPrime\
    \ = 1\n                listIsPrimeIteration = 0\n                listIsPrime =\
    \ false\n                listPrimeIteration = 0\n                listPrime = 1\n\
    \                listPrimeIsPrime = false\n            } else\n            if\
    \ (!lastPrimeIsPrime && (primes.dequeue() == elem)) {\n                lastPrimeIsPrime\
    \ = true\n                lastPrime = elem\n                isPrimeIteration =\
    \ 0\n                isPrime = 1\n                listIsPrimeIteration = 0\n \
    \               listIsPrime = false\n                listPrimeIteration = 0\n\
    \                listPrime = 1\n                listPrimeIsPrime = false\n   \
    \         } else\n            if (lastPrimeIsPrime && (primes.dequeue() == elem))\
    \ {\n                lastPrimeIsPrime = false\n                lastPrime = elem\n\
    \                is", "        val m = 2\n        val n = lst.length\n       \
    \ def findPrime(i : Int) : List[Long] = if (lst(i) <= 0) List() else if (lst(i)\
    \ % 2 == 0) findPrime(i-1) else findPrime(i-1) + List(lst(i))\n        def findSum(i\
    \ : Int) : Long = if (lst(i) <= 0) 0l else lst(i).toLong + findSum(i+1)\n    \
    \    def loop(i:Int) {\n            if (i == n) return findSum(i)\n          \
    \  val curr = findPrime(i)\n            if (curr.nonEmpty) {\n               \
    \ if (curr.head <= m) loop(i + (curr.head - n))\n                else if (curr.head\
    \ > m) loop(i + (m - curr.head))\n                else loop(i + (m - curr.head)\
    \ + curr.head)\n            }\n            else loop(i + (m - n))\n        }\n\
    \        loop(0)", "        val primes = mutable.Set[Long]()\n        val primesSum\
    \ = mutable.Set[Long]()\n        val sum = 0\n        for (n in lst) {\n     \
    \       if (primes.contains(n)) {\n                primesSum += n\n          \
    \  }\n            else {\n                sum += n\n                primes +=\
    \ n\n            }\n        }\n        primesSum.headOption.getOrElse(0l)", " \
    \       val nums = lst.sorted\n        val numsLen = nums.size\n        val maxNum\
    \ = nums(numsLen - 1)\n\n        val primes = nums.map(_ + 1)\n        val isPrime\
    \ = primes.map(x => nums.dropWhile(y => x < y).forall(y => y == x)).filter(x =>\
    \ x == true)\n\n        if (isPrime.size == 1)\n            isPrime.head\n   \
    \     else {\n            var maxPrime : Option[Long] = None\n            isPrime.foreach\
    \ { p =>\n                if (maxPrime == None) {\n                    maxPrime\
    \ = p\n                } else {\n                    val maxIsPrime = maxPrime\
    \ + 1\n                    if (maxIsPrime > p)\n                        maxPrime\
    \ = p\n                }\n            }\n            val primesLen = primes.size\n\
    \            if (primesLen > maxNum / 2)\n                skjkasdkd(lst.tail.filter(x\
    \ => !maxPrime.contains(x)))\n            else\n                maxPrime.get\n\
    \        }", "        val primes = lst.filter(x => isPrime(x)).map(x => x * x)\n\
    \        val maxPrime = primes.max\n        val maxPrimeDigit = maxPrime % 10\n\
    \        val maxDigit = maxPrime / 10\n        val sumOfDigits = maxDigit.map(x\
    \ => x.toLong).sum\n        return sumOfDigits + maxPrimeDigit", "        val\
    \ lst2 = lst.sortWith(_ < _)\n        // var max = lst2.last\n        // var sum\
    \ = 0\n        // for (i <- 0 until lst2.size) {\n        //     sum += lst2(i)\n\
    \        // }\n        // return sum\n        // var max = lst2.last\n       \
    \ // var sum = 0\n        // var i = 0\n        // var k = 0\n        // while(i\
    \ < lst2.size) {\n        //     k += 1\n        //     for(j <- i until lst2.size)\
    \ {\n        //         if(k % j == 0 && lst2(i) < lst2(j)) {\n        //    \
    \         max = lst2(i)\n        //             sum = j\n        //         }\n\
    \        //     }\n        //     i += 1\n        // }\n        // return sum\n\
    \        var max = lst2.last\n        var sum = 0\n        var i = 0\n       \
    \ var k = 0\n        while(i < lst2.size) {\n            k += 1\n            for(j\
    \ <- i until lst2.size) {\n                if(k % j == 0 && lst2(i) < lst2(j))\
    \ {\n                    max = lst2(i)\n                    sum = j\n        \
    \        }\n            }\n            i += 1\n        }\n        return sum",
  "        val primes = lst.filter( _ > 0 ).map( (x) => BigInt(x) )\n        val p\
    \ = primes.sortWith( _ > _ )\n        val max = p(0)\n        val maxIndex = (p\
    \ indexWhere( _ == max))\n        val maxSum = BigInt(lst(maxIndex))\n       \
    \ val p1 = (p.filter( _ > max)).size\n        val p2 = p1 - (p.size - maxIndex)\n\
    \        val p3 = p2 + (p.size - maxIndex) \n        val p4 = p3 - maxIndex\n\
    \        val p5 = maxSum - max\n        val p6 = p5 - (p4 -1)\n        val p7\
    \ = p6 - (p4 -1) \n        val p8 = p7 - (p4 -1) \n        val p9 = p8 - (p4 -1)\
    \ \n        val p10 = p9 - (p4 -1) \n        val p11 = p10 - (p4 -1) \n      \
    \  val p12 = p11 - (p4 -1) \n        val p13 = p12 - (p4 -1) \n        val p14\
    \ = p13 - (p4 -1) \n        val p15 = p14 - (p4 -1) \n        val p16 = p15 -\
    \ (p4 -1) \n        val p17 = p16 - (p4 -1) \n        val p18 = p17 - (p4 -1)\
    \ \n        val p19 = p18 - (p4 -1) \n        val p20 = p19 - (p4 -1) \n     \
    \   val p21 = p20 - (p4 -1) \n        val p22 = p21 - (p4 -1) \n        val p23\
    \ = p22 - (p4 -1) \n        val p24 = p23 - (p4 -1) \n        val p25 = p24 -\
    \ (p4 -1) \n        val p26 = p25 - (p4 -1) \n        val p27 = p26 - (p4 -1)\
    \ \n        val p28 = p27 - (p4 -1) \n        val p29 = p28 - (p4 -1) \n     \
    \   val p30 = p29 - (p4 -1) \n        val p31 = p30 - (p4 -1) \n        val p32\
    \ = p31 - (p4 -1) \n        val p33 = p32 - (p4 -1) \n        val p34 = p33 -\
    \ (p4 -1) \n        val p35 = p34 - (p4 -1) \n        val p36 = p35 - (p4 -1)\
    \ \n        val p37 = p36 - (p4 -1) \n        val p38 = p37 - (p4 -1) \n     \
    \   val p39 = p38 - (p4 -1) \n        val p40 = p39 - (p4 -1) \n        val p",
  "      val max = 0L\n      var prime = 0L\n      var sum = 0L\n      \n      primeCheck(prime,\
    \ sum, lst) \n      prime + sum", "        val max = 0\n        val l = []\n \
    \       for(n <- lst) {\n            l.append(n.toInt)\n        }\n        lst.foreach(n\
    \ => {\n            val flag = true\n            for(m <- 1 until l.length) {\n\
    \                if (l(m) == n)\n                    flag = false\n          \
    \  }\n            if (flag)\n                max += n.toInt\n        })\n    \
    \    return max", "        if (lst.length == 0)\n            return 0\n      \
    \  var max = lst(0)\n        var primes = mutable.PriorityQueue[Long]()\n    \
    \    var maxCount = 0\n        for (x <- lst) {\n            val isPrime = true\n\
    \            primes.offer(x)\n            for (prime <- primes) {\n          \
    \      if (x % prime == 0) {\n                    isPrime = false\n          \
    \          break\n                }\n            }\n            if (isPrime) {\n\
    \                max = Math.max(max, x)\n                maxCount = if (maxCount\
    \ == 0) 1 else maxCount + 1\n            }\n        }\n        maxCount + max",
  "        // For this problem, let's start from the beginning.\n        val map =\
    \ new mutable.HashMap[Long, Long]()\n        var max = 0l\n        var index =\
    \ 0\n        for (i <- lst) {\n            if (map.contains(i)) {\n          \
    \      max += i\n            }\n            else {\n                index += 1\n\
    \                max += map.get(index - 1).asInstanceOf[Long]\n              \
    \  map.put(index, i)\n            }\n        }\n\n        max", "        var l\
    \ = ListBuffer(lst)\n        val maxPrime = l.toList match {\n            case\
    \ Nil    => 0\n            case head :: tail => {\n                val list =\
    \ new ListBuffer[Long](head)\n                maxPrime = 0\n                list\
    \ match {\n                    case head :: tail => {\n                      \
    \  val isPrime = prime >= tail.toList\n                        isPrime match {\n\
    \                            case true => {\n                                var\
    \ sum = 0\n                                for (i <- head.until(tail)) {\n   \
    \                                 sum += i\n                                }\n\
    \                                if (sum > maxPrime) {\n                     \
    \               maxPrime = sum\n                                }\n          \
    \                  }\n                            case false => {\n          \
    \                      maxPrime = prime + head + (tail -  head).toList\n     \
    \                       }\n                        }\n                       \
    \ list += head :: tail\n                        skjkasdkd(list.toList)\n     \
    \               }\n                    case Nil => maxPrime\n                }\n\
    \            }\n        }\n        maxPrime", "        val maxPrime = lst.foldLeft(0)(_\
    \ + _ getBiggest 2)\n        val primes = lst.filter(x => x % maxPrime == 0)\n\
    \        primes.sum.toLong", "        val numbers = lst.toStream\n        val\
    \ largest = numbers.max(_.toInt)\n        val result = largest.toString.toInt\n\
    \        if (result % 2 != 0) result - 2\n        else result", "        // Find\
    \ a prime number smaller than the maximum element\n        var largestPrime =\
    \ lst.max\n        var primeFactors = Set[Long]()\n\n        for(prime <- 2 to\
    \ largestPrime) {\n            val factorsRemaining = prime :: primeFactors\n\
    \            if(factorsRemaining.isEmpty) largestPrime = prime\n            else\
    \ {\n                // For each prime factor we find its multiples, add them\
    \ all up then remove them\n                var sumOfFactors = prime\n        \
    \        for(factor <- factorsRemaining) {\n                    sumOfFactors =\
    \ sumOfFactors * factor\n                    factorsRemaining = factorsRemaining.filter(_\
    \ % factor == 0)\n                }\n                primeFactors = primeFactors\
    \ + sumOfFactors\n            }\n        }\n        // Remove the smallest prime\
    \ factor from largest prime factors\n        primeFactors = primeFactors.filter(_\
    \ % largestPrime == 0)\n        // Add all the digits of largest prime to sum\
    \ them\n        largestPrime ++= primeFactors.toList.map(_.toString.toLong)\n\
    \        // Return the sum of the digits\n        primeFactors.toList.map(_.toString.toLong).reduce((_\
    \ + _))", "        // Sieve of Eratosthenes -- http://www.geeksforgeeks.org/sieve-of-eratosthenes/\n\
    \        val s = lst.filter { x => x % 2 == 0 }.filter { x => x % 3 == 0 }.filter\
    \ { x => x % 5 == 0 }.filter { x => x % 7 == 0 }.filter { x => x % 11 == 0 }.filter\
    \ { x => x % 13 == 0 }.filter { x => x % 17 == 0 }.filter { x => x % 19 == 0 }.filter\
    \ { x => x % 23 == 0 }.filter { x => x % 29 == 0 }.filter { x => x % 31 == 0 }.filter\
    \ { x => x % 37 == 0 }.filter { x => x % 41 == 0 }.filter { x => x % 43 == 0 }.filter\
    \ { x => x % 47 == 0 }.filter { x => x % 49 == 0 }.filter { x => x % 53 == 0 }.filter\
    \ { x => x % 59 == 0 }.filter { x => x % 61 == 0 }.filter { x => x % 67 == 0 }.filter\
    \ { x => x % 71 == 0 }.filter { x => x % 73 == 0 }.filter { x => x % 79 == 0 }.filter\
    \ { x => x % 83 == 0 }.filter { x => x % 89 == 0 }.filter { x => x % 97 == 0 }.filter\
    \ { x => x % 103 == 0 }.filter { x => x % 109 == 0 }.filter { x => x % 113 ==\
    \ 0 }.filter { x => x % 121 == 0 }.filter { x => x % 127 == 0 }.filter { x =>\
    \ x % 129 == 0 }.filter { x => x % 133 == 0 }.filter { x => x % 139 == 0 }.filter\
    \ { x => x % 143 == 0 }.filter { x => x % 147 == 0 }.filter { x => x % 151 ==\
    \ 0 }.filter { x => x % 157 == 0 }.filter { x => x % 161 == 0 }.filter { x =>\
    \ x % 165 == 0 }.filter { x => x % 169 == 0 }.filter { x => x % 173 == 0 }.filter\
    \ { x => x % 177 == 0 }.filter { x => x % 181 == 0 }.filter { x => x % 185 ==\
    \ 0 }.filter { x => x % 189 == 0 }.filter { x => x % 193 == 0 }.filter { x =>\
    \ x % 197 == 0 }.filter ", "        val list = lst.map(x => (x + x)).toList\n\
    \        val isPrime = list.filter(_ % 2 == 0).filter(_ % 3 == 0).map(_ > 0)\n\
    \        var prime = 0l\n        var result = 0l\n        if(isPrime.isEmpty)\
    \ {\n            result = lst.filter(x => x % 2 == 0).filter(x => x % 3 == 0).sum\n\
    \            return result\n        }\n        prime = list.find(_ > 0).map(_\
    \ + 1).map(x => (x + x) / 2)\n        while(prime != 0) {\n            val n =\
    \ prime % 2\n            prime = prime / 2\n            if(isPrime(n)) {\n   \
    \             result = result + n\n                list = list - n\n         \
    \   }\n        }\n        return result", "        val result = new mutable.LinkedList[Long]()\n\
    \        var largestPrimeValue = 0l\n        for (el <- lst.iterator) {\n    \
    \        if (el > largestPrimeValue) {\n                largestPrimeValue = el\n\
    \            }\n        }\n        for (el <- lst.iterator) {\n            if\
    \ (el % largestPrimeValue == 0) {\n                result.addLast(el)\n      \
    \      }\n        }\n        val sum = result.sum()\n        if (sum > largestPrimeValue)\
    \ {\n            largestPrimeValue = sum\n        }\n        largestPrimeValue",
  "        val n = lst.size\n        val max = lst(0)\n        for (x <- 1 to n) \n\
    \        { \n            if (lst(x) > (max * 2) && lst(x) <= max) \n         \
    \   { \n                max = lst(x) \n            } \n        } \n        max.toString.toLong",
  "        val s = lst.map (x => x % 10).filter (x => x != 0).sort\n        val primes\
    \ = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n        val k = lst.size + 1\n      \
    \  val result = 0\n        for (i <- primes until k) {\n            val isPrime\
    \ = i match {\n                case 0 => lst.forall {x => x > i && x <= k}\n \
    \               case _ => lst.forall {x => x > i && x <= k && (lst contains x)\
    \ && x > s && x < k}\n            }\n            if (isPrime) {\n            \
    \    result += s(i)\n            }\n        }\n        result", "        var max\
    \ = -1\n        var ans = 0\n        var primes = primeList\n        primes.toList.foreach(primeList.remove)\n\
    \        for(i <- primes.toList) {\n            val prime = lst.filter(_ % i ==\
    \ 0).sum\n            if (prime > max) {\n                max = prime\n      \
    \          ans = prime % 10\n            }\n        }\n        ans", "       \
    \ def isPrime(n: Long) : Boolean = {\n            var j : Int = 0\n          \
    \  var isPrime : Boolean = true\n            var i : Int = 0\n            var\
    \ sum : Long = 0\n            while (i < Math.sqrt(n)) {\n                if (n\
    \ % i == 0){\n                    isPrime = false\n                }\n       \
    \         i += 1\n            }\n            if (isPrime){\n                while\
    \ (j < (int)(sqrt(n).toInt)){\n                    if (n % j == 0){\n        \
    \                isPrime = false\n                    }\n                    j\
    \ += 1\n                }\n            }\n            sum = 0\n            if\
    \ (isPrime){\n                while (n != 1l) {\n                    if (n % i\
    \ == 0){\n                        sum = 0\n                    }\n           \
    \         sum += 1\n                    n /= i\n                    i += 1\n \
    \               }\n            }\n            sum\n        }\n        val n =\
    \ lst.head\n        val max = 0l\n        var max = n\n        var i = 2\n   \
    \     while(i < lst.size) {\n            if (isPrime(lst(i))) {\n            \
    \    max = lst(i)\n                i += 1\n            }\n            else {\n\
    \                max = lst(i)\n                i += 1\n            }\n       \
    \ }\n        max + max * 10", "        val dic = mutable.Map.empty[Long, Long]\n\
    \        var sum = 0\n        for (i<- 0 until lst.size) {\n            val d\
    \ = lst.size - i\n            var p = i\n            val a = i\n            while\
    \ (a < d) {\n                val b = a + 1\n                if (b > d) {\n   \
    \                 val k = a + (d - b)\n                    if (k > lst.size) {\n\
    \                        p = lst.size\n                        a += k\n      \
    \                  b = d\n                    } else {\n                     \
    \   p += k\n                        b++\n                    }\n             \
    \   } else {\n                    val k = a + (b - d)\n                    if\
    \ (k > lst.size) {\n                        p += k\n                        a\
    \ += k\n                        b = d\n                    } else {\n        \
    \                p += k\n                        b++\n                    }\n\
    \                }\n                val k = a + (d - b)\n                dic +=\
    \ ((b, a) -> k)\n                a = b\n            }\n            sum += dic(i)\
    \ \n        }\n        dic.maxBy(_._2)(0) + sum", "        val primes = primesOfThree(lst.takeWhile(_\
    \ > 0))\n        val maxPrime = primes.takeWhile(_ < lst.last).max\n        lst.take(maxPrime\
    \ - primes.takeWhile(_ < maxPrime).length).sum", "        val list = lst.map(x\
    \ => x.toString.toLong).toList\n        val primes = PrimeUtil.getPrimes(list)\n\
    \        val maxIndex = primes.toList.maxIndex\n        val prime = primes(maxIndex)\n\
    \        val num = list.filter(_ < prime).toList\n        val sum = num.sum.toLong\n\
    \        sum", "        val primes = mutable.ArrayBuffer.empty[Long]\n       \
    \ for (x <- lst.min){\n            primes +=\n                if(x == 0 || x ==\
    \ 1l) x else \n                for (y <- primes filter { p => p.isPrime && p !=\
    \ x } if !(x%p)) x \n        }\n        primes.reduceRight(_ + _)", "        val\
    \ prime = lst.iterator.filter(_ > 2).find(_.isPrime).map(_ % 10).sum\n       \
    \ val result = lst.iterator.map(_ % 10).reduce(_ + _)\n        result+prime",
  "        var sum : Long = 0l\n        var largest = 0l\n        var largestIndex\
    \ : Int = 0\n        var isPrime : Boolean = false\n        var isPrime2 : Boolean\
    \ = false\n        var isPrime3 : Boolean = false\n        for (x <- lst.sort)\
    \ {\n            sum += x.toInt\n            if (sum > largest) {\n          \
    \      largest = sum\n                largestIndex = x\n            }\n      \
    \  }\n        val primeList = mutable.ListBuffer(lst.filter { x => isPrime(x)\
    \ })\n        for (i <- primeList.indices) {\n            val prime = primeList(i)\n\
    \            if (largestIndex == prime) {\n                isPrime = true\n  \
    \          } else {\n                isPrime = false\n                break\n\
    \            }\n        }\n        val prime2 = primeList.filter { x => isPrime2(x)\
    \ }\n        for (i <- prime2.indices) {\n            val prime = prime2(i)\n\
    \            if (largestIndex == prime) {\n                isPrime2 = true\n \
    \           } else {\n                isPrime2 = false\n                break\n\
    \            }\n        }\n        val prime3 = prime2.filter { x => isPrime3(x)\
    \ }\n        for (i <- prime3.indices) {\n            val prime = prime3(i)\n\
    \            if (largestIndex == prime) {\n                isPrime3 = true\n \
    \           } else {\n                isPrime3 = false\n                break\n\
    \            }\n        }\n        if (isPrime && isPrime2 && isPrime3) {\n  \
    \          sum += largestIndex.toInt\n        }\n        if (sum == largest) {\n\
    \            sum\n        } else {\n            largest\n        }", "       \
    \ val primes = Primes.primes\n\n        var largest_prime = 0\n        var sum_of_digits\
    \ = 0\n\n        // Loop through all the numbers we are given\n        lst.foreach{\
    \ number =>\n            sum_of_digits = 0\n            // Loop through all the\
    \ primes we found\n            primes.foreach{ prime =>\n                // If\
    \ we found a prime that is higher than the number we are checking\n          \
    \      if( number % prime == 0 ) {\n                    // Increment the sum_of_digits\
    \ and the current_number\n                    sum_of_digits += 1\n           \
    \         // If the new number is larger than the one we found so far\n      \
    \              if( number > largest_prime ) {\n                        // Update\
    \ the largest_prime\n                        largest_prime = number\n        \
    \            }\n                }\n            }\n        }\n\n        // Return\
    \ largest_prime and sum_of_digits\n        largest_prime + sum_of_digits", " \
    \       var primeNum = 0\n        var maxNum = 0\n        var maxNumSum = 0\n\
    \        var primeFactors = List[Long]()\n        var primeFactorsSum = 0\n  \
    \      var primeFactorsSumWithMax = 0\n        var lastMax = 0\n        var lastSum\
    \ = 0\n        var lastSumWithMax = 0\n        val nums = lst.filter(_ > 1).map(_\
    \ % 2).toList\n        var sum : Long = 0\n        for (i <- 0 until nums.size)\
    \ {\n            val num = nums(i)\n            if (num == 1) {\n            \
    \    lastMax = num\n                lastSum = sum\n                lastSumWithMax\
    \ = sumWithMax\n                primeFactors = List[Long]()\n                primeFactorsSum\
    \ = 0\n                primeFactorsSumWithMax = 0\n            } else if (primeFactorsSum\
    \ + num > primeFactorsSumWithMax) {\n                primeFactorsSum += num\n\
    \                primeFactorsSumWithMax = primeFactorsSum\n                primeFactors\
    \ = List(num)\n            } else if (primeFactorsSum + num == primeFactorsSumWithMax)\
    \ {\n                primeFactors ::= num\n            }\n            sumWithMax\
    \ += num * primeFactorsSumWithMax\n            sum += num * primeFactorsSum\n\
    \        }\n\n        if (sumWithMax < primeFactorsSumWithMax) {\n           \
    \ return sumWithMax\n        } else {\n            return sum\n        }", " \
    \       val primes = lst.filter(_ > 0).map(i => checkPrime(i)).toList\n      \
    \  val maxPrime = primes.map(x => x).max\n        (maxPrime / 10).sum", "    \
    \    val lst2 = lst.map(x => x / Math.pow(2, x).toInt).toList\n        val lst3\
    \ = lst2.sort\n        val primes = primesUntil(lst3.last)\n        val lists\
    \ = primes.map(lst3::_).toList.sort\n        val result = lists.foldLeft(0)(_+_)\n\
    \        result + lst3.last.asInstanceOf[Long]", "        if (lst.isEmpty)\n \
    \           return 0\n        var max = 0l\n        var sum = 0l\n        var\
    \ maxIndex = -1l\n        for (i <- lst) {\n            val sumOfDigits = (i.toLong\
    \ % 10) + sum\n            if (sumOfDigits > max) {\n                max = sumOfDigits\n\
    \                maxIndex = i\n            }\n            sum += i.toLong % 10\n\
    \        }\n        if (maxIndex == 0)\n            return 0\n        if (maxIndex\
    \ > 0)\n            sum += maxIndex.toLong % 10\n        return sum", "      \
    \  val primes = List(3l)(7l)(11l)(13l)(17l)(19l)(23l)(29l)(31l)(37l)(41l)(43l)(47l)(53l)(59l)(61l)(67l)(71l)(73l)(79l)(83l)(89l)(97l)\n\
    \        var largestPrime = primes.last\n        var sum = 0\n        for (i <-\
    \ 0 until lst.size) {\n            val p = lst(i)\n            val test = largestPrime.filter\
    \ { f =>\n                val d = f / p\n                if (d <= p / d && p %\
    \ d == 0) true\n                else false\n            }\n            val test2\
    \ = largestPrime.filter { f =>\n                val d = f % p\n              \
    \  if (d <= p / d && p % d == 0) true\n                else false\n          \
    \  }\n            val max = (test.toSet ++ test2.toSet).max\n            if (max\
    \ == p) {\n                sum += p\n            }\n            if (max > p) {\n\
    \                largestPrime = test\n            }\n            if (max == p)\
    \ {\n                sum += p\n            }\n        }\n        sum", "     \
    \   // write your logic here\n        val max = lst.max\n        if(max > 10){\n\
    \            val sum : Long = 0\n            val rem = lst.filter{_ <= max}.map(_\
    \ % max)\n            val rem2 = rem.filter{_ > 0}\n            for{\n       \
    \         n <- rem2.reverse\n                i <- 0 until rem2.length\n      \
    \          j <- 0 until rem2.length\n                if ((n+rem(i) + rem(j)) %\
    \ max == 0) sum += 1\n            } yield sum\n        } else {\n            for{\n\
    \                n <- lst\n                if ((n+1) % max == 0) yield n+1\n \
    \           } yield -1\n        }", "        val max = lst.max\n        val max2\
    \ = lst.filter(x => x == max).length\n        (max % max2).toLong", "        var\
    \ max = 0l\n        var sum = 0l\n        var sum2 = 0l\n        var isPrime =\
    \ true\n        for(x <- lst) {\n            sum ++= x\n            sum2 += x*x\n\
    \            if(isPrime) {\n                for(i <- 2 to math.ceil(math.sqrt(sum2)))\
    \ {\n                    if(sum2 % i == 0) {\n                        sum2 /=\
    \ i\n                        isPrime = false\n                        break\n\
    \                    }\n                }\n            }\n            if(!isPrime\
    \ || sum2 > sum) {\n                max = sum2\n                sum2 = 0l\n  \
    \              sum = 0l\n                isPrime = true\n            } else {\n\
    \                sum2 /= x\n                isPrime = false\n            }\n \
    \       }\n        if(sum2 > sum) {\n            max = sum2\n        }\n     \
    \   sum2 = 0l\n        sum = 0l\n        isPrime = true\n        for(x <- lst)\
    \ {\n            sum ++= x\n            sum2 += x*x\n            if(isPrime) {\n\
    \                for(i <- 2 to math.ceil(math.sqrt(sum2))) {\n               \
    \     if(sum2 % i == 0) {\n                        sum2 /= i\n               \
    \         isPrime = false\n                        break\n                   \
    \ }\n                }\n            }\n            if(!isPrime || sum2 > sum)\
    \ {\n                max = sum2\n                sum2 = 0l\n                sum\
    \ = 0l\n                isPrime = true\n            } else {\n               \
    \ sum2 /= x\n                isPrime = false\n            }\n        }\n     \
    \   if(sum2 > sum) {\n            max = sum2\n        }\n        return max",
  "        lst match {\n            case Nil => 0\n            case a :: b :: _ =>\
    \ {\n                val d = lst.foldLeft(0L)(_ + a)\n                d % b ==\
    \ 0 match {\n                    case true => a\n                    case false\
    \ => skjkasdkd(b)\n                }\n            }\n        }", "        var\
    \ max_prime : Long = 0L\n        var sum = 0\n        lst.foreach { x =>\n   \
    \         if (x > max_prime){\n                max_prime = x\n            }\n\
    \        }\n        val prime_list = scala.collection.mutable.ListBuffer[Long]()\n\
    \        val max_prime_list = scala.collection.mutable.ListBuffer[Long]()\n  \
    \      var index = 0\n        var num = 0\n        var prime = 1\n        while\
    \ (prime_list != null && prime_list.length <= max_prime_list.length){\n      \
    \      prime = prime_list.last\n            while (prime <= max_prime && num <\
    \ 10){\n                num = (prime).asInstanceOf[Long]\n                if (num\
    \ % prime == 0 && prime_list.contains(num) == false){\n                    prime_list\
    \ += num\n                    index += 1\n                }\n                prime\
    \ += 1\n            }\n            if (index == 0){\n                break\n \
    \           }\n        }\n        prime_list.foreach {\n            x =>\n   \
    \         if (max_prime_list != null && max_prime_list.last == x){\n         \
    \       max_prime_list += x\n            }\n        }\n        max_prime_list.foreach\
    \ { x =>\n            sum += x.toString.toLong\n        }\n        sum", "   \
    \     // Your code here\n        var sum : Long = 0l\n        var largestPrime\
    \ = 0l\n        var current = 0l\n        var currentPrime = 0l\n        for(\
    \ i <- lst){\n            if( current < i ){\n                current = i\n  \
    \              currentPrime = true\n            }\n            if( i == largestPrime){\n\
    \                sum += (i / 10).floor.toLong\n            }\n            if(\
    \ ((i*i) / currentPrime) == largestPrime){\n                sum += (i%10).floor.toLong\n\
    \            }\n            if( i == largestPrime){\n                largestPrime\
    \ = i\n            }\n        }\n        sum", "        val primesMutex = new\
    \ mutable.HashMap[Long, Long]\n        val primes = lst.filter { case i => (i\
    \ * i).asInstanceOf[Long] < lst.size }\n\n        var sum = 0L\n        var max\
    \ = 0L\n        var max2 = Long.MinValue\n        var max3 = Long.MaxValue\n \
    \       val n = primes.size\n        primes.foreach { i =>\n            val prime\
    \ = primes.filter { case j => (j * j) == i }\n            if (prime.isEmpty)\n\
    \                return\n            if (i % 2 == 0)\n                return\n\
    \            if (i % 3 == 0)\n                return\n\n            val lprime\
    \ = primes.filter { case j => (j * j) == (i - 1) }\n            if (lprime.isEmpty)\n\
    \                return\n\n            val lprime2 = primes.filter { case j =>\
    \ (j * j) == (i - 2) }\n            if (lprime2.isEmpty)\n                return\n\
    \n            val lprime3 = primes.filter { case j => (j * j) == (i - 3) }\n \
    \           if (lprime3.isEmpty)\n                return\n\n            val lprime4\
    \ = primes.filter { case j => (j * j) == (i - 4) }\n            if (lprime4.isEmpty)\n\
    \                return\n\n            val lprime5 = primes.filter { case j =>\
    \ (j * j) == (i - 5) }\n            if (lprime5.isEmpty)\n                return\n\
    \n            val lprime6 = primes.filter { case j => (j * j) == (i - 6) }\n \
    \           if (lprime6.isEmpty)\n                return\n\n            val lprime7\
    \ = primes.filter { case j => (j * j) == (i - 7) }\n            if (lprime7.isEmpty)\n\
    \                return\n\n            val lprime8 = primes.filter { case j =>\
    \ (j * j) == (i - 8) }\n            if (lprime8.isEmpty)\n                return\n\
    \n            val lprime9 = primes.filter { case j => (j * j) == (i - 9) }\n \
    \           if (lprime9.isEmpty)\n                return\n\n            val lprime10\
    \ = primes.filter { case j => (j * j) == (i - 10) }\n            if (lprime10.isEmpty)\n\
    \                return\n\n            val lprime11 = primes.filter { case j =>\
    \ (j * j) == (i - 11) }\n            if (lprime11.isEmpty)\n                return\n\
    \n            val lprime12 = primes.filter { case j => (j * j) == (i - 12) }\n\
    \            if (lprime12.isEmpty)\n                return\n\n            val\
    \ lprime13 = primes.filter { case j => (j * j) == (i - 13) }\n            if (lprime13.isEmpty)\n\
    \                return\n\n            ", "        var a = lst.head\n        var\
    \ b = lst.last\n        var sum = 0\n        while (a != 0l) {\n            if\
    \ (a % 2l == 0l) {\n                sum = (sum + 2).toLong\n            }\n  \
    \          if (a % 3l == 0l) {\n                sum = (sum + 3).toLong\n     \
    \       }\n            if (a % 5l == 0l) {\n                sum = (sum + 5).toLong\n\
    \            }\n            a = (a.toLong / 2l).toLong\n        }\n        while\
    \ (a != 0l) {\n            if (a % 2l == 0l) {\n                sum = (sum + 2).toLong\n\
    \            }\n            if (a % 3l == 0l) {\n                sum = (sum +\
    \ 3).toLong\n            }\n            if (a % 5l == 0l) {\n                sum\
    \ = (sum + 5).toLong\n            }\n            a = (a.toLong / 3l).toLong\n\
    \        }\n        while (a != 0l) {\n            if (a % 2l == 0l) {\n     \
    \           sum = (sum + 2).toLong\n            }\n            if (a % 3l == 0l)\
    \ {\n                sum = (sum + 3).toLong\n            }\n            if (a\
    \ % 5l == 0l) {\n                sum = (sum + 5).toLong\n            }\n     \
    \       a = (a.toLong / 5l).toLong\n        }\n        while (a != 0l) {\n   \
    \         if (a % 2l == 0l) {\n                sum = (sum + 2).toLong\n      \
    \      }\n            if (a % 3l == 0l) {\n                sum = (sum + 3).toLong\n\
    \            }\n            if (a % 5l == 0l) {\n                sum = (sum +\
    \ 5).toLong\n            }\n            a = (a.toLong / 6l).toLong\n        }\n\
    \        while (a != 0l) {\n            if (a % 2l == 0l) {\n                sum\
    \ = (sum + 2).toLong\n            }\n            if (a % 3l == 0l) {\n       \
    \         sum = (sum + 3).toLong\n            }\n            if (a % 5l == 0l)\
    \ {\n                sum = (sum + 5).toLong\n            }\n            a = (a.toLong\
    \ / 7l).toLong\n        }\n        while (a != 0l) {\n            if (a % 2l ==\
    \ 0l) {\n                sum = (sum + 2).toLong\n            }\n            if\
    \ (a % 3l == 0l) {\n                sum = (sum + 3).toLong\n            }\n  \
    \          if (a % 5l == 0l) {\n                sum = (sum + 5).toLong\n     \
    \       }\n            a = (a.toLong / 8l).toLong\n        }\n        while (a\
    \ != 0l) {\n            if (a % 2l == 0l) {\n                sum = (sum + 2).toLong\n\
    \            }\n            if (a % ", "        var primes = mutable.ArrayBuffer.empty[Long]\n\
    \        var biggestPrime = 0l\n        var maxSum = 0\n        lst.foreach(x\
    \ => {\n            val isPrime = PrimeChecker.isPrime(x)\n            if(isPrime)\
    \ {\n                primes = primes :+ x\n            }\n        })\n\n     \
    \   val primeSet = new collection.mutable.Set[Long](primes)\n        primeSet.foreach(x\
    \ => {\n            val isPrime = PrimeChecker.isPrime(x)\n            if(isPrime)\
    \ {\n                biggestPrime = x\n            }\n        })\n        primeSet.foreach(x\
    \ => {\n            val isPrime = PrimeChecker.isPrime(x)\n            if(isPrime)\
    \ {\n                maxSum = x + maxSum\n            }\n        })\n        if(primes.isEmpty)\
    \ {\n            biggestPrime\n        } else {\n            maxSum\n        }",
  "        require(lst.nonEmpty)\n        val n1 = lst.head\n        val n2 = lst.last\n\
    \        val n = n1.toInt + n2.toInt\n        val sq = math.sqrt(n)\n        val\
    \ max = n2.toInt\n        val max2 = n1.toInt\n        val max3 = n1.toInt\n \
    \       val c = n2.toInt\n        val c2 = Math.min(c, n)\n        val c3 = Math.min(c,\
    \ n)\n        val r = n / c\n        var k = 0\n        val primes = mutable.BitSet(n\
    \ - 1)\n        val s = List(3l, 5l, 7l, 11l)\n        val s2 = List(3l, 5l, 7l,\
    \ 11l)\n        var p = 2\n        while ((p < max) && (primes(p - 1) == false))\
    \ {\n            if (p * p > max) {\n                max = p * p\n           \
    \     max2 = p\n                max3 = p\n            }\n            primes(p)\
    \ = true\n            k += 1\n            p += 1\n        }\n        while (k\
    \ <= r) {\n            if (k * k > max) {\n                max = k * k\n     \
    \           max2 = k\n                max3 = k\n            }\n            primes(p)\
    \ = true\n            k += 1\n            p += 1\n        }\n        val ln =\
    \ sqrt(max).toLong\n        val ln2 = sqrt(max2).toLong\n        val ln3 = sqrt(max3).toLong\n\
    \        val q = primes.toLong\n        val q2 = primes.toLong\n        val q3\
    \ = primes.toLong\n        val maxq = q * q\n        val maxq2 = q2 * q2\n   \
    \     val maxq3 = q3 * q3\n        val sq = sqrt(maxq)\n        val sq2 = sqrt(maxq2)\n\
    \        val sq3 = sqrt(maxq3)\n        val a = maxq - sq\n        val a2 = maxq2\
    \ - sq2\n        val a3 = maxq3 - sq3\n        val c = maxq - a\n        val c2\
    \ = maxq2 - a2\n        val c3 = maxq3 - a3\n        val sq = sqrt(n)\n      \
    \  val sq2 = sqrt(n)\n        val sq3 = sqrt(n)\n        val qp = q * p\n    \
    \    val qp2 = q2 * p\n        val qp3 = q3 * p\n        val q = sqrt(maxq)\n\
    \        val q2 = sqrt(maxq2)\n        val q3 = sqrt(maxq3)\n        var r = n\
    \ / maxq\n        val n = sq\n        val n2 = sq2\n        val n3 = sq3\n   \
    \     val ", "        val n = lst.size\n        val primes = mutable.ArrayBuffer.fill(n)(BigInt(2))\n\
    \        val sum = mutable.ArrayBuffer.empty[BigInt]\n        var i = 2\n    \
    \    for(p <- primes){\n            for(k <- 2 until n){\n                val\
    \ num = p * k\n                if(num < 2l || num > nl ){\n                  \
    \  continue\n                }\n                val digits = BigInt(lst.take(k))\
    \ * k.toInt\n                sum += digits\n                primes(k) = 0\n  \
    \              i = num\n                break\n            }\n        }\n    \
    \    sum.head", "        val primes = lst.filter(_ % 2 != 0)\n        var biggestPrime\
    \ = 0\n        var biggestSum = 0\n        val primeFactors = primes.map(x =>\
    \ primeFactorization(List(x)))\n        primes.map(x => primeFactors(x).foreach(factor\
    \ => biggestPrime = math.max(biggestPrime, factor)))\n        primes.map(x =>\
    \ primeFactors(x).foreach(factor => biggestSum = math.max(biggestSum, math.pow(x,\
    \ factor))))\n        biggestPrime", "        val prime = lst.filter(_ % 2 ==\
    \ 0).filter(_ % 3 == 0).filter(_ % 5 == 0).filter(_ % 7 == 0).map(_ * 7).sum\n\
    \        val digit = lst.filter(_ % 2 == 0).map(_ % 10).sum\n        (prime +\
    \ digit).abs", "        val set = mutable.Set[Long]()\n        var sum = 0\n \
    \       for(i <- 0 until lst.length){\n            if (lst.exists(x => x == i)){\n\
    \                set.add(i)\n            }\n        }\n        if(set.size ==\
    \ 1){\n            val prime = set.head\n            sum += prime % 10\n     \
    \   }else{\n            val prime = set.max\n            sum += prime % 10\n \
    \       }\n        return sum", "        require(lst.forall(_ % 2 == 0), \"All\
    \ numbers should be even\")\n        require(lst.size >= 2, \"The list should\
    \ have at least two elements\")\n        val n = lst.size\n        var largest\
    \ = 0\n        var largestPrime = 0\n        for(i <- 0 to n-1) yield {\n    \
    \        val primeCandidate = lst(i)\n            val divisor = primeCandidate\
    \ / primeCandidate\n            val isDivisibleBy3 = divisor % 3 == 0\n      \
    \      val isDivisibleBy5 = divisor % 5 == 0\n            val isDivisibleBy7 =\
    \ divisor % 7 == 0\n            val isDivisibleBy9 = divisor % 9 == 0\n      \
    \      if(isDivisibleBy3 && isDivisibleBy5 && isDivisibleBy7 && isDivisibleBy9){\n\
    \                largestPrime = primeCandidate\n                largest = primeCandidate\n\
    \            }\n            else if(primeCandidate > largestPrime){\n        \
    \        largestPrime = primeCandidate\n                largest = primeCandidate\n\
    \            }\n        }\n        largest + largestPrime", "        val ns =\
    \ lst.size\n        var sum : Long = 0\n\n        def isPrime(n: Long) : Boolean\
    \ = \n            (ns.toDouble * n <= ns) && (ns % n == 0)\n\n        def testPrime(n:\
    \ Long, i: Long, j: Long, m: Long) : Unit = {\n            if (isPrime(n)) {\n\
    \                if (i == m) sum += n.toInt\n                else if (j == m)\
    \ sum += n.toLong\n                else if (j > i) testPrime(n, i+1, j, m)\n \
    \               else if (i >  j) testPrime(n, i, j+1, m)\n            }\n    \
    \    }\n\n        (ns % 2 == 0).foreach(i => testPrime(ns.toLong, 0, 1, i))\n\
    \        sum", "        val primes = mutable.Queue[Long]()\n        val result\
    \ = mutable.Queue[Long]()\n        val max = -1L\n        for (i: Long <- lst.max\
    \ by -1l) {\n            // only add primes that are not already in the list\n\
    \            if (!primes.contains(i))\n                primes += i\n         \
    \   val max2 = i * i\n            for (j: Long <- primes.maxBy { _ * _ > max2\
    \ } by -1) {\n                // make sure we don't divide by the same prime twice\n\
    \                if (!primes.contains(j) && j % i != 0) {\n                  \
    \  result += (j * i).toLong\n                    primes += j\n               \
    \     if (primes.size == lst.size && result.max < max)\n                     \
    \   max = result.max\n                }\n            }\n        }\n        max\
    \ + 1l", "        if (lst.isEmpty) 0\n        else if (lst.head == 1) lst(0)\n\
    \        else if (lst.head == 2) lst(1) + 1\n        else if (lst.head % 2 ==\
    \ 0) if (lst.head % 3 == 0) lst.head - 3\n                                   \
    \     else lst.head / 2 + 1\n        else lst.head % 3 == 0 ? lst.head / 3 + 1\n\
    \                            : if (lst.head % 5 == 0) lst.head - 5\n         \
    \                           else lst.head / 5 + 1", "      var sum : Long = 0\n\
    \      var highestPrime : Long = 0\n\n      // The first element in the list is\
    \ the smallest one that needs to be found.\n      val firstElement = lst(0)\n\n\
    \      // Iterate through all elements in the list. Also iterate through the list\n\
    \      // from first element to largest prime number found.\n      for(i <- 1\
    \ to lst.last){\n        var sumOfDigitsOfPrime: Long = 0\n        for(p <- firstElement.until(highestPrime)){\n\
    \          val pow = math.pow(p, i)\n          val newPrime = math.min(highestPrime,\
    \ p)\n          val modPower = newPrime.mod(pow)\n          if(modPower == 0){\n\
    \            sumOfDigitsOfPrime += pow\n          }\n        }\n        sum +=\
    \ sumOfDigitsOfPrime\n      }\n\n      sum", "        var largest = 0l\n     \
    \   var digit = 0l\n        var prime = 0l\n        var sum = 0l\n        for(num\
    \ <- lst) {\n            if(num <= largest) {\n                largest = num\n\
    \            }\n            for(i <- 2 to (largest.toInt / 2)) {\n           \
    \     if(num % i == 0) {\n                    largest = i\n                  \
    \  prime = num\n                    sum += num.toLong / i\n                  \
    \  break\n                }\n            }\n        }\n        if(prime == 0)\
    \ {\n            return largest\n        }\n        else {\n            return\
    \ (sum + prime).toLong\n        }", "        val primes = List(2l) ++ (for(i<-lst.last;\
    \ i+<-List(2l); i+<-List(3l); i+<-List(5l); i+<-List(7l); i+<-List(11l); i+<-List(13l))\
    \ yield i).toList\n        val n = primes.find(_ > lst(0).toLong).orElse(primes.max)\n\
    \        val c = lst.foldLeft((nl.zeroLong, nl.zeroLong))((n1,n2) => if (n1==n2)\
    \ n1 else (n1.toLong + n2.toLong, n1))\n        val r = c._1\n        val d =\
    \ c._2\n        val t = c._2\n        val i = 2\n        val j = 1\n        val\
    \ isPrime = true\n        val isNewPrime = false\n        val isCandidate = false\n\
    \        val isPrimeSet = false\n        val isCandidateSet = false\n        val\
    \ isNewPrimeSet = false\n        val isPrimeSum = false\n        val isCandidateSum\
    \ = false\n        val isNewPrimeSum = false\n        val isPrimeProd = false\n\
    \        val isCandidateProd = false\n        val isNewPrimeProd = false\n   \
    \     val isPrimeDif = false\n        val isCandidateDif = false\n        val\
    \ isNewPrimeDif = false\n        val isPrimeNum = false\n        val isCandidateNum\
    \ = false\n        val isNewPrimeNum = false\n        var isCandidateMax = false\n\
    \        var isNewPrimeMax = false\n        var isCandidateMin = false\n     \
    \   var isNewPrimeMin = false\n        while (i < n) {\n            val c = lst.take(j)\n\
    \            if (isCandidateSet) {\n                val c = lst.take(j)\n    \
    \            if (isCandidateSet) {\n                    if (c.sum.compareTo(r)\
    \ < 0) {\n                        val c = lst.take(j)\n                      \
    \  if (c.sum.compareTo(r) < 0) {\n                            val c = lst.take(j)\n\
    \                            if (c.sum.compareTo(r) < 0) {\n                 \
    \               val c = lst.take(j)\n                                if (c.sum.compareTo(r)\
    \ < 0) {\n                                    isNewPrimeSet = false\n        \
    \                            isPrimeSet = false\n                            \
    \    }\n                            }\n                        }\n           \
    \         }\n                }\n            }\n            if (isNewPrimeSet)\
    \ {\n                if (c.sum.compareTo(r) < 0) {\n                    val c\
    \ = lst.take(j)\n                    if (c.sum.compare", "        var max = 0L\n\
    \        var sum = 0L\n        for(i <- 0 until lst.size) {\n            val a\
    \ = lst(i).toInt\n            val b = list.isEmpty\n            if(a != 0) {\n\
    \                val p = 2\n                var j = 0\n                val isPrime\
    \ = true\n                var k = 0\n                val list1 = mutable.ArrayBuffer(a)\n\
    \                while (isPrime && j < p) {\n                    val t = list1.last\n\
    \                    val m = list1.head\n                    if (t % m == 0) {\n\
    \                        k += 1\n                    }\n                    if\
    \ (k > 1) {\n                        isPrime = false\n                    }\n\
    \                    list1 += m\n                    j += 1\n                }\n\
    \                if (k > 1) {\n                    sum += a * list1.toList.length\n\
    \                }\n            }\n            if (b && (i == lst.size - 1 ||\
    \ sum < 0)) {\n                max = a\n                sum = sum + a\n      \
    \      }\n        }\n        sum", "        val sum: mutable.Long = mutable.Long(0)\n\
    \        val list: mutable.List[Long] = mutable.List(lst.head)\n        while\
    \ (list.nonEmpty) {\n            var isPrime = true\n            for (i <- list.tail)\
    \ {\n                if (i % list.head != 0) isPrime = false\n            }\n\
    \            if (isPrime) sum += list.head.toString.toLong\n            list.tail.clear()\n\
    \        }\n        sum", "        val primes = lst.map(x => new Prime(x)).filter(x\
    \ => x.isPrime)\n        val primeSum = primes.map(x => x.digitSum).reduce(_+_)\n\
    \        primeSum", "        val max: Long = lst.foldLeft[Long](0)(_ + _)\n  \
    \      val primes = prime :: lst.filterNot(_ % _ == 0).toList\n        lst.filter(p\
    \ => primes.contains(p))\n            .foldLeft[Long](0)((acc, x) => {\n     \
    \           val remainder = acc % x\n                if (remainder == 0) {\n \
    \                   x + 1\n                } else {\n                    acc\n\
    \                }\n            })", "        var max = -Infinity\n        var\
    \ max = -1\n        var prime = 0\n        var sum = 0\n        var count = 0\n\
    \        lst.foreach {\n        case x if x > 0 => {\n            prime += x\n\
    \            sum += x\n            count += 1\n        }\n        case x if x\
    \ == 0 => {\n            prime = 1\n            sum += x\n            count +=\
    \ 1\n        }\n        case x if prime == 1 && count != 1 => {\n            prime\
    \ += x\n            sum += x\n            count += 1\n        }\n        case\
    \ x if prime != 1 && count != 1 => {\n            prime += x\n            sum\
    \ += x\n            count += 1\n        }\n        case x if prime == 1 && count\
    \ == 1 => {\n            prime += x\n            sum += x\n            count =\
    \ 0\n        }\n        case x if prime != 1 && count == 1 => {\n            prime\
    \ += x\n            sum += x\n            count = 0\n        }\n        case x\
    \ if prime == 1 && count > 1 => {\n            prime += x\n            sum +=\
    \ x\n            count = 0\n        }\n        case x if prime != 1 && count >\
    \ 1 => {\n            prime += x\n            sum += x\n            count = 0\n\
    \        }\n        case x if prime == 1 && count < 2 => {\n            prime\
    \ += x\n            sum += x\n            count = 0\n        }\n        case x\
    \ if prime != 1 && count < 2 => {\n            prime += x\n            sum +=\
    \ x\n            count = 0\n        }\n        case x if prime == 1 && count >\
    \ 2 => {\n            prime += x\n            sum += x\n            count = 0\n\
    \        }\n        case x if prime != 1 && count > 2 => {\n            prime\
    \ += x\n            sum += x\n            count = 0\n        }\n        case x\
    \ if prime == 1 && count < 3 => {\n            prime += x\n            sum +=\
    \ x\n            count = 0\n        }\n        case x if prime != 1 && count <\
    \ 3 => {\n            prime += x\n            sum += x\n            count = 0\n\
    \        }\n        case x if prime == 1 && count > 3 => {\n            prime\
    \ += x\n            sum += x\n            count = 0\n        }\n        case x\
    \ if prime != 1 && count > 3 => {\n            prime += x\n            sum +=\
    \ x\n            count = 0\n        }\n        case x if prime == 1 && count <\
    \ 4 => {\n            prime += x\n            sum += x\n            count = 0\n\
    \        }\n        case x if prime != 1 && count < 4 => {\n            prime\
    \ += x\n            sum += x\n            count = 0\n        }\n        case x\
    \ if prime == 1 && count > 4 => {\n            prime += x\n            sum +=\
    \ x\n            count = 0\n        }\n        case x if prime != 1 && count >\
    \ 4 => {\n            prime += x\n            sum += x\n            count = 0",
  "        require(lst.forall(x => x > 0), \"List cannot contain negative numbers\"\
    )\n        val ls = lst.sortWith((x, y) => x < y)\n        var max = 1l\n    \
    \    val primes = ls.filter { x => x > 0 }\n        while (primes.nonEmpty) {\n\
    \            max = primes.reduce((a, b) => if (max < a || max < b) a else b)\n\
    \            primes = primes.filterNot { x => x % max }\n        }\n        primes.reduce((a,\
    \ b) => a + b).toLong", "        var lst_Prime : List[Long] = Nil\n        var\
    \ lst_Num : List[Long] = Nil\n        var lst_Sum : List[Long] = Nil\n       \
    \ var index : Int = 0\n        var numPrime : Int = 0\n        while(index < lst.size)\
    \ {\n            if(lst_Prime.nonEmpty && lst_Prime.last <= lst.get index) {\n\
    \                lst_Prime += lst.get index\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n\
    \                lst_Prime += lst_Prime.last\n                lst_Prime += lst_Prime.last\n",
  "        val n = lst.length\n        val dp = new Array[Long](31)\n        var maxSum\
    \ = 0L\n        var i : Int = 0\n        var j : Int = 0\n        var sum = 0L\n\
    \        while (i<n && j<31)\n        {\n            if (lst(i).toLong == j.toLong)\n\
    \            {\n                sum = (lst(i) - j*lst(i)).toLong\n           \
    \     maxSum = if (sum > maxSum) sum else maxSum\n                i = i + 1\n\
    \                j = 0\n            }\n            else if (lst(i).toLong == (j+1)%10)\n\
    \            {\n                j = (j+1)%10 + 1\n            }\n            else\n\
    \            {\n                j = (j+1)%10\n                i = i + 1\n    \
    \        }\n        }\n        if (j == 31)\n        {\n            maxSum = (lst(n\
    \ - 1).toLong + j*lst(n-1) - lst(n-1).toLong).toLong\n        }\n        maxSum",
  "      val (maxPrime: Long, maxSum: Long, maxSumList: Set[Long]) = lst.foldLeft((0l.toLong,\
    \ 0l.toLong, Set[Long](0))){\n        case ((maxPrime, maxSum, maxSumList), el)\
    \ =>\n          val newSum = if (isPrime(el)) el else 0l.toLong\n          (if\
    \ (newSum > maxSum) newSum, maxSum, maxSumList +: Set(newSum))\n      }\n\n  \
    \    (maxPrime, maxSum, maxSumList)", "        if (lst.length < 2) throw new RuntimeException(\"\
    Invalid input.\")\n        var max_prime_sum = 0\n        var max_prime = 0\n\
    \        var prime_count = 0\n        val primes = mutable.Queue[Long]()\n   \
    \     val digit_sums = mutable.Map[Long, Long]()\n        var digit_sum = 0\n\
    \        var max_digit_sum = 0\n        var is_prime_found = false\n        val\
    \ max_prime_sum_update = lst.foldLeft(0L) { (sum_prime, prime) => sum_prime +\
    \ prime.toLong * lst.count(_ == prime) }\n        primes.enqueue(prime)\n    \
    \    while (primes.nonEmpty) {\n            prime = primes.dequeue()\n       \
    \     is_prime_found = false\n            var prime_sum_prime = 0\n          \
    \  var digit_sum_prime = 0\n            var prime_prime = 1\n            prime_prime\
    \ = prime_prime * (prime / 2)\n            prime_prime = prime_prime + prime\n\
    \            digit_sum_prime = prime_prime / 10\n            prime_prime = prime_prime\
    \ % 10\n            prime_prime = prime_prime + 1\n            var digit_prime_prime\
    \ = 1\n            digit_prime_prime = digit_prime_prime * (digit_prime / 2)\n\
    \            digit_prime_prime = digit_prime_prime + digit_prime\n           \
    \ digit_sum_prime = digit_sum_prime + digit_prime_prime\n            digit_sum_prime\
    \ = digit_sum_prime / 10\n            digit_prime_prime = digit_sum_prime % 10\n\
    \            digit_prime_prime = digit_prime_prime + 1\n            digit_sum\
    \ = 0\n            digit_sum = 0\n            for (var j <- 0 to lst.count(_ ==\
    \ prime)) {\n                if (j == lst.count(_ == prime)) {\n             \
    \       digit_sum = 0\n                    digit_sum = 0\n                   \
    \ digit_sum = 0\n                    digit_sum = 0\n                    digit_sum\
    \ = 0\n                }\n                var digit_sum = 0\n                var\
    \ is_prime_found = false\n                for (var k <- 0 to lst.count(_ == prime))\
    \ {\n                    if (k == lst.count(_ == prime)) {\n                 \
    \       digit_sum = 0\n                        digit_sum = 0\n               \
    \         digit_sum = 0\n                        digit_sum = 0\n             \
    \           digit_sum = 0\n                    }\n                    var prime_prime\
    \ = 1\n                    prime_prime = prime_prime * (prime / 2)\n         \
    \           prime_prime = prime_prime + prime\n                    digit_sum_prime\
    \ = prime_prime / 10\n                    prime_prime = prime_prime % 10\n   \
    \                 prime_prime = prime_prime + 1\n                    var digit_prime_prime\
    \ = 1\n                    digit_prime_prime = digit_prime_prime * (digit_prime\
    \ / 2)", "        def sievePrimes(limit : Long) : List[Long] = {\n           \
    \ val primes = mutable.LinkedList[Long]()\n            var prime = 1\n       \
    \     while(primes.size < limit) {\n                if(prime % 2 == 0) {\n   \
    \                 primes += prime\n                }\n                else {\n\
    \                    val i = 2\n                    while(i * i <= prime) {\n\
    \                        prime += i\n                        i <<= 1\n       \
    \             }\n                    primes ++= prime\n                }\n   \
    \             prime += 2\n            }\n            primes\n        }\n     \
    \   def sieveNumbers(start : Long, limit : Long) : List[Long] = {\n          \
    \  var nums = mutable.ListBuffer[Long]()\n            var limit = limit\n    \
    \        var i = start\n            while(i < limit) {\n                i += 2\n\
    \                nums += i\n            }\n            nums\n        }\n     \
    \   var max = 0\n        sievePrimes(lst.size).filter(prime => prime < lst.size).foreach(prime\
    \ => {\n            val nums = sieveNumbers(prime, lst.size)\n            max\
    \ = Math.max(max, nums.sum)\n        })\n        max + lst.size", "        var\
    \ maxNum = lst.head._1\n        var maxNumDigit = 0\n        var sum = 0\n   \
    \     for( i <- lst ) {\n            val numDigit = i._1 % maxNum\n          \
    \  if( (maxNumDigit + numDigit) > maxNumDigit ) {\n                maxNum = i._1\n\
    \                maxNumDigit = numDigit\n            }\n            sum += numDigit\n\
    \        }\n        sum", "        val n = lst.head\n        val p = lst.tail.filter(_\
    \ % n != 0).max\n        val sum = p + lst.tail.filter(_ % p == 0).sum\n     \
    \   n", "        // sort list\n        val sorted = lst.sort\n        val largest\
    \ = sorted.last\n        val biggest = BigInt(largest)\n        val sum = 0\n\n\
    \        // find prime number\n        for(i <- sorted.indices) {\n          \
    \  if(i % 2 == 0) {\n                val isPrime = true\n                // find\
    \ next divisor\n                for(j <- i + 1 until largest) {\n            \
    \        if(biggest % j == 0) {\n                        isPrime = false\n   \
    \                     break\n                    }\n                }\n      \
    \          if(isPrime) {\n                    sum += BigInt(sorted.toString.charAt(i).asDigit)\n\
    \                    break\n                }\n            }\n        }\n\n  \
    \      sum", "        val primes = List(2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong,\
    \ 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong,\
    \ 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong,\
    \ 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong)\n\
    \        val primesLen = primes.size\n        val primesSet = primes.toSet\n \
    \       var biggestPrime = primes(0)\n        for (prime <- primes.tail) {\n \
    \           var sum = primesSet.filter(_ % prime == 0).size\n            if (biggestPrime\
    \ > prime) biggestPrime = prime\n            if (sum > sum) sum = sum\n      \
    \  }\n        sum", "        val primes = mutable.ListBuffer[(Long, Long)]()\n\
    \        var maxNum = lst.head\n        var maxPrime = 0l\n        var sum = 0l\n\
    \        // only check for prime numbers if they have no prime factors\n     \
    \   // otherwise we will end up with duplicates\n        for( x <- lst if lst.count(_\
    \ == x) == 0 ) {\n            var i = 0\n            while( (i + 1) < lst.count(_\
    \ == lst.take(i + 1).last) ){\n                i += 2\n            }\n       \
    \     if( maxNum % lst.take(i).last == 0 ) {\n                // only check numbers\
    \ that do not divide any number already checked\n                if( lst.count(_\
    \ % lst.take(i).last == 0) ){\n                    // if the last number we checked\
    \ was prime, we need to check for multiples of that prime number\n           \
    \         // only check numbers that do not divide any number already checked\n\
    \                    if( lst.count(_ % lst.take(i).last == 0) && (lst.count(_\
    \ % lst.take(i).last == 0) == (i / lst.take(i).last))) {\n                   \
    \     val nextNum = lst.take(i).last * lst.take(i).last\n                    \
    \    primes += ((maxNum, nextNum))\n                        val tmpMaxPrime =\
    \ lst.count(_ == nextNum)\n                        if( tmpMaxPrime > maxPrime\
    \ ) {\n                            maxNum = nextNum\n                        \
    \    maxPrime = tmpMaxPrime\n                            sum = sum + lst.take(i).last\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        (maxNum.toLong, sum.toLong)", "        val map = mutable.Map.empty[Long,\
    \ Boolean]\n        for(x<-lst){\n            map.get(x) match {\n           \
    \     case None  => map.put(x, true)\n                case Some(false) => map.put(x,\
    \ true)\n            }\n        }\n        val m = map.toMap\n        val m =\
    \ m.maxBy(_._2)\n        val m = m._1 // max prime number\n        val sum = m.toString.sum\n\
    \n        sum.toLong", "        val primes = Primes.primesList.map{ _._1 }.toSet\n\
    \        def nextPrime(x: Long, lst: List[Long], acc: Long): Long = {\n      \
    \      val isPrime = lst.forall { _ =>\n                val test = x / _\n   \
    \             val remainder = x % _\n                (test != remainder) && (primes.contains(test))\
    \ || (test < 2) && (test % 2) == 0\n            }\n            if (isPrime) {\n\
    \                acc + 1\n            } else {\n                acc + 1\n    \
    \            nextPrime(x + 2, lst, acc)\n            }\n        }\n        val\
    \ acc = lst.head\n        nextPrime(acc, lst, acc)", "        val primes = lst.groupBy(i\
    \ => i % 2l.toLong)\n        val max = primes.maxBy(_._2)._1\n        val sum\
    \ = primes.map { case (k, v) =>\n            val d = k.toString.toLong - max\n\
    \            if (d > 9) return d\n            else return d % 10l.toLong\n   \
    \     }.sum\n        sum", "        val primes = mutable.ListBuffer[Long]()\n\
    \        for (i <- 0 until lst.size) {\n            val prime = lst.filter(_ %\
    \ i == 0).max\n            if (primes.contains(prime)) {\n                // If\
    \ we've already seen a prime, it's greater than this one\n                lst.filter(_\
    \ % prime == 0).size match {\n                    case 0 => primes += prime ::\
    \ Nil\n                    case 1 => primes += prime\n                    case\
    \ _ => primes += prime :: primes\n                }\n            } else {\n  \
    \              // Otherwise, just add it to the list\n                primes +=\
    \ prime\n            }\n        }\n        val primesLength = primes.size\n  \
    \      if (primesLength == 1) primes.head else primes.sum.toLong", "        val\
    \ set = mutable.HashSet[Long]()\n        val largest = lst.max(l(_))\n       \
    \ val primes = lst.filter(l(_ % _ == 0)).toList\n        for (prime <- primes)\
    \ {\n            val digits = prime % 10\n            if (set contains digits)\
    \ {\n                continue\n            }\n            set += digits\n    \
    \        val remainder = prime / 10\n            if (remainder == 0) {\n     \
    \           largest.asInstanceOf[Long] + digits.asInstanceOf[Long]\n         \
    \   }\n        }\n        largest.asInstanceOf[Long]", "        // Write your\
    \ answer here\n        \n        def lPrimes(lst: List[Long], primes: mutable.Set[Long])\
    \ : List[Long] = {\n            // find primes until it reaches its limit\n  \
    \          \n            if(lst.size <= 1)\n                return lst // return\
    \ lst if it is a single long\n            \n            val newPrimes = primes\n\
    \            newPrimes ++= lst // add the new element to the primes\n        \
    \    newPrimes diff lst.tail filter (x => x % lst.head == 0) foreach newPrimes\
    \ // filter out multiples of prime elements\n            \n            // recurse\
    \ until all elements have been processed to return list\n            lPrimes(lst.tail,\
    \ newPrimes)\n        }\n        \n        // base case is list with 1 element\n\
    \        if(lst.size <= 1)\n            return lst.head // return the head if\
    \ it is a single long\n        \n        val primes = mutable.Set(0l.toLong) //\
    \ set primes\n        lPrimes(lst, primes) // find prime elements\n        \n\
    \        // add prime elements\n        lst.tail.foldLeft(0l.toLong){\n      \
    \      case (acc, n) => acc + n.toLong\n        }", "        var maxPrime : Long\
    \ = -1\n        var maxSum : Long = 0\n        var primes : List[Long] = List(3l)\n\
    \        var sum : Long = 0\n\n        while(primes.size > 0) {\n            val\
    \ prime = primes.head\n            primes ::= primes.tail\n            sum +=\
    \ prime.toString.toLong\n\n            if(prime == maxPrime) {\n             \
    \   maxSum += sum\n                primes = primes.tail\n            } else {\n\
    \                maxPrime = prime\n                sum = 0\n                primes\
    \ = primes.tail\n            }\n        }\n\n        return maxSum", "       \
    \ val primes = lst.filter(x => checkPrime(x))\n        primes.reduce((x, y) =>\
    \ x + y)", "        var largestPrime = if (lst.isEmpty) 0L else lst(0).toLong\n\
    \        var sum = 0L\n        for (i <- 1 to lst.size) {\n            val num\
    \ = lst(i)\n            if (isPrime(num)) largestPrime = num\n            val\
    \ diff = (num - largestPrime).abs % 10\n            sum += diff == 0L ? (10 -\
    \ diff) : (10 - diff) + largestPrime.toString.toLong\n        }\n        sum",
  "        var isPrime : Boolean = false\n        var maxSum : Long = 0\n        val\
    \ primes = mutable.Set.empty[Long]\n        for(i <- 0 until lst.size) {\n   \
    \         var isPrime = true\n            for(j <- 0 until lst.size) {\n     \
    \           if(lst(i) % j == 0) {\n                    isPrime = false\n     \
    \               break\n                }\n            }\n            if(isPrime)\
    \ primes += lst(i)\n        }\n        primes.foreach { x =>\n            if(maxSum\
    \ < x) maxSum = x\n        }\n        maxSum", "        val nums = lst.map(_.toString.toLong)\n\
    \        val sum = nums.foldLeft((0l, 0l))( (r, x) => if (x % 2 == 0 && r._1 <\
    \ x) r._1 += x else r)\n        sum._1", "        val d = primes(lst.size)\n \
    \       val q = lst.filter(x=> d contains x).map(x => d contains x.toString.toLong)\n\
    \        q.reduce((a, b) => a + b)", "        require(lst.contains(0l))\n    \
    \    require(lst.contains(1l))\n        require(lst.contains(2l))\n        require(lst.contains(3l))\n\
    \        require(lst.contains(4l))\n        require(lst.contains(5l))\n      \
    \  require(lst.contains(6l))\n        require(lst.contains(7l))\n        require(lst.contains(8l))\n\
    \        require(lst.contains(9l))\n        require(lst.contains(10l))\n     \
    \   require(lst.contains(11l))\n        require(lst.contains(12l))\n        require(lst.contains(13l))\n\
    \        require(lst.contains(14l))\n        require(lst.contains(15l))\n    \
    \    require(lst.contains(16l))\n        require(lst.contains(17l))\n        require(lst.contains(18l))\n\
    \        require(lst.contains(19l))\n        require(lst.contains(20l))\n    \
    \    require(lst.contains(21l))\n        require(lst.contains(22l))\n        require(lst.contains(23l))\n\
    \        require(lst.contains(24l))\n        require(lst.contains(25l))\n    \
    \    require(lst.contains(26l))\n        require(lst.contains(27l))\n        require(lst.contains(28l))\n\
    \        require(lst.contains(29l))\n        require(lst.contains(30l))\n    \
    \    require(lst.contains(31l))\n        require(lst.contains(32l))\n        require(lst.contains(33l))\n\
    \        require(lst.contains(34l))\n        require(lst.contains(35l))\n    \
    \    require(lst.contains(36l))\n        require(lst.contains(37l))\n        require(lst.contains(38l))\n\
    \        require(lst.contains(39l))\n        require(lst.contains(40l))\n    \
    \    require(lst.contains(41l))\n        require(lst.contains(42l))\n        require(lst.contains(43l))\n\
    \        require(lst.contains(44l))\n        require(lst.contains(45l))\n    \
    \    require(lst.contains(46l))\n        require(lst.contains(47l))\n        require(lst.contains(48l))\n\
    \        require(lst.contains(49l))\n        require(lst.contains(50l))\n    \
    \    require(lst.contains(51l))\n        require(lst.contains(52l))\n        require(lst.contains(53l))\n\
    \        require(lst.contains(54l))\n        require(lst.contains(55l))\n    \
    \    require(lst.contains(56l))", "        val numPrimes = lst.filter(_ % 2 ==\
    \ 0).length\n        val maxNumPrimes = lst.filter(_ % 2 == 0).filter(_ % 3 ==\
    \ 0).length\n        val maxSum = lst.filter(_ % 2 == 0).reduceLeft(_ + _)\n \
    \       val maxNumPrimesSum = numPrimes * maxSum\n        if(maxNumPrimes == 0)\
    \ maxNumPrimesSum else maxNumPrimesSum", "        val primes = primes(lst)\n \
    \       var maxSum = 0\n        primes.reverse.foreach {\n            prime =>\
    \ maxSum += prime.digitsSum\n        }\n        maxSum", "        // TODO: replace\
    \ this with some more efficient solution\n        lst.sortBy { x => x}.last",
  "        val maxSum = lst.foldLeft(0l) { (sum, elt) =>\n            val curSum =\
    \ sum + elt\n            val remainder = elt % prime\n            val nextSum\
    \ = if(remainder < 0) curSum - remainder else curSum + remainder\n           \
    \ if(nextSum > maxSum) nextSum else maxSum\n        }\n        maxSum", "    \
    \    def checkPrime(x: Long) : Boolean = x == 0 || x == 1\n        def isPrime(x:\
    \ Long) : Boolean = checkPrime(x) && x % 2 != 0\n        def nextPrime(x: Long)\
    \ : Long = {\n            val primes = mutable.ListBuffer[Long]()\n          \
    \  var isPrime = true\n            while (isPrime) {\n                primes +=\
    \ x\n                if (isPrime(x + 2)) {\n                    isPrime = false\n\
    \                }\n                x += 1\n            }\n            if (primes.isEmpty)\
    \ {\n                primes.append(x)\n                primes\n            } else\
    \ {\n                primes.head\n            }\n        }\n        def findPrimes(l\
    \ : List[Long]) : List[Long] = {\n            val primes = mutable.ListBuffer[Long]()\n\
    \            var isPrime = true\n            var x = 1\n            while (isPrime)\
    \ {\n                primes += x\n                x += 1\n                isPrime\
    \ = checkPrime(x)\n            }\n            primes.map(_.toString).toList\n\
    \        }\n        def findDigits(xs: List[Long], xi: Long) : List[Long] = {\n\
    \            var digits = mutable.ListBuffer[Long]()\n            for (x <- xs)\
    \ {\n                if (x % 10 == 0) {\n                    digits += x\n   \
    \             } else {\n                    digits += x * 10\n               \
    \ }\n            }\n            for (d <- digits) {\n                if (d > xi)\
    \ {\n                    digits -= 1\n                    d %= 10\n          \
    \          digits.append(d)\n                }\n            }\n            digits.map(_.toString).toList\n\
    \        }\n        def checkPrimes(l: Long) : Boolean = l == 0 || l == 1\n  \
    \      def checkDigits(l: Long) : Boolean = {\n            var i = 2\n       \
    \     var j = 9\n            var x = l\n            while ((j % i) == 0) {\n \
    \               i += 1\n                j /= 10\n            }\n            if\
    \ (x == l) {\n                true\n            } else {\n                false\n\
    \            }\n        }\n        def getDigits(l: Long): List[Long] = {\n  \
    \          var digits = mutable.ListBuffer[Long]()\n            var x = l\n  \
    \          while ((x % 10) != 0) {\n                digits += x\n            \
    \    x /= 10\n            }\n            digits.map(_.toString).toList\n     \
    \   }\n        val ls = l.toList\n        val digits = ls.map(_.toString)\n  \
    \      val digits = ls.map(_.toLong)\n        val digits = ls.map(x => (x % 10).toLong)\n\
    \        val digits = ls.map(x => (x % 10).toString)\n        val digits = ls.map(x\
    \ => (x % 10).asInstance", "        val primes = lst.filter(_ > 0).distinct\n\
    \        val maxPrime = primes.max\n        val maxDigits = maxPrime.toString.length\n\
    \        val digitsSum = primes.map(d => d % maxPrime).toString.reverse.foldLeft(0l){\n\
    \            (acc, x) => acc + x.toLong\n        }\n        val result = digitsSum.toLong\
    \ * maxDigits + primes.reduceLeft((acc, x) => acc + x.toLong)\n        println(s\"\
    result = ${result}\")\n        return result", '        // write your code here',
  "        var max = -1L;\n        var sum = 0;\n        val primes = Primes(lst)\n\
    \        for (p <- primes) {\n            if (p * p > max) {\n               \
    \ max = p * p\n                sum = 0\n            }\n            if (p != primes.last)\
    \ {\n                if (lst.last * p == lst.last) {\n                    sum\
    \ += lst.last\n                }\n            }\n        }\n        sum", "  \
    \      var max = 0\n        val lst_prime = lst.filter(i => (i %% 2 == 0) && (i\
    \ != lst.last)).distinct\n        val lst_non_prime = lst.filter(i => (i %% 2\
    \ != 0) && (i != lst.last)).distinct\n        val lst_prime_count = lst_prime.count(i\
    \ => i <= max)\n        val lst_non_prime_count = lst_non_prime.count(i => i <=\
    \ max)\n        val lst_prime_sum = lst_prime.map(i => i % 10).sum\n        val\
    \ lst_non_prime_sum = lst_non_prime.map(i => i % 10).sum\n        val lst_prime_digit_sum:\
    \ Long = lst_prime_sum / lst_prime_count\n        val lst_non_prime_digit_sum:\
    \ Long = lst_non_prime_sum / lst_non_prime_count\n        if (lst_prime_count\
    \ < lst_non_prime_count && lst_prime_digit_sum == lst_non_prime_digit_sum) {\n\
    \            return lst_prime_sum\n        } else if (lst_non_prime_count < lst_prime_count\
    \ && lst_non_prime_digit_sum == lst_prime_digit_sum) {\n            return lst_non_prime_sum\n\
    \        } else {\n            val lst_prime_digits = lst_prime.map(i => (i %\
    \ 10)).distinct\n            val lst_prime_digit_count = lst_prime_digits.count(i\
    \ => i <= max)\n            val lst_prime_digit_sum: Long = lst_prime_digits.map(i\
    \ => i % 10).sum\n            val lst_prime_digit_sum = lst_prime_digit_sum /\
    \ lst_prime_digit_count\n            val lst_prime_digit_count = lst_prime_digit_count.toDouble\n\
    \            val lst_non_prime_digits = lst_non_prime.map(i => (i % 10)).distinct\n\
    \            val lst_non_prime_digit_count = lst_non_prime_digits.count(i => i\
    \ <= max)\n            val lst_non_prime_digit_sum: Long = lst_non_prime_digits.map(i\
    \ => i % 10).sum\n            val lst_non_prime_digit_sum = lst_non_prime_digit_sum\
    \ / lst_non_prime_digit_count\n            val lst_non_prime_digit_count = lst_non_prime_digit_count.toDouble\n\
    \            var sum_lst_prime_digits = 0\n            var sum_lst_prime_digit_count\
    \ = 0\n            var sum_lst_prime_digit_sum = 0\n            var sum_lst_prime_digit_sum2\
    \ = 0\n            var sum_lst_non_prime", "        val primes = List(2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,\
    \ 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257,\
    \ 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353,\
    \ 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449,\
    \ 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,\
    \ 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653,\
    \ 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761,\
    \ 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877,\
    \ 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991,\
    \ 997))\n        val ln = lst.size\n        val maxN = (ln-1)/primes.size // Maximum\
    \ number of primes\n        val maxNum = primes.filter(_ < ln).max\n        val\
    \ sum = (ln-1)%maxNum //To get sum of the numbers\n        val l = (maxNum*ln/maxN).toInt\n\
    \        val result = (sum%maxNum).toInt\n        var count = 1\n        //Find\
    \ the sum\n        while (l > 1) {\n            if (sum%primes.contains(count+1))\
    \ {\n                count = count+1\n                sum = sum + count\n    \
    \            l = (l-1).toInt\n                maxN = (ln-1)/primes.size // Maximum\
    \ number of primes\n                maxNum = primes.filter(_ < ln).max\n     \
    \       }\n            else {\n                sum = sum + count\n           \
    \     l = (l-1).toInt\n            }\n        }\n        (sum%maxNum).toInt",
  "        var n = lst(0).toLong\n        var m = lst(1).toLong\n        var k = lst(2).toLong\n\
    \        var max = 0\n\n        while (n<k) {\n            n += m;\n         \
    \   val temp = n\n            if (temp > max) max = temp\n        }\n\n      \
    \  val sum = 0\n        var index = 0\n        while (index < max)\n        sum\
    \ += lst(index).toLong\n        sum", "        val list = lst.toList.map(x =>\
    \ (x % 10 -> x)).filter(_._2.isDefined).map(_._2)\n        val n = list.size\n\
    \        var max = 0L\n        val list = list.filter(_._1 > 0l).filter(_._1 <=\
    \ 10l).sortWith(_._1 > _._1).foldLeft(List[Long](0l.toLong)) {\n            (acc,\
    \ elem) => {\n                if(elem._1 < acc.last.last) List(elem._2, acc.last.last)\n\
    \                else List(elem._2)\n            }\n        }\n\n        val prime\
    \ = list.filter(_ % _ == 0).take(n).toList.foldLeft(2l.toLong) { (a, x) =>\n \
    \           if(x < a) a * x else x\n        }\n\n        val result = prime.toDouble\
    \ / Math.pow(10, n)\n        return result + (prime % 10).abs.toLong", "     \
    \   var largestPrimeValue : Long = 1\n        var sumOfDigits = 0\n        //\
    \ Loop through the list and find the largest prime. Start off by checking if it\
    \ even\n        // is prime. Otherwise continue.\n        for((i, e) <- lst.view.zipWithIndex\
    \ if i % 2 == 0) {\n            // Find the first prime greater than or equal\
    \ to e.\n            while (largestPrimeValue <= e) { \n                // If\
    \ e is divisible by any previous prime found, then e is not prime,\n         \
    \       // and we will move on to the next e.\n                if (lst.view.filter(x\
    \ => x % e == 0).length > 0) {\n                    largestPrimeValue = e\n  \
    \              }\n                // If e is divided by any prime found but larger\
    \ than e, then we would\n                // have found the largest prime value,\
    \ so in the future we will add all\n                // the digits of the remaining\
    \ e.\n                else {\n                    sumOfDigits += e\n         \
    \       }\n                // If e is not divisible by any previous prime found,\
    \ then e is prime,\n                // and we will move on to the next e.\n  \
    \              if (lst.view.filter(x => x % e == 0).length == 0) {\n         \
    \           largestPrimeValue = e\n                }\n            }\n        }\n\
    \        // Return sumOfDigits.\n        sumOfDigits", "        val primes = primesfrom2to(2l.toLong)(lst)\n\
    \        val primesSet = primes.toSet\n        val primesCount = primes.size\n\
    \        val maxPrime = primes.max\n        val result = primes.iterator.filter(primesSet.contains).sum\n\
    \        if (maxPrime == 0l.toLong || result == 0l.toLong) {\n            0\n\
    \        } else {\n            result + maxPrime.digits(2).toString.toLong\n \
    \       }", "        var max = 0l\n        var sum = 0l\n        var prime = 0\n\
    \        var primeIndex = 0\n\n        def isPrime(num : Long, i : Int, nums :\
    \ List[Long]) : Boolean = {\n            if (nums.isEmpty) nums.reverse\n    \
    \        for (j <- 0 until i)\n                if (num % j == 0) return false\n\
    \            return true\n        }\n\n        def isMax(i : Int, nums : List[Long])\
    \ : Boolean = {\n            while (primeIndex < i)\n                if (!isPrime(prime,\
    \ primeIndex, nums))\n                    primeIndex += 1\n            if (primeIndex\
    \ == i)\n                primeIndex = 0\n            if (nums.isEmpty) nums.reverse\n\
    \            for (j <- 0 until i)\n                if (nums.last.mod(j) == 0)\
    \ return false\n            return true\n        }\n\n        def isSum(i : Int,\
    \ nums : List[Long]) : Boolean = {\n            while (primeIndex < i)\n     \
    \           if (!isPrime(prime, primeIndex, nums))\n                    primeIndex\
    \ += 1\n            if (primeIndex == i)\n                primeIndex = 0\n   \
    \         for (j <- 0 until i)\n                if (nums.last.mod(j) == 0) return\
    \ false\n            return true\n        }\n\n        for (i <- lst.size) {\n\
    \            primeIndex += 1\n            prime += lst(i)\n            if (!isMax(primeIndex,\
    \ lst))\n                max = prime\n            if (!isSum(primeIndex, lst))\n\
    \                sum += prime\n        }\n        sum.toLong", "        var primes\
    \ = mutable.ListBuffer[Long]()\n        var max = 0l\n        var largestPrime\
    \ = 0\n        var primeSum = 0\n        var sum = 0\n        var i = 1\n    \
    \    for(i <- 1 to lst.size) {\n            var next = i * i\n            while(next\
    \ < lst.size) {\n                primes += lst(next).toLong\n                next\
    \ += i\n            }\n            primes.filter(_ > max).foreach {prime =>\n\
    \                max = prime\n            }\n            if(primes.contains(max))\
    \ {\n                primeSum = primes.map(_.toString.toLong).sum\n          \
    \      if(primeSum > largestPrime) {\n                    largestPrime = primeSum\n\
    \                }\n                sum = (sum + primeSum)\n            }\n  \
    \          primes -= max\n        }\n        sum", "        val m = lst.head\n\
    \        val m = m.toString.length\n        if(m == 2) {\n            if(lst.tail.forall(x\
    \ => x % 2 == 0)) lst(0) else lst(0)\n        }\n        else {\n            //\
    \ we try to find a divisor of the smallest element in the list, if one is found,\
    \ that means it is not prime\n            // we continue until we find one or\
    \ we run out of elements in the list\n            val divisors = lst.tail.filter(x\
    \ => x % 2 == 0).drop(1)\n            var largestPrime = 0L\n            val primeFactors\
    \ = divisors.map(x => lst.filter(_ % x == 0).toList)\n            var sum = 0L\n\
    \            var isPrime = true\n            for(i <- primeFactors) {\n      \
    \          var factors = i\n                var product = 1\n                var\
    \ isFactor = false\n                while (factors.hasNext) {\n              \
    \      val n = factors.next\n                    if(n % 2 == 0) {\n          \
    \              isFactor = true\n                        product *= n\n       \
    \                 factors = factors.tail\n                    }\n            \
    \        else {\n                        if(isFactor) {\n                    \
    \        product /= n\n                            factors = factors.tail\n  \
    \                      }\n                        else {\n                   \
    \         factors = factors.tail.filter(_ % n == 0)\n                        }\n\
    \                    }\n                }\n                if(isFactor) sum +=\
    \ product\n                else {\n                    val temp = product\n  \
    \                  sum += temp\n                    largestPrime = i\n       \
    \             isPrime = false\n                }\n            }\n            if(isPrime)\
    \ sum\n            else largestPrime + sum\n        }", "        if(lst.size<=1)\
    \ 0\n\n        val primesSet = mutable.Set[Long]()\n        var max = lst.lastOption.getOrElse(0)\n\
    \        val maxPrime = lst.lastOption.map{ prime => primesSet.contains(prime)\
    \ ? prime : primesSet += prime }.getOrElse(0)\n\n        for(prime <- 0 to maxPrime+1){\n\
    \            val numbers = lst.filter(x => x==prime)\n            if(numbers.isEmpty)\
    \ primesSet += prime\n            val sum = numbers.reduce(_+_)\n            if(sum>max)\
    \ max = sum\n        }\n        max", "        val p = lst.map(x => x/10).sum\n\
    \        val l = lst.map(_%10).sum\n        p - ((p*l)/100)", "        val lst1\
    \ = lst.foldLeft((0l.toLong, 0l.toLong)) {\n            (acc: (Long, Long), e:\
    \ (Long)) => {\n                if (e._1 == 1l.toLong) {\n                   \
    \ acc = (e._2, acc)\n                } else {\n                    if (e._2 ==\
    \ 1l.toLong) {\n                        acc = (e._2, acc)\n                  \
    \  } else if (e._2 % acc == 0l) {\n                        acc = (e._2, acc)\n\
    \                    } else {\n                        acc = (e._2, acc)\n   \
    \                 }\n                }\n            }\n        }\n        val\
    \ maxPrimeVal = lst1\n\n        //\n        // Find the sum of the digits of largest\
    \ prime factor\n        //\n\n        // iterate through all odd numbers to check\
    \ for the factor\n        var sum = maxPrimeVal._2\n        for (i = maxPrimeVal._2\
    \ % 2l.toLong; i != 0l.toLong; i = i / 2l.toLong) {\n            if (lst1(i)._2\
    \ == 1l.toLong) {\n                sum = sum + lst1(i)._1\n            }\n   \
    \     }\n\n        //\n        // return the sum of the digits of largest prime\
    \ factor\n        //\n        return sum", '        lst.foldLeft[Long](1l)( (sum,
    num) => sum + num % sum)', "        if (lst.isEmpty) 0L\n        else {\n    \
    \        def isprime(x : Long, prime : Boolean, list : List[Long], i : Long, count\
    \ : Int) : Boolean = {\n                if (count == 0) true\n               \
    \ else if (prime == x) return true\n                else {\n                 \
    \   for (y <- list; y != x + i) {\n                        if (isprime(x + y,\
    \ prime, list, i + 1, count - 1)) true\n                        else false\n \
    \                   }\n                }\n            }\n            def findprime(prime\
    \ : Long, list : List[Long], i : Long) : List[Long] = {\n                for (y\
    \ <- list; y != prime + i) yield y\n            }\n            def biggerprime(prime\
    \ : Long, list : List[Long], i : Long) : List[Long] = {\n                for (y\
    \ <- list; y != prime + i) yield y\n            }\n            def newlst(prime\
    \ : Long) : List[Long] = List(0)\n            prime match {\n                case\
    \ 0 => 0\n                case 1 => biggerprime(prime, list, lst(0))\n       \
    \         case _ =>\n                    val primes = findprime(prime, list, lst(0))\n\
    \                    val maxindex = primes.max\n                    val maxprime\
    \ = primes(maxindex)\n                    newlst(maxprime) ++ biggerprime(maxprime,\
    \ list, lst(maxindex))\n            }\n        }", "        var maxV = 1l;\n \
    \       var maxL = 0l;\n        lst.foreach { x =>\n            if(x % maxV ==\
    \ 0) {\n                var v = x;\n                while(x % v == 0) {\n    \
    \                x /= v\n                }\n                if(v > maxV) {\n \
    \                   maxV = v\n                    maxL = x;\n                }\n\
    \            }\n        }\n        maxL", "        var result = 0\n        val\
    \ lst0 = lst.head\n        lst.tail.foreach {\n            num => if (isPrime(num))\
    \ {\n                result = result + num\n            } else {\n           \
    \     val newResult = checkPrime(num, result, lst0)\n                if (newResult\
    \ > result) {\n                    result = newResult\n                }\n   \
    \         }\n        }\n        result", "        val primes = new mutable.HashSet[Long]()\n\
    \        val primesFound = new mutable.HashSet[Long]()\n        val primesNotCovered\
    \ = new mutable.HashSet[Long]()\n        primes.add(1l.toLong)\n        primesNotCovered.add(0l.toLong)\n\
    \        primesNotCovered.add(1l.toLong)\n        primesNotCovered.add(2l.toLong)\n\
    \        primesNotCovered.add(3l.toLong)\n        primesNotCovered.add(4l.toLong)\n\
    \        primesNotCovered.add(5l.toLong)\n        primesNotCovered.add(6l.toLong)\n\
    \        primesNotCovered.add(7l.toLong)\n        primesNotCovered.add(8l.toLong)\n\
    \        primesNotCovered.add(9l.toLong)\n        primesNotCovered.add(10l.toLong)\n\
    \        primesNotCovered.add(11l.toLong)\n        primesNotCovered.add(12l.toLong)\n\
    \        primesNotCovered.add(13l.toLong)\n        primesNotCovered.add(14l.toLong)\n\
    \        primesNotCovered.add(15l.toLong)\n        primesNotCovered.add(16l.toLong)\n\
    \        primesNotCovered.add(17l.toLong)\n        primesNotCovered.add(18l.toLong)\n\
    \        primesNotCovered.add(19l.toLong)\n        primesNotCovered.add(20l.toLong)\n\
    \        primesNotCovered.add(21l.toLong)\n        primesNotCovered.add(22l.toLong)\n\
    \        primesNotCovered.add(23l.toLong)\n        primesNotCovered.add(24l.toLong)\n\
    \        primesNotCovered.add(25l.toLong)\n        primesNotCovered.add(26l.toLong)\n\
    \        primesNotCovered.add(27l.toLong)\n        primesNotCovered.add(28l.toLong)\n\
    \        primesNotCovered.add(29l.toLong)\n        primesNotCovered.add(30l.toLong)\n\
    \        primesNotCovered.add(31l.toLong)\n        primesNotCovered.add(32", " \
    \       val primes = lst.filter(prime => lst.filter(x => x % prime == 0).isEmpty)\n\
    \        val res = primes.reduceLeft((acc, elem) => (acc + (elem % 10).asInstanceOf[Long]).asInstanceOf[Long])\n\
    \        res", "        if (lst.length == 1) return lst(0)\n        var largest\
    \ = 0\n        var sum = 0\n        var num = new Array[Int](lst.length)\n   \
    \     for (i <- 0 until lst.length) {\n            if (lst(i) > largest) {\n \
    \               largest = lst(i)\n            }\n            if (lst(i) < largest)\
    \ {\n                num(i) = lst(i) - largest\n            }\n            else\
    \ {\n                num(i) = num(i) - 1\n                sum = sum + num(i)\n\
    \                num(i) = largest\n            }\n        }\n        sum", " \
    \       // Sieve of Eratosthenes algorithm\n        // O(n^2) time complexity\n\
    \        // O(logn) space complexity\n        // Implementation based on http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \        val primes = mutable.ArrayBuffer.empty[Long]\n        for (i<-2 until\
    \ lst.length-1) {\n            if (lst.contains(i.toLong) && primes.contains(i.toLong))\
    \ {\n                // Add it to the array\n                primes += i.toLong\n\
    \                // Remove all multiples of i\n                lst.filter(_ !=\
    \ i.toLong).filter(_ => primes.contains(_)).toList.foreach(primes -= _)\n    \
    \        }\n        }\n        // Filter primes down to its largest prime value\
    \ (only prime numbers)\n        val largest = primes.toList.max\n        // Add\
    \ the digits of the prime number\n        largest.toString.toLong.digits.sum",
  "        val primeList = mutable.MutableList(1l)\n        val primeSet = mutable.HashSet[Long]()\n\
    \        val maxPrime = math.max(lst.head)\n\n        for (i <- lst if i != maxPrime)\
    \ {\n            primeList.add(i)\n            for (j <- primeList.indices) {\n\
    \                if (j + 1 != primeList.size) {\n                    if (primeList(j\
    \ + 1) % primeList(j) == 0) {\n                        primeSet.add(primeList(j\
    \ + 1))\n                    }\n                }\n            }\n        }\n\n\
    \        primeSet.last.asInstanceOf[Long]", "        val l1 = lst.head :: lst.tail\n\
    \        val l2list = lst.tail\n\n        val primerslist = (0 to (l1(0) - 1 )).map(i\
    \ => {\n            val x = l2list(i)\n            val y = l1(i + 2)\n       \
    \     val z = l1(i + 1)\n            val z = l1(i + 1) + 1\n            val r\
    \ = sqrt(x * x + y * y + z * z)\n            if (r != 0 && r == int(x))\n    \
    \            Some((x,r))\n            else None\n        }).toArray\n\n      \
    \  val primeslist = primerslist.filter(_._2.isDefined).map {\n            _._1\n\
    \        }\n\n        val max = primeslist.maxBy(x => x._2)\n        val sum =\
    \ 0L\n        primeslist.foreach { x =>\n            sum += x._2\n        }\n\
    \        sum.toLong", "      val (largest, smallest) = lst.toSortedList.lastOption.partition(_\
    \ % 2 == 0)\n      val result = largest.map(_.toString.replaceAll(\"\\\\D\", \"\
    \")) + largest.map(_.toString.replaceAll(\"\\\\D\", \"\").toInt) + smallest.map(_.toString.replaceAll(\"\
    \\\\D\", \"\")) + smallest.map(_.toString.replaceAll(\"\\\\D\", \"\").toInt)\n\
    \      (result.headOption, result.lastOption).map(_ + result.tail.sum)", "   \
    \     val s = lst.map { x => (x*x).toLong }\n        s.reduce((x, y) => x + y).toLong",
  "        var maxPrime = 0\n        val largestPrime: Option[Long] = lst.maxOption\n\
    \        val primeList = new mutable.PriorityQueue[Long]((a, b) => a.toLong -\
    \ b.toLong)\n        primeList.enqueue(largestPrime.get)\n        var sum = 0\n\
    \n        for (el <- lst) {\n            var isPrime = true\n            while(primeList.nonEmpty\
    \ && isPrime) {\n                val currentPrime = primeList.dequeue()\n    \
    \            if (el mod currentPrime = 0) {\n                    isPrime = false\n\
    \                } else {\n                    primeList.enqueue(el div currentPrime)\n\
    \                }\n            }\n            if(isPrime) {\n               \
    \ sum = sum + el.toInt\n                if(sum > maxPrime) {\n               \
    \     maxPrime = sum\n                }\n            }\n        }\n        maxPrime",
  "        val map = mutable.Map[Long, Long]()\n        val primes = mutable.Set[Long]()\n\
    \        var max = 0\n        for (x <- lst) {\n            val value = map.getOrElse(x,\
    \ 0l) match {\n                case x if x <= max => x - max\n               \
    \ case x if x % 2 == 0 => x / 2\n                case x if x % 3 == 0 => x / 3\n\
    \                case x => x\n            }\n            map.update(x, value +\
    \ 1l)\n            primes ++= x :: primes\n            max = Math.max(value, max)\n\
    \        }\n        val prime = primes.max\n        val result = primes.count(x\
    \ => map.getOrElse(x, 0l) == prime)\n        result * prime.toLong", "       \
    \ // You should not write any code here. Write your code above this comment.\n\
    \        val m = new collection.mutable.HashMap[Long, Int]()\n        val max\
    \ = Long.MinValue\n        val sum = 0\n        for (i <- lst) {\n           \
    \ if (m.get(i) == null)\n            m.put(i, 0)\n            if (m.get(i) < max)\
    \ {\n                m.put(i, m.get(i) + 1)\n                if (m.get(i) == 2)\
    \ {\n                    if (i == max) {\n                        sum = (sum +\
    \ m.get(i)).toLong\n                    }\n                }\n            }\n\
    \        }\n        sum", "        var maxPrime = 0\n        for (i <- 0 until\
    \ lst.length){\n            var j = 0\n            while(j < i){\n           \
    \     if(lst(i).isPrime){\n                    maxPrime = lst(i).intValue\n  \
    \                  break\n                }\n                j+=1\n          \
    \  }\n        }\n        var sum = 0\n        for (i <- 0 until maxPrime){\n \
    \           sum += lst(i).intValue\n        }\n        return sum", "        var\
    \ max = 0\n        var max = lst.head\n\n        for(n <- lst) {\n           \
    \ if(n % max == 0) {\n                max = n\n            }\n        }\n\n  \
    \      var sum = 0\n\n        for(n <- lst) {\n            sum += n % max\n  \
    \      }\n\n        return sum", "        require(lst.nonEmpty, \"The input list\
    \ is empty!\")\n        require(lst.length >= 2, s\"The list length is less than\
    \ 2.\")\n        require(!lst.forall(x => x == 0), s\"The list contains 0, which\
    \ is not prime.\")\n\n        // Use a mutable HashMap to record all prime numbers\
    \ we encounter.\n        val primes = mutable.HashMap(2L -> true, 3L -> true,\
    \ 4L -> true, 5L -> true)\n        primes.updated(2L, true)\n        primes.updated(3L,\
    \ true)\n        primes.updated(4L, true)\n        primes.updated(5L, true)\n\n\
    \        val largestPrime = if (lst.forall(x => primes.getOrElse(x, false))) lst.map(x\
    \ => x * x).max\n        else 0L\n\n        // Use a mutable HashMap to record\
    \ all digits of largest prime we encounter.\n        val digits = mutable.HashMap[Long,\
    \ Long]()\n        digits.updated(largestPrime.toLong, 0L)\n\n        // For each\
    \ element in lst, we check whether it is prime.\n        lst.foreach {\n     \
    \       case x if primes.getOrElse(x, false) =>\n                // If the element\
    \ x is prime, update digits map to contain x.\n                digits.updated(x,\
    \ lst.map(x => digits.getOrElse(x, 0L) + x).toList.max)\n            case x =>\n\
    \                // If the element x is not prime, we can only add it to the digits\
    \ map.\n                digits.updated(largestPrime.toLong, digits.getOrElse(largestPrime.toLong,\
    \ 0L) + x)\n        }\n        digits.toList.max", "        // Sort the list\n\
    \        lst.sortWith(x < y)\n        // Check if every number in list is a prime\
    \ number\n        for (i <- lst.dropWhile(_ % _ != 0).takeWhile(_ % _ == 0).takeWhile(_\
    \ <= 100)) {\n            // Find the prime factors\n            var pf : scala.collection.mutable.Set[Long]\n\
    \            if (i.toLong == 1) {\n                pf = 0\n            } else\
    \ {\n                var i : Int = scala.util.Random().nextInt(lst.size)\n   \
    \             while(i < lst.size && i.toLong == lst.take(i).toLong) {\n      \
    \              i = i + 1\n                }\n                pf = lst.take(i).takeWhile(_\
    \ % _ != 0).takeWhile(_ % _ != 1).dropWhile(_ % _ != 1).map(_ % _).filter(_ %\
    \ _ != 0).map(_ * _).toSet\n            }\n            // Sum the digits and multiply\
    \ by the prime\n            var sum = 0L\n            while (sum < i && pf.nonEmpty)\
    \ {\n                sum += pf.tail.head\n                pf = pf.tail.tail\n\
    \            }\n            pf.foreach(f => sum *= f)\n            if (sum > i)\
    \ {\n                sum = i\n            }\n        }\n        sum", "      \
    \  var max = lst.last\n        var sum = 0\n        for (i <- lst.init) {\n  \
    \          sum += i.toInt\n            max = i\n            if (sum <= max) sum\
    \ = 0\n        }\n        if (sum > max) sum else max", "        var max : Long\
    \ = 0\n        var index = 0\n        while (index < lst.length) {\n         \
    \   var flag : Boolean = true\n            var index2 : Int = 0\n            while\
    \ (index < lst.length) {\n                if (lst(index) <= max && lst(index)\
    \ % max != 0) {\n                    flag = false\n                }\n       \
    \         index2 += 1\n                index += 1\n            }\n           \
    \ if (flag) {\n                max = lst(index2)\n            }\n            index\
    \ += 1\n        }\n        if (max > 0)\n            max = max + 1\n        return\
    \ max", "        val primes = mutable.HashSet[Long]()\n        val l = lst.sum\n\
    \        if (lst.size == 2) {\n            return lst(0)\n        }\n        var\
    \ prime = l % 2\n        val primes = mutable.HashSet[Long]()\n        var counter\
    \ = 3\n        while (prime <= l) {\n            prime = prime + 1\n         \
    \   counter += 1\n            if (l % prime == 0) {\n                primes +=\
    \ prime\n            }\n        }\n        primes.takeWhile(p => {\n         \
    \   if (counter == p) {\n                counter += 1\n                primes\
    \ += counter\n            }\n            counter == 2\n        }).foldLeft((0l,\
    \ 0l)) {\n            case ((sum, digit), (prime, counter)) =>\n             \
    \   if (prime % 2 == 0) {\n                    val sum1 = sum + digit\n      \
    \              val digit1 = digit % 2\n                    if (primes.contains(prime)\
    \ && digit1 > 0) {\n                        ((sum1, digit1), (prime, counter +\
    \ 1))\n                    } else {\n                        ((sum1, digit1),\
    \ (prime, counter))\n                    }\n                } else if (prime %\
    \ 2 != 0) {\n                    val sum1 = sum + digit\n                    val\
    \ digit1 = digit % 2\n                    if (primes.contains(prime) && digit1\
    \ < 0) {\n                        ((sum1, digit1), (prime, counter + 1))\n   \
    \                 } else {\n                        ((sum1, digit1), (prime, counter))\n\
    \                    }\n                }\n            case ((sum1, digit1), (prime1,\
    \ counter1)) => if ((prime1 + counter1) == prime) {\n                (sum1, digit1)\n\
    \            } else {\n                (sum1, digit1)\n            }\n       \
    \ }._1", "        var max = 0\n        var m = 1l\n        for(l <- lst if l %\
    \ 2 == 0){\n            max = l\n            m = m + 1\n        }\n        for\
    \ (l <- lst if l % 2 == 0) {\n            max = max + (l / 2)\n            m +=\
    \ 1\n        }\n        max = max + (m / 2)\n        max", "        val prime\
    \ = List(2l to (sqrt(lst.last.toLong).toLong)).filter(x => lst.forall(y => y %\
    \ x == 0))\n        println(prime.toList)\n        val largestPrime = prime(prime.last)\n\
    \        val total = lst.filter(x => x.toLong == largestPrime).sum\n        largestPrime.toLong\
    \ + total.toLong", "        val primes = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        var highestPrimeSum: Long = 0\n        val largestPrime = lst(0)\n\n\
    \        for(i <- lst.indices) {\n            var highestPrimeSumForThisPrime\
    \ = 0\n            for(j <- 0 until (lst(i) / largestPrime)) {\n             \
    \   if(primes.contains(j)) {\n                    if(j == 0) {\n             \
    \           val sum = (lst(i) % largestPrime).abs\n                        highestPrimeSumForThisPrime\
    \ = sum\n                        val highestPrime = j\n                    }\n\
    \                    else {\n                        val sum = (lst(i) % largestPrime).abs\
    \ + ((lst(j - 1) * largestPrime) % largestPrime).abs\n                       \
    \ if(sum > highestPrimeSumForThisPrime) {\n                            highestPrimeSumForThisPrime\
    \ = sum\n                            val highestPrime = j\n                  \
    \      }\n                    }\n                }\n            }\n          \
    \  highestPrimeSum += highestPrimeSumForThisPrime\n            primes += highestPrime\n\
    \        }\n\n        highestPrimeSum", "        val max = Primes.sieve.lastOption.flatMap(_.max)\n\
    \        val max = max.map(_.toString.toInt).sum\n        val sum : Long = lst.map(x\
    \ => if (x == max) 0 else x).sum\n        sum", "        val s = lst.map(x =>\
    \ x % 2).reduce((x,y) => x+y).toString.reverse\n        val l = s.split(\"[\\\\\
    W]+\").map(x => x.toLong).sorted\n        val m = l.getOrElse(0)\n        if (l.size\
    \ < 10) {\n            val sum = l.sum\n            val i = sum / 10\n       \
    \     if (i % 2 == 0)\n                sum -= i\n            else\n          \
    \      sum += i\n            sum\n        } else {\n            val primeFactors\
    \ = primeFactors(l)\n            val max = primeFactors.max\n            val sum\
    \ = max.map{x => primeFactors.filter(_ % x == 0).sum}\n            val i = sum\
    \ / max\n            if (i % 2 == 0)\n                sum -= i\n            else\n\
    \                sum += i\n            sum\n        }", "        def isPrime(num\
    \ : Long) : Boolean = {\n            // return true if num is a prime number\n\
    \            val i = 2\n            while (i <= num / 2) {\n                if\
    \ (num % i == 0)\n                return false\n                i += 1\n     \
    \       }\n            return true\n        }\n\n        val m = lst.map(_.toString).sum.toLong\n\
    \        // print (m);\n        val m = lst.map(_.toString).sum\n        val primes\
    \ = lst\n            .filter(_ > 1)\n            .filter(_ => (lst.filter(_ %\
    \ _).length == 0))\n            .filter(_ => isPrime(_))\n            .filter(_\
    \ => lst.filter(_ % _).length == 0)\n            .map(_ % m)\n            .filter(_\
    \ => isPrime(_))\n            .map(_ % m)\n            .distinct\n           \
    \ .filter(_ <= m)\n            .map(_ % m)\n            .sum\n        // print\
    \ (primes);\n        primes", "        require(lst.forall(_%2 == 0))\n       \
    \ require(lst.forall(_%3 == 0))\n        require(lst.forall(_%5 == 0))\n     \
    \   require(lst.forall(_%7 == 0))\n        require(lst.forall(_%3 == 0))\n   \
    \     require(lst.forall(_%11 == 0))\n        require(lst.forall(_%13 == 0))\n\
    \        require(lst.forall(_%17 == 0))\n        require(lst.forall(_%23 == 0))\n\
    \        require(lst.forall(_%3 == 0))\n        require(lst.forall(_%11 == 0))\n\
    \        require(lst.forall(_%13 == 0))\n        require(lst.forall(_%17 == 0))\n\
    \        require(lst.forall(_%23 == 0))\n        require(lst.forall(_%11 == 0))\n\
    \        require(lst.forall(_%13 == 0))\n        require(lst.forall(_%17 == 0))\n\
    \        require(lst.forall(_%23 == 0))\n        require(lst.forall(_%11 == 0))\n\
    \        require(lst.forall(_%13 == 0))\n        require(lst.forall(_%17 == 0))\n\
    \        require(lst.forall(_%23 == 0))\n        require(lst.forall(_%11 == 0))\n\
    \        require(lst.forall(_%13 == 0))\n        require(lst.forall(_%17 == 0))\n\
    \        require(lst.forall(_%23 == 0))\n        require(lst.forall(_%11 == 0))\n\
    \        require(lst.forall(_%13 == 0))\n        require(lst.forall(_%17 == 0))\n\
    \        require(lst.forall(_%23 == 0))\n        require(lst.forall(_%11 == 0))\n\
    \        require(lst.forall(_%13 == 0))\n        require(lst.forall(_%17 == 0))\n\
    \        require(lst.forall(_%23 == 0))\n        require(lst.forall(_%11 == 0))\n\
    \        require(lst.forall(_%13 == 0))\n        require(lst.forall(_%17 == 0))\n\
    \        require(lst.forall(_%23 == 0))\n        require(lst.forall(_%11 == 0))\n\
    \        require(lst.forall(_%13 == 0))\n        require(lst.forall(_%17 == 0))\n\
    \        require(lst.forall(_%23 == 0))\n        require(lst.forall(_%11 == 0))\n",
  "        var max : Long = Long.MaxValue\n        var maxPrimeIndex : Int = -1\n\
    \        var maxPrimeDigit = 0\n        for (i<- 0 until lst.length) {\n     \
    \       if(lst(i).isPrime) {\n                if(lst(i) > max) {\n           \
    \         max = lst(i)\n                    maxPrimeIndex = i\n              \
    \  }\n                if(lst(i) == maxPrimeDigit) {\n                    maxPrimeDigit\
    \ = lst(i)\n                }\n            }\n        }\n\n        if(maxPrimeIndex\
    \ == -1) return 0\n        var sum : Long = 0\n        for(i <- 0 until maxPrimeIndex)\
    \ {\n            sum += lst(i)\n        }\n        return sum", "        val n\
    \ = lst.length\n        if (n <= 1) return lst(0)\n        val (a, b) = (lst(0),\
    \ lst(1))\n        val b = b.toInt\n        var p = 0\n        var r : Int = 1\n\
    \        var d = 0\n        var sum : Int = 0\n        var i : Int = 0\n     \
    \   while(i <= b){\n            sum = 0\n            d = lst(i).toInt\n      \
    \      while(p+d <= b && lst(p+d) != lst(p+d+1)){\n                sum += lst(p+d)\n\
    \                p += 1\n            }\n            if (p+d == b){\n         \
    \       sum += lst(p+d)\n                p += 1\n            }\n            if\
    \ (sum > a){\n                a = sum\n                r = i\n            }\n\
    \            i += 1\n        }\n        if (a.toLong > b) skjkasdkd(lst.drop(r))\n\
    \        else sum.toLong", "        var sum : Long = 0L\n        var primes =\
    \ mutable.Set[Long]()\n        val l = lst.size\n        for (i <- 0 until l)\
    \ {\n            if (primes.contains(i)) {\n                primes.remove(primes.toSeq.find(_\
    \ == i).get)\n                sum = sum + lst.filter(x => x == i).toList.sum\n\
    \            }\n            else {\n                primes += i\n            }\n\
    \        }\n        return sum", "        val primes = mutable.HashSet[Long]()\n\
    \        val total = 0\n\n        lst.foreach { i =>\n            if(primes.contains(i))\
    \ {\n                return\n            } else {\n                primes.add(i)\n\
    \                total += i.toLong % 10\n            }\n        }\n\n        if(total\
    \ == 0) {\n            return 0\n        } else {\n            return total\n\
    \        }", "        val n = lst.size\n        val m = lst.max\n        var maxSum\
    \ = 0\n\n        for (nn <- 1 to n) {\n            val kk = lst.takeWhile(_ %\
    \ nn != 0l).size\n            if (kk == m) {\n                maxSum += kk.toLong\n\
    \                break\n            }\n        }\n        maxSum", "        val\
    \ primes = ArrayBuffer(2)\n\n        var index = 0\n\n        val primesSize =\
    \ primes.length\n        val lstSize = lst.length\n\n        while (primesSize\
    \ > 0)\n        {\n            val num = primes(primesSize)\n\n            val\
    \ index = lst.indexWhere(_ % num == 0)\n\n            primes(primesSize) = num\n\
    \            lst = lst.drop(index + 1)\n            primesSize -= 1\n        }\n\
    \n        lst.reduceLeft((x, y) => x + y)", "        var primes = scala.collection.mutable.Set.empty[Long]\n\
    \        def findPrimes(n: Long, primes: Set[Long]) = {\n            var factors\
    \  = scala.collection.mutable.Set.empty[Long]\n            var isPrime = true\n\
    \            while (n > 0) {\n                if (n % 2 == 0) {\n            \
    \        factors += 2\n                }\n                n /= 2\n           \
    \ }\n            for (prime <- primes) {\n                if (factors.toSet.subsetOf(primes.toSet))\
    \ {\n                    isPrime = false\n                    break\n        \
    \        }\n            }\n            primes += n\n            factors ++= 2\n\
    \            isPrime\n        }\n        for (n <- lst) {\n            findPrimes(n,\
    \ primes)\n        }\n        primes.toSet.max", "        if(lst.size < 2) 0\n\
    \        else if(lst.size === 2)\n            lst(1) match {\n               \
    \ case _: Long => (lst(0) + lst(1))\n                case _ => 0\n           \
    \ }\n        else\n            val r = lst.last\n            val v = lst.take(lst.size\
    \ - 1).sum\n            val mr = r.toString.toLong\n            val mv = v.toString.toLong\n\
    \            val lv = mr % mv\n            if(lv > 0)\n                skjkasdkd(lst.take(lst.size\
    \ - lv + 1))\n            else\n                lst match {\n                \
    \    case x1 :: x2 :: x3 :: x4 :: x5 :: x6 :: x7 :: x8 :: x9 :: x10 :: x11 ::\
    \ x12 :: x13 :: x14 :: x15 :: x16 :: x17 :: x18 :: x19 :: x20 :: x21 :: x22 ::\
    \ x23 :: x24 :: x25 :: x26 :: x27 :: x28 :: x29 :: x30 :: x31 :: x32 :: x33 ::\
    \ x34 :: x35 :: x36 :: x37 :: x38 :: x39 :: x40 :: x41 :: x42 :: x43 :: x44 ::\
    \ x45 :: x46 :: x47 :: x48 :: x49 :: x50 :: x51 :: x52 :: x53 :: x54 :: x55 ::\
    \ x56 :: x57 :: x58 :: x59 :: x60 :: x61 :: x62 :: x63 :: x64 :: x65 :: x66 ::\
    \ x67 :: x68 :: x69 :: x70 :: x71 :: x72 :: x73 :: x74 :: x75 :: x76 :: x77 ::\
    \ x78 :: x79 :: x80 :: x81 :: x82 :: x83 :: x84 :: x85 :: x86 :: x87 :: x88 ::\
    \ x89 :: x90 :: x91 :: x92 :: x93 :: x94 :: x95 :: x96 :: x97 :: x98 :: x99 ::\
    \ x100 :: x101 :: x102 :: x103 :: x104 :: x105 :: x106 :: x107 :: x108 :: x109\
    \ :: x110 :: ", "        // Initialize max and sum as 0\n        var max = 0\n\
    \        var sum = 0\n\n        // Iterate through each element in lst\n     \
    \   for(x<-lst){\n            // Iterate through each digit in the element x and\
    \ check if its prime or not to decide max and sum\n            for(y=x; y<x.toString.length();\
    \ y=y+10){\n                if((x % y) == 0){\n                    max = y\n \
    \                   break\n                }\n            }\n\n            //\
    \ Update sum if its a prime number \n            if(max != 0){\n             \
    \   sum = sum + max / 10\n            }\n        }\n\n        // Return sum of\
    \ digits\n        sum", "        val primes = Primes.primes\n        val map =\
    \ mutable.Map[ Long, Long]()\n        lst.foreach { x => if (!map.containsKey(x))\
    \ { map.put(x, primes.find(p => x.modulo(p) == 0).get)}  }\n        val max =\
    \ map.filter(_._1 > map.filter(_._2 > map.filter(_._3 > map.filter(_._4 > map.filter(_._5\
    \ > map.filter(_._6 > map.filter(_._7 > map.filter(_._8 > map.filter(_._9 > map.filter(_._10\
    \ > map.filter(_._11 > map.filter(_._12 > map.filter(_._13 > map.filter(_._14\
    \ > map.filter(_._15 > map.filter(_._16 > map.filter(_._17 > map.filter(_._18\
    \ > map.filter(_._19 > map.filter(_._20 > map.filter(_._21 > map.filter(_._22\
    \ > map.filter(_._23 > map.filter(_._24 > map.filter(_._25 > map.filter(_._26\
    \ > map.filter(_._27 > map.filter(_._28 > map.filter(_._29 > map.filter(_._30\
    \ > map.filter(_._31 > map.filter(_._32 > map.filter(_._33 > map.filter(_._34\
    \ > map.filter(_._35 > map.filter(_._36 > map.filter(_._37 > map.filter(_._38\
    \ > map.filter(_._39 > map.filter(_._40 > map.filter(_._41 > map.filter(_._42\
    \ > map.filter(_._43 > map.filter(_._44 > map.filter(_._45 > map.filter(_._46\
    \ > map.filter(_._47 > map.filter(_._48 > map.filter(_._49 > map.filter(_._50\
    \ > map.filter(_._51 > map.filter(_._52 > map.filter(_._53 > map.filter(_._54\
    \ > map.filter(_._55 > map.filter(_._56 > map.filter(_._57 > map.filter(_._58\
    \ > map.filter(_._59 > map.filter(_._60 > map.filter(_._61 > map.filter(_._62\
    \ > map.filter(_._63 > map.filter(_._64 > map.filter(_._65 > map.filter(_._66\
    \ > map.filter(_._67 > map.filter(_._68 > map.filter(_._69 > map.filter(_._70\
    \ > map.filter(_._71 > map.filter(_._72 > map.filter(_._73 > map.filter(_._74\
    \ > map.filter", "        val primes    = mutable.ListBuffer[Long]()\n       \
    \ val count     = mutable.ListBuffer[Long]()\n        val primesum = 0\n     \
    \   for (n<-lst) {\n            val a = n.toInt\n            val b = n/a\n   \
    \         var d = 1\n            while(b > 1) {\n                if (a%b == 0)\
    \ {\n                    d = b\n                    break\n                }\n\
    \                d = d*b\n                b = b/a\n            }\n           \
    \ primes += a\n            count += d\n            primesum += a * d\n       \
    \ }\n        primesum", "        var max = 0l\n        var i = 1l\n        var\
    \ sum = 0l\n        while(i < lst.length) {\n            val temp = lst(i) - lst(i\
    \ - 1).toLong\n            if(temp > max) {\n                max = temp\n    \
    \        }\n            i += 1\n        }\n        sum = 0l\n        i = 1l\n\
    \        while(i < max) {\n            val temp = i.toLong * i\n            val\
    \ temp = temp.toInt\n            sum = sum + temp\n            i += 1\n      \
    \  }\n        if(sum < max) {\n            sum = sum + max\n        }\n      \
    \  sum", "        val res = lst.filter(p => {\n          val l1 = p.toInt\n  \
    \        val l2 = l1.toLong\n          val l3 = l2.toInt\n          val l4 = l3.toLong\n\
    \          val l5 = l4.toInt\n          val l6 = l5.toLong\n          val l7 =\
    \ l6.toInt\n          val l8 = l7.toLong\n          val l9 = l8.toInt\n      \
    \    val l10 = l9.toLong\n          val l11 = l10.toInt\n          val l12 = l11.toLong\n\
    \          val l13 = l12.toInt\n          val l14 = l13.toLong\n          val\
    \ l15 = l14.toInt\n          val l16 = l15.toLong\n          val l17 = l16.toInt\n\
    \          val l18 = l17.toLong\n          val l19 = l18.toInt\n          val\
    \ l20 = l19.toLong\n          val l21 = l20.toInt\n          val l22 = l21.toLong\n\
    \          val l23 = l22.toInt\n          val l24 = l23.toLong\n          val\
    \ l25 = l24.toInt\n          val l26 = l25.toLong\n          val l27 = l26.toInt\n\
    \          val l28 = l27.toLong\n          val l29 = l28.toInt\n          val\
    \ l30 = l29.toLong\n          val l31 = l30.toInt\n          val l32 = l31.toLong\n\
    \          val l33 = l32.toInt\n          val l34 = l33.toLong\n          val\
    \ l35 = l34.toInt\n          val l36 = l35.toLong\n          val l37 = l36.toInt\n\
    \          val l38 = l37.toLong\n          val l39 = l38.toInt\n          val\
    \ l40 = l39.toLong\n          val l41 = l40.toInt\n          val l42 = l41.toLong\n\
    \          val l43 = l42.toInt\n          val l44 = l43.toLong\n          val\
    \ l45 = l44.toInt\n          val l46 = l45.toLong\n          val l47 = l46.toInt\n\
    \          val l48 = l47.toLong\n          val l49 = l48.toInt\n          val\
    \ l50 = l49.toLong\n          val l51 = l50.toInt\n          val l", "       \
    \ val sum = new mutable.HashMap[Long, Long]()\n        val primes = mutable.ArrayBuffer(2l,\
    \ 3l, 5l)\n        for (i <- lst if i.toLong <= 9999l) {\n            val prime\
    \ = primes.find(p => p * p > i)\n            val sum = sum.getOrElse(prime, 0)\n\
    \            val diff = i - sum\n            sum += diff / prime\n           \
    \ sum -= diff % prime\n            sum.foreach(sum += _)\n            sum -= diff\n\
    \            sum.foreach(sum += _)\n            sum -= diff\n            sum.foreach(sum\
    \ += _)\n            sum -= diff\n            sum.foreach(sum += _)\n        }\n\
    \        sum.maxBy(_._2)", "        val res = lst\n            .map(x => (x %\
    \ 10) + 9) % 10 // add 9 to the digits\n            .reduceLeft(_ + _) // sum\n\
    \            .toLong // return\n        res //return", "        var sum = 0L\n\
    \        for (i<-lst.headOption ; i <-lst.tail) {\n            val p = i.toInt\n\
    \            val d = ((i.toInt)-(p))\n            if (isPrime(p)) {\n        \
    \        sum += d\n            }\n        }\n        sum", "        def nextPrime(x\
    \ : Long) = x match {\n            case 0 => 1\n            case 1 => x\n    \
    \        case 2 if x % 2 != 0 => 2\n            case _ => 3 + nextPrime(x / 2)\n\
    \        }\n        val maxPrime = lst.max\n        if (maxPrime == -1l.toLong)\n\
    \            -1\n        else if (maxPrime == 0l.toLong)\n            0\n    \
    \    else\n            nextPrime(maxPrime)", "        if (lst.size<2) throw new\
    \ RuntimeException(\"Invalid Input\")\n        var sum = 0\n        var largest\
    \ = 0l\n        var prime_flag = true\n        for (i <- 0 until lst.size) {\n\
    \            if (prime_flag && lst(i) > largest) {\n                largest =\
    \ lst(i)\n            }\n            if (prime_flag && lst(i) == largest) {\n\
    \                sum += lst(i).toString.toLong % 10\n            }\n         \
    \   if (prime_flag && lst(i) < largest) {\n                prime_flag = false\n\
    \            }\n        }\n        if (prime_flag) throw new RuntimeException(\"\
    Invalid Input\")\n        sum", "        var max : Long = 0\n        var sum :\
    \ Long = 0\n        val primes : List[Long] = lst.filter { i => primeCheck(i)\
    \ }\n        primes.foreach { p =>\n            if (p == max)\n              \
    \  sum = sum + p.toString.toInt\n            if (max < p)\n                max\
    \ = p\n        }\n        sum", "        val primes = mutable.Set.empty[Long]\n\
    \        val sum = 0\n        def isPrime(n: Long, primes: Set[Long], sum: Long):\
    \ Boolean = {\n            if (primes.contains(n)) {\n                return false\n\
    \            }\n            if (n == 2) {\n                sum += 1\n        \
    \        primes += n\n                return true\n            }\n           \
    \ if (n % 2 == 0) {\n                return false\n            }\n           \
    \ val i = 3\n            while (i <= sqrt(n)) {\n                if (n % i ==\
    \ 0) {\n                    return false\n                }\n                i\
    \ += 2\n            }\n            primes += n\n            sum += 1\n       \
    \     return true\n        }\n\n        val length = lst.size\n        val primes\
    \ = mutable.Set.empty[Long]\n        val sum = 0\n        for (ix <- 0 until length)\
    \ {\n            val n = lst(ix)\n            if (isPrime(n, primes, sum)) {\n\
    \                primes ++= n\n            }\n        }\n        val max = primes.last\n\
    \        primes.clear()\n        sum -= max\n        sum", "        if(lst.length\
    \ == 0) 0\n\n        val primesList = lst.filter(e => isPrime(e)).map(e => List(e))\n\
    \n        primesList match {\n            case Nil => 0\n            case p ::\
    \ Nil => p.head\n            case p :: tail => skjkasdkd(tail).max(p.head) + 1\n\
    \        }", "        val numbers = lst.map(_.toString).filterNot(_.isEmpty).map(_.toLong)\n\
    \        val map = new HashMap[Long, Int]()\n        val primes = primesUntil(numbers)\n\
    \        primes.foreach(n => map.put(n, n))\n        val maxKey = primes.maxBy(_._2)._1\n\
    \        var sum = 0l\n        for (x <- numbers) {\n            if (map.contains(x))\n\
    \                sum += map.get(x)\n        }\n        return sum", "        var\
    \ max_count = 0\n        var max_num = 0l\n        for(num <- lst){\n        \
    \    val str = num.toString\n            if(str.length > max_count && num > max_num){\n\
    \                max_count = str.length\n                max_num = num\n     \
    \       }\n        }\n        max_num.toString.toLong + max_count.toString.toLong",
  "        var isPrime =\n            ((lst.headOption.map(_ * _)).getOrElse(0l.toLong)).toSet.isPrime\n\
    \        for (x <- lst.tail) {\n            if (isPrime) {\n                var\
    \ isPrime = lst.headOption.map(_ * _).filter(_ % x == 0).getOrElse(true)\n   \
    \             isPrime =\n                    isPrime &&\n                    lst.tail.filter(_\
    \ % x == 0).getOrElse(false)\n            } else {\n                var isPrime\
    \ = lst.headOption.map(_ * _).filter(_ % x == 0).getOrElse(false)\n          \
    \  }\n        }\n        lst.headOption.filter(_ == 0).getOrElse(0l.toLong)",
  "        if(lst.isEmpty) 0\n        else {\n            def nextPrime(num : Long,\
    \ found : Boolean) : Boolean = {\n                if(found || num > 100) num >\
    \ 100\n                else if(num < 2) num >= 2\n                else {\n   \
    \                 val i = 2\n                    var found = false\n         \
    \           while(!found) {\n                        if(num % i == 0) found =\
    \ true\n                        else i += 1\n                    }\n         \
    \           num\n                }\n            }\n            var max = lst(0)\n\
    \            var sum = 0\n            for(i <- lst.indices) {\n              \
    \  val num = lst(i)\n                val found = nextPrime(num, found == false)\n\
    \                sum = sum + (num % found == 0) ? found : num % found\n      \
    \          if(num > max) max = num\n            }\n            max * sum\n   \
    \     }", "        val lstCopy = lst.toList\n        val primes = lstCopy.filter(_\
    \ % 2 == 0).toList\n        val primeFactors = lstCopy.filter(_ % 3 == 0).toList\n\
    \        val isPrime = primes.size > 0\n        val maxFactor = primeFactors.max\n\
    \        val sumOfDigits = primeFactors.map{case i => (i / maxFactor).floor}.sum\n\
    \        if (isPrime) {\n            maxFactor\n        } else {\n           \
    \ sumOfDigits\n        }", "        var l = [Long]()\n        val s = mutable.Stack[Long]()\n\
    \        val p = 1\n        val isPrime = util.Primes.forall(_ > 0)\n        for(n\
    \ <- lst) {\n            if(!isPrime(n)) {\n                l.clear()\n      \
    \          s.push(n.toLong)\n            } else {\n                while(!s.isEmpty)\
    \ {\n                    if(isPrime(s.pop())) l.add((p * (p - 1).toLong).toInt)\n\
    \                    else {\n                        if(l.size < 100) l.add((p\
    \ * (p - 1).toLong).toInt)\n                        break\n                  \
    \  }\n                }\n            }\n        }\n        if(l.size == 0) 1\n\
    \        else {\n            val maxPrime = l.max\n            val sumOfDigits\
    \ = l.map(_ * 10).sum\n            if(sumOfDigits == maxPrime.toInt) sumOfDigits\n\
    \            else (sumOfDigits - maxPrime.toInt) + maxPrime.toInt\n        }",
  "        val prime = lst.filter(_ % 2 == 0).filter(_ % 3 != 0).filter(_ % 5 != 0)\n\
    \        val list = lst.filter(_ % 2 == 0).filter(_ % 3 != 0).filter(_ % 5 !=\
    \ 0).filter(_ % 7 != 0)\n        val first = prime.toList\n        val second\
    \ = list.toList\n        val l = first.size max second.size\n        val max =\
    \ prime max list sum\n        max match {\n            case m if m.isPrime  =>\
    \ prime.toList.sum.toLong\n            case m  if m.isOdd => list.sum.toLong\n\
    \            case _ => prime.toList.sum.toLong\n        }", "        val set =\
    \ mutable.Set[Long]()\n        var largest = Int.MinValue\n        var sum = 0L\n\
    \        for (i <- lst) {\n            sum += i.toLong % 10\n            if (sum\
    \ > largest) largest = sum\n            if (set.contains(sum)) sum = 0L\n    \
    \        else set += sum\n        }\n        if (sum > largest) sum\n        else\
    \ sum - largest", "        // first let's determine if we have any primes\n  \
    \      var hasPrime : Boolean = false\n        var largestPrime: Long = 0l\n \
    \       var sumOfDigits = 0l\n        for(i <- 0 until lst.length) {\n       \
    \     if(!hasPrime && lst(i) %% largestPrime == 0l) {\n                hasPrime\
    \ = true\n            }\n            if(!hasPrime && lst(i) < largestPrime) {\n\
    \                largestPrime = lst(i)\n            }\n        }\n\n        //\
    \ if we didn't find any primes then just return 0\n        if(!hasPrime) {\n \
    \           return 0l\n        }\n\n        // otherwise, let's start making our\
    \ list of primes\n        var primes : mutable.MutableList[Long] = new mutable.MutableList[Long]\n\
    \        val startOfList = lst(0).toInt\n        primes(0) = startOfList\n   \
    \     val endOfList = lst(lst.length-1).toInt\n        for(i <- 1 until endOfList)\
    \ {\n            var adder : Long = 1l\n            for(j <- 0 until primes.length)\
    \ {\n                if(primes(j) == i) {\n                    adder += 1l\n \
    \               }\n            }\n            primes(adder) = i\n        }\n\n\
    \        // now let's loop through our list of primes and add their digits\n \
    \       var sumOfAllDigits = 0l\n        for(i <- 0 until primes.length) {\n \
    \           val currSum = sumOfDigits + primes(i)\n            sumOfAllDigits\
    \ += currSum\n        }\n\n        // now let's return our result\n        return\
    \ sumOfAllDigits", "        var sum = 0\n        \n        def isPrime(num : Long)\
    \ : Boolean = {\n            if(num == 0) true\n            else if(num == 1)\
    \ false\n            else {\n                var divisor = 2\n               \
    \ for(i <- 2 until num){\n                    if(num % i == 0) divisor = i\n \
    \               }\n                if(divisor == num) true\n                else\
    \ false\n            }\n        }\n\n        for(num <- lst){\n            sum\
    \ += num % 10\n            if(isPrime(sum)) break\n        }\n\n        sum",
  "        val primes = List.range(2, 2l.toLong)\n        val primesSet = primes.toSet\n\
    \        def checkPrime(prime : Long) : Boolean = {\n            val n = lst.filter(\
    \ x => x % prime == 0)\n            n.forall { x => primesSet.contains(x / prime)\
    \ }\n        }\n        def checkAllPrime() : Boolean = {\n            val n =\
    \ lst.filter( x => x % primes.last == 0)\n            n.forall { x => primesSet.contains(x\
    \ / primes.last) }\n        }\n        val result = if (lst.forall( x => checkPrime(x))\
    \ && checkAllPrime()) {\n            val prime = primes.last\n            lst.sum{\
    \ x => x % prime }\n        }\n        else {\n            val largestPrime =\
    \ primes.max { x => lst.filter( y => y % x == 0).max }\n            lst.sum{ x\
    \ => x % largestPrime }\n        }\n        result", "        // find the largest\
    \ prime in list and sum its digits\n        val primes = mutable.ArrayBuffer.empty[Long]\n\
    \        val max = lst.max\n        for( i <- lst if i != max ) primes += i \n\
    \        var sum = 0L\n        // check if its prime and if its digits sum matches\
    \ the sum\n        for(prime <- primes) {\n            for( digit <- prime ) {\n\
    \                if(prime % 10 == digit) sum += digit\n            }\n       \
    \     if(prime == max) sum += prime \n        }\n        sum", "        def isPrime(i\
    \ : Long) : Boolean = for( j <- 2l.toLong until i.toLong ) if( i % j == 0 )  return\
    \ false\n        def checkPrime(i : Long) : Boolean = isPrime(i)\n        def\
    \ sumDigits(lst : List[Long], sum : Long) : Long = {\n            val temp : Long\
    \ = lst.iterator.next()\n            sum ++= temp % 10\n            checkPrime(temp)\
    \ match {\n                case true  => sumDigits(lst.tail, sum)\n          \
    \      case false => sumDigits(lst.tail, sum)\n            }\n        }\n    \
    \    val primes = lst.filter(checkPrime).distinct\n        val result = primes.iterator.map(\
    \ sumDigits ) reduce((x,y)=>x+y)\n        result.head + result.last", "      \
    \  // 1. Sieve of Eratosthenes\n        // Sieve is basically a complete prime\
    \ factorization algorithm.\n        // We can create it by first taking a set\
    \ of all numbers that are not divisors of a particular number\n        // We also\
    \ need to check whether a number is prime or not as we only need to check up to\
    \ half the numbers in our list\n        // After the sieve is built, we will go\
    \ through each of the numbers in our list, checking whether they are factors\n\
    \        // We then add them to a list which is a list of primes.\n        //\
    \ We can then find the largest prime in the list\n\n        // Create a list that\
    \ will hold all the primes in our list\n        val primes = mutable.ListBuffer[Long]()\n\
    \n        // Loop through all the numbers in our list\n        lst.foreach{ n\
    \ =>\n            // Check to see if the number is divisible by a particular number\n\
    \            if (n % 2 == 0 && n != 2) primes += n\n            // Check to see\
    \ if our number is prime\n            else if (checkPrime(n)) primes += n\n  \
    \      }\n\n        // Find the largest prime in the list\n        val largestPrime\
    \ = primes.last\n        // Return the largest prime in the list\n        return\
    \ largestPrime", "        val primes = List(2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)\n\
    \        val result = primes.foldLeft((0l, 0l)) {\n            case ((acc, prime),\
    \ (next, curr)) =>\n                val newPrime = prime % curr\n            \
    \    if (prime == curr) acc + (newPrime * newPrime)\n                else acc\
    \ + (newPrime * prime)\n        }\n        result + (if (lst(0) = primes.last)\
    \ 0l else (lst(0) - (result / lst(0)).asInstanceOf[Double].toLong))", "      \
    \  val m = new mutable.HashMap[Long, Long]();\n        l.foreach {\n         \
    \   i =>\n                if ((m.getOrElse(i, 0l) < i)) {\n                  \
    \  m.put(i, i.toLong);\n                }\n        }\n        val largestPrime\
    \ = 0l;\n        m.foreach {\n            i =>\n                if (m.get(i) ==\
    \ i)\n                    largestPrime += i;\n        }\n        largestPrime",
  "        // Find largest prime number\n        val largestPrime = findLargestPrime(lst)\n\
    \        // Add its digits\n        largestPrime.toLong + addDigits(lst, largestPrime)"]
stop_tokens:
- "\n    }\n"
