name: HumanEval_11_string_xor
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform\
  \ binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"\
  010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String)\
  \ : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
  ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
  0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n   \
  \ }\n\n}\n"
completions: ["        // If length of both strings are same, return empty string\
    \ immediately\n        if (a.length == b.length){\n            return \"\"\n \
    \       }\n        val xor = mutable.StringBuilder(a.length)\n        for (i <-\
    \ 0 to (a.length - 1)) {\n            xor(i) = if (a(i) == '1') '0' else '1'\n\
    \            xor(i + 1) = if (b(i) == '1') '0' else '1'\n        }\n        xor.toString()",
  "        val a1 = a.toCharArray\n        val b1 = b.toCharArray\n        val ret\
    \ = new StringBuilder\n        val m = Math.min(a.length(), b.length)\n      \
    \  for( i <- 0 until m) {\n            ret.append(a(i) ^ b(i))\n        }\n  \
    \      return ret.toString", "        val listA = a.toIntList\n        val listB\
    \ = b.toIntList\n        val listAB = listA.zip(listB).toList\n        val res\
    \ = listAB.map{ case (aa, bb) => (aa xor bb).asInstanceOf[Int].toString }\n  \
    \      val res = res.filter(_.isDigit)\n        val res = res.reverse.mkString\n\
    \        res", "        val aBits = a.toInt\n        val bBits = b.toInt\n   \
    \     var result : String = \"\"\n        var carry = 0\n        for (i <- 0 until\
    \ aBits.length){\n            if (carry > 0){\n                result = result\
    \ + carry.toString\n            }\n            val cBits = aBits.apply(i).xor(bBits.apply(i))\n\
    \            if (cBits > 0){\n                result = result + cBits.toString\n\
    \            }\n            if (cBits == 0){\n                carry = 1\n    \
    \        }\n            else {\n                carry = 0\n            }\n   \
    \     }\n        result", "        val aList = a.toIntList.map(_.toInt)\n    \
    \    val bList = b.toIntList.map(_.toInt)\n        val xorResult = aList.zip(yList).filter(_._1\
    \ == 0).map(_._2).mkString\n        val andResult = aList.zip(yList).filter(_._1\
    \ == 1).map(_._2).mkString\n        val finalResult = xorResult + andResult\n\
    \        finalResult", "        val xa = a.toList\n        val xb = b.toList\n\
    \        xa zip xb map { a => a._1 xor a._2 } toList.toString()", "        val\
    \ map = scala.collection.mutable.Map[Char, Int]()\n        var ans = \"\"\n  \
    \      var index = 0\n        while(a.charAt(index) != \"0\" && a.charAt(index)\
    \ != \"1\" && index < a.length){\n            index += 1\n        }\n        while(b.charAt(index)\
    \ != \"0\" && b.charAt(index) != \"1\" && index < b.length){\n            index\
    \ += 1\n        }\n        if(index >= a.length){\n            ans = \"0\"\n \
    \       } else {\n            map.put(a.charAt(index), 1)\n        }\n       \
    \ if(index >= b.length){\n            ans = \"0\"\n        } else {\n        \
    \    map.put(b.charAt(index), 1)\n        }\n        val keys = map.keys.toList\n\
    \        val values = map.values.toList\n        for( i <- keys){\n          \
    \  val temp = scala.math.pow(2,i)\n            val answer = values.take(temp).reduce(_\
    \ + _) match {\n                case x if x < ans.length => {\n              \
    \      ans\n                }\n                case x => {\n                 \
    \   ans\n                }\n            }\n            val sum = ans.split(\"\"\
    ).map(x => if (x.toInt == answer) 1 else 0).sum\n            ans = sum\n     \
    \   }\n        ans", "        val aSet = a.toSet\n        val bSet = b.toSet\n\
    \        val result = new mutable.HashMap[Int, Int]()\n        val n = a.length\n\
    \        val m = b.length\n        var x = aSet.length\n        var y = bSet.length\n\
    \        while (x != 0 || y != 0) {\n            val d = (x * y) % n\n       \
    \     val l = aSet(d)\n            val r = bSet(d)\n            result.put(d,\
    \ r)\n            x -= 1\n            y -= 1\n        }\n        result.values.toList\n\
    \            .sorted.mkString(\"\")", "        val m = a.length\n        val n\
    \ = b.length\n        if(m > n) {\n            throw new IllegalArgumentException\n\
    \        } else {\n            val l = mutable.ArrayBuffer.empty[String]\n   \
    \         while(m > 0) {\n                if(a(m - 1) != b(n - 1)) {\n       \
    \             l(l.get.length - 1) = a(m - 1) ^ b(n - 1)\n                }\n \
    \               m--\n                n--\n            }\n            val rm =\
    \ m.min(l)\n            val ln = l.length\n            val rn = r.length\n   \
    \         val r = scala.util.Right.fromString(l.take(rm).mkString(\"\"), 0, rm)\n\
    \            val l = scala.util.Left.fromString(l.take(ln).mkString(\"\"), 0,\
    \ ln)\n            l.right(l.length - r)\n        }", "        val res = a.zip(b).foldLeft[String](\"\
    0\"){\n            case (res, (a, b)) => res + (\"1\" XOR \"0\" XOR ((a XOR b)\
    \ toInt))\n        }\n        res", "      val aBits = a.toInt.map(x => if (x\
    \ == '1') 1 else 0)\n      val bBits = b.toInt.map(x => if (x == '1') 1 else 0)\n\
    \      val result = new Array[Int](aBits.length+bBits.length).init\n      result.zip(Array.tabulate(bBits.length)(_+_)).foreach\
    \ { case (r, i) =>\n        val aBitsDiff = i.toInt - aBits.length\n        val\
    \ bBitsDiff = i.toInt - bBits.length\n        for ( i <- 0 until aBits.length;\
    \ )\n        {\n          if (i < aBitsDiff) {\n            result(i) = aBits(i)\n\
    \            i += 1\n          } else if (i < aBitsDiff+bBitsDiff) {\n       \
    \     result(i) = 0\n            i += 1\n          } else {\n            result(i)\
    \ = 0\n          }\n        }\n        for ( i <- 0 until bBits.length; )\n  \
    \      {\n          if (i < bBitsDiff) {\n            result(i) = bBits(i)\n \
    \           i += 1\n          } else if (i < bBitsDiff+aBitsDiff) {\n        \
    \    result(i) = 0\n            i += 1\n          } else {\n            result(i)\
    \ = 0\n          }\n        }\n      }\n      result.reverse.mkString.reverse.stripPrefix(\"\
    0\")", "        var x = 0\n        var y = 0\n        var z = 0\n        var newString\
    \ = \"\"\n        for (i<-0 to a.length-1) {\n            x = a(i).toInt\n   \
    \         y = b(i).toInt\n            z = (x XOR y).toInt\n            newString\
    \ = newString + Integer.toBinaryString(z)\n        }\n        return newString",
  "        val result = new StringBuilder\n        val latch = new CountDownLatch(2)\n\
    \        val taskA = Future {\n            val pair1 = a.split(\"\")\n       \
    \     val pair2 = b.split(\"\")\n            var sum = 0\n            pair1.zipWithIndex.foreach{\
    \ case (x, i) =>\n                sum += (x.toInt == pair2(i).toInt)\n       \
    \     }\n            latch.countDown()\n            sum\n        }\n        val\
    \ taskB = Future {\n            val pair1 = a.split(\"\")\n            val pair2\
    \ = b.split(\"\")\n            var sum = 0\n            pair2.zipWithIndex.foreach{\
    \ case (x, i) =>\n                sum += (x.toInt == pair1(i).toInt)\n       \
    \     }\n            latch.countDown()\n            sum\n        }\n        latch.await()\n\
    \        taskA onComplete { case result => result.foreach(x => result.append(x))\
    \ }\n        taskB onComplete { case result => result.foreach(x => result.append(x))\
    \ }\n        result.toString", "        val a = a.toInt\n        val b = b.toInt\n\
    \        val xor = (a^b).asInstanceOf[String]\n        return xor", "        var\
    \ c = 0\n        for(i <- a.indices) c += (if (b(i) == \"0\") 1 else 0)\n    \
    \    for(i <- b.indices) c += (if (a(i) == \"0\") 1 else 0)\n        c + a.size\
    \ + b.size", "        val aLength = a.length\n        val bLength = b.length\n\
    \n        if (aLength != bLength) {\n            throw new IllegalArgumentException(\"\
    Both arguments should have the same length.\")\n        }\n\n        if ( (a ==\
    \ \"0\") || (b == \"0\") ) {\n            return \"0\"\n        }\n\n        var\
    \ result = \"\"\n\n        for (i<- 0 until aLength) {\n            val left =\
    \ a.charAt(i)\n            val right= b.charAt(i)\n            result += \"1\"\
    \ if ((left == \"0\") || (right == \"0\")) else\n                         \"0\"\
    \ if ((left == \"1\") || (right == \"1\")) else\n                         throw\
    \ new IllegalArgumentException(\"The arguments should have the same length.\"\
    )\n        }\n\n        return result", "        var ans = \"\"\n        var i\
    \ = 0\n        var j = 0\n        while(i < a.length && j < b.length){\n     \
    \       ans += (a(i) XOR b(i)) +\n                   if(i < a.length) a(i += 1)\
    \ else \"\"\n            if(j < b.length) ans += b(i) XOR \"\"\n        }\n  \
    \      ans", "        val a = a.toInt\n        val b = b.toInt\n        val result:\
    \ StringBuilder = new StringBuilder\n        var carry = 0\n        var x = 1\n\
    \        var y = 0\n        while (a != 0 || b != 0) {\n            val aDigit\
    \ = if (a != 0) a else 0\n            val bDigit = if (b != 0) b else 0\n    \
    \        val sum = carry + aDigit + bDigit\n            result += Integer.toBinaryString(sum)\n\
    \            carry = (sum / 2)\n            x += 1\n            y += 1\n     \
    \   }\n        result += Integer.toBinaryString(carry)\n        result += Integer.toBinaryString(x\
    \ % 2)\n        result += Integer.toBinaryString(y % 2)\n        result.toString",
  "        var result = new StringBuilder\n\n        var a = a.toIntArray()\n    \
    \    var b = b.toIntArray()\n        var resultIndex = 0\n\n        for (i <-\
    \ 0 until a.length) {\n            val xor = a(i) xor b(i)\n            result(resultIndex)\
    \ = xor.asInstanceOf[Char].toString\n            resultIndex += 1\n        }\n\
    \        result.toString", "        var c = 0\n        for(i <- 0 until a.length)\n\
    \            c += toInt(a(i) ^ toInt(b(i)))\n        val result = (new StringBuilder).append(toChar(c))\n\
    \        return result.toString()", "        assert(a.length == b.length, \"stringXor\
    \ must operate on strings of equal length.\")\n        val aInts = a.grouped(2).map(_.toInt)\n\
    \        val bInts = b.grouped(2).map(_.toInt)\n        val xor: mutable.WrappedArray[Int]\
    \ = mutable.WrappedArray.empty[Int]\n        for (i <- 0 until a.length) {\n \
    \           for (j <- 0 until b.length) {\n                val xorI = i + j\n\
    \                val xorJ = i + j + 1\n                val xorIJ = i + j + 2\n\
    \                // if either input string is too short, pad out with 0's.\n \
    \               if ((xorI < a.length) && (xorJ < b.length)) {\n              \
    \      xor.push(aInts(xorI) xor bInts(xorJ))\n                } else if ((xorIJ\
    \ < aInts.length) && (xorIJ < bInts.length)) {\n                    xor.push(aInts(xorIJ)\
    \ xor bInts(xorJ))\n                } else {\n                    xor.push(aInts(i)\
    \ xor bInts(j))\n                }\n            }\n        }\n        new String(xor.mkString(\"\
    \"))", "        var result = new StringBuilder\n        var c = 0\n        var\
    \ i = 0\n        var k = 0\n        while(i < a.length && k < b.length) {\n  \
    \          c += (scala.util.Char.digit(a(i), 2) XOR scala.util.Char.digit(b(k),\
    \ 2))\n            i += 1\n            k += 1\n        }\n        while(i < a.length)\
    \ {\n            c += (scala.util.Char.digit(a(i), 2))\n            i += 1\n \
    \       }\n        while(k < b.length) {\n            c += (scala.util.Char.digit(b(k),\
    \ 2))\n            k += 1\n        }\n        result.append(scala.util.Char.chr((c)\
    \ XOR '0'))\n        return result.toString()", "        val aList = a.toList\n\
    \        val bList = b.toList\n        var result = \"\"\n        val aLength\
    \ = a.length\n        val bLength = b.length\n        aList.foreach(x => bList.foreach(y\
    \ => result += if (x == y) \"1\" else \"0\"))\n        result", "        val aBytes\
    \ = a.toIntArray\n        val bBytes = b.toIntArray\n        var x = 0\n     \
    \   var y = 0\n        var result : String = \"\"\n\n        while (aBytes.exists(x\
    \ => x != 0))\n        {\n            y = 0\n            while (b.exists(y =>\
    \ y != 0))\n            {\n                x = x ^ y\n                y = y +\
    \ 1\n            }\n            result = result + x.toBinaryString\n         \
    \   x = x + 1\n        }\n        return result", "        val result = a.toInt\
    \ ^ b.toInt\n        val res = new StringBuilder\n        for(i <- 0 until result.toInt)\
    \ res.append(if (result == i) \"1\" else \"0\")\n        res.result()", "    \
    \    val aList = a.split('')\n        val bList = b.split('')\n        val output\
    \ = new StringBuilder\n        \n        val aSet = Set(aList).map(_.toInt)\n\
    \        val bSet = Set(bList).map(_.toInt)\n        \n        val xor = new mutable.HashMap[Int,\
    \ Int]()\n        \n        for (i<- 0 until aList.length) {\n            xor(aList(i),\
    \ bList(i) match {\n                case 0 =>\n                case 1 =>\n   \
    \             val i = aList(i) xor (bList(i))\n                xor.put(i + 1,\
    \ i)\n            })\n        }\n        \n        val result = xor.map(x=> (x._2,\
    \ x._1)).filter(_._1 > 0).map(_._2).mkString\n        output.append(result)\n\
    \        return output.toString", "        val x = Array(a,b)\n        val y =\
    \ Array.ofDim[Char](2)\n        x.zipWithIndex.map { case (z, i) =>\n        \
    \    z.toCharArray.map(x => x(0) ^ x(1))\n        }.reduce(_++_).mkString", " \
    \       val aArray = a.toCharArray\n        val bArray = b.toCharArray\n     \
    \   var res = \"\"\n        aArray.zip(bArray).foreach{ case (b,a) => res += (a\
    \ ^ b) }\n        res", "        // Using mutable HashMap in order to avoid using\
    \ mutable states in loops\n        // The HashMap will contain the keys and the\
    \ corresponding value will store \n        // the result\n        val hm = new\
    \ mutable.HashMap[Char, Char]\n        for(c <- a) hm.put(c.toInt, c.toInt)\n\
    \        for(c <- b) hm(c) = hm(c) ^ c.toInt\n        // The values stored in\
    \ the HashMap will be stored in an ordered array\n        val resultList = hm.values.toList\n\
    \        // We convert these values into string\n        resultList.map(c => c.toString.reverse).mkString(\"\
    \")", "        val bina: List[String] = a.split(\"\").filter(c => c != \"0\").toList\n\
    \        val binb: List[String] = b.split(\"\").filter(c => c != \"0\").toList\n\
    \        bina.zipAll(binb, 0 , \"0\") map {\n        case (a, b, c) => \"1\" +\
    \ ((a xor b) xor c)\n        } mkString \"\"", "        val res = a.toCharArray\n\
    \        val res2 = b.toCharArray\n        for (x<-0 until a.length by 2) {\n\
    \            res(x) ^ res2(x)\n        }\n        new String(res).reverse", " \
    \       val aStr : String = a;\n        val bStr : String = b;\n        // Write\
    \ your code here\n        var retVal : String = null\n        var i = 1\n    \
    \    var j = 1\n        while(i <= (aStr.length / 2)) {\n            while(j <=\
    \ (bStr.length / 2)) {\n                if(aStr(i-1) == bStr(j-1)) {\n       \
    \             retVal += aStr(i)\n                    retVal += bStr(j)\n     \
    \               i++\n                    j++\n                } else if(aStr(i-1)\
    \ != bStr(j-1)) {\n                    retVal += aStr(i)\n                   \
    \ retVal += bStr(j)\n                    i++\n                }\n            \
    \    j++\n            }\n            i++\n            j = 1\n        }\n     \
    \   retVal", "        def xor(aStr : String, bStr : String): String = {\n    \
    \        val aVals = aStr.split(\"\\\\W+\").map(_.toInt)\n            val bVals\
    \ = bStr.split(\"\\\\W+\").map(_.toInt)\n            val resultVals = aVals.zip(bVals).map(x\
    \ => if (x._1 ^ x._2) x._0 else 0)\n            return resultVals.map(_.toString.toChar).mkString(\"\
    \")\n        }\n        xor(a, b)", "        val x = a.toInt\n        val y =\
    \ b.toInt\n        val xorResult = scala.util.Random.nextInt(256) match {\n  \
    \          case x if x > y => 255\n            case x if x < y => 0\n        \
    \    case _ => x + y\n        }\n        xorResult match {\n            case x\
    \ if x > 0 => (a xor (b .& 0xFF)).toChar.toString\n            case x if x < 0\
    \ => ((a .& 0xFF) xor (b .& 0xFF)).toChar.toString\n            case _ => a.toChar.toString\n\
    \        }", "        val bit = scala.collection.mutable.StringBuilder()\n   \
    \     for {\n            i <- 0\n            c <- \"010\"\n        } yield {\n\
    \            if (a(i + (bit.length / 2)) != \"1\") bit.append(\"0\")\n       \
    \     if (b(i + (bit.length / 2)) != \"1\") bit.append(\"0\")\n            bit.append(\"\
    1\") \n        }\n        if (bit.length == 1) bit.toString\n        else bit.take(bit.length\
    \ - 1).mkString() + bit.last", "        val a0 = a(0).toInt\n        val a1 =\
    \ a(1).toInt\n        val a2 = a2(1).toInt\n        val b0 = b(0).toInt\n    \
    \    val b1 = b(1).toInt\n        val b2 = b(2).toInt\n        var res  = \"0000\"\
    \n        val x = ((b0+b1+b2)&0x0000FF).toInt\n        val y = ((a0+a1+a2)&0x0000FF).toInt\n\
    \        val z = (x ^ y).toInt\n        res = res.substring(0, z) + Integer.toString(z)\n\
    \        res", "        val a = a.toInt\n        val b = b.toInt\n        var\
    \ res = a\n        var carry = 0\n        for (aDigit <- 0 to a.length - 1)\n\
    \            if ((aDigit & (1 << (a.length - aDigit - 1))) != 0)\n           \
    \     carry = (carry + ((a(aDigit - 1) ^ b(aDigit))) / 2)\n            else\n\
    \                carry = 0\n            res = ((res + carry) % 2).toString\n \
    \       if (res.length == 1) res = \"0\" + res\n        res", "        val aMap\
    \ = new mutable.HashMap[Int, Int]()\n        val bMap = new mutable.HashMap[Int,\
    \ Int]()\n        a.map(x => aMap.update(x.toInt, aMap.getOrElse(x.toInt, 0)))\n\
    \        b.map(x => bMap.update(x.toInt, bMap.getOrElse(x.toInt, 0)))\n      \
    \  var res = new Array[Int](a.size)\n        var idx = 0\n        while (idx <\
    \ a.size) {\n            if (aMap(idx) == 0)\n                res(idx) = bMap(idx)\n\
    \            else res(idx) = aMap(idx) ^ bMap(idx)\n            idx += 1\n   \
    \     }\n        new String(res)", "        var result = 0\n        for (i <-\
    \ 0 until a.length)\n            for (j <- 0 until b.length)\n               \
    \ result = result + ((Character.getNumericValue(b.charAt(j))) ^\n            \
    \            (Character.getNumericValue(a.charAt(i))))\n        return result.toString",
  "        val a = a.map(_.toInt)\n        val b = b.map(_.toInt)\n        val d =\
    \ a.zip(b)\n        val z = d.map(x=>x(0) * x(1))\n        val e = z.map(x=>String.valueOf(x))\n\
    \        val f = e.map(x=>String.valueOf(x))\n        a.zip(b.toList).flatMap(x\
    \ => f(x)).toList.toString", "        var xor = new StringBuilder\n        for\
    \ (i <- a.indices) {\n            xor.append(a(i) ^ b(i))\n        }\n       \
    \ xor.toString()", "        // Your code goes here\n        var firstInt = a.toInt\n\
    \        var secondInt = b.toInt\n        var result = \"\"\n        for (i<-0\
    \ until firstInt.length)\n            result+= (firstInt(i) != secondInt(i) ?\
    \ \"1\" : \"0\")\n        result", "        var result = \"\"\n        for (i\
    \ <- 0 until a.length; j <- 1 until b.length) {\n            val x = a(i) - b(j)\n\
    \            if (x == 0 && i != a.length-1)\n                result = \"0\"\n\
    \            if (x == 1 && j != b.length-1)\n                result = \"1\"\n\
    \        }\n        result", "        def xor(a: String, a: String): String =\
    \ {\n            if (a.length != b.length) {\n                throw new ArithmeticException(\"\
    invalid input\")\n            }\n            var result = \"\"\n            for\
    \ (i <- 0 until a.length) {\n                result += (a(i) xor b(i)).toString\n\
    \            }\n            result\n        }\n        xor(a, b)", "        //\
    \ Make a string containing each individual char from input strings\n        //\
    \ and convert them to binary numbers as string\n        val aBinStr = (for (i\
    \ <- a.toList) yield Integer.toBinaryString(i)).mkString(\"\") \n        val bBinStr\
    \ = (for (i <- b.toList) yield Integer.toBinaryString(i)).mkString(\"\")\n   \
    \     // Perform XOR on strings and return as binary strings\n        val res\
    \ = aBinStr.zip(bBinStr).map(x => x._1 XOR x._2).toList.map(Integer.toBinaryString).mkString(\"\
    \")\n        // Convert back to string and return results\n        res", "   \
    \   // Convert strings to bit strings\n      val a = bitStringToInts(a)\n    \
    \  val b = bitStringToInts(b)\n      \n      // Perform bit XOR on all bit strings\
    \ and convert to string.\n      val xorBits = zip(a, b).map(x => x._1 ^ x._2)\n\
    \      val bitStrings = xorBits.map(x => x.toString(2)).map(x => if (x == '1')\
    \ x else ('0'))\n      val result = bitStrings.mkString(\"\")\n      result",
  "        var res : String = b.size\n        val a = a.toIntArray\n        val b\
    \ = b.toIntArray\n        val size = a.length\n        for (i <- 0 until size)\
    \ {\n            res += (a(i) xor b(i))\n        }\n        return res.reverse",
  "        val aLen = a.length\n        val bLen = b.length\n        val aChars =\
    \ a.toCharArray\n        val bChars = b.toCharArray\n        val cArray = Array.ofDim[Int](aLen,\
    \ bLen)\n        for ((i, aIdx) <- 0 until aLen, bIdx <- 0 until bLen)\n     \
    \   cArray(aIdx, bIdx) = a(aIdx) xor b(bIdx)\n        new String(cArray)", " \
    \       val a = scala.collection.immutable.BitSet.parse(a).toList\n        val\
    \ b = scala.collection.immutable.BitSet.parse(b).toList\n        val r = new scala.collection.mutable.StringBuilder\n\
    \        for {\n            i <- a\n            j <- b\n        } r.append(i xor\
    \ j)\n        r.result()", "        // Write your code here\n        val a1 =\
    \ a.toInt\n        val b1 = b.toInt\n        val result = (a1 ^ b1) + ((a1 & b1)\
    \ > 0)\n        result + if (a1 & b1 > 0) \"1\" else \"0\"", "        val aArray\
    \ = a.toCharArray\n        val bArray = b.toCharArray\n        var res = \"\"\n\
    \        for (i <- 0 until a.length)\n            res +=  a(i) ^ b(i) \n     \
    \   res", "      var c = 0\n      for( i <- 0 until a.length ) {\n         if(\
    \ a(0) XOR b(i) == a(0) ) c += 1\n      }\n      val str = if (c>0) b.take(c)\
    \ else b\n      str + str.tail", "        var a1 = a.toIntArray\n        var b1\
    \ = b.toIntArray\n        var res = []\n        var i = a.length\n        var\
    \ j = b.length\n        while (i > 0 || j > 0) {\n            if (i==0) res.append(a1.head)\n\
    \            else if (j==0) res.append(b1.head)\n            else {\n        \
    \        if (a1.head^b1.head < 0) res.append(a1.head)\n                else res.append(b1.head)\n\
    \            }\n            i -= 1; j -= 1\n        }\n        return res.mkString(\"\
    \")", "        var ans = \"\"\n        var i = 0\n        var j = 0\n        while(i\
    \ < a.length) {\n            ans = ans + \"0\"\n            i += 2\n        }\n\
    \        while(j < b.length) {\n            ans = ans + \"1\"\n            j +=\
    \ 2\n        }\n        while(i < a.length) {\n            ans = ans + \"0\"\n\
    \            i += 2\n        }\n        while(j < b.length) {\n            ans\
    \ = ans + \"1\"\n            j += 2\n        }\n        return ans", "       \
    \ // Initialize final string\n        val finalString = new mutable.StringBuilder\n\
    \        // Iterate over characters in both inputs\n        for (a <- a) {\n \
    \           for (b <- b) {\n                // If character are different append\
    \ them into final string\n                if (a != b)\n                    finalString.append(a\
    \ ^ b)\n            }\n        }\n        return finalString.toString", "    \
    \    def xor(x : Int, y : Int) : Int = {\n            x xor y match {\n      \
    \          case 0 => x\n                case _ => 0\n            }\n        }\n\
    \        val length = a.length\n        val resultLen = length * 2\n        val\
    \ aArray = a.toList\n        val bArray = b.toList\n        val xorValue = new\
    \ Array[Int](resultLen)\n        val buffer = new Array[Int](resultLen)\n    \
    \    for (i<- 0 to length-1){\n            buffer[(i * 2)] = xor(aArray(i), bArray(i))\n\
    \        }\n        buffer.foreach(xorValue)\n        xorValue.map(x => x % 2).mkString.reverse.charAt(0)",
  "        val res = a.zip(b).map {\n            case (aChar, bChar) => aChar ^ bChar\n\
    \        }.foldLeft(\"\") { (res, elem) => res + elem.toString }\n        res\
    \ + \"0\"", "        val a = a.toInt * 2\n        val b = b.toInt * 2\n      \
    \  (a XOR b) XOR a", "        val aLen = a.length()\n        val bLen = b.length()\n\
    \        var aIndex = 0\n        var bIndex = 0\n        var xorResult = 0\n \
    \       while(true) {\n            xorResult = xorResult + (a.charAt(aIndex) xor\
    \ b.charAt(bIndex))\n            if (aIndex == aLen-1) && bIndex == bLen-1) {\n\
    \                xorResult.toString\n            }\n            if (aIndex ==\
    \ aLen-1) { aIndex = 0 }\n            if (bIndex == bLen-1) { bIndex = 0 }\n \
    \       }", "        val aNum = a.toInt :: Nil\n        val bNum = b.toInt ::\
    \ Nil\n        var result : String = \"\"\n\n        var xorValue : Int = 0\n\
    \        var xorMask = 0\n        var xorSum = 0\n        for(z <- aNum) {\n \
    \           xorValue = z\n            for(h <- bNum) {\n                xorMask\
    \ = h\n                xorSum = xorValue ^ xorMask\n                result +=\
    \ if(xorSum == 0) \"0\" else if(xorSum == 1) \"1\" else \"?\"\n              \
    \  xorValue := xorValue >> 1\n                xorMask := xorMask >> 1\n      \
    \      }\n        }\n        result", "        val result = (a zip b) map { case\
    \ (x, y) => x ^ y } map {\n            case 1 => \"1\"\n            case 0 =>\
    \ \"0\"\n            case _ => \"\"\n        }\n        result.mkString(\"\")",
  "        val ba = a.toInt\n        val bb = b.toInt\n        val c = ba.xor(bb)\n\
    \        Integer.toBinaryString(c)", "        // Convert input strings to an array\
    \ of integers\n        var a = a.toIntArray\n        var b = b.toIntArray\n  \
    \      var res = new Array[Int](b.length)\n        var carry = 0\n        // XOR\
    \ each number in each array\n        for (i <- 0 until a.length) {\n         \
    \   res(i) += a(i) XOR b(i) XOR carry\n            carry = res(i) mod 2\n    \
    \    }\n        // Convert result array to string\n        res(0 until a.length).map(\"\
    %02d\".format(_)).mkString", "        val arrayA = a.map(x => (x: Int)).toArray\n\
    \        val arrayB = b.map(x => (x: Int)).toArray\n        var result = \"\"\n\
    \        for (i <- 0 until arrayA.size) {\n            result = (result + arrayA(i)\
    \ xor arrayB(i)).toString() + \" \"\n        }\n        result", '      a.toCharArray.zip(b.toCharArray).map(c
    => Integer.parseInt(c._1^c._2)).mkString', "        var ret = \"\"\n        var\
    \ carry = 0\n        for ((x, y) <- a.zip(b)) {\n            val bin = Integer.parseInt(x)\
    \ + Integer.parseInt(y) + carry\n            val result = if(bin > 1) bin else\
    \ bin - 2\n            carry = result / 2\n            ret = ret + Integer.toString(result)\n\
    \        }\n        if(!carry)\n            ret += \"0\"\n        ret", "    \
    \    val listA = a.toIntArray.map(x => if (x == 1) 1 else 0)\n        val listB\
    \ = b.toIntArray.map(x => if (x == 1) 1 else 0)\n        var result = \"\"\n \
    \       for (i <- 0 until listA.length) result += listA(i) XOR listB(i)\n    \
    \    return result", "        val mapA = (a :+ \"\").groupBy(x => x)\n       \
    \ val mapB = (b :+ \"\").groupBy(x => x)\n        val mapC = mapA.intersect(mapB)\n\
    \        val mapD = mapC.map(x => (x._1._1, x._2.length)).toMap\n        val mapE\
    \ = mapD.filter(_._2 > 1)\n        val mapF = mapE.map(x => (x._1, x._2.length))\n\
    \        val mapG = mapE.filter(x => x._2.length > 1)\n        val mapH = mapG.map(x\
    \ => (x._1, x._2.length))\n        val mapI = mapH.filter(_._2 > 1)\n        val\
    \ mapJ = mapI.map(x => (x._1, x._2.length))\n        val mapK = mapJ.filter(x\
    \ => x._2 > 1)\n        val mapL = mapK.map(x => (x._1, x._2.length))\n      \
    \  val mapM = mapL.filter(_._2 > 1)\n        val mapN = mapM.map(x => (x._1, x._2.length))\n\
    \        val mapO = mapN.filter(x => x._2.length > 1)\n        val mapP = mapO.map(x\
    \ => (x._1, x._2.length))\n        val mapQ = mapP.filter(x => x._2 > 1)\n   \
    \     val mapR = mapQ.map(x => (x._1, x._2.length))\n        val mapS = mapR.filter(_._2\
    \ > 1)\n        val mapT = mapS.map(x => (x._1, x._2.length))\n        val mapU\
    \ = mapT.filter(x => x._2 > 1)\n        val mapV = mapU.map(x => (x._1, x._2.length))\n\
    \        val mapW = mapV.filter(_._2 > 1)\n        val mapX = mapW.map(x => (x._1,\
    \ x._2.length))\n        val mapY = mapX.filter(x => x._2 > 1)\n        val mapZ\
    \ = mapY.map(x => (x._1, x._2.length))\n        val mapAA = mapZ.filter(x => x._2\
    \ > 1)\n        val mapAB = mapAA.map(x => (x._1, x._2.length))\n        val mapAC\
    \ = mapAB.filter(x => x._2 > 1)\n        val mapAD = mapAC.map(x => (x._1, x._2.length))\n\
    \        val mapAE = map", "        val a = Array(a.split(\"0\"))\n        val\
    \ b = Array(b.split(\"0\"))\n        var ans = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            val temp = ans + a(i) XOR b(i)\n            ans = temp\n\
    \        }\n        ans", "        var xor = 0\n        var a = a.toCharArray\n\
    \        var b = b.toCharArray\n        a.zip(b).foreach(x => xor ^= x._1)\n \
    \       String.fromCharArray(xor.toList)", "        val set1 = a.toIntSet\n  \
    \      val set2 = b.toIntSet\n        val result = new mutable.MutableSet[Int]()\n\
    \        var carry = 0\n        for (i <- set1 union set2) {\n            if ((i\
    \ & carry) == 0) {\n                result += i\n            } else {\n      \
    \          carry = 1\n            }\n        }\n        result.toString.reverse",
  "        val xor_map = new mutable.HashMap[String, String]()\n        a.zip(b).foreach\
    \ { case (x, y) => \n            xor_map(x) = y\n        }\n        val result\
    \ = xor_map.values.mkString\n        xor_map.clear\n        result", "       \
    \ val resultSet = mutable.Set.empty[Char]\n        for( c1 <- a ; c2 <- b ) {\n\
    \            if( c1 == c2 ) {\n                resultSet += c1\n            }\
    \ else {\n                resultSet += c2\n            }\n        }\n        new\
    \ String(resultSet.toSeq)", "        val length = Math.min(a.length, b.length)\n\
    \        val zeros = Array.ofDim[Int](length)\n        val ones = Array.ofDim[Int](length)\n\
    \        val aLen = a.length - 1\n        val bLen = b.length - 1\n        (0\
    \ until length).map { i => if (a(i) == b(i)) ones(i) = 1 else if (a(i) != b(i))\
    \ zeros(i) = 1 }\n        (0 until length).map { i => if (aLen == 0 && bLen >\
    \ i) ones(i) = 1 else if (aLen > 0 && bLen == i) ones(i) = 1 }\n        (0 until\
    \ length).map { i => if (aLen == 0 && bLen == i) ones(i) = 1 }\n        String.valueOf(ones.zip(zeros).map\
    \ { case (a, b) => if (a) b else !b }.mkString(\"\"))", "      val xor_result\
    \ : String = a.zip(b).map(tuple => tuple(0)).fold(\"\")((a, b) => a ^ b)\n   \
    \   xor_result", "        // Convert Strings to bit vectors\n        val aVector\
    \ = convertToString(a)\n        val bVector = convertToString(b)\n        // Convert\
    \ bit vectors to bit strings\n        val aBitString = bitString(aVector)\n  \
    \      val bBitString = bitString(bVector)\n        // Perform bit-wise XOR\n\
    \        val result = aBitString Xor bBitString\n        // Convert result back\
    \ to String\n        convertToString(result)", "      var res : String = \"\"\n\
    \      var xor = a.zip(b).foldLeft(0)(_ xor _)\n      var digit = xor.toString.reverse\n\
    \      while (xor > 0) {\n        res = (digit + \"0\") + res\n        xor = xor\
    \ / 10\n      }\n      res", "        val resultVal = a.toInt ^ b.toInt\n    \
    \    result.appendCodePoint(resultVal.toChar)", "      val s1 = a.toInt\n    \
    \  val s2 = b.toInt\n      var result = \"\"\n      if (s1 XOR s2 == 0)\n    \
    \    result = a.toChar\n      else\n        result = a.toChar XOR b.toChar\n \
    \     result", "        val bitA = new BitSet(a)\n        val bitB = new BitSet(b)\n\
    \        bitA.xor(bitB)\n        bitA.binary.toList.reverse", "        val set1\
    \ = Set(a)\n        val set2 = Set(b)\n        val set3 = Set(a.length min b.length)\n\
    \        var res = \"0\"\n        for (x <- set1 diff set2 diff set3) {\n    \
    \        res = res + x\n        }\n        res", "        var xor = a.map(c =>\
    \ c XOR b(0))\n        xor = mutable.Stack(xor)\n        xor = mutable.Queue(xor)\n\
    \        var res = \"\"\n        while(xor.nonEmpty) {\n            val element\
    \ = xor.dequeue\n            res = res + element.charAt(0).toString + element.substring(1)\n\
    \        }\n        res", "        // Return empty string if either string contains\
    \ no 1s\n        if(a contains \"0\") && (b contains \"0\")\n            return\
    \ \"\"\n        val result = new StringBuilder(\"\")\n        val bArray = b.toCharArray\n\
    \        val aArray = a.toCharArray\n        val length = a.length\n        //\
    \ Iterate over the string by converting each character and storing it to result\n\
    \        for( i <- 0 until length){\n            if( (aArray(i) XOR bArray(i))==1\
    \ )\n                result.append(aArray(i))\n            else\n            \
    \    result.append(0)\n        }\n        return result.toString", "        if\
    \ (b.length > a.length) b else a\n        val aSet = a.toSet\n        val bSet\
    \ = b.toSet\n        if (b.length < a.length) {\n            val set1 = aSet\n\
    \            val set2 = bSet\n            val result = mutable.ListBuffer.empty[String]\n\
    \            for (x <- aSet) {\n                if (set2.contains(x)) {\n    \
    \                result += \"1\"\n                } else {\n                 \
    \   result += \"0\"\n                }\n            }\n            result.toList.toString\n\
    \        } else {\n            val set1 = bSet\n            val set2 = aSet\n\
    \            val result = mutable.ListBuffer.empty[String]\n            for (x\
    \ <- bSet) {\n                if (set1.contains(x)) {\n                    result\
    \ += \"1\"\n                } else {\n                    result += \"0\"\n  \
    \              }\n            }\n            result.toList.toString\n        }",
  "        val ba = b.toCharArray.dropRight(1)\n        val bb = a.toCharArray.dropRight(1)\n\
    \        var res = \"\"\n        for (i <- 0 until ba.length) res += ((ba(i) XOR\
    \ bb(i)) XOR 1).toChar\n        res", "        var x = a.toInt\n        var y\
    \ = b.toInt\n        var result = \"\"\n        while (x >= y) {\n           \
    \ x -= y\n            result += x\n        }\n        result", "      val aBitArray\
    \ = a.toBitArray.map(x => x != 0)\n      val bBitArray = b.toBitArray.map(x =>\
    \ x != 0)\n      val xorBitArray = aBitArray Xor bBitArray\n      xorBitArray.map(_\
    \ => 0 -> 1).foldLeft(0)((acc, x) => acc + x)", "        val aBits = a.toInt.toString.reverse.grouped(2).map(_.toChar).reverse\n\
    \        val bBits = b.toInt.toString.reverse.grouped(2).map(_.toChar).reverse\n\
    \        val aAndB = a.toInt + b.toInt\n        val resultBits = Array.fill(aAndB.toInt){0}\n\
    \        for ( i <- 0 until aAndB.toInt ) {\n            resultBits += ((aBits\
    \ getOrElse 0)(i) xor (bBits getOrElse 0)(i))\n        }\n        return resultBits.map(_.toChar).mkString",
  "        def xor(x: Int, y: Int) : Int = if (x == '1') y else x\n        val x =\
    \ a.toInt\n        val y = b.toInt\n        (0 until Math.pow(2, (2 * Math.ceil(Math.log(x)\
    \ / Math.log(2))))).foldLeft((0 until Math.pow(2, (2 * Math.ceil(Math.log(y) /\
    \ Math.log(2)))))) { case ((acc: Int, acc1: Int), v) => ((acc << 1) | xor((x &\
    \ (1 << (2 * v))), y)) }.toInt.toString", "        if(a.length != b.length){\n\
    \            throw new Exception(\"String lengths are not the same\")\n      \
    \  }\n        val result = new mutable.MutableString(\"\")\n        for (i <-\
    \ 0 until a.length)\n            result += a(i) XOR b(i)\n        result", " \
    \       val ans = mutable.Buffer.empty[Char]\n        var i = 0\n        while\
    \ ( i < a.length ) {\n            ans += (a(i) XOR b(i))\n            i += 1\n\
    \        }\n        ans.mkString", "      val xor = a.zip(b).filter(_._1 == \"\
    0\" && _._2 == \"0\").map(_._2).reduce(_ + _)\n      xor match {\n        case\
    \ x if x < 2 => a\n        case x if x < 4 => b\n        case x => \"\"\n    \
    \  }", "        val xorResult = mutable.StringBuilder()\n        a\n         \
    \   .zip(b)\n            .foreach { case (x, y) => if (x == y) xorResult += x\
    \ else xorResult += y}\n        xorResult.toString()", "        // This can be\
    \ done without using StringBuffer by reversing input strings\n        val aReversed\
    \ : String = a.reverse\n        val bReversed : String = b.reverse\n        val\
    \ aIndex : Int = aReversed.length\n        val bIndex : Int = bReversed.length\n\
    \n        val aMap : Map[Char, Int] = a.reverse.toCharArray.map(x=> x -> 1).toMap\n\
    \        val bMap : Map[Char, Int] = b.reverse.toCharArray.map(x=> x -> 1).toMap\n\
    \n        // xor the two strings character by character and add the results\n\
    \        var res = \"\"\n        for (i <- 0 until aIndex) res = res + aMap(aReversed(i))\
    \ + bMap(bReversed(i))\n        res", "        var a : Array[Char] = a.toCharArray.sortWith(_\
    \ > _) // reverse the order of chars\n        var b : Array[Char] = b.toCharArray.sortWith(_\
    \ > _)\n\n        var acc : Array[Char] = Array.zeros[Char](25)\n\n        for\
    \ (i <- 0 to 25) acc(i) = a(i)\n\n        // we iterate only through elements\
    \ in the same positions\n        for (i <- 0 to 25) {\n            // we iterate\
    \ only through elements in the same positions\n            for (j <- 0 to 25)\
    \ {\n                // if we encounter a 0, we do not have to look anywhere else\
    \ for the next one\n                if( b(i) != '0' && ( acc(i) ==  0) ) \n  \
    \                  acc(i) ^= b(j)\n                // if we encounter a 1, we\
    \ do not have to look anywhere else for the next one\n                if( a(i)\
    \ != '1' && acc(i) ==  1 ) \n                    acc(i) ^= a(j)\n            }\n\
    \        }\n\n        // iterate through the array and transform the results\n\
    \        val sb = new StringBuilder\n        for (i <- 0 to 25) sb.append(i%2\
    \ + '0' + acc(i).toString)\n        sb.toString", "        val zeros = Array.fill(b.length)(0)\n\
    \        val ones = Array.fill(a.length)(1)\n        val zerosAndOnes = ArrayBuffer.empty[Int]\n\
    \        val xorResult = Array.fill(b.length)(0)\n        for (bIndex <- 0 to\
    \ b.length - 1) {\n            if (b(bIndex) == 0) {\n                for (a <-\
    \ 0 to a.length - 1) {\n                    if (a(a) == 0) {\n               \
    \         zerosAndOnes += 0\n                    } else if (a(a) == 1) {\n   \
    \                     zerosAndOnes += 1\n                    }\n             \
    \   }\n            }\n        }\n        var carry = 0\n        for (a <- 0 to\
    \ a.length - 1) {\n            var currentXorResult = carry + zerosAndOnes(a).toInt\n\
    \            carry = 0\n            for (i<- 0 to b.length - 1) {\n          \
    \      val bit = if (b(i) == 0) 1 else 0\n                currentXorResult +=\
    \ (currentXorResult * bit)\n                carry = if (currentXorResult > 1)\
    \ 1 else 0\n            }\n            xorResult += currentXorResult\n       \
    \ }\n        for (i <- 0 to xorResult.length - 1) {\n            if (xorResult(i)\
    \ < 0) xorResult(i) = xorResult(i) + 1\n        }\n        xorResult.map(String.valueOf(_)).mkString(\"\
    \")", "        // Initialise the return string as empty\n        var ret = \"\"\
    \n        // Iterate over characters in the strings\n        for(a <- a.toCharArray)\
    \ {\n            for(i <- 1 to b.length()) {\n                // Check if the\
    \ character is a zero and only a zero\n                if(a(i) == '0') {\n   \
    \                 // If the character in the string a matches the character in\
    \ string b\n                    // then XOR the two characters.\n            \
    \        ret += a(i) XOR b(i) \n                }\n            }\n        }\n\
    \        // Return the return string\n        ret", "      var result = \"\"\n\
    \      var bitCount = 2\n      while ( bitCount < maxBitCount(a) + maxBitCount(b)\
    \ ) {\n        result += xorChars(a, bitCount)\n        result += xorChars(b,\
    \ bitCount)\n        bitCount *= 2\n      }\n      return result", "        val\
    \ aMap = a.map(c => c.toInt).mkString(\"\") + \"\"\n        val bMap = b.map(c\
    \ => c.toInt).mkString(\"\") + \"\"\n        aMap.length.zip(\n            0 to\
    \ a.length-1 by -1 zip bMap.length toList\n        ).foreach {\n            case\
    \ (from, to) =>\n                val c = aMap(from) xor bMap(to)\n           \
    \     aMap(from) = c.toChar\n                bMap(to) = c.toChar\n        }\n\
    \        a.mkString(\"\")", "        val xor = a.map(x => if (x == \"1\") \"0\"\
    \ else \"1\").XOR(b.map(x => if (x == \"1\") \"0\" else \"1\"))\n        xor.map(x\
    \ => if (x == \"0\") \"0\" else \"1\").mkString(\"\")", "        val result =\
    \ new mutable.ArrayBuilder[Char]\n        var carry = 0\n        for (i <- a zip\
    \ b) {\n            val res = i.fold(0)(_ ^ (_ + carry))\n            carry =\
    \ res >> 8\n            if (carry != 0)\n                result.add(carry & 255)\n\
    \        }\n        result.result()", "      val numA = a.map(_.toInt)\n     \
    \ val numB = b.map(_.toInt)\n      val xors = numA zip numB\n      xors.foldLeft(0)((acc,\
    \ element) => (acc ^ element))", "        val a = a.toInt\n        val b = b.toInt\n\
    \        var result = a.toString.toInt\n        for(c in b) result ^= c.toInt\n\
    \        result .toString", "        var c = a.toInt\n        var d = b.toInt\n\
    \        var result = 0\n        while(c != 0){\n            result += (c & d).toInt\n\
    \            c >>= 1\n            d >>= 1\n        }\n        val bits = scala.math.pow(2,\
    \ result.length).toInt\n        var result = new Array[Byte](bits)\n        var\
    \ k = result.length - 1\n        var bit = 0\n        while(k >= 0){\n       \
    \     bit = result & (1 << (k - 1))\n            result &= ~bit\n            result\
    \ |= (bit.toInt << k)\n            k = k - 1\n        }\n        return scala.util.Hex.encodeHexString(result)",
  "        val setA : Set[Char] = a.toCharArray\n        val setB : Set[Char] = b.toCharArray\n\
    \        var result = \"0\"\n        for (i <- setA until (setA.last+1))\n   \
    \     {\n            val c = setA(i)\n            result += c xor setB(i)\n  \
    \      }\n        result", "      var sum = 0\n      val aList = a.toUpperCase.map(_.toInt)\n\
    \      val bList = b.toUpperCase.map(_.toInt)\n      val aLen = aList.length\n\
    \      val bLen = bList.length\n      aList.foreach {\n        x => bList.foreach\
    \ {\n          y => sum += x^y\n        }\n      }\n      aList.zip(List(aLen-1).toList).map\
    \ {\n        case (xs, y) => sum.toString + xs + '0' + y\n      }.mkString", " \
    \       def sum(x: Int, y: Int) : Int = x xor y\n        var sumX = 0\n      \
    \  var sumY = 0\n        for(i <- 0 until a.length) {\n            sumX = sumX\
    \ + a(i) XOR sumY\n            sumY = sumY + b(i) XOR sumX\n        }\n      \
    \  val result = sumX XOR sumY\n        val str = new String(Array(\"0\", \"1\"\
    , \"x\", \"y\").toCharArray, \"UTF-8\")\n        str take (result.length) map\
    \ { x => x XOR result.toString } mkString \"\"", "        // A & B are represented\
    \ as bit vectors.\n        // Bit vectors are represented by a list of (index,\
    \ value)\n        val aBitVector = a.toIntVector\n        val bBitVector = b.toIntVector\n\
    \        val aBitVectorLength = a.length()\n        val bBitVectorLength = b.length()\n\
    \        val xorBitVector = new ListBuffer[Int]()\n        var xorLength = 0\n\
    \n        // Iterate over both bit vectors.\n        for( i <- 0 until aBitVectorLength\
    \ ) {\n            if( aBitVector(i) == 0 && bBitVector(i) == 1 ) {\n        \
    \        xorBitVector += xorLength\n                xorLength += aBitVectorLength\n\
    \            }\n        }\n        xorLength += bBitVectorLength\n\n        //\
    \ If both bit vectors are empty or different length,\n        // result vector\
    \ is empty.\n        if( xorBitVector.length == 0 || xorBitVector.length != xorLength\
    \ ) {\n            return \"\"\n        }\n\n        // Iterate over both bit\
    \ vectors.\n        for( i <- 0 until xorBitVector.length ) {\n            if(\
    \ aBitVector(i) == 0 && bBitVector(i) == 1 ) {\n                xorBitVector(i)\
    \ = xorBitVector(i).toInt * 2 - 1\n            }\n        }\n\n        // Convert\
    \ to bits to string.\n        val bitString = String.valueOf(xorBitVector)\n \
    \       bitString.toIntVector", "        // Convert string representation of binary\
    \ number to a mutable list of\n        // integers\n        def str2ints(s : String)\
    \ : List[Int] = {\n            s.toInt.grouped(2).map{case i => (i shr 1) + (i\
    \ >>> 1)}.toList\n        }\n        // Convert string representation of decimal\
    \ number to a mutable list of\n        // integers\n        def str2intd(s : String)\
    \ : List[Int] = {\n            s.toInt.grouped(5).map{case i => (i shr 1) + (i\
    \ >>> 1)}.toList\n        }\n        // Convert string representation of a ternary\
    \ number to a\n        // list of integers\n        def str2intt(s : String) :\
    \ List[Int] = {\n            s.toInt.grouped(3).map{case i => (i shr 1) + (i >>>\
    \ 1)}.toList\n        }\n\n        // Parse string representation of a binary\
    \ number into an array\n        // of integers\n        def bin2ints(s : String)\
    \ : List[Int] = {\n            s.grouped(2).map{case i => (i shr 1) + (i >>> 1)}.toList\n\
    \        }\n        // Parse string representation of a decimal number into an\
    \ array\n        // of integers\n        def dec2ints(s : String) : List[Int]\
    \ = {\n            s.grouped(5).map{case i => (i shr 1) + (i >>> 1)}.toList\n\
    \        }\n        // Parse string representation of a ternary number into an\
    \ array\n        // of integers\n        def tnt2ints(s : String) : List[Int]\
    \ = {\n            s.grouped(3).map{case i => (i shr 1) + (i >>> 1)}.toList\n\
    \        }\n\n        // Parse string representation of a binary number into a\
    \ binary\n        // representation of the number\n        def bin2bin(s : String)\
    \ : String = {\n            val ints = bin2ints(s)\n            var binstr = \"\
    \"\n            for((i, c) <- ints zip ints.drop(1)){\n                val b =\
    \ bin(i.toBinaryString)\n                if(c != 0 && c != 1){\n             \
    \       binstr = (c * (b.getBinaryString.length)) + binstr\n                }\
    \ else {\n                    binstr = c + binstr\n                }\n       \
    \     }\n            binstr\n        }\n        // Parse string representation\
    \ of a decimal number into a decimal\n        // representation of the number\n\
    \        def dec2dec(s : String) : String = {\n            val ints = dec2ints(s)\n\
    \            var decstr = \"\"\n            for((i, c) <- ints zip ints.drop(1)){\n\
    \                val b = dec(i.toBinaryString)\n                if(c != 0 && c\
    \ != 1){\n                    decstr = (c * (b.getBinaryString.length)) + ", " \
    \       var sum : Int = 0\n        var resultString : String = \"\"\n        for\
    \ (i <- a ; j <- b) {\n            sum += j.toInt\n        }\n        for (i <-\
    \ a ; j <- b) {\n            if (sum % 2 == 0) {\n                sum -= i.toInt\n\
    \            } else {\n                sum += i.toInt\n            }\n       \
    \     resultString += if (sum == 0) \"0\" + j.toString else j.toString\n     \
    \       sum += 0\n        }\n        return resultString", "        // Store the\
    \ result\n        var result : String = \"\"\n\n        // Iterate over characters\
    \ in strings\n        for {\n            a <- a\n            b <- b\n        }\
    \ yield {\n            // Get binary representation of current character\n   \
    \         val current = Integer.valueOf(a).asBinary\n            val current2\
    \ = Integer.valueOf(b).asBinary\n\n            // Get result after XOR\n     \
    \       result = current XOR current2\n            result\n        }", "     \
    \   val listA = a\n        val listB = b\n        val length = listA.size\n  \
    \      val result = mutable.ListBuffer.empty[String]\n        for(i <- 0 until\
    \ length) {\n            val xOr = listA(i) ^ listB(i)\n            result +=\
    \ (xOr.toChar)\n        }\n        result.mkString", "        var result : String\
    \ = \"\"\n        var i = 0\n        var j = 0\n        val x0 = a(i)\n      \
    \  val x1 = b(i)\n        while (i < a.length) {\n            var x0 = x0\n  \
    \          var x1 = x1\n            while (j < b.length) {\n                var\
    \ x0 = x0 ^ b(j)\n                var x1 = x1 ^ a(i)\n                j++\n  \
    \              i += 1\n            }\n            result = result + x0\n     \
    \   }\n        return result", "        val aArray = a.toCharArray.map(c => if\
    \ (c == '1') '0' else '1')\n        val bArray = b.toCharArray.map(c => if (c\
    \ == '1') '0' else '1')\n        val resultArray = new Array[Char](b.length)\n\
    \        aArray.zip(\n            bArray\n        ).filter(\n            (x:Char,\
    \ y:Char) => x == '0' && y == '0'\n        ).foreach { \n            (x, y) =>\
    \ resultArray(x.toInt) = (y.toInt) XOR (x.toInt)\n        }\n        return new\
    \ String(resultArray).reverse", "        val aList = a.toList.reverse.map(_.toInt)\n\
    \        val bList = b.toList.reverse.map(_.toInt)\n        val xor = a.zip(b).foldLeft(0){\n\
    \            case (acc, (x, y)) => acc xor x xor y\n        }\n        xor.toString",
  "        var result = \"\"\n        for (x <- a ; y <- b) { result += if(x == y)\
    \ \"1\" else \"0\"  }\n        result", "        val xor = a.zip(b).map { x =>\
    \ x._1 xor x._2 }\n        val zeros = new Array[Char](xor.length)\n        zeros.fill('0')\n\
    \        val result = xor.foldLeft(zeros) { (x, y) => x xor y }\n        String.fromCharArray(result.take(xor.length).toArray)",
  "        def xor(aStr : String, bStr : String) : String = {\n            var str1\
    \ = List(aStr)\n            var str2 = List(bStr)\n            var result = (str1\
    \ zip str2) map { case (x, y) => (x xor y) } mkString(\"\")\n            return\
    \ result\n        }\n        result = xor(a.toList, b.toList)\n        return\
    \ result", "        val a = a.toList\n        val b = b.toList\n        val aLen\
    \ = a.length\n        val bLen = b.length\n        val res = new ListBuffer[String]()\n\
    \        // If one of the inputs is an empty string, then just return the other\n\
    \        // The caller must handle this case\n        if (aLen == 0 || bLen ==\
    \ 0) {\n            res(aLen + bLen)\n            return\n        }\n        //\
    \ Check each character\n        for (i <- 0 until aLen) {\n            for (j\
    \ <- 0 until bLen) {\n                // If character i of string is 1 and the\
    \ character j of string b is 0\n                if ((a.charAt(i) == '1') && (b.charAt(j)\
    \ == '0')) {\n                    res += '0'\n                } else if ((a.charAt(i)\
    \ == '0') && (b.charAt(j) == '1')) {\n                    res += '1'\n       \
    \         }\n            }\n        }\n        // Return the string built so far\n\
    \        res.mkString", "        var result : String = \"\"\n        for (x  <-\
    \ a; y <- b; y != 0) {\n            var xor = x\n            xor = Integer.bitwiseXor(xor,\
    \ y)\n            xor = Integer.toHexString(xor)\n            result = xor + result\n\
    \        }\n        result", "        var res = \"\"\n        for (v <- List(a,\
    \ b)) {\n            val lv = v.toLong\n            val lv_reverse = lv >>> 1\n\
    \            val bin = lv_reverse.toBinaryString\n            res = res + bin\n\
    \        }\n        return res", "        var x = 0\n        var result: String\
    \ = null\n        for(c1 <- a.iterator){\n            for(c2 <- b.iterator){\n\
    \                if(c1 == '0' && c2 == '0'){\n                    result = \"\
    0\"\n                }\n                else if(c1 == '0' && c2 == '1'){\n   \
    \                 result = \"1\"\n                }\n                else if(c1\
    \ == '1' && c2 == '0'){\n                    result = \"1\"\n                }\n\
    \                else if(c1 == '1' && c2 == '1'){\n                    result\
    \ = \"0\"\n                }\n                x ^= (c1 ^ c2)\n            }\n\
    \        }\n        result", "        val aBytes = a.split(\"\").toArray\n   \
    \     val bBytes = b.split(\"\").toArray\n\n        val result = new mutable.StringBuilder()\n\
    \        for( i <- 0 until aBytes.length ) {\n            if( aBytes(i) != bBytes(i)\
    \ ) {\n                result ++= aBytes(i)\n            }\n        }\n      \
    \  return result.toString()", "        var xor = scala.collection.mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until a.length) xor.append(a(i) xor b(i))\n        xor.toList.reverse.mkString",
  '        // Write your code here', "        val xor = a.foldLeft(b.tail.foldLeft(\"\
    \")(_ + _)) { (s, c) => s ^ c }\n        val res = (a ^ (b foldLeft xor) ^ (xor)).toChar\n\
    \        res", "        val zeros = scala.collection.mutable.BitSet(a.length)\n\
    \        val ones = scala.collection.mutable.BitSet(a.length)\n        var res\
    \ = \"\"\n        for (i <- 0 until a.length) {\n            val iChar = a(i).toInt\n\
    \            val jChar = b(i).toInt\n            if (iChar == jChar) {\n     \
    \           if (iChar == 0) {\n                    zeros(i) = 1\n            \
    \    } else if (iChar == 1) {\n                    ones(i) = 1\n             \
    \   }\n            } else if (iChar == 0) {\n                zeros(i) = 1\n  \
    \          } else if (iChar == 1) {\n                ones(i) = 1\n           \
    \ }\n        }\n        // Handle the case where the two strings have a different\
    \ length\n        if (zeros.length != b.length) {\n            return \"\"\n \
    \       }\n        for (i <- 0 until a.length) {\n            if (zeros(i) &&\
    \ ones(i)) {\n                res +=  a(i).toChar\n            }\n        }\n\
    \        res", "        // To store XOR result\n        val xor = scala.collection.mutable.Buffer[String]()\n\
    \        // To store number of 1s found so far\n        val numberOfOnesSoFar\
    \ = 0\n        // To store number of 0s found so far\n        val numberOfZerosSoFar\
    \ = 0\n        for (i <- 0 to a.length - b.length) {\n            val num = a(i)\
    \ XOR b(i)\n            x match {\n                case \"0\" =>\n           \
    \         // Update number of 1s found so far\n                    numberOfOnesSoFar\
    \ += 1 // Add 1 to number of 1s found so far\n                    xor += num.toString\n\
    \                case \"1\" =>\n                    // Update number of 0s found\
    \ so far\n                    numberOfZerosSoFar += 1 // Add 1 to number of 0s\
    \ found so far\n                    xor += num.toString\n            }\n     \
    \   }\n        xor.reverse.head + (numberOfOnesSoFar - numberOfZerosSoFar)", " \
    \       val xorVal = (0 until a.length)\n            .map{\n                if(a(it)\
    \ == '1') 1\n                else 0\n            }\n            .foldLeft((0,0)){\n\
    \                case((acc1, acc2),i) => (acc1 xor acc2 , xorVal(i))\n       \
    \     }\n            .foldLeft((a,b)){\n                case((acc, xor), i) =>\
    \ (acc.substring(0, i-1) + xor.toString + acc.substring(i), xor)\n           \
    \ }", "        val aChars = a.toCharArray\n        val bChars = b.toCharArray\n\
    \        val xorBits = collection.mutable.ArrayBuffer.empty[Int]\n        for\
    \ (i <- 0 until aChars.size) {\n            xorBits(i) = aChars(i).xor(bChars(i))\n\
    \        }\n        xorBits.toString.toUpperCase(Locale.ROOT)", "        val binA\
    \ = new mutable.MutableList[Int]()\n        var binB = new mutable.MutableList[Int]()\n\
    \        for (i <- a.toInt until a.length.toInt) {\n            binA.append(i)\n\
    \        }\n        for (i <- b.toInt until b.length.toInt) {\n            binB.append(i)\n\
    \        }\n\n        // Perform binary XOR on both lists to get one final binary\
    \ list\n        // of 1s and 0s.\n        binB.reverse.foreach { binA.append(_)\
    \ }\n        binA.reverse.foreach { binB.append(_) }\n        // Convert binary\
    \ list back to binary string\n        binB.reverse.foldLeft((new StringBuilder()).+){\
    \ (sb, i) => sb.append(i).append(if (i % 2 == 0) \"1\" else \"0\") }.reverse.toString",
  "        var result = a\n        for (x <- 0 until a.length) {\n            for\
    \ (y <- 0 until b.length) {\n                result =\n                    if\
    \ (a(x, y) XOR (b(x, y))) result(x, y) else \"0\"\n            }\n        }\n\
    \        return result", "        val aSet = new ArraySet[Int](a.toInt)\n    \
    \    val bSet = new ArraySet[Int](b.toInt)\n        val c = new mutable.ArrayBuffer(a.length)\n\
    \        var i\n        for (i = 0; i < a.length; i ++) {\n            if (aSet.contains(i)\
    \ && bSet.contains(i))\n                c(i) = a(i) xor b(i)\n            else\n\
    \                c(i) = a[i]\n        }\n        c.toString()", "        def binary(a\
    \ : String, len : Int) : String = {\n            var ret = \"\"\n            for(i\
    \ <- 0 until len) {\n                ret += a(i) match {\n                   \
    \ case '0' => \"0\"\n                    case '1' => \"1\"\n                 \
    \   case _ => throw new java.lang.NumberFormatException(\"Only 0s and 1s are allowed\"\
    )\n                }\n            }\n            return ret\n        }\n     \
    \   var xor = \"\"\n        for(i <- 0 until a.length) {\n            xor += b(i)\
    \ match {\n                case '0' => xor(xor.length, b.length, \"0\")\n    \
    \            case '1' => xor(xor.length, b.length, \"1\")\n                case\
    \ _ => throw new java.lang.NumberFormatException(\"Only 0s and 1s are allowed\"\
    )\n            }\n        }\n        xor(xor.length, a.length, \"0\")", "    \
    \    val aList = a.toCharArray.map(_ - 48).toList\n        val bList = b.toCharArray.map(_\
    \ - 48).toList\n        val result = new StringBuilder(\"\")\n        var c =\
    \ 0\n        var d = 0\n        while (c < aList.size || d < bList.size) {\n \
    \           if (c < aList.size) {\n                val aChar = aList(c)\n    \
    \            val bChar = bList(d)\n                result += (if (aChar != bChar)\
    \ '1' else '0')\n                c += 1\n            } else if (d < bList.size)\
    \ {\n                val aChar = aList(c)\n                val bChar = bList(d+1)\n\
    \                result += (if (aChar != bChar) '1' else '0')\n              \
    \  d += 1\n            } else {\n                result += (if (aList(c) != bList(d))\
    \ '1' else '0')\n                c += 1\n                d += 1\n            }\n\
    \        }\n        return result.toString", "        val r = new StringBuilder\n\
    \        for(i<-0 to (a.length-1)) r.append((i.toInt*a.length)+(a(i)^b(i)))\n\
    \        r.toString", "        var res = \"\"\n        var carry = 0\n       \
    \ for (a <- a) {\n            for (b <- b) {\n                val bit = a.toInt()\
    \ xor b.toInt()\n                res = if (bit == 1) res + 1 else res + (bit +\
    \ carry)\n                carry = (bit == 1)\n            }\n        }\n     \
    \   res", "        var result = \"\"\n        var ia = a.toCharArray.zipWithIndex.filter(_._1.toInt()\
    \ <> 0).toList\n        var ib = b.toCharArray.zipWithIndex.filter(_._1.toInt()\
    \ <> 0).toList\n        ia.reverse.foreach{case (v, i) =>\n            result\
    \ += v\n            if (ib.exists(_._1 == i)) result += v\n        }\n       \
    \ ia.reverse.foreach{case (v, i) =>\n            result += v\n            if (ia.exists(_._1\
    \ == i)) result += v\n        }\n        result.reverse", "        // Initialize\
    \ an empty string\n        var result : String = \"\"\n\n        // Iterate over\
    \ each character of the input strings\n        for ((c1, c2) <- a.zip(b)) {\n\
    \            result += (if (c1 == c2) \"1\"  else \"0\")\n        }\n\n      \
    \  return result", "        val oneBits = a.toIntBits() == 1;\n        val zeroBits\
    \ = b.toIntBits() == 0;\n        val firstBit = oneBits || zeroBits;\n       \
    \ if(oneBits && zeroBits)\n            throw new IllegalArgumentException(\"Cannot\
    \ perform XOR for both 0 and 1 bits\");\n        if(!oneBits && !zeroBits)\n \
    \           throw new IllegalArgumentException(\"Cannot perform XOR on inputs\
    \ with no bits\");\n        val bits = firstBit ? (a.getLength * 8 + b.getLength)\
    \ :\n            (Math.min(a.getLength, b.getLength) * 8 + Math.max(a.getLength,\
    \ b.getLength));\n        val bitMask = (1 << bits) - 1;\n        val bitMaskString\
    \ = \"1\" * bitMask;\n        val result = (0.to(bits).toList.map(x => if (x %\
    \ 2 == 0) a.get(x) ^ b.get(x) else \"0\" * x) + \n                      (if (firstBit)\
    \ 1 else 0).toList.map(x => if (x % 2 == 1) a.get(x) ^ b.get(x) else \"0\" * x)).mkString(\"\
    \");\n        result + bitMaskString", "      val aBits = a.toInt :: Nil\n   \
    \   val bBits = b.toInt :: Nil\n      val xorBits = bBits ++ aBits\n      var\
    \ x = 0\n      val len = xorBits.length\n      for( i <- 0 until len )\n     \
    \   x |= xorBits(i) << (len - i - 1)\n      val output = Integer.toBinaryString(x)\n\
    \      if( output.length == 1 ) output else \"0\"", "        val a1 = a.toList\n\
    \        val b1 = b.toList\n        val list1 = for {\n            x <- a1\n \
    \           y <- b1\n        } yield {\n            if (x != y) \"1\" + \"0\"\n\
    \            else \"0\"\n        }\n        val string1 = list1.mkString\n   \
    \     val list2 = for {\n            x <- b1\n            y <- a1\n        } yield\
    \ {\n            if (x != y) \"1\" + \"0\"\n            else \"0\"\n        }\n\
    \        val string2 = list2.mkString\n        return string1 + \"1\" + string2",
  "        var res = \"\"\n        for (i <- 0 until a.length) {\n            res\
    \ ++= a(i) XOR b(i)\n        }\n        return res", "      var result = \"\"\n\
    \      var carry = 0\n      for (i <- 0 until a.length) result += a.charAt(i).toInt\
    \ ^ b.charAt(i).toInt\n      for (i <- 0 until a.length - 1) result += carry *\
    \ a.charAt(a.length - i - 1)\n      result", "        val a1 = a.toList\n    \
    \    val b1 = b.toList\n        val res = mutable.StringBuilder.newBuilder\n \
    \       var i = 0\n        while(i < a1.length) {\n            val i1 = i\n  \
    \          val carry = 0\n            val i2 = i + 2\n            while(i < i2)\
    \ {\n                val j = a1(j) XOR b1(i) XOR carry\n                carry\
    \ = if (j > 0xFF) 1 else 0\n                res.append(j.toString.reverse.charAt(0))\n\
    \                i += 1\n            }\n            if (carry != 0) res.append(1)\n\
    \            i += 1\n        }\n        res.result()", "        val setA = mutable.Set(a.split(\"\
    1\").map(x => x.toInt))\n        val setB = mutable.Set(b.split(\"1\").map(x =>\
    \ x.toInt))\n        val common = setA intersect setB\n        val result = \"\
    \"\n        common.foreach { x =>\n            result += \"1\" if (x == 1) else\
    \ \"0\"\n        }\n        result", "        var ans = \"\"\n        for(i <-\
    \ 0 until a.length) {\n            ans += if (a(i) == '1' && b(i) == '1') '0'\
    \ else ('a(i) == '0' && b(i) == '0')\n        }\n        return ans", "      \
    \  val aList = a.toList\n        val bList = b.toList\n        aList.zip(bList).map{\
    \ case(x, y) => x ^ y }.mkString.reverse", "        // Initialize the empty result\n\
    \        var result : String = \"\"\n        // Iterate over both the inputs and\
    \ update result accordingly\n        for (i <- a.indices) {\n            if (i==0)\
    \ {\n                result+=(if(a(i) == b(i)) \"1\" else \"0\")\n           \
    \ } else {\n                result+=(if(a(i)==b(i)) \"0\" else \"1\")\n      \
    \      }\n        }\n        // Return the result\n        result", "        val\
    \ bitSet = a.zip(b).map { \n            case (\"0\", \"0\") => 0\n           \
    \ case (\"0\", \"1\") => 1\n            case (\"1\", \"0\") => 1\n           \
    \ case (\"1\", \"1\") => 0\n        }\n        (bitSet Xor bitSet.map(_ => 0).map(_\
    \ + 48) toString )", "       var result: String = \"\";\n       val bitMap = new\
    \ mutable.HashMap[Int, Int]();\n       val bitMap2 = new mutable.HashMap[Int,\
    \ Int]();\n       a.foreach { x =>\n           if (x != \"0\" && x != \"1\") {\n\
    \               throw new IllegalArgumentException(\"Only 0 and 1 are allowed\
    \ for input\");\n           }\n           bitMap(x) = bitMap.getOrElse(x, 0) +\
    \ 1\n       }\n       b.foreach { x =>\n           if (x != \"0\" && x != \"1\"\
    ) {\n               throw new IllegalArgumentException(\"Only 0 and 1 are allowed\
    \ for input\");\n           }\n           bitMap2(x) = bitMap2.getOrElse(x, 0)\
    \ + 1\n       }\n\n       val bitMapKeys = bitMap.keys;\n       val bitMapValues\
    \ = bitMap.values;\n       val bitMapKeysSorted = bitMapKeys.sorted;\n       val\
    \ bitMapValuesSorted = bitMapValues.sorted;\n       bitMapKeysSorted.foreach {\
    \ x =>\n           val tempBitMapKeys = bitMapKeys.filter(_ != x);\n         \
    \  val tempBitMapValues = bitMapValues.filter(_ != x);\n           val temp =\
    \ x ^ bitMap(x);\n           val bitMapUpdated = new mutable.HashMap[Int, Int]();\n\
    \           tempBitMapKeys.foreach { y =>\n               bitMapUpdated(y) = bitMapUpdated.getOrElse(y,\
    \ 0) + temp(y)\n           }\n           bitMapUpdated.foreach { x =>\n      \
    \         val newBitMapValue = x ^ bitMap2(x);\n               bitMapUpdated(x)\
    \ = newBitMapValue;\n           }\n           bitMapUpdated.foreach { x =>\n \
    \              result += x._1 + x._2\n           }\n       }\n       result",
  "        val aList = a.toIntList\n        val bList = b.toIntList\n        aList\
    \ zip bList map {\n        case (a, b) => a + b\n        case (a, b) => a - b\n\
    \        case (a, b) => a * b\n        case (a, b) => a / b\n        case (a,\
    \ b) => a % b\n        case (a, b) => if a == b { \"1\" + else if a.equals(b)\
    \ a else a }\n        case (a, b) => if a.equals(b) a else a // this case is never\
    \ reached\n        case (a, b) => if a == b { \"1\" + else if a < b else \"0\"\
    \ + else if b <: a else \"1\" + }\n        case (a, b) => if a == b { \"1\" +\
    \ else if a == 1 else \"0\" + else if b == a  else \"1\" + }\n        case (a,\
    \ b) => if a == b { \"1\" + else if a.toInt == 1 else \"0\" + else if b == a.toInt\
    \ else \"1\" + }\n        case (a, b) => if a.toInt == 1 { \"1\" + else if b ==\
    \ a.toInt else \"0\" + else if b < a.toInt else \"1\" + }\n        case (a, b)\
    \ => if a.toInt == 1 { \"1\" + else if b == a.toInt else \"0\" + else if b < a.toInt\
    \ else \"1\" + }\n        case (a, b) => if a.toInt == 1 { \"1\" + else if b ==\
    \ a.toInt else \"0\" + else if b < a.toInt else \"1\" + }\n        case (a, b)\
    \ => if a.toInt == 1 { \"1\" + else if b == a.toInt else \"0\" + else if b < a.toInt\
    \ else \"1\" + }\n        case (a, b) => if a.toInt == 1 { \"1\" + else if b ==\
    \ a.toInt else \"0\" + else if b < a.toInt else \"1\" + }\n        case (a, b)\
    \ => if a.toInt == 1 { \"1\" + else if b == a.toInt else \"0\" + else if b < a.toInt\
    \ else \"1\" + }\n        case (a, b) => if a.toInt == 1 { \"1\" + else if b ==\
    \ a.toInt else \"0\" + else if b < a.toInt else \"1\" + }\n        case (a, b)\
    \ => if a.toInt == 1 { \"1\" + else if b == a.toInt else \"0\" + else if b < a.toInt\
    \ else \"1\" + }\n        case (a, b) => if a.toInt == 1 { \"1\" + else if b ==\
    \ a.toInt else \"0\" + else if b < a.toInt else \"1\" + }\n        case (a, b)\
    \ => if a.toInt == 1 { \"1\" + else if b == a.toInt else \"0\" + else if b < a.",
  "        var result = 0\n        var carry = 0\n        for (i <- 0 until a.length)\
    \ {\n            val x = a.charAt(i).toInt\n            val y = b.charAt(i).toInt\n\
    \            val sum = x + y + carry\n            if (sum > 'Z') {\n         \
    \       result += (sum - 'Z')\n                carry = 0\n            } else {\n\
    \                result += sum\n                carry = 1\n            }\n   \
    \     }\n        if (carry) {\n            result += 1\n        }\n        \"\"\
    \ + result", "        val binA = a.toIntBitArray\n        val binB = b.toIntBitArray\n\
    \        val result = new mutable.HashMap[Int, Int]()\n        val len = binA.size\
    \ + binB.size\n        var i = 0\n        while (i < len) {\n            val k\
    \ = (i / 2)\n            val v = (binA(k) xor binB(k)).toInt\n            if (result.contains(v))\
    \ {\n                val r = result(v)\n                result.remove(k)\n   \
    \             result(v) = r\n            } else {\n                result(v) =\
    \ k\n            }\n            i += 1\n        }\n        var res = \"\"\n  \
    \      for (value <- result.keys) {\n            res +=  value.toString(2)\n \
    \       }\n        res", "        val aStr : Seq[Int] = a.toSeq.map(_.toInt)\n\
    \        val bStr : Seq[Int] = b.toSeq.map(_.toInt)\n        aStr ++ bStr map\
    \ {\n            case 0 => 0\n            case 1 => 1\n            case _ => 0\n\
    \        }.toSeq.foldLeft((0 , 0)) {\n            case ((c1, c2) , value) => c1\
    \ xor c2\n        }._2", "        val a = a.toCharArray\n        val b = b.toCharArray\n\
    \        var res = new mutable.ArrayBuffer[Char]()\n        for(i <- 0 until a.length)\
    \ {\n            if(a(i) xor b(i) == 0)\n                res += '0'\n        \
    \    else\n                res += '1'\n        }\n        res.toString.toCharArray",
  "        def loop(i: Int) : String = {\n            if (i == a.length) {\n     \
    \           return \"\"\n            } else if (a(i) != b(i)) {\n            \
    \    return loop(i+1)\n            } else {\n                return loop(i+1)\n\
    \            }\n        }\n        return loop(0)", "        val aa = a\n    \
    \    val bb = b\n        var outputString = \"\"\n        var binNum = 0\n   \
    \     var result = 0\n        for(num <- (0 to aa.length)) {\n            binNum\
    \ = aa.charAt(num).toInt\n            output = aa.replaceAll((\"0\" + binNum.toString),\
    \ \"\")\n            if(output.length == aa.length) {\n                binNum\
    \ = bb.charAt(num).toInt\n                output = output.replaceAll((\"0\" +\
    \ binNum.toString), \"\")\n                result = result + binNum xor binNum\n\
    \            }\n            outputString += result.toString\n        }\n     \
    \   outputString", "      val aSeq = a.split(\"0\").map(_.toInt)\n      val bSeq\
    \ = b.split(\"0\").map(_.toInt)\n      var result = \"\"\n      val aSize = a.length\n\
    \      val bSize = b.length\n      val aLen = aSeq.length\n      val bLen = bSeq.length\n\
    \      val aMid = (aLen + bLen - 1) / 2\n      val bMid = bLen - aMid\n      for\
    \ (aPos <- 0 to aMid) {\n        for (j <- 0 to bMid) {\n          result = result\
    \ + \n            if (aSeq(aPos) == bSeq(j))\n              1\n            else\n\
    \              0\n        }\n      }\n      result", "        val aArray = a.toIntArray\n\
    \        val bArray = b.toIntArray\n        val retStr = \"\"\n        aArray.zip(Array.fill(bArray.length)(0))\
    \ foreach { case (aNum, aInd) => bArray.zip(aNum) foreach { case (bNum, bInd)\
    \ => if (aInd == bInd) retStr += \"1\" else \"0\" } }\n        retStr", "    \
    \    // Use mutable string to keep track of bits in correct position\n       \
    \ var result = new mutable.StringBuilder\n        // Initialize first bit in result\
    \ as 1\n        result.append(\"1\")\n        // Iterate through remaining bits\
    \ in each string, starting at position 1\n        for (pos <- 1 to b.length) {\n\
    \            val b = b.substring(0,pos)\n            val a = a.substring(0,pos)\n\
    \            // Perform XOR and append result to string builder if appropriate\n\
    \            result.append(if (aXOR(b) == 1) \"1\" else \"0\")\n        }\n  \
    \      return result.toString", "        val aBin = a.map(bin => bin.toChar)\n\
    \        val aBinOr = ArrayBuffer(bin.or(bin.xor(aBin(bin.length-1)))) ++\n  \
    \          aBin.take(aBin.length-1)\n        val bBin = b.map(bin => bin.toChar)\n\
    \        val bBinOr = ArrayBuffer(bin.or(bin.xor(bBin(bin.length-1)))) ++\n  \
    \          bBin.take(bBin.length-1)\n        val orBin = ArrayBuffer(aBinOr).++(bBinOr)\n\
    \        orBin.map(bin.asDigit).mkString.reverse", "        if (b.length < a.length)\
    \ \n            return stringXor(b, a)\n        else {\n            var result\
    \ = \"\"\n            for (i <- 0 until a.length) {\n                if (a(i)\
    \ == '0' && b(i) == '1') \n                    result += \"1\"\n             \
    \   else if (a(i) == '1' && b(i) == '0') \n                    result += \"0\"\
    \n                else if (a(i) != b(i))\n                    result += \"0\"\n\
    \                else {\n                    if (i == a.length - 1) \n       \
    \                 result += \"0\"\n                    else \n               \
    \         result += \"1\"\n                }\n            }\n            result\n\
    \        }", "        val aa = a.reverse\n        val bb = b.reverse\n       \
    \ val res1 = \"0000\"\n        val res2 = \"0000\"\n        val result = \"0000\"\
    \n        val result1 = 0\n        val result2 = 0\n        var aIndex = 0\n \
    \       var bIndex = 0\n        var i = 0\n        var j = 0\n        var k =\
    \ 0\n        while (i < aa.length && j < bb.length) {\n            if (aa(i) ==\
    \ bb(j)) {\n                result(k) = aa(i)\n                result1(k) = aa(i)\n\
    \                result2(k) = aa(i)\n                k += 1\n                i\
    \ += 1\n                j += 1\n            } else if (aa(i) != bb(j)) {\n   \
    \             result1(k) = aa(i)\n                result2(k) = bb(j)\n       \
    \         k += 1\n                i += 1\n                j += 1\n           \
    \ } else {\n                result1(k) = aa(i)\n                result2(k) = bb(j)\n\
    \                k += 1\n                i += 1\n                j += 1\n    \
    \        }\n        }\n        while (i < aa.length) {\n            result1(k)\
    \ = aa(i)\n            k += 1\n            i += 1\n        }\n        while (j\
    \ < bb.length) {\n            result2(k) = bb(j)\n            k += 1\n       \
    \     j += 1\n        }\n        while (k < res.length && k < result1.length)\
    \ {\n            res(res1(k)) |= result1(k)\n            res(res2(k)) |= result2(k)\n\
    \            k += 1\n        }\n        res.reverse()", "        var x = 0\n \
    \       var y = 0\n        var res: String = \"\"\n        for (x = 0; (x < a.length)\
    \ && (y < b.length); x++, y++) {\n            res += (a get(x) XOR b get(y))\n\
    \        }\n        return res", "        // Convert binary strings to bit vectors\
    \ (0s and 1s)\n        val aBin = Array(a.split(' ').map(x => if (x == '1') 1\
    \ else 0).toArray)\n        val bBin = Array(b.split(' ').map(x => if (x == '1')\
    \ 1 else 0).toArray)\n        // XOR all the vectors together\n        val xor\
    \ = for (x1 <- 0 until aBin.length step 1) {\n            for (x2 <- 0 until bBin.length\
    \ step 1) {\n                xor += (aBin(x1) ^ bBin(x2))\n            }\n   \
    \     }\n        // Convert to string and return result\n        xor.toBitArray.foldLeft(\"\
    \")(_ ++ _).toCharArray", "        def inc(a : Char) : Char = {\n            if\
    \ (a == '1') {\n                return '0'\n            } else {\n           \
    \     return '1'\n            }\n        }\n        def dec(a : Char) : Char =\
    \ {\n            if (a == '0') {\n                return '1'\n            } else\
    \ {\n                return '0'\n            }\n        }\n        val x = 0\n\
    \        val y = a.size\n        val z = b.size\n        val newString = a.drop(y)\
    \ + b.drop(z) + a.take(y) + b.take(z)\n        val res = newString.zip(newString.tail).map\
    \ {\n            case (x, y) => if (x != y) x else inc(y)\n        }.mkString(\"\
    \")\n        res", "        val ab = a.zip(b).map(a => a.toInt ^ b.toInt)\n  \
    \      val result: List[Int] = ab.map(_.toBinaryString).map(_.replaceAll(\"1\"\
    , \"0\")).filter(_ != '0').map(_.toInt).toList\n        result.mkString", "  \
    \      val xor = a.foldLeft(mutable.Set[String]())( (a, b) => a += (b + \"0\"\
    ) )\n        val xorAll = mutable.Set[String]()\n        b.foldLeft(mutable.Set[String]())(\
    \ (a, b) => xorAll += a + (b + \"0\") )\n        xorAll.foldLeft(\"\")( (a, b)\
    \ => a + (b + \"1\") )", "      val aBin = a.replace(\"1\", \"0\").replace(\"\
    0\", \"1\")\n      val bBin = b.replace(\"1\", \"0\").replace(\"0\", \"1\")\n\
    \      aBin.toCharArray.map(i => bBin.toCharArray.map(j => i ^ j).mkString).mkString(\"\
    \")", "        val c = mutable.Stack[Char]()\n        val d = mutable.Stack[Char]()\n\
    \        val e = mutable.Stack[Char]()\n        val g = mutable.Stack[Char]()\n\
    \        val h = mutable.Stack[Char]()\n        val i = mutable.Stack[Char]()\n\
    \        val j = mutable.Stack[Char]()\n        val l = mutable.Stack[Char]()\n\
    \        val m = mutable.Stack[Char]()\n        val n = mutable.Stack[Char]()\n\
    \        val o = mutable.Stack[Char]()\n        val p = mutable.Stack[Char]()\n\
    \        val q = mutable.Stack[Char]()\n        val r = mutable.Stack[Char]()\n\
    \        val s = mutable.Stack[Char]()\n        val t = mutable.Stack[Char]()\n\
    \        val u = mutable.Stack[Char]()\n        val v = mutable.Stack[Char]()\n\
    \        val w = mutable.Stack[Char]()\n        val x = mutable.Stack[Char]()\n\
    \        val y = mutable.Stack[Char]()\n        val z = mutable.Stack[Char]()\n\
    \        var w1 = a\n        var w2 = b\n        while(w1 != \"\" && w2 != \"\"\
    ){\n            c += w1.charAt(0)\n            d += w2.charAt(0)\n           \
    \ e += w1.charAt(1)\n            g += w2.charAt(1)\n            h += w1.charAt(2)\n\
    \            i += w2.charAt(2)\n            j += w1.charAt(3)\n            l +=\
    \ w2.charAt(3)\n            m += w1.charAt(4)\n            n += w2.charAt(4)\n\
    \            o += w1.charAt(5)\n            p += w2.charAt(5)\n            q +=\
    \ w1.charAt(6)\n            r += w2.charAt(6)\n            s += w1.charAt(7)\n\
    \            t += w2.charAt(7)\n            u += w1.charAt(8)\n            v +=\
    \ w2.charAt(8)\n            w += w1.charAt(9)\n            x += w2.charAt(9)\n\
    \            y += w1.charAt(10)\n            z += w2.charAt(10)\n            w1\
    \ += w1.substring(1,w1.length)\n            w2 += w2.substring(1,w2.length)\n\
    \        }\n        var xx = c.mkString(\"\") +\n            d.mkString(\"\")\
    \ +\n            e.mkString(\"\") +\n            g.mkString(\"\") +\n        \
    \    h.mkString(\"\") +\n            i.mkString(\"\") +\n            j.mkString(\"\
    \") +\n            l.mkString(\"\") +\n            m.", "        val result: String\
    \ = b.filterNot(a).map(_ => '0').filterNot(b).map(_ => '0').mkString\n       \
    \ result", "        val bit = a.zip(b).filter(_._1).map(_._2).sum\n        val\
    \ sum = a.zip(b).filter(_._1).map(_._1).sum\n        val result = bit.toString()\
    \ + sum.toString\n        return result", "        val aArr : Array[String] =\
    \ a.split(\"0\").map(s => s.toInt)\n        val bArr : Array[String] = b.split(\"\
    0\").map(s => s.toInt)\n        val aNibble : Array[Int] = aArr.zip(Array(1, 0,\
    \ 0)).toArray\n        val bNibble : Array[Int] = bArr.zip(Array(1, 0, 0)).toArray\n\
    \        val aFinalNibble : Array[Int] = aNibble.zip(bNibble).map(t => t._1 xor\
    \ t._2)\n        return aFinalNibble.toString.padToLength(16, 0)", "        val\
    \ s1 = a.toCharArray\n        val s2 = b.toCharArray\n        var result = 0\n\
    \        for (i <- 0 until s1.length) {\n            result += ((s2(i) xor s1(i)).toInt)\n\
    \        }\n        val output = new StringBuilder(2*result.toString)\n      \
    \  output.append('0')\n        for (i <- 0 to (result-1)) {\n            output.append(s(i))\n\
    \        }\n        output.toString()", "        val aArr = a.split('').toList\n\
    \        val bArr = b.split('').toList\n        val resultArr = new Array[Int](aArr.length\
    \ + bArr.length)\n        var index = 0\n        aArr.zip(bArr).foreach { case\
    \ (x, y) => resultArr += ((x ^ y).toInt) }\n        val resultString = resultArr.map(_.toString(2)).mkString(\"\
    \")\n        resultString", "        val a = a.toInt\n        val b = b.toInt\n\
    \        // create bit string from both strings\n        val ab = mutable.BitVector.empty\
    \ ++ BitVector(a.toInt, b.toInt)\n        // XOR bitstring with each other\n \
    \       val result = BitVector.iterate(ab) { \n            (a, b) => \n      \
    \          val result = a.xor(b)\n                (a, b) => (result.binary, result.binary.size)\
    \ \n            }(ab)\n        val bits = result.toBitString\n        bits.reverse.mkString",
  "        val aToInt = a.reverse.zipWithIndex.map {\n            case ('0' * n) =>\
    \ n\n            case ('1' * n) => n - 1\n        }.toList\n        val bToInt\
    \ = b.reverse.zipWithIndex.map {\n            case ('0' * n) => n\n          \
    \  case ('1' * n) => n - 1\n        }.toList\n        val result = 0\n       \
    \ for ( x <- 0 until aToInt.size )\n            for ( y <- 0 until bToInt.size\
    \ )\n                result = result + aToInt(x) * bToInt(y)\n        (result\
    \ / 2).reverse.mkString", "      val c = mutable.Buffer[Char]()\n      val s =\
    \ mutable.Queue[Char]()\n      a.foreach { x => if (x == 0) s += '0' else s +=\
    \ '1' }\n      b.foreach { x => if (x == 0) s += '0' else s += '1' }\n      val\
    \ n = s.length\n      c.clear()\n      c.addAll(s.takeWhile(x => x == '0').toList)\n\
    \      c.addAll(s.takeWhile(x => x == '1').toList)\n      c.toString.dropRight(1).dropLeft(n-1).toChar",
  "        val ans = \"\"\n        val n1 = a.length()\n        val n2 = b.length()\n\
    \        val len = n1 + n2\n        val aHash = a.toCharArray.hashCode\n     \
    \   val bHash = b.toCharArray.hashCode\n        var i = 0\n        while (i <\
    \ len) {\n            val aa = aHash & (1 << i)\n            val bb = bHash &\
    \ (1 << i)\n            val ab = aa^bb\n            ans += if (ab == 0) \"0\"\
    \ + \"1\" else \"1\"\n            i += 1\n        }\n        return ans", "  \
    \      val c = a.replaceAll(\"1\", \"\").replaceAll(\"0\", \"\").foldLeft((a,\
    \ b)) { case ((d, c), x) =>\n            if (c == \"1\") d + \"1\" else d + \"\
    0\"\n        }\n        val d = b.replaceAll(\"1\", \"\").replaceAll(\"0\", \"\
    \").foldLeft((a, b)) { case ((d, c), x) =>\n            if (c == \"1\") d + \"\
    1\" else d + \"0\"\n        }\n        c == d ? \"1\" : \"0\"", "        val aSet\
    \ = a.toIntArray()\n        val bSet = b.toIntArray()\n        val result = mutable.ArrayBuffer(0)\n\
    \        for (x <- 0 to aSet.size - 1) {\n            val xor = aSet(x) | bSet(x)\n\
    \            result.append(xor)\n        }\n        result.mkString", "      \
    \  var x = 0\n        var y = 0\n        val arrayOfA = a.toIntArray.sortWith(_\
    \ < _).reverse\n        val arrayOfB = b.toIntArray.sortWith(_ < _).reverse\n\
    \        while (x < arrayOfA.length && y < arrayOfB.length) {\n            if\
    \ (arrayOfA(x) == arrayOfB(y)) {\n                x += 1\n                y +=\
    \ 1\n            } else {\n                x += 1\n                y += 1\n  \
    \              x = 0\n                y = 0\n            }\n        }\n      \
    \  val result = arrayOfA.slice(0, x) ++ arrayOfB.slice(0, y)\n        result.foldLeft(\"\
    \")((x, c) => x + c.toString)", "        // TODO: Write your code here\n     \
    \   val aHash = a.hashCode()\n        val bHash = b.hashCode()\n        if(a contains\
    \ \"0\" && b contains \"0\")\n            0\n        else if(aHash == bHash)\n\
    \            a\n        else\n            \"0\"", "        val aVal = a.toInt\n\
    \        val bVal = b.toInt\n        val resultVal = aVal ^ bVal\n        Integer.toString(resultVal)",
  "        var res: String = null\n        if (b.length != a.length) throw new IllegalArgumentException(\"\
    Invalid StringXor input.\")\n        val m = b.toInt\n        val n = a.toInt\n\
    \        for (i <- 0 until m) {\n            var x = m.toInt\n            x ^=\
    \ n.toInt\n            n ^= x.toInt\n            x ^= n.toInt\n            res\
    \ = (x + n).asInstanceOf[String]\n        }\n        res", "        var result\
    \ = 0\n        var x = a.toInt - b.toInt\n        var y = a.toInt - b.toInt\n\
    \        var z = a.toInt - b.toInt\n        while (x > 0)\n        {\n       \
    \     result += (x % 2)\n            x /= 2\n        }\n        while (y > 0)\n\
    \        {\n            result += (y % 2)\n            y /= 2\n        }\n   \
    \     while (z > 0)\n        {\n            result += (z % 2)\n            z /=\
    \ 2\n        }\n        return result + a.toString + b.toString", "        val\
    \ bits = a.grouped(2).map { _.toInt }\n        val bits2 = b.grouped(2).map {\
    \ _.toInt }\n        var result = \"\"\n        for (i <- 0 until bits.len) {\n\
    \            val b1 = bits(i) XOR bits2(i)\n            if (b1 == 0) {\n     \
    \           result += 0\n            } else if (b1 == 1) {\n                result\
    \ += 1\n            }\n        }\n        return result", "      val aHashSet\
    \ = mutable.HashSet(a)\n      val bHashSet = mutable.HashSet(b)\n      \n    \
    \  val xorString = new mutable.StringBuilder\n      \n      aHashSet.foreach {\
    \ c =>\n        bHashSet.foreach { d =>\n          if (c == d) xorString.append(c)\n\
    \        }\n      }\n      \n      xorString.toString", "        if(a.length !=\
    \ b.length) throw new IllegalArgumentException\n        val result = new StringBuilder\n\
    \        for(x <- a) result.append(x ^ (b(x) take 1))\n        return result.toString",
  "        val bits = b.toInt\n        def xor(a : Int, b : Int) : Int = \n      \
    \      a & (~b) match {\n                case 0 => 0\n                case 1 =>\
    \ a\n                case _ => xor(a >> 1, b >> 1) | xor(a & 1, b & 1)\n     \
    \       }\n        val xors = mutable.HashMap.empty[Int, Int]\n        val aBits\
    \ = a.toInt\n        val bBits = bits.toInt\n        (1 to bits).foreach( i =>\
    \ {\n            val idx = aBits + i\n            xors.update(xor(idx, idx), idx)\
    \ \n        })\n        xors.toList.map( x => x._1 -> x._2 ).groupBy( x => x ).map(\
    \ x => x._1 -> x._2.size ).toList\n            .map(x => x._1 -> x._2.max).toMap\n\
    \            .sortBy( x => -x._2 ).map( x => x._1 -> x._2 ).mkString(\"\")", " \
    \       var bitmap : BitSet = BitSet(a.length)\n        for(bit <- 0 until a.length)\n\
    \            bitmap ^= BitSet(a(bit).toInt, b.toInt)\n        bitmap.mkString(\"\
    \")", "        def stringXor(a: Int, b: Int) : Int = a xor b\n        val m =\
    \ a.length\n        val n = b.length\n        if (m != n)\n            throw new\
    \ IllegalArgumentException\n        val xors = mutable.MutableArray.fill(n){0}\n\
    \        for (i<- 0 until n) xors(i) = stringXor(a(i), b(i))\n        a.grouped(m).map(x\
    \ => x.mkString(\"\").padTo(n, 0))", "        val map = mutable.HashMap[Char,\
    \ String]()\n        var index = 0\n        for (c <- a.toCharArray)\n       \
    \     map.put(c, \"\")\n        for (c <- b.toCharArray)\n            map.put(c,\
    \ \"\")\n        while (index < a.length) { map.get(a(index)) = b(index); index\
    \ += 1; }\n        var result = \"\"\n        for (c <- map.values.toList)\n \
    \           result += c\n        result", "        var res = \"\"\n        var\
    \ i = 0\n        while (i < a.length) {\n            res = res + b.charAt(i) +\
    \ a.charAt(i)\n            i += 1\n        }\n        return res", "        def\
    \ bitVector(bv : String) : List[Int] = {\n            bv.length match {\n    \
    \            case 0 => Nil\n                case _ =>\n                    var\
    \ bv1 = bv\n                    bv1 += (bv1.head + 1).toString\n             \
    \       bv1 += (bv1.tail.reverse.head + 1).toString\n                    bv1.toList\
    \ match {\n                        case List() =>\n                          \
    \  Nil\n                        case x :: xs =>\n                            val\
    \ y = x.toInt\n                            x :: bitVector(xs.filter(_ != y))\n\
    \                    }\n            }\n        }\n        var xOrBv = bitVector(a)\
    \ ::: bitVector(b)\n        var result : String = \"\"\n        var xOr : Int\
    \ = 0\n        var xOrBvIndex : Int = 0\n        var bvIndex : Int = 0\n     \
    \   while (xOrBvIndex < xOrBv.length) {\n            xOr = xOrBv(xOrBvIndex)\n\
    \            xOrBvIndex += 1\n            xOrBv(xOrBvIndex) match {\n        \
    \        case 0 => break\n                case x => {\n                    bvIndex\
    \ = xOrBvIndex + x\n                    xOrBvIndex = xOrBvIndex + x\n        \
    \            result = result + xOr.toChar\n                    bvIndex = xOrBvIndex\
    \ + x\n                }\n            }\n        }\n        result", "       \
    \ val xa = a.toInt\n        val xb = b.toInt\n        val xc = xa xor xb\n   \
    \     val xd = xc.toInt\n        xd.toString(2)", "      val aArray = a.toCharArray\n\
    \      val bArray = b.toCharArray\n      var result = 0\n      for (i <- 0 until\
    \ aArray.length) result = result | (aArray(i) xor bArray(i))\n      result.toString(2)",
  "      // Convert strings to bits without leading zeroes\n      val a_bit_array\
    \ = a.toIntArray\n      val b_bit_array = b.toIntArray\n\n      // Bitwise OR\n\
    \      val result_array = a_bit_array | b_bit_array\n\n      // Convert back to\
    \ string with leading zeroes\n      val result_string = result_array.toString(2).padToLength(a_bit_array.length,\
    \ 0).padToLength(b_bit_array.length, 0, '0')\n      result_string", "        var\
    \ result = \"0\"\n        var carry = 0\n        var i = a.length - 1\n      \
    \  var j = b.length - 1\n        while i >= 0 || j >= 0 {\n            if(i>=0){\n\
    \                if(b[j] == '1'){\n                    result += a[i--]\n    \
    \                carry++\n                }\n                else{\n         \
    \           result += a[i--] + '0'\n                    carry = 0\n          \
    \      }\n            }\n            if(j>=0){\n                if(a[i] == '1'){\n\
    \                    result += b[j--]\n                    carry++\n         \
    \       }\n                else{\n                    result += b[j--] + '0'\n\
    \                    carry = 0\n                }\n            }\n        }\n\
    \        if(carry > 0){\n            result += '1' + ('0' * (carry - 1))\n   \
    \     }\n        return result"]
stop_tokens:
- "\n    }\n"
