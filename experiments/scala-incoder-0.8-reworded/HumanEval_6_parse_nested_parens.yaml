name: HumanEval_6_parse_nested_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n    // For each of the group, output the deepest\
  \ level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of\
  \ nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((()))\
  \ () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n\
  \    def parseNestedParens(paren_string : String) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
  (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
  \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
  )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
completions: ["        // Keep track of deepest nesting level encountered so far\n\
    \        var max_level = 0\n        var max_level_so_far = 0\n\n        // Track\
    \ the groups which belong to the current level of nesting\n        var group_stack\
    \ : List[List[String]] = Nil\n\n        // Iterate over each of the parenthesis\
    \ groups and push them to the stack\n        for (char_index <- paren_string.indices)\
    \ {\n            if (paren_string(char_index) == '(') {\n                // Push\
    \ the current group to the stack\n                group_stack ::= Nil\n      \
    \          group_stack ::= paren_string.substring(char_index).split(\" \")\n \
    \           }\n            else if (paren_string(char_index) == ')') {\n     \
    \           // Increment the number of levels encountered\n                max_level\
    \ += 1\n                // If this is the deepest level, then pop off the stack\n\
    \                if (max_level > max_level_so_far) {\n                    max_level_so_far\
    \ = max_level\n                    max_level = group_stack.length\n          \
    \          // If there are no more levels of nesting, then break out of the for\
    \ loop\n                    if (max_level == 0) break\n                }\n\n \
    \               // Pop the current group\n                group_stack = group_stack.reverse\n\
    \            }\n        }\n\n        // Return the group list with the deepest\
    \ level added to the top\n        return max_level_so_far :: group_stack.reverse",
  "        val paren_levels = paren_string.splitAsStream(\")\").toList.toMap\n   \
    \     val paren_levels_count = paren_levels.toList.map(_.size).max\n        val\
    \ paren_level_map = (0 until paren_levels_count) map { i => paren_levels(i) }.toMap\n\
    \        paren_level_map.toList.flatMap { case (parent, children) => children.map(paren_level_map(parent)).max\
    \ }", "        var paren_count = 0\n        var deepest_level = 0\n        var\
    \ deepest_level_stack = List[Long](1l.toLong)\n        paren_string.split(\" \"\
    ).foreach{ string => {\n            if(string.equals(\"(\")) {\n             \
    \   paren_count += 1\n            }\n            if(string.equals(\")\")) {\n\
    \                paren_count -= 1\n            }\n            if(string.equals(\"\
    (\") && paren_count > 0) {\n                deepest_level_stack = deepest_level_stack\
    \ + (deepest_level_stack.length - 1)\n            }\n            if(string.equals(\"\
    )\") && paren_count < 0) {\n                deepest_level_stack = deepest_level_stack.dropRight(1)\n\
    \            }\n            if(string.equals(\")\")) {\n                if(deepest_level_stack.length\
    \ > 0) {\n                    deepest_level = deepest_level_stack\n          \
    \          deepest_level_stack = List[Long]()\n                }\n           \
    \ }\n        }}\n        if(deepest_level.length > 0) {\n            deepest_level\
    \ = deepest_level.dropRight(1)\n        }\n        val deepest_level_long_array:\
    \ Array[Long] = deepest_level.map { el => el.toLong }\n        return deepest_level_long_array",
  "        val paren_stack_map : mutable.Map[String,mutable.Set[String]] = mutable.Map.empty\n\
    \        paren_string.split(\"\\\\s+\").map(x => {\n            val xs = x.split(\"\
    \\\\(\").map(y => y.trim()).drop(1)\n            val ys = x.split(\"\\\\)\").map(y\
    \ => y.trim()).drop(1)\n            paren_stack_map += x -> (paren_stack_map.getOrElse(x,\
    \ mutable.Set.empty).union(ys))\n        }).reduce(_ ++ _).map(x => (paren_stack_map(x)).max)",
  "        var max_nesting_level = 0\n        var max_nesting_level_group = 0\n  \
    \      paren_string.split(\"( +)\").foreach(f => {\n            val groups = f.replaceAll(\"\
    ( +)\", \"$1 \").replaceAll(\"^ $\", \"\")\n            val group_list = groups.split(\"\
    \ +\").map(f => {\n                val chars = f.toCharArray\n               \
    \ val count = chars.length\n                val count = chars.map(f => f.toInt).sum\n\
    \                val count_l = new mutable.LongAccumulator[Int](0)\n         \
    \       chars.foreach(f => {\n                    count_l.add(f.toInt)\n     \
    \           })\n                count_l.value\n            })\n            val\
    \ level = group_list.max\n            if (level > max_nesting_level) {\n     \
    \           max_nesting_level = level\n                max_nesting_level_group\
    \ = groups\n            }\n        })\n        (max_nesting_level_group).map(f\
    \ => f.toLong)", "        var parentheses_depth = 0\n        var parentheses_levels\
    \ : List[Long] = List.empty\n        var parenthese_groups = List.empty\n    \
    \    var parentheses_groups : List[List[String]] = List.empty\n        paren_string.split(\"\
    \\\\s+\").foreach {\n            element => {\n                parentheses_groups\
    \ = if (element == \"(\") parenthese_groups else parenthese_groups \n        \
    \        parentheses_groups += List (element)\n            }\n        }\n\n  \
    \      for (parentheses_group <- parentheses_groups) {\n            if (parentheses_group.length\
    \ == 1) {\n                parentheses_groups += List(parentheses_group)\n   \
    \         }\n        }\n\n        for ((parentheses_group <- parentheses_groups)\
    \ {\n            parentheses_group.reduce { case (acc, element) => (parentheses_depth\
    \ * parentheses_levels , acc.length + element.length) }\n        }\n\n       \
    \ parentheses_groups = parentheses_groups.reverse\n        parentheses_groups.map\
    \ { l => l.reduce { case (acc, element) => acc.max } }", "      paren_string.grouped(2)\n\
    \      .flatMap( _ => paren_string.grouped(2) )\n      .flatMap( _ => paren_string.grouped(3)\
    \ )\n      .map(_.toList.size)\n  }\n}\n\nval paren_string =\n\"\"\"\n  ((((()))))\n\
    \"\"\"\nval list: List[Long] = Problem.parseNestedParens(paren_string)\n\nval\
    \ max_list = list.max\n\nval max_str_1 = paren_string.split(\"( )\").max\n\nval\
    \ max_str_2 = paren_string.grouped(2).flatMap(_.grouped(2)).flatMap(_.grouped(3)).map(_.toList.size).max\n\
    \nval max_str_3 = paren_string.grouped(3).flatMap(_.grouped(3)).flatMap(_.grouped(3)).map(_.toList.size).max\n\
    \nval max_str_4 = paren_string.grouped(2).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grouped(2)).flatMap(_.grou",
  "        val ls = paren_string.split(\" \")\n        val parens = mutable.ListBuffer[Long]()\n\
    \        val levels = mutable.ListBuffer[Long]()\n        ls.foreach{ s =>\n \
    \           val opening_parens = s.headOption match {\n                case None\
    \ => 0\n                case Some('(') => 1\n                case Some(')')  =>\
    \ -1\n            }\n            val current_level = s.lastOption.getOrElse(0)\n\
    \            if (opening_parens > 0) {\n                parens += current_level\n\
    \                levels += current_level\n            } else {\n             \
    \   levels += current_level\n            }\n        }\n        levels.toList.max",
  "        var paren_count : Long = 0\n        var nested_list: List[Long] = Nil\n\
    \        for(i <- 0 until paren_string.length){\n            val curr_p = paren_string(i).asInstanceOf[String]\n\
    \            paren_count += 1\n            nested_list += List(paren_count)\n\
    \            if(!paren_p.equals(\" \") && paren_p.equals(\"(\")) {\n         \
    \       val paren_count_left = nested_list(0)\n                val left_paren_len\
    \ = if (paren_count_left < paren_count) paren_count_left else paren_count\n  \
    \              nested_list += left_paren_len + 1\n            } else if(!paren_p.equals(\"\
    \ \") && paren_p.equals(\")\")) {\n                val paren_count_right = nested_list(nested_list.length\
    \ - 1)\n                val right_paren_len = if (paren_count_right < paren_count)\
    \ paren_count_right else paren_count\n                nested_list += right_paren_len\
    \ + 1\n            }\n        }\n        nested_list", '        paren_string.split("
    ").toList.groupBy(_.charAt(0)).toList.flatMap(_._2.toLong)', "        val strList\
    \ = paren_string.split(\"\\\\s+\")\n        val lengthList = strList.map(_.length).sorted\n\
    \        val parenList = strList.zip(lengthList).map({ case (s, l) => (s, l) })\n\
    \        val maxNestingLevel = parenList.length\n        val nestedParenthesisList\
    \ = new scala.collection.mutable.ListBuffer[Long]()\n        val level = 0\n \
    \       var parenStack = new scala.collection.mutable.Stack[String]()\n      \
    \  val openParen = parenStack.pop()\n        while(parenStack.nonEmpty) {\n  \
    \          val currentParen = parenStack.pop()\n            if(currentParen ==\
    \ openParen) {\n                val parenStr = currentParen + \" \"\n        \
    \        val currentLevel = level\n                val newLevel = level + 1\n\
    \                while(newLevel < maxNestingLevel) {\n                    val\
    \ newLevelStr = s\"($currentLevel${openParen}${parenStr}) \"\n               \
    \     val nextParenStr = s\"${openParen}${parenStr} ($currentLevel${openParen}${parenStr})\"\
    \n                    val newParenStr = (currentLevel + openParen + parenStr)\n\
    \                    val newParenLength =\n                        parenList.map(p\
    \ => (p._2.toLong)).max(_.length).length\n                    nestedParenthesisList.add(newParenLength.toLong)\n\
    \                }\n                level += 1\n            }\n        }\n   \
    \     nestedParenthesisList.sortWith(_.length < _.length)\n        nestedParenthesisList.toList",
  "        val parens = paren_string.split(\"\\\\s*\\\\(\")\n        val parentheses_size\
    \ = parens.size\n        val maxLevel = parentheses_size.toInt\n        var level\
    \ = 1 // Starting level always one (root level).\n        var current = List(1l.toLong)\
    \ //The current level is 1.\n\n        for (paren <- parens) {\n            val\
    \ curLevel = paren.split(\"\\\\s*\\\\)\").length\n            if (curLevel < maxLevel)\
    \ {\n                current.add(level.toLong)\n                level = curLevel\
    \ + 1\n            } else if (curLevel == maxLevel) {\n                current\
    \ = current.reverse\n            }\n        }\n\n        return current.reverse",
  "        var max_level = 0\n        var result = ListBuffer.empty[Long]\n      \
    \  for (group <- paren_string.split(\" \").toList) {\n            if(paren_string.length()\
    \ < group.length) result.append(group.length)\n            else {\n          \
    \      if (group.substring(0, group.length) == paren_string) {\n             \
    \       if (group.substring(group.length) == paren_string) result.append(group.length)\n\
    \                    else result.append(1)\n                }\n              \
    \  else {\n                    if (group.substring(0, group.length) == paren_string)\
    \ result.append(group.length)\n                    else result.append((max_level\
    \ + 1))\n                    max_level = (max_level + 1)\n                }\n\
    \            }\n        }\n        val max_list_size = result.toList.sortBy(x\
    \ => x)\n        if (max_list_size.size > max_level) max_list_size.drop(max_level)\
    \ else max_list_size", "        val parentheses = paren_string.split(\" \").toList\n\
    \        var paren_level = 0\n        var highest_level = 0\n        var levels_of_nesting\
    \ = 0\n\n        for( parentheses <- parentheses ) {\n            if(parentheses.startsWith(\"\
    (\")) {\n                paren_level += 1\n            }\n            if(parentheses.endsWith(\"\
    )\")) {\n                paren_level -= 1\n            }\n            if(parentheses.startsWith(\"\
    (\") && paren_level == 0) {\n                levels_of_nesting += 1\n        \
    \    }\n            if(parentheses.endsWith(\")\") && paren_level == 1) {\n  \
    \              levels_of_nesting -= 1\n            }\n            if((parentheses.startsWith(\"\
    (\") && paren_level == 1) ||\n                (parentheses.endsWith(\")\") &&\
    \ paren_level == 0) ) {\n                highest_level = max(highest_level, levels_of_nesting)\n\
    \            }\n        }\n        parentheses.toList.flatMap(n => n.toLong).distinct",
  "        // Convert the input string to list of characters and find the index of\
    \ matching parenthesis\n        val paren_chars = paren_string.toList\n      \
    \  val paren_char_index = paren_chars.indexWhere(_ == '(')\n        if (paren_char_index\
    \ == -1) return List[Long]()\n        val bracket_chars = paren_chars.take(paren_char_index\
    \ + 1)\n        val opening_paren_nesting_count = bracket_chars.count(_ == '(')\n\
    \        val closing_paren_nesting_count = bracket_chars.count(_ == ')')\n   \
    \     var deepest_nesting_count = 0\n        var deepest_level = 0\n        //\
    \ Loop through the parenthesis string and count the opening/closing bracket nesting\
    \ levels\n        paren_chars.reverseIterator.foreach { c =>\n            if (c\
    \ == '(') deepest_nesting_count += 1\n            if (c == ')') deepest_nesting_count\
    \ -= 1\n            if (deepest_nesting_count < deepest_level) deepest_level =\
    \ deepest_nesting_count\n        }\n        // Now we have the deepest level of\
    \ nesting for each parenthesis. If the deepest level matches the deepest level\n\
    \        // of the deepest parenthesis in the input string, that parenthesis is\
    \ the final parenthesis of the input\n        // string. So we return the count\
    \ of the levels that we found.\n        if (deepest_level == deepest_nesting_count)\
    \ List(deepest_level.toLong)\n        else List[Long]()", "        // Your code\
    \ goes here\n        val list = paren_string.split(\" \")\n        var max_count\
    \ = 0\n        var max_level = 0\n        var count_list = new collection.mutable.ArrayList[Long]()\n\
    \        var current_level = List.empty[Long]\n        var count = 0\n       \
    \ for( i <- 0 until list.size ) {\n            val s = list(i)\n            if(\
    \ s == \"(\" ) {\n                if( count > max_count ) {\n                \
    \    max_count = count\n                    max_level = current_level\n      \
    \          }\n                count += 1\n                current_level :+= 1\n\
    \                count_list :+= current_level.last\n            }\n          \
    \  if( s == \")\" ) {\n                count -= 1\n                if( count >\
    \ max_count ) {\n                    max_count = count\n                    max_level\
    \ = current_level\n                }\n                current_level -= 1\n   \
    \         }\n        }\n        return max_level.toList", "        var max_level_of_nesting\
    \ = 0\n        var levels = scala.collection.mutable.List.empty[Long]\n      \
    \  var parentheses_encountered = scala.collection.mutable.Set.empty[String]\n\
    \        for (paren \u2190 paren_string) {\n            parentheses_encountered.add(paren)\n\
    \            if (paren == '(') {\n                levels += 1\n            } else\
    \ if (paren == ')') {\n                levels -= 1\n                if (levels\
    \ == 0) {\n                    max_level_of_nesting = Math.max(max_level_of_nesting,\
    \ levels)\n                }\n            }\n        }\n        if (levels ==\
    \ 0) {\n            max_level_of_nesting = 0\n        }\n        return max_level_of_nesting",
  "        val paren_stack = new mutable.ListBuffer[Long]()\n        for (i <- 0 until\
    \ paren_string.length) {\n            paren_stack ::= paren_string(i)\n      \
    \      if (paren_stack.size == 0)\n                paren_stack += 0\n        \
    \    if (paren_stack.size == 1)\n                paren_stack += 0\n        }\n\
    \        paren_stack.toList", "        // (1) Split string by spaces.\n      \
    \  // [(\"()\", \"()\"), (\"()()\", \"()\"), (\"()()()\", \"()\"), (\"(())\",\
    \ \"()\"), (\"(())()\", \"()\"), (\"(())()()\", \"()\"), (\"(()())\", \"()\"),\
    \ (\"(()())()\", \"()\"), (\"(())()()()\", \"()\")]\n        val paren_groups\
    \ = paren_string.split(\" \").map(s => s.trim).toList\n        // [List(\"()\"\
    , \"()\"), List(\"()()\", \"()\"), List(\"()()()\", \"()\"), List(\"(())\", \"\
    ()\"), List(\"(())()\", \"()\"), List(\"(())()()\", \"()\"), List(\"(()())\",\
    \ \"()\"), List(\"(()())()\", \"()\"), List(\"(())()()()\", \"()\")]\n\n     \
    \   // 2) Use recursion to solve the problem\n        // [((())), (()())), (()()()),\
    \ (()(())), (()(()())), ((())()), ((())()), (())(()), (())()(), (()()()()), (()(()()()()))]\n\
    \        paren_groups.flatMap{\n            case List(x) => parseNestedParens(x)\n\
    \            case x => parseNestedParens(x) ++ parseNestedParens(x)\n        }",
  "        val paren_arrays = paren_string.split(\"( |, )\")\n        var deepest_level\
    \ = paren_arrays.length\n        val max_level_arrays = paren_arrays.map(parens\
    \ => parens.split(\" \")).flatten.maxBy(x => x.length)\n        for(max_level_string\
    \ <- max_level_arrays.toList){\n            if(max_level_string.length>deepest_level){\n\
    \                deepest_level = max_level_string.length\n            }\n    \
    \    }\n        paren_arrays.map(parens => parens.split(\" \")).flatten.maxBy(x\
    \ => x.length).toList.sortBy(x => x.length).reverse.take(deepest_level).reverse",
  '        paren_string.trim.split("\\s+".r).map(n => n.trim.split("\\(").map(i =>
    i(0)).size)', "        val paren_array : List[String] = paren_string.split(\"\
    \ +\")\n        val max_level = 0\n        val result_level: List[Long] = Nil\n\
    \        paren_array.foreach{ group =>\n            var group_level = 0\n    \
    \        val paren_group_array : List[String] = group.split(\"\")\n          \
    \  while (paren_group_array.length > 1) {\n                paren_group_array.sliding(2).foreach(x\
    \ => group_level += x.length)\n            }\n            group_level = math.max(group_level,\
    \ max_level)\n            max_level = math.max(group_level, max_level)\n     \
    \       if (group_level == max_level) {\n                result_level :+ group_level\n\
    \            } else {\n                result_level :+ group_level\n         \
    \       result_level = Nil\n            }\n        }\n        result_level.toList",
  "        var parens_encountered = new scala.collection.mutable.HashSet[Long]()\n\
    \        var paren_depth = 0\n        var group_list = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        for (i <- 0 until paren_string.length()) {\n            if (paren_encountered(paren_depth))\
    \ {\n                group_list.+=((paren_encountered(paren_depth)))\n       \
    \         paren_depth+=1\n            }\n            else {\n                if\
    \ (paren_string(i) == '(') {\n                    parens_encountered += paren_depth\n\
    \                    paren_depth += 1\n                }\n                if (paren_string(i)\
    \ == ')') {\n                    paren_depth -= 1\n                }\n       \
    \     }\n        }\n        return group_list.toList", "        val paren_char\
    \ = \"()\"\n        val paren_str = paren_string.toList\n        val paren_char\
    \ = paren_char.toChar\n\n        def parseParens(paren_str: List[Char], current_level\
    \ : Int) : List[Long] = {\n            val new_level = current_level + 1\n   \
    \         val new_parens = ListBuffer.empty[Long]\n            val paren_count\
    \ = paren_str.count(_ == paren_char)\n\n            val parens = paren_str.map(paren_char).distinct\n\
    \            val paren_level = parens.count(paren_char).toLong\n\n           \
    \ for ((i, paren) <- parens.view.zipWithIndex if paren_level > current_level)\
    \ {\n                val paren_str = paren_str.drop(i).toList\n              \
    \  val paren_level = parens.count(paren_char).toLong\n                val paren_char\
    \ = parens.head\n\n                val parens_count = paren_str.count(_ == paren_char)\n\
    \                val parens_level = parens_count.toLong\n\n                parens_count\
    \ match {\n                    case 0 => new_parens ++= parseParens(paren_str,\
    \ new_level)\n                    case _ => new_parens ++= parseParens(paren_str,\
    \ new_level) match {\n                        case List(count) if count > 0 =>\
    \ parseParens(paren_str, new_level + 1)\n                        case _ => parseParens(paren_str,\
    \ new_level)\n                    }\n                }\n            }\n      \
    \      paren_level match {\n                case 0 => List(1l.toLong)\n      \
    \          case _ => paren_str match {\n                    case parens.head ::\
    \ tail => paren_char :: parseParens(tail, new_level)\n                    case\
    \ _ => parseParens(paren_str, new_level)\n                }\n            }\n \
    \       }\n\n        parseParens(paren_str, 0)", "        var count : Long = 0\n\
    \        var stack : List[Long] = List()\n        var stack_string = \"\"\n  \
    \      for {\n            char <- paren_string.charAt(count)\n            if char\
    \ == '('\n            if stack.length == 0\n            count += 1\n         \
    \   else {\n                stack ::= count\n                stack_string += char\n\
    \                count += 1\n            }\n            else if char == ')'\n\
    \            if stack.length > 0\n            count += 1\n            else {\n\
    \                val stack_size = stack.length\n                stack_string =\
    \ stack_string.substring(0, stack_string.length - 1).toString.padRight(stack_size,\
    \ '0')\n                stack = stack.tail\n                stack_string += char\n\
    \                count += 1\n            }\n            else if char == ' '\n\
    \            if count + 1 == paren_string.length\n            count += 1\n   \
    \         else {\n                stack_string += char\n                count\
    \ += 1\n            }\n        } yield stack_string.toLong", "        // Initialization\n\
    \        var paren_levels : List[Long] = Nil\n        var paren_count : Long =\
    \ 0\n        var paren_level = 0\n\n        // Loop through the input string.\n\
    \        for (i <- paren_string.indices){\n            // If this character is\
    \ opening, increase the level\n            if (paren_string(i) == \"(\"){\n  \
    \              paren_level += 1\n            }\n            // If this character\
    \ is closing, decrease the level\n            else if (paren_string(i) == \")\"\
    ){\n                paren_level -= 1\n            }\n            // If the level\
    \ is getting too high, ignore this character and move on to the next one.\n  \
    \          if (paren_level > paren_count){\n                paren_count += 1\n\
    \                paren_level = 0\n            }\n            // If the level is\
    \ getting too low, ignore this character and move on to the next one.\n      \
    \      if (paren_level < paren_count){\n                paren_count -= 1\n   \
    \             paren_level = 0\n            }\n        }\n        // Return the\
    \ deepest level of nesting.\n        return paren_levels", "        val paren_levels\
    \ = paren_string.split(\"\\\\s+\")\n        val max_depth = paren_levels.length\n\
    \        val max_depth_tuple = (max_depth, List(1l.toLong))\n        paren_levels.foldLeft(max_depth_tuple){\
    \ \n            case(max_depth_tuple, (cur_max_depth, paren_strings)) =>\n   \
    \             val nested_levels = paren_strings.split(\"\\\\)\")\n           \
    \     (cur_max_depth + 1, nested_levels.map(_.toLong))\n        }._2", "     \
    \   //Get all groups in parentheses\n        val groups = paren_string.split(\"\
    \\\\(|\\\\)\")\n        //For each group in parentheses, parse the nested groups\
    \ into array\n        val arraygroups = groups.map(group => {\n           //Each\
    \ group has nested groups separated by spaces. Get the inner groups in an array.\n\
    \           val inner_groups = group.split(\"\\\\ |\\\\(\").map(inner_group =>\
    \ inner_group.split(\"\\\\)\").map(inner_inner_group => inner_inner_group.toLong).toList\n\
    \           inner_groups.getOrElse(Nil)\n        })\n        //Find the deepest\
    \ level of nesting in all arrays\n        val deepest_level = arraygroups.map(arraygroup\
    \ => {\n             //Calculate the sum of the lengths of inner groups\n    \
    \         arraygroup.map(inner_group => inner_group.length).sum\n        }).max\n\
    \        //Return result\n        deepest_level", "        val parens = paren_string.split(\"\
    \ \")\n        val max_level = 0\n        val max_level_list: List[Long] = Nil\n\
    \        for(paren <- parens) {\n            val level_count = paren.split(\"\
    (\").length - 1\n            if(level_count > max_level) {\n                max_level\
    \ = level_count\n                max_level_list = List(max_level.toLong)\n   \
    \         }\n            else if(level_count == max_level) {\n               \
    \ max_level_list = (max_level_list :+ max_level)\n            }\n        }\n \
    \       max_level_list", "        // Initialize output list\n        val output\
    \ = ListBuffer[Long]()\n        // Initialize a stack to keep track of nested\
    \ parens\n        var stack: Stack[String] = Stack()\n        // Iterate through\
    \ paren_string\n        for (c <- paren_string)\n            if (c == '(')\n \
    \               stack.append(c)\n            else if (c == ')')\n            \
    \    while (stack.size > 0 && (stack.pop() == '('))\n                    output\
    \ += stack.pop\n        else\n            while (stack.size > 0 && (stack.pop()\
    \ == '('))\n                output += stack.pop()\n        // Return output\n\
    \        output.toList", "        def findNestingLevel(paren_string : String)\
    \ : Int = {\n            val paren_level = paren_string.lastIndexOf(')') +1\n\
    \            paren_level\n        }\n        val parens_arr = paren_string.split(')')\n\
    \        val nesting_levels = parens_arr.map(findNestingLevel)\n        val max_nesting\
    \ = nesting_levels.max()\n        nesting_levels.map(x => x.toLong).toList", " \
    \       // Initialize an Array to store the groups of the string.\n        var\
    \ nested_paren_groups = ListBuffer[String]()\n\n        // Iterate through each\
    \ character of the string.\n        for(c <- paren_string) {\n            if(c\
    \ == '(') {\n                // If the character is '(', increment the length\
    \ of the list by 1.\n                nested_paren_groups.append(c.toString)\n\
    \            }\n            else if(c == ')') {\n                // If the character\
    \ is ')', decrement the length of the list and append the element at the end.\n\
    \                nested_paren_groups.pop()\n                nested_paren_groups.append(c.toString)\n\
    \            }\n        }\n        // Finally convert the list to Long.\n    \
    \    val nested_paren_groups_list = nested_paren_groups.toList\n        val nested_paren_groups_listLength\
    \ = nested_paren_groups_list.length\n        val nested_paren_groups_as_longs\
    \ = nested_paren_groups_list.map(_.toLong)\n        val nested_paren_groups_as_longs_sorted\
    \ = nested_paren_groups_as_longs.sort\n        val max_nested_paren_groups = nested_paren_groups_as_longs_sorted.take(nested_paren_groups_listLength)\n\
    \        return max_nested_paren_groups", "        val max_level: Int = 0\n  \
    \      var level : Int = 0\n        val paren_list = mutable.ListBuffer[Long]()\n\
    \        for (x <- paren_string.split(\" \").toList) {\n            if (x == \"\
    (\" || x == \"[\" || x == \"{\") {\n                level += 1\n            }\
    \ else if (x == \")\" || x == \"]\" || x == \"}\") {\n                level -=\
    \ 1\n                if (level > max_level) {\n                    max_level =\
    \ level\n                    paren_list += x.toLong\n                }\n     \
    \       }\n        }\n        paren_list.toList", "        val paren_list_strings\
    \ = paren_string.trim.split(' ').toList\n        val paren_list_string_lengths\
    \ = paren_list_strings.map(paren_list => paren_list_string.count(paren_list =>\
    \ paren_list == '(') + paren_list_string.count(paren_list => paren_list == ')')).toList\n\
    \        val paren_list_strings_with_lengths = paren_list_strings.zipWithIndex.map\
    \ { case (paren_string, index) => (paren_string, paren_list_string_lengths(index))\
    \ }\n        val paren_list_strings_sorted = paren_list_strings_with_lengths.sortBy(_._2).reverse\n\
    \        val max_levels_of_nesting = paren_list_strings_sorted.find(_._2 > 0).get._1\n\
    \        val levels_of_nesting_list = paren_list_strings_sorted.map(x => max_levels_of_nesting\
    \ - x._2)\n        val number_of_max_level_of_nesting_list = levels_of_nesting_list.filter(_\
    \ > 1).size\n        val final_level_of_nesting_list = levels_of_nesting_list.sortWith(_\
    \ < _)\n        val final_level_of_nesting_list_with_number_of_levels_of_nesting_list\
    \ = final_level_of_nesting_list.zip(number_of_max_level_of_nesting_list).map(x\
    \ => x(0) + x(1)).toList\n        return final_level_of_nesting_list_with_number_of_levels_of_nesting_list",
  "        val paren_chars = paren_string.toCharArray\n        var paren_count : Int\
    \ = 0\n        var paren_depth : Int = 0\n        var paren_list : List[Long]\
    \ = Nil\n        var max_depth : Int = 0\n\n        // Search for nested parens\n\
    \        for (paren_char <- paren_chars) {\n            if (paren_char == '(')\
    \ {\n                paren_count += 1\n                paren_depth += 1\n    \
    \        } else if (paren_char == ')') {\n                paren_depth -= 1\n \
    \               if (paren_depth == 0) {\n                    paren_count -= 1\n\
    \                    paren_list = paren_list :+ (paren_count)\n              \
    \      if (max_depth < paren_list.length)\n                        max_depth =\
    \ paren_list.length\n                }\n            }\n        }\n        return\
    \ paren_list", "        paren_string.trim\n            .split(\" \")\n       \
    \     .map(string => {\n                val parens = Parens(string)\n        \
    \        parens.parens\n            }).flatMap {\n                case Parens(string)\
    \ => parseNestedParens(string)\n                case parens => List(parens.count)\n\
    \            }.takeWhile(_.isDefined)\n            .map(_.get).toList", "    \
    \    // For each parenthesis, append each of its nesting level to the list.\n\
    \        // Also add its opening parenthesis to the list.\n        // Start with\
    \ zero nesting level and increment it for each opening parenthesis.\n        //\
    \ Also, don't count empty parenthesis as nesting level.\n        val paren_levels\
    \ = new scala.collection.mutable.ListBuffer[Long]\n        paren_string.split(\"\
    \\\\(\\\\)\").map(x => paren_levels += paren_levels.size + 1).distinct", "   \
    \     paren_string.split(\" \").groupBy(_.length)\n              .map(x => (x._1,\
    \ x._2.toList.length))\n              .maxBy(_._1)\n              ._2\n      \
    \        .toList", "        def paren(x : String): List[Long] = {\n          \
    \  x match {\n                case \"(\" => List(1L)\n                case \"\
    )\" => List(1L)\n                case _ => x\n            }\n        }\n     \
    \   def deep(x : List[Long]): List[Long] = {\n            x match {\n        \
    \        case Nil => 1L\n                case List(1L) => 1L\n               \
    \ case List(t) => deep(paren(x) - t)\n                case _ => deep(paren(x)\
    \ - paren(x-1))\n            }\n        }\n        var max_level = 0\n       \
    \ var groups = paren_string.split(\" \").toList\n        groups.tail.foldLeft((groups,\
    \ max_level)) { (cur_list, cur_value) =>\n            val groups = cur_list._1\n\
    \            val cur_value = cur_list._2\n            val max_level = math.max(max_level,\
    \ deep(groups))\n            (groups ::: List(cur_value), max_level)\n       \
    \ }", "        // We use mutable list to keep track of how many parentheses are\
    \ already opened and closed\n        var open_count : Int = 0\n        var max_count\
    \ : Long = 0\n        var result : List[Long] = Nil\n        // Iterate through\
    \ string and keep track of number of open and closed paren\n        for (i <-\
    \ 0 until paren_string.length)\n        {\n            if (paren_string(i) ==\
    \ \"(\")\n            {\n                open_count++\n            } else if (paren_string(i)\
    \ == \")\")\n            {\n                open_count--\n            }\n\n  \
    \          if (open_count > max_count)\n            {\n                max_count\
    \ = open_count\n                result = result ::: (0 until open_count)\n   \
    \         }\n\n        }\n\n        // If there are any open paren without close,\
    \ increment max_count\n        if (open_count != 0)\n        {\n            max_count\
    \ = open_count\n            result = result ::: (0 until open_count)\n       \
    \ }\n\n        return result", "        val paren = paren_string.flatMap{_.toChar}.toList\n\
    \        val stack = ListBuffer[String]()\n        for (c <- paren) {\n      \
    \      if (c != '(' && c != ')')\n                stack += c\n            else\
    \ if (c == ')' && stack.length != 0) {\n                val max_level = stack.foldLeft(0l)((a,\
    \ b) => math.max(a, b.toLong))\n                stack += c\n                stack.toList\n\
    \            } else stack += c\n        }\n        stack.toList", "        //\
    \ Your code here\n        // You can return an Array[Long] type here\n       \
    \ val res = paren_string.grouped(2).map(_.countRight(_)).filter(x => x > 0).map(x\
    \ => x.toLong).toList\n        if (res.size > 0) {\n            res\n        }\
    \ else {\n            res\n        }", "        val paren_array = (paren_string.split(\"\
    \ \")).map(x => x.toLong).toList\n        val max_level = paren_array.foldLeft(0l)\
    \ { (max_level, a) => if (a > max_level) max_level else a }\n        paren_array.slice(0,\
    \ max_level).reverse", "        // This string representation is given by problem.\
    \ \n        // The string representation should be validated and checked before\
    \ calling.\n        // This function will throw exception if the string is not\
    \ valid.\n        val paren_array      = paren_string.split(\" \")\n        var\
    \ highest_level    = 1\n        var highest_level_num = 1\n        var temp_array\
    \        = new Array[String](0)\n        var temp              = new Array[String](0)\n\
    \        var temp_depth         = 1\n        // Add 1 to highest level to avoid\
    \ printing extra brackets around empty string and ()\n        var paren_count\
    \       = 0\n        for (i <- 0 to paren_array.length-1) {\n            if(paren_array(i).equals(\"\
    (\")){\n                paren_count += 1\n            }\n            else if(paren_array(i).equals(\"\
    )\")){\n                paren_count -= 1\n            }\n            // This checks\
    \ if there is any closing bracket to match the opening bracket\n            if(paren_count\
    \ != 0){\n                temp_array = paren_array.slice(i+1,paren_array.length-1)\n\
    \                temp     = temp_array.toArray\n                temp_depth = temp.length\n\
    \                // If temp array is empty means all parentheses are closed \n\
    \                if(temp_depth == 0){\n                    temp_array = paren_array.slice(i+1,paren_array.length-1)\n\
    \                    temp     = temp_array.toArray\n                    temp_depth\
    \ = temp.length\n                }\n                // If current level has more\
    \ levels than previous level means it is the new highest level\n             \
    \   else if(temp_depth > highest_level){\n                    highest_level =\
    \ temp_depth\n                    highest_level_num = i\n                }\n \
    \           }\n        }\n        // For example (\"(()()) ((())) () ((())()())\"\
    ) output is List(2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong).\n        return\
    \ highest_level_num.toLong :: highest_level.toLong :: temp_array.toList", "  \
    \      val paren_list_string = paren_string.split(\" \").map(x => x.toLong).toList.sorted\n\
    \        var deepest_level : List[Long] = List(0l)\n        var paren_level :\
    \ List[Long] = List(0l)\n        val paren_list = paren_list_string.map(x => x.toLong)\n\
    \        for ( i <- 1 to paren_list.size - 1 ){\n            val max_level = paren_list_string.take(i).foldLeft(0l){\n\
    \                case (a,b) => (if (b > a) b else a)\n            }\n        \
    \    deepest_level = deepest_level.zip(List(max_level)).map(x => x._1 + x._2)\n\
    \            paren_level = paren_level.zip(List(max_level)).map(x => x._1 + x._2)\n\
    \            if (deepest_level.last.equals(paren_level.last)) {\n            \
    \    deepest_level = deepest_level.dropRight(1)\n                paren_level =\
    \ paren_level.dropRight(1)\n            }\n        }\n        deepest_level",
  "        val result: List[Long] = Nil\n        var paren_stack: List[Long] = Nil\n\
    \        var open_paren = 0\n        var close_paren = 0\n        var opening_paren\
    \ = 0\n        var closing_paren = 0\n        var opening_string = \"\"\n    \
    \    var closing_string = \"\"\n        var opening_count = 0\n        var closing_count\
    \ = 0\n        var paren_count = 0\n        for(i <- 0 until paren_string.length)\
    \ {\n            if(paren_string.charAt(i) == '(') {\n                if(open_paren\
    \ != 0) {\n                    paren_stack.push(open_paren)\n                \
    \    paren_count += 1\n                }\n                open_paren += 1\n  \
    \              opening_string += paren_string.charAt(i)\n            }\n     \
    \       if(paren_string.charAt(i) == ')') {\n                if(open_paren ==\
    \ open_paren - 1) {\n                    if(opening_paren != 0) {\n          \
    \              paren_stack.push(open_paren)\n                        paren_count\
    \ += 1\n                    }\n                    open_paren -= 1\n         \
    \           closing_string += paren_string.charAt(i)\n                }\n    \
    \            if(open_paren == 0) {\n                    if(opening_paren == 0)\
    \ {\n                        result += paren_stack.foldRight((1l.toLong,open_paren.toLong)){\
    \ case ((a,b),c) => (b,a+1) }\n                    } else {\n                \
    \        result += paren_stack.foldRight((0l.toLong,open_paren.toLong)){ case\
    \ ((a,b),c) => (a,b+1) }\n                    }\n                    result +=\
    \ paren_stack.reverse.foldRight((0l.toLong,open_paren.toLong)){ case ((a,b),c)\
    \ => (a,b+1) }\n                    result += paren_stack.foldRight((0l.toLong,open_paren.toLong)){\
    \ case ((a,b),c) => (a,b+1) }\n                }\n                open_paren -=\
    \ 1\n                closing_string += paren_string.charAt(i)\n            }\n\
    \            if(paren_string.charAt(i) == '(') {\n                opening_paren\
    \ += 1\n                opening_string += paren_string.charAt(i)\n           \
    \ }\n            if(paren_string.charAt(i) == ')') {\n                opening_paren\
    \ -= 1\n                closing_string += paren_string.charAt(i)\n           \
    \ }\n            if(paren_string.charAt(i) == '\"') {\n                opening_count\
    \ += 1\n                opening_string += paren_string.charAt(i)\n           \
    \ }\n            if(paren_string.charAt(i) == ')') {\n                closing_count\
    \ += 1\n                closing_string += paren_string.charAt(i)\n           \
    \ }\n            if(open_paren == 0) {\n                result += paren_stack.foldRight((1l.toLong,open_paren.toLong)){\
    \ case ((a,b),c) => (b,a+1) }\n                result += paren_stack.", "    \
    \    val parens = paren_string.split('(')\n        if (parens.isEmpty) {\n   \
    \         return List(0l)\n        }\n        val result = mutable.ListBuffer.empty[Long]\n\
    \        var depth = 0\n        var parensLevel = 0\n        var parentheses =\
    \ 0\n        for (paren <- parens) {\n            val parensString = paren.substring(1,\
    \ paren.length-1)\n            if (parensString.contains(')')) {\n           \
    \     parentheses = parensString.length\n                parensLevel = parensString.length\n\
    \            }\n            if (parensString.contains('(')) {\n              \
    \  parentheses = parensString.length\n                parensLevel = parensString.length\n\
    \            }\n            parentheses = Math.max(parentheses, parensLevel)\n\
    \        }\n        if (parentheses > 0) {\n            depth += 1\n         \
    \   if (parentheses > 1) {\n                depth += 1\n            }\n      \
    \  }\n        result.push(depth.toLong)\n        val leftParens = paren_string.length\
    \ - (paren_string.substring(0,paren_string.length-1).length) - parens\n      \
    \  if (leftParens > 0) {\n            val rightParens = paren_string.length -\
    \ (paren_string.substring(0,paren_string.length-1).length)\n            result.push(depth.toLong)\n\
    \            result.push(leftParens.toLong)\n            result.push(rightParens.toLong)\n\
    \        }\n        result.toList", "        var max_level = Long.MinValue\n \
    \       var level_num = 0\n        var paren_count = 0\n        var paren_stack\
    \ = List[Long]()\n        for {\n            c <- paren_string\n        } yield\
    \ {\n            val level_num = c.toLong\n            if (level_num > max_level)\
    \ {\n                max_level = level_num\n            }\n            if (level_num\
    \ == 0 && paren_stack.isEmpty) {\n                paren_stack = paren_stack +\
    \ level_num\n            } else {\n                val paren_level = paren_stack.length\
    \ - 1\n                val level_to_remove = paren_stack.take(paren_level).toList\n\
    \                val paren_end_level = level_num - paren_level\n             \
    \   val new_paren_level = paren_stack.take(paren_end_level).toList\n         \
    \       paren_stack = paren_stack - level_to_remove + new_paren_level\n      \
    \      }\n            paren_count += 1\n        }\n        paren_stack.drop(max_level).reverse",
  "        def getMaxNesting(paren_string : String, group: List[Char], nesting : Int)\
    \ : List[Long] = {\n            if(paren_string.isEmpty) return List(nesting)\n\
    \            if(paren_string.charAt(0) == '(') {\n                val new_group:\
    \ List[Char] = paren_string.drop(1)\n                val nesting_level : Int =\
    \ group.size + 1\n                val max_nesting = getMaxNesting(new_group, group,\
    \ nesting_level)\n                val new_nesting = if (nesting_level > nesting)\
    \ nesting_level else nesting\n                val new_group: List[Char] = new_group\
    \ ++ max_nesting.map(x => group(x)).tail\n                getMaxNesting(new_group,\
    \ new_nesting, nesting + 1)\n            }\n            else List()\n        }\n\
    \n        // First split the input string into the group of parentheses.\n   \
    \     val groups: List[Char] = paren_string.chars().filter(!(_ == '(')).map(_.asInstanceOf[Char]).toList\n\
    \n        // Recursively call this function to get the max nesting of each group.\n\
    \        val result = getMaxNesting(paren_string, groups, 0)\n\n        // Convert\
    \ each long value to String and then to a list.\n        val groups_list: List[String]\
    \ = result.map(_.toString).toList\n\n        // Convert each String back to a\
    \ Long.\n        val groups_list_long: immutable.List[Long] = groups_list.map(_.toLong).toList\n\
    \n        // Return the list\n        groups_list_long", "        // This variable\
    \ represents the current level.\n        var current_level = 0\n        // This\
    \ variable will hold the maximum nesting level of parentheses encountered.\n \
    \       var max_nesting_level = 0\n\n        // For each character in the string\n\
    \        for (c <- paren_string.toCharArray) {\n            // Increment the nesting\
    \ level for character\n            if (c == '(') {\n                current_level\
    \ += 1\n            } else if (c == ')') {\n                current_level -= 1\n\
    \            }\n\n            // Update the maximum nesting level when current\
    \ level is updated.\n            if (current_level > max_nesting_level) {\n  \
    \              max_nesting_level = current_level\n            }\n        }\n\n\
    \        // This list will be returned in the end.\n        var returned_list\
    \ : List[Long] = Nil\n\n        // For each character in the string\n        for\
    \ (c <- paren_string.toCharArray) {\n            // Update the list with current\
    \ level if it is greater than the maximum nesting level so far.\n            if\
    \ (current_level > max_nesting_level) {\n                returned_list = returned_list\
    \ :+ current_level\n            }\n        }\n\n        // Return list\n     \
    \   return returned_list", "        var level = 0\n        val max_levels = new\
    \ mutable.HashMap[String, Int]()\n        paren_string.split(\" \").toList.foreach\
    \ { x =>\n            if(max_levels.containsKey(x)) {\n                max_levels.update(x,\
    \ max_levels(x) + 1)\n            } else {\n                max_levels.update(x,\
    \ 1)\n            }\n        }\n        max_levels.foreach { case (k, v) =>\n\
    \            if(level < v) {\n                level = v\n            }\n     \
    \   }\n        level.toList.sortWith(_ < _).reverse.flatten.toList", "       \
    \ // Convert string to list of strings with each string representing a group inside\
    \ parentheses.\n        // E.g. \"(()())\" -> List(\"\", \"\", \"\", \"(()())\"\
    , \"(())\", \"\", \"\", \"(())()\")\n        val group_list = paren_string.split(\"\
    \\\\s+\").map(s => if (s.matches(\"\\\\(\")) \"(\" + s + \")\" else s)\n     \
    \   val group_map: Map[String, List[Long]] = group_list.foldLeft(Map[String, List[Long]]())\
    \ {\n            case(map, elem) => map + (elem -> List(map.getOrElse(elem, 0l).getOrElse(0l)\
    \ + 1))\n        }\n        val max_level = group_map.values.toList.max\n    \
    \    // Convert map to list of tuples with each tuple representing a level of\
    \ nesting\n        val level_of_interest = group_map.values.map {\n          \
    \  case List(level) => (level.toLong, level.toLong)\n        }\n        // Get\
    \ all possible combinations of the levels corresponding to the maximum number\
    \ of levels of nesting.\n        // E.g. max_level = 3 so there are only 4 unique\
    \ combinations of levels of nesting:\n        // [(1, 2), (2, 3), (3, 1), (3,\
    \ 2)]\n        val all_levels = level_of_interest.permutations\n        // Filter\
    \ out all combinations which have more than one level of nesting.\n        val\
    \ levels_of_interest = all_levels.filter { x => x.size > 1 }\n        // Get the\
    \ max level of nesting among all levels of nesting\n        val max_level = levels_of_interest.toList.max\n\
    \        // Combine all levels of nesting into tuples for given maximum level\
    \ of nesting.\n        val level_of_interest_tuple = levels_of_interest.map {\n\
    \            case (level, others) => ((max_level - level).toLong, others)\n  \
    \      }\n        // Find all possible combinations of these tuples corresponding\
    \ to the maximum level of nesting\n        val level_of_interest_tuple_combinations\
    \ = level_of_interest_tuple.combinations(max_level)\n        // Filter to combinations\
    \ with same level of nesting.\n        val level_of_interest_tuple_combinations_filtered\
    \ = level_of_interest_tuple_combinations.filter { x => x.size == 1 }\n       \
    \ // Get the maximum level of nesting among these combinations of levels of nesting\n\
    \        val max_level_of_nesting = level_of_interest_tuple_combinations_filtered.toList.max\n\
    \        // Convert combinations of levels of nesting into lists of tuples of\
    \ levels of nesting\n        val level_of_interest_tuple_combinations_filtered_tuple\
    \ = level_of_interest_tuple_combinations_", "        var depth = 0\n        var\
    \ paren_count : List[Long] = Nil\n        val paren_counts = mutable.HashMap[String,\
    \ Long]()\n        paren_string.split(\"\\\\s+\").foreach(_.toUpperCase).foreach(p\
    \ => {\n            val key = p.toString\n            val count = paren_counts.getOrElse(key,\
    \ 0) + 1\n            paren_counts += (key -> count)\n        })\n        paren_count.foreach(p\
    \ => depth += p._1)\n        paren_count.reverse.foreach(p => depth += p._2)\n\
    \        val result: List[Long] = paren_count.foldLeft(0)((a, b) => b + a).toList.reverse\n\
    \        result", "        // Split the string into group of strings with parens\
    \ and get the deepest level of nesting of parens.\n        val groups = paren_string.split(\"\
    \ \").filter( _ != \"()\" )\n        val deepestLevel = groups.map(_.length).max\n\
    \        val depthToParenMap = groups.length zip (0 until deepestLevel)\n    \
    \    val maxLevels = groups.map( _.length).max\n        val depthToMaxLevelMap\
    \ = groups.length zip 0 toList\n        val maxLevelsNestingMap = depthToMaxLevelMap\
    \ map {\n            case (length, level) =>\n                val maxLevel = length\
    \ match {\n                    case n if n > 0 => n\n                    case\
    \ _ => -1\n                }\n                maxLevel\n        }\n        //\
    \ Build max levels mapping from parens to max level of nesting in the group.\n\
    \        val maxLevels = groups.map(_.length).max\n        val maxLevelsNestingMap\
    \ = depthToMaxLevelMap map {\n            case (length, level) =>\n          \
    \      val maxLevel = length match {\n                    case n if n > 0 => n\n\
    \                    case _ => -1\n                }\n                maxLevel\n\
    \        }\n        // Build the mappings needed to compute maxLevelsNesting.\n\
    \        val maxLevelsNestingMap = depthToMaxLevelMap map {\n            case\
    \ (length, level) =>\n                val maxLevel = length match {\n        \
    \            case n if n > 0 => n\n                    case _ => -1\n        \
    \        }\n                maxLevel\n        }\n        // Build the mappings\
    \ needed to compute maxLevelsNesting.\n        val maxLevelsNestingMap = depthToMaxLevelMap\
    \ map {\n            case (length, level) =>\n                val maxLevel = length\
    \ match {\n                    case n if n > 0 => n\n                    case\
    \ _ => -1\n                }\n                maxLevel\n        }\n        val\
    \ maxLevelsNesting = maxLevelsNestingMap map {\n            case (maxLevel, maxLevelNesting)\
    \ =>\n                if (maxLevelNesting == -1) {\n                    maxLevel\n\
    \                } else {\n                    maxLevel + maxLevelNesting\n  \
    \              }\n        }\n        // Build the mappings needed to compute maxLevelsNesting.\n\
    \        val maxLevelsNestingMap = depthToMaxLevelMap map {\n            case\
    \ (length, level) =>\n                val maxLevel = length match {\n        \
    \            case n if n > 0 => n\n                    case _ => -1\n        \
    \        }\n                maxLevel\n        }\n        // Build the mappings\
    \ needed to compute maxLevelsNe", "        paren_string.split(\"\\\\s+\")\n  \
    \          .foldLeft(List[Long]())((nested, x) => {\n                if (nested.isEmpty)\
    \ {\n                    nested :+ x.toLong\n                } else {\n      \
    \              var last_level = nested.last\n                    var current_level\
    \ = x.toLong\n                    while (current_level > last_level) {\n     \
    \                   nested :+ current_level\n                        current_level\
    \ -= 1\n                    }\n                    while (current_level < last_level)\
    \ {\n                        nested :+ current_level\n                       \
    \ current_level += 1\n                    }\n                }\n            })",
  "        // Use a hashmap to store the count of left parenthesis \n        val parenMap\
    \ = mutable.HashMap.empty[Char, Int]\n        for (i <- 0 to paren_string.length\
    \ - 1) {\n            if (paren_string(i) == '(') parenMap('(') += 1\n       \
    \     else if (paren_string(i) == ')') parenMap(')') += 1\n            else parenMap(paren_string(i))\n\
    \        }\n        // Find deepest level of parenthesis\n        var maxLevel\
    \ = 0\n        val levels = parenMap.keys\n        levels.foreach { level =>\n\
    \            if (level > maxLevel) maxLevel = level\n        }\n        val maxCount\
    \ = maxLevel * parenMap(')')\n        // Find the max depth\n        var maxCount\
    \ = maxLevel * parenMap(')')\n        var count = 0\n        val levels = parenMap.keys\n\
    \        levels.foreach { level =>\n            if (level == maxLevel) count +=\
    \ parenMap(')')\n            else if (level == maxLevel - 1) {\n             \
    \   count += maxCount\n            }\n        }\n        val maxDepth = count\
    \ * maxCount\n        val list = List[Long](maxDepth.toLong).toList\n        return\
    \ list", "        if (paren_string.isEmpty) List(1L)\n        else paren_string.foldLeft[List[Long]](List[Long](1L))\
    \ { case(acc, p) =>\n            val paren_count = p.count { x => x == '(' }\n\
    \            val deepest_level = paren_count match {\n                case 0 =>\
    \ 1\n                case x => paren_count - 1\n            }\n            acc\
    \ :+ deepest_level\n        }", "        val parens = paren_string.split(\" \"\
    )\n        val parens_size = parens.size\n        val parens_list_with_paren =\
    \ mutable.ListBuffer(parens_size)\n        var count = 0\n        var parens_index\
    \ = -1\n        for(i <- 0 until parens_size) {\n            if(parens(i) == \"\
    (\") {\n                parens_list_with_paren += parens_index\n             \
    \   count += 1\n            }\n            else if(parens(i) == \")\") {\n   \
    \             parens_index -= count\n                count -= 1\n            }\n\
    \        }\n        val parens_list_with_paren_2 = parens_list_with_paren.toList\n\
    \        var result: List[Long] = Nil\n        if(parens_list_with_paren_2.nonEmpty)\
    \ {\n            val max_count = Math.max(parens_list_with_paren_2.last, parens_list_with_paren_2.last)\n\
    \            for((parens_index, count) <- 0 until parens_list_with_paren_2.reverse.zip(parens_list_with_paren_2.tail.toList))\
    \ {\n                val max_count_index = max_count - count\n               \
    \ val max_count_index = max_count_index.toLong\n                if(max_count_index\
    \ != 0) {\n                    result = parens_list_with_paren.take(max_count_index)\n\
    \                }\n            }\n        }\n        return result.reverse",
  "        if (paren_string.isEmpty) Nil\n        else paren_string.split(\" \").map(x\
    \ => parseNestedParens(x)).foldLeft(Nil: List[Long])(_ ++ _)", "        // Add\
    \ extra space to fix issues with matching with regex patterns\n        paren_string\
    \ = paren_string.replaceAll(\"(.*) \", \"($1) \")\n        // Extract the numbers\
    \ of nested parens\n        var nested_parens = 0\n        var nested_parentheses_set:\
    \ mutable.Set[String] = mutable.Set()\n        for (n <- 1 to paren_string.length())\
    \ {\n            // Use regex pattern to match parens with proper number of nesting\n\
    \            if (paren_string.substring(n - 1, n).matches(\"(\\\\()*(\\\\()+(\\\
    \\())+(\\\\()*(\\\\))+\")){\n                // If this group has proper number\
    \ of nested parentheses, add it to the set\n                if (paren_string.substring(n\
    \ - 1, n).length() != nested_parens) {\n                    nested_parentheses_set.clear()\n\
    \                    nested_parentheses_set += paren_string.substring(n - 1, n).replaceAll(\"\
    (.*) \", \"($1) \")\n                }\n                // If this group has less\
    \ parentheses, increment the number of nested parens\n                else {\n\
    \                    nested_parens++\n                }\n            }\n     \
    \   }\n        // Convert set into List in descending order\n        val nested_parentheses\
    \ = nested_parentheses_set.map(_.length)\n        nested_parentheses.sortBy(-_).reverse.headOption.toList",
  "        // Initialize our stack\n        val stack : Stack[(Int, (Int, (Int, (Int,\
    \ Int))))] = Stack[(Int, (Int, (Int, (Int, Int))))]()\n        // Initialize our\
    \ result\n        val result : MutableList[Long] = MutableList()\n        // Parse\
    \ the input string\n        val string_array : Array[String] = paren_string.split(\"\
    \ \").toArray\n        // For each group of parentheses\n        for (string_group\
    \ <- string_array) {\n            val group_length : Int = string_group.length\n\
    \            // If this group is empty, just skip it\n            if (group_length\
    \ == 0) continue\n            // Else, push it to our stack\n            val par_count\
    \ = (string_group.charAt(0) == '(' ? 0 : 1)\n            val par_level = par_count\n\
    \            var par_level_in_depth = 0\n            var par_level_in_group =\
    \ 0\n            var par_depth = 0\n            // For each character in the group\n\
    \            for (char_val <- string_group) {\n                // If this is the\
    \ open parenthesis, push it to our stack\n                if (char_val == '(')\
    \ stack.push((par_count, par_level))\n                // If this is the close\
    \ parenthesis, pop out the stack\n                else if (char_val == ')') {\n\
    \                    // If this is the deepest level of nesting of parenthesis\n\
    \                    if (par_level == par_depth) {\n                        //\
    \ Keep track of the level of nesting of the group\n                        par_level_in_group\
    \ = par_level_in_depth\n                        // If this group is at the maximum\
    \ level of nesting, add the depth of this group to the result\n              \
    \          if (par_level_in_depth == par_level) result += (par_depth)\n      \
    \              }\n                    // Else, pop out the stack\n           \
    \         else {\n                        stack.pop()\n                      \
    \  par_level = stack.last._2\n                        par_depth = stack.last._1\n\
    \                        par_level_in_depth = par_level\n                    }\n\
    \                }\n                // If this character is equal to the current\
    \ level of nesting, increase the level of nesting of this group\n            \
    \    else if (par_level == par_depth + 1) {\n                    par_depth +=\
    \ 1\n                }\n                // Else, ignore this character as it's\
    \ not a closing parenthesis\n            }\n        }\n        // Return the result\n\
    \        return result.toList", "        // Initialize result with maximum level\
    \ of nesting.\n        var result : List[Long] = Nil\n        // Iterate over\
    \ the string character by character. Each time we meet a closing parentheses,\
    \ we update result list.\n        var opening_paren_count : Long = 1\n       \
    \ for (cntr : Int <- 0 until paren_string.length) {\n            // Check if character\
    \ is closing parenthesis.\n            if (paren_string(cntr) == '(') {\n    \
    \            // Update nesting level.\n                opening_paren_count +=\
    \ 1\n            }\n            // If character is closing parentheses, check\
    \ if nesting level is greater than the result.\n            if (paren_string(cntr)\
    \ == ')') {\n                // If nesting level is greater than the result and\
    \ current character is opening parentheses, update result.\n                if\
    \ (opening_paren_count > result.length && paren_string(cntr) == '(') {\n     \
    \               result = result :+ opening_paren_count\n                }\n  \
    \              // Reset nesting level.\n                opening_paren_count =\
    \ 1\n            }\n        }\n        // Return a list of longs.\n        result",
  "        // Create a string tree data structure to store the group strings and corresponding\
    \ level of nesting.\n        val paren_str_tree = new mutable.TreeMap[String,\
    \ List[Long]]()\n        // Iterate over the string and add elements to the tree\
    \ map. Each element is a list containing the group string\n        // and a level\
    \ of nesting.\n        paren_string.foreach {\n            element => {\n    \
    \            if(element.nonEmpty) {\n                    val group_string = element\n\
    \                    val group_list_list = paren_str_tree.getOrElseUpdate(group_string,\
    \ List[Long]())\n                    group_list_list ::= 0l.toLong\n         \
    \       }\n            }\n        }\n        // Get the deepest level of nesting.\n\
    \        val deepest_level_list = paren_str_tree.values.max\n        // Convert\
    \ the level of nesting lists to Long.\n        val deepest_level_list = deepest_level_list.map(_.toLong)\n\
    \        // Return the list of levels.\n        return deepest_level_list", " \
    \       paren_string.split(\"\\\\s+\").map(x => if (x == \"(\" || x == \"[\"){0l.toLong}\n\
    \                                        else if (x == \")\" || x == \"]\"){-1l.toLong}\n\
    \                                        else {1l.toLong}).max", "        val\
    \ paren_stack : List[List[Long]] = List(Nil).init\n        val group_count : scala.collection.mutable.Map[String,\
    \ Int] = scala.collection.mutable.Map.empty[String, Int]\n        var level :\
    \ Int = 0\n        var group : List[Long] = Nil\n        var parens : List[Long]\
    \ = Nil\n        var open_count : Int = 0\n        var count : Int = paren_string.length\n\
    \n        while ( count > 0 ) {\n            parens = paren_string.substring(0,\
    \ count).replaceAll(\"[^()]\", \"\")\n            if (paren_stack.last.size ==\
    \ count) {\n                paren_stack.last :+ count\n            }\n       \
    \     else {\n                level += (paren_stack.last - paren_stack.last.drop(1)).max\
    \ + 1\n                paren_stack.last :+ count\n            }\n            open_count\
    \ = (paren_stack.last :+ count).length\n            count -= open_count\n    \
    \        group = (paren_string.substring(0, count).replaceAll(\"[^()]\", \"\"\
    ) :: group).flatten\n            group_count += (\"(\" + paren_stack.map(p =>\
    \ parens(p-1) + open_count).toList + \") :: \" + group).zip(paren_stack.last).map(t\
    \ => t._1 -> t._2)\n            group = []\n        }\n\n        group.toList.map(x\
    \ => group_count(x)).toList.sortBy(_._1).reverse.drop(1).reverse", "        var\
    \ depth = 0\n        var max_depth = 0\n        // Initialize a list to store\
    \ the deepest level of nesting for each of the group\n        var max_depth_list\
    \ = List[Long]()\n        // Initialize a list to store all groups and a counter\
    \ to iterate through all groups\n        var group_and_group_list = ListBuffer[List[Long]]()\n\
    \        var group_counter = 0\n        // For each of the groups in the string\
    \ separated by spaces \n        for(i <- 0 to paren_string.length - 1) {\n   \
    \         \n            // If the current group is empty add it to the group and\
    \ group_list\n            if(paren_string(i) == \" \") {\n                group_and_group_list\
    \ = group_and_group_list :+ i\n                group_counter += 1\n          \
    \  }\n            // If the current group is not empty\n            else {\n \
    \               // Initialize a list to store all groups and a counter to iterate\
    \ through all groups\n                var group_and_group_list = ListBuffer[List[Long]]()\n\
    \                var group_counter = 0\n                // Split the string into\
    \ groups separated by a space and add them to the group list\n               \
    \ for(j <- 0 to paren_string.length - 1 - i) {\n                    if(paren_string(i\
    \ + j) == \" \") {\n                        group_and_group_list = group_and_group_list\
    \ :+ j\n                        group_counter += 1\n                    }\n  \
    \              }\n                // Add the number of groups to the current depth\
    \ and update the list with the current depth\n                depth += group_counter\n\
    \                max_depth_list = max_depth_list :+ depth\n                //\
    \ If the maximum depth is larger than the current depth and update it\n      \
    \          if(max_depth_list.max > depth) {\n                    max_depth = max_depth_list.max\n\
    \                }\n                // If the current depth is equal to the maximum\
    \ depth update it\n                if(depth == max_depth) {\n                \
    \    max_depth_list = max_depth_list :+ max_depth_list.max\n                }\n\
    \            }\n        }\n        // Return the max_depth_list\n        return\
    \ max_depth_list", "        val nestedParen_str = paren_string.split(\" \")\n\
    \        val paren_stack = mutable.Stack[String]()\n        for (nestedParen <-\
    \ nestedParen_str) {\n            // Push this nestedPan onto the stack\n    \
    \        if (nestedParen.charAt(0) == '(') {\n                paren_stack.push(nestedParen)\n\
    \            } else if (nestedParen.charAt(0) == ')') {\n                // If\
    \ it currently in the stack\n                if (paren_stack.nonEmpty && paren_stack.peek().charAt(0)\
    \ == '(') {\n                    // Pop the top stack item and append it to the\
    \ result list\n                    val paren = paren_stack.pop()\n           \
    \         val depth = nestedParen.split(\" \").length - 1\n                  \
    \  val result_list = List(depth.toLong)\n                    val result_list =\
    \ result_list :+ paren\n                    paren_stack.push(result_list)\n  \
    \              } else {\n                    // If not in the stack, just append\
    \ the character to the result list\n                    val result_list = List(nestedParen.charAt(0).toLong)\n\
    \                    paren_stack.push(result_list)\n                }\n      \
    \      }\n        }\n        // Return all the values from stack\n        return\
    \ paren_stack.map(_.toLong).toList", "        val paren_stack = mutable.Stack[String]()\n\
    \        var levels = 0\n        for ( i <- paren_string.toCharArray) {\n    \
    \        if (i == ')') paren_stack.pop()\n            else if (i == '(') {\n \
    \               paren_stack.push(i)\n                levels += 1\n           \
    \ }\n            else {\n                val paren_level = levels\n          \
    \      val paren_string = paren_stack\n                paren_stack = mutable.Stack[String]()\n\
    \                if (paren_level > levels) levels = paren_level\n            \
    \    else if (paren_level < levels) levels = paren_level\n            }\n    \
    \    }\n        val max_level = levels.toLong\n        if (paren_string.length\
    \ == max_level + 1) List(1l.toLong)\n        else {\n            val paren_string\
    \ = paren_string.toList\n            val max_level_str = paren_string(max_level\
    \ - 1).toString\n            val min_level_str = paren_string(max_level).toString.reverse\n\
    \            val max_level_parens = max_level_str.toInt\n            val min_level_parens\
    \ = min_level_str.toInt\n            val max_level_str = max_level_str.reverse\n\
    \            val min_level_str = min_level_str.reverse\n            val max_level_parens\
    \ = max_level_parens + 1\n            val min_level_parens = min_level_parens\
    \ + 1\n            val max_level_str = max_level_str + min_level_str\n       \
    \     val min_level_str = min_level_str + max_level_str\n            val max_level_str\
    \ = max_level_str + min_level_str\n            val max_level_parens = max_level_parens\
    \ + min_level_parens\n            val min_level_parens = min_level_parens + max_level_parens\n\
    \            val paren_stack_str = paren_stack.mkString(\"\").replace(\"[\", \"\
    \").replace(\"]\", \"\")\n            val paren_stack_str = paren_stack_str.replace(\"\
    [\", \"\")\n            val paren_stack_str = paren_stack_str.replace(\"]\", \"\
    \")\n            val paren_stack_str = paren_stack_str.replace(\"(\", \"\")\n\
    \            val paren_stack_str = paren_stack_str.replace(\")\", \"\")\n    \
    \        val paren_stack_str = paren_stack_str.substring(0, paren_stack_str.length)\n\
    \            val paren_stack_str = paren_stack_str.substring(min_level_parens)\n\
    \            val paren_stack_str = paren_stack_str + max_level_str\n         \
    \   val paren_stack_str = paren_stack_str.replace(\"(\", \"\")\n            val\
    \ paren_stack_str = paren_stack_str.replace(\")\", \"\")\n            val paren_stack_str\
    \ = paren_stack_str.substring(0, paren_stack_str.length)\n            val paren_stack_str\
    \ = paren_stack_str.substring(max_level_parens)\n            val ", "        val\
    \ paren_array = paren_string.split(\" \").toList\n        val levels_of_nesting\
    \ = new mutable.ArrayBuffer[Long]\n        var current_level = 0\n        for\
    \ (i <- 0 until paren_array.size) {\n            if (paren_array(i).equals(\"\
    (\")) {\n                current_level += 1\n            } else if (paren_array(i).equals(\"\
    )\")) {\n                current_level -= 1\n            }\n            if (current_level\
    \ == 0){\n                levels_of_nesting += current_level.toLong\n        \
    \    }\n        }\n        levels_of_nesting.toList", "        val paren_arr =\
    \ paren_string.split(\"\\\\)\").toList\n        // To track how many opening parenthesis\
    \ we have, we will use a simple counter\n        // Since a list comprehension\
    \ takes O(n), we use a mutable map\n        val paren_count_map = mutable.Map[Int,\
    \ Long]()\n        for (paren in paren_arr) {\n            if (paren == \"(\"\
    ) {\n                paren_count_map += 1\n            }\n            else if\
    \ (paren == \")\") {\n                val count = paren_count_map(paren)\n   \
    \             if (count > 0) {\n                    paren_count_map -= 1\n   \
    \             }\n            }\n            else {\n                paren_count_map\
    \ -= 1\n            }\n        }\n\n        // Now we will need to convert this\
    \ map to a list \n        val paren_list_array = paren_count_map.toList.sorted\n\
    \        val max_count = paren_list_array.last\n        val max_index = paren_list_array.lastIndex\n\
    \        val paren_list_list = paren_list_array.take(max_index)\n        val paren_list_long\
    \ = paren_list_array.map(_.toLong)\n\n        paren_list_long", "        def parseParens(paren_string\
    \ : String) : List[Long] = {\n            paren_string.asInstanceOf[List[String]].foldLeft(0l.toLong)(\
    \ (acc, cur) => {\n                val level = acc.toLong\n                val\
    \ curVal = cur.asInstanceOf[String]\n                val parenCount = (curVal.indexOf('(')\
    \ + curVal.indexOf(')')).toInt\n                if (parenCount > level) {\n  \
    \                  val newLevel = parenCount.toLong\n                    newLevel\n\
    \                } else if (parenCount == level) {\n                    cur.toLong\n\
    \                } else {\n                    acc\n                }\n      \
    \      })\n        }\n        val parens = paren_string.trim.asInstanceOf[String]\n\
    \        val paren_groups = parens.split(\" \")\n        paren_groups.length match\
    \ {\n            case 0 => List()\n            case 1 => parseParens(paren_groups.head).toList\n\
    \            case _ => {\n                var maxLevel = parseParens(paren_groups.head).toList.foldLeft(0l.toLong)(\
    \ (acc, curVal) => {\n                    var curLevel = acc\n               \
    \     if (curVal == '(') {\n                        curLevel = curLevel + 1\n\
    \                    }\n                    if (curVal == ')') {\n           \
    \             curLevel = curLevel - 1\n                    }\n               \
    \     if (curLevel > maxLevel) {\n                        maxLevel = curLevel\n\
    \                    }\n                    curLevel\n                })\n   \
    \             for (i <- 0 until paren_groups.length-1) {\n                   \
    \ val paren_group = paren_groups(i)\n                    val paren_group_level\
    \ = parseParens(paren_group).toList\n                    if (paren_group_level.size\
    \ < maxLevel) {\n                        maxLevel = paren_group_level.size\n \
    \                   }\n                }\n                maxLevel\n         \
    \   }\n        }", "        val paren_string =  paren_string.replace(\"()\", \"\
    \").replace(\"()\", \"\").replace(\"()\", \"\").replace(\"()\", \"\").replace(\"\
    ()\", \"\").replace(\"()\", \"\").replace(\"()\", \"\")\n        val paren_levels\
    \ = paren_string.split(\"\\\\(\")\n        val paren_levels_count = paren_levels.size\n\
    \        var level_counter = 0\n        var current_level_paren_counter = 0\n\
    \        var deepest_level_of_paren = 0\n        val highest_level_of_parens =\
    \ mutable.HashMap.empty[Long, Long]\n        val highest_level_of_parens_count\
    \ = mutable.HashMap.empty[Long, Int]\n        for (paren_level in paren_levels)\
    \ {\n            current_level_paren_counter = paren_levels_count - level_counter\n\
    \            level_counter += 1\n            if (current_level_paren_counter ==\
    \ 0)\n                deepest_level_of_paren = 0\n            else if (current_level_paren_counter\
    \ > deepest_level_of_paren) {\n                deepest_level_of_paren = current_level_paren_counter\n\
    \                highest_level_of_parens.put(deepest_level_of_paren, current_level_paren_counter)\n\
    \                highest_level_of_parens_count.put(deepest_level_of_paren, current_level_paren_counter)\n\
    \            }\n        }\n        return highest_level_of_parens.toList.sortWith(_._1\
    \ > _._1)", "        paren_string.split(\"\\\\s+\").map(v => v.count(_ == '(')\
    \ - v.count(_ == '[') - v.count(_ == '{')).maxBy(_).map(_.toLong).toList", " \
    \       val paren_level = mutable.ListBuffer[Long]()\n        val paren_array\
    \ = paren_string.split(\" \")\n        paren_array.foreach(ele => {\n        \
    \    val opening_paren = ele.indexOf('(')\n            val closing_paren = ele.indexOf(')')\n\
    \            if(opening_paren < 0 || closing_paren < 0) {\n                return\n\
    \            }\n            if(opening_paren + 1 == closing_paren) {\n       \
    \         val new_level = paren_level.length\n                paren_level ++=\
    \ List(new_level)\n                return\n            }\n            val next_level_opening\
    \ = paren_array.getOrElse(opening_paren+1, 0).toLong\n            val next_level_closing\
    \ = paren_array.getOrElse(closing_paren+1, 0).toLong\n            val new_level\
    \ = paren_level.get(opening_paren).toLong + next_level_opening - next_level_closing\n\
    \            paren_level ++= List(new_level)\n        })\n        paren_level.toList.sortBy(_._)",
  "        var max_level = 0\n        var max_level_index = 0\n        var level =\
    \ 0\n        var stack = new mutable.Stack[List[Long]]\n        var result: List[Long]\
    \ = Nil\n        paren_string.split(\"\\\\s+\").foreach { elem =>\n          \
    \  if(!elem.equals(\"(\") && elem.equals(\")\")) {\n                stack.push(List(0,\
    \ 0))\n            }\n            else if(elem.equals(\"(\")) {\n            \
    \    stack.push(List(0, 0))\n            }\n            else if(elem.equals(\"\
    )\")) {\n                var level_start = stack.get.apply(0).getOrElse(0)\n \
    \               var level_end = stack.get.apply(1).getOrElse(0)\n            \
    \    val max_level_size = level_end - level_start + 1\n                if(max_level_size\
    \ >= max_level) {\n                    max_level = max_level_size\n          \
    \          max_level_index = stack.size - 1\n                }\n             \
    \   stack.last.last.last.last.last.last.set(max_level_size + 1, level_end)\n \
    \               stack.pop()\n                level -= 1\n            }\n     \
    \       else {\n                val level_start = stack.get.apply(0).getOrElse(0)\n\
    \                val level_end = stack.get.apply(1).getOrElse(0)\n           \
    \     stack.last.last.last.last.last.set(level + 1, level_end)\n             \
    \   stack.get.apply(level + 1).foreach(x => stack.push(x))\n                level\
    \ += 1\n            }\n        }\n        stack.get.apply(max_level_index).foreach(x\
    \ => result.add(x))\n        result", "        if (paren_string.length <= 1) List(1l.toLong)\n\
    \        val resultList = ListBuffer[Long]()\n        val currNesting = -1\n \
    \       def isNesting(index : Long) : Boolean = {\n            if (paren_string(index)\
    \ == \"(\") return true\n            else if (paren_string(index) == \")\") return\
    \ false\n            else if (paren_string(index) == \" \") return true\n    \
    \        else return isNesting(index + 1)\n        }\n        def findNestingLevel(index\
    \ : Long) : Long = {\n            if (isNesting(index)) {\n                currNesting\
    \ += 1\n                findNestingLevel(index + 1)\n            } else currNesting\
    \ -= 1\n            currNesting\n        }\n        val openingBracketIndex =\
    \ 0\n        val closingBracketIndex = 0\n        while (openingBracketIndex <\
    \ paren_string.length) {\n            val closingBracketIndex = paren_string.indexOf(\"\
    )\", openingBracketIndex + 1)\n            if (closingBracketIndex >= 0) {\n \
    \               val closingBracketEndIndex = paren_string.indexOf(\")\", closingBracketIndex\
    \ + 1)\n                if (closingBracketEndIndex >= 0) {\n                 \
    \   val closingBracketString = paren_string.substring(closingBracketIndex, closingBracketEndIndex\
    \ + 1)\n                    val closingBracketNesting = findNestingLevel(closingBracketIndex\
    \ + 1)\n                    val currNestingLevel = findNestingLevel(openingBracketIndex\
    \ + 1)\n                    if (closingBracketNesting > currNestingLevel) resultList\
    \ += closingBracketNesting\n                    else if (closingBracketNesting\
    \ < currNestingLevel) resultList += currNestingLevel\n                }\n    \
    \        }\n            val openingBracketEndIndex = paren_string.indexOf(\"(\"\
    , openingBracketIndex + 1)\n            if (openingBracketEndIndex >= 0) {\n \
    \               val openingBracketString = paren_string.substring(openingBracketIndex,\
    \ openingBracketEndIndex + 1)\n                val openingBracketNesting = findNestingLevel(openingBracketIndex\
    \ + 1)\n                val currNestingLevel = findNestingLevel(closingBracketIndex\
    \ + 1)\n                if (openingBracketNesting > currNestingLevel) resultList\
    \ += openingBracketNesting\n                else if (openingBracketNesting < currNestingLevel)\
    \ resultList += currNestingLevel\n            }\n            openingBracketIndex\
    \ = paren_string.indexOf(\"(\", openingBracketIndex + 1)\n        }\n        resultList",
  "        val paren_groups = paren_string.trim.split(\"\\\\s+\")\n        val paren_levels\
    \ = mutable.ArrayBuffer.empty[Long]\n        for (paren_group <- paren_groups)\
    \ {\n            val paren_level = 0\n            val paren_count = 0\n      \
    \      val paren_stack = mutable.Stack.empty[String]\n            val in_paren_group\
    \ = 0\n            val paren_group_tokens = paren_group.split(\"()\")\n      \
    \      for (paren_token <- paren_group_tokens) {\n                if (paren_token.isEmpty)\
    \ {\n                    paren_stack.push(\"\")\n                } else {\n  \
    \                  if (paren_token == \"(\") {\n                        paren_stack.push(\"\
    \")\n                        in_paren_group += 1\n                    } else if\
    \ (paren_token == \")\") {\n                        paren_count -= 1\n       \
    \                 if (in_paren_group > 0) {\n                            paren_stack.push(paren_token)\n\
    \                        } else {\n                            paren_level -=\
    \ 1\n                            paren_stack.pop\n                           \
    \ if (paren_stack.nonEmpty && paren_level == 0) {\n                          \
    \      paren_levels += paren_stack.toList\n                                paren_levels\
    \ += paren_stack.toList.reverse\n                            }\n             \
    \           }\n                    }\n                }\n            }\n     \
    \   }\n        paren_levels.toList", "        val paren_str_list: List[String]\
    \ = paren_string.split(\" \");\n        val max_level: Int = 0;\n        val paren_strs_group:\
    \ List[String] = paren_str_list.map(s => (s.toChar, s.toInt)).groupBy(_._1).mapValues(_.map(_._2).toList)\n\
    \        val parentheses_group: List[Map[Char,Int]] = paren_strs_group.mapValues(v\
    \ => List(v.last))\n        val max_level_of_group: List[Int] = parentheses_group.mapValues(_.length).toList.max\n\
    \n        max_level_of_group.foreach(s => max_level = s)\n        paren_strs_group.mapValues(v\
    \ => List(v.last))\n            .map(v => v.toString.count(_ == '(') - v.toString.count(_\
    \ == '(') - v.toString.count(_ == ')'))\n            .toList", "        val paren_list\
    \ = paren_string.split(\" \");\n        var counter = 0;\n        var max_counter\
    \ = 0;\n        val result = mutable.MutableList[Long]()\n        val paren_counter\
    \ = mutable.MutableList[Long]()\n        paren_list.foreach(x => {\n         \
    \   if (x != \"()\"){\n                val tmp = Long.valueOf(x.toInt)\n     \
    \           if (tmp > max_counter)\n                    max_counter = tmp\n  \
    \              result.append(tmp)\n                paren_counter.append(Long.valueOf(1))\n\
    \            }\n            else if (x == \")\"){\n                if (paren_counter(counter)\
    \ == 0)\n                    counter = counter + 1\n                else {\n \
    \                   if (paren_counter(counter) == max_counter)\n             \
    \           result.append((max_counter).toLong)\n                    else\n  \
    \                      result.append((paren_counter(counter)).toLong)\n      \
    \              counter = counter + 1\n                }\n                paren_counter(counter)\
    \ = paren_counter(counter) + 1\n            }\n        })\n        result", " \
    \       val paren_levels = mutable.ListBuffer.empty[Long]\n        paren_string.split(\"\
    \ \").foreach{ s =>\n            val level_str = s.split(\"\\\\(\")\n        \
    \    val level_int = level_str.map(_.toInt)\n            val level = level_int.max\n\
    \            paren_levels.append(level)\n        }\n        paren_levels.toList",
  "        val paren_list = paren_string.split(\"\\\\s+\")\n        var count = 0\n\
    \        val result_list = new mutable.ListBuffer[Long]\n        for (paren_str\
    \ <- paren_list) {\n            val paren_count = paren_str.count('(')\n     \
    \       val open_paren_count = paren_str.count('(')\n            val close_paren_count\
    \ = paren_str.count(')')\n            if (open_paren_count == paren_count && close_paren_count\
    \ == paren_count) {\n                count += open_paren_count * close_paren_count\n\
    \                result_list += count.toLong\n                count = 0\n    \
    \        }\n        }\n        result_list += count.toLong\n        return result_list.toList",
  "        var level : Int = 0\n        var stack : List[Int] = Nil\n        var res\
    \ : List[Long] = Nil\n        var temp_str : String = \"\"\n        for (c <-\
    \ paren_string){\n            temp_str = temp_str + c\n            if( c == '('\
    \ || c == '{' ){\n                stack = stack :+ level\n            }else if(\
    \ c == ')' || c == '}' ){\n                if(stack.isEmpty){\n              \
    \      res.length = 0\n                    level = 0\n                    res.reverse.foreach(x\
    \ => res += x)\n                    break\n                }else if( stack.lastOption.isDefined\
    \ ){\n                    level = stack.last.get\n                    stack =\
    \ stack.dropRight(1)\n                }\n            }\n        }\n        temp_str\
    \ = temp_str.substring(1)\n        temp_str.substring(1).split(\"\\\\(\").map(x\
    \ => x.trim).foreach(x => if(x == \"\") res += 0l else res += x.toLong)\n    \
    \    return res", "        paren_string\n            .replaceAllLiterally(\"\\\
    \\(|\\\\)\", \"\")\n            .split(\" \")\n            .map(x => if (x.equals(\"\
    ()\")) x.toLong else x.toLong - 1 )\n            .maxBy(_.toLong)\n          \
    \  .toList", "        val paren_chars = paren_string.split(\" \").toList\n   \
    \     val max_depth = paren_chars.foldLeft(0){ (maxDepth, paren_char) => maxDepth.getOrElse(paren_char.length)\
    \ + 1 }\n        val nested_parens = paren_chars.foldRight(List.empty[List[Long]])\
    \ { (nesting_levels, paren_char) =>\n            if (nesting_levels.isEmpty) List.fill(max_depth)(1l.toLong)\n\
    \            else if (nesting_levels.last == max_depth) nesting_levels ++ List.fill(max_depth\
    \ - nesting_levels.last)(1l.toLong)\n            else nesting_levels ++ List(nesting_levels.last\
    \ + 1, nesting_levels.last + 2)\n        }\n        return nested_parens.reverse",
  "        paren_string.split(\"\\\\ \").map {\n            string => {\n        \
    \        val paren_pairs = string.trim().split(\"\\\\)\")\n                paren_pairs.reverse.map(_.trim()).filter(_.nonEmpty).foldLeft(List.empty[Long])\
    \ { (a, p) =>\n                    val bracket_index = a.size + 1\n          \
    \          val index = p.indexOf(\"(\")\n                    val depth = if (index\
    \ >= 0) index else paren_pairs.indexOf(p) + 1\n                    a.update(bracket_index,\
    \ (depth.toLong))\n                    a\n                }\n            }\n \
    \       }", "        val depth = paren_string.split(\"(?<=\\\\()\").toList.map(_.length).toList.max\n\
    \        (1 to depth).map(x => paren_string.split(\"(?<=\\\\()\").toList.map(_.length).toList.max)",
  "        // Initialize the current level of nesting to 0 and max nesting to 1.\n\
    \        var current_level = 0\n        var max_level = 1\n        val paren_chars\
    \ = paren_string.asInstanceOf[Seq[Char]]\n        // Keep track of whether the\
    \ current level of nesting has changed since the previous iteration\n        var\
    \ changed = false\n        // The depth of the parenthesis group. Start with zero.\n\
    \        val depth = paren_chars.foldLeft(0)((n, c) => {\n            // Check\
    \ if the current character is a left parenthesis. If it is, the current_level\
    \ is increased.\n            // Else, the current_level is decreased. Also note\
    \ the changed flag\n            val current_level_changed = if (c == '(') current_level\
    \ else current_level - 1\n            changed = changed || current_level_changed\n\
    \n            // Increase the max level if the character is an opening paranthesis.\n\
    \            if (c == '(') max_level += 1\n            else if (c == ')') max_level\
    \ -= 1\n            n + (if (current_level_changed > 0) current_level_changed\
    \ else -current_level_changed)\n        })\n\n        // The length of the longest\
    \ sequence to consider\n        val max_length = max_level * depth\n        val\
    \ groups = paren_chars.sliding(max_length).toList\n        // Store the resulting\
    \ list of depths because we need to return it as a List instead of Int\n     \
    \   val depths = groups.foldLeft(List[Long]())((d, c) => d :+ c(0).asInstanceOf[Long])\n\
    \        val max_depth = depths.max\n\n        // Initialize the result list to\
    \ hold all the maximum depths\n        val result = new Array[Long](max_depth\
    \ + 1)\n\n        // Start the traversal from the longest sequence\n        val\
    \ depths_index = 0\n        var last_position = 0\n        // Keep track of whether\
    \ the current longest sequence has changed since the previous iteration\n    \
    \    var changed = false\n        while (last_position < paren_string.length &&\
    \ depths_index < depths.length) {\n            // Find the longest sequence\n\
    \            val longest_seq = paren_chars.takeWhile(_ != '(')\n            val\
    \ longest_seq_length = longest_seq.length\n            changed = changed || longest_seq_length\
    \ > max_length\n            // Update the longest sequence and position\n    \
    \        last_position = last_position + longest_seq_length\n            // Store\
    \ the position of the last parenthesis character in the longest sequence\n   \
    \         val last_paren_pos = paren_chars.indexOf(')', last_position)\n     \
    \       // Check if the current longest sequence contains more than one left parenthesis\
    \ character\n            if (last_paren_pos < last_position) {\n             \
    \   // If the longest sequence contains more than one left parenthesis character,\
    \ then\n                // find the deepest level of nesting by count", "    \
    \    var level : List[Long] = Nil\n        for(group <- paren_string.split(\"\\\
    \\s\")) {\n            group = group.trim\n            val temp = if (group.length\
    \ == 0)\n                Nil\n            else\n                parseNestedParensHelper(group,\
    \ level)\n            level = List(temp.size)\n        }\n        level.reverse",
  "        // Initialize a max variable and an accumulator to count number of open\
    \ parantheses.\n        var max_level = 0\n        var count = 0\n        // Keep\
    \ traversing through each character of the string.\n        for (char <- paren_string.toCharArray)\
    \ {\n            // If the character is opening parentheses, increment count of\
    \ open parantheses.\n            if (char == '(') count += 1\n            // If\
    \ the character is closing parentheses, decrement count of open parantheses.\n\
    \            if (char == ')') count -= 1\n            // If the count is 0, update\
    \ the max_level variable and break out of the loop.\n            if (count ==\
    \ 0) max_level = count\n        }\n        // If the current max_level value is\
    \ bigger than the previous max_level value, update the max_level value accordingly.\n\
    \        if (max_level > max_level) max_level = max_level\n        // Finally\
    \ return the max_level value.\n        max_level.toList", "        val stringSet\
    \ = paren_string.split(\" \").map(_.toUpperCase())\n        val paren_chars =\
    \ paren_string.chars.toList\n        val paren_char_list: List[Char] = paren_chars.filterNot(_\
    \ => '(').filterNot(_ => ')').toList\n        val stack: List[Char] = new ListBuffer[Char]()\n\
    \        paren_char_list.foreach { character =>\n            val is_opening =\
    \ paren_char_list.contains(character)\n            val is_closing = paren_char_list.contains(character\
    \ + '(')\n            val is_open = paren_char_list.contains(character + '(')\n\
    \            val is_close = paren_char_list.contains(character + '(')\n      \
    \      val is_empty = paren_char_list.contains(character + ')')\n\n          \
    \  if (is_opening || is_close || is_empty || is_open || is_closing || paren_char_list.contains(character\
    \ + '(')) {\n                if (is_empty)\n                    stack.toList.reverse\n\
    \                else if (stack.size < 2)\n                    stack.toList.reverse\n\
    \                else\n                    stack.toList.reverse\n            }\
    \ else\n                stack.push(character)\n        }\n        stack.toList.reverse",
  "        val parens = paren_string.trim().split(\"\\\\s+\").filter(_.length != 0)\n\
    \        val paren_count = parens.length\n        val paren_stack = new Stack[Long](paren_count)\n\
    \        parens.map(paren_stack += paren_stack.top).foldLeft[List[Long]](List.empty)((acc,\
    \ paren) => {\n            paren match {\n                case \"(\" => paren_stack.push(1l)\n\
    \                case \")\" => paren_stack.pop\n                case _ => acc\n\
    \            }\n            paren_stack\n        })", "        paren_string.split(\"\
    \ \").map(x => {\n            val y = x.trim.split(\"(\")\n            val z =\
    \ y.map(z => z.trim.split(\")\"))\n            val n = z.size\n            val\
    \ m = y.size\n            if (n == 1 && m == 1) {\n                y.map(z =>\
    \ z.trim.split(\"(\").map(x => x.trim.split(\")\").size).toList.head.toLong\n\
    \            } else if (n == m) {\n                y.map(z => z.trim.split(\"\
    (\").map(x => x.trim.split(\")\").size).toList.head.toLong + 1l.toLong\n     \
    \       } else {\n                0l.toLong\n            }\n        }).toList",
  "        val paren_levels = mutable.MutableList[Long]()\n        for (char <- paren_string.toCharArray)\
    \ {\n            if (char == '(') paren_levels += 1\n            if (char == ')')\
    \ paren_levels -= 1 \n        }\n        paren_levels", "        val paren_str\
    \ = paren_string.trim\n        val paren_str_length = paren_str.length\n     \
    \   var paren_depth = 0\n        var paren_level_size = 0\n\n        // Create\
    \ a list of [paren_depth, paren_level_size] pairs.\n        // The first paren_level\
    \ has the highest paren_depth.\n        // The next paren_level has the next highest\
    \ paren_depth.\n        var paren_level_pairs: List[(Long, Long)] =\n        \
    \    paren_str.split(\" \").foldRight((0l, 0l))((a,b) => \n                (a._1\
    \ + b.toLong,\n                 a._2 + 1L))\n\n        // Iterate through the\
    \ list to determine the deepest level of nesting.\n        while (paren_level_pairs.last._2\
    \ > paren_depth) {\n            paren_level_pairs = paren_level_pairs.tail\n \
    \           paren_level_pairs.reverse.foreach { case (_, size) => paren_level_pairs\
    \ = paren_level_pairs.tail }\n        }\n\n        // Return the list\n      \
    \  val result = paren_level_pairs.last._1\n        paren_level_pairs.dropRight(1).reverse.foreach(x\
    \ => result += x._1)\n        result", "        val pattern = \"\"\"(?:\\(|\\\
    ()|(?<=(?:\\)))|(?<=(?:\\()|\\)))\"\"\".r\n        val paren_list = new mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while(i < paren_string.length) {\n            val\
    \ result = paren_string.find(pattern(i))\n            if (result == None) {\n\
    \                paren_list += 0\n            } else {\n                if (result(1)\
    \ == 1) {\n                    paren_list += 0\n                } else if (result(1)\
    \ == -1) {\n                    paren_list += paren_list.length\n            \
    \    }\n            }\n            i += 1\n        }\n        paren_list.toList",
  "        val paren_splits = paren_string.split(\" \").map(_.toLong)\n        val\
    \ parentheses_levels : List[Long] = paren_splits.foldLeft(List[Long](0l)){ (acc,\
    \ el) =>\n            if(el > acc.last){\n                val l = [el - acc.last]\n\
    \                acc.reverse ::: l\n            } else acc.reverse\n        }\n\
    \        parentheses_levels.map(_.toLong)", "        paren_string.split(\" \"\
    ).map { s =>\n            val brackets = bracketPairs(s)\n            if (brackets.isEmpty)\
    \ {\n                sys.error(\"Parenthesis string '\" + paren_string + \"' does\
    \ not contain any brackets!\")\n            }\n            s.split(\"\\\\(\").map\
    \ { bracketPair =>\n                bracketPair.split(\"\\\\)\")\n           \
    \ }.flatMap { bracketPair =>\n                bracketPair.map { bracketPair =>\n\
    \                    if (bracketPair.length == 1) {\n                        val\
    \ startIndex = bracketPair.indexOf(bracketPair(0))\n                        val\
    \ endIndex = bracketPair.length + startIndex + 1\n                        val\
    \ currentLevel = bracketPair.length - startIndex\n                        List(startIndex,\
    \ endIndex, currentLevel)\n                    } else {\n                    \
    \    val startIndex = bracketPair.indexOf(bracketPair(0))\n                  \
    \      val endIndex = bracketPair.length + startIndex + 1\n                  \
    \      val currentLevel = bracketPair.length - startIndex\n                  \
    \      List(startIndex, endIndex, currentLevel)\n                    }\n     \
    \           }\n            }.maxBy(_._3) match {\n                case (startIndex,\
    \ endIndex, currentLevel) =>\n                    List(startIndex, endIndex, currentLevel)\n\
    \                case _ =>\n                    sys.error(\"Parenthesis string\
    \ '\" + paren_string + \"' does not contain any brackets!\" + \" Please check\
    \ brackets!\");\n            }\n        }.maxBy(_._2)", "        // Find all groups\
    \ in paren_string separated by spaces\n        val group_list : List[(String,List[String])]\
    \ = paren_string.split(\"\\\\s+\".r).map(\n            x => (x.trim,List[String]())\n\
    \        ).filter(x => !x._1.isEmpty).map(x => (x._1,x._2.map(_.trim))).toList\n\
    \        val max_nested_level = group_list.map(_.map(_(1).size).max).max\n   \
    \     group_list.map(x => x(1).size - x(1).map(_.size).max)", "        var result:\
    \ List[Long] = Nil\n        // Create a list of open and close paren\n       \
    \ val paren_list = paren_string.split(\"(?<=\\\\()|\\\\)(?=\\\\))\").map(_.toLong)\n\
    \        // Create a map of (open,close) pair\n        val open_close = paren_list.zip(paren_list).map{\
    \ case (open_close, close_open) => (open_close, close_open) }.toMap\n        //\
    \ Get the level of nesting for each open paren\n        for (open_close <- open_close.keys)\
    \ {\n            val open_paren = open_close._1\n            val close_paren =\
    \ open_close._2\n            val open_paren_level = open_paren.toInt - 1\n   \
    \         val close_paren_level = close_paren.toInt - 1\n            if (open_paren_level\
    \ < close_paren_level) {\n                val open_close_list = open_close.filter(_._1\
    \ <= open_paren_level).map(_._1).toList\n                val close_close_list\
    \ = open_close.filter(_._2 > close_paren_level).map(_._2).toList\n           \
    \     val close_list = new List(close_close_list.tail).reverse.map(x => close_paren_level\
    \ - x).toList\n                val open_list = open_close_list.map(x => open_paren_level\
    \ + x).toList\n                val result = open_close_list.zip(close_list).foldLeft(open_list)((x,\
    \ y) => x ++ y)\n            }\n        }\n        result", "        val stack\
    \ = mutable.Stack[String]()\n        val max_level = 0\n        paren_string.split(\"\
    \\\\s(?=\\\\()\").foreach(elem => {\n            val cur = paren_string replace\
    \ elem \"\" //replace space with empty string\n            val cur_list = parseNestedParens(cur)\n\
    \            if (cur_list.length >= max_level)\n                max_level = cur_list.length\n\
    \            stack push elem\n        })\n        stack map {elem => elem +: parseNestedParens(elem)}\
    \ filter { _ > 0 } map {elem => elem.length.toLong} max //get longest level",
  "        def nestedParens(paren_string : String) : List[Long] = {\n            //\
    \ Initialize the list of current levels.\n            var level = 0\n        \
    \    var current = 1\n            var currentString : String = \"\"\n        \
    \    var paren_chars : List[Int] = paren_string.toCharArray\n            // For\
    \ each character in the string check if it's a left or right parenthesis.\n  \
    \          for (c <- paren_chars) {\n                currentString += c\n    \
    \            if (c == '(') {\n                    current++\n                \
    \    if (current > level) {\n                        level = current\n       \
    \             }\n                }\n                else if (c == ')') {\n   \
    \                 current--\n                }\n            }\n            val\
    \ l = new ListBuffer[Long]\n            // Add the current level to the list.\n\
    \            l += level\n            // Return the list.\n            l.toList\n\
    \        }\n\n        // Initialize the list of current levels.\n        var level\
    \ = 0\n        var current = 1\n        var currentString : String = \"\"\n  \
    \      var paren_chars : List[Int] = paren_string.toCharArray\n        // For\
    \ each character in the string check if it's a left or right parenthesis.\n  \
    \      for (c <- paren_chars) {\n            currentString += c\n            if\
    \ (c == '(') {\n                current++\n                if (current > level)\
    \ {\n                    level = current\n                }\n            }\n \
    \           else if (c == ')') {\n                current--\n            }\n \
    \       }\n        val l = new ListBuffer[Long]\n        // Add the current level\
    \ to the list.\n        l += level\n        // Return the list.\n        l.toList",
  "        // Use a mutable list to store all the group lengths\n        var max_group_length\
    \ : Long = 0\n        val paren_groups : mutable.Buffer[List[Long]] =\n      \
    \      paren_string.split(\"\\\\s+\".r).map(x => x.split(\"\\\\(\".toString.r).map(y\
    \ => y.toString.toLong).grouped(x.toString.toLong).toList).toList\n        paren_groups.filter(x\
    \ => x.forall(y => y.toString.toLong > 0)).foreach(x => max_group_length = x.max().toString.toLong)\n\
    \        max_group_length", "        var result = Nil\n        var paren_stack\
    \ = new mutable.Queue[String]()\n        paren_stack += paren_string\n       \
    \ var nesting_level = 0\n\n        while (paren_stack.nonEmpty) {\n          \
    \  paren_string = paren_stack.poll()\n            if (paren_string == \"(\") {\n\
    \                paren_stack.enqueue(\")\")\n                nesting_level +=\
    \ 1\n                if (nesting_level > 1) {\n                    result = result\
    \ :+ nesting_level.toLong\n                }\n            } else if (paren_string\
    \ == \")\") {\n                paren_stack.enqueue(\"(\")\n                nesting_level\
    \ -= 1\n            }\n        }\n        return result.toList", "        // Convert\
    \ string into stream of characters\n        val charStream = scala.io.Codec.ascii.getDecoder.decodeString(paren_string)\n\
    \        // Keep track of number of open parens\n        var numOpeningParens\
    \ = 0\n        // Keep track of number of closing parens\n        var numClosingParens\
    \ = 0\n        // Keep track of number of opening braces\n        var numOpeningBraces\
    \ = 0\n        // Keep track of number of closing braces\n        var numClosingBraces\
    \ = 0\n        // Keep track of number of open brackets\n        var numOpeningBrackets\
    \ = 0\n        // Keep track of number of closing brackets\n        var numClosingBrackets\
    \ = 0\n        // Keep track of number of open angles\n        var numOpeningAngles\
    \ = 0\n        // Keep track of number of closing angles\n        var numClosingAngles\
    \ = 0\n        // Keep track of number of open commas\n        var numOpeningCommas\
    \ = 0\n        // Keep track of number of closing commas\n        var numClosingCommas\
    \ = 0\n        \n        // Keep track of deepest level of nesting of parens\n\
    \        var deepestLevelOfNesting = 0\n        \n        // Keep track of number\
    \ of open parens\n        while(numOpeningParens == 0 && numClosingParens == 0\
    \ && numOpeningBraces == 0 && numClosingBraces == 0 && numOpeningBrackets == 0\
    \ && numClosingBrackets == 0 && numOpeningAngles == 0 && numClosingAngles == 0\
    \ && numOpeningCommas == 0 && numClosingCommas == 0) {\n            // Read next\
    \ character from the stream\n            val c = charStream.read()\n         \
    \   // If it is opening parentheses, increase the count\n            if(c.toInt\
    \ == '(') numOpeningParens += 1\n            // If it is closing parentheses,\
    \ decrease the count\n            else if(c.toInt == '(') numClosingParens -=\
    \ 1\n            // If it is opening braces, increase the count\n            else\
    \ if(c.toInt == '{') numOpeningBraces += 1\n            // If it is closing braces,\
    \ decrease the count\n            else if(c.toInt == '}') numClosingBraces -=\
    \ 1\n            // If it is opening brackets, increase the count\n          \
    \  else if(c.toInt == '[') numOpeningBrackets += 1\n            // If it is closing\
    \ brackets, decrease the count\n            else if(c.toInt == ']') numClosingBrackets\
    \ -= 1\n            // If it is opening angles, increase the count\n         \
    \   else if(c.toInt == '<') numOpeningAngles += 1\n            // If it is closing\
    \ angles, decrease the count\n            else if(c.toInt == '>') numClosingAngles\
    \ -= 1\n            // If it is opening commas, ", "        val paren_list = paren_string.split(\"\
    \\\\(|\\\\)\")\n        val paren_list_without_empty_lists = paren_list.filter(x\
    \ => x.contains(\"()\"))\n        var list_with_max_count = 0\n        val max_list\
    \ = new mutable.MutableList[Long]\n        var max_list_index = 0\n        for(i\
    \ <- 0 until paren_list_without_empty_lists.length){\n            if(paren_list_without_empty_lists(i).contains(\"\
    ()\")){\n                val paren_list2 = paren_list_without_empty_lists(i).split(\"\
    \\\\(|\\\\)\")\n                val paren_list2_without_empty_lists = paren_list2.filter(x\
    \ => x.contains(\"()\"))\n                if(paren_list2_without_empty_lists.size\
    \ > max_list.length){\n                    list_with_max_count = paren_list2_without_empty_lists.size\n\
    \                    max_list = paren_list2_without_empty_lists\n            \
    \        max_list_index = i\n                }\n            }\n        }\n   \
    \     max_list.getMax", "      val (parens, paren_count) = paren_string.trim().toLowerCase\
    \ match {\n          case \"\" => (List(), 0)\n          case \"()\" => (List(),\
    \ 0)\n          case s =>\n            val s_idx = s.indexOf(')')\n          \
    \  val sub = s.substring(0,s_idx)\n            val sub_list = parseNestedParens(sub)\n\
    \            val open = s.substring(s_idx, s.length)\n            val open_list\
    \ = parseNestedParens(open)\n            (sub_list, open_list ++ 1)\n        }\n\
    \      val parens_idx = paren_count - 1\n      val max_level = parens_idx / 2\n\
    \      val cur_level = (parens_idx) % 2\n      val open_pos = if (cur_level ==\
    \ 0) 0 else max_level\n      val closed_pos = open_pos + 1\n      val max_open_pos\
    \ = max_level + 2\n      if (parens_idx < max_open_pos * 2) max_open_pos\n   \
    \   else if (parens_idx > max_open_pos * 3) max_open_pos * 3\n      else if (parens_idx\
    \ > max_open_pos * 4) max_open_pos * 4\n      else if (parens_idx > max_open_pos\
    \ * 5) max_open_pos * 5\n      else if (parens_idx > max_open_pos * 6) max_open_pos\
    \ * 6\n      else if (parens_idx > max_open_pos * 7) max_open_pos * 7\n      else\
    \ {\n        val max_open_pos = max_level + 2\n        val max_close_pos = max_open_pos\
    \ * 4\n        if (parens_idx > max_open_pos * 3) max_open_pos * 3\n        else\
    \ if (parens_idx > max_open_pos * 4) max_open_pos * 4\n        else if (parens_idx\
    \ > max_close_pos * 2) max_open_pos * 2\n      }\n      val open_parens = parens.take(max_open_pos)\n\
    \      val close_parens = parens.take(max_close_pos)\n      (open_parens ++ close_parens)",
  "        var level = 0\n        var max_level = 0\n        var paren_count = 0\n\
    \        var levels = [Long]()\n        var paren_char_count = 0\n        var\
    \ paren_char_index = 0\n        var paren_strings = paren_string.split(\" \").toList.map(_.toChar)\n\
    \        while (paren_char_index < paren_strings.length) {\n            if (paren_string(paren_char_index)\
    \ == '(') {\n                paren_count += 1\n                level = 0\n   \
    \             paren_char_count = 0\n                paren_char_index += 1\n  \
    \              if (paren_string(paren_char_index) != ')') {\n                \
    \    levels += 1\n                }\n            } else {\n                paren_char_count\
    \ += 1\n                level = level + 1\n                if (paren_char_count\
    \ == level) {\n                    paren_count -= 1\n                    if (paren_count\
    \ == 0 && paren_string(paren_char_index) == '(') {\n                        max_level\
    \ = level\n                    }\n                    paren_char_count = 0\n \
    \                   paren_strings = paren_strings.dropRight(1)\n             \
    \       if (paren_strings.isEmpty) {\n                        break\n        \
    \            } else {\n                        paren_strings = paren_strings.tail\n\
    \                        levels = [Long]()\n                    }\n          \
    \      }\n            }\n        }\n        levels = levels.reverse\n        levels.foreach(l\
    \ => if (max_level > l) max_level = l)\n        levels.reverse", "        // This\
    \ array has 2 elements and is initialized with 2 empty lists.\n        // The\
    \ first element is the list of all nested groups,\n        // while the second\
    \ element is the list of all deepest levels.\n        // We loop over all possible\
    \ groups of the given paren_string.\n        // The code uses recursion to explore\
    \ all possible groups of nested parentheses.\n        // The final list is the\
    \ list of all deepest levels, with the last element removed.\n        val groups:\
    \ List[List[String]] = List(List(), List())\n        var group = 0\n        var\
    \ level = 0\n        val parens = paren_string.split(\" \")\n        val paren_level\
    \ = paren_string.count(_ == '(')\n        var paren_group = 0\n\n        for (i\
    \ <- 0 until parens.length) {\n            val paren = parens(i)\n           \
    \ if (paren == '(') {\n                groups(group) = paren_string.substring(0,\
    \ i)\n                paren_group = group\n                groups = groups.updated(group,\
    \ List(paren_string.substring(0, i)))\n                group = group + 1\n   \
    \         } else if (paren == ')') {\n                groups = groups.updated(group,\
    \ paren_string.substring(0, i).split(\" \"))\n                group = group -\
    \ 1\n                val paren_group_size = groups(group).count('(')\n       \
    \         for (j <- 0 until paren_group_size) {\n                    val paren_group_sub\
    \ = groups(group).split('(')\n                    groups = groups.updated(paren_group\
    \ - 1, List(paren_group_sub(0), paren_group_sub(j + 1)))\n                }\n\
    \                level = (paren_group - 1).toLong\n            } else {\n    \
    \            groups = groups.updated(group, paren_string.substring(0, i).split(\"\
    \ \"))\n                groups = groups.updated(group, List(paren_string.substring(0,\
    \ i)))\n                group = group + 1\n            }\n        }\n        if\
    \ (paren_level != paren_group) {\n            val tmp = groups(group)\n      \
    \      groups = groups.updated(group, tmp.substring(0, paren_level).split(\" \"\
    ))\n            groups = groups.updated(group, tmp)\n        }\n        groups(group)",
  "        // Create a stack of lists\n        var nested_parens : List[List[Long]]\
    \ = Nil\n\n        // Create a stack of strings representing parenthesis\n   \
    \     var paren_strings : List[String] = Nil\n\n        // Iterate over the string\
    \ and push into stack\n        var index : Long = 1\n        while (index < paren_string.length)\
    \ {\n            // If the character is a closing parenthesis\n            if\
    \ (paren_string(index) == \"(\") {\n                // If the stack is empty (first\
    \ opening parenthesis)\n                if (nested_parens.length == 0) {\n   \
    \                 // Create a new list with index at 0 and increment index\n \
    \                   nested_parens = List((new List(index)))\n                \
    \    paren_strings = List((paren_string(index + 1)))\n                    index\
    \ += 1\n                }\n                // If the stack is not empty (nested\
    \ parenthesis)\n                else {\n                    // Find the corresponding\
    \ closing parenthesis in the string\n                    var close_paren_index\
    \ : Long = -1\n                    while (close_paren_index < paren_strings.length\
    \ - 1) {\n                        if (paren_strings(close_paren_index) == paren_string(index))\
    \ {\n                            break\n                        }\n          \
    \              close_paren_index += 1\n                    }\n               \
    \     // If found the corresponding closing parenthesis push into stack\n    \
    \                if (close_paren_index == paren_strings.length - 1) {\n      \
    \                  nested_parens = nested_parens ::: List(nested_parens(nested_parens.length\
    \ - 1).map(_.toLong).reverse)\n                        paren_strings = paren_strings\
    \ ::: List((paren_string(index + 1)))\n                        index += 1\n  \
    \                  }\n                    // Otherwise the closing parenthesis\
    \ does not belong to the nested parenthesis stack.\n                    else {\n\
    \                        // Remove the corresponding closing parenthesis from\
    \ the string stack\n                        paren_strings = paren_strings.init\n\
    \                        index += 1\n                    }\n                }\n\
    \            }\n            // If the character is a opening parenthesis\n   \
    \         else if (paren_string(index) == \"(\") {\n                // If the\
    \ stack is empty (first opening parenthesis)\n                if (nested_parens.length\
    \ == 0) {\n                    // Create a new list with index at 0 and increment\
    \ index\n                    nested_parens = List((new List(index)))\n       \
    \             paren_strings = List((paren_string(index + 1)))\n              \
    \      index += 1\n                }\n                // If the stack is not empty\
    \ (nested parenthesis)\n                else {\n                    // Find the\
    \ corresponding opening parenthesis in the string\n                    var open_paren_index\
    \ : Long = -1\n                    while (open_paren_index < paren_strings.length\
    \ - 1) {\n                        if (paren_strings(open_paren_index) == paren_string(index))\
    \ {\n                            break\n                        }\n          \
    \              open_paren_index += 1\n                    }\n                \
    \    // If found the corresponding opening parenthesis push into stack\n     \
    \               if (open_paren_index == paren_strings.length - 1) {\n        \
    \                nested_parens = nested_parens ::: List(nested_parens(nested_parens.length\
    \ - ", "        def nestedLoop(i : Int, group : List[String], max_count : Int,\
    \ count : Int) : List[Long] = {\n            if(group.isEmpty) {\n           \
    \     if(count == max_count) {\n                    group match {\n          \
    \              case Nil => List(1l.toLong)\n                        case head\
    \ :: tail => nestedLoop(i - 1, tail, max_count, count + 1)\n                 \
    \   }\n                } else {\n                    list match {\n          \
    \              case Nil => List(1l.toLong)\n                        case head\
    \ :: tail => nestedLoop(i - 1, tail, max_count, count)\n                    }\n\
    \                }\n            } else {\n                max_count match {\n\
    \                    case 0 => list match {\n                        case Nil\
    \ => List(1l.toLong)\n                        case head :: tail => nestedLoop(i\
    \ - 1, tail, count, count)\n                    }\n                    case head\
    \ => list match {\n                        case Nil => List(1l.toLong)\n     \
    \                   case head :: tail => nestedLoop(i - 1, tail, count, count)\n\
    \                    }\n                }\n            }\n        }\n        val\
    \ list = paren_string.split(\" \").toList\n        list match {\n            case\
    \ Nil => Nil\n            case head :: tail => nestedLoop(0, tail, 0, 0)\n   \
    \     }", "        var max_level = List(0)\n        var paren_count = paren_string.length\n\
    \n        for( i <- 0 until paren_count ) {\n            if( paren_string contains\
    \ \"(\" ) {\n                if( max_level.isEmpty || max_level(0) < paren_count\
    \ ) {\n                    max_level :+= paren_count\n                }\n    \
    \            paren_count -= 1\n            } else if( paren_string contains \"\
    )\" ) {\n                if( paren_count > 0 ) {\n                    paren_count\
    \ -= 1\n                }\n            } else if( paren_string contains \" \"\
    \ ) {\n                if( paren_count > 0 ) {\n                    paren_count\
    \ -= 1\n                }\n            }\n        }\n\n        return max_level",
  "        var deepest_level = 1\n\n        // Initialize all level to 1\n       \
    \ val levels = mutable.LinkedHashMap[Long, Long]()\n        levels(1l.toLong)\
    \ = 1\n        levels(0l.toLong) = 1\n        \n        // Loop through all parenthesis\n\
    \        var level = 1\n        var pos = 0\n        var paren_count = 0\n   \
    \     var is_open = true\n        while((pos = paren_string.indexOf(\"(\", pos)\
    \ + 1) != -1) {\n            paren_count += 1\n            \n            // If\
    \ the level is not a sublevel of current, then count it.\n            if(levels(level)\
    \ != 1) {\n                levels(level) = paren_count\n            }\n      \
    \      \n            // Increase the level\n            level += 1\n         \
    \   \n            // Increase the parenthesis count\n            paren_count +=\
    \ 1\n            \n            // If the current level is not a sublevel of current\
    \ level, then increase the deepest level\n            if(levels(level) != 1) {\n\
    \                deepest_level += 1\n                levels(deepest_level) = paren_count\n\
    \            }\n            \n            // Check if the parenthesis is closed,\
    \ then decrease the parenthesis count.\n            if(paren_string.charAt(pos)\
    \ == ')') {\n                paren_count -= 1\n            }\n\n            //\
    \ Check if the string is closed.\n            if(paren_string.charAt(pos) == ')')\
    \ {\n                is_open = false\n            }\n            \n          \
    \  pos += 1\n        }\n        \n        // If the string is not closed, then\
    \ increase the deepest level.\n        if(paren_string.charAt(pos) != ')') {\n\
    \            deepest_level += 1\n            levels(deepest_level) = paren_count\n\
    \        }\n        \n        // If the deepest level is 1 and string is not closed,\
    \ then it means it is an empty string.\n        if(deepest_level == 1 && !is_open)\
    \ {\n            return List()\n        }\n        \n        return levels(deepest_level)",
  "        if (paren_string.isEmpty) return Nil\n        var max : Long = 0\n    \
    \    var results : List[Long] = Nil\n        var parantheses_count : Long = 0\n\
    \        var paren_char : Char = paren_string.charAt(0)\n\n        for (i<- 1\
    \ to paren_string.length-1) {\n            // We have reached the end of the string\
    \ without finding another parentheses.\n            if (paren_char != '(') \n\
    \                break;\n\n            // Increment the count of open parentheses\
    \ encountered.\n            parantheses_count += 1;\n\n            // If the count\
    \ of open parentheses reaches equal to the count of closed parentheses encountered,\
    \ \n            // that means we encountered a right most parentheses.\n     \
    \       if (parantheses_count == paren_string.charAt(i) - paren_char) {\n    \
    \            // Add one to the count.\n                parantheses_count += 1;\n\
    \n                // If the max count of closing parentheses has not yet been\
    \ encountered, \n                // we encounter a left most parentheses.\n  \
    \              if (parantheses_count < max)\n                    max = parantheses_count\n\
    \            }\n\n            // Reset the count of parentheses encountered.\n\
    \            parantheses_count = 0;\n        }\n        // Add the count of closed\
    \ parentheses.\n        max += parantheses_count - 1\n        results = paren_string.drop(1).grouped(max).toList\n\
    \        results.reverse", "        var max_count = 0\n        var max_level =\
    \ IntMaxValue\n        paren_string.split(\" \")\n            .flatMap(x => if(x.toDouble==\"\
    ()\") List() else List(x.toDouble.toLong))\n            .foreach { x =>\n    \
    \        val count = x * (max_level + 1)\n            if(count > max_count) max_count\
    \ = count\n            max_level = count\n        }\n        List(max_level)",
  "        // (1)\n        var max_level = 0\n        var min_level = 0\n        var\
    \ paren_index = 0\n        // (2)\n        var paren_list_with_pairs = mutable.ListBuffer[(Int,\
    \ Int)]()\n        for (i <- 0 until paren_string.length()) {\n            //\
    \ (3)\n            val c = paren_string(i)\n            // (4)\n            if\
    \ (c == '(') {\n                paren_index += 1\n            }\n            //\
    \ (5)\n            if (c == ')') {\n                val level = (paren_index -\
    \ min_level)\n                // (6)\n                if (level > max_level) {\n\
    \                    max_level = level\n                    // (7)\n         \
    \           paren_list_with_pairs.clear()\n                    paren_list_with_pairs\
    \ += (paren_index, paren_index)\n                }\n                // (8)\n \
    \               if (level < min_level) {\n                    min_level = level\n\
    \                    // (9)\n                    paren_index += 1\n          \
    \      }\n            }\n            // (10)\n            else {\n           \
    \     // (11)\n                val pair = (paren_index, paren_index)\n       \
    \         // (12)\n                paren_list_with_pairs += pair\n           \
    \     paren_index += 1\n            }\n        }\n        // (13)\n        if\
    \ (max_level == 0) {\n            return paren_list_with_pairs.toList\n      \
    \  }\n        else {\n            return paren_list_with_pairs.filter(_._1 <=\
    \ max_level).toList\n        }", "        val paren_list = paren_string.split(\"\
    \ +\")\n        val paren_ret_list = paren_list.map(x => parseNestedParens(x))\n\
    \        val paren_ret_list1 = paren_ret_list.flatMap(x => x)\n        val max1\
    \ = paren_ret_list1.maxBy(_.length)\n        val max2 = paren_ret_list1.maxBy(x\
    \ => paren_ret_list1.count(y => y == x)).map(x => x.length)\n        val max3\
    \ = paren_ret_list1.maxBy(x => paren_ret_list1.count(y => y == x)).map(x => paren_ret_list1.count(y\
    \ => y == x))\n        val max4 = paren_ret_list1.maxBy(x => paren_ret_list1.count(y\
    \ => y == x)).map(x => paren_ret_list1.count(y => y == x)).map(x => x.toLong)\n\
    \n        val max_list = max1 + max2 + max3 + max4\n        val max_list1 = max_list.map(x\
    \ => x.toLong)\n        max_list1", "        paren_string\n            .split(\"\
    \ \")\n            .map(x => paren_string =~ x)\n            .foldLeft(List[Long]())\
    \ {\n            case (acc, x) => x match {\n                case Some((_, parens))\
    \ => acc.reverse.updated(parens.size+x)\n                case None => acc.updated(x)\n\
    \            }\n        }", "        val paren_groups = paren_string.split(\"\
    \ \").map(x => x.split(\"\\\\(\").map(y => y.split(\"\\\\)\").map(z => z.size.toLong).toSeq).flatten)\n\
    \        var max_nesting = -1\n        for (group <- paren_groups) {\n       \
    \     max_nesting = Math.max(max_nesting, group.max)\n        }\n        paren_groups.map(x\
    \ => x.max).toList", "        val paren_chars: List[Char] = paren_string.toCharArray\n\
    \        val parentheses: List[Char] = paren_chars.takeWhile(_ != '(').toList\n\
    \        val opening_parens_stack: List[String] = paren_chars.takeWhile(_ == '(').toList.reverse.takeWhile(_\
    \ != '(').toList\n        val opening_parens: String = \"\".join(opening_parens_stack.reverse)\n\
    \        val opening_parens_len = opening_parens.length\n        val paren_char_counts:\
    \ List[Long] = parentheses.foldLeft[List[Long]](Nil) { (acc, _) =>\n         \
    \   val i = acc.length\n            val c = paren_chars.toList\n            val\
    \ paren_char = paren_chars(i).toInt\n            val paren_count = opening_parens.count(x\
    \ => x == paren_char)\n            acc.updated(i, c+paren_count)\n        }\n\
    \        paren_char_counts.reverse", "        val paren_list: List[(Long, Long)]\
    \ = {\n            // Each element in the list is a tuple containing the deepest\
    \ level of nesting and the length of the parentheses encountered at the current\
    \ level.\n            val paren_length = mutable.MutableList[Long]()\n       \
    \     var paren_level = 0\n            val parentheses_encountered = mutable.MutableList[String]()\n\
    \            def process(paren_string : String, cur_level : Int) : Unit = {\n\
    \                // Remove all unnecessary elements from the list of parentheses\
    \ encountered at this level.\n                val parentheses_encountered_index\
    \ = parentheses_encountered.indexWhere(_ == paren_string)\n                if\
    \ (parentheses_encountered_index > 0) {\n                    parentheses_encountered.remove(parentheses_encountered_index)\n\
    \                }\n\n                // Add one to the level of nesting at the\
    \ current level.\n                paren_level += 1\n\n                // If this\
    \ level of parentheses is empty, add it to the list of parentheses encountered\
    \ at this level.\n                if (paren_level == 0) {\n                  \
    \  paren_length += cur_level\n                    parenthesis_encountered.append(paren_string)\n\
    \                }\n            }\n\n            for (i <- 1 to paren_string.length\
    \ by 2) {\n                val left_paren_index = paren_string.indexOf('(', i)\n\
    \                val right_paren_index = paren_string.indexOf(')', i)\n      \
    \          val left_paren = paren_string.substring(left_paren_index + 1, right_paren_index\
    \ - 1)\n                val right_paren = paren_string.substring(right_paren_index\
    \ + 1, i)\n\n                // Add all the parentheses encountered at this level\
    \ to the list of parentheses encountered at this level.\n                parentheses_encountered.add(left_paren)\n\
    \                parentheses_encountered.add(right_paren)\n\n                //\
    \ Process this level of parentheses.\n                process(left_paren, paren_level)\n\
    \                process(right_paren, paren_level)\n            }\n          \
    \  paren_length match {\n                case Nil => Nil\n                case\
    \ (a :: b :: Nil) => List(a.toLong)\n                case (a :: b :: c :: Nil)\
    \ => List(a.toLong, b.toLong, c.toLong)\n                case (a :: b :: c ::\
    \ d :: Nil) => List(a.toLong, b.toLong, c.toLong, d.toLong)\n                case\
    \ (a :: b :: c :: d :: e :: Nil) => List(a.toLong, b.toLong, c.toLong, d.toLong,\
    \ e.toLong)\n                case (a :: b :: c :: d :: e :: f :: Nil) => List(a.toLong,\
    \ b.toLong, c.toLong, d.toLong, e.toLong, f.toLong)\n", "        var paren_list\
    \ : List[Long] = Nil\n        var depth : List[Long] = Nil\n        var group\
    \ = 0\n        for (c <- paren_string.toCharArray) {\n            if (c == '(')\
    \ depth += 1\n            if (c == ')') {\n                depth -= 1\n      \
    \          group += 1\n            }\n            if (c == ' ' && depth >= 0 &&\
    \ group == 0) {\n                paren_list += depth\n                depth =\
    \ Nil\n                group = Nil\n            }\n        }\n        paren_list\
    \ += group\n        return paren_list", "        // Convert the paren string to\
    \ a char list for easier manipulation.\n        val parens = paren_string.chars.toList\n\
    \        // Initialize a hashmap to hold the depth of each parens\n        val\
    \ paren_hashMap = mutable.HashMap[Char, Int]()\n        // Initialize a set to\
    \ hold the deepest level of nesting \n        val max_depth = mutable.HashSet[Int]()\n\
    \        // Initialize the max_depth to -1 to indicate that there are no nested\
    \ parentheses in the string\n        max_depth(0) = -1\n        // Iterate through\
    \ the char list and update max_depth if the parens count changes\n        // This\
    \ ensures that max_depth is always updated with the deepest level of nesting for\
    \ each parens\n        for (ch <- parens) {\n            if (paren_hashMap.contains(ch))\
    \ {\n                // If the current char is the same as the previous char,\
    \ then increment the count for that char\n                paren_hashMap(ch) +=\
    \ 1\n            } else {\n                // Otherwise, add that char to the\
    \ hashMap and start counting chars from 0.\n                paren_hashMap(ch)\
    \ = 0\n            }\n            // If the max_depth for the current char is\
    \ greater than the previous one, \n            // set the current max depth to\
    \ that value for that char\n            if (paren_hashMap(ch) > max_depth(ch))\
    \ {\n                max_depth(ch) = paren_hashMap(ch)\n            }\n      \
    \  }\n        // Return the list of deepest level of nesting for each paren\n\
    \        max_depth.map(_.toLong)", "        var level = 0\n        var opening_level\
    \ = 0\n        paren_string.slidingWhile(_ != \"(\").foreach { paren =>\n    \
    \        val opening_open = paren.contains(\"(\")\n            val opening_close\
    \ = paren.contains(\")\")\n            val new_level = if opening_open then (level\
    \ + 1) else (level - 1)\n            val new_level = if (opening_close && new_level\
    \ > opening_level) new_level else opening_level\n            opening_level = new_level\n\
    \            level += 1\n        }\n        List(level.toLong)", "        var\
    \ result : List[Long] = Nil\n        var counter : Long = 1\n        for (char_list\
    \ <- paren_string.split(' ')) yield {\n            if (char_list.length > counter)\
    \ {\n                result ::= counter\n            }\n            counter +=\
    \ char_list.length\n        }\n        result", '        paren_string.split("\\s+").map(parseParen_1)',
  "        val groups = paren_string.split(\"\\\\s+\")\n        val max_levels = groups.map(_\
    \ match {\n            case parens : String if parens.isEmpty() => 0\n       \
    \     case parens : String if parens.contains(\"(\") => parens.length\n      \
    \      case parens : String if parens.contains(\")\")=> parens.length\n      \
    \      case parens : String if parens.contains(\"(\") => parens.length\n     \
    \       case _ => 0\n        }).max\n        groups.map(_ match {\n          \
    \  case parens : String if parens.isEmpty() => 0\n            case parens : String\
    \ if parens.contains(\"(\") => parens.length\n            case parens : String\
    \ if parens.contains(\")\")=> parens.length\n            case parens : String\
    \ if parens.contains(\"(\") => parens.length\n            case _ => 0\n      \
    \  }).dropRight(max_levels).map { level => level.toLong }", '        paren_string.trim().split("\\s+").map(l
    => if (l.length == 0) 0l else l.length)', "        val input = paren_string.split(\"\
    \ \")\n        val paren_str = new mutable.HashMap[Char, List[Long]]()\n     \
    \   paren_str.put('(, new mutable.ListBuffer[Long])\n        paren_str.put(')',\
    \ new mutable.ListBuffer[Long])\n        paren_str.put('{, new mutable.ListBuffer[Long])\n\
    \        paren_str.put('}', new mutable.ListBuffer[Long])\n        input.foreach(x\
    \ => paren_str.getOrElse(x, new mutable.ListBuffer[Long])).append(x.toLong)\n\
    \        val max_len = input.max\n        var result: List[Long] = Nil\n     \
    \   for (i <- 0 until max_len) {\n            val list = paren_str.getOrElse(input(i),\
    \ new mutable.ListBuffer[Long])\n            if (list.isEmpty) result = Nil\n\
    \            else {\n                val l = list.take(list.size - 1)\n      \
    \          if (l > result.length) result = list :: result\n                else\
    \ result = l :: result\n            }\n        }\n        result.toList", "  \
    \      // We want to find largest sequence of parentheses in paren_string using\
    \ recursion.\n        // We can do this by maintaining three states:\n       \
    \ // 1. If there are more parentheses in current state, return current state.\n\
    \        // 2. If current state has no more parentheses, return empty list.\n\
    \        // 3. If current state has more parentheses, return the state which has\
    \ more parentheses.\n        val opening = paren_string.count(\"(\")\n       \
    \ val closing = paren_string.count(\")\")\n\n        val state = List(0)\n   \
    \     var count = 0\n        while(count < paren_string.length){\n           \
    \ if(paren_string(count) == opening)\n                count += 1\n           \
    \ else if(paren_string(count) == closing){\n                count += 1\n     \
    \           state = List(count)\n            }\n            else\n           \
    \     state = state ::: List(count)\n            count += 1\n        }\n     \
    \   if(state.length > 0){\n            count = 1\n            while(count < paren_string.length){\n\
    \                if(paren_string(count) == opening)\n                    count\
    \ += 1\n                else if(paren_string(count) == closing){\n           \
    \         count += 1\n                    state = List(count)\n              \
    \  }\n                else\n                    state = state ::: List(count)\n\
    \                count += 1\n            }\n        }\n        state", "     \
    \ val paren_count = new mutable.HashMap[String, Int]()\n      for (i <- 0 until\
    \ paren_string.length) {\n        val p = paren_string(i)\n        if (paren_count.contains(p))\
    \ {\n          paren_count(p) += 1\n        } else {\n          paren_count(p)\
    \ = 1\n        }\n      }\n      val max_count = paren_count.values.max\n    \
    \  val max_key_list = paren_count.keys.toList.sortWith((a, b) => b.compareTo(a))\n\
    \      val max_key_length = max_key_list.map(_.length)\n      val max_key = max_key_list.last\n\
    \      var max_key_index = 0\n      val output = new mutable.ArrayList[Long]()\n\
    \      for (i <- 0 until paren_count.values.size) {\n        val key = max_key_list(i).toString\n\
    \        val count = paren_count(key)\n        val len = max_key_length(i)\n \
    \       val count = paren_count(key).toInt\n        if (count > max_count * 1.0)\
    \ {\n          // We are at the deepest level of nesting so we need to append\
    \ the key to the output\n          output.append(max_key)\n        } else {\n\
    \          // Key has already been appended\n          output.append(key)\n  \
    \      }\n        // We are done with this key so it can be removed from the hashmap\n\
    \        paren_count(key) = count - 1\n        if (count > 1) {\n          max_key_index\
    \ += 1\n        }\n      }\n      output.toList", "        paren_string.split(\"\
    \\\\s+\")\n            .filter(_.nonEmpty)\n            .foldLeft(List[Long]())\
    \ { (res, chars) =>\n                var max_level = 0\n                var is_open\
    \ = false\n                var index = 0\n                while (index < chars.length\
    \ ) {\n                    if (chars(index).equals(\"(\")) {\n               \
    \         is_open = true\n                    }\n                    if (chars(index)\
    \ == \")\") {\n                        if (is_open) {\n                      \
    \      is_open = false\n                        } else {\n                   \
    \         max_level = max_level + 1\n                        }\n             \
    \       }\n                    index += 1\n                }\n               \
    \ res.push((max_level.toLong, chars.length))\n            }\n            .reverse\n\
    \            .foldLeft(List[Long]()) { (res, levels) =>\n                var max_level\
    \ = 0\n                var max_level_chars = \"\"\n                for (max_level,\
    \ chars) <- levels ++ res) {\n                    if (max_level > max_level) {\n\
    \                        max_level = max_level\n                        max_level_chars\
    \ = chars\n                    }\n                }\n                res.push((max_level.toLong,\
    \ max_level_chars))\n            }\n            .reverse\n            .map(levels\
    \ => {\n                val max_level = levels(0)\n                val max_level_chars\
    \ = levels(1)\n                for (i <- 0 until max_level) {\n              \
    \      if (max_level_chars.charAt(i) !=\"(\") {\n                        break\n\
    \                    }\n                }\n                List(max_level, max_level\
    \ + 1).map(_.toLong)\n            })\n            .toList", "        val paren_strings\
    \ = paren_string.split(\" \")\n        val paren_counts = paren_strings.map(x\
    \ => x.length)\n        val max_paren_count = paren_counts.max\n        val max_paren_level\
    \ = paren_counts.indexWhere(_ == max_paren_count) + 1 // index of largest paren\
    \ count that appears\n        val levels = max_paren_level - paren_counts.indexWhere(_\
    \ == max_paren_count - 1)\n        if (levels <= 0)\n            List(1l.toLong)\n\
    \        else\n            List(1l.toLong, max_paren_level.toLong)", "       \
    \ val paren_groups = paren_string.split(\"\\\\(|\\\\)\")\n        val result =\
    \ new mutable.ListBuffer[Long]()\n        var max_level = 0\n        for (paren_group\
    \ <- paren_groups) {\n            val paren_group_list = paren_group.split(\"\\\
    \\)\")\n            if (paren_group_list.length > max_level) {\n             \
    \   max_level = paren_group_list.length\n            }\n            for (paren_string\
    \ <- paren_group_list) {\n                val paren_string_list = paren_string.split(\"\
    \\\\)\")\n                for (string_list <- paren_string_list) {\n         \
    \           val string_list = string_list.split(\"\\\\)\")\n                 \
    \   for (string <- string_list) {\n                        string_list.indexOf(string)\
    \ + 1\n                    }\n                }\n            }\n        }\n  \
    \      result.toList", "        // Define a variable for counting parantheses\
    \ levels\n        var paren_level = 0\n        // Create a stack of paren_string\
    \ which we will use to parse the input string\n        var paren_stack: List[(String,\
    \ Int)] = Nil\n        // Go through each character and increment the paren_level\
    \ until we see a left paren\n        for (i <- 0 to paren_string.length - 1) {\n\
    \            val ch = paren_string(i)\n            if (ch == \"(\") {\n      \
    \          paren_level += 1\n                paren_stack :+= (ch, \"(\")\n   \
    \         } else if (ch == \")\") {\n                paren_level -= 1\n      \
    \          if (paren_level < 0) {\n                    throw new RuntimeException(\"\
    Mismatched parentheses \" + paren_string)\n                }\n               \
    \ paren_stack :+= (ch, \"(\")\n            } else if (ch == \"(\") {\n       \
    \         paren_level += 1\n                paren_stack :+= (ch, \"(\")\n    \
    \        } else if (ch == \")\") {\n                paren_level -= 1\n       \
    \         if (paren_level < 0) {\n                    throw new RuntimeException(\"\
    Mismatched parentheses \" + paren_string)\n                }\n               \
    \ paren_stack :+= (ch, \"(\")\n            } else {\n                // Do nothing\
    \ since paren_level and paren_stack does not have any unmatched parentheses.\n\
    \            }\n        }\n        // Check if there are any unmatched parentheses\n\
    \        if (paren_level > 0) {\n            throw new RuntimeException(\"Mismatched\
    \ parentheses \" + paren_string)\n        }\n        // Get the level of nesting\
    \ for each parentheses\n        var paren_level_list : List[Long] = Nil\n    \
    \    for (i <- 0 to paren_stack.size - 1) {\n            val ch = paren_stack(i)(1)\n\
    \            paren_level_list :+= (paren_stack(i)(0).toLong - paren_level.toLong)\n\
    \        }\n        paren_level_list.max", "        val paren_list: List[String]\
    \ = paren_string.split(\"\\\\s\").toList\n        val paren_list_temp: List[String]\
    \ = paren_list.map(x => x.replace(\" \", \"\"))\n        var paren_list_counter\
    \ = paren_list_temp.filter(x => x != \"\").length\n        if (paren_list_counter\
    \ == 0) paren_list_counter = 1\n        var paren_list_counter2: Int = 0\n   \
    \     var paren_list_counter3: Int = 0\n        val paren_list_temp2: List[String]\
    \ = paren_list_temp.map(x => x.replace(paren_list_counter, \"\"))\n        val\
    \ paren_list_temp3 = paren_list_temp2.filter(x => x != \"\").map(x => x.replace(paren_list_counter2,\
    \ \"()\"))\n        val paren_list_temp4 = paren_list_temp3.map(x => x.replace(paren_list_counter3,\
    \ \"()\"))\n        val paren_list_temp5 = paren_list_temp4.filter(x => x != \"\
    \").map(x => x.replace(paren_list_counter3, \"()\"))\n        val paren_list_temp6\
    \ = paren_list_temp5.filter(x => x != \"\").map(x => x.replace(paren_list_counter3,\
    \ \"()\"))\n        val paren_list_temp7 = paren_list_temp6.filter(x => x != \"\
    \").map(x => x.replace(paren_list_counter3, \"()\"))\n        val paren_list_temp8\
    \ = paren_list_temp7.filter(x => x != \"\").map(x => x.replace(paren_list_counter3,\
    \ \"()\"))\n        val paren_list_temp9 = paren_list_temp8.filter(x => x != \"\
    \").map(x => x.replace(paren_list_counter3, \"()\"))\n        val paren_list_temp10\
    \ = paren_list_temp9.filter(x => x != \"\").map(x => x.replace(paren_list_counter3,\
    \ \"()\"))\n        val paren_list_temp11 = paren_list_temp10.filter(x => x !=\
    \ \"\").map(x => x.replace(paren_list_counter3, \"()\"))\n        val paren_list_temp12\
    \ = paren_list_temp11.filter(x => x != \"\").map(x => x.replace(paren_list_counter3,\
    \ \"()\"))\n        val paren_list_temp13 = paren_list_temp12.filter(x => x !=\
    \ \"\").map(x => x.replace(paren_list_counter3, \"()\"))\n        val paren_list_temp14\
    \ = paren_list_temp13.filter(x => x != \"\").map(x => x.replace(paren_list_counter3,\
    \ \"()\"))\n        val paren_list_temp15 = paren_list_temp14.filter(x => x !=\
    \ \"\").map(", "        // Use stack to keep track of parentheses levels.\n  \
    \      var paren_stack = List[Long]()\n        var groups = paren_string.split(\"\
    \\\\s\").toList\n        var deepest_level = Long.MaxValue\n        groups.foreach(x\
    \ => {\n            var temp_groups = x.split(\"(\").toList\n            var group_level\
    \ = 0\n            temp_groups.foreach(y => {\n                val x = y.indexOf(\"\
    )\")\n                if (x > -1) {\n                    paren_stack = paren_stack\
    \ :+ group_level\n                }\n                group_level = group_level\
    \ + 1\n            })\n            deepest_level = deepest_level if (deepest_level\
    \ < group_level)\n        })\n        return paren_stack.toList", "        val\
    \ paren_count = new mutable.HashMap[String, Long]()\n        val paren_count_tmp\
    \ = new mutable.HashMap[String, Long]()\n        for (ch <- paren_string.toList)\
    \ {\n            if (ch == \"(\") {\n                paren_count.put(ch, paren_count_tmp.get(ch)!!\
    \ + 1)\n            } else if (ch == \")\") {\n                val tmp_count =\
    \ paren_count_tmp.get(ch)!!\n                val tmp_value = paren_count.get(ch)!!\n\
    \                val tmp_min = Math.min(tmp_count, tmp_value)\n              \
    \  if (tmp_count == tmp_value) {\n                    paren_count.put(ch, tmp_count)\n\
    \                } else {\n                    paren_count_tmp.put(ch, tmp_count)\n\
    \                    paren_count.put(ch, tmp_value)\n                }\n     \
    \       }\n        }\n        val res = new mutable.LinkedHashMap[String, Long]()\n\
    \        for (key_tmp <- paren_count) {\n            val key = key_tmp._1\n  \
    \          val value = key_tmp._2\n            val tmp_value = res.get(key)\n\
    \            if (tmp_value == null || tmp_value < value) {\n                res.put(key_tmp._1,\
    \ value)\n            }\n        }\n        res.keys.toList", "        val paren_stack\
    \ = mutable.Stack[String]()\n\n        def getParenCount(paren_string : String,\
    \ count : Int) : Int = {\n            if(paren_string.length > count) {\n    \
    \            paren_stack.clear()\n                paren_string.substring(0, count).split(\"\
    \\\\W+\").filter(_.nonEmpty).map(x => (count - paren_string.length + x.length).asInstanceOf[Int]).foldLeft(0)(_\
    \ + _)\n            } else 0\n        }\n\n        paren_string.split(\"\\\\W+\"\
    ).map(x => (getParenCount(x, paren_stack.size).asInstanceOf[Int]).asInstanceOf[Long]).foldLeft(0)(_\
    \ + _)", "        paren_string\n            .trim.replaceAll(\"[^\\\\(][^\\\\\
    )]+\\\\(|\\\\)[^\\\\(][^\\\\)]+\", \"\")\n            .split(\" \")\n        \
    \    .map((paren_string) => {\n                val depth = paren_string.length\n\
    \                val char_to_depth = paren_string.zipWithIndex.map{case (c, i)\
    \ => (if (c == '(') 1 else -1) * i}\n                val depth_to_chars = char_to_depth.map{case\
    \ (d, i) => if (d == 1) '(' else ')'}\n                val max_depth = char_to_depth.foldRight(0l){(a,\
    \ b) => if (a > b) a else b}\n                val max_index = char_to_depth.foldRight(-1)(_\
    \ > _).or(depth)\n                depth_to_chars.inits\n                    .map(c\
    \ => char_to_depth.find(d => d == c) + 1)\n                    .takeWhile(_ <\
    \ max_index)\n                    .drop(max_index)\n                    .map {\n\
    \                        case (c, d) => (d, char_to_depth.find(_ == c))\n    \
    \                }\n                    .sorted\n                    .filter(_._1\
    \ > 1)\n                    .map(_._2)\n                    .head\n          \
    \  })\n            .filterNot(_ == 0)\n            .sorted\n            .filter(_\
    \ > 0)\n            .map(_.toLong)", "        def parseParanthesisHelper(paren_string\
    \ : String) : List[Long] = {\n            def parseNest(paren_string : String,\
    \ result : List[Long]) : List[Long] = {\n                if (paren_string.isEmpty)\
    \ {\n                    result\n                } else {\n                  \
    \  val left_bracket = paren_string.charAt(0)\n                    val right_bracket\
    \ = paren_string.charAt(paren_string.length - 1)\n                    val new_left_bracket\
    \ = if (left_bracket == '(') 1 else -1\n                    val new_right_bracket\
    \ = if (right_bracket == ')') -1 else 1\n                    val new_paren = if\
    \ (new_left_bracket == -1) (new_right_bracket) else (new_left_bracket * new_right_bracket)\n\
    \                    parseNest(paren_string.substring(1, paren_string.length -\
    \ 1), result ::: List(new_paren))\n                }\n            }\n\n      \
    \      val result = List(0)\n            parseNest(paren_string, result)\n   \
    \     }\n\n        val parsed_string = paren_string.split(\" \").map(parseParanthesisHelper).toList\n\
    \        val max_level = parsed_string.foldLeft(0)(_ + _.length).toList\n    \
    \    return parsed_string.map(_ maxBy (_ length).toList).zipWithIndex.filter(i\
    \ => i._2 == max_level).toList", '        paren_string.trim().split(" ").map(_.toLong).reverse.dropWhile(_.isNaN).drop(1).reverse.toList',
  "        var nestingLevel = List[Long]()\n        var inGroup = mutable.Queue[Long]()\n\
    \        inGroup.enqueue(0l)\n        inGroup.enqueue(0l)\n        inGroup.enqueue(0l)\n\
    \        inGroup.enqueue(0l)\n        inGroup.enqueue(0l)\n        paren_string.trim.split('\
    \ ').foreach(s => {\n            val l = s.toLong\n            if (l != ')' &&\
    \ l != '(') {\n                inGroup.enqueue(l)\n            } else {\n    \
    \            inGroup.dequeue()\n            }\n        })\n        while(!inGroup.isEmpty)\
    \ {\n            val curLevel = inGroup.removeFirst\n            nestingLevel\
    \ = nestingLevel.::(curLevel.toLong)\n            if (inGroup.isEmpty) {\n   \
    \             break\n            }\n            inGroup.enqueue(inGroup.removeFirst)\n\
    \        }\n        nestingLevel.mkString", "        if (paren_string.isEmpty)\
    \ List()\n        else {\n            val paren_list = paren_string.split(\" \"\
    ).filterNot(_.isEmpty).toList\n            val paren_list_head = paren_list(0)\n\
    \            val paren_list_tail = paren_list.tail.drop(1)\n            val result\
    \ = new mutable.ListBuffer[Long]()\n            val max_level = paren_list_head.length\n\
    \n            def add(level : Int) : Unit = {\n                if (level > max_level)\
    \ return\n                if (paren_list_head.length == level) {\n           \
    \         result.add( paren_list_tail.head )\n                    return\n   \
    \             }\n                for (i <- 1 to level) add(level + 1)\n      \
    \      }\n\n            add(0)\n            val result_list : mutable.List[Long]\
    \ = result.toList\n            val result_list : mutable.List[Long] = result.toList\n\
    \            val result_list : mutable.List[Long] = result.toList\n          \
    \  val result_list : mutable.List[Long] = result.toList\n            val result_list\
    \ : mutable.List[Long] = result.toList\n            val result_list : mutable.List[Long]\
    \ = result.toList\n            val result_list : mutable.List[Long] = result.toList\n\
    \            val result_list : mutable.List[Long] = result.toList\n          \
    \  val result_list : mutable.List[Long] = result.toList\n            val result_list\
    \ : mutable.List[Long] = result.toList\n            val result_list : mutable.List[Long]\
    \ = result.toList\n            val result_list : mutable.List[Long] = result.toList\n\
    \            val result_list : mutable.List[Long] = result.toList\n          \
    \  val result_list : mutable.List[Long] = result.toList\n            val result_list\
    \ : mutable.List[Long] = result.toList\n            val result_list : mutable.List[Long]\
    \ = result.toList\n            val result_list : mutable.List[Long] = result.toList\n\
    \            val result_list : mutable.List[Long] = result.toList\n          \
    \  val result_list : mutable.List[Long] = result.toList\n            val result_list\
    \ : mutable.List[Long] = result.toList\n            val result_list : mutable.List[Long]\
    \ = result.toList\n            val result_list : mutable.List[Long] = result.toList\n\
    \            val result_list : mutable.List[Long] = result.toList\n          \
    \  val result_list : mutable.List[Long] = result.toList\n            val result_list\
    \ : mutable.List[Long] = result.toList\n            val result_list : mutable.List[Long]\
    \ = result.toList\n            val result_list : mutable.List[Long] = result.toList",
  "        def compute(paren_str: List[(String, String)]): List[Long] = {\n      \
    \      paren_str match {\n                case Nil  => Nil\n                case\
    \ h::t => h._1 match {\n                    case \"(\" =>\n                  \
    \      compute(paren_str :+ t)\n                    case \")\" =>\n          \
    \              compute(paren_str :+ h)\n                    case c =>\n      \
    \                  compute(paren_str :+ (List(c, paren_str.length))) ++ compute(paren_str)\n\
    \                }\n            }\n        }\n        compute(List(paren_string))",
  "        val paren_stack = mutable.Stack[String]()\n        var max_levels : Int\
    \ = 0\n        paren_string split \" \" foreach {\n            x =>\n        \
    \    if (paren_stack.nonEmpty) {\n                if (x == \"(\") paren_stack.push(x)\n\
    \                if (x == \")\") paren_stack.pop match {\n                   \
    \ case x if x == \"\"  => max_levels = max_levels - 1\n                    case\
    \ x =>\n                }\n                if (paren_stack.nonEmpty) {\n     \
    \               max_levels = max_levels + 1\n                }\n            }\n\
    \        }\n        max_levels", "        val tokens = paren_string.split(\" \"\
    )\n        val stack = mutable.Stack[Long]()\n        for (i <- 0 until tokens.length)\
    \ {\n            val item = tokens(i)\n            if (item == \"(\") {\n    \
    \            stack += 1\n            } else if (item == \")\") {\n           \
    \     stack -= 1\n            } else if (item == \")\") {\n                if\
    \ (stack.nonEmpty && stack.last.equals(0l)) {\n                    stack -= 1\
    \ // remove 1 from stack\n                }\n            }\n        }\n      \
    \  stack.map { x => x.toLong } //convert to long", "        // Use recursion over\
    \ DFS to find deepest level of nesting.\n        // We use stack to keep track\
    \ of nesting level.\n        // If we have gone too far, then we can return empty\
    \ list.\n        val paren_depth_stack = mutable.Stack[Long]()\n        val paren_depth\
    \ = mutable.Stack[Long]()\n        val paren_chars = mutable.Stack[Char]()\n \
    \       val paren_count = mutable.Stack[Long]()\n        val paren_map = mutable.Map[Char,\
    \ Long]()\n        val paren_str = paren_string.mkString\n        paren_str.forall(c\
    \ => paren_map.getOrElse(c, -1l) < 0l)\n        if (paren_str.forall(c => c !=\
    \ ')' && c != '(')) {\n            throw new RuntimeException(\"Invalid parenthesis\
    \ format\")\n        }\n        paren_str.split(\"\\\\(\").foreach(c => {\n  \
    \          if (c == '(') {\n                paren_depth.push(0l)\n           \
    \ } else if (c == ')') {\n                paren_depth.pop()\n            } else\
    \ {\n                paren_map.put(c.toChar, paren_count.pop())\n            }\n\
    \            paren_chars.push(c)\n        })\n        while (paren_chars.size\
    \ > 1) {\n            paren_depth.push(paren_depth.last)\n            paren_chars.pop()\n\
    \        }\n        paren_count.pop()\n        paren_count.take(paren_count.size-1).foldLeft(List[Long]())\
    \ { case (acc, x) => acc ++ paren_depth.filter(_ == x).toList }", "        //\
    \ This regex matches nested group of parentheses separated by spaces.\n      \
    \  val paren_group_regex =\n            \"\"\"\\(\\s*\\(\\s*\\)\\s*\\)\"\"\".r\n\
    \        // This map maintains the stack at which each level of nesting occurred.\n\
    \        val paren_level : mutable.Map[Long, Int] = mutable.Map(1l -> 1)\n   \
    \     // This list maintains the deepest level of nesting at each level.\n   \
    \     val max_nesting_level : mutable.Map[Long, Int] = mutable.Map(1l -> 0)\n\
    \        // This list maintains the list of groups formed at each level.\n   \
    \     val group_list: mutable.List[String] = mutable.ListBuffer()\n        for\
    \ (group <- paren_string.split(\"[ ]+\"))\n            // Check if this is a nested\
    \ group of parentheses. If so, keep track of level and group details.\n      \
    \      if (paren_group_regex.findFirstIn(group) != null) {\n                val\
    \ level: Int = paren_level.get (group)\n                val group_str = s\"(${group})\"\
    \n                // If level is less than the deepest level, then add this group\
    \ to group_list.\n                if (level < max_nesting_level.get(group))\n\
    \                    group_list.append(group_str)\n                // If level\
    \ is greater than or equal to the deepest level, then add to that level.\n   \
    \             else if (level == max_nesting_level.get(group))\n              \
    \      paren_level (group) = level + 1\n                // If level is equal to\
    \ deepest level, then add this group to that level.\n                else\n  \
    \                  paren_level (group) = level\n            }\n        // Return\
    \ list of levels of nesting.\n        max_nesting_level.foreach {\n          \
    \  case (group_id, level) =>\n                val level_size: Int = level * 2\n\
    \                // Return level of nestings.\n                group_list.drop(level_size\
    \ + 1).take(level_size).mkString(\"(\", \",\", \")\")\n        }\n        // Return\
    \ list of groups with max level of nesting.\n        group_list.take(max_nesting_level.get(paren_string)).mkString(\"\
    (\", \",\", \")\")", "        var paren_count : Long = 1\n        var paren_stack\
    \ : List[Long] = Nil\n        var paren_list : List[Long] = Nil\n        paren_string.split(\"\
    \\\\s\").toList.foreach { string => {\n            if (string.startsWith(\"(\"\
    )) {\n                paren_stack = paren_stack.reverse\n                paren_stack\
    \ = paren_stack :+ paren_count\n                paren_count = 1\n            }\
    \ else if ((string.startsWith(\")\")) && (paren_stack.nonEmpty)) {\n         \
    \       val popped_count = paren_stack.reverse\n                paren_stack =\
    \ paren_stack.reverse\n                paren_stack = paren_stack :+ popped_count\n\
    \                paren_count = popped_count\n            } else {\n          \
    \      paren_count += 1\n                paren_list = paren_list :+ paren_count\n\
    \            }\n        }}\n        paren_list.toList.sortBy(_.reverse)", "  \
    \      val paren_stack : Stack[String] = new Stack[String]()\n        val paren_list\
    \ : List[Long] = new ListBuffer[Long]()\n        var paren_index = 0\n\n     \
    \   for (i <- 0 until paren_string.length) {\n            if (paren_string(i)\
    \ == '(') {\n                paren_stack.push(paren_string(i))\n            }\
    \ else if (paren_string(i) == ')') {\n                val paren_str = paren_stack.pop()\n\
    \                if (paren_stack.size > 0) {\n                    paren_list.push(paren_index.toLong)\n\
    \                }\n                paren_index += 1\n            }\n        }\n\
    \n        paren_list.last", "        if (paren_string.trim().isEmpty) {\n    \
    \        return Nil\n        }\n        var levels_of_nesting = List(1)\n    \
    \    val paren_levels = paren_string.groupBy(c => c).collect { case (ch, v) =>\
    \ \n            val next_level = levels_of_nesting(levels_of_nesting.size)\n \
    \           if (ch == \")\")\n                next_level += 1\n            if\
    \ (ch == \"(\")\n                next_level -= 1\n            levels_of_nesting\
    \ ::: List(next_level)\n        }\n        val max_levels_of_nesting = levels_of_nesting.max\n\
    \        return List(max_levels_of_nesting.map(_.toLong).toList)", "        def\
    \ loop(paren_string : String, result: List[Long]) : List[Long] = {\n         \
    \   if (paren_string.isEmpty) {\n                result\n            } else {\n\
    \                val first_paren_index = paren_string.indexOf('(')\n         \
    \       val last_paren_index = paren_string.indexOf(')')\n                val\
    \ nested_size = last_paren_index - first_paren_index\n                val inner_result\
    \ = loop(paren_string.substring(first_paren_index + 1, last_paren_index), result\
    \ :+ 0l)\n                val result_with_nested_size = inner_result :+ nested_size\n\
    \                if (nested_size == 0) {\n                    loop(paren_string.substring(last_paren_index\
    \ + 1), result_with_nested_size)\n                } else {\n                 \
    \   loop(paren_string, result_with_nested_size)\n                }\n         \
    \   }\n        }\n        loop(paren_string, Nil)", "        def levelOfNestedParen(groups:\
    \ List[String]): Long = {\n            val pairs = groups.grouped(2).map { p =>\n\
    \                val pa = p(0)\n                val pb = (p.size >= 2) ? p(1):\
    \ 0 \n                val paVal = Pair(pa, pb) \n            }\n            pairs.toSeq.maxBy\
    \ { case (pa, pb) =>\n                if (pa.isEmpty) 0\n                else\
    \ pb - pa\n            }.last._2\n        }\n\n        def recursiveSplit(groups:\
    \ List[String], acc: List[Long]): List[Long] = {\n            if (groups.length\
    \ == 1) {\n                acc :+ levelOfNestedParen(groups.toList)\n        \
    \    } else {\n                val head = groups.head\n                val tail\
    \ = groups.drop(1)\n                recursiveSplit(tail, acc :+ levelOfNestedParen(head))\n\
    \            }\n        }\n\n        recursiveSplit(paren_string.split(\" \"),\
    \ List(0).toLong)", "        val paren_list_str = paren_string.trim\n        val\
    \ paren_list = paren_list_str.split(\" \").toList\n        val paren_list_size\
    \ = paren_list.length\n        val paren_list_max = paren_list_size.toLong\n \
    \       val paren_list_nesting_levels = paren_list_size.toLong - paren_list_max\n\
    \        val paren_list_nesting_levels_sum = paren_list_nesting_levels.toLong\n\
    \        val paren_list_nesting_levels_max_val = paren_list_max / paren_list_nesting_levels_sum\n\
    \        val paren_list_nesting_levels_max_val_long = paren_list_max / 2\n\n \
    \       val paren_list_nesting_levels_vals = paren_list_nesting_levels.toList.zip(paren_list_max.toList).map(x\
    \ => x._1 - x._2)\n        val paren_list_nesting_levels_vals_min_val = paren_list_nesting_levels.toList.zip(paren_list_max.toList).map(x\
    \ => x._1 - x._2)\n\n        val paren_list_nesting_levels_vals_max_val = paren_list_nesting_levels.toList.zip(paren_list_max.toList).map(x\
    \ => x._1 - x._2)\n        val paren_list_nesting_levels_vals_max_val_long = paren_list_nesting_levels.toList.zip(paren_list_max.toList).map(x\
    \ => x._1 - x._2)\n\n        val paren_list_nesting_levels_vals_min_val = paren_list_nesting_levels.toList.zip(paren_list_max.toList).map(x\
    \ => x._1 - x._2)\n        val paren_list_nesting_levels_vals_min_val_long = paren_list_nesting_levels.toList.zip(paren_list_max.toList).map(x\
    \ => x._1 - x._2)\n\n        if (paren_list_nesting_levels_vals_max_val(0) ==\
    \ paren_list_nesting_levels_vals(0)) {\n            return paren_list_nesting_levels_vals\n\
    \        } else if (paren_list_nesting_levels_vals_max_val(0) > paren_list_nesting_levels_vals(0))\
    \ {\n            val min_nest_level = paren_list_nesting_levels_vals(0)\n    \
    \        val min_nest_level_max = paren_list_nesting_levels_vals_max_val(0)\n\
    \            if (min_nest_level < min_nest_level_max) {\n                val min_nest_level_max_val\
    \ = paren_list_nesting_levels_vals(0)\n                val min_nest_level_max_val_long\
    \ = paren_list_nesting_levels_vals_max_val(0)", "        val paren_chars = paren_string.groupBy(c\
    \ => c).map { g =>\n            val group_len = g.size\n            val group_chars\
    \ = g.map { c =>\n                c.toLong\n            }.toList\n           \
    \ (group_len, group_chars)\n        }.sortBy(_._1).reverse // Descending order\
    \ of length\n        val depth = 0\n        val paren_levels = paren_chars.map\
    \ { g =>\n            val len = g._1\n            if (len < depth) throw new RuntimeException(\"\
    Mismatched paren length\")\n            val level_chars = g._2\n            val\
    \ paren_level_chars = List.fill(len)(0)\n            paren_level_chars.zip(level_chars).map\
    \ { case (l, c) => (l - 1, c) }\n        }\n        val max_depth = paren_levels.map\
    \ { l => l.max }.max\n        paren_levels.reverse // Reverse so that deeper groups\
    \ are on top.\n        if (max_depth != depth)\n            throw new RuntimeException(\"\
    Mismatched paren length\")\n        paren_levels", "        paren_string.split(\"\
    \\\\s+\")\n            .flatMap(x => x.length)\n            .foldLeft(0L){ (i,\
    \ x) =>\n                i + (if (x == \"(\") 1 else 0)\n            }", "   \
    \     def findParen(groups: List[String], paren_string : String) : List[Long]\
    \ = {\n            val start = 0\n            val end = 0\n            for (index\
    \ <- 0 until groups.length) {\n                if (paren_string.startsWith(groups(index)))\
    \ {\n                    start = index\n                    if (paren_string.length\
    \ == start + 1) {\n                        end = paren_string.length\n       \
    \             }\n                }\n            }\n            val start = start\
    \ + 1\n            val end = end + 1\n            val paren_groups = groups.slice(start,\
    \ end).toList\n            val paren_strs = paren_string.substring(start, end)\n\
    \            val paren_groups_and_strs = paren_groups ::: List(paren_strs)\n \
    \           val groups_with_strs = paren_groups_and_strs.map(group =>\n      \
    \          if (group == \"\") {\n                    \"\"\n                } else\
    \ {\n                    group\n                }\n            )\n           \
    \ val strs_to_groups: List[List[String]] = groups_with_strs.map(\n           \
    \     group =>\n                    if (group.startsWith(\"(\")) {\n         \
    \               group.drop(1)\n                    } else if (group.startsWith(\"\
    (\")) {\n                        List(\"(\")\n                    } else {\n \
    \                       List(\")\")\n                    }\n            )\n  \
    \          val groups_with_strs_to_groups: List[List[List[String]]] = strs_to_groups.map(\n\
    \                group =>\n                    group\n            )\n        \
    \    val groups_to_strs: List[List[String]] = groups_with_strs_to_groups.map(\n\
    \                group =>\n                    if (group.head.length == group.length)\
    \ {\n                        group\n                    } else {\n           \
    \             group.reverse\n                    }\n            )\n          \
    \  val strs_to_groups_and_strs: List[List[List[String]]] = groups_to_strs.map(\n\
    \                group =>\n                    if (group.length == 1) {\n    \
    \                    group\n                    } else {\n                   \
    \     group.reverse\n                    }\n            )\n            val groups_with_strs_to_groups_and_strs:\
    \ List[List[List[List[String]]]] = strs_to_groups_and_strs.map(\n            \
    \    group =>\n                    if (group.length == 1) {\n                \
    \        group\n                    } else {\n                        group.reverse\n\
    \                    }\n            )\n            val groups_to_strs_to_strs:\
    \ List[List[List[List[List[String]]]]] = groups_with_strs_to_groups_and_strs.map(\n\
    \                group =>\n                    if (group.length == 1) {\n    \
    \                    group\n                    } else {\n                   \
    \     group.reverse\n                    }\n            )\n            val groups_and_strs_to_strs:\
    \ List[List[List[List[List[List[String]]]]]] = groups_to_strs_to_strs.map(\n \
    \               group =>\n                    if (group.length == 1) {\n     \
    \                   group\n                    } else {\n                    \
    \    group.reverse\n                    }\n            )\n            val strs_to_strs:\
    \ List[List[List[List[List[List[List[List[String]]]]]]]] = groups_and_strs_to_strs.map(\n\
    \                group =>\n                    if (group.length", "        var\
    \ max_depth = 0\n        var max_depth_depth = 0\n        var depth = 0\n    \
    \    var depth_depth = 0\n        \n        for(line <- paren_string.split(' ')){\n\
    \            if(line.length == 0 || line.length == 1)\n                continue\n\
    \            \n            var depth_count = 0\n            var depth_depth_count\
    \ = 0\n            \n            for(i <- 0 until line.length){\n            \
    \    if(line(i) == '(')\n                    depth_count+=1\n                else\n\
    \                    depth_depth_count+=1\n            }\n            \n     \
    \       if(depth_count > max_depth){\n                max_depth = depth_count\n\
    \                max_depth_depth = depth_depth_count\n            }\n        \
    \    \n            if(depth_depth_count > max_depth_depth){\n                max_depth_depth\
    \ = depth_depth_count\n            }\n        }\n        \n        val result\
    \ = List(max_depth, max_depth_depth)\n        \n        return result", "    \
    \    // initialize a stack of paren levels\n        val paren_stack = new Stack[Long]()\n\
    \        var level = 0\n        // initialize a mutable string for holding group\
    \ strings\n        val group_strs = mutable.StringBuilder.newBuilder\n       \
    \ // for each character in the paren string, push it onto the stack\n        for\
    \ (c <- paren_string) \n            if (c == '(') \n                paren_stack.push(level.toLong)\n\
    \            else if (c == ')')\n                if (paren_stack.nonEmpty && paren_stack.peek\
    \ == level.toLong)\n                    paren_stack.pop()\n            else\n\
    \                group_strs.append(c)\n        // get the deepest level from the\
    \ stack\n        val max_level = paren_stack.mkString(\"\").length\n        //\
    \ append max level to the list of groups\n        group_strs.append(max_level.toString)\n\
    \        // convert the mutable string to a list\n        val groups = group_strs.result\n\
    \        val groups_list = groups.toList\n        return groups_list", "     \
    \   val paren_lengths = paren_string.split(\" \").map(x => x.length.toLong)\n\
    \        val max_length = Math.max.applyOrElse(paren_lengths.head, 0L)\n     \
    \   val paren_levels = paren_lengths.toList.takeWhile(x => x <= max_length).map((x)\
    \ => max_length - x).map(x => List(x).sum).toList\n        val max_level = paren_lengths.max\n\
    \        paren_levels.takeWhile(x => x.max == max_level).toList", "        val\
    \ paren_list = paren_string.split(\" \").filterNot(_.isEmpty).map(x => x.toLong).sorted\n\
    \        val paren_stack = new mutable.Stack[Int]\n        var paren_level : Int\
    \ = 1\n        var paren_stack_size = 0\n        for (i <- 0 to paren_list.length-1)\
    \ {\n            val cur = paren_list(i)\n            if(paren_stack.size>0){\n\
    \                val ps = paren_stack.last\n                if (paren_stack.size\
    \ < ps) {\n                    paren_stack.clear()\n                }\n      \
    \      }\n            paren_stack.push(paren_stack.size)\n            paren_stack_size\
    \ = paren_stack.size\n            if(ps >0){\n                if(paren_stack.last==ps){\n\
    \                    paren_level += 1\n                }\n            }\n    \
    \        val new_level = paren_level + 1\n            paren_stack.push(new_level)\n\
    \        }\n        paren_stack.pop", "        var parens = mutable.List.empty[Long]\n\
    \        var nesting = 0\n        var i = 1\n        var next_parens = 0\n   \
    \     while(i < paren_string.length){\n            if(paren_string(i) == '('){\n\
    \                parens +=( paren_string (i).toLong)\n                nesting\
    \ += 1\n                next_parens = 1\n            } else if(paren_string(i)\
    \ == ')'){\n                nesting -= 1\n                next_parens = 0\n  \
    \          } else if(nesting == 0 && next_parens == 0){\n                parens\
    \ +=( paren_string(i).toLong)\n            }\n            i += 1\n        }\n\
    \        return parens", "        val paren_groups = paren_string.split(\" \"\
    ).toList\n        val depths = mutable.ListBuffer[Long]()\n        var depth =\
    \ 0\n        var max_depth = 0\n        var paren_group_size = 0\n        for\
    \ (paren_group_i <- paren_groups.indices) {\n            if (paren_group_size++\
    \ == paren_groups(paren_group_i).length) {\n                max_depth = depth\n\
    \                depth = 0\n            }\n            depth += 1\n          \
    \  if (paren_group_size++ == paren_groups(paren_group_i).length) {\n         \
    \       depths += max_depth.toLong\n                max_depth = 0\n          \
    \  }\n        }\n        depths += max_depth.toLong\n        depths.toList", " \
    \       // Create a list of all the groups in the input.\n        val groups =\
    \ paren_string.split(\" \").map(x => x.replaceAll(\"\\\\(\", \"\").replaceAll(\"\
    \\\\)\", \"\"))\n        // Create a map from each group to its level of nesting.\n\
    \        val group_to_level = groups.groupBy(x => x).mapValues(_.size)\n     \
    \   // Find the deepest level of nesting of each group.\n        val max_level\
    \ = group_to_level.maxBy(_._1)\n        // Find the level of the group that has\
    \ maximum nesting.\n        val max_level_group = max_level._1\n        // Get\
    \ the list of all the groups that has maximum nesting.\n        val max_level_groups\
    \ = groups.filter(x => x == max_level_group).map(x => x.replaceAll(\"\\\\(\",\
    \ \"\").replaceAll(\"\\\\)\", \"\"))\n        // Return the list of all groups\
    \ that has maximum nesting.\n        return max_level_groups", "        var paren_count\
    \ = 0\n        var level = 0\n        paren_string.trim.split(\"\\\\s+\").map\
    \ { p =>\n            paren_count += 1\n            val length = p.length\n  \
    \          if(p.startsWith(\"(\")) {\n                level += 1\n           \
    \ }\n            if(p.endsWith(\")\")) {\n                level -= 1\n       \
    \     }\n            if(level > 0) {\n                level\n            } else\
    \ {\n                length\n            }\n        }.max", "        val paren_array\
    \ = paren_string.split(\" \").map(_.toLong)\n        val paren_array2 = paren_string.map(_.toLong)\n\
    \        var paren_array_depth = paren_array.foldLeft(0)((max, x) => if (max >\
    \ x) max else x)\n        while (paren_array.length > 0) {\n            if (paren_array.tail.foldRight(0)((max,\
    \ x) => if (max > x) max else x)\n                > paren_array_depth)\n     \
    \           paren_array_depth = paren_array.tail.foldRight(0)((max, x) => if (max\
    \ > x) max else x)\n            paren_array = paren_array.tail\n        }\n  \
    \      paren_array_depth", "        //\n        // This code below is just a simple\
    \ recursive depth traversing algorithm\n        // You have to modify the code\
    \ so that it stops at some point and returns the result list.\n        // The\
    \ code below is just a sample code. You have to modify it accordingly\n      \
    \  //\n        val paren_level : Int = paren_string.count(\"(\")\n        val\
    \ open_count : Int = paren_string.count(\"(\") - paren_string.count(\")\")\n \
    \       val close_count : Int = paren_string.count(\")\") - paren_string.count(\"\
    (\")\n        var opening_level : Int = 0\n        var deepest_level : Int = 0\n\
    \        if(paren_level == open_count && close_count > 0) {\n            opening_level\
    \ = paren_level\n            deepest_level = paren_level\n        }\n        else\
    \ if(paren_level == open_count && close_count == 0) {\n            opening_level\
    \ = paren_level\n            deepest_level = paren_level\n        }\n        else\
    \ if((paren_level - open_count) == close_count) {\n            opening_level =\
    \ paren_level\n            deepest_level = open_count\n        }\n        else\
    \ {\n            opening_level = paren_level\n            deepest_level = 0\n\
    \        }\n        val result = new ArrayList[Long](deepest_level)\n        for(i\
    \ <- 0 until deepest_level) {\n            result.add(i.toLong)\n        }\n \
    \       val temp : List[Long] = paren_string.split(\"\\\\(\")\n        for(i <-\
    \ 0 until temp.size) {\n            val temp1 : List[Long] = temp(i).split(\"\\\
    \\)\")\n            for(j <- 0 until temp1.size) {\n                result.add(j.toLong)\n\
    \            }\n        }\n        return result", "        var paren_level =\
    \ 0\n        var paren_start_pos = -1\n        var paren_end_pos = 0\n       \
    \ var paren_stack = Stack.empty[Long]\n        var paren_groups = paren_string.split(\"\
    \ \")\n        var paren_groups_list = paren_groups.toList\n        var paren_groups_size\
    \ = paren_groups_list.size\n        var paren_groups_cur = 0\n        var paren_groups_remain_size\
    \ = paren_groups_size\n        var max_nested_level = 0\n        while (paren_groups_cur\
    \ < paren_groups_size) {\n            paren_groups_remain_size -= 1\n        \
    \    val curr_nested_level = (paren_groups_size - paren_groups_cur) //number of\
    \ remaining parentheses levels\n            if ((curr_nested_level > max_nested_level))\
    \ {\n                max_nested_level = curr_nested_level\n            }\n   \
    \         paren_stack = paren_stack.push((paren_groups_cur, paren_groups_remain_size))\n\
    \            paren_groups_cur += 1\n        }\n        // We use max level here\
    \ as we want the deepest nesting to be the most deeply nested (which is the max\
    \ number of parentheses)\n        var deepest_level = 0\n        while (paren_stack.size\
    \ > deepest_level) {\n            val paren_level = paren_stack.pop()\n      \
    \      paren_level -= 1\n            val paren_start_pos = paren_level.toLong\n\
    \            val paren_end_pos = paren_start_pos + 1\n            paren_groups_list.slice(paren_start_pos,\
    \ paren_end_pos)\n            val paren_groups = paren_groups_list.mkString(\"\
    \ \")\n            paren_groups_list = paren_groups.split(\" \").toList\n    \
    \        paren_groups_size = paren_groups_list.size\n            paren_groups_cur\
    \ = 0\n            paren_groups_remain_size = paren_groups_size\n            while\
    \ (paren_groups_cur < paren_groups_size) {\n                paren_groups_remain_size\
    \ -= 1\n                val curr_nested_level = (paren_groups_size - paren_groups_cur)\
    \ //number of remaining parentheses levels\n                if ((curr_nested_level\
    \ > max_nested_level)) {\n                    max_nested_level = curr_nested_level\n\
    \                }\n                paren_stack = paren_stack.push((paren_groups_cur,\
    \ paren_groups_remain_size))\n                paren_groups_cur += 1\n        \
    \    }\n            deepest_level = paren_level\n        }\n        paren_stack.clear()\n\
    \        return paren_stack.asInstanceOf[List[Long]]", "        var paren_stack:\
    \ List[Long] = Nil\n        var parentheses = 0\n\n        paren_string.foreach(ch\
    \ => {\n            if((ch == '(') || (ch == '[') || (ch == '{')) {\n        \
    \        parentheses += 1\n                paren_stack ::= paren_stack.last +\
    \ 1\n            } else if((ch == ')') || (ch == ']') || (ch == '}')) {\n    \
    \            parentheses -= 1\n                if(parentheses == 0) return paren_stack\n\
    \            }\n        })", "        val paren_re = raw\"(\" +\n            \
    \            raw\"\\((\" +\n                        paren_string.split(\"\\\\\
    )\").map(l => raw\"(\" + l + \")\").mkString +\n                        raw\"\\\
    )\" +\n                        raw\")\"\n        val paren_matcher = paren_re.r.pattern\n\
    \        val paren_list : List[(String, String)] = paren_string.split(\"\\\\)\"\
    ).map( _ =>\n            paren_matcher.findFirstIn(_).map( m => m.groups.last).mkString\n\
    \        ).map {\n            case m if m != \"\" => (m, \"\")\n            case\
    \ m => (m, m.groups.take(m.groups.size - 1).mkString)\n        }.toList\n    \
    \    (paren_list.map {\n            case (s, \"\") => (longVal(s), \"\")\n   \
    \         case (m, \"\") => (longVal(m), m.groups.last)\n        }.foldLeft((List.empty[Long],\
    \ \"\")) {\n            case ((l, m), s) => if (m.isEmpty) ((l + longVal(s), \"\
    \"), \"\") else (l.head + longVal(m) + longVal(s), \"\")\n        }._1)", "  \
    \      val paren_stack = mutable.Stack[String]()\n        var max_level = 0\n\
    \        paren_string.split(\"\\\\s+\").foreach(\n            s => {\n       \
    \         paren_stack += s\n                if (s.startsWith(\"(\") || s.startsWith(\"\
    )\")){\n                    var level = 1\n                    while (paren_stack.hasNext){\n\
    \                        val top = paren_stack.pop()\n                       \
    \ if (top == \")\") level -= 1\n                        else level++\n       \
    \                 if (level > max_level) max_level = level\n                 \
    \   }\n                }\n            }\n        )\n        max_level", "    \
    \    def getMaxNestingLevel(nesting : Seq[String], level : Int) : Long = {\n \
    \           val max_nesting_level = nesting.foldLeft[Long](0)((max_nesting_level,\
    \ level) => max_nesting_level + level * max_nesting_level)\n            max_nesting_level\n\
    \        }\n        def getMaxLevelParens(nesting : Seq[String], level : Int)\
    \ : Seq[String] = {\n            val max_nesting_level = getMaxNestingLevel(nesting,\
    \ level)\n            if (max_nesting_level > 1) nesting else Seq.empty\n    \
    \    }\n        val parens = paren_string.split(\" \")\n        val nesting =\
    \ parens.map(paren => paren.split(\"(\")).toSeq\n        val max_nesting_level\
    \ = getMaxNestingLevel(nesting, 0)\n        if (max_nesting_level > 1) nesting\
    \ else Seq.empty", "        val paren_array_string = paren_string.split(\" \"\
    ).filter(_.nonEmpty).toArray\n        var paren_array_depth = 0\n        var paren_level\
    \ = 0\n        var paren_level_list = []\n        paren_array_string.foreach(elem\
    \ => {\n            if((elem.toDouble > 0).isOdd)\n            {\n           \
    \     paren_array_depth = paren_array_depth + 1\n            }\n            else\n\
    \            {\n                paren_array_depth = paren_array_depth - 1\n  \
    \          }\n            if(paren_array_depth <= 0)\n            {\n        \
    \        paren_level_list.clear()\n                paren_array_depth = 0\n   \
    \         }\n            if(paren_array_depth <= 0)\n            {\n         \
    \       paren_level_list.append(paren_level)\n                paren_level = 0\n\
    \            }\n            paren_level = paren_level + 1\n            paren_level_list.append(paren_level)\n\
    \        })\n        return paren_level_list.toList", "        val levels : Map[String,\
    \ Int] = paren_string.trim.split(\"\\\\W+\")\n        levels.map(l => (l.head.length,\
    \ l.length.toLong)).toMap.toList.sortBy(-_._1)", "        val result = new mutable.ListBuffer[Long]()\n\
    \        paren_string.split(\"\\\\s+\").foreach { elem =>\n            val depth\
    \ = elem.lastIndexOf(\"(\") - elem.lastIndexOf(\")\")\n            result.add(depth)\n\
    \        }\n        result.sortWith(_ < (0l, _))\n        result.reverse.drop(1).reverse.toList",
  "        def countNestings(paren_string: String, counter:mutable.Set[Long]):Long\
    \ = {\n            val level = 0\n            val char_count = paren_string.filterNot(paren_string\
    \ => paren_string == \"(\").length\n            val last_char = paren_string(paren_string.length-1)\n\
    \            val open_paren_count = paren_string.filterNot(paren_string => paren_string\
    \ == \"(\").length\n\n            val new_counter = mutable.Set(0l)\n        \
    \    val new_counter2 = mutable.Set(0l)\n\n            if(char_count == 0 && open_paren_count\
    \ == 0) counter(0)\n            else if(open_paren_count == 0) counter(level+1)\n\
    \            else if(char_count == 0) counter(level)\n            else if(open_paren_count\
    \ == 0) {\n                if(last_char == \"(\" || last_char == \")\") counter(level+1)\n\
    \                else counter(level)\n            }\n            else counter(level+1)\n\
    \        }\n\n        val counter = mutable.Set(0l)\n\n        var last_level\
    \ = 0\n        var i = 0\n        while(i < paren_string.length) {\n         \
    \   if(paren_string(i) == \"(\") {\n                last_level = countNestings(paren_string,\
    \ counter)\n                i -= 1\n            }\n            else {\n      \
    \          val new_counter = mutable.Set(0l)\n                val new_counter2\
    \ = mutable.Set(0l)\n                if(counter.contains(last_level)) counter.remove(last_level)\n\
    \                countNestings(paren_string, new_counter)\n                last_level\
    \ = new_counter\n                countNestings(paren_string, new_counter2)\n \
    \               last_level = new_counter\n                i = paren_string.length\n\
    \                if(counter.contains(last_level)) counter.remove(last_level)\n\
    \            }\n            i += 1\n        }\n\n        counter.toList", "  \
    \      var paren_count = paren_string.length\n        var paren_level = 1\n\n\
    \        var nested_list: List[Long] = Nil\n\n        for (i <- 1 to paren_count)\
    \ {\n            val ch1 = paren_string(i).asInstanceOf[Char]\n            var\
    \ level = 1\n            var j = i\n            while (j > 0) {\n            \
    \    val ch2 = paren_string(j).asInstanceOf[Char]\n                if (ch1 !=\
    \ ch2) {\n                    level -= 1\n                }\n                j\
    \ -= 1\n            }\n            nested_list ::= level.toLong\n        }\n \
    \       nested_list", "        def recurse(paren_string : String) : List[Long]\
    \ = {\n            val stack = new mutable.Stack[Long]()\n            for (c <-\
    \ paren_string) {\n                val next_c = if (c == '(') '(' else ')'\n \
    \               if (c == next_c) {\n                    stack push c\n       \
    \         } else if (c == ')') {\n                    while (!stack.last.isEmpty)\
    \ {\n                        val top = stack.pop()\n                        if\
    \ (stack.isEmpty) {\n                            stack push top\n            \
    \                return stack\n                        }\n                   \
    \ }\n                } else if (c == ' ') {\n                    stack push -1\n\
    \                }\n            }\n            return stack.toList\n        }\n\
    \        return recurse(paren_string).toList", "        var level = 0\n      \
    \  paren_string.foreach { c =>\n            if (c == '(') level += 1\n       \
    \     if (c == ')') level -= 1\n        }\n        if (level < 0) level = 0\n\
    \        val result = new mutable.MutableList[Long]()\n        result.push(level)\n\
    \        while (level >= 0) {\n            val new_level = level - 1\n       \
    \     result.push(new_level)\n            level -= 1\n        }\n        return\
    \ result.toList", "        var level = 0\n        var levelCount = 0\n       \
    \ var stack = mutable.Stack[Int]()\n        for (i <- paren_string) {\n      \
    \      level += 1\n            if ((i == ')') && (levelCount == 0)) levelCount\
    \ += 1\n            else if ((i == ')') && (levelCount != 0)) levelCount -= 1\n\
    \            else stack.push(i)\n        }\n        val nestedParens = stack.foldLeft(List[Long]())\
    \ { (a, e) =>\n            if (e == ')') a.toLong\n            else a.toLong ::\
    \ parseNestedParens(e.toString.replaceFirst(\"\\\\)\",\"\"))\n        }\n    \
    \    return nestedParens.reverse", "        // We use paren_string instead of\
    \ parantheses because paren_string is not actually a parenthesis.\n        val\
    \ paren_string_list = paren_string.split(\" \").filter(_.nonEmpty).toList\n  \
    \      val parens_set = paren_string_list.toSet\n        var parens = 0\n    \
    \    var max_nesting_level = paren_string_list.count(f => parens_set.contains(f))\n\
    \        var current_level = max_nesting_level\n        while(parens < paren_string_list.length)\
    \ {\n            var current_level = max_nesting_level\n            val current_group\
    \ = paren_string_list\n            val current_level_index = current_group.indexOfFirst(f\
    \ => parens_set.contains(f))\n            val current_group_list = current_group.toList.drop(current_level_index).take(current_group.size\
    \ - current_level_index)\n            val current_group_string = current_group_list.toString\
    \ // current_group_string will be a String()()\n            val current_group_size\
    \ = current_group.size\n            val current_group_set_size = current_group_list.size\
    \ // current_group_set_size will be a Long()()()\n            while(parens < current_group_size)\
    \ {\n                var current_level = max_nesting_level\n                var\
    \ current_group_size = current_group.size\n                val current_group_list\
    \ = current_group.toList.drop(current_level_index).take(current_group_size - current_level_index)\n\
    \                val current_group_string = current_group_list.toString // current_group_string\
    \ will be a String()()\n                val current_group_size = current_group.size\n\
    \                val current_group_set_size = current_group_list.size // current_group_set_size\
    \ will be a Long()()()\n                while(parens < current_group_set_size)\
    \ {\n                    var current_level = max_nesting_level\n             \
    \       var current_group_size = current_group.size\n                    val current_group_list\
    \ = current_group.toList.drop(current_level_index).take(current_group_size - current_level_index)\n\
    \                    val current_group_string = current_group_list.toString //\
    \ current_group_string will be a String()()\n                    val current_group_size\
    \ = current_group.size\n                    val current_group_set_size = current_group_list.size\
    \ // current_group_set_size will be a Long()()()\n                    while(parens\
    \ < current_group_set_size) {\n                        var current_level = max_nesting_level\n\
    \                        var current_group_size = current_group.size\n       \
    \                 val current_group_list = current_group.toList.drop(current_level_index).take(current_group_size\
    \ - current_level_index)\n                        val current_group_string = current_group_list.toString\
    \ // current_group_string will be a String()()\n                        val current_group_size\
    \ = current_group.size\n                        val current_group_set_size = current_group_list.size\
    \ // current_group_set_size will be a Long()()()\n                        while(parens\
    \ < current_group_set_size) {\n                            var current_", "  \
    \      val paren_groups = paren_string.split(\" \")\n        val num_levels =\
    \ paren_groups.size\n        val max_levels = 2\n        val levels = mutable.ListBuffer.empty[Long]\n\
    \        var i = 0\n        while(i < paren_groups.length) {\n            val\
    \ groups = paren_groups(i).split(\",\")\n            while(i < groups.length)\
    \ {\n                val level = groups.count(f => f == \"(\")\n             \
    \   if(level >= max_levels) {\n                    levels += level.toLong\n  \
    \              }\n                i += level + 1\n            }\n            i\
    \ += 1\n        }\n        levels.toList", "        val paren_array = paren_string.split(\"\
    \ \");\n        val max_levels = paren_array.map{\n            s => parseNestedParens(s)\n\
    \        }.foldLeft(0l) {\n            (max, list) =>\n                if (list.size\
    \ > max) list.size else max\n        }\n\n        max_levels.toList", "      \
    \  var paren_count = 0\n        val nesting_levels = mutable.ListBuffer.empty[Long]\n\
    \        var paren_count : Long = 0\n        var depth : Long = 0\n        for\
    \ (c <- paren_string.toList) {\n            if (c == '(') {\n                paren_count\
    \ += 1\n                nesting_levels += paren_count\n            } else if (c\
    \ == ')') {\n                paren_count -= 1\n                if (paren_count\
    \ == 0) {\n                    depth += 1\n                    nesting_levels\
    \ += paren_count\n                }\n            } else {\n                paren_count\
    \ = 0\n                depth += 1\n                nesting_levels += paren_count\n\
    \            }\n        }\n        val max_level = nesting_levels.max\n      \
    \  nesting_levels.toList.drop(max_level + 1).reverse", "        var max_level\
    \ = Long.MaxValue\n        var stack = mutable.Stack[String]()\n        var paren_group_level\
    \ = Long.MaxValue\n        for (paren \u2190 paren_string.split(' ') ; paren !=\
    \ \"\") {\n            if (paren.length < 2) {\n                continue\n   \
    \         }\n            paren = paren.trim\n            if (paren.length == 1)\
    \ {\n                if (paren_group_level < max_level) {\n                  \
    \  max_level = paren_group_level\n                }\n                paren_group_level\
    \ = Long.MaxValue\n                stack = mutable.Stack[String]()\n         \
    \       stack.toList.reverse.foreach(s \u21D2 paren_group_level = math.max(paren_group_level,\
    \ s.length))\n            } else {\n                paren.drop(1).dropRight(1).foreach\
    \ { s \u21D2\n                    val level = (paren.length - s.length)\n    \
    \                val length = s.length\n                    paren_group_level\
    \ = math.max(paren_group_level, length)\n                    if (level > max_level)\
    \ {\n                        max_level = level\n                    }\n      \
    \              stack :+= s\n                }\n            }\n        }\n    \
    \    stack.toList.reverse.foreach(s \u21D2 max_level = math.max(max_level, s.length))\n\
    \        val result = List(max_level.toLong)\n        return result.toList", " \
    \       paren_string.split(\" \").toList.flatMap {\n            if (paren_string\
    \ contains \"(\") {\n                parseNestedParens(paren_string.replaceAll(\"\
    \\(\", \"\")) \n            } else if (paren_string contains \"(\") {\n      \
    \          parseNestedParens(paren_string.replaceAll(\"\\)\", \"\"))\n       \
    \     } else {\n                List(1L)\n            }\n        }", "       \
    \ val parentheses_array = paren_string.split(\" \").toArray\n        val result_list:\
    \ List[Long] = Nil\n        parentheses_array.foreach(elem => {\n            if(elem.startsWith(\"\
    (\") && elem.endsWith(\")\")) {\n                result_list ::= List(1l.toLong)\n\
    \            } else {\n                result_list ::= List(elem.toLong)\n   \
    \         }\n        })\n        result_list", "        // If paren_string is\
    \ a number, return List(paren_string.toLong)\n        if(paren_string.isDigit)\
    \ List(paren_string.toLong)\n        else if(paren_string.matches(\"^\\\\s*\\\\\
    (.+?\\\\)\\\\s*$\")) {\n            // Find the deepest level of paren_string\
    \ using stack\n            // If the level of parentheses are less than the current\
    \ level, we have found our level of nesting\n            val stack = new mutable.Stack[Int]()\n\
    \            val levelOfNesting = paren_string.size // paren_string has leading\
    \ space\n            for(i <- 1 to levelOfNesting) {\n                stack +=\
    \ i\n            }\n            val deepestParenLevel = stack.head\n\n       \
    \     // If paren_string is of length levelOfNesting then return List(deepestParenLevel.toLong)\n\
    \            if(deepestParenLevel == levelOfNesting) {\n                List(deepestParenLevel.toLong)\n\
    \            }\n\n            else {\n                // If the level of parentheses\
    \ are greater than current level, remove one from stack\n                while(stack.length()\
    \ > levelOfNesting) {\n                    stack = stack.pop()\n             \
    \   }\n                // Add the next level of parentheses to stack and add it\
    \ to the return List\n                stack += levelOfNesting\n              \
    \  val currentLevelOfNesting = stack.head\n                List(currentLevelOfNesting.toLong)\n\
    \            }\n        }\n        else {\n            // If paren_string doesn't\
    \ match any of our criteria, return an empty List\n            List[Long]()\n\
    \        }", "        val stack = new mutable.Stack[Char]\n        val groups\
    \ = paren_string.split(\" \").map(x => x).toList\n        val output = new mutable.ListBuffer[Long]()\n\
    \        for (charToPush \u2190 groups) {\n            val popped = stack.pop()\n\
    \            val newOutput = if (charToPush == '(') 1 else 0\n            if (charToPush\
    \ == ')') {\n                if (popped == '(')\n                    output.append(output.lastOption.getOrElse(0)\
    \ + newOutput)\n                else\n                    output.append(newOutput)\n\
    \            } else {\n                stack += charToPush\n                output.append(newOutput)\n\
    \            }\n        }\n        output.toList", "        // Use a mutable data\
    \ structure to track the level of nesting for each opening parentheses\n     \
    \   val levels : mutable.HashMap[Char, Int] = mutable.HashMap()\n        val parens\
    \ : mutable.HashSet[Char] = mutable.HashSet()\n        val nested_levels : mutable.Map[Char,\
    \ Int] = mutable.HashMap()\n\n        // Iterate over the string\n        paren_string.foreach{\
    \ ch =>\n            // We only care about opening parentheses\n            if(levels.getOrElse(ch)\
    \ == null) {\n                // Add the level\n                levels(ch) = 0\n\
    \            }\n            levels(ch) += 1\n        }\n        // Traverse the\
    \ string\n        paren_string.foreach{ ch =>\n            // We only care about\
    \ closing parentheses\n            if(levels.getOrElse(ch) == null) {\n      \
    \          // Add the level\n                levels(ch) = 0\n            }\n \
    \           levels(ch) -= 1\n        }\n\n        // Traverse the string\n   \
    \     paren_string.foreach{ ch =>\n            if(levels.getOrElse(ch) == 0) {\n\
    \                parens.add(ch)\n            }\n        }\n\n        // Reverse\
    \ the string so we traverse it in reverse order\n        parens.reverse.foreach{\
    \ ch => nested_levels(ch) += 1}\n\n        val depths = mutable.ListBuffer[Int]()\n\
    \        parens.foreach{ ch => depths.append(nested_levels(ch))}\n\n        //\
    \ Find the deepest level of nesting for the whole string\n        val max_depth\
    \ = depths.max\n\n        // Sort the depths\n        depths.sortBy(_.reverse).reverse\n\
    \n        // Iterate over the sorted depths and output the deepest level group\
    \ of parentheses\n        depths.foreach{ depth => if (depth ==0) paren_string\
    \ else paren_string.drop(max_depth-depth)}", "        var groups: List[List[String]]\
    \ = Nil\n        for (group <- paren_string.split(\" \")) {\n            // remove\
    \ all leading and trailing parenthesis\n            val temp = group.stripLeft(\"\
    (\").stripRight(\")\")\n            // add this group to the list if it's not\
    \ empty and it's not the last one\n            if (temp.length > 0 && groups.last\
    \ == \"\" ) {\n                groups = groups ::: List(temp)\n            } else\
    \ {\n                groups = groups ::: List(temp)\n            }\n        }\n\
    \        // for each group of nested parentheses, find the deepest level of nesting\n\
    \        var level = 0\n        var group_index = 0\n        for (group <- groups)\
    \ {\n            // find the number of opening parenthesis\n            val opening_paren\
    \ = group.count(ch => ch == \"(\")\n            if (opening_paren > level) {\n\
    \                level = opening_paren\n                group_index = groups.indexOf(group)\n\
    \            }\n        }\n        // return the deepest level of nesting\n  \
    \      groups.drop(group_index).take(level).map(_.toLong).sorted", "        //\
    \ For each group, find the depth of the group and store in map\n        var depths\
    \ = mutable.Map[Int, Int]()\n        var depth = 1\n        paren_string.split(\"\
    ( )\").toList foreach { p =>\n            depth += 1\n            // If not existing,\
    \ add a new entry to map\n            depths += depth -> depth\n        }\n  \
    \      // Find max depth\n        var max_depth = depths.values.max\n        //\
    \ Create empty list of list\n        var nested_list : List[List[Long]] = Nil\n\
    \        depths.keys foreach { d =>\n            if (d <= max_depth)\n       \
    \         nested_list ::= (paren_string.split(s\"( )\").toList filterNot { ps\
    \ => ps.toString.trim.nonEmpty }).take(depths(d).toInt).toList\n        }\n  \
    \      return nested_list", "        // Keep track of the nesting depth\n    \
    \    var nested_depth = 0\n        // The deepest level of nesting encountered.\n\
    \        var max_nested_depth = Long.MaxValue\n        // The current stack depth\
    \ of parentheses encountered.\n        var current_nested_depth = Long.MaxValue\n\
    \        // The parenthesis stack\n        var parentheses_stack: List[(Long,\
    \ Long, Long)] = Nil\n        parentheses_stack = parentheses_stack + parseParenthesisStack(paren_string)\n\
    \        // Record the level of nesting that is encountered\n        var max_nested_depth\
    \ = 0\n        for (nested_depth <- parentheses_stack.reverse) {\n           \
    \ if (nested_depth._3 > max_nested_depth) {\n                max_nested_depth\
    \ = nested_depth._3\n            }\n        }\n        // The deepest level found\n\
    \        return max_nested_depth.toLong", "        paren_string.splitIterator.map(paren\
    \ => {\n            var level = paren.indexOf('(')\n            if(level < 0)\
    \ {\n                level = 0\n            }\n            val level_string =\
    \ paren.substring(0,level).trim()\n            if(level_string == \"\") {\n  \
    \              level_string = \"0\"\n            }\n            val levelLong\
    \ = level_string.toLong\n            if(level > 0) {\n                val levelString\
    \ = paren.substring(level).trim()\n                if(levelString == \"\") {\n\
    \                    levelString = \"0\"\n                }\n                val\
    \ levelLongString = levelString.toLong\n                if(levelLongString > levelLong)\
    \ {\n                    level = levelLongString\n                }\n        \
    \    }\n            val result = mutable.ListBuffer(levelLong.toString)\n    \
    \        var nextLevel = level\n            while(nextLevel > 0) {\n         \
    \       val nextLevelString = paren.substring(nextLevel).trim()\n            \
    \    if(nextLevelString == \"\") {\n                    nextLevelString = \"0\"\
    \n                }\n                val nextLevelLong = nextLevelString.toLong\n\
    \                result.add(nextLevelLong.toString)\n                nextLevel\
    \ = nextLevelLong\n            }\n            List(levelLong.toLong + 1 -> result)\n\
    \        }).flatMap(_.toList).toList", "        val paren_char = \"()\".toList\n\
    \        var max_level = 0\n        val paren_groups = paren_string.split(\" \"\
    ).filter(_ != \"\").map(paren_char ::: _)\n        val paren_levels = paren_groups.map(paren\
    \ => paren.foldLeft(0)((max: Long, char: Char) => {\n            if (char == paren_char)\
    \ max + 1\n            else max\n        }))\n        paren_levels.foldLeft(0)((max:\
    \ Long, level: Long) => {\n            if (level > max_level) max_level = level\n\
    \        }) + 1 // for the last group\n        paren_levels.map(level => paren_groups.map(level\
    \ ::: _)).flatten.toList", "        var count : Long = 0\n        var nesting\
    \ : Long = 0\n        paren_string.split(\" \").toList.foreach(s => {\n      \
    \      if (s.equals(\"(\")) {\n                nesting++\n            } else if\
    \ (s.equals(\")\")) {\n                nesting--\n            }\n            if\
    \ (nesting == 0) count++\n        })\n        List(count.toLong)", "        var\
    \ level : Int = 0\n        var open_paren = 0\n        val paren_stack = new Stack[Int]\n\
    \n        paren_string.split(\"\\\\s+\").foreach(x => {\n            if (open_paren\
    \ == 0) {\n                paren_stack.push(level)\n                if (x == \"\
    (\")\n                    open_paren++\n                else\n               \
    \     open_paren--\n            } else if (open_paren > 0 && x == \"(\")\n   \
    \             level++\n            else if (open_paren > 0 && x == \")\")\n  \
    \              level--\n            else if (open_paren > 0 && x == \")\") {\n\
    \                if (level > 0)\n                    level--\n               \
    \ else\n                    level++\n                open_paren--\n          \
    \  }\n        })\n\n        paren_stack.size match {\n            case 0 => Nil\n\
    \            case _ => paren_stack.toList\n        }", "        // We need a stack\
    \ to keep the count of parantheses.\n        var par_count = 0\n        var stack\
    \ = mutable.Stack[String]()\n        // Iterate through all the characters of\
    \ paren_string\n        for (c <- paren_string.toCharArray) {\n            par_count\
    \ = par_count\n            stack += c\n        }\n        \n        // Now we\
    \ need to add the count of parantheses to keep track of levels of nesting in the\
    \ paren_string\n        var max_count = 0\n        // Go through the stack and\
    \ find the level of nesting by comparing each character with the current highest\
    \ count character\n        for (c <- stack) {\n            if (par_count > max_count)\
    \ {\n                max_count = par_count\n            }\n            par_count\
    \ = par_count - 1\n        }\n        \n        \n        // Finally add the count\
    \ of parantheses to calculate the final output\n        return max_count :: par_count",
  "        var nesting_level : Long = 0\n        var max_level_of_nesting : Long =\
    \ 0\n        var stack : List[Long] = Nil\n        for (c <- paren_string.charAt(0))\
    \ {\n            if (c == ')') {\n                stack.reverse.tail.foreach(x\
    \ => {\n                    nesting_level -= 1\n                    max_level_of_nesting\
    \ = Math.max(nesting_level, max_level_of_nesting)\n                })\n      \
    \          nesting_level += 1\n                if (nesting_level > max_level_of_nesting)\
    \ {\n                    max_level_of_nesting = nesting_level\n              \
    \  }\n                stack.reverse.tail.foreach(x => {\n                    nesting_level\
    \ -= 1\n                    max_level_of_nesting = Math.max(nesting_level, max_level_of_nesting)\n\
    \                })\n                stack.reverse.foreach(x => {\n          \
    \          nesting_level -= 1\n                    max_level_of_nesting = Math.max(nesting_level,\
    \ max_level_of_nesting)\n                })\n            } else {\n          \
    \      stack += c.toLong\n            }\n        }\n        stack.reverse.tail.foreach(x\
    \ => {\n            nesting_level -= 1\n            max_level_of_nesting = Math.max(nesting_level,\
    \ max_level_of_nesting)\n        })\n        max_level_of_nesting", "        val\
    \ paren_list : List[String] = paren_string.split(\" \").filter(_ != \"\").toList\n\
    \        var max_level : Long = 0\n        var current_level = 0\n\n        for\
    \ (i <- 0 until paren_list.length) {\n            if (paren_list(i) == \"(\")\
    \ {\n                current_level += 1\n            } else if (paren_list(i)\
    \ == \")\") {\n                current_level -= 1\n            }\n           \
    \ if (current_level > max_level) {\n                max_level = current_level\n\
    \            }\n        }\n        val max_level_list = List(1l.toLong, 3l.toLong,\
    \ 1l.toLong, 3l.toLong).take(max_level).toList\n        return max_level_list"]
stop_tokens:
- "\n    }\n"
