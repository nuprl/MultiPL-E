name: HumanEval_114_minSubArraySum
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a list of integers nums, find the minimum sum of any non-empty sub-list\n\
  \    // of nums.\n    // Example\n    // >>> minSubArraySum((List[Long](2l.toLong,\
  \ 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong)))\n    // (1l)\n    //\
  \ >>> minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong)))\n    // (-6l)\n\
  \    def minSubArraySum(nums : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(minSubArraySum((List[Long](2l.toLong,\
  \ 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong))) == (1l));\n    assert(minSubArraySum((List[Long](-1l.toLong,\
  \ -2l.toLong, -3l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](-1l.toLong,\
  \ -2l.toLong, -3l.toLong, 2l.toLong, -10l.toLong))) == (-14l));\n    assert(minSubArraySum((List[Long](-9999999999999999l.toLong)))\
  \ == (-9999999999999999l));\n    assert(minSubArraySum((List[Long](0l.toLong, 10l.toLong,\
  \ 20l.toLong, 1000000l.toLong))) == (0l));\n    assert(minSubArraySum((List[Long](-1l.toLong,\
  \ -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](100l.toLong,\
  \ -1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));\n   \
  \ assert(minSubArraySum((List[Long](10l.toLong, 11l.toLong, 13l.toLong, 8l.toLong,\
  \ 3l.toLong, 4l.toLong))) == (3l));\n    assert(minSubArraySum((List[Long](100l.toLong,\
  \ -33l.toLong, 32l.toLong, -1l.toLong, 0l.toLong, -2l.toLong))) == (-33l));\n  \
  \  assert(minSubArraySum((List[Long](-10l.toLong))) == (-10l));\n    assert(minSubArraySum((List[Long](7l.toLong)))\
  \ == (7l));\n    assert(minSubArraySum((List[Long](1l.toLong, -1l.toLong))) == (-1l));\n\
  \    }\n\n}\n"
completions: ["        val min = math.Long.MaxValue\n        val list = mutable.ListBuffer[Long]()\n\
    \        val iter = nums.iterator\n        while (iter.hasNext) {\n          \
    \  val cur = iter.next\n            list.append(cur)\n            if (cur < min)\
    \ {\n                min = cur\n            }\n        }\n        list.toList.sortWith((x,\
    \ y) => x - y)", "        val nums = nums filterNot (_ <= 0)\n        val minList\
    \ = List[Int]()\n        val minSum = nums.reduce((sum: Long, x: Long) => sum\
    \ + x)\n        nums.foreach { x =>\n            if (x < minSum) minList ::= x\n\
    \            else minList.foreach { y =>\n                val temp = y\n     \
    \           val sum = y - x\n                if (sum < 0) temp = temp + sum\n\
    \                if (sum > 0) temp = temp - sum\n                if (temp < minSum)\
    \ minList ::= temp\n            }\n        }\n        minSum", "        nums match\
    \ {\n            case Nil => -1\n            case x :: xs => if (x == 0) xs else\
    \ minSubArraySum(xs)\n        }", "        val (maxLength, maxSum) = nums.foldLeft((0l,\
    \ 0l)) {\n            case ((maxLength, maxSum), x) => if (x > maxSum) (x, maxSum)\
    \ else (maxLength, maxSum)\n        }\n        var min = maxSum - maxLength\n\
    \        for (i <- 0 until nums.size) {\n            val nextSum = maxSum - nums(i)\n\
    \            if (nextSum < 0) nextSum = math.max(nextSum, min) + nums(i)\n   \
    \         if (nextSum < min) min = nextSum\n        }\n        min", "       \
    \ val array = nums.toArray\n        val resultArray = array.toList\n        val\
    \ result = new Array[Long](array.length)\n        val length = array.length\n\
    \        for (i  <- 0 until length) {\n            for (j <- 0 until i) {\n  \
    \              result(j) = resultArray(j)\n            }\n            if (i >\
    \ 0 && array(i) > 0) {\n                val minOfMin = result.min\n          \
    \      val min = result.max\n                if (minOfMin >= array(i) - array(i-1))\
    \ {\n                    result(length-1) = array(i) - array(i-1)\n          \
    \      }\n                else if (minOfMin <= array(i) - array[(i-1)]) {\n  \
    \                  result(length-1) = array(i) - array[(i-1)]\n              \
    \  }\n            }\n        }\n        result.min", "        val (smallest, largest)\
    \ = nums.span(_ > 0)\n        if (smallest == null || largest == null || smallest.head\
    \ < largest.head) {\n            return 0\n        } else {\n            var result\
    \ = smallest.head\n            var smallestSum = 0\n            var largestSum\
    \ = 0\n            smallest foreach {\n                currentSum =>\n       \
    \         if (currentSum > largestSum) {\n                    largestSum = currentSum\n\
    \                } else if (currentSum < smallestSum) {\n                    smallestSum\
    \ = currentSum\n                }\n            }\n            result += smallestSum\n\
    \            result -= largestSum\n            result\n        }", "        val\
    \ min_sum = nums.reduceLeft(_.min + _.max) \n        val max_sum = nums.reduceLeft(_.min\
    \ + _.max)\n        min_sum + max_sum", "        // base case\n        if(nums.isEmpty)\
    \ throw new RuntimeException(\"No numbers provided\");\n        // sort\n    \
    \    nums.sortWith(_ < _)\n        var min = Long.MaxValue\n        // recurse\n\
    \        for(x<-nums.tail) {\n            val currentSum = x + nums.head\n   \
    \         val newMin = min - currentSum\n            min = newMin\n        }\n\
    \        min", "        def minSubArray(nums : List[Long], result : Long) : Long\
    \ = {\n            if (nums.isEmpty) {\n                println(s\"result = $result\"\
    )\n                return result\n            }\n            val n = nums.head\n\
    \            var leftSum = nums.tail.map(_.toLong).sum\n            var rightSum\
    \ = nums.tail.map(_.toLong).sum\n            if (leftSum > rightSum) {\n     \
    \           minSubArray(nums.tail, result)\n            } else {\n           \
    \     minSubArray(nums.tail.reverse, result + n.toLong)\n            }\n     \
    \   }\n\n        minSubArray(nums, 0l)", "        val numsSet = nums.toSet\n \
    \       val numsSortedSet = numsSet.sortBy(x => x)\n        val sumList = new\
    \ Array[Long](numsSortedSet.size)\n        var curMin = numsSortedSet.head\n \
    \       var sum = 0\n        for (nn <- numsSortedSet) {\n            val curSum\
    \ = sum + nn\n            if (curSum > curMin) {\n                curMin = curSum\n\
    \            }\n            sum = sum + nn\n            sumList(numsSortedSet.indexWhere(_\
    \ == nn)) = curSum\n        }\n        if (sumList.size != numsSortedSet.size)\
    \ {\n            throw new IllegalArgumentException(\"minSubArraySum: size mismatch\
    \ \" + sumList.size + \" and \" + numsSortedSet.size)\n        }\n        sumList.sum",
  "        var minSum = math.Long.MaxValue\n        for (i <- 0 until nums.length)\
    \ {\n            val curSum = nums.filterNot(i => i == 0).sum\n            if\
    \ (curSum < minSum) {\n                minSum = curSum\n            }\n      \
    \  }\n        minSum", "        val minSum = nums.foldLeft(0l)(_ + _)\n      \
    \  val list = nums.toList\n        val length = list.length\n        def findMinSum(n:\
    \ Int, r: List[Long], min: Long = 0) : Long = {\n            if (n == length)\
    \ {\n                if (r == null || r(0) == minSum) {\n                    minSum\n\
    \                } else {\n                    null\n                }\n     \
    \       } else {\n                val nextMinSum = findMinSum(n + 1, r, min)\n\
    \                if (nextMinSum == null) {\n                    nextMinSum = findMinSum(n\
    \ + 1, r + nums(n), min + nums(n))\n                }\n                nextMinSum\n\
    \            }\n        }\n        findMinSum(list.length)", "        var total\
    \ = 0L\n        var sublist = new ListBuffer[Long]()\n        var current = 0L\n\
    \        var j = 0\n        var i = 0\n        while (i < nums.length) {\n   \
    \         val cur = nums(i)\n            if (cur > 0) {\n                val temp\
    \ = sublist.last\n                if (temp < cur) {\n                    sublist.clear()\n\
    \                    j = 0\n                }\n                sublist += temp\n\
    \                total += cur\n            }\n            i += 1\n        }\n\
    \        val minSum = sublist.last\n        if (minSum > 0L)\n            total\
    \ += minSum\n        return total", '        // Write your code here.', "    \
    \    require(nums.length > 0)\n        val numsCopy = nums.toList\n        var\
    \ min = Long.MinValue\n        var max = 0\n        for (i <- 0 until numsCopy.size\
    \ ) {\n            val sum = numsCopy(i) + min\n            if (max < sum) {\n\
    \                max = sum\n            }\n        }\n        return max", " \
    \       val result = mutable.ArrayBuffer.empty[Long]\n        val numsCopy = nums.toList\n\
    \        // Find the first sub-array which contains at least one number.\n   \
    \     // For example, for the input List(2L, 3L, 4L, 1L, 2L, 4L),\n        //\
    \ the sub-array List(1, 2L, 3L, 4L) is selected as first sub-array.\n        var\
    \ first = numsCopy.head\n        var last = -1\n        while (first != 0) {\n\
    \            last = numsCopy.lastIndexOf(first)\n            val numsSum = last\
    \ - first + 1\n            if (numsSum > result.size) {\n                result\
    \ += numsCopy.slice(first, last + 1).sum\n            } else {\n             \
    \   // No need to update result if the sum is already known.\n               \
    \ result += numsSum\n            }\n            first = numsCopy.drop(last + 1).head\n\
    \        }\n        result.toList.min", "        require(nums.nonEmpty)\n    \
    \    val result = nums.foldLeft(nums.head)( (acc, value) => acc + value )\n  \
    \      if (result < 0)\n            result\n        else\n            nums.head\
    \ + result", "        // If there is just one element in the list\n        if(nums.isEmpty){\n\
    \            return 0\n        }\n        // Get the first element from the list\n\
    \        var currMin = nums.head\n        // Iterate through remaining elements\
    \ in the list\n        var currSum = 0\n        for(num <- nums.tail){\n     \
    \       if(currSum + num <= currMin){\n                currSum += num\n      \
    \      }else{\n                currMin = currSum\n                currSum = num\n\
    \            }\n        }\n        return currSum", "        if (nums.isEmpty)\
    \ 0\n        else nums.map(x => sum(x, nums, 1)).foldLeft(0l) { (min, next) =>\n\
    \            val oldMin = min\n            val newMin = math.min(min, next)\n\
    \            (oldMin + newMin, newMin) }", "        val minArray = mutable.ArrayBuffer.empty[Long]\n\
    \        val minIndexes = mutable.ArrayBuffer.empty[Int]\n        for( i <- 0\
    \ until nums.size) {\n            if(nums.exists(_ > nums(i))) {\n           \
    \     minArray.append(nums(i))\n                minIndexes.append(i)\n       \
    \     }\n        }\n        var sum = 0l\n        for( i <- 0 until minArray.size)\
    \ {\n            sum += minArray(i)\n        }\n        if(minArray.size > 0)\
    \ {\n            val sum = minArray(0)\n            for( i <- 0 until minArray.size)\
    \ {\n                sum += minArray(i)\n            }\n            val leftOver\
    \ = sum - sum.toLong\n            for(i <- 0 until minArray.size) {\n        \
    \        minArray(i) -= leftOver\n            }\n        }\n        minArray.zipWithIndex.map\
    \ { case (v,i) => (nums(i), v) }.minBy(_._1)._2", "        val numsSorted = nums.sortWith((x,\
    \ y) => x < y)\n        val list: List[Long] = numsSorted.toList\n        var\
    \ minSum = list(0)\n        for (x <- list.drop(1)) {\n            val subList\
    \ = list.dropWhile(i => i < x)\n            minSum = math.min(minSum, x - subList.last)\n\
    \        }\n        minSum", "        val minSum = Long.MinValue\n        for\
    \ (num <- nums) {\n            val maxSum = math.max(minSum, num + minSum)\n \
    \           minSum = math.min(maxSum, num + minSum)\n        }\n        minSum",
  "        if(nums.isEmpty)\n            return 0l\n        val numsSet = nums.toSet\n\
    \        if(numsSet.size < 2)\n            return numsSet.toList.sum\n       \
    \ val setSize = numsSet.size / 2\n        val left = nums.take(setSize).toSet\n\
    \        val right = nums.drop(setSize).toSet\n        val maxSum = left.sum +\
    \ right.sum\n        val leftSum = minSubArraySum(left)\n        val rightSum\
    \ = minSubArraySum(right)\n        if(leftSum < maxSum)\n            leftSum\n\
    \        else\n            rightSum", "        if (nums.isEmpty)\n           \
    \ return 0l\n        var minSum = 0l\n        var curSum = 0l\n        for(i <-\
    \ nums.indices) {\n            val cur = nums(i)\n            val rest = nums.filter(_\
    \ != cur)\n            val newSum = rest min cur\n            if(newSum < minSum)\
    \ {\n                minSum = newSum\n            }\n        }\n        minSum",
  '        nums.foldLeft(0l) { (sum, el) => sum + el }', "        val totals = new\
    \ mutable.LinkedHashMap[Long, Long]\n        for {\n            total <- totals\n\
    \            n <- nums\n        } yield {\n            val value = total + n\n\
    \            totals.put(value, value)\n        }.min._2", "        val sum = new\
    \ scala.collection.mutable.HashMap[List[Long], Long]();\n        for(i <- 0 until\
    \ nums.length)\n            sum.put(nums.take(i).takeWhile(_ < nums.head), nums(i))\n\
    \        sum.values.reduceLeft(_+_)", "        val nums0 = nums.toSeq.toList\n\
    \        val len = nums0.size\n        val sum = nums0.sum\n\n        val nums1:\
    \ List[Long] = nums0.drop(len).takeWhile(x => x < sum).reverse\n        val nums2\
    \ : List[Long] = nums0.drop(len - nums1.size).takeWhile(x => x < sum).reverse\n\
    \n        nums0.take(len).reduce(_ + _) + sum + nums0.drop(len).reduce(_ + _)\
    \ + nums0.take(len - nums1.size).reduce(_ + _) + nums1.reduce(_ + _) + nums2.reduce(_\
    \ + _)", "        var min = Double.PositiveInfinity\n        var cur = nums(0)\n\
    \        var idx = 1\n        for (n <- nums.drop(1)){\n            cur = cur\
    \ + n\n            min = math.min(min, cur)\n        }\n        return min", " \
    \       // Write your code here.\n        val minSum = (nums.head + nums.last).min(nums.head)\n\
    \        var minSumOfRemainingElements = 0.0\n        for(i<-1 to nums.last){\n\
    \            minSumOfRemainingElements = minSumOfRemainingElements + nums(i)\n\
    \            minSum = minSumOfRemainingElements\n        }\n        minSumOfRemainingElements\
    \ = minSumOfRemainingElements - nums.last\n        minSum", "        def minSubArraySumHelper(nums:List[Long],\
    \ bestSoFar:Long, bestNum:Long) : Long = {\n            if (nums.isEmpty) {\n\
    \                return bestNum\n            } else {\n                val nextNum\
    \ = nums.head\n                val sum = bestSoFar + nextNum\n               \
    \ if (sum < bestNum) {\n                    minSubArraySumHelper(nums.tail, sum,\
    \ nextNum)\n                } else {\n                    minSubArraySumHelper(nums.tail,\
    \ bestNum, nextNum)\n                }\n            }\n        }\n        minSubArraySumHelper(nums,\
    \ 0l, 0l)", "        val sums = nums.map(x => Array[Int](x, x)).groupBy(x => x(0)).map\
    \ { case (l, v) =>\n            val sum = l.map(x => v(x).sum).sum\n         \
    \   (sum, l)\n        }.sortBy(_._1).map(x => x._2).take(1)(0)._1.toLong\n   \
    \     sums", "        var sum = 0L\n        var i = nums.head._1\n        var\
    \ j = nums.head._2\n        var len = nums.length\n        for (x <- nums.tail)\
    \ {\n            var temp = i\n            i = j\n            j = temp\n     \
    \       sum += x\n        }\n        sum", "        // 1. First sort list to get\
    \ the largest numbers to the front.\n        // 2. Iterate from the end of the\
    \ list to find the sum of a contiguous sub-array of the numbers.\n        // 3.\
    \ Return the sum.\n        val sortedList = nums.sortWith(_ > _)\n        val\
    \ maxNumbers = sortedList(nums.size - 1)\n        val sum = sortedList.reduceLeft((x:\
    \ Long, y: Long) => x + y)\n        val startIndex = sortedList.indexOf(0)\n \
    \       if (startIndex == 0) sum\n        else {\n            var currentSum =\
    \ sum\n            var i = startIndex\n            while (i < nums.size - 1) currentSum\
    \ = currentSum + nums(i) + currentSum\n            currentSum\n        }", " \
    \       if (nums.isEmpty) 0\n        else {\n            val sums = nums.map(x\
    \ => math.max(0, x + nums.min)).toList\n            sums.min\n        }", "  \
    \      var currentSum = 0\n        for (i <- nums) {\n            if (i < 0l)\
    \ {\n                currentSum = currentSum - i\n            } else {\n     \
    \           currentSum += i\n            }\n        }\n        currentSum", " \
    \       // Find sub-array where sum is minimum\n        val minSum = nums.foldLeft((Long.MaxValue,List[Long]())){\
    \ (m,i) => if (i+1 == m._2) (m, i) else if (m < (m._2 + i)) (m, i) else (m,i)\
    \ }._2\n        // Find the minimum sum of sub-array in nums\n        minSum.foldLeft((0l,0)){\
    \ (m,i) => if (nums.take(i).sum == m) (m,i) else (m,i) }._1 + nums.sum", "   \
    \     // Step 1: Find the sum of all the elements in nums\n        val sum = nums.reduceLeft(_\
    \ + _)\n        // Step 2: Find out how many elements are in the sub-array of\
    \ nums\n        // which sum is equal to the sum of nums\n        val count =\
    \ (nums.foldLeft((sum, List()))((a, x) => if (x == sum) (a, 1) else (a.head ::\
    \ a.tail, x + 1)))\n            .filter(_._1 == sum).length\n        // Step 3:\
    \ Sum all elements from the sub-array which sum is equal to nums\n        nums.take(count).reduceLeft(_\
    \ + _)", "        val ans = nums.foldLeft(nums.head)((l,r) => l.toLong + r)\n\
    \        val min = nums.min match {\n            case None => Long.MaxValue\n\
    \            case Some(_) => ans\n        }\n        min", "        val sorted\
    \ = nums.sortBy(_).reverse\n        val subArray = sorted grouped sorted (_ !=\
    \ SortedSet.empty)\n        val sumOfSubArray = subArray map {\n            case\
    \ (list: List[Long], sum) => list.reduce(_ + _) + sum\n        }.min\n       \
    \ sumOfSubArray", "        var minimum = 0L\n        var index = nums.length -\
    \ 1\n        while(index >= 0) {\n            var sum = nums.take(index).sum\n\
    \            if(sum < minimum) {\n                minimum = sum\n            }\n\
    \            index -= 1\n        }\n        return minimum", "        val numsMap\
    \ = nums.toMap\n        var minSum = 0L\n        for( n <- nums.toList ) {\n \
    \           if(numsMap.contains(n)) {\n                var tempSum = 0L\n    \
    \            numsMap.remove(n)\n                for( m <- numsMap.toList ) {\n\
    \                    tempSum += m\n                }\n                minSum =\
    \ math.min(minSum, tempSum)\n            }\n        }\n        minSum", "    \
    \    val min = Int.MinValue\n        val sum = new mutable.ListBuffer[Long]()\n\
    \        for (x <- nums.toList) {\n            if (x == 0l.toLong)\n         \
    \       continue\n            sum.append(x)\n            if (sum.sum < min)\n\
    \                min = sum.sum\n        }\n        sum.sum", "        // write\
    \ your logic here\n        var min = Long.MaxValue\n        var cur = Long.MaxValue\n\
    \        for (x <- nums) {\n            if (x < cur) min = x\n            cur\
    \ = x\n        }\n        if (min == Long.MaxValue) min\n        else min + minSubArraySum(nums.drop(1))",
  "        // Your Code Here\n        def maxSubArraySum(nums: List[Long]): (Long,\
    \ List[Long]) = {\n            def subArraySum(nums: List[Long], idx: Int): (Long,\
    \ List[Long]) = {\n                if (nums.isEmpty)\n                    return\
    \ 0L, List(nums.head)\n                val sum = nums.head + subArraySum(nums.tail,\
    \ idx+1)\n                (sum, subArraySum(nums.tail, idx))\n            }\n\
    \            val minSum = subArraySum(nums, 0)(0)\n            val maxSum = subArraySum(nums,\
    \ 0)(1)(0)\n            (minSum, maxSum)\n        }\n        maxSubArraySum(nums)._1",
  "        val sums = mutable.ArrayBuffer.empty[Long]\n        var sum = 0\n     \
    \   for (x <- nums) {\n            sum = sum + x\n            sums += sum\n  \
    \      }\n\n        val min = sums.min\n        sums.remove(min)\n        min",
  "        // Write your code here\n        var res = 0\n        nums.foreach(x=>\
    \ {\n            if (x>0) {\n                res += x\n            }\n       \
    \ })\n        return res", "        var minSum = Long.MaxValue\n        var sum\
    \ = 0L\n        for (i <- 0 until nums.size) {\n            sum = sum + nums(i)\n\
    \            if (sum < minSum) {\n                minSum = sum\n            }\n\
    \        }\n        minSum", "        var max = -1L\n        for (i <- 0 until\
    \ nums.size) {\n            val newMax = max\n            val newMaxIndex = i\n\
    \            max = Math.min(max +(nums(i) - nums(newMaxIndex)), nums.sum)\n  \
    \      }\n        return max", "        val l: mutable.HashMap[Int, Int] = new\
    \ mutable.HashMap[Int, Int]()\n        nums.foreach{ n =>\n            val i =\
    \ l.getOrElse(n, 0)\n            l.put(n, i + n)\n        }\n        val keys\
    \ = l.keys.toList.sortBy(-_)\n        val res = -1l\n        for(i <- 0 to keys.length\
    \ - 1) {\n            if(l(keys(i)) > res) {\n                res = l(keys(i))\n\
    \            }\n        }\n        res", "        val result = new mutable.ListBuffer[Long]()\n\
    \        nums.foreach { n => \n            val sum = sumSubArray(new mutable.ArrayBuffer[Long](),\
    \ nums, n)\n            result.add(sum)\n        }\n        result.min", "   \
    \     def minSubArraySumHelper(nums : List[Long], sum : Long, numsIndex : Long,\
    \ minIndex : Long) : List[Long] = {\n            if (numsIndex == nums.length\
    \ - 1)\n                (sum, numsIndex)\n            else {\n               \
    \ val next = nums(numsIndex + 1)\n                val newSum = sum + next\n  \
    \              val newNumsIndex = numsIndex + 1\n                if (newSum <=\
    \ minIndex)\n                    minSubArraySumHelper(nums, newSum, newNumsIndex,\
    \ next)\n                else if (newSum > minIndex)\n                    minSubArraySumHelper(nums,\
    \ newSum, newNumsIndex, next)\n                else {\n                    minSubArraySumHelper(nums,\
    \ newSum, newNumsIndex, next)\n                }\n            }\n        }\n \
    \       minSubArraySumHelper(nums, 0l, 0l, nums(0))._1", "        val sets = nums.toSet\n\
    \        if (sets.isEmpty) return 0l\n        val size = nums.size\n        val\
    \ sums = mutable.HashMap[Long, Int]()\n        val current = sets.tail.head\n\
    \        var start = 0\n        val next = sets.head\n        var max = 0l\n \
    \       while (true) {\n            val currentSum = sums.get(current) * size\n\
    \            val nextSum = sums.get(next) * size\n            val currentKey =\
    \ start + sums.getOrElse(current, 0) - currentSum\n            val nextKey = start\
    \ + sums.getOrElse(next, 0) - nextSum\n            if (currentKey > max) {\n \
    \               max = currentKey\n            } else if (nextKey > max) {\n  \
    \              max = nextKey\n            }\n            val currentVal = sums.getOrElse(current,\
    \ 0) - currentSum\n            val nextVal = sums.getOrElse(next, 0) - nextSum\n\
    \            if (nextVal > size) {\n                sums += (nextVal - size) ->\
    \ size\n                size += 1\n            } else if (nextVal < size) {\n\
    \                sums -= nextVal\n            } else {\n                sums +=\
    \ currentVal * size -> size\n                size += 1\n            }\n      \
    \      current = next\n            start = nextKey\n            next = current\n\
    \        }\n        sums.maxBy(_._1)", "        var min = Long.MaxValue\n    \
    \    var index = 0\n        for (i <- 0 until nums.size) {\n            if (min\
    \ > nums(i) - i) {\n                min = nums(i) - i\n                index =\
    \ i\n            }\n        }\n        min", "        val list = nums.toList\n\
    \        val listSum = list.reduce{\n            (a: Int, b: Long) => a + b\n\
    \        }\n        val start = list.indexWhere(i => i > 0)\n        val end =\
    \ list.size - 1\n        val arraySum = listSum - list.take(start).sum + list.drop(end).sum\n\
    \        arraySum", "        var minSum = 0L\n        var minSubArray = nums.takeWhile(x\
    \ => x > 0)\n        var minSumInSubArray = minSubArray.reduce(_ + _)\n\n    \
    \    for (ns <- nums.dropWhile(x => x > 0)) {\n            val nsInSubArray =\
    \ ns.takeWhile(x => x > 0)\n            val nsInSubArraySum = ns.reduce(_ + _)\n\
    \n            if (minSumInSubArray > nsInSubArraySum) {\n                minSumInSubArray\
    \ = nsInSubArraySum\n                minSubArray = nsInSubArray\n            \
    \    minSum = minSumInSubArray\n            }\n        }\n        minSum", " \
    \       // find sum\n        val sum = nums.foldLeft(0L){ case (sum, num) =>\n\
    \            if (sum >= num) sum + num\n            else sum\n        }\n    \
    \    // find min sum\n        val min = sum / 2\n        // find all sub list\
    \ with sum >= min and no sub list with sum <= min\n        val result = nums.filter(num\
    \ => sum - num >= min)\n                      .filterNot(num => sum + num < min)\n\
    \                      .headOption\n                      .getOrElse(sum)\n  \
    \      result", "        def helper(nums : List[Long], r : Long) : Long = {\n\
    \            if (nums.isEmpty) {\n                r\n            }\n         \
    \   else if (nums.head < 0l) {\n                helper(nums.tail, r + nums.head)\n\
    \            }\n            else {\n                helper(nums.tail, r + nums.head)\n\
    \            }\n        }\n        helper(nums, 0l)", "        val numsCopy =\
    \ nums\n        val minSum = Long.MaxValue\n        var minSumIndex = 0\n    \
    \    var minSumIndexStart = 0\n        var minSumIndexEnd = nums.size\n\n    \
    \    for(index <- 0 until nums.size){\n            val curSum = numsCopy(index).asInstanceOf[Long]\n\
    \            if(index == nums.size-1){\n                minSum = curSum\n    \
    \            minSumIndex = index\n                minSumIndexStart = index\n \
    \           }\n            else if(minSum < curSum){\n                minSum =\
    \ curSum\n                minSumIndex = index\n                minSumIndexStart\
    \ = index\n                minSumIndexEnd = index\n            }\n           \
    \ else if(minSum == curSum){\n                minSumIndexEnd = index\n       \
    \     }\n        }\n\n        // If only one element exists, then return it\n\
    \        if(numsCopy(minSumIndexEnd) == -1l.toLong && numsCopy(minSumIndexStart)\
    \ == -1l.toLong){\n            return numsCopy(minSumIndex)\n        }\n\n   \
    \     // If no element exists, then return max\n        if(numsCopy(minSumIndexEnd)\
    \ == -1l.toLong && numsCopy(minSumIndexStart) != -1l.toLong){\n            return\
    \ numsCopy(minSumIndexStart).asInstanceOf[Long]\n        }\n\n        // If no\
    \ element exists, then return max\n        if(numsCopy(minSumIndexEnd) != -1l.toLong\
    \ && numsCopy(minSumIndexStart) != -1l.toLong){\n            return Math.min(numsCopy(minSumIndexStart).asInstanceOf[Long],\n\
    \                           numsCopy(minSumIndexEnd).asInstanceOf[Long]).asInstanceOf[Long]\n\
    \        }\n\n        // If all elements exists, then return sum\n        return\
    \ minSum", "        def sumWithoutEmptySubArray(nums: Array[Long], startIndex\
    \ : Int, endIndex : Int) : Long = {\n            val index = startIndex\n    \
    \        val subArray = new Array[Long](endIndex - startIndex)\n            while\
    \ (index < endIndex) {\n                subArray(index) = nums(index) + sumWithoutEmptySubArray(nums,\
    \ index + 1, endIndex)\n                index += 1;\n            }\n         \
    \   subArray(0)\n        }\n\n        val result = sumWithoutEmptySubArray(nums,\
    \ 0, nums.size);\n        result", "        val lists = nums.groupBy(x => x).toList\n\
    \        val sums = lists.map{ case (k, v) => k.sum }\n        val minSums = sums.min\n\
    \        lists.map{ case (k, v) => k(minSums) }.reduceLeft(_ + _)", "        val\
    \ minSum = math.LongMaxValue\n        for (num <- nums) {\n            val subList\
    \ = nums.filter(_ > num)\n            if (subList.nonEmpty) {\n              \
    \  val sumOfSubList = subList.reduce(_ + _)\n                if (sumOfSubList\
    \ < minSum) {\n                    minSum = sumOfSubList\n                }\n\
    \            }\n        }\n        minSum", "        if(nums.isEmpty)\n      \
    \      return 0\n        var result = nums.head\n        var sum = nums.tail.foldLeft(nums.head){(a,b)\
    \ => a + b}\n        for( x <- nums.tail ){\n            if( x < sum ){\n    \
    \            result = x\n                sum = sum - x\n            }\n      \
    \  }\n        result", "        val numsSize = nums.size\n        val numsSize1\
    \ = numsSize - 1\n        val numsSize2 = numsSize - 2\n        val numsSize3\
    \ = numsSize - 3\n        val numsSize4 = numsSize - 4\n\n        val arr = (0\
    \ until nums.size).map( x => (0 until nums.size).map( y => (0 until nums.size).map(\
    \ z => (0 until nums.size).map( w => if((w == 0l) && (z == numsSize)) {w}\n  \
    \              else if (z == numsSize) {w}\n                else if (y == numsSize)\
    \ {w + (nums(w))}\n                else if (x == numsSize) {w + (nums(w)) + (nums(z))\
    \ }\n                else if (y == numsSize) {w + (nums(w)) + (nums(z)) + (nums(y))}\n\
    \                else if (x == numsSize) {w + (nums(w)) + (nums(z)) + (nums(y))\
    \ + (nums(x))}\n                else if (z == numsSize) {w + (nums(w)) + (nums(z))\
    \ + (nums(y)) + (nums(x)) + (nums(y))}\n                else if (y == numsSize)\
    \ {w + (nums(w)) + (nums(z)) + (nums(y)) + (nums(x)) + (nums(x)) + (nums(z))}\n\
    \                else if (x == numsSize) {w + (nums(w)) + (nums(z)) + (nums(y))\
    \ + (nums(x)) + (nums(x)) + (nums(y)) + (nums(x))}\n                else if (z\
    \ == numsSize) {w + (nums(w)) + (nums(z)) + (nums(y)) + (nums(x)) + (nums(x))\
    \ + (nums(y)) + (nums(x)) + (nums(y))}\n                else if (y == numsSize)\
    \ {w + (nums(w)) + (nums(z)) + (nums(y)) + (nums(x)) + (nums(x)) + (nums(y)) +\
    \ (nums(x)) + (nums(x)) + (nums(z))}\n                else if (x == numsSize)\
    \ {w + (nums(w)) + (nums(z)) + (nums(y)) + (nums(x)) + (nums(x)) + (nums(y)) +\
    \ (nums(x)) + (nums(y)) + (nums(x)) + (nums(x))}\n                else if (z ==\
    \ numsSize) {w + (nums(w)) + (nums(z)) + (num", "        val numSet = nums.toSet\n\
    \        val result = new mutable.HashMap[Long, Long]\n        nums.foldLeft(0L)\
    \ {\n            case (max, num) =>\n                val res = num.toLong - max.toLong\n\
    \                if (res.isNaN)\n                    throw new IllegalArgumentException(\"\
    input list contains negative values\")\n                if (result.contains(res))\n\
    \                    throw new IllegalArgumentException(\"duplicate element\"\
    )\n                result.put(res, num)\n                max\n        }\n    \
    \    if (result.size < nums.size) throw new IllegalArgumentException(\"empty list\"\
    )\n        val minVal = result.minBy(_._1)._2\n        if (minVal == 0) 0l else\
    \ minVal", "        val numArray = nums.toArray\n        var minSum = 0\n    \
    \    var minIndex = 0\n\n        for( i <- 0 until numArray.length - 1 ) {\n \
    \           if( numArray(i) < 0 ) {\n                minSum = numArray(i)\n  \
    \              minIndex = i\n            }\n            else {\n             \
    \   val newSum = minSum + numArray(i)\n                if( newSum < minSum ) {\n\
    \                    minSum = newSum\n                    minIndex = i\n     \
    \           }\n            }\n        }\n        minSum", "        val minSum\
    \ = math.max(nums.reduceLeft((x,y) => x + y))\n        val subsets = nums.partition(e\
    \ => e > 0)\n        subsets.map(x => minSum + x.reduceLeft((x,y) => x + y)).reduceLeft(_\
    \ + _)", "        var result = nums.foldLeft(0l) { (x, y) => x + y }\n       \
    \ val currentMax = nums.foldRight(List.empty[Long]) { case (y, x) => x + y }\n\
    \        if (currentMax.nonEmpty) result = math.min(currentMax, result)\n    \
    \    result", "        var numsSum : Long = 0l\n        var numsSubArray = nums\n\
    \        while(numsSubArray.nonEmpty) {\n            numsSum += numsSubArray(0)\n\
    \            numsSubArray = numsSubArray(1)\n        }\n        numsSum", "  \
    \      def maxSubArraySum(num : Long, sum : Long) : Long = if (num > sum) num\n\
    \        else sum\n        val sumsBuffer = mutable.ArrayBuffer(0l)\n        val\
    \ maxSumsBuffer = mutable.ArrayBuffer(0l)\n        val subArraySumsBuffer = mutable.ArrayBuffer(0l)\n\
    \        val numsBuffer = mutable.ArrayBuffer(0l)\n        for (i <- nums.indices){\n\
    \            val sum = nums(i)\n            numsBuffer(0) = nums(i)\n        \
    \    maxSumsBuffer(0) = sum\n            sumsBuffer(0) = sum\n            subArraySumsBuffer(0)\
    \ = sum\n        }\n        val minSum = -1l\n        var minSumIndex = 0\n  \
    \      var minSumNum = 0\n        var minSumSubArray = 0\n        var i = nums.length-1\n\
    \        for(i <- nums.indices){\n            val sum = nums(i)\n            sumsBuffer(i)\
    \ = sum\n            if(sum >= maxSumsBuffer(minSumIndex)){\n                minSumIndex\
    \ = i\n                minSumNum = sum\n                minSumSubArray = sumsBuffer(i)\n\
    \            }else if(sum < minSumSubArray){\n                minSum = minSumSubArray\n\
    \                minSumNum = sum\n                minSumSubArray = sumsBuffer(i)\n\
    \            }else{\n                val j = i+1\n                while(j < nums.length\
    \ && sum < sumsBuffer(j))\n                    j += 1\n                val maxSubArraySum\
    \ = maxSubArraySum(nums(j), sumsBuffer(j))\n                if(maxSubArraySum\
    \ < minSumSubArray){\n                    minSum = minSumSubArray\n          \
    \          minSumNum = minSumNum + maxSubArraySum\n                    minSumSubArray\
    \ = maxSubArraySum\n                }else{\n                    val maxSubArraySum\
    \ = maxSubArraySum(nums(i), sumsBuffer(i))\n                    if(maxSubArraySum\
    \ < minSumSubArray){\n                        minSum = minSumSubArray\n      \
    \                  minSumNum = maxSubArraySum\n                        minSumSubArray\
    \ = maxSubArraySum\n                    }\n                }\n            }\n\
    \        }\n        minSumNum", "        val numsCopy = nums.toList\n        val\
    \ numsSize = nums.size\n        if (numsSize < 3) return 0\n        val maxSubArraySize\
    \ = numsCopy.tail.foldLeft[Int](0)((acc, cur) => acc > cur ? acc : cur)\n    \
    \    val totalSize = numsCopy.last\n        var minSubArray = numsCopy.head\n\
    \        for (i <- 0 to (numsSize - maxSubArraySize + 1)) {\n            val nextSubArray\
    \ = numsCopy.slice(i + 1, i + maxSubArraySize + 1)\n            var newTotalSize\
    \ = totalSize - nextSubArray.last\n            var newMinSubArray = minSubArray\n\
    \            nextSubArray.foreach { num =>\n                newTotalSize += num\n\
    \                newMinSubArray += num\n            }\n            if (newMinSubArray\
    \ < minSubArray) minSubArray = newMinSubArray\n        }\n        minSubArray",
  "        val (i, min) = nums.span(_ > 0)\n        if (i.isEmpty) 0\n        else\
    \ if (i.head == -1) -1\n        else i.head + min min minSubArraySum(i.tail)",
  "        var min_sum = Long.MaxValue\n        for(l <- nums) {\n            if (l\
    \ != 0)\n                min_sum = math.min(min_sum, l)\n        }\n        min_sum",
  "        val (maxElem, minElem) =\n            nums.span(_ < 0).maxBy(_._1).getOrElse(throw\
    \ new IllegalArgumentException)\n        val subList = nums.span(_ < 0).drop(1).filterNot(_\
    \ == minElem)\n        // The sublist is non-empty. We compute the minimum sum\
    \ of any non-empty sub-list of\n        // nums\n        // and compare it to\
    \ the maximum element of the list nums\n        // If they are equal the answer\
    \ is maxElem. Else, the answer is minElem + subListSum\n        if(subList.isEmpty)\
    \ {\n            return maxElem\n        }\n        val subListSum = subList.sum\n\
    \        val currentSum = subListSum - minElem\n        if(currentSum == 0) {\n\
    \            return maxElem\n        }\n        if(currentSum < 0) {\n       \
    \     return minElem + subListSum\n        }\n        return minElem + subListSum",
  "        val sums = nums.foldLeft(0l){case (sum, v) => (sum + v)}\n        val subSum\
    \ = nums.foldLeft((0l, 0l)) {\n            case ((suma, subSum), (v, idx)) =>\n\
    \                val sub = nums.drop(idx)\n                (suma + v, subSum +\
    \ sub.sum)\n        }\n        if (subSum._2 < sums) {\n            subSum._2\n\
    \        } else {\n            sums\n        }", "        if (nums.isEmpty) 0\n\
    \        else {\n            val maxsum = nums.reduce((x, y) => max(x, y))\n \
    \           val minsum = nums.reduce((x, y) => min(x, y))\n            minsum\
    \ + minSubArraySum(nums.subList(1, nums.length))\n        }", "        val res\
    \ = nums.foldLeft(Long.MaxValue) { (sum, cur) =>\n            val maxSub = List(cur,\
    \ sum - cur).max\n            if (maxSub != 0)\n                maxSub\n     \
    \       else\n                sum\n        }\n        res", "        val minSum\
    \ = sys.maxLong\n        for(i <- 0 until nums.length)\n            if (i + nums.head\
    \ < nums.length) minSum = min(minSum, i + nums.head + nums.slice(i+1).minBy(_+_).orElse(0))\n\
    \            else minSum\n        minSum", "        // O(n)\n        var minSum\
    \ = -1l.toLong\n        var curSum = -1l.toLong\n        var curCount = 1l\n \
    \       for (i <- nums.indices) {\n            if (nums(i) != -1l.toLong) {\n\
    \                curSum = curSum + nums(i)\n                curCount = curCount\
    \ + 1\n                if (minSum < -1l) {\n                    minSum = curSum\n\
    \                }\n            }\n        }\n        return minSum", "      \
    \  val s = nums.foldLeft(0l)( (a,e) => Math.min(a,e) )\n        s", "        val\
    \ min = math.min(nums.headOption,nums.lastOption)\n        val sublist = new mutable.ListBuffer[Long]()\n\
    \        nums.foreach { x =>\n            val min = math.min(min, x)\n       \
    \     val sublist = sublist :+ min\n        }\n        val min = math.min(min.product,\
    \ sublist.sum)\n        min", "      if(nums.isEmpty) {\n        0\n      }\n\
    \      else {\n        val min = math.min(nums.head)\n        var sum = nums.head\
    \ + min\n        var sumOfRest = sum\n        nums = nums.tail\n        while(nums.nonEmpty)\
    \ {\n          val tmp = math.min(nums.head)\n          sum = sum + tmp\n    \
    \      sumOfRest = sumOfRest + tmp\n          nums = nums.tail\n        }\n  \
    \      sumOfRest\n      }", "        def min(a: Int, b: Int, i: Int, l: List[Long])\
    \ : Option[Long] = {\n            if (i >= l.length) None\n            else {\n\
    \                if (a <= 0) Some(l.sum())\n                else if (b < 0) Some(min(a,\
    \ l.sum(), i+1, l))\n                else if (nums(i) < 0) Some(min(a, min(l.sum(),\
    \ b+nums(i))+nums(i), i+1, l))\n                else {\n                    val\
    \ sum = a + nums(i)\n                    val c1 = min(a, l.sum(), i+1, l)\n  \
    \                  val c2 = min(b+nums(i), sum, i+1, l)\n                    if\
    \ (c2.isDefined && c1.isDefined) Some(math.min(c2.get, c1.get))\n            \
    \        else if (c1.isDefined) c1.get\n                    else if (c2.isDefined)\
    \ c2.get\n                    else Some(sum)\n                }\n            }\n\
    \        }\n\n        if (nums.isEmpty) throw new Exception(\"empty list\")\n\
    \        if (nums.head <= 0) throw new Exception(\"negative value\")\n       \
    \ val l = nums.dropRight(1)\n        min(0, l.sum, -1, l)", "      val n = nums.size\n\
    \      val l = nums.foldLeft(0l){ (sum, num) =>\n        if((sum + num) > sum)\
    \ sum + num\n        else sum\n      }\n      n * (n - l) / 2 + l", "        var\
    \ minSum : Long = nums.head._2 // initialize min sublist sum to first number\n\
    \        var idx : Int = 0\n        for (i <- 0 until nums.length) if (nums(i)\
    \ > 0) minSum = math.max(minSum + nums(i), minSum) // find max sublist sum in\n\
    \        // this iteration\n        idx += 1\n        for (i <- 0 until nums.length)\
    \ if (nums(i) > 0) minSum = math.max(minSum, minSubArraySum(nums.dropRight(idx+1)))\
    \ // find min sublist sum\n        // after remaining iteration\n        idx -=\
    \ 1\n        minSum", "        // Base Case\n        if (nums.isEmpty) {\n   \
    \         return 0L\n        }\n        // Recursive Case\n        val min = nums.head\n\
    \        val rest = nums.tail\n        val minSum = minSubArraySum(rest)\n   \
    \     return math.min(min + minSum, rest.map(_.toLong).sum)", "        val numArray\
    \ = nums.toArray\n        val n = nums.toArray.length\n        val k = math.min(n,\
    \ numArray.length)\n        val dp = (0 to k).map(x => math.max((math.min(numArray.length\
    \ - x, 0), math.max(0, x - math.min(numArray.length - x, 0))))).toArray\n    \
    \    val result = numArray.reduce(_ + _ - dp.sum)\n        result", "        val\
    \ numsLen = nums.size\n        val sumList = mutable.ArrayBuffer.empty[Long]\n\
    \        var maxSum = -Long.MaxValue\n        var maxIndex = -1\n        for(i\
    \ <- 0 until numsLen) {\n            val tmp = nums(i) + minSubArraySum(nums.drop(i))\n\
    \            sumList.append(tmp)\n            val curSum = tmp\n            if\
    \ (curSum > maxSum) {\n                maxSum = curSum\n                maxIndex\
    \ = i\n            }\n        }\n        sumList.min", "        if (nums.isEmpty)\
    \ {\n            -1\n        }\n        else{\n            // Sort the list\n\
    \            nums.sortWith(_ < _)\n\n            val left = nums.head\n      \
    \      var sum : Long = left //Sum of current number\n            var right =\
    \ nums.tail.head\n            var curSum : Long = left //Sum of remaining numbers\n\
    \n            // Iterate through the rest and find the min one\n            while\
    \ (right != -1) {\n                curSum += right\n                right = nums.tail.last\n\
    \                if (curSum < sum) {\n                    sum = curSum\n     \
    \           }\n            }\n            sum\n        }", "        // Use recursive\
    \ algorithm to find the minimum sum from the sub-array\n        // that only consists\
    \ of one element\n\n        // The idea is that if we have a sub-array with one\
    \ element, we can\n        // update our running minimum sum to that element by\
    \ adding the number\n        // to our running minimum sum\n        val minSum\
    \ : Long = 0\n        val index = 0\n        val size = 0\n        // Iterate\
    \ through the list until we find the first index where a sub-array\n        //\
    \ with one element is found\n        while (index < nums.length) {\n         \
    \   val thisSum : Long = 0\n            val thisSize : Int = 0\n            while\
    \ (index < nums.length && thisSize == 0) {\n                // Keep adding numbers\
    \ to the running minimum sum\n                thisSum += nums(index)\n       \
    \         thisSize += 1\n                index += 1\n            }\n         \
    \   // If the sum is less than the running minimum sum, then update the running\
    \ minimum\n            minSum <- (thisSum + thisSize)\n        }\n        minSum",
  "        val min = math.min(nums.head, nums.last)\n        var sum = 0L\n      \
    \  for (nElem <- nums) {\n            if (nElem > min) {\n                sum\
    \ += nElem - min\n            }\n        }\n        min", "        val minSum\
    \ = math.min(nums.reduceLeft(_ + _))\n        val sum = nums.foldLeft(math.min(nums.reduceLeft(_\
    \ + _))) {_ + _}\n        sum - minSum", "        // Write your code here\n  \
    \      var sum = nums.foldLeft(0l){(acc, curr) => acc+curr}\n        for (x <-\
    \ nums) {\n            if (nums.exists(y => y-x == 0)) continue\n            var\
    \ sum1 = sum;\n            sum -= x;\n            sum = sum + x\n            if\
    \ (sum < sum1) sum1 = sum\n        }\n        return sum", "        if(nums.isEmpty)\
    \ 0\n        else nums.head._1 + minSubArraySum(nums.tail)", "        var minSum\
    \ = 0L\n        var minSumIndex = 0\n        var maxSum = -1000000000L\n     \
    \   var maxSumIndex = 0\n        nums.foreach{ x =>\n            minSum = minSum\
    \ + x\n            if (minSum > maxSum) {\n                minSumIndex = x\n \
    \               maxSum = minSum\n            } else if (minSum < maxSum) {\n \
    \               maxSumIndex = x\n                maxSum = minSum\n           \
    \ }\n        }\n        val answer = minSumIndex + maxSumIndex\n        return\
    \ answer", "        val res = nums.foldLeft[Long](-1l)( (acc, x) => acc + x )\n\
    \        require(res >= 0l, \"Invalid input\")\n        res", "        if(nums.isEmpty)\n\
    \            return -1l.toLong;\n        val min = nums.reduce(_ + _);\n     \
    \   val minIndex = -1;\n        val numsToFind = nums.takeWhile((_,_) => true).map(_._2).sum;\n\
    \        val startIndex = nums.size - numsToFind.toInt;\n        val endIndex\
    \ = startIndex + numsToFind.toInt;\n        val resultList = nums.drop(startIndex).take(endIndex).map(_._2).mkString(\"\
    , \");\n        val start = resultList + \" \" + resultList.lastIndexOf(\",\"\
    , resultList.lastIndexOf(\",\")+1);\n        val end = resultList.lastIndexOf(\"\
    ,\", resultList.lastIndexOf(\",\") - 1) + 1;\n        return if (nums.indexOf(min)\
    \ == start) {\n            min\n        } else {\n            minSubArraySum(nums.takeWhile((_,_)\
    \ => false).map(_._2).sum)\n        }", "        // Add up all the elements within\
    \ the sub-lists\n        val summands = nums.map(n => n*n)\n        // Sum all\
    \ the elements in the sub-lists\n        val sum = summands.reduce{ (a,b) => a\
    \ + b }\n        // Find the minimum sum\n        val min = summands.find(_ >=\
    \ sum)\n        sum.toLong", "        var min = Long.MaxValue\n        var sum\
    \ = 0\n        for (i <- 0 until nums.length) {\n            sum += nums(i)\n\
    \            if (sum < min)\n                min = sum\n        }\n        min",
  "        require(nums.nonEmpty, \"Empty list\")\n        val min = nums.head\n \
    \       val index = nums.indexWhere(_.nonEmpty)\n        val numsMinusMin = nums.drop(index)\n\
    \        numsMinusMin.foldLeft(min){\n            (min, x) => min + x\n      \
    \  }", "        var max = 0L\n        var min = Long.MinValue\n        for(i <-\
    \ 0 until nums.size) {\n            var maxSum = 0L\n            for(j <- 0 until\
    \ i if j != nums.indexOf(i)) {\n                val curSum = nums(i) + nums(j)\n\
    \                if (curSum > maxSum) maxSum = curSum\n            }\n       \
    \     if (maxSum > max) max = maxSum\n        }\n        if (max < min) min =\
    \ max\n        return min + max", "        def minSubArraySumHelper(nums, currentSum\
    \ : Long, minSum : Long) : Long = {\n            val curNum = nums.head\n    \
    \        val curSum = currentSum + curNum\n            if(curNum == 0)\n     \
    \           return minSum\n\n            val newMinSum = minSubArraySumHelper(nums.tail,\
    \ curSum, minSum)\n            if(curSum > newMinSum)\n                newMinSum\n\
    \            else\n                minSubArraySumHelper(nums.tail, curSum, newMinSum)\n\
    \        }\n        minSubArraySumHelper(nums, 0l, 0l)", "        if (nums.isEmpty)\n\
    \            return 0\n        var sum = 0\n        var min = nums.head\n    \
    \    var min = nums.head\n        var max = nums.head\n        for ( i <- nums.tail\
    \ ) {\n            if (i < min)\n                min = i\n            if (i >\
    \ max)\n                max = i\n            sum += min\n        }\n        return\
    \ sum", "      if(nums.isEmpty) {\n        0L\n      } else {\n        def helper(nums2\
    \ : List[Long], sum : Long, idx : Int) : Long = nums2.head match {\n         \
    \ case -1 =>\n            sum + helper(nums2.tail, sum, idx + 1)\n          case\
    \ -2 =>\n            sum + helper(nums2.tail, sum, idx + 1)\n          case _\
    \ =>\n            helper(nums2.tail, sum + nums2.head, idx)\n        }\n     \
    \   helper(nums.tail, 0L, 0)\n      }", "        def minSum(nums1 : List[Long],\
    \ nums2 : List[Long], sum : Long) : Long = {\n            if (nums1.isEmpty) sum\n\
    \            else minSum(nums1.tail, nums2.tail, sum + nums1.head) \n        }\n\
    \        val m = nums.head\n        val n = nums.tail\n        minSum(nums.takeWhile(_\
    \ < m), nums.dropWhile(_ < m), m)", "        var sum : Long = 0l\n        var\
    \ minSum : Long = math.maxLong(sum)\n        var index = 0\n        while (index\
    \ < nums.length) {\n            var sum : Long = math.minLong(math.max(nums(index)\
    \ + sum, minSum))\n            if (sum < minSum) {\n                minSum = sum\n\
    \            }\n            index += 1\n        }\n        minSum", "        val\
    \ result = nums.foldLeft(0L) { (acc, e) =>\n            acc + (e.asInstanceOf[Long])\n\
    \        }\n        return result", "        // Base Case\n        if(nums.isEmpty)\
    \ return 0\n        val min = nums.head\n        // Recursive Case\n        for(elem\
    \ <- nums.tail) {\n            min = min(elem + min, min)\n        }\n       \
    \ min", "        if (nums.isEmpty) {\n            0l\n        } else {\n     \
    \       var sum = 0l\n            for (x <- nums.toList)\n                sum\
    \ += x\n            val min = sum / nums.size\n            for (x <- nums.toList)\n\
    \                if (x < min)\n                    min = x\n            min\n\
    \        }", "        def find(start : Long, acc : Long) : Long = \n         \
    \   if (nums.isEmpty) acc\n            else find(start + nums.head, acc + (nums.head\
    \ - start))\n\n        def findSubList(start : Long, acc : Long) : Long = \n \
    \           if (nums.isEmpty) acc\n            else {\n                val sum\
    \ = nums.head - start\n                if (sum < acc) findSubList(start + sum,\
    \ acc)\n                else findSubList(start, sum)\n            }\n\n      \
    \  find(0, 0l)", "        var sum = 0l\n        for (x<-nums) {\n            val\
    \ end = nums.indexWhere{ _ > x}\n            sum += (x :: nums.drop(end)).toList.sum\n\
    \        }\n        return sum", "        var min = 0L\n        var subSum = 0L\n\
    \        var next = 0L\n        var i = -1L\n        var j = -1L\n        var\
    \ k = -1L\n        while(true) {\n            if(nums.isEmpty) {\n           \
    \     return 0\n            }\n            if(next < 0) {\n                next\
    \ = 0L\n            } else {\n                subSum += nums.head\n          \
    \      next += 1L\n                nums = nums.tail\n            }\n         \
    \   i -= 1L\n            j -= 1L\n            k -= 1L\n            val temp =\
    \ subSum - nums(j)\n            if(temp > min) {\n                min = temp\n\
    \            }\n        }", "        // Your code here\n        var sum : Long\
    \ = 0\n        var i = 0\n        var j = 1\n        var k = 0\n        var index\
    \ = 0\n        val numberSet = nums.toSet\n        while(i < nums.size) {\n  \
    \          if(numberSet.contains(nums(i))) {\n                j += 1\n       \
    \         sum += nums(i)\n            }\n            i += 1\n        }\n     \
    \   if(j < nums.size) {\n            index += 1\n        }\n        sum", "  \
    \      val minMaxSum = nums.toList\n            .foldLeft((Long.MaxValue, Long.MinValue))((sum,\
    \ i) => (sum, i))\n            ._1\n            .foldLeft((0l, 0l))((min, max)\
    \ => (if (min > max) max else min))\n            ._1\n        val numsSum = nums.toList.foldLeft((0l,\
    \ 0l))((min, max) => (if (min > max) max else min))\n            ._1\n\n     \
    \   if (minMaxSum > numsSum) return minMaxSum\n        val maxMinSum = nums.toList.foldRight((0l,\
    \ 0l))((min, max) => (if (min > max) max else min))\n            ._2\n       \
    \ if (maxMinSum < numsSum) return maxMinSum\n        return numsSum", "      \
    \  val (minSum, maxSum, currentSum) =\n            nums.foldLeft((nums.head, nums.last,\
    \ nums.head.asInstanceOf[Long])) {\n                case ((minSum2, maxSum2, currentSum2),\
    \ (currentNum, maxNum, i)) =>\n                    val newMinSum = if (minNum\
    \ < currentNum) currentNum else minNum\n                    val newMaxSum = if\
    \ (maxNum > currentNum) currentNum else maxNum\n                    (newMinSum,\
    \ newMaxSum, (newMinSum + currentNum))\n            }\n        (maxSum - minSum).asInstanceOf[Long]",
  "        // write your code here\n        val n = nums.max\n        val min = Long.MinValue\n\
    \        var sum : Long = 0\n        var i : Int = 0\n        var j = n\n    \
    \    while (i < n && j < n) {\n            sum = nums.take(i).reduceLeft(_ + _)\n\
    \            j = i\n            while (sum < nums.last) sum +=nums(i)\n      \
    \      i = i + 1\n        }\n        return sum", "      val (sums, numsToAdd)\
    \ = nums.foldLeft((Seq.empty, Seq.empty)) {\n        case ((sums, nums), i) =>\
    \ nums.map(num => (num - i, num)).foldLeft((sums, nums)) {\n          case ((sums2,\
    \ nums2), j) => if (sums2.length < nums2.length) sums2 :+ nums2 else sums\n  \
    \      }\n      }\n\n      val min = sums.min\n      (sums.max - min, numsToAdd.map(sum\
    \ => (sum + min)).min) // <- this is where you're getting the error from.", " \
    \       val res = nums match {\n            case Nil => 0\n            case _\
    \ => {\n                val ns = nums.sort\n                val minSum = ns.head\
    \ + ns.last\n                val tmpMinSum = minSum\n                val n = nums.size\n\
    \                for (i <- n until 1) tmpMinSum = tmpMinSum - ns(i) + ns(i)\n\
    \                tmpMinSum\n            }\n        }\n        res", "        var\
    \ bestSum = -1\n        var bestSub = 0\n\n        for (i <- 0 until nums.size)\n\
    \        {\n            var curSum = 0\n\n            for (j <- 0 until nums.size-i)\n\
    \            {\n                curSum += nums(i)\n                curSum += nums(i\
    \ + j)\n\n                if (curSum < bestSum)\n                {\n         \
    \           bestSum = curSum\n                    bestSub = i + j\n          \
    \      }\n            }\n        }\n\n        bestSum", "        var min = Long.MaxValue\n\
    \        var index = 0\n        for (elem <- nums) {\n            if (index >=\
    \ 0) {\n                min = math.min(min, math.max(0, elem - nums(index)))\n\
    \            }\n            else {\n                min = math.min(min, elem)\n\
    \            }\n            index++\n        }\n        min", "        def subSum(i\
    \ : Int) : Long = {\n            val sum = i\n            val min = i\n      \
    \      for (j <- i+1 until nums.size) {\n                val minSum = min + nums(j)\n\
    \                if (minSum > sum) {\n                    sum = minSum\n     \
    \           }\n                min = minSum\n            }\n            sum\n\
    \        }\n        val s = nums.reduceLeft(0)(_ + _)\n        val l = nums.reduceLeft(0)(_\
    \ + _)\n        s + l", "        val n = new mutable.ListBuffer[Long]()\n    \
    \    val m = nums.length\n        val maxN = m.toLong\n        var total = 0L\n\
    \        var start = 0L\n        var end = ns(num)\n        var totalSum = 0L\n\
    \        var minSum = 0L\n        while(start < end){\n            val x = nums(start)+nums(end)\n\
    \            total += x\n            totalSum += x\n            n.push(x)\n  \
    \          if(n.length >  maxN){\n                minSum = totalSum\n        \
    \        totalSum = 0\n                start = end\n                end = ns(num)\n\
    \                max = ns(num)\n            }\n            start += 1\n      \
    \      end -= 1\n        }\n        return minSum", "        val s = nums.reduce(_\
    \ + _)\n        nums.find(num => nums.takeWhile(x => x + x < num).forall(x =>\
    \ x < num)).getOrElse(s)", "        val l = nums.size\n        var smallestSum\
    \ = 0L\n        var index = 0\n\n        // iterate over the sub lists to get\
    \ the minimum sum\n        while (index < l) {\n            // if we get a new\
    \ smallest sum then record it\n            if (smallestSum < nums.sum) {\n   \
    \             smallestSum = nums.sum\n            }\n            // move the index\n\
    \            index += 1\n        }\n\n        return smallestSum", "        var\
    \ min = Long.MaxValue\n        for(n <- nums){\n            min = math.min(min,\
    \ n)\n        }\n        min", "        val min = Int.MinValue\n        def helper(n:Int,\
    \ cur : List[Long], sum : Long, sums : mutable.ArrayBuffer[Long]) : Long = {\n\
    \            if (n == 0) {\n                sum\n            } else if (cur.length\
    \ == 0) {\n                sums += sum\n                sum\n            } else\
    \ {\n                val mid = cur.length / 2\n                val left = mid\
    \ - 1\n                val right = mid\n                val leftSum = helper(n,\
    \ cur.take(left), sum + cur(left), sums)\n                val rightSum = helper(n,\
    \ cur.takeRight(right), sum + cur(right), sums)\n                if (leftSum <\
    \ rightSum) {\n                    helper(n, cur.take(left), leftSum, sums)\n\
    \                } else {\n                    helper(n, cur.takeRight(right),\
    \ rightSum, sums)\n                }\n            }\n        }\n        helper(nums.length,\
    \ nums, 0, 0)", "        nums.size match {\n            case 0 => 0\n        \
    \    case 1 => nums.head\n            case _ => {\n                val min = nums.head\
    \ + minSubArraySum(nums.tail)\n                for (i <- 0 until nums.size) {\n\
    \                    val tail = nums.slice(i + 1, nums.size).sum\n           \
    \         if (tail < min) {\n                        min = tail\n            \
    \        }\n                }\n                min\n            }\n        }",
  "        var sum = 0L\n        var minsum = nums.reduceLeftOption( { (sum1, current)\
    \ => \n            val sum = sum1 + current\n            if (sum >= sum1) {\n\
    \                sum\n            } else {\n                sum1\n           \
    \ }\n        }).getOrElse(0L)\n\n        nums.foreach(sum ++= _)\n        minsum",
  "        // Base case\n        if (nums.isEmpty)\n            return 0\n\n     \
    \   // Find first element that is > the sum of every element in the rest of the\
    \ list\n        var min : Long = nums.head\n        var sum = 0\n        for (i\
    \ <- 0 until nums.size) {\n            sum += nums(i)\n            if (sum < min)\n\
    \                min = sum\n        }\n\n        // Iterate over rest of the list\
    \ and update min\n        var i : Long = 0\n        var sum : Long = nums.last\n\
    \        for (j <- 0 until nums.size) {\n            sum += nums(j)\n        \
    \    if (sum < min)\n                min = sum\n\n            // Subtract from\
    \ sum all the element in the rest of the list that were subtracted earlier\n \
    \           sum += nums(i)\n            i = j - 1\n        }\n\n        // Return\
    \ the minimum sum\n        min", "        // Your code here\n        nums.sliding(3).drop(1).foldLeft((Long.MaxValue\
    \ ,0)) { (sum,list) =>\n            var s = sum._1 + list.sum\n            list.foreach(sum._2\
    \ = max(s, sum._2))\n            sum\n        }._1", "        // write your code\
    \ here\n        var min = sys.Long.MaxValue\n        var temp : Long = 0\n   \
    \     for( elem <- nums){\n            temp = temp + elem\n            if(temp\
    \ < min) {\n                min = temp\n            }\n        }\n        min",
  "        // Brute force - O(n^2)\n        // let res = Int.MinValue\n        nums.foldLeft((Int.MinValue,\
    \ 0L)) {\n          case ((acc, sum), x) => if (x > 0) (minSubArraySum(nums.take(x)),\
    \ sum + x) else (acc, sum)\n        }._1", "        // Sort the list to prevent\
    \ repeated sublists sums\n        val numsSorted = nums.sortWith(_ > _)\n    \
    \    var minSum = 0L\n        var maxSum = 0L\n        var lastSum = 0L\n    \
    \    // For every sum from the sorted list, subtract from the current minimum\
    \ or maximum\n        for (currentSum <- numsSorted) {\n            // Subtract\
    \ the current sum from either the min or max\n            minSum = currentSum\
    \ - minSum\n            maxSum = currentSum - maxSum\n            // If the current\
    \ sum is lower than the last sum, we need to add a new minimum sum\n         \
    \   // and reset max and min for the new sum\n            if (currentSum < lastSum)\
    \ {\n                // Add the current sum to a new min sum\n               \
    \ minSum += currentSum\n                maxSum = currentSum\n            } else\
    \ {\n                // Add the current sum to a new max sum\n               \
    \ maxSum = currentSum\n            }\n            lastSum = currentSum\n     \
    \   }\n        // Return the minimum sum\n        minSum", "        val set =\
    \ mutable.Set[Long]()\n        def sum(ns : List[Long]) : Long = {\n         \
    \   val s = ns.sum\n            if (set.contains(s)) s\n            else set.add(ns\
    \ sum)\n        }\n        val l = nums.reduce(sum)\n        val r = nums.reduceLeftOption[Long](sum).orElse(0)\n\
    \        val m = nums.foldLeft[Long](0)(_ + _)\n        (l - r) / (2 * m)", " \
    \       val minSum = math.Long.MinValue\n        val numsCopy = nums.toList\n\
    \        val mutableList = new mutable.ListBuffer[Long]()\n        mutableList.add(numsCopy.head)\n\
    \        \n        for ( i <- numsCopy.tail ) {\n            val current = mutableList\n\
    \            current.remove(0)\n            \n            if( i < (current.last\
    \ - current.last) ) \n                current.last += i\n            else \n \
    \               current.last -= i\n                \n            if( current.last\
    \ < minSum ) \n                minSum = current.last\n            else if( current.last\
    \ > minSum ) \n                mutableList.clear()\n                mutableList.add(current.last)\n\
    \                \n            mutableList.add(i)\n        }\n        \n     \
    \   minSum", "        // Find a sub-list with at least one element\n        def\
    \ findSubList(nums : List[Long], num : Long) : List[Long] = {\n            if\
    \ (nums.isEmpty) List(num)\n            else nums.head :: nums.tail.filter(x =>\
    \ x >= num).find(findSubList(_, num)).map(_ + num)\n        }\n\n        // Find\
    \ a sub-list with exactly one element\n        def findSubListExactly(nums : List[Long],\
    \ num : Long) : List[Long] = {\n            if (nums.isEmpty) List(num)\n    \
    \        else nums.head :: nums.tail.filter(x => x != num).find(findSubListExactly(_,num)).map(_\
    \ + num)\n        }\n\n        // Find a sub-list with two or more elements\n\
    \        def findSubListMoreThanOne(nums : List[Long], num : Long) : List[Long]\
    \ = {\n            if (nums.isEmpty) List(num)\n            else nums.head ::\
    \ nums.tail.filter(x => x >= num).find(findSubListMoreThanOne(_,num)).map(_ +\
    \ num)\n        }\n\n        // Find a sub-list with exactly two elements\n  \
    \      def findSubListExactlyTwo(nums : List[Long], num : Long) : List[Long] =\
    \ {\n            if (nums.isEmpty) List(num)\n            else nums.head :: nums.tail.filter(x\
    \ => x != num).find(findSubListExactlyTwo(_,num)).map(_ + num)\n        }\n\n\
    \        // Find a sub-list with three or more elements\n        def findSubListMoreThanThree(nums\
    \ : List[Long], num : Long) : List[Long] = {\n            if (nums.isEmpty) List(num)\n\
    \            else nums.head :: nums.tail.filter(x => x >= num).find(findSubListMoreThanThree(_,num)).map(_\
    \ + num)\n        }\n\n        nums.find(findSubListExactly(nums,0l)).map(x =>\
    \ x.sum).min", "        nums.foldLeft(0l) { (sum, next) =>\n            if (sum\
    \ + next < 0)\n                sum + next\n            else\n                sum\n\
    \        }", "        var sum : Long = math.MinLong\n        var list: List[Long]\
    \ = Nil\n\n        for (i <- 0 until nums.length) {\n            var sumOfNext\
    \ = sum\n            sum += nums(i)\n            if (sumOfNext > sum) {\n    \
    \            list = List(nums(i))\n                sum = sumOfNext\n         \
    \   }\n        }\n        list.toList.reduceLeftOption(_ + _)", "        val minSum:\
    \ Long = nums.head.asInstanceOf[Long]\n        var currentSum: Long = minSum\n\
    \        for (n: Long <- nums.tail) {\n            if (n < currentSum) {\n   \
    \             currentSum = n\n            } else {\n                currentSum\
    \ -= n\n            }\n            minSum = currentSum\n        }\n        return\
    \ minSum", "        val m = mutable.Buffer.empty[Long]\n        val n = mutable.Buffer.empty[Long]\n\
    \        for (x <- nums) {\n            if (m.isEmpty) n += x\n            else\
    \ {\n                if (x - m.head < n.head - m.head) m += x\n              \
    \  else n += x\n            }\n        }\n        if (m.isEmpty) n.head\n    \
    \    else {\n            if (n.head - m.head > n.last - m.last) m.last\n     \
    \       else n.last\n        }", "        val minArray = mutable.ArrayBuffer.empty[Long]\n\
    \        var minSum = Long.MinValue\n        for (i <- 0 until nums.length-1)\
    \ {\n            if (minArray.length == 0) {\n                minArray += nums(i)\n\
    \                minSum = nums(i)\n            } else {\n                val newSum\
    \ = minSum + nums(i)\n                if (newSum < minSum) {\n               \
    \     minArray = newArray\n                    minSum = newSum\n             \
    \   } else {\n                    minArray += nums(i)\n                }\n   \
    \         }\n        }\n        minSum", "        var min = Long.MaxValue\n  \
    \      for {\n            n <- nums\n            if (n != 0l) {\n            \
    \    val summ = n.toDouble + min\n                if (summ < min) min = summ\n\
    \            }\n        } yield min", "        val index = 0\n        var min\
    \ = Long.MinValue\n        val list = new ArrayList[Long]()\n        for (x <-\
    \ nums) {\n            index += 1\n            if (list.isEmpty) list.push(x)\n\
    \            else {\n                if (x < list.get(list.size - 1)) list.update(1,\
    \ x)\n                else list.update(0, x)\n            }\n            if (list.size\
    \ <= index) min = list.get(list.size - 1)\n        }\n        min", "        val\
    \ numsCopy = nums.filter(!_.isZero)\n        if (numsCopy.isEmpty)\n         \
    \   return 0\n        val maxListSize = numsCopy.foldLeft(0l)((sum,elem) => math.max(sum,elem.toLong))\n\
    \        val sortedNums = numsCopy.sorted\n        val sumLists = numsCopy.scanLeft(0l)(_+_).filter(!_.isZero)\n\
    \        val sumListsSize = sumLists.foldLeft(0l)(_+_)\n        val minimumSum\
    \ = (maxListSize + sumListsSize) / 2 + sumLists.min\n        minimumSum.toLong",
  "        var sum = 0\n        var minSum = -1\n        for ((i <- nums.indices)\
    \ if (!nums(i).isEmpty && sum + nums(i) < minSum) {\n            sum += nums(i)\n\
    \            minSum = sum\n        }\n        minSum", "        val result = Long.MinValue\n\
    \        val numsMap = nums.groupBy(identity)\n        var min = Long.MinValue\n\
    \        for ((k,v) <- numsMap) {\n            val sum = v.sum\n            if\
    \ (min > sum) {\n                min = sum\n            }\n            val nextSum\
    \ = min - sum\n            if (nextSum > result && sum > 0) {\n              \
    \  result = nextSum\n            }\n        }\n        result", "        val sums\
    \ = nums.map(x => if(x >=0l) x else x + 1l)\n        val sumsOfSubArrays = sums.sliding(2).map(_.reduce(_+_)).filter(_>0l)\n\
    \        sumsOfSubArrays.min", "        var minsum = nums.head\n        var min\
    \ = nums.head\n        for(i <- nums.tail) {\n            if(i < min) {\n    \
    \            minsum -= min\n            }\n            minsum += i\n        }\n\
    \        minsum", "        val numsCopy = nums\n        val minSum = Long.MaxValue\n\
    \        var idx = 0\n        while (idx < nums.length) {\n            var sum\
    \ = 0L\n            while (idx < numsCopy.length && numsCopy.head <= nums(idx))\
    \ {\n                sum += nums(idx)\n                idx += 1\n            }\n\
    \            if (sum < minSum) {\n                minSum = sum\n            }\n\
    \        }\n        minSum", "        val set = nums.toSet\n        if(set.size\
    \ == 0) 0\n        else {\n            val minSum = 0l\n            for(i <- nums.indices)\
    \ {\n                if(set(i)) minSum = math.min(minSum, nums.sum)\n        \
    \    }\n            minSum\n        }", "      val (start, end) = nums.span(_\
    \ > 0l)\n      if (start == end) {\n          val sum : Long = start.reduce((a,\
    \ b) => a + b)\n          if (sum < 0l)\n            throw new IllegalArgumentException(\"\
    Negative number is not allowed\")\n          sum\n      }\n      else {\n    \
    \    val (middle, tail) = nums.span(_ > middle)\n        if (middle == 0 || tail\
    \ == 0) 0l\n        else {\n          val middleSum = middle.reduce((a, b) =>\
    \ a + b)\n          val (middleTailSum, tailSum) = nums.span(_ > middleTailSum)\n\
    \          val middleTailSumSum = middleTailSum.reduce((a, b) => a + b)\n    \
    \      val tailSumSum = tail.reduce((a, b) => a + b)\n          if (middleTailSumSum\
    \ < tailSumSum)\n              middleTailSumSum\n          else if (middleTailSumSum\
    \ == tailSumSum)\n              middleTailSumSum\n          else\n           \
    \   tailSumSum\n        }\n      }", "        var sum = 0L\n        for (ns <-\
    \ nums) {\n            val oldSum = sum\n            sum += ns\n            if\
    \ (sum < oldSum) sum = oldSum\n        }\n        sum", "        if (nums.isEmpty)\
    \ return 0\n        var min = nums.head\n        var list = nums\n        while\
    \ (list.tail.isEmpty) {\n            val curr = list.head\n            val prevSum\
    \ = list.tail.sum\n            val newSum = prevSum + curr\n            if (newSum\
    \ < min) min = newSum\n            else list = list.tail\n        }\n        list.head",
  "        var minSum = 0l\n        for(i <- nums.indices) {\n            minSum +=\
    \ nums(i)\n            if(minSum < 0) {\n                minSum = Long.MaxValue\n\
    \            }\n        }\n        minSum", "        var min = Double.PositiveInfinity\n\
    \        var max = 0\n        for (i <- 0 until nums.length) {\n            val\
    \ sum = nums.filter(_ > 0).sum\n            if (sum > max) {\n               \
    \ max = sum\n            } else if (sum < min) {\n                min = sum\n\
    \            }\n        }\n        if (min == Double.PositiveInfinity)\n     \
    \       0\n        else if (min < Double.PositiveInfinity)\n            min\n\
    \        else\n            -1", "        val subArrays = nums.filter(n => n >\
    \ 0).toArray\n        val total = subArrays.foldLeft(0L) { (sum, array) => sum\
    \ + array.toLong }\n        (total / subArrays.length).toLong", "        val numSet\
    \ = mutable.Set[Long]()\n        val ans = List[Long]()\n        for (ns <- nums.tails)\
    \ {\n            val n = ns.sum\n            numSet += n\n            ans = ans.::(n)\n\
    \        }\n        val min = ans.sum\n        val minIndex = numSet.min\n   \
    \     val curSum = ans(minIndex)\n        numSet.remove(minIndex)\n        val\
    \ newSum = numSet.sum\n        minIndex + curSum - newSum", "        val m = mutable.ArrayBuffer[Long]()\n\
    \        def f(i : Int) : Int = {\n            if (i == nums.length) 0\n     \
    \       else { \n                val n = nums(i)\n                val s = m +=\
    \ n\n                if (f (n) < s (m)) m += n\n                f(++i)\n     \
    \       }\n        }\n        f(0)", "        val len = nums.length\n        val\
    \ minsum = Long.MinValue // assume negative numbers are less than positive numbers\n\
    \        if (len == 0) return minsum\n        for (i <- 0 until len) {\n     \
    \       val sublist = nums.filter(_ != nums(i))\n            if (sublist.isEmpty)\
    \ continue\n            val subsum = sublist.map(_.toLong).sum\n            if\
    \ (subsum < minsum) minsum = subsum\n        }\n        minsum", "        val\
    \ min = nums.reduce((acc,e) => if (acc < e) acc else e)\n        nums.foldLeft(0l)\
    \ { (acc,e) =>\n            if (acc < e) acc\n            else nums.drop(acc).map(x\
    \ => acc + x).takeWhile(x => x < e).map(x => x+e).sum\n        }", "        require(nums.nonEmpty)\n\
    \        require(nums.head.isLong)\n        var min = nums.head.toLong\n     \
    \   for (nn <- nums.tail) {\n            if (nn.toLong < min) {\n            \
    \    min = nn.toLong\n            }\n        }\n        min", "        require(nums.nonEmpty,\
    \ \"No elements specified\")\n        var minSum : Long = nums.head\n        for\
    \ (i <- nums.drop(1)) {\n            minSum = math.min(minSum + i, nums.head);\n\
    \        }\n        minSum", "        //Sort array and then use binary search\
    \ to find the sum of all contiguous sublist\n        //Find min and max of array\
    \ and add 1 so we don't have a negative index\n        var min = nums.min\n  \
    \      var max = nums.max\n        var sum = min\n        val minIncr = (min +\
    \ max) / 2.0\n        val maxIncr = (min + max) / 2.0 + 1.0\n        //If the\
    \ sum is negative add 1\n        if(sum < 0){\n            sum = sum + 1\n   \
    \     }\n        //Binary Search on left of min\n        if(nums(0) < min && nums(0)\
    \ != -1l){\n            val lb = BinarySearch(nums, min)\n            if(lb >\
    \ 0){\n                sum = sum + nums(lb)\n            }\n        }\n      \
    \  //Binary Search on right of max\n        else if(nums.last > max && nums.last\
    \ != 0l){\n            val ub = BinarySearch(nums, max)\n            if(ub > 0){\n\
    \                sum = sum + nums(ub)\n            }\n        }\n        //Otherwise\
    \ the sum is the max\n        else if(nums.last == max)\n            sum = sum\
    \ + nums.last\n        //Otherwise binary search in middle to find the sublist\n\
    \        else\n            sum = sum + BinarySearch(nums, minIncr, maxIncr)\n\
    \        sum", "        val numsMap = nums.groupBy(_)\n        val minSum = nums.reduce(_+_)\n\
    \        numsMap.filter(_._2.min == minSum).map(_._1).head", "        val (subList,\
    \ sum) = nums.span(_ >= 0)\n        if (subList.isEmpty) sum.min else subList.foldLeft(sum.min)\
    \ { (sum, a) => sum + a}", "        val a = nums.filter(_ > 0).map(n => nums.filter(_\
    \ == n).min)\n        val b = nums.filter(_ > 0).map(n => nums.filter(_ > n).min)\n\
    \        val c = nums.filter(_ < 0).map(n => nums.filter(_ == n).min)\n      \
    \  val d = nums.filter(_ < 0).map(n => nums.filter(_ < n).min)\n        val sum\
    \ = a.reduceLeftOption(_ + _) + b.reduceLeftOption(_ + _) + c.reduceLeftOption(_\
    \ + _) + d.reduceLeftOption(_ + _)\n        sum.getOrElse(0)", "        val result\
    \ = Array[Long](0)\n        for(i <- 0 to nums.length-1){\n            val min\
    \ = nums(i)\n            for(j <- i+1 to nums.length){\n                if(nums(j)\
    \ < min){\n                    min = nums(j)\n                }\n            }\n\
    \            result = result :+ min\n        }\n        result.min", "       \
    \ val minSum = math.max(0L, 0)\n        val numsCopy = nums.toList\n        val\
    \ min = Long.MinValue\n        val max = Long.MaxValue\n        while (numsCopy.nonEmpty)\
    \ {\n            var sum = 0L\n            var maxSum = 0L\n            while\
    \ (numsCopy.nonEmpty) {\n                sum += numsCopy(0)\n                maxSum\
    \ = math.max(sum, maxSum)\n                numsCopy.remove(0)\n            }\n\
    \            if (sum < minSum) {\n                minSum = sum\n            }\n\
    \            else if (sum > maxSum) {\n                maxSum = sum\n        \
    \    }\n        }\n        minSum", "        var result = 0L\n        var min\
    \ = Long.MaxValue\n        for(a <- nums.takeWhile(_ > 0){\n            var curSum\
    \ = 0L\n            var b = a\n            for(i <- 0 until  nums.size) {\n  \
    \              var j = 0\n                while (j < i && a.isDefined && b > 0)\
    \ {\n                    curSum += a.get\n                    a -= b\n       \
    \             j++\n                }\n                curSum += a.get\n      \
    \          a -= b\n            }\n            if (curSum <= min) {\n         \
    \       result = curSum\n                min = curSum\n            }\n       \
    \ }\n        result", "        def dfs(currentSum : Long, num : Long, i : Int,\
    \ l : List[Long]): Long = {\n            if (i == l.size) {\n                return\
    \ currentSum\n            }\n            val left = l(i-1)\n            val right\
    \ = l(i)\n            val currentLeft = dfs(currentSum + left, num, i, l)\n  \
    \          val currentRight = dfs(currentSum + right, num, i + 1, l)\n       \
    \     if (currentLeft < currentRight) {\n                return currentLeft\n\
    \            } else {\n                return currentRight\n            }\n  \
    \      }\n        dfs(0l, nums.head, 1, nums)", "        val arrays = nums.groupBy(_\
    \ % nums.length)\n            .toList.flatMap{ case (index, values) => (0 until\
    \ values.length).map(i => \n                index match {\n                  \
    \  case 0 => values(i).sum\n                    case _ => 0\n                }\n\
    \            )}\n        arrays.min", "        def minSubArraySumHelper(start\
    \ : Int, end : Int, sum : Long) : Long = {\n            if (start > end) sum\n\
    \            else {\n                val mid = start + (end - start) / 2\n   \
    \             minSubArraySumHelper(start, mid - 1, sum + nums(mid))\n        \
    \        minSubArraySumHelper(mid + 1, end, sum + nums(mid))\n            }\n\
    \        }\n\n        minSubArraySumHelper(0, nums.length - 1, nums.head)", " \
    \       var minSum = nums.head.asInstanceOf[Long]\n        for (i <- nums.tail)\
    \ {\n            val curSum = i.asInstanceOf[Long]\n            if (curSum < minSum)\
    \ minSum = curSum\n            else { minSum = minSum - i; break }\n        }\n\
    \        minSum", "        // 1. Use recursion to find all the possible sums\n\
    \        // 2. Find the minimum of all the sums\n        // 3. Return the minimum\
    \ of all the sums\n        var minSum : Long = 0\n        findSums(nums, 1, minSum)\n\
    \        minSum", "        def subArraySum(num: Long, i: Int, j : Int) : Long\
    \ = {\n            if (i < j)\n                num + subArraySum(nums, i + 1,\
    \ j)\n            else num\n        }\n        val l = nums.length\n        if\
    \ (l == 0)\n            0\n        else\n            math.min(subArraySum(nums.head,\
    \ l, 0, l), 0)", "        val m = nums.head\n        val n = nums.tail.size\n\
    \        val sum = n * m\n        if (sum < 0) sum\n        else {\n         \
    \   val r = new scala.collection.mutable.HashMap[Long, Int]()\n            for\
    \ (i <- 0 until n) {\n                val v = nums.drop(i + 1).sum\n         \
    \       r += v -> (r.getOrElse(v, 0) + 1).toLong\n            }\n            val\
    \ maxSum = r.maxBy(_._1)._2\n            if (maxSum < 0) maxSum else (sum + maxSum)\n\
    \        }", "        val sums = mutable.ArrayBuffer.empty[Long]\n        var\
    \ min = math.Long.MinValue // to initialize min to largest long possible\n\n \
    \       // find smallest sums\n        for { i <- nums.indices if nums.exists(i\
    \ => i < 0) } { // don't add negative numbers\n            sums ++= nums.take(i\
    \ + 1) // copy over non-negative values\n            sum += nums.sum // add up\
    \ remaining values\n        }\n\n        // remove negative numbers from sums\
    \ and keep track of the smallest sum\n        for (i <- nums.indices if nums.exists(i\
    \ => i >= 0)) { // don't add positive numbers\n            val newSum = sums.sum\n\
    \            if (newSum < min)\n                min = newSum\n            sums\
    \ -= nums.take(i + 1) // remove numbers\n        }\n\n        min", "      def\
    \ sumOfSubList(nums : List[Long], minSum : Long = 0) : Long = {\n        if(nums.isEmpty)\n\
    \          minSum\n        else {\n          val first = nums.head\n         \
    \ val rest = nums.tail\n          val newMin = first.toLong + sumOfSubList(rest,\
    \ minSum)\n          if(newMin < minSum)\n            sumOfSubList(rest, newMin)\n\
    \          else\n            sumOfSubList(rest)\n        }\n      }\n      sumOfSubList(nums.sorted).asInstanceOf[Long]",
  "        var minSum = 0L\n        var i = 0\n        while (i < nums.size && nums.head\
    \ < 0L) {\n            minSum = math.min(minSum, nums.head + nums(i++))\n    \
    \    }\n        minSum", "        val set = new mutable.HashSet[Long]()\n    \
    \    val res = Long.MinValue\n        val minSum = Long.MinValue\n\n        for(i\
    \ <- nums.indices) {\n            set.clear()\n            for(j <- 0 until nums.size\
    \ - i) {\n                if (nums(j) < 0) {\n                    if (!set.contains(nums(j)))\
    \ {\n                        val sum = nums(j) + set.toList(0)(0)\n          \
    \              val tmp = minSum\n                        if (tmp > sum) {\n  \
    \                          minSum = sum\n                        }\n         \
    \           }\n                    set.add(nums(j))\n                }\n     \
    \       }\n            res = minSum\n        }\n        minSum", "        def\
    \ getSums(nums : List[Long], arr : List[Int]) : List[Int] = {\n            if\
    \ (nums.isEmpty) arr\n            else {\n                val left = getSums(nums.tail,\
    \ arr :+ nums.head)\n                val right = getSums(nums.tail, arr)\n   \
    \             left.foldLeft(right)( (x, y) => x + y )\n            }\n       \
    \ }\n        getSums(nums, List[Int]())", "        val ls = nums.toList\n    \
    \    val result = new ListBuffer[Long]()\n        var sum = 0\n        var pos\
    \ = 0\n        val mid = ls.length/2\n        while (ls.nonEmpty) {\n        \
    \    sum = ls.head + sum\n            pos = ls.length - 1\n            ls.remove(mid)\n\
    \            while (pos > 0) {\n                ls.insert(pos, ls(pos-1))\n  \
    \              pos -= 1\n            }\n        }\n        result = result :+\
    \ sum\n        result.min", "        val sublists = nums.toList.toSeq.groupBy(i\
    \ => i % nums.size)\n        sublists.foldLeft(0l){\n            case (acc, (key,\
    \ list)) => acc + list.reduceLeft((a, b) => a + b)\n        }", "        val n\
    \ = nums.toList\n        val nums0 = nums.init\n        val nums1 = nums.tail.init\n\
    \        // Find min of nums\n        val minNums = nums0.zip(nums1).minBy { case\
    \ (l, r) => math.min(l, r) }\n        // Find max of nums\n        val maxNums\
    \ = nums0.zip(nums1).maxBy { case (l, r) => math.max(l, r) }\n        // Check\
    \ if n is sublist of minNums\n        if (n.isSubList(minNums.toList)) {\n   \
    \         // If not, then add minNums to maxNums\n            // and check if\
    \ n is sublist of maxNums\n            val maxNums1 = maxNums.zip(nums1).maxBy\
    \ { case (l, r) => math.max(l, r) }\n            if (n.isSubList(maxNums1.toList))\
    \ {\n                maxNums.zip(nums1).maxBy { case (l, r) => math.max(l, r)\
    \ }\n            }\n        }\n        else {\n            0l\n        }", " \
    \       val sums = mutable.HashMap()\n\n        for (n<-nums.reverse) {\n    \
    \        sums(n) match {\n                case None => sums += ((0L+n) -> 1L)\n\
    \                case Some(x) => sums += ((0L+n) -> x+1)\n            }\n    \
    \    }\n\n        sums.minBy(_._2)._2", "        val minSum = math.Long.MinValue\n\
    \        for(i <- 0 until nums.size) {\n            val currentMinSum = nums(i)\
    \ + minSum\n            if (currentMinSum > nums.size)\n                return\
    \ currentMinSum\n            else\n                minSum = currentMinSum\n  \
    \      }\n        return minSum", "        val sortedNums = nums.sortWith(_ <\
    \ _) // Sort ascending\n        val minSum = sortedNums(0)\n        var i = 0\n\
    \        while (i < sortedNums.length - 1) {\n            val curSum = sortedNums(i)\
    \ + sortedNums(i + 1)\n            if (curSum < minSum) {\n                minSum\
    \ = curSum\n            }\n            i += 2\n        }\n        minSum", " \
    \       val (lower, upper) = nums.splitAt(nums.length / 2)\n        val sum =\
    \ lower reduceLeft (_ + _)\n        val sum2 = upper reduceLeft (_ + _)\n    \
    \    sum.min(sum2)", "        val subSums = mutable.ArrayBuffer[Long]()\n    \
    \    for (num <- nums) {\n            if (subSums.isEmpty) subSums += num\n  \
    \          else {\n                val lastSum = subSums.last\n              \
    \  if (lastSum > num) subSums += num\n                else subSums.remove(lastSum)\n\
    \            }\n        }\n        subSums.reduceLeft(_ + _)", "        if (nums.isEmpty)\
    \ 0L\n        else {\n            val n = nums.head\n            val l = 1L\n\
    \            var sum = 0L\n            for (i <- 1 until nums.size) {\n      \
    \          sum+=(nums(i)-l)\n                l = sum\n            }\n        \
    \    if (sum < n) sum+n else sum\n        }", "        def minSubArraySumRecursive(index\
    \ : Int, accum : Long) : Long = {\n            if (index >= nums.size) {\n   \
    \             return accum\n            } else {\n                val minSum =\
    \ math.min(minSubArraySumRecursive(index + 1, accum + nums(index)))\n        \
    \        minSum\n            }\n        }\n        minSubArraySumRecursive(0,\
    \ 0l)", "        var min = Long.MinValue\n        var max = Long.MaxValue\n  \
    \      var currentSum = 0\n        for( i <- nums.indices ){\n            currentSum\
    \ += nums(i)\n            if( currentSum < min ){\n                min = currentSum\n\
    \            }\n            if( currentSum > max ){\n                max = currentSum\n\
    \            }\n        }\n        min", "        val m = scala.math.min(nums.size)\n\
    \        val m = scala.math.min(nums.size, m)\n        val s = scala.math.min(nums.size,\
    \ m)\n        val minSum = scala.math.min(nums.size, m)\n        val minSum =\
    \ scala.math.min(nums.size, s)\n        val minSum = scala.math.min(nums.size,\
    \ minSum)\n        val minSum = scala.math.min(nums.size, minSum)\n        scala.math.min(nums.size,\
    \ minSum)", "        // Create a list with the largest sum\n        // And a list\
    \ with the smallest sum\n        // And add them both to minSum and maxSum\n \
    \       val maxSum = nums.foldLeft(0l)((acc, x) => acc + (if (acc > x) x else\
    \ acc))\n        val minSum = nums.foldLeft(0l)((acc, x) => acc + (if (acc < x)\
    \ x else acc))\n        val sums= nums.foldLeft(0l)((acc, x) => acc + (if (acc\
    \ < x) x else acc))\n\n        // Find the difference between the largest sum\
    \ and the smallest sum\n        val diff = maxSum - minSum\n\n        // Calculate\
    \ the new difference by subtracting the sums\n        diff - sums", "        val\
    \ sum = nums.foldLeft[Long](Long.MinValue){(sum, i) => sum + i}\n        val diff\
    \ = nums.diff(sum)\n        if(diff == List()) {\n            sum\n        } else\
    \ {\n            val minSum = minSubArraySum(diff)\n            sum - minSum\n\
    \        }", "        val maxSize : Long = nums.size\n        val maxSum : Long\
    \ = nums.reduceLeft((x,y) => x + y)\n        val minSum : Long = maxSum\n    \
    \    val minSize : Long = 1\n        var minSumIndex : Int = 0\n        // loop\
    \ through in reverse\n        var lastIndex = maxSize\n        while (lastIndex\
    \ > 0) {\n            // find all indices where this sum is larger than our current\n\
    \            // minimum\n            var sumIndex = 0\n            var sumOfThisIndex\
    \ = 0\n            var lastSum : Long = maxSum\n            var sumOfThisSum :\
    \ Long = maxSum\n            for (i <- 0 until lastIndex) {\n                val\
    \ currentSum = nums(i)\n                val currentSubSum = lastSum - currentSum\n\
    \                val nextSum = nums(i + 1)\n                val nextSubSum = lastSum\
    \ - nextSum\n                if (nextSubSum > currentSubSum) {\n             \
    \       sumOfThisSum = nextSubSum\n                }\n                sumOfThisIndex\
    \ = i\n                lastSum = nextSum\n            }\n            if (sumOfThisSum\
    \ < minSum) {\n                minSum = sumOfThisSum\n                minSumIndex\
    \ = sumOfThisIndex\n                minSize = lastIndex\n            }\n     \
    \       lastIndex -= 1\n        }\n        return minSum", "        val array1\
    \ = new Array[Long](nums.size)\n        var result = 0L\n        for (i <- 0 until\
    \ nums.size) {\n            val tempSum = nums(i) - array1(i)\n            val\
    \ oldSum = array1(i)\n            array1(i) = tempSum\n            result += tempSum\n\
    \            while (array1(i) > 0) {\n                val k = tempSum + array1(i)\
    \ - 1\n                if (k < array1(i)) {\n                    array1(i) = k\n\
    \                    result += k\n                }\n            }\n        }\n\
    \        result", "        val len = nums.length\n        var sum : Long = nums(0)\n\
    \        var index = 0\n        while (index < len) {\n            val curr =\
    \ nums(index)\n            sum += curr\n            index += 1\n            if\
    \ (index < len) {\n                sum += nums(index)\n            }\n       \
    \ }\n        minSubArraySumSum(sum)", "        var result = nums.reduceLeft((x,\
    \ y) => x + y)\n        var minSum = nums.reduceLeft((x, y) => if (x > y) x else\
    \ y)\n\n        nums.takeWhile(x => x < nums.reduceLeft((x, y) => x + y)).foreach\
    \ { x =>\n            minSum = minSum - nums.reduceLeft((x, y) => x + y)\n   \
    \         result = result + minSum\n        }\n        return result", "     \
    \   // The list must be non-empty\n        if(nums.isEmpty) {\n            return\
    \ 0\n        }\n        // Sort the list\n        nums.sortWith((x, y) => x.compareTo(y))\n\
    \        // The minimum sum of the first k elements, where k is the length of\
    \ the\n        // list, is computed using binary search to determine the k+1 element\n\
    \        // to consider in each recursive step.\n        def binarySearch(nums:\
    \ List[Long], minSum: Long, index: Int): Int = {\n            // The minimum sum\
    \ is found when index == nums.length - 1, otherwise the minimum\n            //\
    \ sum is found when index > nums.length - 1\n            if(index < nums.length)\
    \ {\n                // The sum of the current element must be at least minSum\n\
    \                if(nums(index) >= minSum) {\n                    // The sum is\
    \ found if the sum of the next element is at least the minimum sum\n         \
    \           if(binarySearch(nums, minSum, index + 1)) {\n                    \
    \    index\n                    } else {\n                        binarySearch(nums,\
    \ minSum, index - 1)\n                    }\n                } else {\n      \
    \              // The sum is found if the sum of the next element is greater than\
    \ the minimum sum\n                    binarySearch(nums, minSum, index - 1)\n\
    \                }\n            } else {\n                // The sum is found\
    \ when the index is 0\n                index\n            }\n        }\n     \
    \   // The minimum sum is computed from the sorted list\n        val minSum =\
    \ nums.sum\n        // The index of the minimum sum is computed from the binary\
    \ search of the sorted list\n        val index = binarySearch(nums, minSum, nums.length)\n\
    \        // Return the sum of the first k elements as the minimum sum\n      \
    \  minSum - nums(index)"]
stop_tokens:
- "\n    }\n"
