name: HumanEval_161_solve
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a string s.\n    // if s[i] is a letter, reverse its case\
  \ from lower to upper or vise versa, \n    // otherwise keep it as it is.\n    //\
  \ If the string contains no letters, reverse the string.\n    // The function should\
  \ return the resulted string.\n    // Examples\n    // >>> solve((\"1234\"))\n \
  \   // (\"4321\")\n    // >>> solve((\"ab\"))\n    // (\"AB\")\n    // >>> solve((\"\
  #a@C\"))\n    // (\"#A@c\")\n    def solve(s : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(solve((\"AsDf\")).equals((\"\
  aSdF\")));\n    assert(solve((\"1234\")).equals((\"4321\")));\n    assert(solve((\"\
  ab\")).equals((\"AB\")));\n    assert(solve((\"#a@C\")).equals((\"#A@c\")));\n \
  \   assert(solve((\"#AsdfW^45\")).equals((\"#aSDFw^45\")));\n    assert(solve((\"\
  #6@2\")).equals((\"2@6#\")));\n    assert(solve((\"#$a^D\")).equals((\"#$A^d\")));\n\
  \    assert(solve((\"#ccc\")).equals((\"#CCC\")));\n    }\n\n}\n"
completions: ["        def reverse(s1 : String) : String = {\n            val index\
    \ = 0\n            val end = s1.length\n            while(index<end){\n      \
    \          if(s1.charAt(index) != 'a'){\n                    val temp = s1.charAt(index)\n\
    \                    s1.charAt(index) = s1.charAt(end)\n                    s1.charAt(end)\
    \ = temp\n                    end = end-1\n                }else{\n          \
    \          index = index+1\n                }\n            }\n            s1\n\
    \        }\n        val charArray = s.toCharArray\n        val index = charArray.indexOf(0)\n\
    \        val reverseString = reverse(s.substring(1,index))\n        if(charArray.indexOf(0)!=-1){\n\
    \            s = s.substring(1,s.length-1)\n            reverseString = reverse(s.substring(1,index))\n\
    \        }\n        s = reverseString\n        return s.mkString.reverse", " \
    \       def rev(s: String): String = {\n            for (i <- 0 until s.length\
    \ - 1) {\n                if(s.charAt(i) == s.charAt(i).toLowerCase) {\n     \
    \               s = s.replace(s.charAt(i).toLowerCase, s.charAt(i).toUpperCase)\n\
    \                } else if (s.charAt(i) == s.charAt(i).toLowerCase) {\n      \
    \              s = s.replace(s.charAt(i).toLowerCase(), s.charAt(i).toUpperCase)\n\
    \                }\n            }\n            return s\n        }\n\n       \
    \ def addChar(s: String) : String = {\n            def reverse(s: String) : String\
    \ = {\n                val sb = new StringBuilder\n                for(i <- 0\
    \ until s.length - 1) {\n                    if(s.charAt(i) == s.charAt(i).toLowerCase)\
    \ {\n                        sb append (s.charAt(i).toLowerCase)\n           \
    \         } else {\n                        sb append (s.charAt(i).toUpperCase)\n\
    \                    }\n                }\n                sb.toString\n     \
    \       }\n\n            val sb = new StringBuilder\n            val n = s.length\n\
    \            for (i <- 0 until n) {\n                val c = s.charAt(i)\n   \
    \             if (c == '#') {\n                    sb append (\" \")\n       \
    \         } else if (c == '@') {\n                    sb append (reverse(sb.toString))\n\
    \                } else {\n                    sb append (c)\n               \
    \ }\n            }\n            sb.toString\n        }\n\n        def addCharRev(s:\
    \ String) : String = {\n            def reverse(s: String) : String = {\n    \
    \            val sb = new StringBuilder\n                for(i <- 0 until s.length\
    \ - 1) {\n                    if(s.charAt(i) == s.charAt(i).toLowerCase) {\n \
    \                       sb append (s.charAt(i).toUpperCase)\n                \
    \    } else {\n                        sb append (s.charAt(i).toLowerCase)\n \
    \                   }\n                }\n                sb.toString\n      \
    \      }\n\n            val sb = new StringBuilder\n            val n = s.length\n\
    \            for (i <- 0 until n) {\n                val c = s.charAt(i)\n   \
    \             if (c == '#') {\n                    sb append (\" \")\n       \
    \         } else if (c == '@') {\n                    sb append (reverse(sb.toString))\n\
    \                } else {\n                    sb append (c)\n               \
    \ }\n            }\n            sb.toString\n        }\n\n        val str = s.replaceAll(\"\
    [^a-zA-Z]\", \"\")\n        if (str.isEmpty) s\n        else addChar(addCharRev(addCharRev(addCharRev(rev(str)))))",
  "        val result = if (s.isEmpty) s else {\n            for (i <- 0 until s.length)\n\
    \                if (s.charAt(i).toLowerCase == s.charAt(i).toUpperCase || \n\
    \                    s.charAt(i).toUpperCase == s.charAt(i).toLowerCase) \n  \
    \                  s.replaceCharAt(i, '_').toUpperCase\n                else \n\
    \                    s.replaceCharAt(i, '_').toLowerCase\n        }\n        result",
  "        val list = s.toLowerCase\n        val result = new mutable.StringBuilder\n\
    \        for (i <- list.toCharArray.indices) {\n            if (i > 0) {\n   \
    \             if (Character.isLetter(list(i))) {\n                    val firstLetter\
    \ = list.substring(0, i)\n                    val lastLetter = list.substring(i\
    \ + 1, list.size)\n                    result.append(lastLetter).append(firstLetter.toUpperCase)\n\
    \                } else {\n                    result.append(list.substring(0,\
    \ i))\n                }\n            } else {\n                result.append(list.substring(0,\
    \ i))\n            }\n        }\n        result.toString", "        var s = StringBuilder(s)\n\
    \        for( i <- 0 until s.length )\n        {\n            if( isLetter( s.charAt(i)\
    \ ) )\n            {\n                s.reverse()\n                s = s.substring(0,\
    \ s.length - 1) + s.charAt(i)\n            }\n        }\n        if( s.length\
    \ == 0 ) return s\n        else return s.reverse().toString()", "        var res\
    \ = \"\"\n        var flag = false\n        for(i <- 0 until s.length()){\n  \
    \          flag = false\n            if(s.charAt(i)!='A' && s.charAt(i)!='a' &&\
    \ s.charAt(i)!='B' && s.charAt(i)!='b' && s.charAt(i)!='C' && s.charAt(i)!='c'){\n\
    \                res = res + s.charAt(i)\n                flag = true\n      \
    \      }else{\n                i = i+1\n            }\n        }\n        for(i\
    \ <- 0 until s.length()){\n            if(s.charAt(i)!='A' && s.charAt(i)!='a'\
    \ && s.charAt(i)!='B' && s.charAt(i)!='b' && s.charAt(i)!='C' && s.charAt(i)!='c'){\n\
    \                res = res + s.charAt(i)\n            }\n        }\n        if(!flag){\n\
    \            res = s.reverse\n        }\n        res", "        var i = 0\n  \
    \      var j = 0\n        var temp = \"\"\n        val len = s.length\n      \
    \  while(i < len){\n            if(s.charAt(i) == s.charAt(j)){\n            \
    \    temp = s.charAt(i)\n                s.charAt(i) = s.charAt(j)\n         \
    \       s.charAt(j) = temp\n                i += 1 \n                j += 1 \n\
    \            }\n            else{\n                temp = s.charAt(i)\n      \
    \          s.charAt(i) = s.charAt(j)\n                s.charAt(j) = temp\n   \
    \             i += 1\n                j++\n            }\n        }\n        s ",
  "        val input = s.toCharArray\n        val output = input.toList\n        val\
    \ reversed = input.toList.reverse\n        if (input.length == 0) {\n        \
    \    s\"$s\"\n        } else {\n            val hasLetter = input.exists(_ >=\
    \ 'a' && _ <= 'z')\n            if (hasLetter) {\n                output.map(_\
    \ + input(0).toChar)\n            } else {\n                val res = output.map(_\
    \ + input(0).toChar).mkString\n                output.clear\n                output.reverse\n\
    \                output.map(_ + input(0) +: res) mkString \n            }\n  \
    \      }", "        val c = s.toCharArray\n        var i = 0\n        val res\
    \ = c.reverse\n        var rev = res\n        val n = c.length\n        while\
    \ (i < n) {\n            val t = s(i, res)\n            if (t >= 65 && t <= 90)\
    \ {\n                rev = rev + t.toChar\n            } else if (t >= 97 && t\
    \ <= 122) {\n                rev = rev + t.toChar.swapCase\n            } else\
    \ {\n                rev = rev + t\n            }\n            i = i + 1\n   \
    \     }\n        rev", "        val arr = s.toList\n        val newArr : List[Char]\
    \ = arr.map(c => if(c.isLetter) c.toUpper else c.toLower).toList\n        val\
    \ firstChar = newArr.head\n        val restOfChars = newArr.tail\n        if(firstChar.isLetter)\
    \ solveHelper(restOfChars, firstChar)\n        else solveHelper(restOfChars.reverse,\
    \ firstChar)", "        val ret = new mutable.ArrayBuffer[Char]()\n        s.toCharArray.foreach(c\
    \ => {\n            if( c.isLetter ) ret.append(c.toUpperCase)\n            else\
    \ ret.append(c)\n        })\n        return ret.toString", "        var ans :\
    \ List[Char] = Nil\n        var i = 0\n        while (i < s.length) {\n      \
    \      if (isLetter(s(i))) {\n                val c = s(i)\n                var\
    \ j = i\n                while (j < s.length && isLetter(s(j))) {\n          \
    \          j -= 1\n                }\n                ans = ans ::: List(c)\n\
    \                i += 1\n                j = i\n                while (j < s.length\
    \ && isLetter(s(j))) {\n                    j -= 1\n                }\n      \
    \          ans = ans ::: List(s(i))\n                i += 2\n            } else\
    \ {\n                ans = ans ::: List(s(i))\n                i += 1\n      \
    \      }\n        }\n        ans.reverse", "        var s = s\n        val len\
    \ = s.length\n        var i = 0\n        while (i < len) {\n            if (isLetter(s.charAt(i)))\
    \ {\n                s = s.substring(0, i) + s.substring(i, i + 1) + s.substring(i\
    \ + 1, len) + s.substring(len)\n                i += 1\n            }\n      \
    \      else {\n                i += 1\n            }\n        }\n        return\
    \ s", "        var result = \"\"\n        for (x <- s) {\n            if (x.isLetter)\
    \ {\n                if (x.toUpperCase() == x) result +=  x.toUpperCase() else\
    \ result += x.toLowerCase()\n            } else {\n                result += x\n\
    \            }\n        }\n        return result", "        val reversed = reverseStringWithCase(s,\
    \ s.length)\n        if(s.length != reversed.length)\n            reversed\n \
    \       else\n            s", "        val result = s.foldLeft(\"\"){(s,x) =>\
    \ \n            if(x == \"a\") (s.reverse+x.toUpperCase) else (s.reverse+x)\n\
    \        }\n        \n        if(result.isEmpty) \"\" else result", "        var\
    \ res = \"\"\n        var i = 0\n        while (i<s.length()) {\n            val\
    \ c = s(i)\n            if(c>='a' && c<='z')\n                res = res + c.toUpperCase\n\
    \            if(c>='A' && c<='Z')\n                res = res + c.toLowerCase\n\
    \            i = i + 1\n        }\n        if(res.isEmpty)\n            res =\
    \ s\n        res", "        var reverseString = \"\"\n        var count = 1\n\
    \        for(i <- s.length) if(s.charAt(i) != '#') count = count + 1\n       \
    \ if(count == 0) return s\n        for(i <- 0 to s.length - count) if(s.charAt(i)\
    \ == '#') {\n            val l = s.substring(0, i)\n            val r = s.substring(i\
    \ + 1)\n            reverseString = reverseString + new String(l) + new String(r).toUpperCase\n\
    \        }\n        for(i <- 0 to s.length - count) if(s.charAt(i) == '@') {\n\
    \            val l = s.substring(0, i)\n            val r = s.substring(i + 1)\n\
    \            reverseString = reverseString + new String(l) + new String(r).toLowerCase\n\
    \        }\n        return reverseString", "        val result: mutable.MutableList[String]\
    \ = mutable.MutableList();\n        for(char <- s.toCharArray) if(char.isLetter)\
    \ result.append(char.toUpper) else result.append(char.toLower);\n        if (result.length\
    \ == 0) s.reverse else result", "        // write your code in Scala 2.12\n  \
    \      s.toList\n            .filter(_.isLetter)\n            .map(_.toLowerCase)\n\
    \            .map(_.toUpperCase)\n            .map(_.toString)\n            .mkString",
  "        var result : String = \"\"\n        for( i <- 0 until s.length ) {\n  \
    \          if( isLetter(s(i)) ) {\n                val temp = s(i)\n         \
    \       s(i) = s(s.length - i - 1)\n                s(s.length - i - 1) = temp\n\
    \            }\n        }\n        for( i <- 0 until s.length ) {\n          \
    \  if( !isLetter(s(i)) ) {\n                val temp = s(i)\n                s(i)\
    \ = s(s.length - i - 1)\n                s(s.length - i - 1) = temp\n        \
    \    }\n        }\n        result", "        def recur(s : String) : (String,\
    \ String) = {\n            val result = if (s.isEmpty) \"\" else s.charAt(0)\n\
    \            val rest = s.substring(1)\n            if (rest.forall(_.isLetter))\
    \ (recur(rest), (rest + result.swapCase()))\n            else (rest, result)\n\
    \        }\n        recur(s)._2", "        def reverseString(s : String) : String\
    \ = {\n            var res = \"\"\n            for (i <- 0 until s.length) res\
    \ += (if (Character.isLetter(s.charAt(i))) s.charAt(i).toUpperCase else s.charAt(i).toLowerCase)\n\
    \            return res\n        }\n        val str = s.toCharArray.toList\n \
    \       val str1 = s.toCharArray.toList\n        val str2 = s.toCharArray.toList\n\
    \        for (i <- 0 until str.length-1) {\n            val c = str.charAt(i)\n\
    \            val c1 = str1.get(i)\n            val c2 = str2.get(i)\n        \
    \    if (c == 'a' && (c1 == 'A' || c1 == 'a')) str1.set(i, (c2 == 'A' || c2 ==\
    \ 'a')?'a':'A')\n            if (c == 'A' && (c1 == 'a' || c1 == 'A')) str2.set(i,\
    \ (c2 == 'a' || c2 == 'A')?'a':'A')\n            if (c == '#' && (c1 == '@' ||\
    \ c1 == '#')) str1.set(i, (c2 == '@' || c2 == '#')?'@':'#')\n            if (c\
    \ == '@' && (c1 == '#' || c1 == '@')) str2.set(i, (c2 == '#' || c2 == '@')?'@':'#')\n\
    \        }\n        reverseString(new String(str1.toArray))", "        def isLetter(ch:\
    \ Char) : Boolean = ('A' <= ch && ch <= 'Z') || ('a' <= ch && ch <= 'z') || ('0'\
    \ <= ch && ch <= '9')\n        def isLetter(ch: Char) : Boolean = ('A' <= ch &&\
    \ ch <= 'Z') || ('a' <= ch && ch <= 'z')\n        def isDigit(ch: Char) : Boolean\
    \ = ('0' <= ch && ch <= '9')\n        def reverseString(str: String) : String\
    \ = str.reverse\n        def reverseString(str: Int) : String = str.toString\n\
    \        def reverseString(str: Long) : String = str.toString\n        def reverseString(str:\
    \ Boolean) : String = str.toString\n        def reverseString(str: Char) : String\
    \ = str.toString\n        def reverseString(str: StringBuffer) : String = str.toString\n\
    \        def reverseString(str: StringBuilder) : String = str.toString\n     \
    \   def reverseString(str: Array[Char]): String = str.toString\n        def reverseString(str:\
    \ Array[String]): String = str.toString\n        def reverseString(str: Array[Byte]):\
    \ String = str.toString\n        val buf = new StringBuffer\n        for (char\
    \ <- s) {\n            if (isDigit(char)) {\n                buf.append(char)\n\
    \            } else {\n                if (isLetter(char)) {\n               \
    \     buf.append(reverseString(char))\n                } else {\n            \
    \        buf.append(char)\n                }\n            }\n        }\n     \
    \   buf", "        var newS = s\n        for(i <- 0 until s.length){\n       \
    \     if(s.contains(Char(i))){\n                newS = newS.replaceFirst(s.substring(i,\
    \ s.length), s.substring(i, s.length).reverse)\n            }\n            else{\n\
    \                newS = newS.replaceFirst(s, s.substring(i, s.length))\n     \
    \       }\n        }\n        newS", "        val map = mutable.Map[Char,Char]()\n\
    \        for(i <- 0 until s.length){\n            map(i) match {\n           \
    \     case c if ('A' <= c && c <= 'Z') => map(i) = c.toUpper\n               \
    \ case c if ('a' <= c && c <= 'z') => map(i) = c.toLower\n                case\
    \ _ => map(i) = s(i)\n            }\n        }\n        new String(map.toSeq)",
  "        val len = s.length\n        val res = new Array[Char](len)\n        var\
    \ i = 0\n        for(i <- 0 until len) {\n            val ch = s.charAt(i)\n \
    \           if(isLetter(ch))\n                res.update(i, isLetter(ch) ? ch.toUpperCase()\
    \ : ch.toLowerCase)\n            else\n                res(i) = ch\n        }\n\
    \        return new String(res)", "        val r : ListBuffer[String] = ListBuffer()\n\
    \        for (i <- 0 until s.length()) {\n            val c = s.charAt(i)\n  \
    \          if (c.isLetter) {\n                c match {\n                    case\
    \ \"a\" => \"A\"\n                    case \"b\" => \"b\"\n                  \
    \  case \"c\" => \"C\"\n                    case \"d\" => \"D\"\n            \
    \        case \"e\" => \"e\"\n                    case \"f\" => \"F\"\n      \
    \              case \"g\" => \"g\"\n                    case \"h\" => \"H\"\n\
    \                    case \"i\" => \"I\"\n                    case \"j\" => \"\
    J\"\n                    case \"k\" => \"K\"\n                    case \"l\" =>\
    \ \"L\"\n                    case \"m\" => \"M\"\n                    case \"\
    n\" => \"N\"\n                    case \"o\" => \"o\"\n                    case\
    \ \"p\" => \"p\"\n                    case \"q\" => \"Q\"\n                  \
    \  case \"r\" => \"r\"\n                    case \"s\" => \"s\"\n            \
    \        case \"t\" => \"T\"\n                    case \"u\" => \"U\"\n      \
    \              case \"v\" => \"V\"\n                    case \"w\" => \"W\"\n\
    \                    case \"x\" => \"x\"\n                    case \"y\" => \"\
    Y\"\n                    case \"z\" => \"Z\"\n                    case \"A\" =>\
    \ \"a\"\n                    case \"B\" => \"b\"\n                    case \"\
    C\" => \"c\"\n                    case \"D\" => \"d\"\n                    case\
    \ \"E\" => \"e\"\n                    case \"F\" => \"f\"\n                  \
    \  case \"G\" => \"g\"\n                    case \"H\" => \"h\"\n            \
    \        case \"I\" => \"i\"\n                    case \"J\" => \"j\"\n      \
    \              case \"K\" => \"k\"\n                    case \"L\" => \"l\"\n\
    \                    case \"M\" => \"m\"\n                    case \"N\" => \"\
    n\"\n                    case \"O\" => \"o\"\n                    case \"P\" =>\
    \ \"p\"\n                    case \"Q\" => \"q\"\n                    case \"\
    R\" => \"r\"\n                    case \"S\" => \"s\"\n                    case\
    \ \"T\" => \"t\"\n                    case \"U\" => \"u\"\n                  \
    \  case \"V\" => \"v\"\n                    case \"W\" => \"w\"\n            \
    \        case \"X\" => \"x\"\n                    case \"Y\" => \"y\"\n      \
    \              case \"Z\" => \"z\"\n                    case _ => r.append(c.toUpperCase)\n\
    \                }\n            } else r.append(c)\n        }\n        r.toString.reverse",
  "        var result : MutableList[String] = MutableList.empty\n        for( i <-\
    \ 0 until s.length ){\n            val letter = s.charAt(i)\n            if( letter\
    \ >= 'a' && letter <= 'z' ){\n                result :+ letter.toString.reverse\n\
    \            } else if( letter >= 'A' && letter <= 'Z' ){\n                result\
    \ :+ letter.toString.toLowerCase\n            } else {\n                result\
    \ :+ letter\n            }\n        }\n        result :+ \"\".reverse", "    \
    \    val nums = s.toList.toString.toInt\n        var res = \"\"\n        var first\
    \ = true\n        for (i <- 0 until nums.length) {\n            if (nums(i) >\
    \ 0) {\n                val next = nums(i).toString.toInt\n                if\
    \ (next > 0) {\n                    if (first) {\n                        first\
    \ = false\n                        res += nums(i).toString.toUpper\n         \
    \           } else {\n                        res += nums(i).toString.toUpper\n\
    \                    }\n                } else {\n                    res += nums(i).toString.toLower\n\
    \                }\n            } else if (nums(i) == 0) {\n                val\
    \ next = nums(i).toString.toInt\n                if (next > 0) {\n           \
    \         res += nums(i).toString.toUpper\n                } else {\n        \
    \            res += nums(i).toString.toLower\n                }\n            }\n\
    \        }\n        if (nums.isEmpty) {\n            return s.reverse\n      \
    \  } else {\n            return res\n        }", "        var reversed = \"\"\n\
    \        for ((i, c) <- s.zipWithIndex) {\n            val letter = c match {\n\
    \                case 'a' => 'A'\n                case 'b' => 'B'\n          \
    \      case 'c' => 'C'\n                case 'd' => 'D'\n                case\
    \ 'e' => 'E'\n                case 'f' => 'F'\n                case 'g' => 'G'\n\
    \                case 'h' => 'H'\n                case 'i' => 'I'\n          \
    \      case 'j' => 'J'\n                case 'k' => 'K'\n                case\
    \ 'l' => 'L'\n                case 'm' => 'M'\n                case 'n' => 'N'\n\
    \                case 'o' => 'O'\n                case 'p' => 'P'\n          \
    \      case 'q' => 'Q'\n                case 'r' => 'R'\n                case\
    \ 's' => 'S'\n                case 't' => 'T'\n                case 'u' => 'U'\n\
    \                case 'v' => 'V'\n                case 'w' => 'W'\n          \
    \      case 'x' => 'X'\n                case 'y' => 'Y'\n                case\
    \ 'z' => 'Z'\n                case 'A' => 'a'\n                case 'B' => 'b'\n\
    \                case 'C' => 'c'\n                case 'D' => 'd'\n          \
    \      case 'E' => 'e'\n                case 'F' => 'f'\n                case\
    \ 'G' => 'g'\n                case 'H' => 'h'\n                case 'I' => 'i'\n\
    \                case 'J' => 'j'\n                case 'K' => 'k'\n          \
    \      case 'L' => 'l'\n                case 'M' => 'm'\n                case\
    \ 'N' => 'n'\n                case 'O' => 'o'\n                case 'P' => 'p'\n\
    \                case 'Q' => 'q'\n                case 'R' => 'r'\n          \
    \      case 'S' => 's';\n                case 'T' => 't'\n                case\
    \ 'U' => 'u'\n                case 'V' => 'v'\n                case 'W' => 'w'\n\
    \                case 'X' => 'x'\n                case 'Y' => 'y'\n          \
    \      case 'Z' => 'z'\n                case '_' => 'A'\n                case\
    \ '-' => 'B'\n                case '+' => 'C'\n                case '.' => 'D'\n\
    \                case '/' => 'E'\n                case '%' => 'F'\n          \
    \      case '$' => 'G'\n                case '#' => 'H'\n                case\
    \ '&' => 'I'\n                case '@' => 'J'\n                case '$' => 'K'\n\
    \                case '%' => 'L'\n                case '^' => 'M'\n          \
    \      case '&' => 'N'\n                case '*' => 'O'\n                case\
    \ '(' => 'P'\n                case ')' => 'Q'\n                case '[' => 'R'\n\
    \                case ']' => 'S'\n                case '|' => 'T'\n          \
    \      case '-' => 'U'\n                case '+' => 'V'\n                case\
    \ '.' => 'W'\n                case '/' => 'X'\n                case '?' => 'Y'\n\
    \                case '!' => 'Z'\n                case _ => c\n            }\n\
    \            val toAdd = if (letter.isLetter) letter else c.toUpperCase\n    \
    \        val letterIndex = s.indexOf(c, i)\n            if (", "        val s1\
    \ =\n            s match {\n                case x if x.matches(\"[a-z]+\") =>\
    \ x.toUpperCase()\n                case x if x.matches(\"[A-Z]+\") => x.toLowerCase()\n\
    \                case x => x\n            }\n        val s2 =\n            if\
    \ (s1 == s) s1 else (\n                s1.replaceAllIn(\n                    s,\n\
    \                    s => if (s.contains(Character.toLowerCase(s.charAt(0))))\
    \ s.toUpperCase() else s.toLowerCase()\n                )\n            )\n   \
    \     s2", "        val res = new StringBuilder\n        for (i <- 0 until s.length){\n\
    \            val letter = s.charAt(i)\n            res.append(if(letter == letter.toUpperCase)\
    \ letter.toUpperCase\n                    else letter.toLowerCase)\n        }\n\
    \        if(res.isEmpty) res.reverse\n        else res.reverse", "        val\
    \ chars = s.toList.toSet.toList.map(_.toString.toChar).toSet\n        val r =\
    \ s.reverse\n        if (chars.isEmpty) r\n        else r.map(x=>(x==='A'||x==='a'?x.toUpperCase():x).toChar).mkString",
  "        var str = s.toUpperCase\n\n        if (s.isEmpty) {\n            str =\
    \ \"#\"\n        } else if (s.head == s.tail) {\n            str = s.toUpperCase\n\
    \        } else {\n            var lst : mutable.LinkedHashSet[Char] = mutable.LinkedHashSet()\n\
    \            for (i <- 0 until str.length) {\n                if (str.charAt(i)\
    \ == str.charAt(i).toLowerCase) {\n                    lst.add(str.charAt(i).toLowerCase)\n\
    \                }\n            }\n            str = str.reverse\n           \
    \ str = str.toLowerCase.mkString(\"\") +\n                str.split(\"\").map(lst.remove(_)).mkString(\"\
    \")\n        }\n        return str", "        val charMap = new mutable.HashMap[Character,\
    \ String]()\n        val reString = new mutable.StringBuilder(s.reverse)\n   \
    \     for(c <- s) {\n            if(charMap.contains(c)) {\n                charMap.get(c)\
    \ = charMap.get(c) + c.toUpperCase\n                charMap.remove(c)\n      \
    \      }\n            else if(c.isLetter) {\n                charMap.get(c) =\
    \ c.toUpperCase\n            }\n            else {\n                charMap.get(c)\
    \ = c\n            }\n        }\n        charMap.map(s => reString.append(s) +\
    \ \"\\n\")", "        if(!s.contains(\"\")){\n            return s\n        }else{\n\
    \            var r = \"\"\n            var v = \"\"\n            var f = s.length()\n\
    \            for(i<-0 until f){\n                if(s.charAt(i)>='A' && s.charAt(i)<='Z'){\n\
    \                    v = s.charAt(i).toUpperCase + v\n                }else{\n\
    \                    v = s.charAt(i).toLowerCase + v\n                }\n    \
    \        }\n            r = v\n            return r\n        }", "        if (s.length()\
    \ == 0) {\n            return \"\"\n        } else {\n            var newString\
    \ = \"\"\n            var isLetter = false\n            for (i <- 0 until s.length())\
    \ {\n                val c = s.charAt(i)\n                if (Character.isLetter(c))\
    \ {\n                    isLetter = true\n                } else {\n         \
    \           if (!isLetter) {\n                        newString += c\n       \
    \             } else {\n                        newString += c.toUpperCase()\n\
    \                    }\n                }\n            }\n            newString\n\
    \        }", "        var reversed = \"\"\n        for (i <- 0 until s.length)\
    \ reversed = reversed.concat(s.charAt(i).toLowerCase + s.charAt(i).toUpperCase\
    \ )\n        if (reversed.length != s.length) return reversed\n        reversed.toUpperCase",
  "       var res = \"\"\n       for ( i <- 0 until s.length ) {\n         if ( Character.isLetter(s.charAt(i))\
    \ ) {\n           val c = s.charAt(i).toLower\n           val u = s.charAt(i).toUpper\n\
    \           if ( c != u ) {\n              res =  res +  c\n           } else\
    \ {\n              res =  res +  u\n           }\n         } else {\n        \
    \   res =  res +  s.charAt(i)\n         }\n       }\n       res", "       s.foldLeft(\"\
    \")(\n          (acc, x) => {\n            x match {\n                case a if\
    \ a.isLetter => acc + (x.toUpper + x.toLowerCase)\n                case a => acc\
    \ + x\n            }\n          }\n       )", "        val chars = s.length\n\
    \        val output = mutable.ArrayBuffer.empty[String]\n        for(i <- 0 until\
    \ chars) {\n            val ch = s.charAt(i)\n            if(ch == ch) {\n   \
    \             output += s.substring(i)\n            }\n        }\n        output.toString.reverse",
  "        var result = \"\"\n        for (i <- 0 until s.length)\n        result\
    \ += (if (s.toUpperCase(s.charAt(i))) s.toUpperCase(s.charAt(i)) else s.toLowerCase(s.charAt(i)))\
    \ + \"\"\n        result", "        val result = new StringBuilder(s.length)\n\
    \        for (i <- s.indices) {\n            val t = s.charAt(i)\n           \
    \ if (t >= 'a' && t <= 'z') {\n                result.append((t - 'a').toUpper)\n\
    \            } else if (t >= 'A' && t <= 'Z') {\n                result.append((t\
    \ - 'A').toUpper)\n            } else {\n                result.append(t)\n  \
    \          }\n        }\n        result.toString", "        var res = \"\"\n \
    \       var temp = \"\"\n        for (i <- 0 until s.length){\n            if\
    \ ( isLetter(s.charAt(i)) ){\n                temp = s.charAt(i)\n           \
    \     res = temp.toUpperCase\n            }\n            else{\n             \
    \   res = temp + s.charAt(i)\n            }\n        }\n        return res", " \
    \       if (s.isEmpty) {\n            s\n        } else {\n            val res\
    \ = new Array[String](s.length)\n            val sL = s.toLower\n            val\
    \ sU = s.toUpperCase\n            val sF = s.filterNot(_.isLetter)\n         \
    \   val sA = s.filter(_.isLetter)\n            var i = 0\n            for (x <-\
    \ sF) {\n                if (i == res.length) {\n                    res(i) =\
    \ x.toUpperCase\n                    i += 1\n                    res(i) = x.toLowerCase\n\
    \                    i += 1\n                } else {\n                    res(i)\
    \ = x.toUpperCase\n                    i += 1\n                }\n           \
    \ }\n            for (x <- sA) {\n                if (i == res.length) {\n   \
    \                 res(i) = x.toLowerCase\n                    i += 1\n       \
    \         } else {\n                    res(i) = x.toLowerCase\n             \
    \       i += 1\n                }\n            }\n            for (x <- sU) {\n\
    \                if (i == res.length) {\n                    res(i) = x.toUpperCase\n\
    \                    i += 1\n                } else {\n                    res(i)\
    \ = x.toUpperCase\n                    i += 1\n                }\n           \
    \ }\n            for (x <- sL) {\n                if (i == res.length) {\n   \
    \                 res(i) = x.toLowerCase\n                    i += 1\n       \
    \         } else {\n                    res(i) = x.toLowerCase\n             \
    \       i += 1\n                }\n            }\n            res\n        }",
  "        if (s.isEmpty) {\n            s\n        } else {\n            val rev\
    \ = if (s.head.isLetter) s.toUpper else s.toLower\n            var rev2: String\
    \ = \"\"\n            var index = 0\n            var isRev2 = false\n        \
    \    var isRev = false\n            val c = charArrayOf(s.head)\n            for\
    \ (i <- 0 until c.length) {\n                if (s.subSequence(index, i + 1).forall(_.isLetter))\
    \ {\n                    isRev = true\n                    rev2 = rev2 + c.charAt(i)\
    \ + s.subSequence(index, i + 1).mkString(\"\")\n                } else {\n   \
    \                 isRev2 = true\n                    rev2 = rev2 + c.charAt(i)\
    \ + s.subSequence(index, i + 1).mkString(\"\")\n                }\n          \
    \      index = i + 1\n            }\n            if (isRev && isRev2) {\n    \
    \            rev\n            } else if (isRev) {\n                rev\n     \
    \       } else {\n                rev2\n            }\n        }", "        var\
    \ newstr = \"\"\n        for ( i <- 0 until s.length ) {\n            val c =\
    \ s(i)\n            if ( c.isLetter) {\n                newstr = newstr + c.toUpperCase\n\
    \            }\n            else {\n                newstr = newstr + c\n    \
    \        }\n        }\n        return newstr", "        val array = s.toCharArray\n\
    \        val s = array\n        var i = 0\n        while (i < s.length) { \n \
    \           val x = s(i)\n            if (x >='a' && x <='z' || x >='A' && x <='Z')\
    \ {\n                val y = x.toUpperCase\n                s(i) = y\n       \
    \     }\n            else {\n                s(i) = x\n            }\n       \
    \     i += 1\n        }\n        new String(s)", "        var new_s = s\n    \
    \    for( i <- 1 to s.length ) {\n            if( s.charAt(i).isLetter) {\n  \
    \              if( s.charAt(i) == s.charAt(i).toLower ) {\n                  \
    \  new_s = new_s.replace( s.charAt(i), s.charAt(i).toUpper )\n               \
    \ }else {\n                    new_s = new_s.replace( s.charAt(i), s.charAt(i).toLower\
    \ )\n                }\n            }\n        }\n        if( new_s.length ==\
    \ 0 ) {\n            return s\n        }else {\n            return new_s\n   \
    \     }", "        var res = \"\"\n        for(i <- s.length){\n            if(isLetter(s.charAt(i))){\n\
    \                if(s.charAt(i).isUpper){\n                    res += s.charAt(i).toLowerCase\n\
    \                }else{\n                    res += s.charAt(i).toUpperCase\n\
    \                }\n            }else{\n                res += s.charAt(i)\n \
    \           }\n        }\n        res", "        def isLetter(char : Char) : Boolean\
    \ = {\n            char.equals('a') || char.equals('b') || char.equals('c') ||\
    \ char.equals('d')\n        }\n\n        var result: String = \"\"\n        for\
    \ (i <- 0 until s.length) {\n            if (isLetter(s.charAt(i))) {\n      \
    \          result += s.charAt(i).toLowerCase + s.charAt(i).toUpperCase\n     \
    \       } else {\n                result += s.charAt(i)\n            }\n     \
    \   }\n        return result", "        val letters = mutable.LinkedHashSet[Char]()\n\
    \        var i = 0\n        for (c <- s) {\n            if (Character.isLetter(c))\
    \ {\n                letters += c\n            } else {\n                letters\
    \ += Char(c.toUpperCase)\n            }\n        }\n        val result = s.reverse\n\
    \        letters.foreach { c => result = result.swap(0, c.length) }\n        return\
    \ result", "        val arr = s.toCharArray()\n        var resultStr = \"\"\n\
    \        var pos = 0\n        while (pos < arr.length) {\n            val c =\
    \ arr(pos)\n            if (c.isLetter) {\n                resultStr += c.toUpper\n\
    \                resultStr += c.toLower\n            } else {\n              \
    \  resultStr += c\n            }\n            pos += 1\n        }\n        resultStr.reverse",
  "        val sb = new StringBuilder(s)\n        for(i <- 0 until s.length)\n   \
    \         if(i == 0 || Character.isLetter(s.charAt(i-1)))\n            {\n   \
    \             sb.setCharAt(i, s.charAt(i-1).toLower)\n            }\n        \
    \    else\n            {\n                sb.setCharAt(i, s.charAt(i-1).toUpper)\n\
    \            }\n        sb.reverse", "        def reverse(str: String, i: Int):\
    \ String = {\n            if (i >= str.length) str\n            else reverse(str.substring(0,i+1),\
    \ i) + str.substring(i+1, str.length) + reverse(str.substring(i+1, str.length),\
    \ i+1)\n        }\n        val resultSet = mutable.LinkedHashSet[String]()\n \
    \       val reversedString = reverse(s, 0)\n        def checkAndAdd(str: String,\
    \ i: Int) {\n            if (i >= str.length) return\n            if (!resultSet.contains(str))\
    \ {\n                resultSet += str\n                checkAndAdd(reversedString,\
    \ i+1)\n            }\n        }\n        checkAndAdd(reversedString, 0)\n   \
    \     resultSet.mkString.reverse", "        val chars = s.toList.toSet\n     \
    \   chars.foldLeft(\"\")( (acc, c) => {\n            val reversed = if (c.isUpper)\
    \ c.toLower else c.toUpperCase\n            acc + (if (acc.isEmpty) \"\" else\
    \ \",\") + reversed\n        }).dropRight(1) ++ chars.head.toLower", "       \
    \ val strArray = s.toList\n        val reversedArray = strArray.reverse\n    \
    \    if (strArray.isEmpty) reversedArray\n        else {\n            val lettersCounts\
    \ = strArray.map(letter => letter -> 1).groupBy(_._1).mapValues(_.size).withDefault(0)\
    \ {_ + _}\n            val strArrayInverted = strArray.map(letter => lettersCounts(letter)\
    \ - lettersCounts(letter.toUpperCase)).reverse.map(i => letter -> i)\n       \
    \     reversedArray.filter(_._1 == 0).getOrElse(reversedArray.toList.flatMap(item\
    \ => lettersCounts(item._1) / lettersCounts(item._1.toUpperCase).roundToInt)).reverse\n\
    \        }", "        var s = \"\"\n        var i = 0\n        var k = 0\n   \
    \     var charCount = 0\n        for (i <- 0 until s.length)\n        {\n    \
    \        k = i\n            while(k != 0)\n            {\n                char\
    \ = s.charAt(k - 1)\n                if (char.matches(\"[a-zA-Z]+\"))\n      \
    \          {\n                    charCount += 1\n                    k = k -\
    \ 1\n                }\n                else\n                {\n            \
    \        charCount = 0\n                    k = k - 1\n                }\n   \
    \         }\n            if (charCount == 0)\n            {\n                k\
    \ = i\n                while(k != 0)\n                {\n                    char\
    \ = s.charAt(k - 1)\n                    charCount += 1\n                    k\
    \ = k - 1\n                }\n            }\n            if (charCount > 0)\n\
    \            {\n                k = i\n                while(k != 0)\n       \
    \         {\n                    char = s.charAt(k - 1)\n                    if\
    \ (char.matches(\"[a-zA-Z]+\"))\n                    {\n                     \
    \   charCount -= 1\n                        k = k + 1\n                    }\n\
    \                    else\n                    {\n                        charCount\
    \ = 0\n                        k = k - 1\n                    }\n            \
    \    }\n            }\n            s = s.substring(0,i) + s.substring(i+1, s.length)\
    \ + s.substring(0,k)\n        }\n        return s", "        if(s.length == 0)\
    \ return s\n        var l = 0\n        var r = 0\n        var count = 0\n    \
    \    val lower = mutable.HashMap[Char,Char]()\n        val upper = mutable.HashMap[Char,Char]()\n\
    \        for(i <- 0 until s.length)\n        {\n            if(i < s.length)\n\
    \            {\n                val c = s(i)\n                if(c in lower)\n\
    \                    lower(c) = i\n                else\n                    upper(c)\
    \ = i\n            }\n            else\n            {\n                if(count\
    \ == 0)\n                {\n                    r = i - 1\n                  \
    \  l = i\n                }\n                else if(count < s.length)\n     \
    \           {\n                    val c = s(count)\n                    if(c\
    \ in upper)\n                    {\n                        lower(c) = l\n   \
    \                     upper(c) = r\n                        count += 1\n     \
    \               }\n                    else\n                    {\n         \
    \               lower(c) = l\n                        upper(c) = r\n         \
    \               count += 1\n                    }\n                }\n       \
    \     }\n        }\n        if(count(upper) > 0)\n            for(c <- upper)\n\
    \                lower(c) = count\n        if(count(lower) > 0)\n            for(c\
    \ <- lower)\n                upper(c) = count\n        val result = mutable.ArrayBuffer(\"\
    \")\n        var i = 0\n        while(i < s.length)\n        {\n            val\
    \ c = s(i)\n            if(!(c in lower) && !(c in upper))\n                result\
    \ += c\n            i += 1\n        }\n        return result.toString", "    \
    \    val mapString = mutable.LinkedHashMap[Char, String]()\n        val arrayString\
    \ = s.toCharArray.map(x => (x, \"\")).toArray\n        for(i <- 0 to arrayString.size\
    \ - 1) {\n            val currentChar = arrayString(i)\n            mapString.put(currentChar,\
    \ \"\")\n        }\n        val finalString = \"\"\n        for(i <- 0 to arrayString.size\
    \ - 1) {\n            val currentChar = arrayString(i)\n            val currentStringValue:\
    \ String = mapString(currentChar)\n            if(currentStringValue != \"\")\
    \ {\n                if(currentStringValue.length >= arrayString.size) {\n   \
    \                 currentStringValue ++= arrayString(arrayString.size - 1)\n \
    \               }\n                mapString.put(currentChar, currentStringValue)\n\
    \                mapString.putIfAbsent(currentChar, currentStringValue)\n    \
    \        }\n        }\n        for(i <- 0 to mapString.size - 1) {\n         \
    \   val currentChar = arrayString(i)\n            val currentStringValue: String\
    \ = mapString(currentChar)\n            if(currentStringValue != \"\") {\n   \
    \             finalString += mapString(currentChar)\n                mapString.remove(currentChar)\n\
    \            }\n        }\n        finalString", "        val result = s.reversed\n\
    \        val isLetter = result.forall(_.isLetter)\n        if (isLetter) {\n \
    \           result.reverse\n        } else {\n            result\n        }",
  "        val ret = new StringBuilder\n        val letter = s.toCharArray\n     \
    \   val len = s.length\n        if (len > 0) {\n            val letterMap = Map(('a'\
    \ to 'z'), ('A' to 'Z'))\n            var index = 0\n            while (index\
    \ < len) {\n                val c = letter(index)\n                index += 1\n\
    \                if (letterMap.contains(c)) {\n                    ret.append(letterMap(c))\n\
    \                } else {\n                    ret.append(c)\n               \
    \ }\n            }\n        }\n        return ret.toString", "        var newString\
    \ : String = s.reverse\n        var isInLowerCase = true\n        var index =\
    \ 0\n        while (index < s.length) {\n            val char = s.charAt(index)\n\
    \            if (char >= 'a' && char <= 'z') {\n                if (!isInLowerCase)\
    \ {\n                    val newChar = char.toUpperCase\n                    newString\
    \ = newString.substring(0, newString.length - 1) + newChar\n                 \
    \   index = index + 1\n                    isInLowerCase = true\n            \
    \    }\n                else {\n                    val newChar = char.toLowerCase\n\
    \                    newString = newString.substring(0, newString.length - 1)\
    \ + newChar\n                    index = index + 1\n                    isInLowerCase\
    \ = false\n                }\n            }\n            else {\n            \
    \    newString = newString + char\n                index = index + 1\n       \
    \     }\n        }\n        newString", "        val resultArray = s.map {\n \
    \           char =>\n                if (char >= 'a' && char <= 'z')\n       \
    \             char.toUpperCase\n                else if (char >= 'A' && char <=\
    \ 'Z')\n                    char.toLowerCase\n                else\n         \
    \           char\n        }\n        val result = resultArray.toString.reverse\n\
    \        result != \"\" ? result : s.reverse", "        var index = 0\n      \
    \  var resultString : String = \"\"\n\n        for (c <- s) {\n            if\
    \ (c.isLetter) {\n                if (index != 0) {\n                    resultString\
    \ += c.toUpperCase\n                    index = 0\n                } else {\n\
    \                    resultString += c.toLowerCase\n                }\n      \
    \      } else {\n                index += 1\n            }\n        }\n\n    \
    \    if (index > 0) {\n            resultString += s.substring(index).reverse\n\
    \        }\n\n        return resultString", "        if (s.isEmpty) s\n      \
    \  val m = s.toLower\n        val n = m.countLetters\n        if (n == 0) s.reverse\n\
    \        else if (n == 1) s(0).toUpper + s(1)\n        else {\n            val\
    \ t = m span (_.isLetter)\n            val c = t.length\n            val b = t\
    \ map (_.toLowerCase)\n            val b = b.sortWith ((x, y) => x.compareTo(y))\n\
    \            val l = b.length /2 + 1\n            val x = b.take(l).mkString\n\
    \            val y = b.drop(l).mkString\n            val z = x ++ \"@\" + y\n\
    \            z\n        }", "        val a = mutable.ArrayBuffer(0)\n        var\
    \ r = \"\"\n        for(i<- 0 until s.length)\n            {\n               \
    \ if(s.charAt(i).toUpperCase == 'A')\n                    r = r.substring(1) +\
    \ s.charAt(i)\n                else\n                    a = a.cons(s.charAt(i)\
    \ + s.charAt(i).toLowerCase)\n            }\n        r = r ++ a.reverse\n    \
    \    return r", "      var result = \"\"\n      var i = 0\n      while (i < s.length\
    \ && charAt.apply(s,i) != ' ') {\n        result += charAt.apply(s,i)\n      \
    \  i += 1\n      }\n      \n      if (i == s.length) {\n        result += charAt.apply(s,0)\n\
    \      } else {\n        val j = s.length-1\n        while (i >= 0 && charAt.apply(s,i)\
    \ != ' ') {\n          result += charAt.apply(s,i)\n          i -= 1\n       \
    \ }\n        if (i < 0) {\n          result += charAt.apply(s,i)\n        }\n\
    \      }\n      result", "        val chars = s.toCharArray.map(c => if (isLetter(c.toString))\
    \ c.toUpperCase else c.toLowerCase).toArray\n        val newChars = chars.filter(c\
    \ => isLetter(c.toString)).map(c => if (isLetter(c)) c.toUpperCase else c.toLowerCase)\n\
    \        val reversed = newChars.reverse\n        if (chars.isEmpty) reversed\n\
    \        else reversed.mkString", "        val res = new StringBuilder(s.length)\n\
    \        for((i, _) <- s.zipWithIndex) { \n            val c = s.charAt(i)\n \
    \           if(c.isLetter) res.append(c.toUpperCase)\n            else res.append(c)\n\
    \        }\n        if(s.length == 0) res.reverse\n        else res", "      \
    \  val arr = s.toList\n        val reverse = arr.reverse\n        if(arr.forall(_.isLetter))\n\
    \        {\n            var newStr = \"\"\n            for(i <- 0 until arr.length)\n\
    \            {\n                if(!arr(i).isLetter)\n                {\n    \
    \                arr(i) = arr(i).swapCase\n                }\n               \
    \ else\n                {\n                    arr(i) = arr(i).toUpper\n     \
    \           }\n            }\n            for(i <- 0 until arr.length)\n     \
    \       {\n                if(arr(i).isLetter && !arr(i).equals(\"\"))\n     \
    \           {\n                    newStr += arr(i).swapCase\n               \
    \ }\n                else\n                {\n                    newStr += arr(i)\n\
    \                }\n            }\n            return newStr\n        }\n    \
    \    else\n        {\n            return reverse\n        }", "        s.toUpperCase()\
    \ match {\n            case \"\" => s\n            case s => s.head + s.tail\n\
    \        }", "        var result : String = \"\"\n        for (i<- 0 until s.length){\n\
    \            if (s(i).toLower.toUpper == s(i)){\n                result = s.substring(0,i)\
    \ + s.substring(i+1)\n                break\n            }\n            else{\n\
    \                result = result + s(i)\n            }\n        }\n        return\
    \ result", "        var res = s\n        var count = s.size\n        var i = 0\n\
    \        var j = 0\n        while(i < count){\n            if(s.charAt(i) == '\
    \ '){\n                i += 1\n                if(i < count){\n              \
    \      if(s.charAt(i) == ' '){\n                        i += 1\n             \
    \           if(i < count){\n                            if(s.charAt(i) == ' '){\n\
    \                                i += 1\n                                if(i\
    \ < count){\n                                    if(s.charAt(i) == ' '){\n   \
    \                                     i += 1\n                               \
    \         if(i < count){\n                                            if(s.charAt(i)\
    \ == ' '){\n                                                i += 1\n         \
    \                                   }\n                                      \
    \  }\n                                    }\n                                }\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n        while(i < count){\n\
    \            if(s.charAt(i) == ' '){\n                i += 1\n               \
    \ if(i < count){\n                    if(s.charAt(i) == ' '){\n              \
    \          i += 1\n                        if(i < count){\n                  \
    \          if(s.charAt(i) == ' '){\n                                i += 1\n \
    \                               if(i < count){\n                             \
    \       if(s.charAt(i) == ' '){\n                                        i +=\
    \ 1\n                                    }\n                                }\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n        while(i < count){\n\
    \            if(s.charAt(i) == ' '){\n                i += 1\n               \
    \ if(i < count){\n                    if(s.charAt(i) == ' '){\n              \
    \          i += 1\n                        if(i < count){\n                  \
    \          if(s.charAt(i) == ' '){\n                                i += 1\n \
    \                               if(i < count){\n                             \
    \       if(s.charAt(i) == ' '){\n                                        i +=\
    \ 1\n                                    }\n                                }\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n        while(i < count){\n\
    \            if(s.charAt(i) == ' '){\n                i += 1\n               \
    \ if(i < count){\n                    if(s.charAt(i) == ' '){\n              \
    \          i += 1\n                        if(i < count){\n                  \
    \          if(s.charAt(i) == ' '){\n                                i += 1\n \
    \                               if(i < count){\n                             \
    \       if(s.charAt(i) == ' '){\n                                        i +=\
    \ 1\n                                    }\n                                }\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n        while(i < count){\n\
    \            if(s.charAt(i) == ' '){\n                i += 1\n               \
    \ if(i < count){\n                    if(s.charAt(i) == ' '){\n              \
    \          i += 1\n                        if(i < count){\n                  \
    \          if(s.charAt(i) == ' '){\n                                i += 1\n \
    \                               if(i < count){\n                             \
    \       if(s.charAt(i) == ' '){\n                                        i +=\
    \ 1\n                                    }\n                                }\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n        while(i < count){\n\
    \            if(s.charAt(i) == ' '){\n                i += 1\n               \
    \ if(i < count){\n                    if(s.charAt(i) == ' '){\n              \
    \          i += 1", "        var newString : String = \"\"\n        var i = 0\n\
    \        for (i <- 0 until s.length()) {\n            if (isLetter(s.charAt(i)))\
    \ {\n                newString += s.charAt(i).toLower\n            }\n       \
    \     else {\n                newString += s.charAt(i)\n            }\n      \
    \  }\n        newString += s.substring(0, i)\n        newString.reverse", "  \
    \      var newString :String = \"\"\n        val letters = mutable.HashSet[Char]()\n\
    \        for (i <- 0 until s.length()) {\n            val c = s(i)\n         \
    \   if (letters.contains(c)) {\n                newString += (newString.toUpperCase)\n\
    \            } else {\n                newString += (newString.toLowerCase)\n\
    \            }\n            letters.add(c)\n        }\n        newString", " \
    \       val counts = mutable.HashMap[(Int, Int), Int]()\n        for (c <- s.toCharArray)\
    \ {\n            counts.getOrElse((c, 1), 0)\n            counts.update((c + ('a'\
    \ -'A'), counts.getOrElse((c, 1), 0) + 1), (c + ('a' -'A'), 1))\n        }\n \
    \       val list = for ((key, val) <- counts) yield (val -> key)\n        list.sortWith(_._1\
    \ > _._1).flatMap(x => x._2.toCharArray).mkString", "      val s = s(0)\n    \
    \  val s = s.toLowerCase + s.toUpperCase + s.toCharArray\n      if(s.toCharArray.length\
    \ == 0) {\n        return s.reverse\n      }\n      var i = 0\n      for(i <-\
    \ 0 until s.length - 1) {\n        if(s(i).isLetter) {\n          if(s(i + 1)\
    \ != s(i)) {\n            s(i + 1) = s(i)\n          }\n        }\n      }\n \
    \     return s.reverse", "        var newS = s\n        for {\n            i <-\
    \ 0 to newS.length - 1\n            c <- newS.charAt(i)\n            l <- 1 to\
    \ c.toString.length - 1\n            if (c.toString.toUpperCase() == c.toString.charAt(l))\
    \ {\n                newS = newS.replaceAll(c, c.toString.charAt(l).toUpperCase)\n\
    \            }\n            else if (!(c.toString.toUpperCase() == c.toString.charAt(l)))\
    \ {\n                newS = newS.replaceAll(c, c.toString.charAt(l).toLowerCase)\n\
    \            }\n        } yield newS", "        val result = new StringBuilder\n\
    \        for (c <- s)\n            c match {\n                case x@(\"\\\\\"\
    )  => result.append((x map {_.toUpperCase})(0))\n                case x@(\"`\"\
    )   => result.append((x map {_.toLowerCase})(0))\n                case x     \
    \    => result.append(x)\n            }\n        result.reverse", "        val\
    \ result = s.foldLeft(\"\") { (result, c) =>\n            if (c >= 'a' && c <=\
    \ 'z') {\n                result + c.toUpperCase()\n            } else (result\
    \ + c.toLowerCase())\n        }\n        if (!result.isEmpty) result.reverse\n\
    \        else s", "        val str = s.toLowerCase\n        val result = str.filter(\
    \ c => c.isLetter || c.isDigit)\n            .foldLeft(\"\")( (acc, c) =>\n  \
    \              if ( acc.isEmpty) {\n                    acc\n                }\
    \ else {\n                    if (acc.last.isDigit) {\n                      \
    \  if (acc.last.isUpper) {\n                            acc + c.toUpper\n    \
    \                    } else {\n                            acc + c.toLower\n \
    \                       }\n                    } else {\n                    \
    \    if (acc.last.isUpper) {\n                            acc + c.toUpper\n  \
    \                      } else {\n                            acc + c.toLower\n\
    \                        }\n                    }\n                }\n       \
    \     )\n        return result", "        var result = \"\"\n        var flag\
    \ = true\n        for(i <- s.indices) {\n            if(s[i].toLowerCase == s[i].toUpperCase)\n\
    \            {\n                if(s.substring(i).contains(s[i].toUpperCase) ==\
    \ false)\n                    result += s.substring(0,i) + s[i].toUpperCase\n\
    \                else\n                    result += s.substring(0,i) + s[i].toLowerCase\n\
    \                flag = true\n                i += 1 \n            }\n       \
    \     else\n            {\n                if(result == \"\")\n              \
    \      result += s.substring(0,i)\n                else\n                    result\
    \ += s.substring(0,i)\n                \n                result += s[i].toLowerCase\n\
    \                flag = false\n                i += 1\n            }\n       \
    \     \n        }\n        \n        \n        if(result == \"\")\n          \
    \  return s\n        else\n            return result", "        val lowerCaseChars\
    \ = s.toCharArray.toList.flatMap(c => if (isLetter(c)) c.toLower else c)\n   \
    \     val upperCaseChars = s.toCharArray.toList.flatMap(c => if (isLetter(c))\
    \ c.toUpper else c)\n        val emptyChars = s.toCharArray.toList.filter(c =>\
    \ !isLetter(c))\n        val emptyCharsChars = s.toCharArray.toList.filterNot(c\
    \ => isLetter(c))\n        val emptyCharsCharsChars = s.toCharArray.toList.filterNot(c\
    \ => isLetter(c) && c.toLower == c.toUpper)\n        val emptyCharsCharsCharsChars\
    \ = s.toCharArray.toList.filterNot(c => isLetter(c) && c.toUpper == c.toLower)\n\
    \        val charsToBeReversed = if (emptyChars.isEmpty) emptyCharsChars else\
    \ upperCaseChars\n        charsToBeReversed.foldLeft(\"\") {\n            case\
    \ (acc, c) => acc + (if (isLetter(c)) c else c.toUpper)\n        }", "      val\
    \ (n, rest) = s.length, s.drop(n).reverse\n      if (rest == \"\") s\n      else\
    \ solve(rest) + s.take(n) + s.take(rest.length).map(x => (x.toUpperCase).reverse)",
  "        var res = \"\"\n        for (i <- 0 until s.length) { \n            if(s.charAt(i).toLower.toUpper\
    \ == s.charAt(i)) {\n                s = s.substring(0, i) + s.substring(i + 1,\
    \ s.length)\n                res.reverse\n            }\n            else {\n\
    \                s += s.charAt(i).toLower\n            }\n        }\n        s",
  "        var str = \"\"\n        var newStr = \"\"\n        for (i <- 0 to s.length\
    \ - 1) {\n            str += s(i)\n            if (isLetter(s(i))) {\n       \
    \         newStr += s(i).swapCase()\n            } else {\n                newStr\
    \ += s(i)\n            }\n        }\n        if (str == \"\") {\n            newStr\
    \ += s\n        }\n        newStr", "        var newString = \"\"\n        for\
    \ (i <- 0 until s.length)\n            if (s.charAt(i) != '#' && s.charAt(i) !=\
    \ '@' && s.charAt(i) != '.')\n                newString += s.charAt(i).toUpper\n\
    \            else\n                newString += s.charAt(i)\n        newString",
  "        var result = \"\"\n        for (c <- s) {\n            if (c.toLower.isLetter)\
    \ {\n                c = c.toUpperCase\n            } else {\n               \
    \ c = c.toLowerCase\n            }\n        }\n        for (c <- s) {\n      \
    \      if (c.toUpper.isLetter) {\n                c += c.toUpper\n           \
    \ } else {\n                c += c.toLower\n            }\n        }\n       \
    \ result", "        val res = s.map(x => x.toUpperCase()).map(x => x.toLowerCase())\n\
    \        res.foldLeft(\"abc\") {\n            (t, x) => if (t.length < x.length)\
    \ x else t.charAt(t.length - x.length) + x\n        }", "        val sb = new\
    \ mutable.StringBuilder\n        for (i <- 0 until s.length) \n            if\
    \ (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') \n                sb.append((s.charAt(i)\
    \ - 'a' + 26).toChar)\n            else \n                sb.append(s.charAt(i))\n\
    \        sb.reverse", "        var reversedString = \"\"\n        var letterCount\
    \ = 0\n        for (xs <- s) {\n            if (xs.isLetter) {\n             \
    \   letterCount += 1\n                val reversed = xs.toUpperCase(Locale.ROOT)\n\
    \                if (letterCount > 1) {\n                    reversedString +=\
    \ reversed\n                } else {\n                    reversedString += xs\n\
    \                }\n            } else {\n                val reversed = xs.toLowerCase(Locale.ROOT)\n\
    \                reversedString += reversed\n            }\n        }\n      \
    \  return reversedString", "        def reverse1(i : Int, j : Int) : String =\
    \ {\n            if (i < j) \n                if (s(i) == s(j)) s(i)\n       \
    \         else (s(i) + s(j)) \n            else if (i == j) \n               \
    \ s(i)\n            else s(j)\n        }\n        def reverse2(i : Int, j : Int)\
    \ : String = {\n            if (i < j)\n                if (s(i) == s(j))\n  \
    \              {\n                    if (s(i) == s('a')) s(i)\n             \
    \       else s(i) ++ (s(j) - s('a'))\n                }\n                else\
    \ (s(i) + s(j))\n            else if (i == j)\n                if (s(i) == s('a'))\n\
    \                {\n                    if (s(i) == s('a')) s(i)\n           \
    \         else s(i) ++ (s(j) - s('a'))\n                }\n                else\
    \ if (s(i) == s('A')) s(i) ++ s(j) \n                else if (s(i) == s('a'))\
    \ s(i) ++ s(j) \n                else if (s(i) == s('A')) s(i) ++ s(j) \n    \
    \            else (s(i) + s(j))\n            else s(j)\n        }\n        val\
    \ str = s.toUpperCase\n        var result : String = \"\"\n        var i : Int\
    \ = 0\n        var j : Int = str.length - 1\n        while (j < i)\n        {\n\
    \            if (str(i) == str[j])\n            {\n                result = result\
    \ + reverse1(i, j)\n                i = j\n            }\n            else \n\
    \            {\n                result = result + str[j]\n                j =\
    \ i\n            }\n        }\n        if (str.length > i) result = result + reverse2(i,\
    \ j)\n        result", "        val str = s.toUpperCase\n        val revStr =\
    \ new StringBuilder(str)\n        var index = 0\n        while (index < revStr.length)\
    \ {\n            val chr = revStr(index)\n            if (chr.isLetter) revStr.reverse()\n\
    \            else revStr.insert(index, chr.toLowerCase)\n            index +=\
    \ 1\n        }\n        revStr.toString", "        var newString = \"\"\n    \
    \    for(c:String <- s.toCharArray) {\n            if(c == c.toLower) c = c.toUpper\n\
    \            else c = c.toLower\n            newString = newString.concat(c)\n\
    \        }\n        newString", "        val reversed = s.foldLeft(new StringBuilder){\
    \ (builder, char) =>\n            if (char >= 'a' && char <= 'z') {\n        \
    \        builder.append(char.asInstanceOf[String]).append(char.asInstanceOf[String])\n\
    \            } else {\n                builder.append(char)\n            }\n \
    \       }.toString\n        val chars = reversed.asInstanceOf[String].toCharArray\n\
    \        val result = chars.foldLeft(new StringBuilder){ (builder, char) =>\n\
    \            if (char >= 'a' && char <= 'z') {\n                builder.append(char.asInstanceOf[String]).append(char.asInstanceOf[String])\n\
    \            } else {\n                builder.append(char)\n            }\n \
    \       }.toString\n        result", "        val l = s.length\n        val arr\
    \ = new Array[Char](l)\n        for (i<- 0 to l-1){\n            arr(i) = s.charAt(i)\n\
    \        }\n        if(arr.length == 0)\n            return s\n        val len\
    \ = arr.length\n        val s = arr.mkString.toUpperCase\n        val r = new\
    \ StringBuilder(s.length)\n        var i = 0\n        for (i <- 0 to (len-1)){\n\
    \            if(i == 0 && s.charAt(i) == s.charAt(i+1))\n                r(i+1)\
    \ = s.charAt(i)\n            else if(s.charAt(i) == s.charAt(i+1))\n         \
    \       r(i) = s.charAt(i)\n            else\n                r(i) = s.charAt(i)\n\
    \        }\n        return r.reverse", "        def isLetter(s: String): Boolean\
    \ = s.forall(_.isLetter)\n        def isLower(s: String): Boolean = s.forall(_.isLower)\n\
    \        def isUpper(s: String): Boolean = s.forall(_.isUpper)\n        def toUpper(s:\
    \ String): String = s.foldLeft(\"\")(_ + _.toUpperCase)\n        def toLower(s:\
    \ String): String = s.foldLeft(\"\")(_ + _.toLowerCase)\n        def reverseCase(s:\
    \ String): String = {\n            if (isLetter(s)) toUpper(toLower(s)) else s\n\
    \        }\n        if (isLetter(s)) reverseCase(s) else s", "        val map\
    \ = mutable.Map[Char, String]()\n        for (c <- s.toCharArray) \n         \
    \   if (map.contains(c)) {\n                map += (c->map.get(c))\n         \
    \   } else {\n                map += (c->c.toString)\n            }\n        \n\
    \        val keys: Set[Char] = map.keySet.toSet\n        val vals: Set[String]\
    \ = map.values.toSet\n        val keys = keys diff vals.toSet\n\n        val result\
    \ = keys.toIterator.map(c => c -> map.get(c)).toMap\n\n        val result2 = for\
    \ ( (k, v) <- result if v == \"\" ) yield k\n        val reversed = result2.toIterator.map(c\
    \ => c -> map.get(c._1)).toMap\n        val result3 = reversed.toIterator.map(c\
    \ => c._1 -> c._2)\n        \n        val final = result3.toSeq.sortBy(c => -c._1.length).map(c\
    \ => c._1 + \"@\" + c._2)\n        \n        val final2 = final diff result2\n\
    \        final2.toSeq.sortBy(c => -c._2.length).map(c => c._1 + \"@\" + c._2)",
  "        val charMap = new mutable.HashMap[Char, Char]()\n        for (ch <- s.toCharArray)\
    \ {\n            if (!charMap.contains(ch)) {\n                charMap += (ch\
    \ -> ch)\n            } else {\n                charMap += (ch -> charMap(ch))\n\
    \            }\n        }\n        if (charMap.isEmpty) {\n            return\
    \ s\n        }\n        for (ch <- charMap.keySet) {\n            charMap.remove(ch)\n\
    \        }\n        charMap.toList.sortWith((x, y) => x._2 < y._2).map(_._1).mkString.reverse",
  "        val ans = mutable.ListBuffer[String]()\n        for (i <- 0 to s.length\
    \ - 1) {\n            val chr = s.charAt(i)\n            if (isLetter(chr)) {\n\
    \                val ch = chr.toUpperCase\n                val l = chr.toLowerCase\n\
    \                if (isLetter(l)) {\n                    ans append l\n      \
    \          } else {\n                    ans append ch\n                }\n  \
    \          } else {\n                ans append chr\n            }\n        }\n\
    \        if (ans.isEmpty) {\n            s.reverse\n        } else {\n       \
    \     ans\n        }", "      val result = new StringBuilder\n      for (c <-\
    \ s) {\n        if (c >= 'A' && c <= 'Z') {\n          result.append(c.toUpperCase)\n\
    \        } else {\n          result.append(c)\n        }\n      }\n      if (result.toString.isEmpty)\
    \ {\n        result.toString\n      } else {\n        result.reverse\n      }",
  "        val reverses = s.toString.toUpperCase.map(_.toUpperCase).getOrElse(s)\n\
    \        val withoutLetters = reverses.filter(!Char.isLetter)\n        withoutLetters.reverse",
  "        var str = \"\"\n        for (ch <- s) {\n            if (Character.isLetter(ch))\
    \ str = ch + str\n            else str = ch + str.toUpperCase\n        }\n   \
    \     str.reverse", "        val arr = s.toCharArray\n        val result = mutable.Buffer.empty[String]\n\
    \        var i = 1\n        while (i <= arr.length) {\n            if (arr(i).toLowerCase\
    \ != arr(i).toUpperCase && arr(i) != 0) {\n                result += arr(i)\n\
    \            }\n            i += 1\n        }\n        result.toString()", " \
    \       val l = s.length\n        val rs = new StringBuilder\n        var i =\
    \ 0\n        while (i < l) {\n            if (s.charAt(i) >= 65 && s.charAt(i)\
    \ <= 90)\n                rs.append(s.charAt(i)-32) \n            else if (s.charAt(i)\
    \ >= 97 && s.charAt(i) <= 122)\n                rs.append(s.charAt(i)+32) \n \
    \           else\n                rs.append(s.charAt(i))\n            i += 1\n\
    \        }\n        return rs.reverse", "        val strArray = s.toCharArray\n\
    \        strArray.foldLeft(\"\") {\n        case (acc, x) =>\n            if(x.isLetter)\
    \ {\n                acc +: x.toUpperCase\n            } else {\n            \
    \    acc +: x.toLowerCase\n            }\n        }", "        if(s.isEmpty) {\n\
    \            s\n        } else {\n            val temp = s.toUpperCase\n     \
    \       var result : List[String] = Nil\n            for(i <- 0 until temp.length)\
    \ {\n                val s = temp(i)\n                if(s.isLetter) {\n     \
    \               if(temp.indexOf(s) + 1 ==  temp.length)\n                    \
    \    result ::= s\n                    else\n                        result ::=\
    \ s.toUpperCase\n                } else {\n                    result ::= s\n\
    \                }\n            }\n            val res = result.mkString.reverse\n\
    \            res\n        }", "        val input = s.toLowerCase \n        var\
    \ resultStr = \"\"\n        var i = 0;\n        while (i < input.length) {\n \
    \           if (input.charAt(i).toUpperCase != input.charAt(i).toLowerCase) {\n\
    \                val tmp = input.charAt(i)\n                input.charAt(i) =\
    \ input.charAt(i).toLowerCase\n                input.charAt(i).toLowerCase = tmp\n\
    \            }\n            resultStr += input.charAt(i)\n            i += 1\n\
    \        }\n        return resultStr", "        val a = s.toUpperCase\n      \
    \  val b = a.replaceAll(\"[A-Z]\", \"[a-z]\")\n        val c = b.replaceAll(\"\
    [a-z]\", \"[A-Z]\")\n        if (b.isEmpty || c.isEmpty) s \n        else c.toUpperCase",
  "        // write your code here\n        val strList = s.toList\n        strList.foreach\
    \ { x => if(x.isLetter) x.toUpperCase() else x.toLowerCase() }\n        strList.reverse\n\
    \        \n        val result = strList.mkString\n        \n        result ",
  "        var rev = \"\"\n        for (i <- 0 until s.length)\n            if (s.charAt(i)\
    \ == s.charAt(i).toLowerCase())\n                rev = s.charAt(i) + rev\n   \
    \         else\n                rev = s.charAt(i) + rev\n        \n        if(rev.equals(\"\
    aaa\"))\n            rev = \"\"\n        else\n            rev = rev.reverse\n\
    \        \n        return rev", "      var reverse = s\n      val letter = mutable.HashSet[Char]()\n\
    \      def isUpper(letter : Char) : Boolean = {\n        if(letter.contains(letter.toLowerCase))\n\
    \          return false\n        else\n          return true\n      }\n      def\
    \ isLower(letter : Char) : Boolean = {\n        if(letter.contains(letter.toUpperCase))\n\
    \          return false\n        else\n          return true\n      }\n      for(i<-0\
    \ until reverse.length)\n        if(reverse(i).isLetter) \n          if(isUpper(reverse(i)))\
    \ reverse(i) = (reverse(i).toChar.toUpperCase)\n          else if(isLower(reverse(i)))\
    \ reverse(i) = (reverse(i).toChar.toLowerCase)\n          else \n            letter\
    \ += reverse(i).toChar\n      reverse = reverse.mkString\n      for(i<-0 until\
    \ letter.length)\n        if(!letter.contains(reverse(i))) reverse = reverse.reverse\n\
    \      reverse", "        def checkLetter(x:String) : Unit = {\n            if\
    \ (x.toUpper == x)\n                x.toUpper\n            else if (x.toLower\
    \ == x)\n                x.toLower\n            else \n                x \n  \
    \      }\n        var rev = \"\"\n        var x = s.toCharArray().toList;\n  \
    \      var index = x.length\n        while (index > 0) {\n            rev += checkLetter(x(0))\n\
    \            x -= 1\n            index -= 1\n        }\n        rev", "      \
    \  val result = s.toUpperCase\n        val reversed = s.replaceAll(\"[^a-zA-Z]+\"\
    , \"\").reverse\n        if (reversed.isEmpty) result\n        else reversed.replaceAll(\"\
    [A-Za-z]+\", result)", "        if(s.isEmpty || s.forall(c => c.isLetter)) s \n\
    \        else {\n            val list = s.toList.map(_.toLowerCase)\n        \
    \    val reversed = list.reverse\n            val newString = \"\"\n         \
    \   list.foreach(i => { newString += i })\n            newString += reversed.mkString\n\
    \        }", "        val str = \"\"\n        for(i <- 0 until s.length)\n   \
    \         str match {\n                case s if Character.isLetter(s.charAt(i))\
    \ => Character.toUpperCase(s.charAt(i)) :: str\n                case s if Character.isUpperCase(s.charAt(i))\
    \ => Character.toLowerCase(s.charAt(i)) :: str\n                case _ => str\
    \ :+ s\n            }\n        str.reverse", "      def reverse(str: String) :\
    \ String = {\n        if (str.size() <= 1) str\n        else reverse(s.subString(str.lastIndex))\
    \ + str.charAt(0) + reverse(s.subString(0,str.lastIndex))\n      }\n\n      def\
    \ check(str: String, letters: List[Char]) : Boolean = {\n        if (str.size()\
    \ == 0) true else letters.forall(letter => letter == str.charAt(0)) || check(str.substring(1),\
    \ letters)\n      }\n\n      val result = check(s, List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z').toList)\n\
    \      if (result == true) reverse(s.toList)\n      else s", "      def checkChar(s\
    \ : String) : String = {\n        if (s.contains(\"\")) \n          \"\"\n   \
    \     else \n          (s.toCharArray map {_.toUpperCase}) mkString \"\"\n   \
    \   }\n      val arr = s.toCharArray\n      val ls = arr.length\n      val out\
    \ = new mutable.ArrayBuffer[Char]\n      for (i<-ls downto 0 by -1)\n      if\
    \ (arr(i).isLetter) out.append(checkChar(arr(i)))\n      else out.append(arr(i))\n\
    \      out.toString", "        val result = new mutable.StringBuilder\n      \
    \  for ( i <- 0 to s.length - 1) {\n            val letter = s(i)\n          \
    \  if (letter.isUpper) {\n                val upperLetter = s(i).toUpperCase\n\
    \                if (upperLetter != letter)\n                    result.append(upperLetter)\n\
    \            }\n            else\n                result.append(letter)\n    \
    \    }\n        if (result.length == 0)\n            s.reverse\n        else\n\
    \            result.toString", "        val map = mutable.Map[Char,Char]()\n \
    \       s.toList foreach {c => map.putIfAbsent(c.toLowerCase,c.toLowerCase)}\n\
    \        map.toList foreach {c =>\n            val upper = c.toUpperCase\n   \
    \         val lower = c.toLowerCase\n            map.remove(lower)\n         \
    \   map.remove(upper)\n        }\n        s.reverse", "        val str = new StringBuilder\n\
    \        val l = s.length\n        for (i <- 0 until l) {\n            str.append(\n\
    \                if (s.charAt(i).isLetter) {\n                    if (s.charAt(i).toUpperCase\
    \ == s.charAt(i)) {\n                        s.charAt(i).toLowerCase\n       \
    \             } else {\n                        s.charAt(i).toUpperCase\n    \
    \                }\n                } else if (s.charAt(i) == s.charAt(i)) {\n\
    \                    s.charAt(i)\n                } else {\n                 \
    \   s.charAt(i)\n                }\n            )\n        }\n        str.result()",
  "        var res = \"\"\n        for(c <- s) {\n            if(c.isLetter) res +=\
    \ c.toUpper\n            else if(c.isLower && !c.isUpper) res += c.toLower\n \
    \           else res += c\n        }\n        if(res.isEmpty) res \n        else\
    \ res.reverse", "        val l = s.length\n        val arr = new Array[String](l)\n\
    \        for(i <- 0 until l){\n            arr(i) = s(i).toChar\n        }\n \
    \       val r = arr.map(_.toUpperCase).foldLeft(\"\"){(acc, s) => \n         \
    \   val ind = acc.lastIndexOf(s)\n            if(ind != -1){\n               \
    \ acc += acc.substring(ind)\n            }\n            acc += s\n        }\n\
    \        if(r.length == 0){\n            return s\n        } else {\n        \
    \    return r.substring(0,r.length)\n        }", "        val strList = s.toUpperCase().toList\n\
    \        strList.sortWith(a => a.isLetter ? 0 : a.isUppercase ? 1 : -1)\n    \
    \    strList.foldLeft(\"\")( (acc, c) => acc + (if (c.isLetter) c.toUpperCase\
    \ else c.toLowerCase))", "        val result = s.foldLeft(\"\") { (result, c)\
    \ =>\n            if(c.isLetter) c.toUpperCase() : c.toLowerCase()\n         \
    \   else result + c\n        }\n        if(result.isEmpty) \"\" else result.reverse",
  "        var newStr = \"\"\n        var lastChar = scala.util.Try(s.lastChar).getOrElse(\"\
    \")\n        \n        for(i <- 0 until s.length)\n            if(s.charAt(i)\
    \ == lastChar)\n                s = s.substring(0, i) + s.substring(i+1, s.length)\
    \ + s.substring(i, s.length)\n            else newStr += s.charAt(i)\n       \
    \ newStr", "        val result = s.map(x => {\n            if (x.isLetter) {\n\
    \                x.toUpperCase\n            } else {\n                x\n    \
    \        }\n        }).reverse\n        result.filter(_.isLetter).reverse", '        s.filter(_.isLetter).map(_.toUpperCase).mkString',
  "        var chars = s.toCharArray\n        for(i <- chars.indices) {\n        \
    \    if(!chars(i).isLetter) {\n                chars(i) = chars(i).toUpper\n \
    \           } else {\n                chars(i) = chars(i).toLower\n          \
    \  }\n        }\n        new String(chars)", "      val arr = s.toList\n     \
    \ val len = arr.size\n      val count = mutable.HashMap[String, Int]()\n     \
    \ for(i <- 0 until len){\n        val ch = arr(i)\n        if(count.contains(ch)){\n\
    \          count(ch) += 1\n        } else {\n          count(ch) = 1\n       \
    \ }\n      }\n      var newArr : List[Char] = Nil\n      for(i <- 0 until len){\n\
    \        val ch = arr(i)\n        if(count(ch) == 1){\n          newArr ::= ch\n\
    \        } else {\n          newArr ::= ch.toUpper\n        }\n      }\n     \
    \ newArr.mkString", "        val a = s.toUpperCase\n        val b = a.toUpperCase.drop(1)\n\
    \        val l = b.toUpperCase.map(chr => if(chr == '#') chr - '@' else '#')\n\
    \        val d = l.toList.foldLeft(List[Char]())((l,c) => c +: l)\n        (a\
    \ diff b diff d).mkString.toUpperCase", "        if(s.length == 0)\n         \
    \ return s\n        var str = s\n        var chars = Array[Char](s.toCharArray:\
    \ _*)\n        var reversedChars = Array[Char](s.toCharArray: _*)\n\n        var\
    \ i = 0\n        var j = 0\n\n        for(i <- 0 until chars.length) {\n     \
    \       if(chars(i) == chars(i))\n              chars(i) = chars(i).toLower\n\
    \            else chars(i) = chars(i).toUpper\n        }\n\n        for(i <- 0\
    \ until chars.length) {\n            if(chars(i) != chars(i)) // if the char is\
    \ not the same\n              chars(j) = chars(i) \n            else // if it\
    \ is the same\n              chars(j) = chars(i).toLower\n              j = (j\
    \ + 1) % chars.length // change the char and change position\n        }\n\n  \
    \      for(i <- 0 until reversedChars.length)\n          reversedChars(i) = chars(i)\
    \ \n        str = reversedChars.mkString(\"\")\n        return str", "       \
    \ val chars = s.toCharArray\n        var rs = \"\"\n        var i = 0\n      \
    \  while (i < chars.length) {\n            val c = chars(i)\n            if (c\
    \ == c.toLower) {\n                chars(i) = c.toUpper\n            } else {\n\
    \                chars(i) = c.toLower\n            }\n            i += 1\n   \
    \     }\n        for ( i <- 0 until chars.length) rs = rs.toString + chars(i)\n\
    \        rs", "        val arr = s.toCharArray\n        var newS = new StringBuilder(\"\
    \")\n        for ((index, c) <- arr.zipWithIndex) {\n            if (Character.isLetter(c))\
    \ {\n                c match {\n                    case 'a' -> newS.append('A');\n\
    \                    case 'b' -> newS.append('B');\n                    case 'c'\
    \ -> newS.append('C');\n                    case 'd' -> newS.append('D');\n  \
    \                  case 'e' -> newS.append('E');\n                    case 'f'\
    \ -> newS.append('F');\n                    case 'g' -> newS.append('G');\n  \
    \                  case 'h' -> newS.append('H');\n                    case 'i'\
    \ -> newS.append('I');\n                    case 'j' -> newS.append('J');\n  \
    \                  case 'k' -> newS.append('K');\n                    case 'l'\
    \ -> newS.append('L');\n                    case 'm' -> newS.append('M');\n  \
    \                  case 'n' -> newS.append('N');\n                    case 'o'\
    \ -> newS.append('O');\n                    case 'p' -> newS.append('P');\n  \
    \                  case 'q' -> newS.append('Q');\n                    case 'r'\
    \ -> newS.append('R');\n                    case 's' -> newS.append('S');\n  \
    \                  case 't' -> newS.append('T');\n                    case 'u'\
    \ -> newS.append('U');\n                    case 'v' -> newS.append('V');\n  \
    \                  case 'w' -> newS.append('W');\n                    case 'x'\
    \ -> newS.append('X');\n                    case 'y' -> newS.append('Y');\n  \
    \                  case 'z' -> newS.append('Z');\n                    case 'A'\
    \ -> newS.append('a');\n                    case 'B' -> newS.append('b');\n  \
    \                  case 'C' -> newS.append('c');\n                    case 'D'\
    \ -> newS.append('d');\n                    case 'E' -> newS.append('e');\n  \
    \                  case 'F' -> newS.append('f');\n                    case 'G'\
    \ -> newS.append('g');\n                    case 'H' -> newS.append('h');\n  \
    \                  case 'I' -> newS.append('i');\n                    case 'J'\
    \ -> newS.append('j');\n                    case 'K' -> newS.append('k');\n  \
    \                  case 'L' -> newS.append('l');\n                    case 'M'\
    \ -> newS.append('m');\n                    case 'N' -> newS.append('n');\n  \
    \                  case 'O' -> newS.append('o');\n                    case 'P'\
    \ -> newS.append('p');\n                    case 'Q' -> newS.append('q');\n",
  "      val list = s.toList\n      list.map(x => (x.toString.toLowerCase match {\n\
    \        case 'a' => x.toUpperCase\n        case 'b' => x.toLowerCase\n      \
    \  case _ => x\n      }))\n      .filter(x => x != s)\n      .reverse\n      .toString",
  "        val str = s.toUpperCase\n        val len : Int = str.length\n        val\
    \ newStr = new StringBuilder(\"\")\n        var i = 0\n        while ( i < len)\
    \ {\n            val c = str(i).toChar\n            if (c.isLetter) {\n      \
    \          if (c.isUpper) {\n                    newStr += str(i).toUpperCase\n\
    \                } else {\n                    newStr += str(i).toLowerCase\n\
    \                }\n                i += 1\n            } else if (c.isDigit)\
    \ {\n                newStr += c\n                i += 1\n            } else {\n\
    \                newStr += c\n            }\n        }\n        if (newStr.length\
    \ == 0)\n            newStr = str.substring(1)\n        newStr.reverse", "   \
    \     val len = s.length\n        val maxIndex = len - 1 // last character in\
    \ s\n        val mapChar = Map('a' -> 'z', 'A' -> 'Z', '0' -> '9')\n        var\
    \ i = 0\n        while(i < maxIndex) {\n            val char = s(i)\n        \
    \    if(mapChar(char) match {\n                case Some(v) => char += v\n   \
    \             case None => char\n            } != s) {\n                return\
    \ s\n            }\n            i += 1\n        }\n        if(s.isEmpty || s(0)\
    \ == '.') {\n            return s\n        }\n        if(s(0) == '#') {\n    \
    \        var i = 0\n            var j = 0\n            while(i < maxIndex) {\n\
    \                val char = s(i)\n                if(j == i) {\n             \
    \       if(char == '@') {\n                        j = 0\n                   \
    \ } else {\n                        i -= 1\n                        j += 1\n \
    \                   }\n                } else {\n                    val map =\
    \ Map(char.toLowerCase() -> char)\n                    var k = i\n           \
    \         while(k != j) {\n                        map(map(k.toLowerCase())) match\
    \ {\n                            case Some(v) => char += v\n                 \
    \           case None => char\n                        }\n                   \
    \     k += 1\n                    }\n                }\n                i += 1\n\
    \            }\n        }\n        return s", "        if (s.isEmpty) \"\"\n \
    \       else{\n            var sb = scala.collection.mutable.StringBuilder.newBuilder\n\
    \            for (i <- 0 until s.length){\n                sb ++= if(s.charAt(i)\
    \ >= 'a' && s.charAt(i) <= 'z') s.charAt(i).toUpperCase else s.charAt(i).toLowerCase\n\
    \            }\n            sb.toString\n        }", "        val numSet = s.toList.toSet\n\
    \        val numLen = s.size\n        val numList = numSet.filter( _ >= 'a' &&\
    \ _ <= 'z' ).map { (_ - 'a') }\n        val reversed = s.filter( _ >= 'a' && _\
    \ <= 'z' ).map { (_ - 'a') }\n        val numNumSet = numList.filter( _ >= 'a'\
    \ && _ <= 'z' ).map { (_ - 'a') }\n        val reverseNumNumSet = reversed.filter(\
    \ _ >= 'a' && _ <= 'z' ).map { (_ - 'a') }\n        if(numList.size == 0 && numSet\
    \ == numLen) reversed\n        else if(numNumSet.size == 0 && numNumSet == numLen)\
    \ reverseNumNumSet\n        else if(numSet.size == 0 && numNumSet == numLen) numSet\n\
    \        else reverseNumNumSet", "        val map: Map[Character, Char] = Map(a\
    \ -> 'A', b -> 'B', c -> 'C', d -> 'D', e -> 'E', f -> 'F', g -> 'G', h -> 'H',\
    \ i -> 'I', j -> 'J', k -> 'K', l -> 'L', m -> 'M', n -> 'N', o -> 'O', p -> 'P',\
    \ q -> 'Q', r -> 'R', s -> 'S', t -> 'T', u -> 'U', v -> 'V', w -> 'W', x -> 'X',\
    \ y -> 'Y', z -> 'Z')\n        var newString = \"\"\n        for {\n         \
    \   i <- s.indices\n            c <- s.charAt(i)\n            map <- Map(c ->\
    \ c)\n        } yield {\n            if (map.containsKey(c)) {\n             \
    \   newString += map.get(c)\n            } else {\n                newString +=\
    \ c\n            }\n        }\n        newString", "        val arr = s.toCharArray\n\
    \        val res = arr.reverse.map(x => {\n            if (x>=65 && x<=90){\n\
    \                (x+32).toChar\n            }\n            else{\n           \
    \     x\n            }\n        }).mkString\n        res", "        val chars\
    \ = s.toList\n        var result: String = \"\"\n        var i = 0\n        while\
    \ (i < chars.length) {\n            if (chars(i) >= 65 && chars(i) <= 90) {\n\
    \                result += (chars(i) + 32).toChar\n            } else {\n    \
    \            result += chars(i)\n            }\n            i += 1\n        }\n\
    \        result", "        val l = s.length\n        var res: String = \"\"\n\
    \        var index = 0\n        var result = 0\n        for(i <- 0 until l) {\n\
    \            val temp = s(i)\n            if(temp.equalsIgnoreCase(\"a\")) temp\
    \ = s(i + 1)\n            else if(temp.equalsIgnoreCase(\"b\")) temp = s(i + 2)\n\
    \            else if(temp.equalsIgnoreCase(\"c\")) temp = s(i + 3)\n         \
    \   else temp = s(i)\n            if(!temp.equalsIgnoreCase(\"_\")){\n       \
    \         result = Character.toUpperCase(temp.charAt(0)) + Character.toUpperCase(temp.charAt(1))\
    \ + Character.toUpperCase(temp.charAt(2)) + Character.toUpperCase(temp.charAt(3))\n\
    \            }\n            else if(temp.equalsIgnoreCase(\"_\")){\n         \
    \       result = Character.toUpperCase(temp) + Character.toUpperCase(temp) + Character.toUpperCase(temp)\
    \ + Character.toUpperCase(temp)\n            }\n            else {\n         \
    \       result = temp\n            }\n            if(!res.equalsIgnoreCase(result)){\n\
    \                res = result\n                index += l\n            }\n   \
    \     }\n        if(!res.equalsIgnoreCase(res)){\n            res = res\n    \
    \        index += 1\n        }\n        if(!res.equalsIgnoreCase(res)){\n    \
    \        res = res\n            index += 1\n        }\n        if(!res.equalsIgnoreCase(res)){\n\
    \            res = res\n            index += 1\n        }\n        if(!res.equalsIgnoreCase(res)){\n\
    \            res = res\n            index += 1\n        }\n        if(!res.equalsIgnoreCase(res)){\n\
    \            res = res\n            index += 1\n        }\n        if(!res.equalsIgnoreCase(res)){\n\
    \            res = res\n            index += 1\n        }\n        if(!res.equalsIgnoreCase(res)){\n\
    \            res = res\n            index += 1\n        }\n        if(!res.equalsIgnoreCase(res)){\n\
    \            res = res\n            index += 1\n        }\n        if(!res.equalsIgnoreCase(res)){\n\
    \            res = res\n            index += 1\n        }\n        if(!res.equalsIgnoreCase(res)){\n\
    \            res = res\n            index += 1\n        }\n        if(!res.equalsIgnoreCase(res)){\n\
    \            res = res\n            index += 1\n        }\n        if(!res.equalsIgnoreCase(res)){\n\
    \            res = res\n            index += 1\n        }\n        if(!res.equalsIgnoreCase(res)){\n\
    \            res = res\n            index += 1\n        }\n        if(!res.equalsIgnoreCase(res)){\n\
    \            res = res\n            index += 1\n        }\n        if(!res.equalsIgnoreCase(res)){\n\
    \            res = res\n            index += 1\n        }\n        if(!res.equalsIgnoreCase(res)){\n\
    \            res = res\n            index += 1\n        }\n        if(!res.",
  "        val result = new collection.mutable.HashMap[Character, String]()\n    \
    \    for(i <- 0 until s.length)\n            if(!result.contains(s.charAt(i)))\n\
    \                result += (s.charAt(i) -> s.substring(0,i) + s.substring(i+1,s.length))\n\
    \        result.mapValues { v => v.reverse.mkString(\"\") }.toSeq.mkString(\"\"\
    )", "        var result : String = s.toUpperCase\n        for (i <- 0 to s.length\
    \ - 1 by -1) {\n            if (result(i) == s(i)) {\n                if (s(i)\
    \ ==  \"A\" || s(i) ==  \"a\") {\n                    result =result.substring(0,\
    \ i) + result.substring(i + 1, result.length) + result.substring(0, i)\n     \
    \           } else if (s(i) ==  \"B\" || s(i) ==  \"b\") {\n                 \
    \   result =result.substring(0, i) + result.substring(i + 1, result.length) +\
    \ result.substring(0, i)\n                } else if (s(i) ==  \"C\" || s(i) ==\
    \  \"c\") {\n                    result =result.substring(0, i) + result.substring(i\
    \ + 1, result.length) + result.substring(0, i)\n                } else if (s(i)\
    \ ==  \"D\" || s(i) ==  \"d\") {\n                    result =result.substring(0,\
    \ i) + result.substring(i + 1, result.length) + result.substring(0, i)\n     \
    \           } else if (s(i) ==  \"E\" || s(i) ==  \"e\") {\n                 \
    \   result =result.substring(0, i) + result.substring(i + 1, result.length) +\
    \ result.substring(0, i)\n                } else if (s(i) ==  \"F\" || s(i) ==\
    \  \"f\") {\n                    result =result.substring(0, i) + result.substring(i\
    \ + 1, result.length) + result.substring(0, i)\n                } else if (s(i)\
    \ ==  \"G\" || s(i) ==  \"g\") {\n                    result =result.substring(0,\
    \ i) + result.substring(i + 1, result.length) + result.substring(0, i)\n     \
    \           } else if (s(i) ==  \"H\" || s(i) ==  \"h\") {\n                 \
    \   result =result.substring(0, i) + result.substring(i + 1, result.length) +\
    \ result.substring(0, i)\n                } else if (s(i) ==  \"I\" || s(i) ==\
    \  \"i\") {\n                    result =result.substring(0, i) + result.substring(i\
    \ + 1, result.length) + result.substring(0, i)\n                } else if (s(i)\
    \ ==  \"J\" || s(i) ==  \"j\") {\n                    result =result.substring(0,\
    \ i) + result.substring(i + 1, result.length) + result.substring(0, i)\n     \
    \           } else if (s(i) ==  \"K\" || s(i) ==  \"k\") {\n                 \
    \   result =result.substring(0, i) + result.substring(i + 1, result.length) +\
    \ result.substring(0, i)\n                } else if (s(i) ==  \"L\" || s(i) ==\
    \  \"l\") {\n                    result =result.substring(0, i) + result.substring(i\
    \ + 1, result.length) + result.substring(0, i)\n                } else if (s(i)\
    \ ==  \"M\" || s(i) ==  \"m\") {\n                    result =result.substring(0,\
    \ i) + result.substring(i + 1, result.length) + result.substring(0, i)\n     \
    \           } else if (s(i) ==  \"N\" || s(i) ==  \"n\") {\n                 \
    \   result =result.substring(0, i) + result.substring(i + 1, result.length) +\
    \ result.substring(0, i)\n                } else if (s(i) ==  \"O\" || s(i) ==\
    \  \"o\") {\n                    result =result.substring(0, i) + result.substring(i",
  "        var r = \"\"\n        for (char1 <- s) {\n            if (char1.isLetter)\
    \ {\n                if (char1.toLower > char1.toUpper) {\n                  \
    \  r ++= char1.toUpper\n                } else {\n                    r ++= char1.toLower\n\
    \                }\n            } else {\n                r ++= char1\n      \
    \      }\n        }\n        if (s.length == 0) {\n            r = r.toUpperCase\n\
    \        } else {\n            r = r.toLowerCase\n        }\n        r", "   \
    \     val chars = s.toList\n        val reversedChars = chars.reverse\n      \
    \  val newChars = chars.map {\n            case c if c.isLetter => (c.toUpperCase\
    \ + c.toLowerCase + c.toUpperCase).filter(_ != c)\n            case c => (c +\
    \ c).filter(_ != c)\n        }\n        val empty = newChars.isEmpty\n       \
    \ val newString = newChars.mkString\n        if (empty) {\n            return\
    \ newString\n        }\n        return solve(newString)", "        val letters\
    \ = s.toList\n        var result : String = s\n        letters.foreach{ letter\
    \ =>\n            if (letter.toUpperCase != letter)\n                result =\
    \ result.replace(letter, letter.toUpperCase)\n        }\n        result", "  \
    \      s.toList match {\n            case Nil => \"no letters\"\n            case\
    \ h::t => {\n                val list = h.toList\n                val revList\
    \ = list.map(l => {\n                    val first = l.head\n                \
    \    val rest = l.tail\n                    if (first.isLetter) {\n          \
    \              if (first.isLower) first.toUpperCase()\n                      \
    \  else first.toLowerCase()\n                    } else {\n                  \
    \      if (first.isUpper) first.toLowerCase()\n                        else first.toUpperCase()\n\
    \                    }\n                    rest match {\n                   \
    \     case Nil => Nil\n                        case x => x\n                 \
    \   }\n                })\n                val revString = (revList match {\n\
    \                    case Nil => s\n                    case x => x.reverse.mkString(\"\
    \")\n                }).mkString(\"\")\n                revString\n          \
    \  }\n        }", "        var result = \"\"\n        for (charSeq <- s.toList)\n\
    \            for (letter <- charSeq)\n                if ('a' <= letter && letter\
    \ <= 'z') result += letter.toUpperCase\n                else if (('a' <= letter\
    \ && letter <= 'z') || ('A' <= letter && letter <= 'Z')) result += letter\n  \
    \              else result += letter\n        return result.dropWhile(_.isLower).reverse",
  "        val result = new mutable.StringBuilder\n        for (i <- 0 until s.length)\n\
    \        {\n            val c = s.charAt(i)\n            if ( c >= 'a' && c <=\
    \ 'z')\n            {\n                result.append((s.charAt(i) - 'a').toChar)\n\
    \            }\n            else if ( c >= 'A' && c <= 'Z')\n            {\n \
    \               result.append((s.charAt(i) - 'A').toChar)\n            }\n   \
    \         else\n            {\n                result.append(c)\n            }\n\
    \        }\n        if (result.length == 0)\n        {\n            result.reverse\n\
    \        }\n        else\n        {\n            result\n        }", "       \
    \ val map = HashMap[Char,String]()\n        for (i <- 0 to s.length - 1) {\n \
    \           map(i.toChar, s.substring(i, i+1))\n        }\n        map.values.map(_.toLowerCase).reduceLeft((x,\
    \ y) => x + y)", "        if(s.length == 0) return s\n        val newS = s.toLowerCase\n\
    \        val newS = newS.replace(s.toUpperCase, \"\")\n        val newS = newS.replace(\"\
    \", \"@\")\n        val newS = newS.replace(\"@\", \"\")\n        val newS = newS.replaceAll(\"\
    [#@]\", \"\")\n        return newS", "        def isLetter(c : Char) = Character.isLetter(c)\n\
    \        def swapLetter(c : Char, i : Int, j : Int) = if(isLetter(c)) {\n    \
    \        val s = c.toUpperCase()\n            val l = s.substring(0, i)\n    \
    \        val u = s.substring(j, j)\n            s -> l + u.substring(i, i) + u\
    \ + l\n        } else c\n        def swapCase(c : Char) = c.toUpperCase\n    \
    \    val l = s.toList\n        val m = l.map(c => swapCase(c))\n        val n\
    \ = m.map(c => swapLetter(c, l.indexOf(c), l.lastIndexOf(c) + 1))\n        val\
    \ result = n.reduce(_ + _)\n        result", "        var chars = s.toCharArray\n\
    \        var result = new StringBuilder\n        val stack = new mutable.Stack[String]()\n\
    \        var i = 0\n        while ( i < chars.length) {\n            if (chars(i)\
    \ == '#') {\n                val n = stack.pop()\n                val v = chars(i)\n\
    \                val k = chars(i + 1)\n                stack += s\"$v$k\"\n  \
    \              i += 1\n            } else if (chars(i) != '@' && chars(i) != '.')\
    \ {\n                result += chars(i)\n                i += 1\n            }\n\
    \        }\n        result.toString()", "        var result = \"\"\n        for(i\
    \ <- s.indices) {\n            val c = s(i)\n            if(('A' <= c && c <=\
    \ 'Z') || ('a' <= c && c <= 'z')) {\n                result += c.toUpperCase\n\
    \            } else {\n                result += c.toLowerCase\n            }\n\
    \        }\n        if(result.isEmpty) {\n            result = s.reverse\n   \
    \     }\n        return result", "        val s = mutable.ListBuffer[String]()\n\
    \        for (x <- s)\n            if (x.isLetter) s += x.toUpperCase\n      \
    \      else s += x.toLowerCase\n        if (s.isEmpty) s\n        else s.mkString",
  "      val sb = mutable.Stack[String]()\n      sb.push(s)\n      while (sb.nonEmpty)\
    \ {\n        val sCopy = sb.copy\n        var s = sb.mkString(\"\")\n        if\
    \ (s.isEmpty) break\n        val strList = s.chars().filter(x => x.isLetter).toList\n\
    \        strList.foreach(x => if (x.isLetter) {\n          val len = s.length\n\
    \          s = s.substring(0,len - x) + s.substring(len - x)\n        }) \n  \
    \      sCopy = sCopy.mkString(\"\")\n        sCopy = sCopy.substring(0,s.length\
    \ - strList.size) + sCopy.substring(s.length - strList.size)\n        sb.push(sCopy)\n\
    \      }\n      sb.mkString(\"\")", "        val len  = s.length\n        val\
    \ strs = s.toList\n        var i = 0\n        while (i < len) {\n            if\
    \ (strs(i)  < 'a') {\n                strs(i) = strs(i).asInstanceOf[Char].toUpper\n\
    \            } else {\n                strs(i) = strs(i).asInstanceOf[Char].toLower\n\
    \            }\n            i += 1\n        }\n        strs.reverse.toList", " \
    \       var s = StringBuilder(s).reverse\n        for (i<- 0 to s.length-1){\n\
    \            if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z'){\n                var\
    \ newChar = s.charAt(i).toUpper\n                s.replace(i, 1, newChar)\n  \
    \              s.replace(i, 1, newChar)\n            }\n            else {\n \
    \               var newChar = s.charAt(i).toLower\n                s.replace(i,\
    \ 1, newChar)\n                s.replace(i, 1, newChar)\n            }\n     \
    \   }\n        return s.toString", "        val arr = s.toList\n        val m\
    \ = arr.length\n        var res : String = arr(0)\n        for (i <- 0 until m)\
    \ {\n            if (arr(i).isLetter)\n                res +=  arr(i).swapCase\n\
    \            else\n                res += arr(i)\n        }\n        res", " \
    \       val ls : List[Char] = s.toList\n        val rev = ls.reverse\n       \
    \ rev.filter(x=>x != ' ').reduce(_ ++ _).filter(x=>x != ' ')", "      var res\
    \ = \"\"\n      for(i <- s.length.toInt){\n        if(s.charAt(i) >= 'a' && s.charAt(i)\
    \ <= 'z'){\n          s = s.replaceAt(i, s.charAt(i).toString.toUpperCase)\n \
    \       }\n        else if(s.charAt(i) >= 'A' && s.charAt(i) <= 'Z'){\n      \
    \    s = s.replaceAt(i, s.charAt(i).toString.toLowerCase)\n        }\n       \
    \ else s += s.charAt(i)\n      }\n      if(s.length < 1){\n        res = s\n \
    \     }\n      else s = s.reverse\n      res", "        val a = mutable.ArrayBuffer.empty[String]\n\
    \        val list = s.toList\n        for(i <- 0 until list.length){ \n      \
    \      if(isLetter(list(i)))\n            a.append(toUpperCase(list(i)) + toUpperCase(list.drop(i).head))\n\
    \            else \n            a.append(list(i))\n        }\n        a.toList.toString()",
  "        def swap (c1 , c2) = if(c1 >= 'a' && c1 <= 'z') (c1 - 'a' + 26).toChar\
    \ + (c2 - 'a' + 26).toChar else c1 + c2.toChar\n        val map = mutable.Map[Char,Char]()\n\
    \        s.toList\n            .filter(_.isLetter)\n            .foreach(c =>\
    \ map += c -> (map.getOrElse(c, c.toLower) + 'a'.toLower))\n            .toList\n\
    \            .map(c => (map get c).orElse(c))\n            .foldLeft[String](\"\
    \")(swap)", "        def reverse(s: String) : String = {\n            val len\
    \ = s.length\n            var res = \"\"\n            for (i <- 0 until len) {\n\
    \                val lower = s(i).toLowerCase\n                val upper = lower(i).toUpperCase\n\
    \                if (lower == upper)\n                    res += upper\n     \
    \           else\n                    res += lower\n            }\n          \
    \  res\n        }\n        \n        def isLetter(s: Char) : Boolean = {\n   \
    \         s match {\n                case \"a\" => \"a\" == \"a\"\n          \
    \      case \"b\" => \"b\" == \"b\"\n                case \"c\" => \"c\" == \"\
    c\"\n                case \"d\" => \"d\" == \"d\"\n                case \"e\"\
    \ => \"e\" == \"e\"\n                case \"f\" => \"f\" == \"f\"\n          \
    \      case \"g\" => \"g\" == \"g\"\n                case \"h\" => \"h\" == \"\
    h\"\n                case \"i\" => \"i\" == \"i\"\n                case \"j\"\
    \ => \"j\" == \"j\"\n                case \"k\" => \"k\" == \"k\"\n          \
    \      case \"l\" => \"l\" == \"l\"\n                case \"m\" => \"m\" == \"\
    m\"\n                case \"n\" => \"n\" == \"n\"\n                case \"o\"\
    \ => \"o\" == \"o\"\n                case \"p\" => \"p\" == \"p\"\n          \
    \      case \"q\" => \"q\" == \"q\"\n                case \"r\" => \"r\" == \"\
    r\"\n                case \"s\" => \"s\" == \"s\"\n                case \"t\"\
    \ => \"t\" == \"t\"\n                case \"u\" => \"u\" == \"u\"\n          \
    \      case \"v\" => \"v\" == \"v\"\n                case \"w\" => \"w\" == \"\
    w\"\n                case \"x\" => \"x\" == \"x\"\n                case \"y\"\
    \ => \"y\" == \"y\"\n                case \"z\" => \"z\" == \"z\"\n          \
    \  }\n        }\n        \n        def getUpperLetter(s: String) : String = {\n\
    \            val len = s.length\n            var res = \"\"\n            for (i\
    \ <- 0 until len) {\n                val lower = s(i).toLowerCase\n          \
    \      if (!isLetter(lower)) {\n                    res += lower(i).toUpperCase\n\
    \                } else {\n                    res += lower(i)\n             \
    \   }\n            }\n            res\n        }\n        \n        def getLowerLetter(s:\
    \ String) : String = {\n            val len = s.length\n            var res =\
    \ \"\"\n            for (i <- 0 until len) {\n                val lower = s(i).toLowerCase\n\
    \                if (!isLetter(lower)) {\n                    res += lower(i)\n\
    \                } else {\n                    res += lower(i).toUpperCase\n \
    \               }\n            }\n            res\n        }\n        \n     \
    \   var res = ", "        val letters: List[Char] = s.toList\n        val result:\
    \ String = letters.foldLeft(\"\"){case (res, c) =>\n            c match {\n  \
    \              case \"a\" => \"A\"\n                case \"b\" => \"B\"\n    \
    \            case \"c\" => \"C\"\n                case \"d\" => \"D\"\n      \
    \          case \"e\" => \"E\"\n                case \"f\" => \"F\"\n        \
    \        case \"g\" => \"G\"\n                case \"h\" => \"H\"\n          \
    \      case \"i\" => \"I\"\n                case \"j\" => \"J\"\n            \
    \    case \"k\" => \"K\"\n                case \"l\" => \"L\"\n              \
    \  case \"m\" => \"M\"\n                case \"n\" => \"N\"\n                case\
    \ \"o\" => \"O\"\n                case \"p\" => \"P\"\n                case \"\
    q\" => \"Q\"\n                case \"r\" => \"R\"\n                case \"s\"\
    \ => \"S\"\n                case \"t\" => \"T\"\n                case \"u\" =>\
    \ \"U\"\n                case \"v\" => \"V\"\n                case \"w\" => \"\
    W\"\n                case \"x\" => \"X\"\n                case \"y\" => \"Y\"\n\
    \                case \"z\" => \"Z\"\n                case _ =>\n            }\n\
    \        }\n        result", "        var res = \"\";\n        for (i <- 0 until\
    \ s.length) {\n            if (s.charAt(i) > 'Z')\n                s = s.reverse\n\
    \            else if (s.charAt(i) > 'z')\n                s = s.toUpperCase\n\
    \            else\n                s = s.toLowerCase\n            res += s\n \
    \       }\n        res", "      val str = s.toList\n      val newStr = str.foldLeft(\"\
    \")(\n        (r: String, acc: List[Char], i: Int) => {\n          if (i >= str.length)\
    \ r else acc + str.charAt(i) + r\n        }\n      )\n      newStr.length <= s.length\
    \ match {\n        case false => newStr\n        case true => s.reverse\n    \
    \  }", "       var stringRev = s.reverse \n       var charSet = string.split(\"\
    \") \n       val rev = stringRev filter { x => charSet.contains(x.toChar) }\n\
    \       charSet = charSet filter { x => !charSet.contains(x.toChar) }\n      \
    \ stringRev = stringRev filter { x => !charSet.contains(x.toChar) }\n       rev\
    \ mkString \"\"", "        val a = s.toList\n        var i = a.length-1\n    \
    \    var s1 =  a.map(_ + \"\").filter(_ == \"a\") map (_.toUpperCase)\n      \
    \  var s2 = a.map(_ + \"\").filter(_ == \"A\") map (_.toUpperCase)\n        var\
    \ s3 = a.map(_ + \"\").filter(_ == \"c\") map (_.toUpperCase)\n        while (s1\
    \ contains \"a\" ||  s2 contains \"A\" || s3 contains \"c\") {\n            if\
    \ (s1 contains \"a\") {\n                s2 += \"A\"\n                s1 -+= \"\
    A\"\n            } else if (s2 contains \"A\") {\n                s1 += \"a\"\n\
    \                s2 -+= \"a\"\n            } else if (s3 contains \"c\") {\n \
    \               s1 += \"c\"\n                s3 -+= \"c\"\n            }\n   \
    \     }\n        s1 ++= a\n        s2 ++= a\n        s3 ++= a\n        s1 ++=\
    \ s2.toList\n        s2 ++= s1.toList\n        s3 ++= s1.toList\n        a.clear()\n\
    \        a.extend(s1.toList)\n        a.extend(s2.toList)\n        a.extend(s3.toList)\n\
    \        a.mkString", "        val str: List[Char] = s.toList\n        str.zipWithIndex.map{case\
    \ (c, i) => \n            val isLetter = c.toLowerCase == c\n            c.toUpperCase()\
    \ if isLetter else c.toLowerCase()\n        }.foldLeft(\"\"){case (str, char)\
    \ => str + char}", "        val input = s + \"$\"\n        val result = new StringBuilder()\n\
    \        var index = 0\n        var ch = \"\"\n        while(index < input.length)\
    \ {\n            ch = input((index + 1))\n            if(ch.isLetter) {\n    \
    \            ch = ch.toUpperCase\n            }\n            else {\n        \
    \        ch = ch.toLowerCase\n            }\n            result.append(ch)\n \
    \           index += 1\n        }\n        result.toString()", "      val sb =\
    \ new StringBuilder\n      for (x <- s) {\n        if (x.isLetter) {\n       \
    \   if (x.toUpperCase == x) sb.append(x.toUpperCase)\n          else sb.append(x.toLowerCase)\n\
    \        }\n        else sb.append(x)\n      }\n      if (sb.toString() == \"\"\
    ) sb.toString()\n      else sb.reverse.toString()", "        val stringBuilder\
    \ = new StringBuilder(s.length)\n        var charArray = Array.ofDim[Char](s.length)\n\
    \        for (i<-0 until s.length){\n            charArray(i) = s.charAt(i)\n\
    \        }\n        if (charArray.exists(!Char.isLetter(charArray(i)))){\n   \
    \         for (i <-0 until s.length){\n                stringBuilder.append(charArray(i))\n\
    \            }\n            return stringBuilder.reverse\n        }else{\n   \
    \         for (i <-0 until s.length){\n                charArray(i) = charArray(i).swapCase()\n\
    \                stringBuilder.append(charArray(i))\n            }\n         \
    \   return stringBuilder.reverse\n        }", "        var result = \"\"\n   \
    \     var last = 0\n        for (i <- 0 until s.length){\n            val c =\
    \ s(i)\n            if (c >= 'a' && c <= 'z'){\n                if (last+1 > i)\
    \ result += s.substring(last+1, i)\n                last += 1\n              \
    \  result += c.toUpperCase\n            } else if (c >= 'A' && c <= 'Z'){\n  \
    \              if (last+1 > i) result += s.substring(last+1, i)\n            \
    \    last += 1\n                result += c.toLowerCase\n            } else {\n\
    \                if (last+1 > i) result += s.substring(last+1, i)\n          \
    \      last += 1\n                result += c\n            }\n        }\n    \
    \    if (last > 0) result += s.substring(last+1)\n        result", "        val\
    \ l = s.toLower\n        val uc = s.toUpper\n        s.find(x => x => x.isLetter)\
    \ match {\n            case Some(idx) => \n                val rev = s.reverse\n\
    \                val rev2 = rev.reverse\n                val rev3 = rev2.reverse\n\
    \                val rev4 = rev3.reverse\n                val rev5 = rev4.reverse\n\
    \                val rev6 = rev5.reverse\n                val rev7 = rev6.reverse\n\
    \                val rev8 = rev7.reverse\n                val rev9 = rev8.reverse\n\
    \                val rev10 = rev9.reverse\n                val rev11 = rev10.reverse\n\
    \                val rev12 = rev11.reverse\n                val rev13 = rev12.reverse\n\
    \                val rev14 = rev13.reverse\n                val rev15 = rev14.reverse\n\
    \                val rev16 = rev15.reverse\n                val rev17 = rev16.reverse\n\
    \                val rev18 = rev17.reverse\n                val rev19 = rev18.reverse\n\
    \                val rev20 = rev19.reverse\n                val rev21 = rev20.reverse\n\
    \                val rev22 = rev21.reverse\n                val rev23 = rev22.reverse\n\
    \                val rev24 = rev23.reverse\n                val rev25 = rev24.reverse\n\
    \                val rev26 = rev25.reverse\n                val rev27 = rev26.reverse\n\
    \                val rev28 = rev27.reverse\n                val rev29 = rev28.reverse\n\
    \                val rev30 = rev29.reverse\n                val rev31 = rev30.reverse\n\
    \                val rev32 = rev31.reverse\n                val rev33 = rev32.reverse\n\
    \                val rev34 = rev33.reverse\n                val rev35 = rev34.reverse\n\
    \                val rev36 = rev35.reverse\n                val rev37 = rev36.reverse\n\
    \                val rev38 = rev37.reverse\n                val rev39 = rev38.reverse\n\
    \                val rev40 = rev39.reverse\n                val rev41 = rev40.reverse\n\
    \                val rev42 = rev41.reverse\n                val rev43 = rev42.reverse\n\
    \                val rev44 = rev43.reverse\n                val rev45 = rev44.reverse\n\
    \                val rev46 = rev45.reverse\n                val rev47 = rev46.reverse\n\
    \                val rev48 = rev47.reverse\n                val rev49 = rev48.reverse\n\
    \                val rev50 = rev49.reverse\n                val rev51 = rev50.reverse\n\
    \                val rev52 = rev51.reverse\n                val rev53 = rev52.reverse\n\
    \                val rev54 = rev53.reverse", "        val numArray = s.toCharArray.map(_.toInt)\n\
    \        val numArray2 = s.toCharArray.map(_.toInt - 65).filter(x => x > 0 &&\
    \ x < 26)\n        val numArray3 = s.toCharArray.map(_.toInt - 97).filter(x =>\
    \ x > 0 && x < 26)\n        val numArray4 = s.toCharArray.map(_.toInt - 65).filter(x\
    \ => x > 0 && x < 26).filter(x => x > 0 && x < 26)\n        val numArray5 = s.toCharArray.map(_.toInt\
    \ - 97).filter(x => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x =>\
    \ x > 0 && x < 26)\n        val numArray6 = s.toCharArray.map(_.toInt - 65).filter(x\
    \ => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x\
    \ => x > 0 && x < 26)\n        val numArray7 = s.toCharArray.map(_.toInt - 97).filter(x\
    \ => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x\
    \ => x > 0 && x < 26).filter(x => x > 0 && x < 26)\n        val numArray8 = s.toCharArray.map(_.toInt\
    \ - 65).filter(x => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x =>\
    \ x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x\
    \ => x > 0 && x < 26)\n        val numArray9 = s.toCharArray.map(_.toInt - 97).filter(x\
    \ => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x\
    \ => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x\
    \ => x > 0 && x < 26)\n        val numArray10 = s.toCharArray.map(_.toInt - 65).filter(x\
    \ => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x\
    \ => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x\
    \ => x > 0 && x < 26).filter(x => x > 0 && x < 26)\n        val numArray11 = s.toCharArray.map(_.toInt\
    \ - 97).filter(x => x > 0 && x < 26).filter(x => x > 0 && x < 26).filter(x =>\
    \ x > 0 && x < 26).filter(x => x > 0 && x < 26).", "        val l = s.toList\n\
    \        val reversed = mutable.Buffer.empty[String]\n        for (i <- 0 until\
    \ l.size) {\n            if (l.contains(i.toString))\n                reversed.+=(i.toString.toUpperCase)\n\
    \            else reversed.+=(i.toString)\n        }\n        reversed.toString.reverse",
  "        var reverseString = \"\"\n        var index = 0\n        while (index <\
    \ s.length){\n            if(s(index).isLetter){\n                val toUpper\
    \ = s(index).toUpper\n                val toLower = s(index).toLower\n       \
    \         reverseString += (toUpper + toLower)\n                index++\n    \
    \        }else{\n                reverseString += s(index)\n                index++\n\
    \            }\n        }\n        return reverseString", "      val arr = mutable.ArrayBuffer.empty[String]\n\
    \      var flag = false\n      var i = 0\n      while (i < s.length) {\n     \
    \   val c = s.charAt(i)\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c\
    \ <= 'Z')) {\n          arr.push(s.reverse)\n          flag = true\n        }\n\
    \        i += 1\n      }\n      if (flag) arr.reverse.toString.toUpperCase()\n\
    \      else s", "        val r = new StringBuilder(s).reverse\n        val a =\
    \ s.toList\n        a.foreach {\n            case c: Char =>\n               \
    \ if (c.isLetter) r +=  c.toUpper else r +=     c.toLower\n            case _\
    \ =>\n        }\n        r.reverse", '        s.reverse', "        val result\
    \ = mutable.ArrayBuffer.empty[String]\n        var index = 0\n        while (index\
    \ < s.length) {\n            val letter = s(index)\n            index += 1\n \
    \           if (letter.matches(\"\\\\d\")) result += \"0\"\n            else if\
    \ (letter.matches(\"[a-zA-Z]\")) {\n                val letter2 = s(index)\n \
    \               index += 1\n                if (letter2.matches(\"[a-zA-Z]\"))\
    \ {\n                    result += letter.toLowerCase\n                    result\
    \ += letter2.toUpperCase\n                } else {\n                    result\
    \ += letter.toLowerCase\n                }\n            } else {\n           \
    \     result += letter\n            }\n        }\n        result.mkString", " \
    \       def toUpper(s : String) : String = { \n            if(s.isEmpty) s\n \
    \           else s.toUpperCase\n        }\n        def toLower(s : String) : String\
    \ = { \n            if(s.isEmpty) s\n            else s.toLowerCase\n        }\n\
    \        val lowerCase = mutable.ListBuffer[String]()\n        val upperCase =\
    \ mutable.ListBuffer[String]()\n        for(x <- s.toCharArray) \n           \
    \ if(x.isLetter) \n                if(x.toUpperCase == x) \n                 \
    \   upperCase += toUpper(x)\n                else upperCase += x\n           \
    \ else\n                if(x.toLowerCase == x) \n                    lowerCase\
    \ += toLower(x)\n                else lowerCase += x\n        toLower(upperCase.toIterable.mkString)\
    \ + toUpper(lowerCase.toIterable.mkString)", "        var newStr = s\n       \
    \ var newStr2 = newStr\n        var i = 0\n        var j = 0\n        var count\
    \ = 1\n        while (i < newStr.length && j < newStr2.length) {\n           \
    \ if (newStr(i) == newStr2(j)) {\n                newStr += newStr2(i).asInstanceOf[String].toUpperCase\n\
    \                i += 1\n                j += 1\n                count += 1\n\
    \            } else {\n                count += 1\n            }\n        }\n\
    \        if (count == newStr2.length) {\n            newStr2 = newStr.reverse\n\
    \        }\n        newStr = newStr2.reverse\n        newStr", "        if(s.length\
    \ == 0) s.reverse\n        else \n            val countMap = mutable.Map[Char,\
    \ Int]()\n            for (i <- 0 until s.length) {\n                countMap(s(i))\
    \ = countMap(s(i)) + 1\n            }\n            var result : String = \"\"\n\
    \            var i = 0\n            while (i < s.length) {\n                if\
    \ (countMap.contains(s(i))) {\n                    countMap(s(i)) = countMap(s(i))\
    \ - 1\n                    result += s(i)\n                    i += 1\n      \
    \          } else {\n                    result += s(i)\n                }\n \
    \               i += 1\n            }\n            result\n        }", "     \
    \  val chars = s filter (c => ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z'))\n\
    \       val newChars = chars.toList.sortWith(_ < _)\n       if (chars.isEmpty)\
    \ {\n           newChars.mkString\n       } else {\n           newChars.reverse.mkString\n\
    \       }", "        var result = \"\"\n        var temp = \"\"\n        for(char\
    \ <- s.toCharArray) {\n            if(char >= 'a' && char <= 'z') {\n        \
    \        temp =  temp + char.asInstanceOf[Int].toString.toUpperCase\n        \
    \    } else if(char >= 'A' && char <= 'Z') {\n                temp = temp + char.asInstanceOf[Int].toString\n\
    \            } else {\n                temp = temp + char\n            }\n   \
    \     }\n        result = result + temp\n        return result", "        val\
    \ charSet = new collection.mutable.HashSet[Char]()\n        for (c <- s) {\n \
    \           if (charSet.contains(c)) charSet.remove(c.toLowerCase)\n         \
    \   charSet += c.toLowerCase\n        }\n        charSet.map(c => if (charSet.contains(c.toLowerCase))\
    \ c.toUpper else c).toString.reverse", "        val result = new mutable.ArrayBuffer[String]()\n\
    \        val lowerCase = s.toLowerCase // keep a lowercase copy of original string\n\
    \        for (i <- 0 until s.length){ // traverse the original string until it\
    \ ends\n            if (isLetter(lowerCase(i))){\n                val revCase\
    \ = revCase(lowerCase(i))\n                result.append((revCase))\n        \
    \    }else {\n                result.append(lowerCase(i))\n            }\n   \
    \     }\n        return result", "        val rev = s.reverse\n        val str\
    \ = rev.split(\"\").map(_.toLowerCase).toList\n        val noLettersStr = if (str.isEmpty)\
    \ \"#a@C\" else s\n        val result = if (str.contains(rev.split(\"\").head))\
    \ \n            str.map(_.toLowerCase).reverse\n        else\n            noLettersStr.map(_.toLowerCase).reverse\n\
    \        result.mkString(\"\")", "        val res = new StringBuilder(s.length)\n\
    \        for(i <- 0 until s.length) res += if(s.charAt(i).toUpperCase == s.charAt(i).toLowerCase)\
    \ s.charAt(i).toUpperCase else s.charAt(i).toLowerCase\n        res", "      \
    \  if(s.isEmpty) {\n            return s\n        }\n        var revStr = \"\"\
    \n        var i = 0\n        while(i < s.length()) {\n            if(s.charAt(i).toLowerCase\
    \ == 'a') {\n                revStr = s.substring(i, s.length()).reverse\n   \
    \             i = s.length()\n            }else if(s.charAt(i).toUpperCase ==\
    \ 'A') {\n                revStr = s.substring(i, s.length()).reverse\n      \
    \          i = s.length()\n            }else if(s.charAt(i).toLowerCase == 'b')\
    \ {\n                revStr = s.substring(i, s.length()).reverse\n           \
    \     i = s.length()\n            }else if(s.charAt(i).toUpperCase == 'B') {\n\
    \                revStr = s.substring(i, s.length()).reverse\n               \
    \ i = s.length()\n            }\n            else {\n                revStr =\
    \ revStr + s.charAt(i)\n                i = i + 1\n            }\n        }\n\
    \        if(revStr.length() == 0) {\n            revStr = revStr + s.substring(0,\
    \ s.length())\n        }\n        return revStr", "        var result : String\
    \ = \"\"\n        var tmpStr : String = \"\"\n        for(i <- 0 until s.length){\n\
    \            if(s.charAt(i)>= 'a' && s.charAt(i)<= 'z'){\n                tmpStr\
    \ += s.charAt(i).toLower\n            }\n            else if(s.charAt(i)>= 'A'\
    \ && s.charAt(i)<= 'Z'){\n                tmpStr += s.charAt(i).toUpper\n    \
    \        }\n            else{\n                tmpStr += s.charAt(i)\n       \
    \     }\n        }\n        val tmpArray = tmpStr.toCharArray\n        var reverseStr\
    \ = \"\"\n        for(i <- 0 until tmpArray.length){\n            reverseStr +=\
    \ tmpArray(i)\n        }\n        return reverseStr", "        val len = s.length\n\
    \        var result = \"\"\n        var flag = 0\n        var temp = \"\"\n  \
    \      var i = 0\n        var j = 0\n        while(i < len) {\n            if\
    \ (s.charAt(i) >= 'A' && s.charAt(i) <= 'Z') {\n                temp = temp +\
    \ s.charAt(i).toUpper\n            } else {\n                temp = temp + s.charAt(i).toLower\n\
    \            }\n            i = i + 1\n        }\n        for (i = 1; i < len;\
    \ i++) {\n            if (temp == \"\") {\n                result = result + s.charAt(i)\n\
    \            } else {\n                flag = i\n                temp = \"\"\n\
    \                j = 0\n                while (j < flag) {\n                 \
    \   temp = temp + s.charAt(j).toUpper\n                    j = j + 1\n       \
    \         }\n                temp = temp + s.charAt(flag).toLower\n          \
    \      flag = flag - 1\n                while (j > flag) {\n                 \
    \   temp = temp + s.charAt(j).toLower\n                    j = j - 1\n       \
    \         }\n                temp = temp + s.charAt(flag).toLower\n          \
    \      i = i + 1\n                while (i < len) {\n                    if (s.charAt(i)\
    \ >= 'A' && s.charAt(i) <= 'Z') {\n                        temp = temp + s.charAt(i).toUpper\n\
    \                    } else {\n                        temp = temp + s.charAt(i).toLower\n\
    \                    }\n                    i = i + 1\n                }\n   \
    \             result = result + temp\n            }\n        }\n        return\
    \ result", "        val lower = s.toLowerCase \n        val upper = s.toUpperCase\
    \ \n        if (lower == upper) {\n            return s\n        }\n        val\
    \ nums = mutable.ArrayBuffer.empty[String]\n        for (x <- lower) {\n     \
    \       if (x != x.toLowerCase) {\n                nums += x\n            } else\
    \ if (x != x.toUpperCase) {\n                nums += x.toUpperCase\n         \
    \   }\n        }\n        nums.reverse", "        val lower = (\"a\" -> \"A\"\
    , \"b\" -> \"B\", \"c\" -> \"C\", \"d\" -> \"D\", \"e\" -> \"E\", \"f\" -> \"\
    F\", \"g\" -> \"G\", \"h\" -> \"H\", \"i\" -> \"I\", \"j\" -> \"J\", \"k\" ->\
    \ \"K\", \"l\" -> \"L\", \"m\" -> \"M\", \"n\" -> \"N\", \"o\" -> \"O\", \"p\"\
    \ -> \"P\", \"q\" -> \"Q\", \"r\" -> \"R\", \"s\" -> \"S\", \"t\" -> \"T\", \"\
    u\" -> \"U\", \"v\" -> \"V\", \"w\" -> \"W\", \"x\" -> \"X\", \"y\" -> \"Y\",\
    \ \"z\" -> \"Z\")\n        val upper = lower\n        val news = lower.keySet.filter(s\
    \ => s !in lower.values)\n        news.foreach(s => s += upper(s))\n        lower"]
stop_tokens:
- "\n    }\n"
