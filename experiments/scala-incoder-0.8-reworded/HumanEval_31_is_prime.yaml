name: HumanEval_31_is_prime
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return true if a given number is prime, and false otherwise.\n    // >>>\
  \ isPrime((6l))\n    // (false)\n    // >>> isPrime((101l))\n    // (true)\n   \
  \ // >>> isPrime((11l))\n    // (true)\n    // >>> isPrime((13441l))\n    // (true)\n\
  \    // >>> isPrime((61l))\n    // (true)\n    // >>> isPrime((4l))\n    // (false)\n\
  \    // >>> isPrime((1l))\n    // (false)\n    def isPrime(n : Long) : Boolean =\
  \ {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(isPrime((6l)) ==\
  \ (false));\n    assert(isPrime((101l)) == (true));\n    assert(isPrime((11l)) ==\
  \ (true));\n    assert(isPrime((13441l)) == (true));\n    assert(isPrime((61l))\
  \ == (true));\n    assert(isPrime((4l)) == (false));\n    assert(isPrime((1l)) ==\
  \ (false));\n    assert(isPrime((5l)) == (true));\n    assert(isPrime((11l)) ==\
  \ (true));\n    assert(isPrime((17l)) == (true));\n    assert(isPrime((85l)) ==\
  \ (false));\n    assert(isPrime((77l)) == (false));\n    assert(isPrime((255379l))\
  \ == (false));\n    }\n\n}\n"
completions: ["      val isPrime = new mutable.BitSet(math.pow(2, n.toInt).toInt)\n\
    \      val n = math.pow(10, n.toInt).toInt\n      var p = 2l\n      while (p <\
    \ n) {\n        if (isPrime(p)) {\n          p += 1\n          isPrime.set(p)\n\
    \        }\n        p += 1\n      }\n      isPrime.get(n-1)", "        val factors\
    \ = mutable.ListBuffer(2L)\n        var r = n\n        while (r > 2L) {\n    \
    \        if (n % r == 0)\n                factors += r\n            r /= 2L\n\
    \        }\n        return factors.isEmpty == false", "        if ((n == 1l) ||\
    \ (n == 2l)) {\n            return true\n        }\n        else if ((n % 2l)\
    \ == 0l) {\n            return false\n        }\n        else {\n            val\
    \ div = n.toDouble / 2l\n            val fdiv = n.toDouble / n\n            if\
    \ (div == 1) {\n                return false\n            }\n            else\
    \ if (fdiv == 2) {\n                return true\n            }\n            else\
    \ {\n                isPrime(div)\n            }\n        }", "        // Implement\
    \ this function using recursion.\n        // Note, this is not a simple prime\
    \ number test\n        // as this does not give a good lower bound on \n     \
    \   // how long it takes to run your program\n        var limit : Long = 2l\n\
    \        var numPrime = 0\n        var prime = true\n        for (x <- 1 to limit\
    \ if n % x == 0) {\n            if (x == limit) {\n                limit = limit.toLong\
    \ * 2\n            }\n            else {\n                limit = limit * 2\n\
    \            }\n            numPrime += 1\n        }\n        if (numPrime ==\
    \ 2) {\n            prime = true\n        }\n        else {\n            prime\
    \ = false\n        }\n        return prime", "        val l = n - 1\n        if\
    \ (l < 2l) true\n        else if (n == 2l) true\n        else if (n % 3l) == 2l)\
    \ true\n        else if (n % 5l) == 2l) true\n        else if (n % 7l) == 2l)\
    \ true\n        else false", "        val n = n.toInt\n        if(n == 1) true\n\
    \        else (\n            (n % 2 == 0)\n                && (n != 1 && isPrime(n\
    \ / 2)) && (n % 1 != 0 && isPrime(n / 3)) \n        )", "        // Your code\
    \ here\n        if(n <= 1)\n          return true\n        if(n == 2)\n      \
    \    return true\n        if(n != (n.toInt / 2))\n          return(false)\n  \
    \      for(x <- 2 to n/2)\n          if(n%x == 0)\n            return(false)\n\
    \        return(true)\n      }\n    \n    val ls = mutable.LinkedList(List(1l,\
    \ 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l,\
    \ 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l))\n    val ls2 = 0l :: ls\n    val ls21\
    \ = 1l :: ls ++ 1l :: 0l :: ls21\n    val ls210 = 0l :: ls ++ 0l :: 1l :: ls21\n\
    \    val ls2101 = 1l :: ls ++ 1l :: 0l :: ls21\n    val ls2103 = 1l :: ls ++ 1l\
    \ :: 0l :: ls21\n    val ls2104 = 1l :: ls ++ 1l :: 0l :: ls21\n    val ls2105\
    \ = 1l :: ls ++ 1l :: 0l :: ls21\n    val ls2106 = 1l :: ls ++ 1l :: 0l :: ls21\n\
    \    val ls2107 = 1l :: ls ++ 1l :: 0l :: ls21\n    val ls2108 = 1l :: ls ++ 1l\
    \ :: 0l :: ls21\n    val ls2109 = 1l :: ls ++ 1l :: 0l :: ls21\n    val ls2110\
    \ = 1l :: ls ++ 1l :: 0l :: ls21\n    val ls2111 = 1l :: ls ++ 1l :: 0l :: ls21\n\
    \    val ls2113 = 1l :: ls ++ 1l :: 0l :: ls21\n    val ls2114 = 1l :: ls ++ 1l\
    \ :: 0l :: ls21\n    val ls2115 = 1l :: ls ++ 1l :: 0l :: ls21\n    val ls2116\
    \ = 1l :: ls ++ 1l :: 0l :: ls21\n    val ls2117 = 1l :: ls ++ 1l :: 0l :: ls21\n\
    \    val ls2119 = 1l :: ls ++ 1l :: 0l :: ls21\n    val ls2121 = 1l :: ls ++ 1l\
    \ :: 0l :: ls21\n    val ls2123 = 1l :: ls ++ 1l :: 0l :: ls21\n    val ls2124\
    \ = 1l :: ls ++ ", "        import scala.math._\n        val max = scala.math.pow(n,\
    \ 2.0)\n        var i = 2l\n        while (i <= max) {\n            if (n % i\
    \ == 0) {\n                return false\n            }\n            i = i + 1l\n\
    \        }\n        true", "        if(n.toInt == 1){\n            return false\n\
    \        }\n        if(n.toInt > 1){\n            val sqrt : Long = Math.sqrt(n)\n\
    \            val isprime : Long = 1\n            var i : Long = 1\n          \
    \  while(i <= sqrt){\n                if((isprime % n) == 0){\n              \
    \      return false\n                }\n                i += 2\n             \
    \   isprime += 1\n            }\n            return true\n        }else{\n   \
    \         return true\n        }", "        val sqrt2 = Math.sqrt(n).toLong\n\
    \        for ((x, i) <- 1 to sqrt2 by 2) {\n            if ((x % n) != 0) {\n\
    \                false\n            }\n            n -= 1\n        }\n       \
    \ true", "        def primes(n : Long) : List[Long] = {\n            var i : Long\
    \ = 0\n            val primes : mutable.MutableList[Long] = mutable.MutableList.empty\n\
    \            while (i < n) {\n                if (n % i == 0) {\n            \
    \        primes += i\n                }\n                i += 2\n            }\n\
    \            primes.toList\n        }\n        def nextPrime(n : Long) : Long\
    \ = {\n            val i : Long = 1\n            while (i < n) {\n           \
    \     if (n % i == 0) {\n                    i += 1\n                } else {\n\
    \                    return i\n                }\n            }\n            return\
    \ n\n        }\n        if (n < 2) false\n        else if (n == 2) true\n    \
    \    else primes(n).forall(p => isPrime(nextPrime(p)))", "        if(n == 1) return\
    \ false\n        if(n == 2) return true\n        val l = n.toInt\n        for(i\
    \ <- 2 to l/2) {\n            if(!l%i)\n                return false\n       \
    \ }\n        return true", "        val two = 3l\n        val three = 3l+1\n \
    \       var result : Boolean = true\n        for(i <- 2l..n) result &= (n%i ==\
    \ 0)\n        for(i <- 2l..two) result &= (i%n  == 0)\n        for(i <- 2l..three)\
    \ result &= (i%n == 0)\n        result", "        if (n<2l) false\n        if\
    \ (n<4l) true\n        if (n % 2 == 0) false\n        if (n % 3 == 0) false\n\
    \        val max = Math.sqrt(n)\n        for (i <- 2l to max) {\n            if\
    \ (n % i == 0) false\n        }\n        true", "        var result = true\n \
    \       for (i <- 2 to sqrt(n)) {\n            if (n % i == 0) {\n           \
    \     result = false\n                break\n            }\n        }\n      \
    \  result", "        if (n < 2) return false\n        for (f : Long => Boolean)\
    \ if (f(n)) return true\n        if (n % 2 == 0) return false\n        for (xs\
    \ <- {2 until Math.sqrt(n).toLong}) {\n            val x = (n - xs) / 2\n    \
    \        if (x == 1 && f(x)) return false\n            if (f(x)) return false\n\
    \        }\n        return true", "        def sieveOfEratosthenes(n : Long) :\
    \ Unit = {\n            val sieve = scala.collection.mutable.ListBuffer(2l).init\
    \ // 2 > sqrt(n) \n            var i = 3l\n            var flag : Boolean = true\n\
    \            while (i <= n && (flag = true)) {\n                val temp = sieve.takeWhile(_\
    \ <= i).tail.last\n                if (temp < i)\n                    sieve =\
    \ sieve.updated(temp + 2, 1)\n                else\n                    flag =\
    \ false\n                i += 1\n            }\n        }\n        val upperBound\
    \ = math.sqrt(n).toInt\n        sieveOfEratosthenes(upperBound)\n        var flag\
    \ : Boolean = true\n        while (i <= n) {\n            if (sieve.contains(i))\
    \ {\n                if (flag) {\n                    flag = false\n         \
    \           false\n                } else {\n                    return true\n\
    \                }\n            }\n            i += 1\n        }\n        false",
  "        val m = 31l\n        var i = 2l\n        while(i < n) {\n            if\
    \ (n % i == 0l) {\n                m += i;\n            }\n            i += 2l\n\
    \        }\n        if (m <= n) { \n            return true\n        } else {\
    \ \n            return false\n        }", "        val i = 2l\n        val s =\
    \ 2l\n        val prime = new MutableList[Long]()\n        var isPrime = true\n\
    \n        while ( i < n ) {\n            if ( n % i == 0 ) {\n               \
    \ isPrime = false\n                break\n            }\n\n            if ( i\
    \ % s == 0 ) {\n                prime = prime :+ i\n                s = s * 3l\n\
    \            } else {\n                s = s * 2l\n            }\n\n         \
    \   i += 1\n        }\n\n        isPrime", "        // First see if n is greater\
    \ than the square root of 2\n        if (n < 4l){\n            return false\n\
    \        }\n        // If the number is greater than 4, then n is prime.\n   \
    \     // If the number is greater than 4, then n is prime.\n        else if ((n\
    \ % 4l) == 0){\n            return false\n        }\n        // If n is greater\
    \ than the square root of 2, then n is not prime.\n        else if (math.pow(n,\
    \ 2l) > 4l){\n            return false\n        }\n        // If n is greater\
    \ than the square root of 2, then n is prime.\n        else if (math.pow(n, 2l)\
    \ == 4l){\n            return true\n        }\n        // If the number is prime,\
    \ then\n        else {\n            val div = 1l until math.pow(n, 2l)\n     \
    \       for (d <- div) {\n                if (n % d == 0){\n                 \
    \   return false\n                }\n            }\n            return true\n\
    \        }", "        for (i <- 2 until n by 2)\n            if (n % i == 0)\n\
    \                return false\n        return true", "        // If n is less\
    \ than 1 we return false\n        if(n < 1l) false\n        // If n is less than\
    \ 2 we return false\n        if(n < 2l) false\n        // If n is less than 3\
    \ we return false\n        if(n < 3l) false\n        // Set a flag true if n is\
    \ greater than 3\n        var flag : Boolean = false\n        // If n is odd we\
    \ check if n is even\n        if(n % 2l == 0l) {\n            // If n is even\
    \ we set flag to true\n            flag = true\n            // and set n = 3n\
    \ - 2\n            n = n - 2l\n        }\n        // If the flag is true we check\
    \ whether\n        // n is divisible by only 2 numbers\n        flag match {\n\
    \            case true =>\n                (n == 3l) match {\n               \
    \     case true =>\n                        (n == 2l) match {\n              \
    \              case true =>\n                                true\n          \
    \                  case false =>\n                                false\n    \
    \                    }\n                    case false =>\n                  \
    \      false\n                }\n            case false =>\n                //\
    \ If n is divisible by 2 numbers,\n                // we add one to n and call\
    \ isPrime\n                // with that number\n                isPrime(n.add(1l))\n\
    \        }", "        require(n > 1, \"n must be greater than 1\")\n        def\
    \ test(x: Long, i: Long) = {\n            if (x == i) {\n                x % i\
    \ == 0\n            } else {\n                val t = x * x\n                if\
    \ (t <= n && (t % i) != 0) {\n                    false\n                } else\
    \ {\n                    test(t, i + 1)\n                }\n            }\n  \
    \      }\n        test(1l, 1l)", "        def div(n: Long) : Int = {\n       \
    \     val i = n / 2l\n            if (n % 2 == 0) 0\n            else 1 + div(i\
    \ + 1)\n        }\n        val factors = mutable.HashSet.empty[Long]\n       \
    \ for (i <- 2l to Math.sqrt(n).toInt) factors += i\n        for (i: Long <- factors)\
    \ {\n            if (n % i == 0) return false\n        }\n        return true",
  "        if(n == 0)\n            return false\n        if(isPrimeIterative(n))\n\
    \            return true\n        if(n % 2 == 0)\n            return false\n \
    \       var i = 3\n        while(i <= n/2) {\n            if(n % i == 0)\n   \
    \             return false\n            i += 2\n        }\n        return true",
  "        require(!(n == 0), \"Parameter must be a positive integer\")\n        val\
    \ factors = mutable.Set[Long]()\n        for (d <- 2 until n.toInt) {\n      \
    \      if (n % d == 0) {\n                factors += d\n            }\n      \
    \  }\n        factors.size == 2 && factors.contains(n) ? true : n == 1", "   \
    \     for(a <- 2l to n; a <= Math.sqrt(n)) {\n            if (n % a == 0)\n  \
    \              return false\n        }\n        return true", "        if(n==0\
    \ || n==1) return true\n        if(n==2) return true\n        var d : Long = math.sqrt(n)\n\
    \        for(i <- 0 until d.toInt) {\n            if(n%(i*i)==0) return false\n\
    \        }\n        return true", "        val factors = mutable.Set.empty[Long]\n\
    \        var j = 0\n        for (i <- 2 to n by 2) {\n            while (n % i\
    \ == 0) {\n                factors += i\n                n /= i\n            }\n\
    \        }\n        if (n == 1) {\n            factors -= 1\n        }\n     \
    \   factors.size == 1", "        // TODO: implement a better algorithm here\n\
    \        val sq = math.pow(n, 2); \n        var j : Long = 1\n        var flag\
    \ = true \n        var sq2 = 0\n        var j2 = 0\n        for(i <- 0 until sq)\
    \ sq2 += sq\n        for(i <- 0 until sq) j2 += j\n        val sq3 = sq2\n   \
    \     val j3 = j2\n        val sq4 = sq3\n        val j4 = j3\n        while(sq3\
    \ < sq4) j3 += 1; \n        while(j3 <= sq3) j3 += 2;\n        sq3 += sq\n   \
    \     j3 += j\n        val sq5 = sq3\n        val j5 = j3\n        for(i <- 0\
    \ until sq5) sq4 += sq5\n        for(i <- 0 until sq5) j4 += j5\n        val sq6\
    \ = sq4\n        val j6 = j4\n        val sq7 = sq6\n        val j7 = j6\n   \
    \     while(sq6 < sq7) j6 += 1; \n        while(j6 < sq6) j6 += 2;\n        sq6\
    \ += sq\n        j6 += j\n        val sq8 = sq6\n        val j8 = j6\n       \
    \ for(i <- 0 until sq8) sq7 += sq8\n        for(i <- 0 until sq8) j7 += j8\n \
    \       val sq9 = sq7\n        val j9 = j7\n        for(i <- 0 until sq9) sq8\
    \ += sq9\n        for(i <- 0 until sq9) j9 += j9\n        val sq10 = sq8\n   \
    \     val j10 = j9\n        for(i <- 0 until sq10) sq9 += sq10\n        for(i\
    \ <- 0 until sq10) j10 += j10\n        val sq11 = sq9\n        val j11 = j10\n\
    \        for(i <- 0 until sq11) sq10 += sq11\n        for(i <- 0 until sq11) j11\
    \ += j11\n        val sq12 = sq10\n        val j12 = j11\n        for(i <- 0 until\
    \ sq12) sq11 += sq12\n        for(i <- 0 until sq12) j12 += j12\n        val sq13\
    \ = sq11\n        val j13 = j12\n        for(i <- 0 until sq13) sq12 += sq13\n\
    \        for(i <- 0 until sq13) j13 += j13\n        val sq14 = sq12\n        val\
    \ j14 = j13\n        for(", "        for (d <- 2 to sqrt(n)) {\n            if\
    \ (n%d == 0) return false\n        }\n        return true", "        var num :\
    \ Long = n\n        // First check if n is even and less than or equal to half\
    \ the prime number (11).\n        if (n % 2 == 0 && n <= 11) {\n            val\
    \ limit = n/2\n            var i : Long = 0\n            while (i <= limit) {\n\
    \                if (num % i == 0) return false\n                i += 1\n    \
    \        }\n            return true\n        }\n        // If n is less than or\
    \ equal to 3, then it is not prime. So, if n is less than 11, then\n        //\
    \ it is prime to begin with (since 5 is prime).\n        else if (n < 3) return\
    \ false\n        else if (n % 2 == 0) return false\n        else if (n <= 11)\
    \ return true\n        // Otherwise, there are only two prime numbers <= n <=\
    \ 19, so we can check for\n        // a divisor.\n        else { val limit = (n\
    \ - 3)/2; var i : Long = 0\n            while (i <= limit) {\n               \
    \ if (num % i == 0) return false\n                i += 1\n            }\n    \
    \        return true\n        }", "        val m = 2l\n        val lPrime = new\
    \ mutable.ArrayBuffer[Long]()\n        for (i <- 2l to math.ceil(math.sqrt(n))-1)\
    \ {\n            if(n % i == 0) {\n                lPrime += i\n             \
    \   m += 1\n            }\n        }\n        lPrime.toSet.size == 1", "     \
    \   val s = BigInt(n.toString.toInt)\n        val m = BigInt(n.toString.toInt).sqrt\n\
    \        val d = BigInt(n.toString.toInt).divide(BigInt(2))\n        val result\
    \ = true\n        if(m != BigInt(1)) return false\n        for(i <- 0 until d)\
    \ {\n            val s = BigInt(s.toString.toInt).multiply(BigInt(i+2))\n    \
    \        if(s.toLong < n) result = false\n        }\n        if(result) return\
    \ true\n        return false", "        val bound = (sqrt(n.toDouble) - 1.0).toInt\n\
    \        val primes = Vector.fill(bound)(true)\n        for (ip <- 2 to bound)\
    \ {\n            if (!primes(ip) && n % ip == 0) {\n                primes(ip)\
    \ = false;\n            }\n        }\n        primes.last == true", "        val\
    \ sqrt = math.pow(math.ceil(math.sqrt(n)), 2)\n        // check for odd values\n\
    \        if((n % 2) == 0) {\n            false\n        }\n        else {\n  \
    \          val isPrime = true\n            for(i <- 2 to sqrt) {\n           \
    \     if (n % i == 0) {\n                    isPrime = false\n               \
    \     break\n                }\n            }\n            if(isPrime) {\n   \
    \             true\n            }\n            else {\n                false\n\
    \            }\n        }", "        for {\n                x <- 2 to n\n    \
    \            if (n % x == 0)\n                    break\n        } yield false\n\
    \        return true", "        val sqr = (1l + sqrt(n).toLong)._2\n        val\
    \ num = (1l until sqr).toList\n        for (i<- num.iterator) {\n            if\
    \ (n % i == 0) {\n                return false\n            }\n        }\n   \
    \     return true", "        for (p <- 2 to sqrt(n)) {\n            if (n % p\
    \ == 0)\n                return false\n        }\n        true", "        assert(n\
    \ >= 2l, \"n must >= 2\");\n        for(i <- 2l until sqrt(n)) {\n           \
    \ if(n % i == 0)\n                return false;\n        }\n        return true;",
  "        // Check for divisors of 2\n        if (n == 1l) false\n        else if\
    \ (n == 0l) true\n        else {\n            // Check nth divisor against n-1\n\
    \            var i : Long = math.floor(math.sqrt(n).toInt)\n            while\
    \ (i < n) {\n                if (n % i == 0l) {\n                    n = n / i\n\
    \                } else {\n                    return false\n                }\n\
    \            }\n            if (n == 1l) true\n            else false\n      \
    \  }", "        if (n <= 1l) false\n        val sqrt = (1l * n).floor\n      \
    \  for (i = 1 until sqrt if n % i == 0l) yield false\n        true", "       \
    \ if (n == 0 || n == 1) return false\n        if (n == 2) return true\n      \
    \  var i : Long = n / 2\n        var rem = n % 2\n        while (i < n / 2) {\n\
    \            if (!rem) {\n                return true\n            }\n       \
    \     i += 1\n            rem = n % i\n        }\n        return false", "   \
    \     // if (n == 1L) return true\n        // if (n == 2L) return true\n     \
    \   // if (n % 2 == 0L) return false\n\n        // if (isPrime(n - 1L)) {\n  \
    \      // return true\n        // }\n\n        // if (isPrime(n - 3L)) {\n   \
    \     // return true\n        // }\n        // if (isPrime(n - 5L)) {\n      \
    \  // return true\n        // }\n        // if (isPrime(n - 7L)) {\n        //\
    \ return true\n        // }\n        // if (isPrime(n - 11L)) {\n        // return\
    \ true\n        // }\n        // if (isPrime(n - 13L)) {\n        // return true\n\
    \        // }\n        // if (isPrime(n - 17L)) {\n        // return true\n  \
    \      // }\n        // if (isPrime(n - 19L)) {\n        // return true\n    \
    \    // }\n        // if (isPrime(n - 23L)) {\n        // return true\n      \
    \  // }\n        // if (isPrime(n - 29L)) {\n        // return true\n        //\
    \ }\n        // if (isPrime(n - 31L)) {\n        // return true\n        // }\n\
    \        // if (isPrime(n - 37L)) {\n        // return true\n        // }\n  \
    \      // if (isPrime(n - 41L)) {\n        // return true\n        // }\n    \
    \    // if (isPrime(n - 43L)) {\n        // return true\n        // }\n      \
    \  // if (isPrime(n - 47L)) {\n        // return true\n        // }\n        //\
    \ if (isPrime(n - 53L)) {\n        // return true\n        // }\n        // if\
    \ (isPrime(n - 59L)) {\n        // return true\n        // }\n        // if (isPrime(n\
    \ - 61L)) {\n        // return true\n        // }\n        // if (isPrime(n -\
    \ 67L)) {\n        // return true\n        // }\n        // if (isPrime(n - 71L))\
    \ {\n        // return true\n        // }\n        // if (isPrime(n - 73L)) {\n\
    \        // return true\n        // }\n        // if (isPrime(n - 79L)) {\n  \
    \      // return true\n        // }\n        // if (isPrime(n - 83L)) {\n    \
    \    // return true\n        // }\n        // if (isPrime(n - 89L)) {\n      \
    \  // return true\n        // }\n        // if (isPrime(n - 97L)) {\n        //\
    \ return true\n        // }\n        // if (isPrime(n - 101L)) {\n        // return\
    \ true\n        // }\n        // if (isPrime(n - 107L)) {\n        // return true\n\
    \        // }\n        // ", "        val n = n.toInt\n        var i = 2\n   \
    \     val array = new Array[Int](31)\n        array(0) = 1\n        while (i <=\
    \ array.length) {\n            if (n % i == 0) {\n                i += 1\n   \
    \             if (i > array.length) {\n                    return false\n    \
    \            }\n            } else {\n                i += 1\n            }\n\
    \        }\n        return true", "        val max = (math.pow(n, 2) + (2l)) /\
    \ 2l\n        for{\n            i <- 0 until max\n            p <- primes(i) if\
    \ (i % p == 0)\n        } yield {\n            n mod p == 0\n        }\n     \
    \   == true", "        if(n % 2 == 0) false\n        else if(n % 3 == 0) false\n\
    \        else (2l ** n.toInt) <= (math.sqrt (n))", "        for(d <- 2 to (sqrt(n)-1)){\n\
    \            if(n % d == 0) return false\n        }\n        return true", " \
    \       if(n == 1)\n            true\n        else if(n % 2 == 0)\n          \
    \  false\n        else \n            for(i <- 3 to (Math.sqrt(n).toInt)) \n  \
    \              if((n % i == 0))\n                    false\n                else\n\
    \                    true", "        for (p <- 2 to (sqrt(n).toInt)) {\n     \
    \       if (n % p == 0) return false\n        }\n        return true", "     \
    \   val factors = scala.collection.mutable.HashSet.empty[Long]\n        for (x\
    \ <- 2 to (Math.sqrt(n).toInt)) {\n            if (n % x == 0) factors += x\n\
    \        }\n        return factors.size == n", "        // Check if n is prime\n\
    \        // If it is, return true\n        if ((n.toInt % 2) == 0)\n         \
    \   return false\n        val sqrt = Math.sqrt(n)\n        var i = 2\n       \
    \ while (i <= sqrt) {\n            if ((n % i) == 0)\n                return false\n\
    \            i += 1\n        }\n        return true", "        if (n == 2) true\n\
    \        else {\n            val isPrime = (2l *) primes(n)\n            if (isPrime\
    \ == null) false\n            else\n                if (n % isPrime != 0) false\n\
    \                else\n                    isPrime(n+1)\n        }", "       \
    \ def isPrimeHelper(n: Long, primes: List[Long], flag: Boolean) : Boolean = {\n\
    \            if (n == 2l) flag\n            else {\n                if (n % 2\
    \ == 0) false\n                else {\n                    primes match {\n  \
    \                      case p :: rest if p > n => false\n                    \
    \    case p :: rest => isPrimeHelper(n / p, rest, false)\n                   \
    \     case _ => isPrimeHelper(n, primes + 2l, flag)\n                    }\n \
    \               }\n            }\n        }\n        val primes = List.fill(10)(2l)\n\
    \        isPrimeHelper(n, primes, true)", "        if (n <= 1l) return false\n\
    \        var i = 2l\n        var remainder = n - 1l\n        while (i <= remainder)\
    \ {\n            while (n % i == 0l) i += 1\n            if (i == remainder) break\n\
    \            i += 1\n        }\n        return i == remainder", "      val primes\
    \ = mutable.ArrayBuffer.fill(n)(true).toSeq\n      def isPrimeIter(n: Long) :\
    \ Boolean = { if (n == 1) primes(n) else primes(n - 1) && isPrimeIter(n + 2) }\n\
    \      isPrimeIter(n)", "        val isPrime = (n until Math.sqrt(n)) forall (_\
    \ % _ == 0)\n        return isPrime", "        if (n < 2l) return false\n    \
    \    var isPrime = true\n        for (k <- 2 to n-1) if (n%k==0) isPrime = false\n\
    \        if (isPrime) return true\n        for (k <- 2 to n/2l-1) if (n%k==0)\
    \ return false\n        return isPrime", "        for(x <- 2 until Math.sqrt(n).toInt)\n\
    \            if(n % x == 0)\n                return false\n        return true",
  "        val limit = math.ceil(math.sqrt(n)) + 1\n        (2 to limit by -1).forall(p\
    \ => (n % p == 0) || (p < n / p))", "        if((n%2l) == 0)\n            return\
    \ false\n        if((n%3l) == 0)\n            return false\n        if(n==1l)\n\
    \            return true\n        val r = scala.math.floor(math.sqrt(n)).toInt\n\
    \        for(i <- 0 until r) {\n            if((n%(i+l) == 0)||(n%i==0))\n   \
    \             return false\n        }\n        return true", "        // Primes\
    \ are always odd.\n        n match {\n            case x if x < 2l   => false\n\
    \            case x if x <= 2l && x % 2l == 0 => true\n            case _ => isPrimeImpl(1l,\
    \ n, 2l)\n        }", "        val k = math.ceil(n)\n        for (i <- 2 to k)\
    \ {\n            if (n % i == 0) return false\n        }\n        return true",
  "        assert(n>1)\n        def isPrimeHelper(n : Long, i : Long) : Boolean =\
    \ \n            if(n <= 1) {\n                true\n            } else {\n   \
    \             if(n % i == 0) {\n                    isPrimeHelper(n, i+1)\n  \
    \              } else {\n                    false\n                }\n      \
    \      }\n        val result = isPrimeHelper(n, 2l) \n        if(!result) {\n\
    \            false\n        } else {\n            true\n        }", "        val\
    \ sqrtN = sqrt(n).toInt\n        for (i = 1; i < sqrtN; i++) {\n            if\
    \ (n % i == 0) {\n                return false\n            }\n        }\n   \
    \     return true", "        for (p <- 2 until Math.sqrt(n)) {\n            if\
    \ (n % p == 0) {\n                return false\n            }\n        }\n   \
    \     return true", "        for (i <- 1 to (n/2) if n % i == 0) {\n         \
    \   return false\n        }\n        return true", "        def isPrimeIter(n:\
    \ Long) : Boolean = {\n            if (n<=2) true\n            else if ((n % 2)\
    \ == 0) false else if (n%3 == 0) false else isPrimeIter(n-2)\n        }\n    \
    \    if (isPrimeIter(n)) {\n            true\n        } else {\n            false\n\
    \        }", "        val k = if (n == 0l) 2 else if (n % 2 == 0) 3\n        else\
    \ (n - 1)\n        for (i <- 3 to k) if (n % i == 0) return false\n        return\
    \ true", "        for (i <- 2 to (n/2) if n % i == 0) {\n            return false\n\
    \        }\n        return true", "        // Check that n is a Long.\n      \
    \  if (n != n || n < 1l || n > Math.pow(2, n)) {\n            // If n is not a\
    \ Long, or if n is outside the range 1..2, return false.\n            return false\n\
    \        }\n        // We are interested in numbers less than or equal to n.\n\
    \        var limit = n - 1l\n        // If n is greater than the squareroot of\
    \ 2l (that is, if n is a perfect square),\n        // then n is composite.\n \
    \       if (limit >= Math.pow(2, Math.sqrt(2l))) {\n            return true\n\
    \        }\n        // If n is exactly a square, then n is prime.\n        if\
    \ (limit == Math.pow(2, n)) {\n            return true\n        }\n        //\
    \ If n is divisible by a factor of 2 smaller than n, then n is prime.\n      \
    \  while (limit % 2l == 0) {\n            if (limit < n) break\n            limit\
    \ /= 2l\n        }\n        // If n is exactly a factor of 2, then n is prime.\n\
    \        if (limit == 2l) return true\n        // If we reached this point, limit\
    \ must be greater than 1, so n is not prime.\n        return false", "       \
    \ val bound = (n.toInt - 2l) / 2 + 2l\n        val sq = Math.sqrt(n)\n       \
    \ for (i<-0 until bound)\n            if (n.toInt - i == 0 || n.toInt - i - sq\
    \ == 0)\n                return false\n        return true", "        val numPrimes\
    \ : mutable.Set[Long] = mutable.Set()\n        var factor = 1l\n        var i\
    \ = 2l\n        while (i < n){\n            if (n % i == 0){\n               \
    \ numPrimes += i\n                factor *= i\n                numPrimes += factor\n\
    \            }\n            i += 2l\n        }\n        numPrimes.contains(n)",
  "        val divisors : (Long, Long) = (1l, 3l).productIterator // a tuple with\
    \ two elements\n        val divisorsCopy = divisors.toList // make a copy to prevent\
    \ modification\n        var isPrime = false\n        divisorsCopy.foreach {\n\
    \            d =>\n                if (n % d == 0)\n                    isPrime\
    \ = false\n                else\n                    isPrime = true\n        }\n\
    \        isPrime", "        if (n < 2l) return false\n        var check = 3l\n\
    \        while(check <= n) check = (check + 2l)\n        return (n == 2l || n\
    \ == 3l || check == 2l || check == 3l)", "        // if n is odd, then it is not\
    \ prime\n        if (n.toInt % 2 == 1)\n            return false\n\n        //\
    \ test all odd divisors up to n\n        var i = 2l\n        while (i < n) {\n\
    \            if (n % i == 0)\n                return false\n            i += 1l\n\
    \        }\n\n        // n has no odd divisors\n        return true", "      \
    \  var result : Boolean = false\n        var isPrime = true\n        var i : Long\
    \ = 1\n        var isPrime2 : Boolean = true\n        while (i < n) {\n      \
    \      isPrime2 = false\n            while (!isPrime2 && i < n) {\n          \
    \      if (n % i == 0) {\n                    isPrime2 = true\n              \
    \  } else {\n                    isPrime2 = false\n                }\n       \
    \         i += 1\n            }\n            isPrime = isPrime && isPrime2\n \
    \           i += 1\n        }\n        result", "        if(n<2l) return false\n\
    \        var d = 2l\n        while(d < n) d *= 2l\n        var isPrime = true\n\
    \        for(d <- 2l..n-1l) if(!(n%d)==0) isPrime = false\n        return isPrime",
  "        for (i <- 2 until n) \n            if (n % i == 0)\n                return\
    \ false\n        return true", "        if(n%2==0) false\n        else{\n    \
    \        val a = math.max(math.floor(math.sqrt(n)),2L)\n            for(i<-1 to\
    \ a)\n                if(n%i==0)\n                    false\n                else\n\
    \                    true\n        }", "        val lowPrime = List (2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97)\n        val highPrime = List (7, 13, 19, 31, 37, 61, 71, 73, 79, 83,\
    \ 89, 101)\n        n match {\n            case(2l) => (lowPrime).contains(n)\n\
    \            case(3l) => (lowPrime).contains(n)\n            case(4l) => (lowPrime).contains(n)\n\
    \            case(7l) => (lowPrime).contains(n)\n            case(11l) => (lowPrime).contains(n)\n\
    \            case(13l) => (lowPrime).contains(n)\n            case(17l) => (lowPrime).contains(n)\n\
    \            case(19l) => (lowPrime).contains(n)\n            case(23l) => (lowPrime).contains(n)\n\
    \            case(29l) => (lowPrime).contains(n)\n            case(31l) => (lowPrime).contains(n)\n\
    \            case(37l) => (lowPrime).contains(n)\n            case(41l) => (lowPrime).contains(n)\n\
    \            case(43l) => (lowPrime).contains(n)\n            case(47l) => (lowPrime).contains(n)\n\
    \            case(53l) => (lowPrime).contains(n)\n            case(59l) => (lowPrime).contains(n)\n\
    \            case(61l) => (lowPrime).contains(n)\n            case(67l) => (lowPrime).contains(n)\n\
    \            case(71l) => (lowPrime).contains(n)\n            case(73l) => (lowPrime).contains(n)\n\
    \            case(79l) => (lowPrime).contains(n)\n            case(83l) => (lowPrime).contains(n)\n\
    \            case(89l) => (lowPrime).contains(n)\n            case(97l) => (lowPrime).contains(n)\n\
    \            case(101l) => (lowPrime).contains(n)\n            case(333l) => (lowPrime).contains(n)\n\
    \            case(777l) => (lowPrime).contains(n)\n            case(999l) => (lowPrime).contains(n)\n\
    \            case(9999l) => (lowPrime).contains(n)\n            case(10001l) =>\
    \ (lowPrime).contains(n)\n            case(100", "        val result = true\n\
    \        def isPrimeHelper(n : Long) : Boolean = {\n            if (n <= 1) {\n\
    \                result = false\n                return result\n            }\n\
    \            val i = 2\n            while (i <= (n/2)){\n                result\
    \ = !result && (n % i == 0)\n                i += 1\n            }\n         \
    \   result\n        }\n        isPrimeHelper(n)", "        if(n%2l==0l) false\n\
    \        for(i <- 2l; n%i==0l && i>2l; i+=1l)\n            if(n%i==0l)\n     \
    \           return false\n        true", "        if(n < 2l) \n            false\n\
    \        else {\n            val d = 2l\n            val s = 3l\n            var\
    \ isPrime = true\n            var i = 2l\n            for(i <- 2l until n/d) if\
    \ ((n % i) == 0)\n                isPrime = false\n            if(isPrime) \n\
    \                for(i <- 2l until s) \n                    if(n % i == 0) \n\
    \                        isPrime = false\n            return isPrime\n       \
    \ }", "        if (isPrimeHelper <= n) return true\n        if (isPrimeHelper\
    \ == n+1) return false\n        val m = (2l*n + 1).longValue\n        if (isPrimeHelper+m\
    \ < n) isPrimeHelper = m + isPrimeHelper\n        else isPrimeHelper = isPrimeHelper+1\n\
    \        return isPrimeHelper%n == 0", "        for(i <- 2 to n/2) {\n       \
    \     if(n % i == 0) return false\n        }\n        return true", "        val\
    \ p = 2l\n        while (p <= (n.toInt + 1l))\n            if (n % p == 0)\n \
    \               return false\n            p += 1\n        return true", "    \
    \    if (n == 1L) false\n        else if (n == 2L) true\n        else if (n %\
    \ 2L == 0L) false\n        else if (n % 3L == 0L) false\n        else { val i\
    \ = 3L; for (k <- 3L to n by 2L) if (n % kL == 0L) false else { i = k; break }\
    \ } true", "        val primes = mutable.Set()\n        for (i <- 0 until n) primes.add(i)\n\
    \        primes.forall(n => (n / 2 % n) == 0)", "        if(n == 2)\n        \
    \    true\n        else if(n%3==0 || n%5==0)\n            false\n        else\n\
    \            if(n%3==0 || n%5==0)\n                false\n            else\n \
    \               if(n%3==0 || n%5==0)\n                    false\n            \
    \    else\n                    if(n%3==0 || n%5==0)\n                        false\n\
    \                    else\n                        if(n%3==0 || n%5==0)\n    \
    \                        false\n                        else\n               \
    \             isPrime(n - (3l))", "        if (n <= 0l) false\n        else {\n\
    \            // Prime numbers greater than one must be odd integers.\n       \
    \     val k = n\n            val limit = n + 1\n            var sq : Long = 1l\n\
    \            var isPrime : Boolean = true\n            var flag : Boolean = false\n\
    \            while (k <= limit) {\n                if ((k % 2l) == 0l) isPrime\
    \ = false\n                else {\n                    sq = (k * k).toLong\n \
    \                   k = sq + (2l to limit).toIterator\n                    flag\
    \ = true\n                }\n            }\n            if (isPrime && (!flag))\
    \ true\n            else false\n        }", "        // TODO: implement this\n\
    \        n", "        if (n == 0L) return false\n        if ((2L * n) == n) return\
    \ true\n        if (n % 2L == 0L) return false\n\n        // First check for divisibility\
    \ by 3.\n        if ((n + 1L) % 3L == 0L) return false\n\n        // Now the number\
    \ must be odd so it is safe to use \n        // the formula above to check primality.\
    \ \n        for (i = 3L; i <= Math.sqrt(n); i += 2L) \n            if (n % i ==\
    \ 0L) return false\n\n        return true", "        def isPrime(n : Long) : Boolean\
    \ = {\n            val l: Int = n\n            val r: Long = l\n\n           \
    \ if (l==0 || l==1)\n                return true\n            else if (r%2 ==\
    \ 0 || r%3 == 0)\n                return false\n            else if (l == r -\
    \ 1 || l == r + 1)\n                return true\n            else\n          \
    \      return isPrime(r/2)\n        }\n        val l: Int = n\n        val r:\
    \ Long = l\n\n        if (l==0 || l==1)\n            return true\n        else\
    \ if (r%2 == 0 || r%3 == 0)\n            return false\n        else if (l == r\
    \ - 1 || l == r + 1)\n            return true\n        else\n            return\
    \ isPrime(r/2)", "        val i = math.ceil(n/2)\n        val s = math.abs(n-i)\n\
    \        val m = 2l\n        val primes = (for (iprime <- Iterator(i) to s) yield\
    \ {\n            if(iprime > m && iprime < n)\n                m\n           \
    \ else\n                if(iprime * iprime > n)\n                    false\n \
    \               else\n                    iprime\n        })\n        primes.forall(p\
    \ => n % p == 0)", "        var result = false\n        val l = (n+1) >>> 1\n\n\
    \        while (l > 1) {\n            if (n % l == 0) {\n                result\
    \ = true\n            } else {\n                result = false\n             \
    \   break\n            }\n            l >>>= 1\n        }\n        result", " \
    \       if(n <= 1L) return false\n        var m : Long = 2L\n        while(m <=\
    \ n) if(n % m == 0) return false\n        true", "        if (n <= 3) return true\n\
    \        val div = math.floor(n/2)\n        if (n % 2 == 0)\n            if (div\
    \ % 2 == 0) true else false\n        else \n            if (div % 3 == 0) true\
    \ else false", "        var isPrime = true\n        var isDivisor = false\n\n\
    \        if(n <= 1l) return false\n\n        for (j <- (3l..n) ; j <- (3l..n)\
    \ ; j += 2l) {\n            if(j % n == 0) isPrime = false\n\n            if(n\
    \ % j == 0) isDivisor = false\n        }\n\n        if(isPrime && !isDivisor)\
    \ return true\n        return false", "        val a = 2l\n        val m = n /\
    \ a\n        (2l+m*m) <= n &&\n            (m < (2l+m*m))", "        for (i <-\
    \ 2 to n)\n            if (n % i == 0)\n                return false\n       \
    \ return true", "        for (d <- 2 until math.sqrt((n).toLong)) {\n        \
    \    if ((n % d) == 0)\n                return false\n        }\n        return\
    \ true", "        def isPrimeAcc(n : Long, acc : Int) : Boolean = {\n        \
    \    if (n == 1l) acc\n            else {\n                if (isPrimeAcc(n-1l,\
    \ acc+n)) \n                    isPrimeAcc(n+1l, acc)\n                else \n\
    \                    isPrimeAcc(2l, acc)\n            }\n        }\n        isPrimeAcc(n,0)",
  "        // The first six prime numbers are:\n        // 2, 3, 5, 7, 11, and 13.\n\
    \        // Only even numbers are odd.\n        // Therefore, if we divide by\
    \ 2, we\n        // discard the remainder.\n        val divisor = 2\n        var\
    \ i = 2\n        var isPrime : Boolean = true\n        var prime = false\n   \
    \     while (!isPrime && i <= n) {\n            if (n % i == 0)\n            \
    \    isPrime = false\n            else {\n                prime = true\n     \
    \           i += 1\n            }\n        }\n        if (prime && isPrime) {\n\
    \            true\n        }\n        else {\n            false\n        }", " \
    \       val i = 2\n        while (i <= n / 2) {\n            if (n % i == 0)\n\
    \                return false\n            i += 2\n        }\n        true", " \
    \       if (isPrimeHelper(n))\n            true\n        else\n            false",
  "        def loop(n: Long, i: Int, res: Set[Long]) : Boolean = n != 0 match {\n\
    \            case 0 | 1 | 2 | 3 | 5 | 7 | 11 |\n                13 | 17 | 19 |\
    \ 23 | 29 | 31 | 37 | 43 |\n                47 | 53 | 59 | 61 | 67 | 71 | 73 |\
    \ 79 |\n                83 | 89 | 97 => res\n            case _ =>\n         \
    \       val l = n - 1\n                if (res(l)) loop(n, i + 1, res)\n     \
    \           else {\n                    loop(l, (i, l) :: res)\n             \
    \   }\n        }\n        val r = scala.math.sqrt(n)\n        if (n == 0 || (n\
    \ / 2l) < 1l) false\n        else loop(n - 1l, 0 :: scala.collection.mutable.Set.empty)",
  "        val isPrime = (2l*2l*2l*2l*2l*2l*2l*2l*2l*2l*2l*2l*2l*2l <= n) match {\n\
    \            case true  => true\n            case false => n % 2 != 0\n      \
    \  }\n        n match {\n            case n if n == 1l => true\n            case\
    \ n           => isPrime\n        }", "        // Write your code here\n     \
    \   var num = 3\n        var res = true\n        if (n == 0) return false\n  \
    \      while (n != 1) {\n            if (n % 2 == 1) return false\n          \
    \  n /= 2\n        }\n        return true", "        for (d <- 2l to Math.sqrt(n)){\n\
    \            if ((n % d) == 0) return false\n        }\n        true", "     \
    \   var isPrime : Boolean = false\n\n        if (n < 1) {\n            isPrime\
    \ = false\n        }\n        else {\n            if (n == 1l) {\n           \
    \     isPrime = true\n            }\n            else {\n                val squareRoot\
    \ = (n.toInt) / Math.sqrt(n.toInt)\n                var squarePrime = squareRoot\n\
    \                while (squarePrime < squareRoot) {\n                    if (n\
    \ % squarePrime == 0l) {\n                        isPrime = false\n          \
    \              squarePrime = squarePrime + 1l\n                    }\n       \
    \             else {\n                        isPrime = true\n               \
    \         squarePrime = squarePrime + 1l\n                    }\n            \
    \    }\n            }\n        }\n        return isPrime", "        def isPrimeHelper(i\
    \ : Int, isPrimeNext : (Long) => Boolean) : Boolean = {\n            if (i % 2\
    \ == 0) {\n                isPrimeNext(n)\n            } else if ((n % i) != 0)\
    \ {\n                false\n            } else if (i == 1) {\n               \
    \ true\n            } else {\n                isPrimeHelper(i - 1, isPrimeNext)\n\
    \            }\n        }\n\n        val isPrimeNext : (Long) => Boolean = (i\
    \ : Long) => {\n            val isPrimeNextForPrimeTest = (i : Long) => {\n  \
    \              if (i % n == 0) {\n                    true\n                }\
    \ else {\n                    false\n                }\n            }\n\n    \
    \        val isPrimeNextForNonPrimeTest = (i : Long) => {\n                if\
    \ (i % n != 0) {\n                    false\n                } else {\n      \
    \              isPrimeNextForPrimeTest(i)\n                }\n            }\n\n\
    \            if (i < 3 && isPrimeNextForPrimeTest(i)) {\n                true\n\
    \            } else if (i > 5) {\n                false\n            } else {\n\
    \                isPrimeNextForNonPrimeTest(i)\n            }\n        }\n\n \
    \       val primeNumbers = Vector(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l,\
    \ 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l)\n\
    \n        (primeNumbers diff Seq(n)).isEmpty", "        // The prime number sequence\
    \ is defined as a sequence of natural numbers,\n        // where the prime numbers\
    \ are separated by natural numbers that divide them.\n        // The sequence\
    \ of natural numbers is denoted by N, from 2 to N-1.\n        // The sequence\
    \ of prime numbers is a natural number that is greater than or\n        // equal\
    \ to 2, and that has a multiplicative coeficient that is equal to 1 (i.e.\n  \
    \      // it is the only number that is evenly divisible by all natural numbers).\
    \ Since\n        // the sequence is a natural number, we can write N \u2212 1\
    \ \u2212 i as i\u22121, and have this\n        // relationship established: the\
    \ prime number n is greater than or equal to 2 if\n        // and only if 2\u22C5\
    n is divisible by all natural numbers greater than or equal to n.\n        //\
    \ Write a function that takes a natural number and returns the corresponding prime\
    \ number.\n        // >>> isPrime(6)\n        // (false)\n        // >>> isPrime(100)\n\
    \        // (false)\n        // >>> isPrime(111)\n        // (true)\n        //\
    \ >>> isPrime(13441)\n        // (true)\n        // >>> isPrime(61)\n        //\
    \ (true)\n        // >>> isPrime(4)\n        // (false)\n        // >>> isPrime(1)\n\
    \        // (false)\n        // >>> isPrime(2l)\n        // (false)\n        //\
    \ >>> isPrime(22l)\n        // (true)\n        // >>> isPrime(24l)\n        //\
    \ (false)\n        // >>> isPrime(6l-1)\n        // (false)\n        // >>> isPrime(2l)\n\
    \        // (false)\n        val primes = mutable.ArrayBuffer(2l).+:(2l).map(x\
    \ => x - (x-2l)).dropWhile(x => x % x != 0l).drop(1)\n        for (p <- primes)\
    \ if (n % p == 0) return false\n        true", "        // Check if number is\
    \ even\n        if(n % 2 == 0)\n            return false\n        // Check if\
    \ number is odd\n        else if(n % 2 != 0)\n            return true\n      \
    \  else\n            // Check if the number is prime\n            if(isPrimeHelper(n,\
    \ 2))\n                return true\n            else\n                // If it\
    \ is not, then it is not prime\n                return false", "        def isPrimeHelper(n\
    \ : Long, i : Long) : Boolean = {\n            if ((i%2) == 0) (true) else (\n\
    \                isPrimeHelper(n, i+1) ||\n                ((n%(i+2)) == 0) ||\
    \ ((n%i) == 0)\n            )\n        }\n        ((n%2) == 0) || (isPrimeHelper(n,\
    \ 2l))", "        if (n < 2l) return false\n        for (x <- 2l until n by 2l)\
    \ if (n % x = 0l) false\n        else true", "        def checkFactor (n:Long)\
    \ : Boolean = {\n            if (n % 2 == 0) {\n                return false\n\
    \            }\n            for (i <- 2 to (Math.sqrt(n.toDouble)) by 2) {\n \
    \               if (n % i == 0) {\n                    return false\n        \
    \        }\n            }\n            true\n        }\n        val nums = for\
    \ (i <- 2 to (n) by 2) yield i.toLong\n        for (n <- nums) {\n           \
    \ if (!checkFactor(n)) {\n                return false\n            }\n      \
    \  }\n        true", "        val s = BigInt(n.toString.reverse)\n        // Test\
    \ odd factors.\n        for (i = 1 to s.maxBound / 2) \n            if (s.mod(i).isZero)\
    \ \n                return false\n        // Test even factors.\n        val odd\
    \ = BigInt(n.toString.reverse).ceil\n        for (i <- 1 to odd) \n          \
    \  if (s.mod(i).isZero) \n                return false\n        return true",
  "        def findFactor(x: Long): Set[Long] = {\n            if (x == 1) return\
    \ Set(1l, x).toSet\n            val r = findFactor(x/2).head\n            (x%r\
    \ == 0 || r).forall(!_.isInstanceOf[Number])\n        }\n        findFactor(n).size\
    \ == n", "        def isPrimeSieve(i: Long, primes: mutable.Set[Long]) : Boolean\
    \ = {\n            if (i == 0) true\n            else {\n                val ps\
    \ = primes.iterator\n                if (ps.hasNext) {\n                    val\
    \ p = ps.next()\n                    if (isPrime(i / p)) true\n              \
    \      else {\n                        ps -= p\n                        isPrimeSieve(i\
    \ - p * p, ps)\n                    }\n                } else false\n        \
    \    }\n        }\n\n        val sieve = mutable.ArrayBuffer(2l)\n        for\
    \ (x <- 3l to n by 2)\n            if (isPrime(x, sieve)) sieve.update(x) += 1\n\
    \n        sieve.toSet == primes", "        // Check primality of n\n        val\
    \ lprimes = 2l..(n/2l)\n        val ldivisors = lprimes.filter( n => n%n == 0l)\n\
    \        if (ldivisors.isEmpty) true\n        else {\n            val ldivisors_product\
    \ = ldivisors.reduce( _ * _ )\n            if (ldivisors_product <= n) true\n\
    \            else\n                ldivisors_product < n &&\n                \
    \    (ldivisors_product % n == 0 || isPrime(n/ldivisors_product))\n        }",
  "        val sqrt = math.sqrt((n.toLong).toDouble - 1)\n        for (i <- 0 until\
    \ sqrt) if (n % i == 0) return false\n        return true", "        if (n <=\
    \ 1l) false\n        else if (n == 2l) true\n        else {\n            var isPrime\
    \ : Boolean = true\n            val i = 2l\n            while (i * i < n) {\n\
    \                isPrime = (n % i == 0l)\n                i ++= 2l\n         \
    \   }\n            isPrime\n        }", "        def sieve(n : Long) : Unit =\
    \ {\n            val arr = new Array[Boolean](n)\n            var i : Long = 0\n\
    \            var j : Long = 1\n            while (j < n) {\n                arr(i)\
    \ = true\n                j = 3 * i + 1\n                while (j < n) {\n   \
    \                 if (arr(j) = false) {\n                        j += i\n    \
    \                    arr(j) = true\n                    }\n                  \
    \  j += 2\n                }\n                i += 1\n            }\n        }\n\
    \n        sieve(n)\n        if (arr.contains(false)) {\n            return false\n\
    \        } else {\n            return true\n        }", "        if(n <= 0) return\
    \ false\n        if(n % 2 == 0) return false\n        val upperLimit = (sqrt(n)\
    \ + 1).ceil.toLong\n        for(i <- 2 to upperLimit) {\n            if(n % i\
    \ == 0) return false\n        }\n        return true", "        val factors =\
    \ primeFactors(n)\n        if(factors.isEmpty)\n            return true\n    \
    \    else if(factors.contains(n))\n            return true\n        else\n   \
    \         return false", "        val isPrime = True\n        if(n < 2l) isPrime\n\
    \        else if(n % 2l == 0l) isPrime\n        else (for( a <- 3l; if n % a ==\
    \ 0l ) yield {\n            isPrime = False\n        }).exists(isPrime)", "  \
    \      def isprime(n: Long): Boolean = {\n            // return true if a is prime\
    \ (and not 1)\n            if (n == 1l) true\n            // return false otherwise\n\
    \            else n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || (n % 7 == 0 && (n\
    \ % 9 == 0 || n % 11 == 0))\n        }\n        if ((n <= 1l) || (n == 2l)) true\
    \ else false", "        val sqrt = (Math.sqrt(n) + 1)\n        for((i : Int) <-\
    \ 0 until sqrt)\n            if(n % i == 0)\n                return false\n  \
    \      return true", "        val max = (2l * math.pow(3, Long.MaxValue)).toLong\n\
    \n        (2l until max).forall { i =>\n            if(n%i != 0) { return false\
    \ }\n            val mid = (n + i) / 2.toLong\n            if(!isPrime(mid)) {\
    \ return false }\n        }\n        true", "        val result = n%2 == 0\n \
    \       for (x3 <- 3 to (Math.sqrt(n).toLong - 1)){\n            val i = (x +\
    \ x3)/2\n            if (i % 2 == 0 && i != n) return false\n            x = x3\n\
    \        }\n        result", "        // Return true if n is prime, false otherwise\n\
    \        val l = new scala.collection.mutable.ListBuffer[Long]\n        var i\
    \ = 2\n        while (i <= n/2) {\n            l.append(i)\n            if (n\
    \ % i == 0) {\n                l.append(n%i)\n                i = 2\n        \
    \        l.append(i) // The number is not prime if and only if\n             \
    \   // i is not prime.\n            } else {\n                i = i + 1\n    \
    \        }\n        }\n        l.isEmpty", "        if(n < 1l) throw new IllegalArgumentException(\"\
    n should be positive\")\n        if(n <= 1l) true\n        else if(n <= 4l) isPrime1(n,\
    \ 3l, 5l)\n        else isPrime2(n, 3l, 5l)", "        val r = BigInt(n) + 1\n\
    \        var i = 2\n        while (i <= r) {\n            if (n % i == 0)\n  \
    \              return false\n            i += 1\n        }\n        true", " \
    \       if (n <= 1) false\n        if (n <= 3) true\n        val xs = List(2,\
    \ 3, 4, 7, 11, 13, 17, 19)\n        var divisor = 2\n        var prime = true\n\
    \        var limit = xs.last\n        while (prime && limit <= Math.sqrt(n)) {\n\
    \            if (n % divisor == 0) {\n                prime = false\n        \
    \    }\n            else {\n                divisor++\n            }\n       \
    \     limit += 1\n        }\n        return prime", "        if (n < 2l) false\n\
    \        else {\n            val m = scala.math.ceil(n / 2l)\n            val\
    \ left = if (n % 2l == 0l) m else m - 1\n            var isPrime = true\n    \
    \        val right = m - left\n            for (i <- 1 to right) {\n         \
    \       if ((n % 2l == 0l) && (n % i) == 0l) {\n                    isPrime =\
    \ false\n                }\n            }\n            isPrime\n        }", " \
    \       val s = BigInteger.valueOf(n).toBigInt\n        if(s.equals(BigInteger.valueOf(2)))\
    \ true\n        else if(s.equals(BigInteger.valueOf(3)) || s.equals(BigInteger.valueOf(4))\
    \ || s.equals(BigInteger.valueOf(5))) true\n        else s % 2 == 0 || s % 3 ==\
    \ 0", "        val max = (3l*(n-1l)).toInt\n        val i = 2\n        while (i\
    \ <= max) {\n            if (n % i == 0) return false\n            i += 1\n  \
    \      }\n        return true", "        // Return true if the number is prime.\
    \ Otherwise, return false.\n        val isPrime = (0 until n) contains n\n   \
    \     if (isPrime) {\n            true\n        } else {\n            false\n\
    \        }", "        val sqroot = Math.sqrt(n)\n        val i = 2\n        var\
    \ bool = false\n        while(i <= sqroot) {\n            if (n % i == 0) {\n\
    \                bool = false\n                break\n            }\n        \
    \    bool = true\n            i += 1\n        }\n        bool", "        val N\
    \ = n.toInt\n        if (N < 2)\n            true\n        else if (N == 2)\n\
    \            true\n        else if (N % 2 == 0)\n            false\n        else\
    \ {\n            var i = 2\n            while (i < N) {\n                if (N\
    \ % i == 0)\n                    false\n                i += 1\n            }\n\
    \            true\n        }", "        val a = 2l\n        val b = 5l\n     \
    \   val c = 6l\n\n        val divisors = scala.collection.mutable.Set[Long]()\n\
    \n        while (n == 0 || n == 1l){\n            if (n % 2l == 1l){\n       \
    \         divisors += 2l\n                divisors += n/4l\n            }\n  \
    \          else if (n % 5l == 1l){\n                divisors += 5l\n         \
    \       divisors += n/3l\n            }\n            else if (n % 6l == 1l){\n\
    \                divisors += 6l\n                divisors += n/4l\n          \
    \      divisors += n/3l\n            }\n            else{\n                divisors\
    \ += n\n            }\n            n += 1l\n        }\n        val primes = scala.collection.mutable.Set[Long]()\n\
    \        for (divisor <- divisors){\n            primes += divisor\n        }\n\
    \        primes.forall(p => n % p == 0l)", "        if(n%2l==0){\n           \
    \ if(n<3l){\n                return true\n            }\n            else{\n \
    \               for(a : Long <- 3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l\
    \ until (n-1l)){\n                    if(a>n){\n                        break\n\
    \                    }\n                    else{\n                        if(a%n==0){\n\
    \                            return false\n                        }\n       \
    \             }\n                }\n                return true\n            }\n\
    \        }\n        else{\n            for(a : Long <- 3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l*3l\
    \ until (n-1l)){\n                if(a%n==0){\n                    return false\n\
    \                }\n            }\n            return true\n        }", "    \
    \    val s = Stream.from(2l).takeWhile(x => x <= n)\n        s.forall(i => n %\
    \ i == 0)", "        if (n == 1l) true\n        else (n != 0l) && {\n        \
    \    val (d, r) = n / 2l match {\n                case 0 => (0l, 1l)\n       \
    \         case 1 => (1l, 1l)\n                case _ => (n-1l, n % 2l)\n     \
    \       }\n            d match {\n                case 1l if (r == 0) => isPrime(d)\n\
    \                case 1l => true\n                case 0 => isPrime(d)\n     \
    \           case _ => isPrime(d)\n            }\n        }", "        for ( i\
    \ <- 2 to n-1) {\n            if (n % i == 0)\n                return false\n\
    \        }\n        return true", "        val prime = mutable.Set[Long]()\n \
    \       (2 to (Math.sqrt(n)) + 1l) foreach {\n            i =>\n            if\
    \ (n % i == 0l) prime += i\n        }\n        (n != 1l) && prime.isEmpty", " \
    \       val max = Math.sqrt(n)\n        var sum = 0\n        (1 to max) foreach\
    \ { i =>\n            val isPrime = n % i != 0\n            if (isPrime) sum +=\
    \ i\n        }\n        return (n == sum)", "        // Return true if the number\
    \ is odd.\n        // >>> isPrime((5l))\n        // (false)\n        // >>> isPrime((2l))\n\
    \        // (true)\n        n match {\n            case 2 | 3 | 5 | 7 | 11 |\n\
    \                  13 | 17 | 19 | 23 | 29 |\n                  31 | 37 | 41 |\
    \ 43 | 47 |\n                  53 | 59 | 61 | 67 | 71 |\n                  73\
    \ | 79 | 83 | 89 | 97 |\n                  101 |\n                  127 =>\n \
    \               false\n            case _ =>\n                def sqrt_of_last_to_int\
    \ (x:Long) =\n                    if (x <= 0) x\n                    else x >>\
    \ 1\n                val last_prime_multiple = sqrt_of_last_to_int(n)\n      \
    \          def prime_checker(x : Long) =\n                    if (x < 2) false\n\
    \                    else if (x == 2) true\n                    else (x == last_prime_multiple)\
    \ ^ prime_checker(x + last_prime_multiple)\n                (n until sqrt_of_last_to_int(n).toInt)\
    \ forall prime_checker\n        }", "        val i = 2l\n        val divs: scala.collection.mutable.Set[Long]\
    \ = scala.collection.mutable.Set()\n        while (i < n) {\n            if (n\
    \ % i == 0l) {\n                divs += i\n                i += 2\n          \
    \  }\n            else {\n                i += 1\n            }\n        }\n \
    \       if (divs.size == 1l) {\n            (divs.size == n.toString.toInt)\n\
    \        }\n        else {\n            (divs.size != n.toString.toInt)\n    \
    \    }", "        val isPrime = (2l) match {\n            case x if (n % x) ==\
    \ 0  =>  true\n            case x if (n % x) == 0  => false\n            case\
    \ x =>  true\n        }\n        // A number n greater than 2 is not prime if\
    \ any of its divisors are greater than n.\n        n match {\n            case\
    \ x if x > 2l  =>\n                val divisors = (2l) :: (3l) :: (4l) :: (5l)\
    \ :: (6l) :: (7l) :: (8l) :: (9l) :: (10l) :: (x-1l) :: (Nil)\n              \
    \  divisors.exists(x => n%x != 0)\n            case x if x < 2l =>\n         \
    \       isPrime\n            case _ => false\n        }", "        (2l).until(n)\
    \ match {\n            case _ if n == 0l => true\n            case _ => n % 2l\
    \ == 0l && (isPrime(n/1l) || isPrime(n/3l))\n        }", "        assert(n >=\
    \ 2)\n        for(x <- 2 to (sqrt(n))) {\n            if (n % x == 0) {\n    \
    \            return false\n            }\n        }\n        true", "        for\
    \ (x <- 2l; x <- n-l) if (n % x) == 0 {\n            return false\n        }\n\
    \        return true", "        var flag : Boolean = false\n        if (n <= 1l)\n\
    \            return false\n        if (n % 2 == 0 || n == 1l)\n            return\
    \ false\n        if (n % 3 == 0 || n % 2 == 1l || n == 3l)\n            return\
    \ false\n        for (i <- 3l*4l to (6l*6l)) {\n            if ((n % (i + 1l))\
    \ != 0l)\n                flag = true\n            if (n % i == 0l)\n        \
    \        flag = true\n        }\n        return flag", "        // Write your\
    \ code here.\n        val max = (scala.math.BigInt(1)/scala.math.BigInt(n)).toInt\n\
    \        for (i <- 1 to max) {\n            if (n % i == 0)\n                return\
    \ false\n        }\n        return true", "        for {\n            (x , y)\
    \ = (2l, 3l)\n        }\n        while( (n % x) == 0 ) y *= 2\n        for (x\
    \ <- 1l..(y-1)){\n            if (n % x == 0) return false\n        }\n      \
    \  return true", "        if (n < 2) false\n        val i = 2l\n        val d\
    \ = 2l\n        val m = 3l\n        var sq = Long.MaxValue\n        while (i<sq)\
    \ {\n            if (n % d == 0) return false\n            if (n == m || n % m\
    \ == 0) return false\n            if (m > n/m) sq = m + (n*(n+1)/m)\n        \
    \    else sq = (i*(i-1))/2\n        }\n        return true", "        if (n%2\
    \ == 0 || n%3 == 0)\n            return false\n        else if (n%5 == 0)\n  \
    \          return true\n        else\n            for (x <- 1 to (n/2))\n    \
    \            if (n%x == 0)\n                    return false\n               \
    \ else if (x == 3) {\n                    val a = scala.math.BigInt(n).divide(BigInt(x))\n\
    \                    if (a%6 == 0)\n                        return true\n    \
    \            }\n            true", "        val mods = Array.fill(n+1)(2l).filter(_\
    \ % _ == 0)\n        val primes = Set.empty[Long]\n        (2l..n) foreach { n\
    \ =>\n            if ((mods.last + mods.head + 1) != n) return\n            primes\
    \ += n\n            mods.drop(1).forall(mods.last + _ % _ == 0)\n        }\n \
    \       primes.size == n", "        if (n < 2l) false\n        else if (n <= 1l)\
    \ true\n        else {\n            var i = 2l\n            while (i <= n) { if\
    \ (!n % i) false; i = i + 2l; }\n        }", "        if (n == 1L)\n         \
    \   return false\n        // check if n is divisible by 2, or is evenly divisible\
    \ by 3\n        if (n % 2 == 0 || n <= 1 || (n % 3 == 0) && (n != 1) && (n !=\
    \ 2) && (n != 3) )\n            return false\n        // check if n is divisible\
    \ by 5\n        if (n % 5 == 0)\n            return false\n        // if n is\
    \ divisible by both 2 and 3, then it is not prime\n        if ((n % 2 == 0) &&\
    \ (n % 3 == 0))\n            return false\n        // if n is divisible by 2 or\
    \ 3, then it is prime\n        return true", "        def helper(n:Long):Boolean\
    \ = if (n == 1l) true\n        else n % 2 != 0l && n != 1l && n != 3 && !helper(n\
    \ - 2l) && helper(n - 3l) \n        \n        def isPrime(n:Long):Boolean = helper(n)\n\
    \        \n        isPrime(n) ", "      if (n == 1l) return false\n      if (n\
    \ == 0l) return true\n      if (n == -1l) return true\n\n      val m = math.ceil(sqrt(n)).toInt\n\
    \      var i = 2l\n      while (i <= m) {\n        if (n % i == 0l) return false\n\
    \        i += 1\n      }\n\n      return true", "        if(n == 1) return true\n\
    \        if(n == 2) return true\n        if(n == 0) return false\n\n        if(n\
    \ % 2 == 0) return false\n\n        for(i <- 3 to (sqrt(n) - 1l)) {\n        \
    \    if(n == i || n % (i + 1l) == 0) return false\n        }\n\n        return\
    \ true", "        def isPrimeHelper(n: Long) : Boolean = {\n            if (n\
    \ <= 1L) {\n                return true\n            }\n            var primeFound\
    \ = false\n            val upperBound = math.ceil(n/2)\n            val lowerBound\
    \ = 0L\n            // Loop through all odd numbers from 2 to upperBound, inclusive.\n\
    \            // If none of them divide n, then n is prime.\n            for (i\
    \ <- 2L to upperBound by 2) {\n                if (n % i == 0L) {\n          \
    \          primeFound = false\n                    break\n                } else\
    \ {\n                    primeFound = true\n                }\n            }\n\
    \            if (primeFound == false) {\n                return false\n      \
    \      } else {\n                return isPrimeHelper(lowerBound)\n          \
    \  }\n        }\n        return isPrimeHelper(n)", "        val a = 3l\n     \
    \   // the number must be greater than 1\n        if (n < 1l) false\n        if\
    \ (n == 1l) true\n        if (n == 0l) false\n        // Only odd numbers are\
    \ tested\n        while (n % 2l == 0l) n /= 2l\n        val limit = sqrt(n).toLong\n\
    \        val factors = mutable.ListBuffer[Long]()\n        // Test all factors\n\
    \        while(n-- > 0) {\n            val testDivisor = n / a\n            if\
    \ (testDivisor == 0l) false\n            if (factors.contains(testDivisor)) false\n\
    \            factors += testDivisor\n        }\n        return factors.size ==\
    \ 1", "        if(n <= 1l) false\n        else if(n % 2l == 0l) false\n      \
    \  else if(n % 3l == 0l) false\n        else if(n % 5l == 0l) false\n        else\
    \ if(n % 7l == 0l) false\n        else {\n            var mutable primesCount\
    \ = 1\n            var mutable primesTable = new mutable.HashMap[Long, Boolean]\n\
    \            for(i <- 1l to n) primesTable += i -> isPrime(i)\n            primesCount\
    \ += primesTable.length\n            primesCount -= 1\n            primesTable\
    \ += (n -> (primesCount > 0l))\n            primesTable -= 7l\n            primesTable\
    \ -= 5l\n            primesTable -= 3l\n            primesTable -= 2l\n      \
    \      primesTable -= 1l\n            for(i <- 1l until primesCount) {\n     \
    \           if(primesTable.get(i))\n                    return false\n       \
    \     }\n            true\n        }", "        if (n <= 1) false\n        val\
    \ sqrtN = (2l*sqrt(n))\n        (2l until sqrtN) forall { e => n % e != 0 } &&\n\
    \            (2l until sqrtN - 1) forall { e => n % e != 0 }", "        val a\
    \ = (2l * 3l).toLong\n        val b = (7l * 11l).toLong\n        val c = n\n \
    \       // Check if n is prime\n        for( i <- a until (n-1l) ) \n        \
    \    if ((n % i) == 0) \n                return false\n        // Check if n is\
    \ a perfect power\n        for( i <- b until (n-1l) ) \n            if ((n % i)\
    \ == 0) \n                return false\n        // Check if n is divisible by\
    \ 2 or 3\n        for( i <- c until (n-1l) ) \n            if ((n % i) == 0 )\
    \ \n                return false\n        return true", "        // Write your\
    \ code here.\n        // Hint : Try using the prime number theorem.\n        if(n\
    \ <= 1){\n            return false\n        }\n        var primes = Vector.fill(n\
    \ - 1){false}\n        val div = Iterator.continually(long2Int((2l*i).toLong)).takeWhile(_\
    \ < n).takeWhile(_ > 1).tail\n        val divInts = div.map(_*2l).toList\n   \
    \     var num : Long = 1l\n        var inc : Boolean = true\n        while (inc)\
    \ {\n            inc = false\n            for (divInt <- divInts) {\n        \
    \        val div = (num / divInt).toInt\n                primes(div) = true\n\
    \                if (num % divInt == 0) {\n                    inc = true\n  \
    \                  break\n                }\n                num+=1l\n       \
    \     }\n        }\n        return primes.reduce(false){case (acc, val) => acc\
    \ || val}", "        val a = new Array[Long](2)\n        a(0) = n\n        a(1)\
    \ = 1l\n        val b = a(0)\n        val c = a(1)\n        var count = 0\n  \
    \      for (i <- 1L to n-1) {\n            if (i%b == 0 || i%c == 0) {\n     \
    \           count = count + 1\n            }\n        }\n        if (count > 1)\
    \ {\n            return false\n        }\n        else {\n            return true\n\
    \        }", "        // Write your code here!\n        val list = mutable.ListBuffer[Long]()\n\
    \        list += 2l\n        list += 3l\n        list += 5l\n        list += 7l\n\
    \        list += 11l\n        list += 13l\n        list += 17l\n        list +=\
    \ 19l\n        list += 23l\n        list += 29l\n        list += 31l\n       \
    \ list += 37l\n        list += 41l\n        list += 43l\n        list += 47l\n\
    \        list += 53l\n        list += 59l\n        list += 61l\n        list +=\
    \ 67l\n        list += 71l\n        list += 73l\n        list += 79l\n       \
    \ list += 83l\n        list += 89l\n        list += 97l\n        list += 101l\n\
    \        list += 103l\n        list += 107l\n        list += 109l\n        list\
    \ += 113l\n        list += 127l\n        list += 131l\n        list += 137l\n\
    \        list += 139l\n        list += 147l\n        list += 151l\n        list\
    \ += 157l\n        list += 163l\n        list += 171l\n        list += 173l\n\
    \        list += 179l\n        list += 181l\n        list += 191l\n        list\
    \ += 193l\n        list += 197l\n        list += 199l\n        list += 211l\n\
    \        list += 223l\n        list += 227l\n        list += 229l\n        list\
    \ += 233l\n        list += 239l\n        list += 241l\n        list += 243l\n\
    \        list += 247l\n        list += 251l\n        list += 253l\n        list\
    \ += 257l\n        list += 263l\n        list += 269l\n        list += 271l\n\
    \        list += 277l\n        list += 281l\n        list += 283l\n        list\
    \ += 293l\n        list += 297l\n        list += 301l\n        list += 303l\n\
    \        list += 307l\n        list += 311l\n        list += 313l\n        list\
    \ += 317l\n        list += 319l\n        list += 323l\n        list += 327l\n\
    \        list += 331l\n        list += 337l\n        list += 347l\n        list\
    \ += 349", "        if (n == 0) true\n        else {\n            // We know that\
    \ n is odd if and only if it is not equal to 0\n            // because it is used\
    \ in the following test.\n            val l = n >>> 0\n            if (n == 1l)\
    \ false\n            else {\n                if (l % 2 == 0) false\n         \
    \       else {\n                    // n is odd, so n-1 must be even\n       \
    \             val r = n-1\n                    if (r % 2 == 0) false\n       \
    \             else {\n                        // If n-1 is even, then n+1 must\
    \ be odd\n                        val s = n+1\n                        if (s %\
    \ 2 == 0) false\n                        else {\n                            val\
    \ a = (r + (s >>> 1)) / 2  ;\n                            val b = (r + (s >>>\
    \ 1)) / 2  ;\n                            val c = r / 2               ;\n    \
    \                        val d = (s - (a >>> 1)) / 2  ;\n                    \
    \        val e = (c - (a >>> 1)) / 2  ;\n                            val f = (c\
    \ - (b >>> 1)) / 2  ;\n                            val g = (e - (b >>> 1)) / 2\
    \  ;\n                            val h = (f - (a >>> 1)) / 2  ;\n           \
    \                 val i = (d - (a >>> 1)) / 2  ;\n                           \
    \ val j = (f - (c >>> 1)) / 2  ;\n                            val k = (h - (c\
    \ >>> 1)) / 2  ;\n                            val l = (i - (c >>> 1)) / 2  ;\n\
    \                            val m = (j - (e >>> 1)) / 2  ;\n                \
    \            val n = (m - (e >>> 1)) / 2  ;\n                            val p\
    \ = (k - (e >>> 1)) / 2  ;\n                            val q = (l - (f >>> 1))\
    \ / 2  ;\n                            val r = (p - (f >>> 1)) / 2  ;\n       \
    \                     val s = (q - (g >>> 1)) / 2  ;\n                       \
    \     val t = (r - (g >>> 1)) / 2  ;\n                            val u = (t -\
    \ (h >>> 1)) / 2  ;\n                            val v = (u - (h >>> 1)) / 2 \
    \ ;\n                            val w = (v - (i >>> 1)) / 2  ;\n            \
    \                val x = (w - (i >>> 1)) / 2  ;\n                            val\
    \ y = (x - (j >>> 1)) / 2  ;\n                            val z = (y - (k >>>\
    \ 1)) / 2  ;\n                            val zz = (z - (l >>> 1)) / 2  ;\n  \
    \                          val qq = zz + (zz >>> 1)  ;\n                     \
    \       val qqq = qq + (qq >>> 1)  ;\n                            val qqqq = qqqq\
    \ + (qqqq >>> 1)  ;\n                            val qqqqq = qqqqq + (qqqqq >>>\
    \ 1)  ;\n                            val qqqqqq = qqqqqq + (", "        var i\
    \ : Long = 0\n        while (i != 1) {\n            if (n <= 1)\n            \
    \    return false\n            i = i + 1\n            n = n/2\n        }\n   \
    \     if (n == 1)\n            return true\n        return false", "        if\
    \ (n <= 1) return false;\n        for (d <- 2 until Math.sqrt(n))\n          \
    \  if (n % d == 0) return false;\n        return true;", "        var sum = 0\n\
    \        var prime = true\n        for (i <- 2 to math.floor(math.sqrt(n)) by\
    \ 2) {\n            if (n % i == 0)\n                sum++\n            else\n\
    \                break\n        }\n        if (sum == n && n != 1)\n         \
    \   prime = false\n        return prime", "        val sqrt = Math.sqrt(n)\n \
    \       if (n < 2) true\n        else {\n            for (x <- 2 to sqrt) {\n\
    \                if (n % x == 0) return false\n            }\n            true\n\
    \        }", "        if (n % 2 == 0 || n % 3 == 0) {\n            return false\n\
    \        }\n        var i = 5\n        while (i < (n / 2)) {\n            if (n\
    \ % i == 0 || n % (i + 2) == 0) {\n                return false\n            }\n\
    \            i += 6\n        }\n        return true", "        if (n%2 == 0)\n\
    \            return false\n        if (n%2 != 0 && n%3 != 0)\n            return\
    \ false\n        var i = 5\n        while (i <= n.toInt){\n            if ((n\
    \ % i) == 0)\n                return false\n            i = i*5 + 1\n        }\n\
    \        return true", "        var isPrime = false\n        for (d <- 2 to n.toInt)\
    \ if(n % d == 0) isPrime = true\n        isPrime", "        if (n < 2)\n     \
    \       return false\n        if (n == 2)\n            return true\n        val\
    \ d = 1\n        while ((d * d) <= n)\n            if (n % d == 0)\n         \
    \       return false\n            d += 1\n        return true", "        // TODO:\
    \ Find a way of doing this without using an infinite loop.\n        (2l*n <= n)\
    \ && ((n/2l) <= 1l*n)", "        if (n < 2) \n            false\n        else\
    \ {\n            val factors = mutable.Set[Long]()\n            while (n > 1)\
    \ {\n                if (n % 2 == 0) {\n                    factors += 2\n   \
    \             }\n                if (n % 3 == 0) {\n                    factors\
    \ += 3\n                }\n                if (n % 5 == 0) {\n               \
    \     factors += 5\n                }\n                n /= 2\n            }\n\
    \            factors foreach (p => factors += p)\n            factors contains\
    \ n\n        }", '        (2 until Math.sqrt(n)) exists (n mod _ == 0)', "   \
    \     var i = 2\n        var flag = false\n        var maxi = 2l\n        while(i\
    \ <= maxi && !flag)\n        {\n            if(n%i == 0)\n            {\n    \
    \            flag = true\n            }\n            else if(i == n.toInt)\n \
    \           {\n                flag = true\n            }\n            else\n\
    \            {\n                i += 1\n            }\n        }\n        if(!flag)\n\
    \        {\n            return false\n        }\n        else\n        {\n   \
    \         return true\n        }", "      val sqrt: Double = Math.sqrt(n).toDouble\n\
    \      var flag = true\n\n      for (x <- 2 to sqrt) {\n        if(n % x == 0)\
    \ flag = false\n      }\n      flag", "        def isPrimeIteratee() : Boolean\
    \ = {\n            if (n % 2 == 0) {\n                false\n            } else\
    \ if (n % 3 == 0) {\n                true\n            } else {\n            \
    \    val isPrimeIteratee = isPrimeIteratee\n                isPrimeIteratee(n\
    \ % 5)\n            }\n        }\n        def isPrimeFactorizer(n : Long) : Long\
    \ = {\n            if (n <= 1) 1\n            else {\n                val isPrimeIteratee\
    \ = isPrimeIteratee\n                (isPrimeIteratee(n) * n).toLong\n       \
    \     }\n        }\n        val prime = isPrimeFactorizer(n)\n        prime ==\
    \ 1", "        if (n < 2l) return false\n        // Test for divisors\n      \
    \  for (i = 1l; i < n; i += 1l)\n            if (n % i == 0l) return false\n \
    \       return true", "        if (n < 2) {\n            return false\n      \
    \  }\n        var i = 2\n        var numPrime = 1\n        while (i < n) {\n \
    \           if (n % i == 0) {\n                return false\n            }\n \
    \           numPrime = numPrime + 1\n            i = i + 1\n        }\n      \
    \  return numPrime == n", "        val i = 2l\n        while (i <= Math.sqrt(n))\
    \ {\n            if (n % i == 0l) {\n                return false\n          \
    \  }\n            i += 1\n        }\n        return true", "        if(n<2) return\
    \ false\n        if(n<3l) return true\n        if(isPrime(2n+2l)) return true\n\
    \        val maxN = math.max(n,3l)\n        for(i<-2 until maxN) {\n         \
    \   val d = n-i\n            if(d>0 && i<d+2 && isPrime(d)) {\n              \
    \  return true\n            }\n        }\n        return false", "        if (n\
    \ < 2) return false\n        var max = math.abs(n)\n        var d = 2\n      \
    \  while (d*d <= max) {\n            if (n % d == 0) return false\n          \
    \  d += 1\n        }\n        return true", "        for (i <- 1 to (n / 2)) {\n\
    \            if (n % i == 0) {\n                return false\n            }\n\
    \        }\n        return n == 1", "        val d = 2l\n        val i = (2l *\
    \ n).toInt\n        for(i <- 2l until i by d){\n            if(n % i == 0){\n\
    \                return false\n            }\n        }\n        true", "    \
    \    def isPrimeImpl(n: Long, n: Long, d: Long, primes: scala.collection.mutable.Set[Long]\
    \ = Set.empty): Boolean = {\n            if (n == 1) {\n                primes.add(1)\n\
    \                return true\n            }\n            if (n % 2 == 0) {\n \
    \               return false\n            }\n            val i = 3\n         \
    \   while (i <= Math.ceil(n)) {\n                if (n % i == 0) {\n         \
    \           return false\n                }\n                i += 2\n        \
    \    }\n            primes.add(n)\n            return true\n        }\n      \
    \  isPrimeImpl(n, n, 2l)", "        n match {\n            case 2 | 3 | 5 | 7\
    \ | 11 | 13 | 17 | 19 | 23 | 29 | 31 | 37 | 41 | 43 | 47 | 53 | 59 | 61 | 67 |\
    \ 71 | 73 | 79 | 83 | 89 | 97 => true\n            case _ => { \n            \
    \    val divisors      = List(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n                val factors\
    \        = List(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97)\n                val divisorFactors = divisors.zip(factors).filter(_._1\
    \ == _._2)\n                val largestDivisor = divisorFactors.sortBy(_._1).reverse.head._1\n\
    \                val rootOfDivisor  = divisorFactors.filter(_._1 == largestDivisor).sortBy(_._2).head._2\n\
    \                divisorFactors.map(_._2).contains(rootOfDivisor)\n          \
    \  }\n        }", "        var factorsNeeded = (2 until Math.sqrt(n)).length\n\
    \        for(i <- 0 until factorsNeeded) {\n            val primeFactor = n.toInt\
    \ / Math.pow(2l, i)\n            if(!(factorsNeeded - 1)) {\n                if(primeFactor.toLong\
    \ == n) {\n                    return true\n                } else {\n       \
    \             factorsNeeded -= 1\n                }\n            }\n         \
    \   factorsNeeded -= 1\n        }\n        return false", "        if (n <= 1l)\
    \ false\n        else n % 2 != 0 && for( _ <- 3l to n by 2l) yield false", " \
    \     if (n == 1L) false\n      else if (n % 2L == 0L) false\n      else {\n \
    \       var i = 2L\n        var factors = mutable.Set[Long]()\n        while (i\
    \ < n) {\n          if (n % i == 0L) {\n            factors += i\n           \
    \ if (factors.size < n) i += 1\n            else return false\n          }\n \
    \         i += 1\n        }\n        return true\n      }"]
stop_tokens:
- "\n    }\n"
