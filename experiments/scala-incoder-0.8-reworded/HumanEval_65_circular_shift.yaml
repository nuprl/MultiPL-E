name: HumanEval_65_circular_shift
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Circular shift the digits of the integer x, shift the digits right by shift\n\
  \    // and return the result as a string.\n    // If shift > number of digits,\
  \ return digits reversed.\n    // >>> circularShift((12l), (1l))\n    // (\"21\"\
  )\n    // >>> circularShift((12l), (2l))\n    // (\"12\")\n    def circularShift(x\
  \ : Long, shift : Long) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(circularShift((100l),\
  \ (2l)).equals((\"001\")));\n    assert(circularShift((12l), (2l)).equals((\"12\"\
  )));\n    assert(circularShift((97l), (8l)).equals((\"79\")));\n    assert(circularShift((12l),\
  \ (1l)).equals((\"21\")));\n    assert(circularShift((11l), (101l)).equals((\"11\"\
  )));\n    }\n\n}\n"
completions: ["        if (shift <= x.toString().length)\n            return x.toString()\n\
    \        else {\n            val digits = x.toString().substring(0, shift)\n \
    \           val reversed = digits.replace(s\"${digits.length - shift, 0}\", \"\
    \")\n            digits + reversed\n        }", "        val s = x.toString.reverse.charAt(0).toCharArray.take(shift+1).mkString\n\
    \        (if (shift > s.length) s else s.reverse)", "        var temp = x.toString.reverse\n\
    \        for (i <- 0 to shift) {\n            if (i < temp.length)\n         \
    \       temp = temp.dropRight(1)\n            temp = temp + temp\n        }\n\
    \        temp.reverse.dropRight(1) + temp", "        val digitsCount = x.toString.length\n\
    \        val result = new StringBuilder\n        for (i <- 0 until digitsCount\
    \ - shift) {\n            val digit = x.toString.charAt(digitsCount + i - shift)\n\
    \            result += digit\n        }\n        if (shift < digitsCount) {\n\
    \            val digit = x.toString.charAt(digitsCount + shift) \n           \
    \ result += digit\n        }\n        result.reverse", "        val n = math.pow(10,\
    \ shift)\n        val remainder = x % n\n        val digits = (x / (n / 10)).map(_\
    \ % 10).toArray\n        (digits ++ digits).mkString(\"\")", "        def digits(x\
    \ : Long) : List[Long] = {\n            if (x < 10L)\n                List(x)\n\
    \            else if (x < (1l << shift))\n                digits(x / 10L) ++ List(x%10L)\n\
    \            else\n                digits(x/10L / 10L) ++ digits(x%10L/10L) ++\
    \ digits(x%10L)\n        }\n        val digits = digits(x)\n        val shifted\
    \ = digits.reverse.tail.drop(shift).reverse\n        val result = shifted.reverse.mkString\n\
    \        val padding = Array.fill(shift.toString.length+1).takeRight(shift)\n\
    \        padding ++ result", "        var result = 0\n        var remainder =\
    \ x % shift\n        x /= shift\n        while(x > 0) {\n            result =\
    \ result*10 + remainder\n            x /= shift\n            remainder = x % shift\n\
    \        }\n        if (result < 0) (result + '9' * (shift - 1))\n        else\
    \ (result + '0' * (shift - 1))", "        val r = x.toString.reverse\n       \
    \ val s = r.takeRight(shift)\n        val r = r.dropRight(shift).reverse\n   \
    \     s + r", "        val result = scala.collection.mutable.StringBuilder()\n\
    \        var i = 0\n        while(i < x.length) {\n            val digit = x(i).toInt\n\
    \            val nextDigit = if (digit/10 > shift) digit%10 + 10 else digit%10\n\
    \            result += digit\n            i += 1\n            if (i < x.length)\
    \ {\n                result += (nextDigit + x(i).toInt).toChar\n            }\n\
    \        }\n        result.toString", "        var result : String = \"\"\n  \
    \      var i = x\n        while(i > 0) {\n            result += (i mod 10).asInstanceOf[String]\n\
    \            i /= 10\n        }\n        val digits = result.reverse.drop(shift).reverse\n\
    \        result = digits.length >= shift ? digits : digits.padTo(shift,\"0\")",
  "        var s = \"\"\n        var m = x.toInt\n        // shift the digits right\
    \ by shift\n        while (m>0) {\n            s += m.toString() + \" \"\n   \
    \         m = m.toInt / 10\n            m %= 10\n            shift = shift - 1\n\
    \        }\n        // remove leading space and return\n        val ss = s.dropRight(1)\n\
    \        if (ss.length < shift) ss else ss.reverse.drop(shift).reverse", "   \
    \     val n = math.max(x.toString.length, shift.toString.length)\n        val\
    \ buf = new Array[Char](n)\n        var i = 0\n        while (i < n) {\n     \
    \       buf(i) = x.toChar + x.toString.charAt(i)\n            i += 1\n       \
    \ }\n        buf ++= Array.fill(n)(0).mkString\n        var j = buf.length - 1\n\
    \        while (j >= 0) {\n            val c = buf.charAt(j)\n            buf(j)\
    \ = buf.charAt(j + shift)\n            buf(j + shift) = c\n            j -= 1\n\
    \        }\n        new String(buf)", "        def digits(x : Long) : List[String]\
    \ = x match {\n            case 0 => List()\n            case _  => digits(x /\
    \ 10) ++ digits(x % 10)\n        }\n        val digits = digits(x)\n        if\
    \ (shift == 0) digits.reverse\n        else {\n            val shift = shift -\
    \ 1\n            val shift = math.min(digits.length, shift)\n            digits.reverse.slice(0,\
    \ shift)\n                .reverseIterator.map(i => digits.head + i)\n       \
    \         .toList\n                .reverse\n                .mkString(\"\")\n\
    \        }", "        var result = new Array[Char](x.toString.length + shift)\n\
    \        var pos = 0\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var digit = 0\n        var digits = new Array[Long]\n\n        while(i\
    \ < x.toString.length) {\n            digit = x.toString.charAt(i)\n         \
    \   digits(k) = digit.toLong\n            i += 1\n            k += 1\n       \
    \ }\n\n        while(pos < digits.length) {\n            j = pos\n           \
    \ k = pos\n            while(k >= 0 && digits(k) == digits(k + 1)) {\n       \
    \         k -= 1\n            }\n            k = pos + 1\n            while(k\
    \ <= digits.length && digits(k) == digits(k + 1)) {\n                k += 1\n\
    \            }\n            if(k <= digits.length) {\n                if(pos >\
    \ 0) {\n                    result(pos) = digits(k)\n                    pos =\
    \ 0\n                } else {\n                    result(k) = digits(k + 1)\n\
    \                }\n                pos = k + 1\n            } else {\n      \
    \          while(k >= 0 && digits(k) == digits(k + 1)) {\n                   \
    \ k -= 1\n                }\n                result(pos) = digits(k + 1)\n   \
    \             pos = k + 1\n            }\n        }\n\n        while(pos < digits.length)\
    \ {\n            j = pos\n            k = pos\n            while(k >= 0 && digits(k)\
    \ == digits(k + 1)) {\n                k -= 1\n            }\n            result(k)\
    \ = digits(k + 1)\n            pos = k + 1\n        }\n\n        return result.map(_.toString).reverse.mkString.toUpperCase",
  "        val shift = shift % (x.length.toLong)\n        if (shift < 0)\n       \
    \     x = x.toString.reverse\n        val y = x.toString\n        for {\n    \
    \        i <- 0 until shift\n            j <- 0 until x.length - i\n        }\
    \ yield {\n            y((i + j))\n        }.toString", "        val shiftRight\
    \ = shift > x.toString.length\n        val shift = shift - (x.toString.length\
    \ % shift)\n        if (shiftRight) {\n            (x.toString.reverse.dropRight(shift))\n\
    \        }\n        else {\n            (x.toString.reverse.dropRight(x.toString.length\
    \ + shift))\n        }", "        var digits = \"\"\n        var lastDigit = 0\n\
    \        while (shift > 0) {\n            digits = x.toString.charAt(lastDigit)\
    \ + digits\n            lastDigit = lastDigit + shift - 1\n            if (lastDigit\
    \ >= x.toString.length)\n                lastDigit = 0\n            shift = shift\
    \ - 1\n        }\n        digits", "        // If the number to be circulated\
    \ by shift is already greater than the\n        // modulus of the number, just\
    \ return it\n        if (x > x.mod(shift))\n            return x.toString\n\n\
    \        // Otherwise, split the number into digits, shift each digit to the\n\
    \        // left by shift and concatenate all digits to form the new number\n\
    \        val digits = x.toString.reverse.grouped(shift).reverse\n        val newDigits\
    \ = mutable.ListBuffer.empty[String]\n        for (d <- digits)\n            newDigits.append(d.drop(shift))\n\
    \        newDigits.reverse.mkString", "        var result : String = \"\"\n  \
    \      var digits = x.toString.toInt\n\n        for( i <- 1 to shift) {\n    \
    \        var j : Int = 0\n            while( (j = (2 * i) - 1) < digits) yield\
    \ {\n                result += digits(j)\n            }\n        }\n\n       \
    \ return result.reverse", "        val digits = List((x.toString.dropRight(shift+1)\
    \ + x.toString.takeRight(shift+1)))\n        if(digits == 0) \"\" else digits.reverse.mkString",
  "      val n = x.toString.length\n      val s = x.toString.reverse\n      val z\
    \ = ((n - shift) % n).toString.reverse\n      s + z", "        var x = x.toString.reverse\n\
    \        var shift = shift.toString.reverse\n        var s = \"\"\n        var\
    \ i = 0\n        while (i < shift.length) {\n            if (shift(i) >= x.length)\n\
    \                s = x ++ s\n            else\n                s = x take shift(i)\
    \ ++ s\n            i += 1\n        }\n        s", "        val digits = x.toString.reverse.grouped(shift)\n\
    \        return digits.mkString(\"\").reverse", "        if (shift == 0)\n   \
    \         x.toString\n        else if (shift > x.length)\n            x.toString.reverse\n\
    \        else\n            val s = x.toString.reverse.substring(0,shift)\n   \
    \         x + (x.toString.reverse.substring(shift))", "        val xs = x.toString.toInt\n\
    \        val shifts = shift.toString.toInt\n        val result = new mutable.StringBuilder\n\
    \        for (i<-xs;i>=shifts;i--) {\n            val n = xs.drop(i)\n       \
    \     result.append(n)\n        }\n        return result.toString", "        if(x\
    \ == 0) {\n            return \"\"\n        } else if(shift > x.length) {\n  \
    \          var result = \"\"\n            for(i <- 0 until x.length) {\n     \
    \           result += x.toCharArray(i + 1).reverse\n            }\n          \
    \  return result.reverse\n        } else {\n            var result = \"\"\n  \
    \          for(i <- 0 until x.length) {\n                result += x.toCharArray(i\
    \ + shift)\n            }\n            return result\n        }", "        val\
    \ shiftDigits = Array.fill(shift)(0)\n        var xDigits = x.toString.toLongDigits().map(_.toChar)\n\
    \        var xDigit = Array.fill(xDigits.length)('0')\n        xDigits.copyToArray(xDigit,\
    \ 0, xDigits.length)\n        while (xDigit.length > shiftDigits.length) {\n \
    \           shiftDigits(xDigit.length - shiftDigits.length) = xDigit(xDigits.length\
    \ - 1)\n            xDigit(xDigits.length - 1) = '1'\n        }\n        shiftDigits.copyToArray(xDigit,\
    \ 0, shiftDigits.length)\n        val resultString = xDigit.foldLeft(\"\") {\n\
    \            (s, digit) => s + digit\n        }\n        resultString", "    \
    \    val digits = x.toString.dropRight(shift)\n        val result = if (digits.isEmpty)\
    \ digits else digits.reverse\n        result + digits.reverse.take(shift).reverse",
  "        val s = x.toString.toCharArray\n        val rev = if (shift > s.length)\
    \ s.reverse\n        else s\n        val r = new StringBuilder\n        for (i\
    \ <- 0 until shift)\n            r += rev(s.length - i - 1)\n        r.toString",
  "        val remainder = x - x % shift\n        val digit = x % shift\n        (remainder\
    \ << shift) + digit + \"\"", "        var digits = x\n        val newDigits =\
    \ mutable.ListBuffer[Long]()\n        var shiftDigits = 0\n        var lastDigits\
    \ = 0\n        while(digits != 0) {\n            if (shiftDigits > shift)\n  \
    \              newDigits = newDigits.reverse\n            if (digits % 10 > 0)\
    \ {\n                newDigits.append(digits % 10)\n                digits /=\
    \ 10\n                shiftDigits += 1\n            } else {\n               \
    \ lastDigits = digits\n                digits /= 10\n            }\n        }\n\
    \        if (shiftDigits > shift) {\n            newDigits = newDigits.reverse\n\
    \        }\n        if (newDigits.size == lastDigits)\n            newDigits.reverse.toString\n\
    \        else\n            newDigits.toString + lastDigits.toString", "      \
    \  var x = x.toString.toInt\n        if (shift == 0)\n            return Integer.toString(x)\n\
    \        val result = \"\"\n        var digit = 0\n        while (x > 0) {\n \
    \           val nextDigit = x % 10\n            result += Integer.toString(nextDigit\
    \ + digit)\n            digit += shift\n            if (digit > 9) {\n       \
    \         digit = digit % 10\n                result += Integer.toString(nextDigit\
    \ + digit)\n            }\n            x /= 10\n        }\n        result.reverse",
  "        val shiftDigits = math.pow(10, shift)\n        val digits = (x /shiftDigits)\
    \ % 10\n        x = (x /shiftDigits)\n        val reversedDigits = (digits * shiftDigits)\
    \ % 10\n        val result = reversedDigits.toString\n        val firstDigit =\
    \ reversedDigits.substring(0).toString\n        if (firstDigit.isEmpty) result\
    \ else result + firstDigit", "        val numDigits = x.toString().length\n  \
    \      var res = \"\"\n        var i = 0\n        while (i < numDigits) {\n  \
    \          val rightShift = numDigits - i\n            val carry = (x/(2l*Math.pow(10,rightShift)).toInt)\
    \ match {\n                case 0 => i\n                case _ => i + 1 // add\
    \ one to avoid overflow\n            }\n            res = (res + x.toString %\
    \ Math.pow(10, rightShift).toInt.toString) + carry.toString\n            x = x\
    \ - x/(2l*Math.pow(10,rightShift)).toInt\n            i += carry\n        }\n\
    \        if (shift == numDigits) {\n            res = res.reverse\n        }\n\
    \        res", "        if(shift > x.toString.length) x.toString.reverse\n   \
    \     else (x % pow(2, shift)).int.toString() + circularShift(x / pow(2, shift),\
    \ shift)", "        val digits = x.toString.reverse\n        val max = (digits.size\
    \ * shift.toInt).toInt\n        var i = 0\n        var c = 0\n        val digitList\
    \ = new mutable.Queue[String]()\n        while (i < digits.length) {\n       \
    \     c = (digits.charAt(i) - '0') * 10 + c\n            i += 1\n            if\
    \ (c > max) {\n                digitList.enqueue(digits.charAt(i) - '0')\n   \
    \             c = c - max\n                i += 1\n            }\n        }\n\
    \        if (digitList.size == 0)\n            return digits.reverse\n       \
    \ val result = digitList.dequeue\n        for (j <- 0 until shift) {\n       \
    \     result = result + '0'\n        }\n        return result + digits.reverse",
  "        val bits = (x shl shift).toLong\n        (x.toString ++ bits.toString(2)).substring(bits.length)",
  "        val s = x / shift\n        val r = x - (s * shift)\n        return s.toString.reverse\
    \ + r.toString", "        val result = (x / (shift / 10l)) % 10 + ''\n       \
    \ (result + result.take(shift + 1).toString) match {\n            case \"\" =>\
    \ result\n            case s => circularShift(result, shift)\n        }", "  \
    \      def loop(shift : Long, acc : String) : String = {\n            if (shift\
    \ == 0)\n                acc\n            else\n                loop(shift - 1,\
    \ (x + acc).asInstanceOf[String])\n        }\n        loop(shift, \"\")", "  \
    \      var n = x\n        if (shift < x.toString.length) n = x.toString.reverse\n\
    \        var i = shift\n        var result = \"\"\n        while (i > 0) {\n \
    \           result = n.charAt(i) + result\n            i = i - 1\n        }\n\
    \        result", "      val s = \"\" + x\n      val l = (s.length - shift)\n\
    \      val m = s if l > 0 else None\n      val r = s if l < s.length else None\n\
    \      val p = s if l > 0 else r.reverse\n      p match {\n        case None =>\
    \ r\n        case Some(x) => (s + x) * Math.pow(10, l % s.length).reverse\n  \
    \    }", "        def shift(x : (Long, Long)) = x._1 shr shift | x._2 shr shift\n\
    \        var bits = x.toString.reverse.map { ch => if (ch == '1') 1 else if (ch\
    \ == '0') 0 }\n        if (shift < bits.size) {\n            val x = bits.drop(shift);\n\
    \            val y = bits.take(shift);\n            bits -= shift.toString.reverse.map\
    \ { ch => if (ch == '1') 1 else 0 } ++ shift(x)\n            bits += shift(y)\n\
    \        }\n        bits.toString.reverse", "        val len = x.length\n    \
    \    val resultString = new StringBuilder\n        if (len < shift) {\n      \
    \      resultString.append(x)\n        }\n        else {\n            val x =\
    \ x.toString // convert to string\n            for ( i <- 0 to len - shift ) {\n\
    \                resultString.append(x.charAt(i)) // add digits at position\n\
    \            }\n            resultString.append(x.charAt(len-shift)) // add the\
    \ right most digit\n        }\n        return resultString.reverse", "       \
    \ var result = ''\n        for(i <- 0 until shift) {\n            result += x(i\
    \ + (shift - 1))\n        }\n        result.reverse", "        val l = x.length\n\
    \        val r = shift % l\n        val r = math.min(r, (l-1))\n        // TODO\
    \ handle shift < 0\n        var y = x.toString.toCharArray\n        var z = new\
    \ Array[Char](l)\n        for (i <- 0 to r) {\n            z(i) = y(i)\n     \
    \   }\n        var str = new StringBuilder\n        for (i <- 0 to (l-r)) {\n\
    \            str += z(i)\n        }\n        return str.toString", "        def\
    \ leftShift(x: Long, shift : Long) : Long = {\n            def shiftLeft(x : Long,\
    \ shift : Long) : Long = {\n                val digit = x.toInt % 10\n       \
    \         val result = x.toInt - digit + digit\n                if (result > 9)\
    \ return 10 + result - shift\n                else result\n            }\n   \
    \         val shiftedDigit = shiftLeft(x, shift)\n            val lastDigit =\
    \ x % 10\n            val newDigit = lastDigit + shiftedDigit - 10\n         \
    \   if (newDigit > 9) leftShift(newDigit, shift + 1) + 10\n            else newDigit\n\
    \        }\n        val digits = x.toString.reverse.tail\n        val resultDigits\
    \ = digits.map(leftShift(_, 1)) reverse\n        resultDigits mkString \"\"",
  "        val digits = x.toString.reverse\n        val shift = shift - 1\n      \
    \  if (shift > digits.length)\n            digits.reverse\n        else {\n  \
    \          val shiftedDigits = digits.drop(shift).take(digits.length - shift)\n\
    \            digits.reverse.concat(shiftedDigits)\n        }", "        var result\
    \ = \"\"\n        var i = 0;\n        while (i < shift) {\n            result\
    \ = (x + result).mod(BigInt(10)).toString\n            i += 1\n        }\n   \
    \     i = 0;\n        while (i >= shift) {\n            result = (result + x).toString\n\
    \            i -= 1\n        }\n        result", "        val digits = x.toString.reverse\n\
    \        val newDigits = digits.length - shift - 1\n        val newDigitsInt =\
    \ digits.substring(0,newDigits)\n        val newDigitString = newDigitsInt + digits.substring(newDigits)\n\
    \        return newDigitString", "        if(shift > x.toString().length)\n  \
    \          return x.toString().reverse\n        val xs = x.toString.split(\"\\\
    \\.\")\n        val ys = Array.fill(shift) {0l}\n        ys(0) = xs(0).take(shift)\n\
    \        val result = (xs(0) + ys.map(_.toLong).reverse).drop(shift).toString()\
    \ + \".\" + xs(1).take(shift).toString() + \".\" + xs(2)\n        if(result.length\
    \ == x.toString().length)\n            result\n        else\n            circularShift(result,\
    \ shift)", "        val digits = x % 10\n        x = x / 10\n        if (shift<=digits.length)\
    \ digits(shift) else digits.reverse", "        def digit(x: Long, shift : Long,\
    \ digits: Array[Long]) : Long = {\n            if (x >= shift) digits(x)\n   \
    \         else digits(x) + digit(x+shift-x, shift-x, digits)\n        }\n    \
    \    val digits = Array.fill(x.digits.length)(0)\n        var shift = shift\n\
    \        while (shift > x.digits.length) shift -= x.digits.length\n        digits.reverse.foldLeft(\"\
    \")(\n            (x, y) => digit(y, x, digits) + x\n        )", "        val\
    \ digits  = x.toString.reverse\n        val shifted = digits.drop(shift)\n   \
    \     val newDigit = digits.takeRight(shift)\n        s\"$shifted$newDigit\"",
  "      var s = \"\"\n      while(x > 0) {\n        val temp = x % 10\n        x\
    \ = x / 10\n        s = s + temp.toString\n      }\n      if(shift > s.length)\n\
    \        s = s ++ s.dropRight(shift)\n      else\n        s = s ++ s.take(shift).reverse\n\
    \      s", "       val result = (x >>> shift).toCharArray\n       val resultStr\
    \ = new StringBuilder(result)\n       resultStr.reverse\n       resultStr.toString",
  "        val n = x.toString.length\n        var digits = x.toString.reverse.grouped(shift.toInt).map(_.reverse)\n\
    \        if (digits == Nil) {\n            digits = x.toString.reverse.grouped(shift.toInt).map(_.reverse)\n\
    \        }\n        digits.reverse.toSeq.foldLeft(\"\"){ (res, d) => res + d.mkString\
    \ }", "        val digits = scala.math.pow(2, shift)\n        val reversedDigits\
    \ = (digits).div((2l*digits) + digits)\n        val remainder = digits - reversedDigits\n\
    \        val digitPosition = digits - shift\n        val output = x.toString.reverse.slice(digitPosition)(0)\
    \ + remainder.toString.reverse\n        return output + reversedDigits.toString.reverse",
  "        val digits = math.divrem(x.toInt, 10).map(_.toInt)\n        val shiftDigits\
    \ = math.divrem(shift.toInt, 10).map(_.toInt)\n        val result = digits.map(x\
    \ => (x + shiftDigits(x)) % 10).map(x => digits(x)).toList.reverse.mkString\n\
    \        result.substring(0, Math.max(result.length, shift))", "        var res\
    \ = \"\"\n        var carry = 0\n        var len = Math.max(1, Math.ceil(Math.log10(x)\
    \ + shift))\n        for(i<- 0 until len) {\n            val nextVal = (x.toLong\
    \ * Math.pow(10, len-i)) + carry\n            res +=  (nextVal.toFloat / Math.pow(10,\
    \ len-i)).trunc * Math.pow(10, len-i)\n            if(nextVal.abs % Math.pow(10,\
    \ len-i) != 0) {\n                res +=  nextVal.abs / Math.pow(10, len-i)\n\
    \                carry = 0\n            } else {\n                carry = 1\n\
    \            }\n        }\n        if(res.length < len) {\n            res +=\
    \ new String(x.toByte, len-res.length)\n        }\n        res", "        val\
    \ x = x.toInt\n        val shift = shift.toInt\n        if (shift > x.length)\
    \ x.reverse\n        else (x << (shift.toInt)) + (x >> (x.length << shift.toInt))",
  "        def shiftLeftByShift(x : Long, shift : Long) : Long = {\n            if\
    \ (shift > x.length) {\n                (x % 10)  + 10 * (x / (10 * shift))\n\
    \            } else {\n                (x % 10)  + 10 * (x / (10 * shift))\n \
    \           }\n        }\n        val xStr = (x / 100).toInt\n        val shiftStr\
    \ = (shift / 10).toInt\n        val newStr = xStr + shiftLeftByShift(xStr, shiftStr)\n\
    \        val newInt = newStr * 10 + newStr\n        newInt.toString", "      \
    \  val shiftMod = x % shift\n        val digits = x.toString.toCharArray.drop(shiftMod\
    \ % 10)\n        val shiftDigits : Array[Char] = Array.fill(10){digits(shiftMod\
    \ % 10)}\n        val newString : String = new StringBuilder(digits).mkString(\"\
    \") + new StringBuilder(shiftDigits).mkString(\"\")\n        return newString",
  "        // Initialize result to \"\"\n        var result = \"\"\n        // Get\
    \ number of digits in x\n        var nDigits = x.toString().length\n        //\
    \ Keep looping while there are digits or shift > nDigits\n        while ((shift\
    \ > nDigits) || (nDigits < shift)) {\n            // If the shift is > number\
    \ of digits, use nDigits as shift and add \"0\"\n            if (shift > nDigits)\
    \ {\n                shift = (nDigits + 1l)\n                result = x.toString().reverse.dropRight(shift)\
    \ + \"0\"\n                // If nDigits < shift, just add \"0\"\n           \
    \ } else {\n                result = (x.toString()).reverse.dropRight(shift) +\
    \ \"0\"\n            }\n            nDigits += 1\n        }\n        return result",
  "        var xStr = x\n        val digits = xStr.length\n        if (shift < digits)\
    \ {\n            val digitShift = (digits - shift)\n            var shiftPlus\
    \ = 0\n            for ((i, iPlus, iMinus) <- Iterator.iterate(digitShift)(_+)(0))\n\
    \                if ((i + digitShift) > digits) (iMinus, digitShift, iPlus)\n\
    \                else (iPlus, digitShift, i)\n            var x = new StringBuilder\n\
    \            x ++= xStr.drop(digitShift).reverse\n            x ++= xStr.take(digitShift)\n\
    \            x.toString\n        } else {\n            xStr.toString\n       \
    \ }", "        val length = x.toString.length\n        var newX = x\n        val\
    \ tempVal = x.toString\n        var newVal = \"\"\n        while(newX > 0) {\n\
    \            if(newX < shift)\n                newVal = newVal + tempVal.charAt(newX\
    \ - shift) + tempVal.charAt(newX) \n            newX = newX - shift\n        }\n\
    \        if(length == newX) newVal\n        else newVal + tempVal.charAt(newX\
    \ + shift)", "        if (shift == 0) {\n            x.toString.reverse\n    \
    \    } else {\n            var result = \"\"\n            for (i <- 0 until shift)\
    \ {\n                val digit = x % 10\n                x /= 10\n           \
    \     result += (digit * 10 + i).toString.reverse\n            }\n           \
    \ result\n        }", "        var newX = x.toInt % 10\n        var newShift =\
    \ shift.toInt % 10\n        var result : String = \"0\"\n        while(newShift\
    \ > newX) {\n            newX = newX * 10\n            newShift = newShift * 10\n\
    \        }\n        while(newShift < newX) {\n            newX = newX / 10\n \
    \           newShift = newShift / 10\n        }\n        result = newX + newShift\n\
    \        return result.toString", "        var stringInLong = x.toString.toLong\n\
    \        var finalString = \"\"\n        var lastDigit = 0\n        while (stringInLong\
    \ > 0) {\n            finalString += lastDigit\n            lastDigit = stringInLong\
    \ % 10\n            stringInLong = (stringInLong - lastDigit) / 10\n        }\n\
    \        if (shift > finalString.length) {\n            finalString = finalString.reverse\n\
    \        }\n        return finalString", "        val n = x.toString\n       \
    \ val digits = n.toCharArray\n        val m = n.length\n        var x = 0\n  \
    \      var i = 0\n        var k = 0\n        var k1 = m + shift\n        while(i\
    \ < m){\n            x = ((digits(i) - '0') << 1) | (digits(i-1) - '0')\n    \
    \        k += 1\n            if (k1 < 0){\n                k1 = k1 + m\n     \
    \       }\n            else if (k1 > m){\n                k1 = k1 - m\n      \
    \      }\n            digits(i) = digits(i) + x\n            digits(i-1) = digits(i-1)\
    \ - x\n            i += 1\n            k += 1\n        }\n        return new String(digits)",
  "        if((shift > 0) && (shift < x.length)) (x.toString.padTo(shift, \"\") +\
    \ x.toString.substring(shift, x.length))\n        else if(shift < 0) (x.toString.substring(shift,\
    \ x.length) + x.toString.padTo(shift, \"\"))\n        else (x.toString.substring(shift,\
    \ x.length) + x.toString.padTo(shift, \"\"))", "        val r = x / (10l ** shift);\n\
    \        val s = x - (r * (10l ** shift));\n        if (s < 10l) s\"0$s\" else\
    \ s.toString", "        val str = x.toString.reverse\n        val digits = str.substring(1,\
    \ str.length-1)\n        val shiftDigits = digits.substring(0,shift)\n       \
    \ val result = shiftDigits + str.substring(shift,str.length-1)\n        result",
  "        val result = new collection.mutable.StringBuilder\n        val carry =\
    \ 0L\n        val newValue = x >> shift\n        result ++= digits(newValue, shift,\
    \ carry)\n        result.reverse.mkString", "        var x = x.toString.reverse\n\
    \        var s = \"\"\n        for (i <- 0 until shift) {\n            s = (x\
    \ dropRight(1l) + s).dropLeft((1l - i).toInt)\n        }\n        return s", " \
    \       def circularShiftDigits(x : Long, shift : Long) : List[Long] = {\n   \
    \         val retVal = new mutable.ListBuffer[Long]\n            val n = Math.min(x,\
    \ Math.max(x, shift))\n            val l = Math.max(0, Math.min(n, Math.pow(2,\
    \ shift + 1) - 1))\n            val m = Math.max(n, Math.pow(2, shift + 1))\n\
    \            var i = l\n            var j = m\n            while (i >= 0) {\n\
    \                retVal += i\n                i /= 10\n            }\n       \
    \     while (j >= 0) {\n                retVal += j\n                j /= 10\n\
    \            }\n            retVal.toList.reverse\n        }\n        val digits\
    \ = circularShiftDigits(x, shift)\n        var retVal = \"\"\n        var i =\
    \ 0\n        var shiftDigit = 0\n        for (d <- digits) {\n            shiftDigit\
    \ = shift % 10\n            if (i >= (digits.size - 1)) {\n                retVal\
    \ += digits(i).asInstanceOf[String].charAt(shiftDigit)\n                retVal\
    \ += digits(i).asInstanceOf[String].charAt(shiftDigit)\n                shiftDigit\
    \ += 1\n                i -= 1\n            } else {\n                retVal +=\
    \ digits(i).asInstanceOf[String].charAt(shiftDigit)\n                shiftDigit\
    \ += 1\n                i += 1\n            }\n        }\n        retVal", " \
    \       def circularShiftHelper(x: Int, shift: Int): String = {\n            if\
    \ (shift > x.length) {\n                return x.reverse\n            } else {\n\
    \                if (x.length <= shift) {\n                    return \"\"\n \
    \               }\n                val temp = x.substring(shift, x.length)\n \
    \               val reverse = circularShiftHelper(temp, shift + 1)\n         \
    \       return reverse(x.substring(0, shift) + reverse(temp) + reverse)\n    \
    \        }\n        }\n        circularShiftHelper(x, 0)", "        val digits\
    \ = x.toString().reverse\n        var remainder = digits % shift\n        digits\
    \ = digits - remainder\n        val newDigits = digits + remainder\n        if\
    \ (newDigits > Integer.MAX_VALUE.toString().length)\n            digits.substring(0,\
    \ digits.lastIndexOf(\".\"))\n        else\n            digits.substring(0, newDigits)",
  "        val digits = x\n        val digits_reversed = if (shift > digits.length)\
    \ digits.reverse.toString else digits.toString.reverse\n        val shift = shift.toInt\n\
    \        val result_digits = digits_reversed.reverse.foldLeft(\"\"){\n       \
    \     (acc, _) =>\n                val cur = (acc + (if (shift > acc.length) \"\
    \" else \" \"))\n                (cur + digits(shift).charAt(0))\n        }\n\
    \        if (shift > digits.length) result_digits(digits.length - shift) :: result_digits\
    \ else result_digits", "        var res = 0\n        var curr = x\n        var\
    \ tmp = 0\n        while(curr != 0){\n            tmp = curr % 10\n          \
    \  res = res * 10 + tmp\n            curr = curr // 10\n        }\n        var\
    \ res = res * shift\n        val digits = res % 10\n        var str = \"\"\n \
    \       var numDigits = 0 // number of digits in the result\n        while(str.isEmpty\
    \ && numDigits < shift - 1){\n            str = digits(numDigits) + str\n    \
    \        numDigits++\n        }\n        if(numDigits == 0){\n            str\
    \ = digits(numDigits) + str\n        }\n        if(numDigits > shift){\n     \
    \       str = str.substring(0,numDigits - shift)\n        }\n        return str",
  "        var y = x >> shift\n        var result : String = null\n        for(i <-\
    \ 0 until shift) {\n            result += (y % 10)\n            y = y / 10\n \
    \       }\n        if(shift > 0)\n            result += (reverse(y.toString.drop(shift)).reverse)\n\
    \        return result", "        var result = \"\"\n        var shift = shift\
    \ % x.length\n        var i = 0\n        while (shift > 0) {\n            if ((shift\
    \ & 1) != 0) {\n                result += \"0\"\n            }\n            shift\
    \ >>= 1\n        }\n        while (shift > 0) {\n            if ((shift & 1) !=\
    \ 0) {\n                result += \"1\"\n            }\n            shift >>=\
    \ 1\n        }\n        result", "        if (shift == 0)\n            x.toString.reverse\n\
    \        else\n            circularShift(x.toString.reverse, shift - x.toString().length)\
    \ + x.toString", "        val shift = shift.toInt\n        var xString = \"\"\
    \ + x\n        var shiftString = \"\" + shift\n        var digit = 0\n       \
    \ var digitString = \"\"\n        var x = xString.toInt\n        var shift = shiftString.toInt\n\
    \        while (shift > 0) {\n            digit = x % 10\n            x = x /\
    \ 10\n            digitString = digitString.concat(digit.toString)\n         \
    \   shift = shift - 1\n        }\n        while ((shift > 0) && (xString.length\
    \ < shiftString.length)) {\n            digit = x % 10\n            x = x / 10\n\
    \            digitString = digitString.concat(digit.toString)\n            shift\
    \ = shift - 1\n        }\n        if (shift > 0) {\n            xString = digitString\n\
    \        }\n        if ((shift > 0) && ((xString.length + shift) > shiftString.length))\
    \ {\n            xString = xString.concat(digitString.reverse)\n        }\n  \
    \      xString", "        if (x.toString.length < shift) x.toString.reverse\n\
    \        else (x / (10 * shift)).floor.toString + x.toString.substring(x.toString.length\
    \ - shift)", '        if (shift == 0) "" else (x + x) % shift + circularShift(x,
    shift - Integer.digitCount(shift))', "        if(shift > x.length){\n        \
    \    val reversed = circularShift(x.toString.reverse, shift.toString.toInt)\n\
    \            reversed.reverse\n        } else {\n            var shiftDigit =\
    \ shift % x.length\n            var digits = x % shiftDigit\n            var x\
    \ = x - (digits * shiftDigit)\n            var res = \"\"\n            while (x\
    \ > 0) {\n                digits += 1\n                if (digits > x.length)\
    \ digits -= 1\n                res = res + digits.toString\n                x\
    \ = x - (digits * shiftDigit)\n            }\n            res\n        }", " \
    \       val shiftCount = x.toString.length / shift;\n        val shiftString =\
    \ new Array[Char](shiftCount)\n        var j = 0;\n        var z = 0;\n      \
    \  while (j < shiftCount) {\n            z = x * Math.pow(10, shiftCount-j-1);\n\
    \            shiftString(j) = ((z / (10l.toDouble)) % 10).toChar\n           \
    \ j += 1\n        }\n        var x = new StringBuffer(x.toString)\n        for\
    \ (i <- 0 until shiftCount)\n            x.setCharAt(i, shiftString(i))\n    \
    \    x.reverse", "        def shiftDigits(n : Long, shift : Long) : String = {\n\
    \            val result = \"\"\n            val shift = shift.toInt\n        \
    \    while (n != 0) {\n                val tmp = n % 10\n                result\
    \ += tmp\n                n /= 10\n            }\n            result.reverse.take(shift).reverse\n\
    \        }\n\n        def getDigit(n: Long) : String = n.toString.charAt(0)\n\
    \        val digits = x.getDigits.reverse\n\n        // Shift digits in both directions\n\
    \        for (h <- 1 to shift) {\n            val tmp = digits\n            digits\
    \ = shiftDigits(digits.reverse, h)\n            digits += tmp\n        }\n   \
    \     digits.reverse", "        val m = x.length\n        val m = math.min(m,\
    \ shift)\n        var result = 0\n        for (i <- 0 until m) {\n           \
    \ val bit = (x & 1l).toInt\n            result |= bit << shift\n            shift\
    \ -= 1\n            if (shift == 0) {\n                x >>= 1\n             \
    \   shift += 1\n            }\n        }\n        (result reverse).asDigitString(10)",
  "        var result = \"\"\n        x match {\n            case 0 => result = \"\
    0\"\n            case n => \n                while ((x % shift) != 0) {\n    \
    \                result += \"0\"\n                }\n                while ((x\
    \ % shift) != 0) {\n                    x /= shift\n                }\n      \
    \          x match {\n                    case 0 => result = \"0\"\n         \
    \           case n => result += (x % shift) + \"\"\n                }\n      \
    \  }\n        result", "        val digits = x.toString\n        val digitsLength\
    \ = digits.length\n        if (shift > digitsLength) return digits.reverse\n \
    \       var carry = 0\n        val digitsShiftRight = digitsLength - (shift %\
    \ digitsLength)\n        var resultDigits = ListBuffer[String]()\n        for\
    \ (i <- 0 until digitsShiftRight) {\n            val digit = digits.charAt(i)\n\
    \            val newDigit = digit + (carry / 10)\n            val newCarry = carry\
    \ % 10\n            val newDigitString = Integer.toString(newDigit)\n        \
    \    if (newCarry > 0) resultDigits.append(newDigitString)\n            else resultDigits.append(digitString)\n\
    \            carry = newCarry\n        }\n        if (digitsLength > shift) resultDigits.append(digits.substring(digitsLength\
    \ - shift))\n        else resultDigits.append(digits.substring(shift))\n     \
    \   resultDigits.reverse.toString.mkString", "        val digits = x.toString.reverse.grouped(shift).map(_.toString).reverse.toList\n\
    \        if (shift > digits.size) {\n            digits.reverse\n        } else\
    \ {\n            digits\n        }", "        val shifted = ((x shl shift) xor(x\
    \ shr shift))\n        val reversed = shifted.reverse\n        (reversed.toString.dropRight(shift)).reverse",
  "        val s = scala.math.min(shift, x.toString().length())\n        (0 until\
    \ s).map( i => x.toString().charAt(i) + x.toString().substring(i, i + s).reverse.charAt(0)).mkString",
  "        val len = math.min(x.toString.length.toInt, shift.toString.length.toInt)\n\
    \        val buf = new Array[Char](len)\n        var i = 0\n        var j = 0\n\
    \        val len = math.min(x.toString.length.toInt, shift.toString.length.toInt)\n\
    \        while (i < len) {\n            buf(j) = x.toString.charAt(i)\n      \
    \      j += shift\n            i += 1\n        }\n        new String(buf.reverse)",
  "        def digits(x : Long) : List[Long] = \n            scala.math.pow(10, x.toString.length).drop(shift).toList\n\
    \            .reverse\n        val digitsToShift  = digits(x) - digits(shift)\n\
    \        var res            = \"\"\n        for (i<- 0 to digitsToShift.length)\
    \ {\n            if (digitsToShift < 0) res = res + digits(x(-digitsToShift))(i)\n\
    \            else res = res + digits(x)(i)\n        }\n        res ++ \"0\"",
  "        // Create a list with the number of digits\n        val list = (1 to (math.log10(x.toLong)\
    \ + 1)).map(i => x.toLong / 10.toInt)\n        val list = list.drop(list.length\
    \ - shift)\n        var i = 0\n        list.foreach(_ => i += 1) // Increment\
    \ i\n        val result = x.toString.drop(shift).reverse.drop(i).toString.reverse\n\
    \        result", "        var x = x.toString.toInt;\n        var shift = shift.toString.toInt;\n\
    \        var digits = new mutable.ArrayBuffer(x)\n        while (shift > digits.size)\n\
    \            digits = digits.reverse\n        val shiftPower = 2L\n        var\
    \ lastDigit : Long = digits(0)\n        var digit : Long = 0\n        for (i =\
    \ 1 to digits.size) {\n            digit += digits.size - i\n            digits(i)\
    \ = lastDigit + digit / shiftPower\n            lastDigit = digit\n          \
    \  digit %= shiftPower\n        }\n        digits.reverse", "        var rem =\
    \ x\n        for (i <- 0 until shift) {\n            rem = (rem / 10) + ((rem\
    \ % 10) / 10).toDouble\n        }\n        rem.toString.reverse", '        //
    Implement here!', "       val digits = toDigits(x)\n       val digitsShifted =\
    \ digits.take(shift)\n       val digitsShiftedReversed = digitsShifted.reverse\n\
    \       val result = digitsShiftedReversed.mkString(\"\")\n       result", " \
    \     val digits = x.toString\n      val res = \"\"\n      var carry = 1\n   \
    \   for (i <- 0 until digits.length)\n        if (digits(i).isDigit) {\n     \
    \     val digit = digits(i).toLong\n          val next = digit + shift\n     \
    \     if (next > 9) {\n            val temp = next - 10\n            next += carry\n\
    \            carry = temp % 10\n          }\n          res += digits(i) + next.toString\n\
    \        }\n        else {\n          res += digits(i)\n          carry = 1\n\
    \        }\n      if (carry > 0) res += carry.toString\n      res", "        val\
    \ digits = x.toString.reverse.grouped(shift)\n        digits.mkString(\", \")",
  "      var result = \"\"\n      var carry = 0\n      while (shift > 0) {\n     \
    \   var temp = x\n        if ((temp % 10) != 0) {\n          temp += carry\n \
    \       }\n        temp = temp / 10\n        carry = temp % 10\n        result\
    \ = temp + result\n        shift -= 1\n      }\n      if ((carry != 0) || (shift\
    \ != 0)) {\n        result = result + carry\n      }\n      return result", " \
    \       (x >>> shift) match {\n        case 0 => (0 until shift).map(_.toString).reduce(_\
    \ + _).mkString(\"\")\n        case _ =>\n            val length = scala.math.log10(x)\
    \ + shift\n            (x >>> length).map(_.toString).reduce(_ + _).mkString(\"\
    \")\n        }", "        def rotate(x : Long) : Long = x >>> shift \n       \
    \ def shift(x : Long) : Long = x << shift \n        val s = x.toString.reverse\n\
    \        val r = s.reverse\n        val m = r.length - shift\n        if (m >\
    \ 0)\n            r take (m) ++ r.drop(m + 1)\n        else\n            r", " \
    \       val shift2 = shift >>> 1\n        val digits = (x % shift2).toString.reverse\n\
    \        val leftShiftDigits = (x - shift2)\n        if (leftShiftDigits.toString.length\
    \ < digits.length)\n            digits + leftShiftDigits.toString else digits",
  "        val sx = x.toString.reverse\n        val sh = shift.toString.reverse\n\
    \        var out = new StringBuilder(sx)\n        val s = sx(sh)\n        for\
    \ (i = sh + 1; i >= 0; i--)\n            out = out + s\n        out.toString",
  "        var s = x.toString\n        for (i<- 1l..shift) {\n          s = swap(s,\
    \ i)\n        }\n        s", "        val sb = scala.collection.mutable.StringBuilder()\n\
    \        val digits = List('0','1','2','3','4','5','6','7','8','9')\n        var\
    \ remainder = 0\n        while (x > 0) {\n            // Shift right of remainder\n\
    \            remainder = x % 10\n            x = x / 10\n            // Adjust\
    \ remaining digit to move it to the front of the digit\n            if (remainder\
    \ > shift) {\n                remainder -= digits.length\n            }\n    \
    \        // Add the digit that just moved\n            sb ++= digits.apply(remainder)\n\
    \        }\n        // Return digits reversed\n        if (sb.length() > digits.length)\
    \ {\n            sb.reverse\n        } else {\n            sb\n        }", " \
    \       val digits = x.toString.reverse.map(_.toInt)\n        val digitSize =\
    \ Math.max(digits.length - shift, 0)\n        val result = new StringBuilder\n\
    \        digits.slice(0, digitSize).foreach(result.append _)\n        digits.slice(digitSize).foreach(result.append\
    \ _)\n        result.toString", "        var i = x\n        val d = (x % (x+1l))\n\
    \        var str = d + ((x - (d+(x+(1l*shift))) % (x+1l)).toString.reverse + ((x\
    \ - (d+(x+(1l*shift+2l))) % (x+1l)).toString.reverse)\n        var shifts = (x+(1l*shift))/(x+1l).toInt\n\
    \        val shiftStr = (x+1l*shift).toInt\n        var k = x+1l*shift\n     \
    \   while(str.length < shifts){\n            if(i > (x+1l)){\n               \
    \ shifts -= 1\n                k -= 1\n            }\n            i = i + (k -\
    \ x).toInt\n            str = str + i.toString\n        }\n        str = str.reverse\n\
    \        return str", "        var res : String = \"\"\n        // Compute the\
    \ number of digits in x\n        var digits = math.min(math.max((x.toString.length),\
    \ 1), 10)\n        // Shift the digits right by shift\n        if (shift > digits)\
    \ {\n            for ( var i = digits - shift; i > 0; i-- ) {\n              \
    \  res += x.toString.charAt(x.toString.length - i - 1)\n            }\n      \
    \  } else {\n            for ( var i = digits; i > shift; i-- ) {\n          \
    \      res += x.toString.charAt(x.toString.length - i - 1)\n            }\n  \
    \      }\n        return res", "      val shift = math.min(x.toString.length,\
    \ shift)\n      val remainder = x % 10\n      x /=10\n      var reversed = 0\n\
    \      for(i <- 0 to shift until (shift+1-i)) {\n        reversed += (10 * remainder)\
    \ + i\n      }\n      val result = reversed.toString.reverse\n      if(result\
    \ < 0) \"0\"+result else result", "        val str = (x / (Math.pow(10, shift))\
    \ % 10) match {\n            case 0 => \"\"\n            case i => Integer.toString(i)\n\
    \        }\n        circularShift(x, shift + 1l) match {\n            case \"\"\
    \  => str\n            case i  => i + str\n        }", "        // Compute number\
    \ of digits using log base 10\n        val digits = math.log(x, 10).toInt\n  \
    \      val result: List[String] = for (i <- 0 until digits) yield {\n        \
    \    val digit = math.mod(x, 10).toInt\n            val bitShift = shift % 10\n\
    \            val carry = (digit + (bitShift / 2)) % 10\n            val newDigit\
    \ = (carry + digit).toInt\n            Integer.toString(newDigit)\n        }\n\
    \        result.reverse", "        val n = x.toString.toInt\n        val shifted\
    \ = (n * shift) `mod` 10\n        val reversed = shifted + n\n        val s =\
    \ reversed.toString.reverse\n        s", "        val n = x.toString.length\n\
    \        val shift = if (shift > n) n-1 else shift\n        var xStr = \"\" +\
    \ x\n        var yStr = \"\"\n        var i = 0\n        while (i < shift) {\n\
    \            xStr = xStr.substring(1) + xStr.substring(0, xStr.length-1)\n   \
    \         yStr = yStr.substring(1) + yStr.substring(0, yStr.length-1)\n      \
    \      i = i + 1\n        }\n        xStr = xStr.substring(1) + yStr\n       \
    \ xStr", "        var digits = Integer.toString(x).asDigitIterator\n        val\
    \ shiftDigits = digits.length.toLong - shift.toLong\n        if(shiftDigits >\
    \ 0) digits = digits.drop(shiftDigits)\n        else digits = digits.reverse\n\
    \        for(d <- digits) yield d", "        val digits = x % 10\n        val\
    \ remainder = x / 10\n        var newVal = remainder\n        var shiftLeft =\
    \ shift\n        var shiftRight = shift - 1\n        while (shiftLeft > 0 && shiftRight\
    \ > 0 && shiftLeft <= shiftRight) {\n            if (digits(shiftLeft) >= digits(shiftRight))\
    \ {\n                newVal = digits(shiftRight)\n                shiftRight -=\
    \ 1\n            } else {\n                newVal = digits(shiftLeft)\n      \
    \          shiftLeft += 1\n            }\n        }\n        if (shiftLeft > 0)\
    \ newVal += digits(shiftLeft)\n        if (shiftRight > 0) newVal += digits(shiftRight)\n\
    \        val newStr = newVal + digits(0)\n        return newStr", "        var\
    \ shiftByOne = shift.toInt\n        var x = 0\n        var result = \"\"\n   \
    \     while (x > 0) {\n            x = x shl shiftByOne\n            result +=\
    \ x.toString\n            shiftByOne -= 1\n        }\n        result.reverse",
  "        val radix = 1l\n        val shiftDigit = shift % radix\n        var result\
    \ = \"\"\n        var index = 0\n        while (x * radix <= shift)\n        \
    \    x = x * radix\n        if (shiftDigit < radix)\n            while (x / (radix\
    \ - (shiftDigit * radix)) > radix)\n                x /= radix\n            var\
    \ remainder = x % radix\n            x /= radix\n            result = remainder\
    \ + result\n            while (x != 0) {\n                remainder = x % radix\n\
    \                result = remainder + result\n                x /= radix\n   \
    \         }\n            if (shiftDigit < radix)\n                result = result\
    \ + (shiftDigit * radix.toString)\n            else\n                result =\
    \ result + shiftDigit.toString\n        else\n            while (x / (radix *\
    \ radix) > radix)\n                x /= radix\n            var remainder = x %\
    \ radix\n            x /= radix\n            result = remainder + result\n   \
    \         while (x != 0) {\n                remainder = x % radix\n          \
    \      result = remainder + result\n                x /= radix\n            }\n\
    \            if (shiftDigit < radix)\n                result = result + (shiftDigit\
    \ * radix.toString)\n            else\n                result = result + shiftDigit.toString\n\
    \        result", "        var ret = new StringBuilder\n        var rem = x\n\
    \        while (shift > 0) {\n            shift -= 1\n            rem = rem /\
    \ 10\n            ret = ret + rem\n        }\n        if (ret == x) {\n      \
    \      ret = ret + \"\"\n        }\n        return ret.toString", "        val\
    \ len = (x.toString.length + shift)\n        val str = (0 to len).map(i => x.toString.charAt(len\
    \ - 1 - i)).mkString(\"\")\n        return str.substring(0, str.size - 1)", " \
    \       val stringifiedLong = x.toString\n        val numDigits = stringifiedLong.length\n\
    \        val newNumDigits = numDigits + shift\n        val newDigits = stringifiedLong.substring(0,numDigits)\
    \ + stringifiedLong.substring(numDigits, newNumDigits)\n        newDigits", " \
    \     val numStr = x.toString.toInt // Convert long to string\n      val digits\
    \ = numStr.length // # of digits\n      val shift = shift % digits // Get new\
    \ shift\n      val shifted = numStr.dropRight(digits-shift) // Drop shifted digits\
    \ off the end\n      shifted.reverse+shifted.take(shift).reverse", "        val\
    \ digits = x.toString.toInt\n        val shift = shift.toInt\n        val shifted\
    \ = (x << shift) >> shift\n        val result = (shifted / 10) + digits.toString\n\
    \        result += digits.toString.reverse\n        result", "        val xChar\
    \ = x.toCharArray\n        var y = xChar.foldLeft(\"\")((b, c) => b + xChar(b)\
    \ + xChar(c))\n        var i = 0\n        while (i < shift) {\n            i =\
    \ i + 1\n            y = y + xChar(i - 1)\n        }\n        y.reverse", "  \
    \      val res = new StringBuilder\n        var carry = 0\n        for (i <- 0\
    \ until shift)\n            res.append(if (carry >= x) x.toString.charAt(i) +\
    \ 1 else x.toString.charAt(i))\n            carry = x % 10\n        res", "  \
    \      val radix = 10\n        val digits = x.toString.reverse\n        if (shift\
    \ > radix) {\n            return digits.reverse\n        }\n        var shiftDigits\
    \ = digits.substring(shift, digits.length)\n        var numDigits = digits.length\n\
    \        var digitsShifted = digits - shiftDigits\n        var numShiftedDigits\
    \ = 0\n        var numToShift = digits.length\n        var nextDigit = 0\n   \
    \     while (numToShift > numShiftedDigits + 1) {\n            numToShift -= 1\n\
    \            shiftDigits = shiftDigits.substring(1) + digits(nextDigit)\n    \
    \        numShiftedDigits += 1\n            nextDigit += 1\n        }\n      \
    \  while (digitsShifted.length <= numShiftedDigits) {\n            digitsShifted\
    \ = digitsShifted + \"0\"\n        }\n        digitsShifted + shiftDigits", " \
    \       val str = Integer.toString x\n        val len = str.length\n        var\
    \ remain = len - shift\n        var shift = len - remain\n        if (shift ==\
    \ 0)\n            return str\n        val res = new StringBuilder\n        while\
    \ (shift > 0)\n            res.insert(0, str.charAt(shift))\n            shift\
    \ -= 1\n        res.insert(0, str.charAt(remain))\n        return res.toString()",
  "      val digits = x.toString.reverse.grouped(shift)\n      val shiftRight = digits.drop(1)\n\
    \      val shiftLeft = new StringBuilder(shiftRight.toString)\n      shiftLeft.reverse().append(digits.last).toString",
  "        var shift : Long = shift\n        var result : String = \"\"\n        while\
    \ (shift > 0) {\n            val digit = (x % 10).toString // get the last digit\n\
    \            x /= 10\n            result += digit\n            if (shift > 1)\
    \ {\n                shift -= 1\n                val lastDigit = (x % 10).toString\
    \ // get the last digit\n                x /= 10\n                result += lastDigit\n\
    \            }\n        }\n        result.reverse", "        val digits = scala.math.mod(x.abs,\
    \ Math.pow(10, shift.toInt))\n        val length = digits.toString.length\n  \
    \      val reverse = if (shift > length) digits else digits.reverse\n        reverse.toString",
  "        val s = x.toString.reverse\n        val len = s.length\n        val mod\
    \ = (len + shift - 1) % len\n        var result = \"\"\n        for(i <- 0 until\
    \ len) {\n            result += (s.charAt(i) << shift)\n            shift += len\n\
    \        }\n        return result + s.charAt(mod)", "        def shiftDigits(x:\
    \ Long, shift: Long) : String = {\n            def shiftDigit(x: Long, shift:\
    \ Long): String = {\n                if (x>0) {\n                    if (shift<digit.length)\
    \ {\n                        digit(shift) := x%10\n                        x :=\
    \ x/10\n                        shift := shift+1\n                        shiftDigits(x,\
    \ shift)\n                    } else {\n                        digit(shift) :=\
    \ x%10\n                        shiftDigits(x/10, shift-1)\n                 \
    \   }\n                } else {\n                    if (shift<digit.length) {\n\
    \                        digit(shift) := x%10\n                        shiftDigits(x/10,\
    \ shift-1)\n                    } else {\n                        digit(shift)\
    \ := x%10\n                        shiftDigits(x, shift)\n                   \
    \ }\n                }\n            }\n            var digit = Array.fill(shift)(0)\n\
    \            shiftDigits(x, shift)\n            digit.toList.mkString(\"\")\n\
    \        }\n        var digit = Array.fill(shift)(0)\n        shiftDigits(x, shift)\n\
    \        digit.toList.mkString(\"\")", "        val xDigitsLength = x.toString.length\n\
    \        val shiftDigitsLength = shift.toString.length\n\n        var newString\
    \ = \"\"\n        var newNum = x.toLong\n\n        var carry = 0\n        var\
    \ digits = \"\"\n\n        for (i <- 0 until xDigitsLength) {\n            digits\
    \ = x.toString.charAt(i) + digits\n            if (carry > 0) {\n            \
    \    carry = digits.length % shiftDigitsLength\n                if (carry > 0)\
    \ {\n                    digits += \"0\"\n                }\n                newString\
    \ += digits\n            } else {\n                carry = 0\n               \
    \ newString += digits\n            }\n        }\n        // Handle the case where\
    \ the shift is bigger than the digit's length.\n        if (carry > 0) {\n   \
    \         newString += \"0\" * carry\n        }\n        if (newString.length\
    \ < shiftDigitsLength) {\n            newString = newString.reverse\n        }\n\
    \n        return newString", "        val digits = x.toString.reverse.grouped(shift).reverse\n\
    \        if (digits.isEmpty) {\n            return x.toString\n        }\n   \
    \     digits.take(shift).foldLeft(\"\") { (x, digit) => x ++ digit }", "     \
    \   val digits = x.toString.reverse\n        val digitsCount = digits.length\n\
    \        val shiftCount = shift.toString.length\n        val shift = shiftCount\
    \ - shiftCount.toInt\n        if (shift < 0)\n            digits.reverse.slice(shiftCount,\
    \ digits.length)\n        else\n            digits.slice(shift, digits.length)",
  "       val digits = x.toString.reverse\n       val shift = shift.toString.reverse\n\
    \       digits.reverse.slice(shift, digits.length).reverse", "        var digits\
    \ = BigInt(x)\n        val n = BigInt(shift)\n        val temp = new Array[BigInt](digits.toString.length)\n\
    \        val temp2 = new Array[BigInt](digits.toString.length)\n\n        digits.toString.reverse.take(n).foreach(x\
    \ => temp(digits.toString.length - 1 - x)) //reverse the digits to avoid losing\
    \ leading 0s\n        for (i <- 0 until digits.toString.length - n) {\n      \
    \      temp2(i) = temp(i + n)\n        }\n        val result = BigInt(temp2.reverse).toString(2)\n\
    \n        //now we need to reverse the result and lose the leading 0\n       \
    \ if (result.length < digits.toString.length)\n            result = (\"0\" * (digits.toString.length\
    \ - result.length) + result)\n        else\n            result = result.reverse\n\
    \n        result", "        def shift(i: Int, n: Int) = i + (n >> i)\n       \
    \ def digits(x: Long): List[Int] = x match {\n            case 0 => List(0)\n\
    \            case n => List((n shr 0).toInt)\n        }\n        val length =\
    \ digits(x).length\n        val x = x shr shift\n        val y = x % 10\n    \
    \    val yList = digits(y)\n        val yListLength = yList.length\n        val\
    \ firstDigit = shift(yListLength - 1, length)\n        val result = digits(x)\n\
    \        val secondDigit = shift(yListLength - 2, length)\n        result :::\
    \ (firstDigit ++ secondDigit :: result)", "        val length = x.toString.length\n\
    \        var res = \"\"\n        for (i <- 0 to length-1){\n            res +=\
    \ x.toString.charAt(i) + x.toString.charAt(length+1-i)\n        }\n        val\
    \ shift1 = length - shift\n        if (shift1 < 0) res += x.toString.charAt(shift1)\n\
    \        if (shift1 > 0) res += x.toString.charAt(shift1-1)\n        if (shift1\
    \ > 0) res += x.toString.charAt(0)\n        if (shift1 < 0) res += x.toString.charAt(-shift1)\n\
    \        res", "        var str = String.valueOf(x)\n        var res = (str.length\
    \ + shift) - x.length\n        if (res < 0) res = res+str.length\n        str\
    \ = str.substring(0,res) + str.substring(res,str.length)\n        if (str.length\
    \ == 0) str = \"0\"\n        str = str.substring(0,str.length-shift) + str.substring(str.length-shift,str.length)\n\
    \        str = str.substring(0,shift) + str.substring(shift,str.length)\n    \
    \    str", "        val digits = (x % 10).toString.reverse\n        val num =\
    \ x\n        // If shift > num digits, reverse digits from right\n        if(shift\
    \ > digits.length) digits = digits.reverse\n        val shift = x - num\n    \
    \    val result = digits + digits.drop(shift)\n        result", "        val digits\
    \ = Array[Char](x)\n        val shiftedDigits = Array.tabulate(shift){i => digits((digits.length\
    \ - i) % digits.length)}.mkString.reverse\n        digits.dropRight(shift).append(shiftedDigits)",
  "        val shifted = x.asInstanceOf[String].toList.take(shift)\n        val shiftedRight\
    \ = shifted.reverse.take(shift)\n        shiftedRight.reverse.mkString(\"\") +\
    \ shiftedRight.mkString(\"\")", "        if (shift > x.toString.length)\n    \
    \        x.toString.reverse\n        else\n            val digits = x.toString.reverse.grouped(shift).toList\n\
    \            val digit = digits.head\n            val rem = digits.tail.foldLeft(0)\
    \ {\n                case (acc, digit) =>\n                    if (acc > digit)\
    \ acc - digit\n                    else acc + (digit % 10)\n            }\n  \
    \          (rem + digit).toString", "        val digits = x.getClass\n       \
    \ val digitCount = digits.length\n        val shiftCount = shift.getClass\n  \
    \      val shiftDigitCount = shiftCount.length\n        val shifted = digits shl\
    \ shiftDigitCount\n        val shifted = shifted.toString + digits.drop(shiftDigitCount)\n\
    \        if (shifted.length < digitCount) {\n            shifted.reverse\n   \
    \     } else {\n            shifted\n        }", "        val digits = scala.math.pow(x,\
    \ shift.toInt)\n        val res = digits % 10\n        val shiftDigits = scala.math.pow(10,\
    \ shift.toInt)\n        val shiftDigitLen = digits.length\n        val shiftDigit\
    \ = digits(0) // in scala, digits is indexed from zero, not from 1\n        val\
    \ digitsList = scala.collection.mutable.ListBuffer[String]()\n        digitsList.append(shift\
    \ + res.toInt)\n        while (shiftDigit > 0){\n            digitsList.append(shiftDigit\
    \ % 10)\n            shiftDigit = (shiftDigit-1)/10\n        }\n        res.toString.reverse\
    \ + digitsList.toString.reverse", "        if (shift > x.toString.length) {\n\
    \            x.toString.reverse\n        } else {\n            val shift = shift.abs\n\
    \            val digits = x.toString\n            var index = 0\n            var\
    \ resultString = \"\"\n            while (index < (digits length)) {\n       \
    \         resultString += (digits(index) << shift)\n                index += 1\n\
    \                shift -= 1\n            }\n            resultString\n       \
    \ }", "        val digitsSize = log10(x.toInt) + 1\n        var digits = List.fill(digitsSize){0l}\n\
    \        digits += List(x.toInt, 0)\n        var i = 0\n        while (i <= digitsSize\
    \ - shift) {\n            val shift = digits.head\n            if (digits.tail.sum\
    \ < shift) digits.tail += digits(i).reverse\n            digits = digits.tail\n\
    \            i += 1\n        }\n        digits.reverse.mkString", "        val\
    \ digits = x.toString.reverse\n        (digits reverse drop shift) append digits.take(shift)",
  "        val nx = x.toString\n        val nshift = shift.toString\n        val nlen\
    \ = nx.length\n        val nshift1 = nshift.substring(0,1)\n        var xdigits\
    \ = Array[Char]()\n        var xstr = StringBuilder(nx.length)\n        var slen\
    \ = nshift1.length\n        for(i <- 0 to nlen - 1) {\n            var xc = nx.charAt(i)\n\
    \            var slen2 = slen\n            for(j <- 0 to slen - 1) {\n       \
    \         val xc2 = xc.charAt(j)\n                val slen3 = slen2 - 1\n    \
    \            xc2 = xc2.toChar\n                xdigits :+ xc2.toChar\n       \
    \         xc = xc.substring(0,j+1) + xc2.substring(j+1,slen2)\n              \
    \  xstr = xstr + xc\n                slen2 = slen3 - 1\n            }\n      \
    \      xstr = xstr + xc\n        }\n        xstr = xstr + xdigits(xlen -1)\n \
    \       for(i <- 0 to nlen - 1) {\n            xstr = xstr.substring(0, xlen-i)\
    \ + xstr.substring(xlen-i)\n        }\n        xstr.toString", "        if (shift\
    \ > x.length) { x.toString.reverse}\n        else { val shifted = (x << shift)\
    \ mod x\n            val result = shifted.toString.reverse\n            result\
    \ }", "        if (shift <= x.toString.length && shift > 0)\n            x.toString.substring(shift,\
    \ x.toString.length+shift).reverse\n        else\n            x.toString", " \
    \     val shifted = x << shift\n      val num = shifted.toString.reverse\n   \
    \   val padded = num.padTo(shift.toString.length, \"0\")\n      padded", "   \
    \     val n = x\n        val i = shift - 1\n        var result = \"\"\n      \
    \  if (n < 0) {\n            while (n > 0)\n                result += (n % 10\
    \ + '0');\n            result.reverse\n        }\n        while (i > 0) {\n  \
    \          result = (n % 10 + '0') + result;\n            n /= 10;\n         \
    \   i -= 1\n        }\n        result", "        def circShift(x : Long, shift\
    \ : Long) : Long = {\n            var n = x\n            var d = shift\n     \
    \       while (d > Integer.numberOfTrailingZeros(n))\n                d -= Integer.numberOfTrailingZeros(n)\n\
    \            while (d > 0)\n            {\n                n += d\n          \
    \      d /= 10\n            }\n            return n\n        }\n        var result\
    \ = \"\"\n        var remaining = x\n        var rest = circShift(remaining, shift)\n\
    \        var digits = Array[String](1l).fill(rest)\n        while (digits.length\
    \ > 0)\n        {\n            result = digits(digits.length - 1) + \"0\" + result\n\
    \            remaining = circShift(remaining, rest)\n            digits = Array[String](1l).fill(remaining)\n\
    \        }\n        return result", "        val n = x.length\n        val shift\
    \ = shift % n\n        var str = \"\"\n        var i = 0;\n        var carry =\
    \ 0\n        while(i < n) {\n            val temp = x.toString % 10\n        \
    \    val sum = carry + temp.toInt\n            val carry = (sum / 10).toInt\n\
    \            val digit = sum % 10\n            str = str + digit.toString\n  \
    \          i = i + 1\n        }\n        while(i < shift) {\n            str =\
    \ str + str.toString\n            i = i + 1\n        }\n        if(carry > 0)\
    \ {\n            str = str + carry.toString\n        }\n        return str.reverse",
  "        val xDigits = x % 10\n        val shiftDigits = shift % 10\n        val\
    \ newDigit = xDigits >>> shiftDigits\n        val remainder = xDigits - newDigit\n\
    \        if( remainder > 0 ) {\n            circularShift( newDigit + 10l, shift\
    \ - shiftDigits )\n        } else {\n            circularShift( newDigit, shift\
    \ )\n        }", "        val digits = x.toString.reverse\n        val result\
    \ = new StringBuilder()\n        for (i<-0 to shift.toInt-1){\n            result.append(digits(i))\n\
    \        }\n        result.toString()", "        val xDigits = x.toString.reverse.dropRight(shift)\n\
    \        val yDigits = x.toString.takeRight(shift).toString.reverse\n        val\
    \ newDigits = xDigits + yDigits\n        val newString = newDigits.reverse\n \
    \       println(newString)", "        val maxDigits = (x.toString.length / shift.toString.length)\n\
    \        val digits = x.toString.substring(shift.toString.length).chars.toSet\n\
    \        var res = \"\"\n        for (i <- 0 until maxDigits) {\n            val\
    \ a = digits(i)\n            val b = (x.toString.charAt(shift.toString.length)\
    \ + i).toChar\n            res = res + a\n            res = res + b\n        }\n\
    \        return res", "        val remainder = x % shift\n        val result =\
    \ x / (shift % shift)\n        val shiftedResult = circularShift(result, shift)\n\
    \        result + shiftedResult + remainder", "        val x = x.toString.toInt\n\
    \        var result = \"\"\n        if (x < 0) {\n            var s = -shift\n\
    \            var a = x\n            while (a>0) {\n                a /= 10\n \
    \               s += 1\n            }\n            s = -s*10\n            a =\
    \ 1\n            while (a>0) {\n                result += (10 * a%10).toString.toString\
    \ + (if (s<0) \"-\" else \"\")\n                a /= 10\n                s +=\
    \ 1\n            }\n        } else {\n            var s = shift\n            var\
    \ a = x\n            while (a>0) {\n                result += (10 * a%10).toString.toString\
    \ + (if (s<0) \"-\" else \"\")\n                a /= 10\n                s +=\
    \ 1\n            }\n        }\n        result", "        var str = x.toString\n\
    \        var index = shift\n        var newstr = \"\"\n        while(index > 0)\
    \ {\n            index = index - str.charAt(index)\n            newstr = str.charAt(index)\
    \ + newstr\n        }\n        return newstr", "        val digits = x.toString\n\
    \        var result = \"\"\n        var index = 0\n        while (index != shift)\
    \ {\n            result += digits(index)\n            index = (index + 1) % digits.length\n\
    \        }\n        result += (digits reverse)\n        return result", "    \
    \    val shiftDigits = shift.toString.length\n        var res = \"\"\n       \
    \ while( x>0 && resLength(x) < shiftDigits ) {\n            res = res.concat(x.toString)\n\
    \            x = (x >>> 1)\n        }\n        if ( resLength(x) < shiftDigits\
    \ ) {\n            res = res.reverse\n        }\n        return res", "      \
    \  val l = (x % 1000000000000000000)\n        var y = x\n        for(i <- 0 until\
    \ shift) {\n            y = y / 1000000000000000000\n        }\n        var z\
    \ = y\n        for(i <- 0 until shift) {\n            z = z / 1000000000000000000\n\
    \        }\n        return Integer.toString((l + (z - y) * shift).toInt)", " \
    \       if (shift > x.length) {\n            val reversed = x.reverse\n      \
    \      reversed.slice(shift, x.length).reverse.toString\n        } else {\n  \
    \          x.slice(shift, x.length).reverse.toString\n        }", "        var\
    \ ret = \"\"\n        while(x.toString.length < shift.toString.length){\n    \
    \        ret = \"0\" + ret\n        }\n        while(x.toString.length > shift.toString.length){\n\
    \            ret = x.toString.substring(ret.length) + ret\n        }\n       \
    \ return ret", "        if (shift > x.toString.length) return x.toString.reverse\n\
    \        val xString = x.toString\n        var shiftChars = xString.length - shift\
    \ - 1\n        var result = \"\"\n        var x = 1l\n        while (xString.length\
    \ > shift) {\n            var digit = xString.charAt(xString.length - 1)\n   \
    \         result = (digit + result).asInstanceOf[String]\n            x = x *\
    \ 10l\n            xString = xString.substring(0,xString.length - 1)\n       \
    \ }\n        return result.reverse", "        var result = \"\"\n        val l\
    \ = x.toString.length\n        var shift = shift % l\n        for(i <- 0 until\
    \ shift - 1) {\n            result += x.toString(i)\n        }\n        result\
    \ += x.toString(shift - 1)\n        return result", "        var x = x.toString.reverse\n\
    \        var shift = shift.toString.reverse\n        var result = \"\"\n     \
    \   for(i <- 0 until shift.length) result = result + x.dropRight(shift.length\
    \ - i) + x\n        result", "        val n = x.toString.toLong\n        val result\
    \ = ((n * (1l ** shift)).toString).reverse\n        if (shift>=n) result\n   \
    \     else circularShift(result,shift-1)", "       val digits = String.valueOf(x).split(\"\
    \").reverse.toList\n       val shift = shift % digits.size // Modulo (%) operator\
    \ to ensure shift is positive\n       val newDigits = digits.map(_.toChar).reverse.drop(shift)\n\
    \       return newDigits.mkString(\"\") + digits.take(shift).mkString(\"\")",
  "        val length = x.toString.length\n        val shift = shift % length\n  \
    \      val reversedString = x.toString.reverse\n        val reversedLength = reversedString.length\n\
    \        val result = reversedString.substring(shift, reversedLength - shift)\
    \ +\n            reversedString.substring(0, reversedLength - shift)\n       \
    \ res: Any", "        var digits : Array[Long] = x.toString.toLongArray.grouped(shift).toArray\n\
    \        var resultString : String = \"\"\n        for(i <- 0 to digits.length\
    \ - 1) {\n            resultString += (digits(i).toString.reverse)\n        }\n\
    \        return resultString", "        def rightShift(x : Long, shift : Long)\
    \ : Long = {\n            var result = x\n            var remainder = result\n\
    \            while (result != 0) {\n                remainder = result % shift\n\
    \                result = result / shift\n            }\n            result\n\
    \        }\n        if (shift > x.toString.length) {\n            return x.toString.reverse\n\
    \        }\n        var result = x.toString.reverse\n        var remainder = result\n\
    \        while (remainder != 0) {\n            remainder = rightShift(remainder,\
    \ shift)\n            result = result + remainder\n        }\n        result",
  "        var i = 0\n        var digits = \"\"\n        while (i < shift) {\n   \
    \         digits += x.toString.substring(i, i + 1)\n            i += 1\n     \
    \   }\n        digits += x.toString.substring(shift, x.toString.length())\n  \
    \      digits", "        // Recursive case. Base case.\n        if (shift <= 0)\
    \ return \"\"\n        // Recursive case. Handle left shift\n        if (shift\
    \ > x.length) shift = 0\n        val start = x.length\n        // Recursive case.\
    \ Handle right shift\n        val end = x.length + shift\n        val result =\
    \ circularShift(x.substring(start, end), shift - start)\n        // Handle left\
    \ shift\n        if (shift > start) result += x.substring(start, start + shift).reverse\n\
    \        // Handle right shift\n        if (shift < end) result += x.substring(end\
    \ - shift, end).reverse\n        return result.reverse", "        val digits =\
    \ x.toString.reverse\n        (digits.reverse.substring(shift, digits.length).reverse).reverse\
    \ + digits.substring(0, shift)", "        var ans = \"\"\n        while (x.compareTo(Long.MinValue)\
    \ < 0) {\n            ans = (x.toString.reverse + ans)\n            x = x + shift\
    \ % x.toString.length\n            shift /= x.toString.length\n        }\n   \
    \     if (x.compareTo(Long.MinValue) < 0) ans = (x.toString.reverse + ans)\n \
    \       ans", "        val x = x % 10\n        var xs = \"\" + x\n        val\
    \ shift = shift % 10\n        if(shift == 0)\n            return xs;\n       \
    \ else if(shift > x)\n            xs = xs.reverse;\n        if(shift < xs.length)\n\
    \            xs = xs.substring(0,xs.length-shift) + xs.substring(xs.length-shift+1);\n\
    \        else\n            xs = xs.substring(0,shift) + xs.substring(shift+1);\n\
    \        return xs;", "        val x = x.toString.toInt;\n        val shift =\
    \ shift.toString.toInt;\n        var result = \"\";\n        var digits = scala.collection.mutable.ListBuffer[String]();\n\
    \        while (shift != 0) {\n            if (shift % 2 == 1) {\n           \
    \     digits += x.toString.toChar;\n                shift /= 2;\n            }\
    \ else {\n                digits += x.toString.toInt.reverse.toChar;\n       \
    \         shift /= 2;\n            }\n        }\n        result = digits.reverse.toString.trim();\n\
    \        if (shift != 0) {\n            result = circularShift(x, shift.toInt)\
    \ + result;\n        }\n        result;", "        val digits = x.toString.toInt\n\
    \        val reversed = if (shift > digits.length) digits(digits.length - shift)\n\
    \        else digits(shift)\n        val result = (new StringBuilder).append(reversed).toString()\n\
    \        if (shift <= digits.length) result\n        else result.substring(0,\
    \ digits.length) + new StringBuilder(result).reverse().toString()", "        //\
    \ Recursive implementation that uses tail recursion and a stack\n        // to\
    \ simulate the shift operation of the radix shifter.\n        // x is treated\
    \ as a binary string of 1s and 0s.\n        // We start from the rightmost digit.\n\
    \        val rec : Long = 0\n        val stack = mutable.Stack[Long]()\n     \
    \   val digit = x.toString.reverse.charAt(0)\n        x % shift match {\n    \
    \        case 0 => \"\"\n            case _ => {\n                if (digit ==\
    \ '1') {\n                    stack.push(x)\n                    rec = circularShift(stack.peek,\
    \ shift)\n                    stack.pop\n                } else {\n          \
    \          rec = stack.pop * 10 + digit\n                }\n                rec\
    \ % shift match {\n                    case 0 => rec // return result\n      \
    \              case _ => rec + circularShift(rec, shift)\n                }\n\
    \            }\n        }", "        val stringOfNumber = x.toString.reverse.take(shift)\n\
    \        val reversedString = stringOfNumber.reverse.mkString\n        val reversedNumberInAscendingOrder\
    \ = stringOfNumber.reverse.mkString.toLong\n        val result = reversedNumber.toString.reverse.take(shift).reverse.mkString\n\
    \        // The \"result\" should be reversedNumber but it is reversedNumberInAscendingOrder\n\
    \        result", "        val digits = x.toString.reverse.drop(shift).reverse.drop(shift+1)\n\
    \        if (digits == \"\") digits\n        else digits.tail + digits.head +\
    \ digits.drop(shift).reverse", "        var result = \"\"\n        var index =\
    \ 0\n        var carry = 0\n        var i = 1\n        while(i < shift && index\
    \ < (x.toString.length - 1)){\n            result += x.toString.substring(index,\
    \ index+i) + i\n            carry = x.toString.charAt(index+i).toLong - x.toString.charAt(index).toLong\
    \ * i.toLong\n            i = i + 1\n            index = index + 1\n        }\n\
    \        if(index == x.toString.length){\n            result += x.toString.substring(index)\n\
    \        }\n        if(carry > 0){\n            result += carry.toString\n   \
    \     }\n        return result", "        val digits = x.toString.reverse.grouped(shift)\n\
    \        val result = mutable.StringBuilder(digits.size)\n        for (i <- digits.indices)\
    \ {\n            result += digits(i).toList\n        }\n        result.toString",
  "        val digits = x.toString.toInt\n        // For each digit of the number\n\
    \        var i = digits\n        while (i >= shift) {\n            val mod = i\
    \ % 10\n            i = i / 10\n            digits = digits - mod\n        }\n\
    \        val result = (digits*(shift + 1)).toString.reverse\n        return result\
    \ + digits", "        val digits = x.toString.reverse\n        val digits_shift\
    \ = digits.dropRight(shift).toString.reverse\n        digits_shift.drop(shift)",
  "        val string = \"0\" * (shift-x.toString.length) \n        string + x.toString.reverse",
  "        // Create a list to store all digits of the number as a list\n        val\
    \ digits = scala.collection.mutable.ListBuffer[Long]()\n        while(x>0) {\n\
    \            digits += (x%10)\n            x = x>>1\n        }\n        digits.reverse.map(x\
    \ => x+1l).toList.map(x => x.toString).mkString(\"\")", "        val shiftFactor\
    \ = shift.toLong / x.toLong\n        // Return digits reversed\n        if (shiftFactor.equals(0))\
    \ {\n            return x.toString.reverse\n        }\n        // Get last shift\
    \ digit\n        val lastDigit = x.toString.charAt(x.toString.length-1)\n    \
    \    // Get digits in reverse order\n        val reversedDigits = x.toString.reverse\n\
    \        val newDigits = reversedDigits.substring(0, reversedDigits.length-lastDigit)\
    \ + reversedDigits.substring(reversedDigits.length-lastDigit)\n        // Get\
    \ new digits\n        val newDigit = newDigits.reverse.charAt(0)\n        // Return\
    \ new digits\n        return (newDigit + newDigits.substring(newDigits.length-lastDigit)).reverse",
  "        if (shift == 0)\n            return x.toString\n        val y = x.toString.reverse\n\
    \        val l = math.min(shift, y.length)\n        var i = 0\n        while (i\
    \ < l) {\n            val temp = y(i)\n            y(i) = y(i-1)\n           \
    \ y(i-1) = temp\n            i += 1\n        }\n        y.reverse", "        val\
    \ s = x.toString.reverse\n        (s length + shift) match {\n            case\
    \ 0 => \"\"\n            case _ => {\n                val c = chars(s)\n     \
    \           val r = \"\"\n                for (i <- 0 until shift) {\n       \
    \             r = r + c(i)\n                }\n                r\n           \
    \ }\n        }"]
stop_tokens:
- "\n    }\n"
