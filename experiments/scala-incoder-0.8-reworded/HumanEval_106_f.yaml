name: HumanEval_106_f
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Implement the function f that takes n as a parameter,\n    // and returns\
  \ a list of size n, such that the value of the element at index i is the factorial\
  \ of i if i is even\n    // or the sum of numbers from 1 to i otherwise.\n    //\
  \ i starts from 1.\n    // the factorial of i is the multiplication of the numbers\
  \ from 1 to i (1 * 2 * ... * i).\n    // Example:\n    // >>> f((5l))\n    // (List[Long](1l.toLong,\
  \ 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))\n    def f(n : Long) : List[Long]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(f((5l)).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong))));\n    assert(f((7l)).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 6l.toLong, 24l.toLong, 15l.toLong, 720l.toLong, 28l.toLong))));\n \
  \   assert(f((1l)).equals((List[Long](1l.toLong))));\n    assert(f((3l)).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 6l.toLong))));\n    }\n\n}\n"
completions: ["        if (n == 1) {\n          List[Long](1l.toLong)\n        } else\
    \ {\n          val facts = mutable.ArrayBuffer.empty[Long]\n          for (i <-\
    \ 1l to n) { facts += i.toLong * factorial(i) }\n          List[Long](facts.toList)\
    \ \n        }", "      val l = List(1)\n      for (i <- 0 until n) {\n       \
    \ if (i.toInt == 1) {\n          l :+ i.toLong\n        }\n        else {\n  \
    \        l :+ (i.toLong * (l.last :+ i.toLong))\n        }\n      }\n      l",
  "        val facts = mutable.MutableList[Long]()\n        for(i <- 1l to n) facts\
    \ += i.toLong * i.toLong\n        if(n % 2 == 0) facts else facts.init :+ n",
  "        if (n == 0)\n            return Nil\n        if (n % 2 == 0)\n        \
    \    return List(n.toLong)\n        else\n            val total = 1\n        \
    \    for (i = 1; i<n; i++) total = total * i\n            List(total, total.toLong)",
  "        // Your code goes here\n        val list = mutable.ListBuffer[Long]()\n\
    \        if (n == 0) list.+1\n        else for (i<- 1 to n by 2) list.+(i.toLong)\n\
    \        list.toList", "      val factorials = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \      var i = 1 // i = 1\n      factorials += 1l\n      while (i <= n) {\n  \
    \      if (i % 2 == 0) {\n          factorials += i\n        }\n        else {\n\
    \          for (j <- 1 to i) {\n            factorials += j.toLong\n         \
    \ }\n        }\n        i += 1\n      }\n      factorials.toList", "        if(n.isEven)\n\
    \            n.toLong*1l.toLong*f(n.toLong-1)\n        else\n            1 until\
    \ n.toLong map { i => i.toLong*1l.toLong+i.toLong }", "        def fact(x: Long)\
    \ = {\n            if (x == 1) 1\n            else if (x % 2 == 0) x * fact(x-1)\n\
    \            else (1 to x).reduce(_ * _)\n        }\n        List(1l.toLong, 1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong).take(n.toInt).map(fact).toList", "        if\
    \ (n.toInt <= 0) List[Long]() else { \n            val (ns, ix) = List((1l.toLong,\
    \ 1l), (n-1l.toLong, 2l), (n.toLong, n.toInt-1))\n            List(1l.toLong +\
    \ ix * ns(ix).toLong, 1l.toLong + ix * ns(ix).toLong + ix * ns(ix-1).toLong)\n\
    \        }", "        n match {\n            case 1 => List(nl.toLong)\n     \
    \       case x if x % 2 == 0 => for { i <- 1 to n } yield i.toLong * x.toLong\n\
    \            case x if x % 2 == 1 => for { i <- 1 to n } yield i.toLong + x.toLong\n\
    \        }", "        val result = mutable.ListBuffer[Long]()\n        if(n %\
    \ 2 == 0) result ++= 1 to n else result ++= 1 to n\n        result .toList", " \
    \       val fact = mutable.ArrayBuffer.fill(n)(1)\n        var factSum = 0\n \
    \       for(i <- 1 to n) {\n            if((i.toLong % 2) == 0) {\n          \
    \      fact += i to (i+1)\n            }\n            else {\n               \
    \ factSum += i to (i+1)\n            }\n        }\n        fact.toList", "   \
    \     // initialize a list to return\n        var ans = List[Long]()\n       \
    \ // base case: when the factorial of the number n is 1\n        if ( n == 1 )\n\
    \            return List(n)\n        // recursive case\n        else\n       \
    \     // for each even number\n            for ( i <- 1 to n by 2 )\n        \
    \        // calculate the factorial\n                ans :+ i*factorial(i)\n \
    \           ans", "        val r : List[Long] = Nil\n        var i = 1 \n    \
    \    while (i <= n) r +=  i * i\n        if (n.toDouble % 2 == 0) r +=  n.toDouble\
    \ * f(n.toDouble / 2l)\n        else r +=  1 to n.toDouble\n        r ", "   \
    \     val list: List[Long] = List()\n        for (i in 1L until n) list += if\
    \ (i % 2 == 0) i * 1L else i * 1L + i\n        list", "        val numbers = 1\
    \ to n\n        numbers.filter(_ % 2 == 0).map(_ * numbers.filter(!_ % 2 == 0).sum)",
  "        var list = List[Long]()\n        list.updated(1l, 1l)\n        list.updated(2l,\
    \ 1l)\n        var k = 0\n        while (k <= n) {\n            list.updated(k,\
    \ k.toLong*k.toLong)\n            k += 2\n        }\n        list", "        val\
    \ factorials = scala.collection.mutable.ListBuffer[Long](1)\n        factorials\
    \ += 1\n        for (i = 1 to n) factorials *= i\n        factorials.toList",
  "        val factorial: mutable.Buffer[Long] = new mutable.Buffer[Long](n)\n   \
    \     for (i<-1 to n-1) {\n            if (i%2 == 0) {\n                factorial(i)\
    \ = factorial(i) * i.toLong\n            } else {\n                factorial(i)\
    \ = factorial(i) + i.toLong\n            }\n        }\n        factorial.map(_.toLong).toList",
  "        val factorial = scala.math.combinatorics._\n        for (i <- 1 to n) {\n\
    \            if (i % 2 == 0) {\n                factorial(n - 1).map(_.toLong\
    \ * i).toList\n            } else {\n                factorial(n - 1).map(_.toLong\
    \ * (i + 1)).toList\n            }\n        }", "        val factorialList = List.fill(n.toInt)(1L)\n\
    \        for {i <- 1 to n\n             f <- factorialList(i mod 2 => factorialList(i\
    \ div 2 :: factorialList.take(i)))}\n            f :: factorialList", "      \
    \  var sum = 0\n        var fact = 1\n        var listOfFactorials = List[Long]()\n\
    \        if (n<=0) {\n            listOfFactorials = List[Long]()\n          \
    \  return listOfFactorials\n        }\n        if (n==1) {\n            listOfFactorials\
    \ = List[Long](1l.toLong)\n            return listOfFactorials\n        }\n  \
    \      if (n%2==0) {\n            for (i <- 1L to n-1) {\n                fact\
    \ = fact * i\n                sum = sum + i\n                listOfFactorials\
    \ = listOfFactorials ::: (1l.toLong, fact)\n            }\n        } else {\n\
    \            for (i <- 1L to n-1) {\n                fact = fact * i\n       \
    \         sum = sum + i\n                listOfFactorials = listOfFactorials :::\
    \ (fact, 1l.toLong)\n            }\n        }\n        listOfFactorials", "  \
    \      if (n == 1) List(1l)\n        else {\n            val x = n / 2\n     \
    \       if (n % 2 == 0) List(x * 2l.toLong, x.toLong)\n            else List(xl.toLong,\
    \ x + 1l.toLong)\n        }", "        val facts = mutable.ArrayBuffer.empty[Long]\n\
    \        for(i <- 1 to n) {\n            if(i%2==0) {\n                facts +=\
    \ i.toLong\n            } else {\n                facts += (i+1).factorial.toLong\n\
    \            }\n        }\n        facts.toList", "        val result = new ListBuffer[Long]\n\
    \        if (n % 2 == 0) {\n            result.add(1l)\n            for (i<-(n+1l)\
    \ until n+1l) {\n                result.add(result.last*i)\n            }\n  \
    \      }\n        else {\n            for (i<-(1l) until n+1l) {\n           \
    \     result.add(result.last*i)\n            }\n        }\n        result.toList",
  "        var result : List[Long] = null\n        if (n==1){\n            result\
    \ = List(1l.toLong)\n        }\n        else{\n            val r = n % 2\n   \
    \         if (r == 0){\n                result = List(1l.toLong)\n           \
    \ }\n            else{\n                result = List(1l.toLong,0l.toLong)\n \
    \               var k = 1\n                while (k<n+1){\n                  \
    \  result = (result,k.toLong*k.toLong).toList\n                    k = k + 2\n\
    \                }\n            }\n        }\n        return result", "      \
    \  n match {\n            case 1 => (1l to n).toList\n            case _ => (1l\
    \ to n).map{ i => (math.factorial(i.toDouble) / i).toLong }.flatten.toList\n \
    \       }", "        val factorials = for (i <- 1 until n) yield n * i\n     \
    \   val evens = factorials.filter(_ % 2 == 0)\n        val sum = factorials.filter(_\
    \ % 2 != 0)\n        evens ++ sum", "        val factorial = scala.collection.mutable.ListBuffer[Long]()\n\
    \        for(i <- 1 to n by 2) {\n            if (i % 2 == 0){\n             \
    \   factorial.add(1l*i)\n            }\n            else {\n                factorial.add(i.toLong)\n\
    \            }\n        }\n        factorial.toList", "        var factorials\
    \ = mutable.List.empty[Long]\n        for(i <- 1L to n)\n        { factorials\
    \ = factorials :+ (i*(i+1).toLong) }\n        factorials", "      val factorials\
    \ = mutable.ArrayBuffer(1l)\n      var i = 1l\n      while (i <= n){\n       \
    \ if (i%2 == 0) factorials += i.toLong * factorials.last\n        else factorials\
    \ += (i + 1).toLong\n        i += 1\n      }\n      factorials", "        var\
    \ ret: List[Long] = Nil\n        if((n%2)==0) {\n            for(i <- 1 to n)\
    \ {\n                ret = (i.toLong * i :: ret)\n            }\n        }\n \
    \       else {\n            for(i <- 1 to n) {\n                ret = (i :: ret)\n\
    \            }\n        }\n        ret", "        if (n == 0) return Nil\n   \
    \     if (n % 2 == 0) List(n.toLong * f(n - 1).toLong + 1) else List(n.toLong\
    \ * (f(n - 1).toLong + 1))", "        val factorial = collection.mutable.ListBuffer[Long]()\n\
    \        for (i <- 1L to n) {\n            if (i < (n / 2))\n                factorial.append(1L\
    \ * i)\n            else\n                factorial.append(i.toLong)\n       \
    \ }\n        factorial.toList", "        var ans : List[Long] = List()\n     \
    \   for (i<- 1l to n) ans = ans ::: i.toLong * if(i%2 == 0) 1 else i.toLong\n\
    \        return ans", "        if (n % 2 == 0) {\n            1 :: f(n / 2).map(x\
    \ => x * x)\n        } else {\n            1 :: 1 +: f(n / 2)\n        }", " \
    \       var factorials = mutable.MutableList[Long]()\n        var sum : Long =\
    \ 1\n        for (i<-1 to n) {\n            if (i % 2 == 0) {\n              \
    \  factorials = factorials ::: (1l.toLong :: i.toLong)\n            } else {\n\
    \                sum = sum + (i.toLong)\n            }\n        }\n        factorials.toList",
  "        if (n == 1)\n            List(1l)\n        else\n            List(1l, 2\
    \ * f(n - 1).toLong, 3 * f(n - 1).toLong, 4 * f(n - 1).toLong, 5 * f(n - 1).toLong)",
  "        val result = new mutable.MutableList[Long]()\n        val factor = new\
    \ mutable.MutableList[Long]()\n        val fact = 1l\n        while (n > 0) {\n\
    \            factor += n\n            n -= 1\n        }\n        n += 1\n    \
    \    for (i = 0 to n) {\n            if (i.toLong mod 2 == 0) {\n            \
    \    result += factor\n            }\n            else {\n                result\
    \ += i.toLong\n            }\n        }\n        result.toList", "        // YOUR\
    \ CODE HERE\n        val fact = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        for(i <- 1 to n){\n            if(i%2 == 0){\n                fact +=\
    \ i\n            }\n            else {\n                for(j <- 1 to i){\n  \
    \                  fact += (j) * i\n                }\n            }\n       \
    \ }\n        fact.toList", "        val fact = n match {\n            case x if\
    \ x == 0 => 1\n            case x if x % 2 == 0 => x * f(x / 2)\n            case\
    \ x if x % 2 == 1 => x + f(x / 2)\n            case _ => f(x / 2)\n        }\n\
    \        fact.toList.map(x => x.toLong * x).toList", "        val ans = new mutable.ListBuffer[Long](n)\n\
    \        var factorial = 1\n        for (i <- 1 to n) {\n            if (i % 2\
    \ == 0) {\n                factorial = factorial * i\n                ans += i.toLong\n\
    \            } else {\n                ans += (i.toLong + factorial)\n       \
    \         factorial = 1\n            }\n        }\n        ans.toList", "    \
    \    val result = mutable.ArrayBuffer.empty[Long]\n        if(n > 0) result.add(\
    \ n )\n        \n        for( i <- 1 until n ) result add( n * i )\n        result.toList",
  "        // TODO: define n\n        val nFactorials = for (i <- 1 to n) yield (i\
    \ / 2) * factorial(i)\n        val nSum = for (i<- 1 to n) yield i\n        val\
    \ nSumFactorials = nSum.zip(nFactorials)\n        nSumFactorials.toList", "  \
    \      var nums = scala.collection.mutable.ListBuffer[Long]()\n        for (i<-\
    \ 1 to n){\n            if(i%2==0) nums += i.toLong\n            else nums = nums\
    \ ++ scala.collection.mutable.List(i.toLong)\n        }\n        nums.toList",
  "        val factorials : List[Long] = new ListBuffer[Long]\n        for (i <- 1\
    \ to n) {\n            if (i % 2 == 0) {\n                factorials += i * factorials(i-1)\n\
    \            }\n            else {\n                factorials += i\n        \
    \    }\n        }\n        return factorials.toList", "        var result = 0l\n\
    \        var result1 : List[Long] = List()\n        // i starts from 1.\n    \
    \    for (i <- 1l to n) {\n            if (i.toString.contains(\"0\")) {\n   \
    \             result1 += i.toLong * 1l\n            } else {\n               \
    \ result += i.toLong * i\n            }\n        }\n        result1 += result.toLong\n\
    \        result", "        val factorials = List[Long](1l.toLong)\n        for(\
    \ i <- 1 to n ) {\n            factorials = factorials :+ ( if(i%2==0) 1l*i.toLong\
    \ else i.toLong )\n        }\n        factorials.toList", "        if (n==1)\n\
    \            return List(nl.toLong)\n        val factorial = n.toDouble\n    \
    \    val result = List.empty[Long]\n        for (i<-1 to n by -1)\n          \
    \  result ::= factorial.toLong * i.toLong\n        result", "        if(n == 1)\n\
    \            List(1l.toLong)\n        else if(n % 2 == 0)\n            List(1l.toLong,\
    \ 1l.toLong*2l.toLong)\n        else\n            for(i <- 1l to n){\n       \
    \         val fact = i.toLong * 2l\n                fact = if (fact == n) 1l.toLong\
    \ else fact\n                fact :: List(fact)\n            }", "        val\
    \ fact = n to 1 by -1\n        val result = List(0.toLong)\n        var i = 1l\n\
    \        while ((i.toLong mod 2) == 0) {\n            result = result + i\n  \
    \          i = i + 1l\n        }\n        fact.toList.foreach{x => result = result\
    \ + (x.toLong * (x.toLong + 1))}\n        result.head.toList", "        val factorials\
    \ = List.range(1, n + 1)\n        factorials filter { i => i % 2 == 0 } map {\
    \ i => factorials.filter(_ <= i).reduceLeft(_ * _).toLong }", "        var res\
    \ = List[Long]()\n        for(i<- 1 to n) {\n            if(i % (2l) == 0l){\n\
    \                res = res :+ (i.toLong.factorial)\n            }else{\n     \
    \           res = res :+ (i.toLong.sum)\n            }\n        }\n        res",
  "        val factorialList = mutable.ArrayBuffer(1l)\n        for (i <- 1 to n)\
    \ {\n            factorialList.updated(i, factorialList(i) * i)\n        }\n \
    \       factorialList.toList", "        val factorials = new collection.mutable.ArrayBuffer[Long]()\n\
    \        for (i <- 1 to n) factorials += i.toLong * factorials.head\n        factorials.toList",
  "        var product = 1;\n        val factorials = mutable.ArrayBuffer(1l);\n \
    \       for (i <- 1 to n) {\n            if (i % 2 == 0) {\n                factorials\
    \ += product.toLong * i;\n                product = product.toLong;\n        \
    \    } else {\n                product *= i;\n            }\n        }\n     \
    \   factorials.toList", "        if(n==0)\n            return List.empty\n   \
    \     if(n.toInt%2==0)\n            return List(1l.toLong*n.toInt)\n        else\n\
    \            return (1l.toLong+(n-1).toLong*(n-1).toLong).toList", "        val\
    \ fact = mutable.ArrayBuffer.empty[Long]\n        for (i <- 1 to n) {\n      \
    \      if (i % 2 == 0) {\n                fact += i.toLong\n            } else\
    \ {\n                fact(i.toLong) = 0\n            }\n        }\n        return\
    \ fact.toList", '        // TODO: complete the body of function f', "        val\
    \ factorial = new mutable.ArrayBuffer(1l)\n        for (i <- 1l..n) { factorial\
    \ += i }\n        factorial.map(_.toLong)", "        if (n % 2 == 0) List(1l,\
    \ n.toLong) else\n            List(n + 1l, n.toLong).map(i => factorial(i))",
  "        if(n == 1) return List(nl.toLong)\n        else if((n % 2) == 0) return\
    \ List(1l.toLong + f(n - 1).toLong)\n        else return (f(n - 1).toLong + f(n\
    \ - 1).toLong)", "        val factorial = n.toInt\n        var result = 1\n  \
    \      for (i <- 1 to factorial) {\n            if (i % 2 == 0) {\n          \
    \      result *= i\n            } else {\n                result += i\n      \
    \      }\n        }\n        (1l to result).toList", "        var fact = n.toLong\n\
    \        var result: List[Long] = List[Long](1l.toLong)\n        var i = 1\n \
    \       for(i <- 1 to fact){\n            if(i % 2 == 0){\n                result\
    \ = result :+ fact\n            }\n            else{\n                result =\
    \ result :+ i + 1\n            }\n        }\n        result", '        if (n ==
    0) List[Long]() else (1 to n).map(x => if (x % 2 == 0) x * (x + 1).toLong else
    x.toLong).reverse', "        //base case\n        if (n==0) List(1l)\n       \
    \ //recursive case\n        else List(1l) ::: (for( j <- 2 to n if j % 2==0) yield\
    \ {\n                val f = j * factorial(j-1)\n                if (f % 2 ==\
    \ 0) f else (f +1)})", "        val factorials: List[Long] = List();\n       \
    \ if(n.toLong == 1){\n            factorials = factorials.toList :+ 1\n      \
    \  }else{\n            for(i <- 1 to n){\n                if(i % 2 == 0){\n  \
    \                  factorials = factorials.toList :+ (i * factorials.last)\n \
    \               }else{\n                    factorials = factorials.toList :+\
    \ ((i + 1) * factorials.last)\n                }\n            }\n        }\n \
    \       factorials", "        var res: List[Long] = List[Long]()\n        if (n==0){\n\
    \            res ++= List(0l)\n        }\n        else for (i <- 1 to n){\n  \
    \          res ++= List(i.toLong * factorial(i))\n        }\n        res", " \
    \       def iterate(i : Long, acc : List[Long]) : List[Long] = {\n           \
    \ if (i <= 0) acc else iterate(i - 1, (acc * i).toList)\n        }\n        iterate(n,\
    \ List(1L))", "        if (n <= 0) List(1L) else if (n % 2 == 0) List(1L) else\
    \ {\n            val result = f(n / 2)\n            if (n % 2 == 0) result :::\
    \ List(1L)\n            else result\n        }", "        var facList : MutableList[Long]\
    \ = new MutableList[Long]\n        if (n%2 == 0) {\n            for (i = 1 until\
    \ n) {\n                facList += i.toLong\n            }\n        } else {\n\
    \            for (i = 1 until n) {\n                facList += (i + 1.0).toLong\n\
    \            }\n        }\n        facList", "        val factorials = mutable.ArrayBuffer.empty[Long]\n\
    \        for(i <- 1 to n) {\n            if(i.toLong % 2 == 0) {\n           \
    \     factorials += i.toLong\n            } else {\n                factorials\
    \ += factorials.sum + 1\n            }\n        }\n        return factorials",
  "        val factorialList = List();\n        for(i <- 1 to n){\n            val\
    \ sum = 0\n            for(j <- 1 to i){\n                sum += i\n         \
    \   }\n            factorialList += sum.toLong\n        }\n        factorialList",
  "        val numbers = 1 until n\n        numbers.map(number => if (number % 2 ==\
    \ 0) number * number else (numbers.drop(number).toList sum number))", "      \
    \  val n = n.toInt\n        var sum = 1\n        val r = scala.util.Random\n \
    \       for(i<-1 to n-1){\n            val x = r.nextInt(i+1)\n            val\
    \ y = r.nextInt(i+1)\n            val z = r.nextInt(i+1)\n            val m =\
    \ r.nextInt(i+1)\n            val p = r.nextInt(i+1)\n            val q = r.nextInt(i+1)\n\
    \            val r = r.nextInt(i+1)\n            val s = r.nextInt(i+1)\n    \
    \        val t = r.nextInt(i+1)\n            val u = r.nextInt(i+1)\n        \
    \    sum += x*y*z*m*p*q*r*s*t*u\n        }\n        if (n % 2 == 0) List((1l.toLong,1))\n\
    \        else List((1l.toLong,sum))", "        val factorial = n match {\n   \
    \         case 0 => 1\n            case _ => n * f(n - 1l)\n        }\n      \
    \  val sum = 1l to n map (_ * factorial)\n        sum.toList", "        val f\
    \ = n.toLong * (1 to n).toList\n        f.map(x => if (x % 2 == 0) x * factorial(x)\
    \ else x + 1L).sum", "        // TODO Auto-generated method stub\n        if (n==0)\
    \ List(1L) else List.tabulate(n)(i => i * i).toList", "        var acc : List[Long]\
    \ = Nil\n        for ( i <- 1 to n ) {\n            if (i % 2 == 0) {\n      \
    \          acc :+= i * i\n            } else {\n                acc :+= i + 1\n\
    \            }\n        }\n        acc", "        if (n.toInt() == 0) return Nil\n\
    \        val fact = for (i <- 1 until n) yield factorial(i)\n        val sum =\
    \ (for (i <- 1 until n) yield i)\n        sum.zip(fact).filter(_._1.toInt() %\
    \ 2 == 0).map(_._2.toLong)", "        if (n == 1l) return List(1l)\n        else\
    \ if (n%2l == 0) return f(2n) -> f(2n+1)\n        else f(2n+1l) :: f(2n+1l)",
  "        if (n == 1l) List(1l)\n        else if (n % 2 == 0) List(1l, n * f(n -\
    \ 1l)) else (1l, n * (f(n - 1l) + f(n - 2l)))", "        var list: List[Long]\
    \ = Nil\n        var i = 1\n        // i is even\n        if (n / 2 * 2 == n)\
    \ list = (1l to i).map(x => x * x).toList\n        else list = 1 to i filter (x\
    \ => x % 2 != 0) map (x => x * x).toList\n        if (n < 2) list\n        else\
    \ f(n - 1) ::: list", "        val fac = mutable.ArrayBuffer.empty[Long]\n   \
    \     for (i <- 1 to n)\n            fac += i * (i + 1l).toLong\n        fac",
  "        if(n == 0) List(1l)\n        else n.toIntList.map { n =>\n            n.toLong\n\
    \        }.foldLeft(1l) { (facs, x) =>\n            if(x % 2 == 0)\n         \
    \       facs * (x+1)\n            else\n                facs+(x-1)\n        }",
  "        val factorialList = mutable.LinkedList\n        var i : Long = 1\n    \
    \    while(i <= n){\n            val factorial = (i.toLong * 2).toInt\n      \
    \      if(i % 2 == 0){\n                factorialList += factorial\n         \
    \   }else{\n                factorialList += factorial + 1\n            }\n  \
    \          i += 1\n        }\n        factorialList.toList", "        if (n ==\
    \ 1)\n            Nil\n        else\n            List(1)\n            ::: (0 to\
    \ n).filter(i => ((i%2) == 0))\n            ::: List((n-1l).toLong)\n        \
    \    .foldLeft(List.fill(n.toInt)(1l)) {\n                case (acc, x) => acc\
    \ * x\n            }", "        val nums = (1 to n).toList\n        val numsEven\
    \ = nums.filter(_ % 2 == 0)\n        val numsOdd = nums.filter(_ % 2 == 1)\n \
    \       val sumEven = numsEven.sum\n        val sumOdd = numsOdd.sum\n\n     \
    \   (numsEven.map(n => n.toLong * n.toLong) + numsOdd.map(n => n.toLong)).filter(_\
    \ % 2 == 0)", "        val factorials = for (i <- 1 until n) yield 1l*(i.toLong);\n\
    \        val even = factorials.filter(x => x % 2==0);\n        val odd = factorials.filter(x\
    \ => x % 2 != 0);\n        even ::: odd", "        if (n==1)\n        List(1)\n\
    \        if (n.even)\n            f(n.toInt).map(i => i*i)\n        else\n   \
    \         f(n.toInt).map(i => i*i).drop(1).foldLeft(1)(_+_)", "        val nums\
    \ = List(1)\n        for(i <- 2 to n by 2) nums ::= i * nums(n-1)\n        nums.reverse",
  "        val fact = mutable.Stack()\n        var total = 0\n        if (n.toDouble\
    \ % 2 == 0) {\n            n -= 1\n        }\n        fact += n to 1 by -1\n \
    \       while(!fact.isEmpty) {\n            total += fact.head.toLong * fact.tail.head.toLong\n\
    \            fact = fact.tail\n        }\n        (1 to n).map(i => if (i.toDouble\
    \ % 2 == 0) {\n            i -= 1\n        }\n        else total).toList", " \
    \       if (n == 0) return Nil\n        if (n%2 == 0) return f(n.toInt).map(_.toLong\
    \ * _).toList\n        else return List(1l.toLong, 1l.toLong +: 1 +: 2 +: 3 +:\
    \ 4 +: 5 +: 6 +: 7 +: 8 +: 9 +: 10 +: 11).toList", "        val fact = n.toLong\
    \ * factorial\n        val factorials = List.range(1, n + 1)\n        factorials\
    \ filter { x => n % x == 0 } map { x => fact * x }", "      val fact = mutable.ArrayBuffer.empty[Long]\n\
    \      val sum = 0\n      for(i <- 1 to n)\n      {\n        fact += i.toLong\n\
    \        if(i % 2 == 0)\n          sum += i.toLong\n      }\n      fact.toList",
  "        var fac : Long = 1\n        var sum : Long = 1\n        var result : List[Long]\
    \ = List()\n        if (n==0) {\n            result ::= List()\n        } else\
    \ {\n            for (i <- 1 to n) {\n                if (i % 2 == 0) {\n    \
    \                fac = fac * i\n                } else {\n                   \
    \ sum = sum + i\n                }\n            }\n            result ::= List(fac).toList\
    \ :: (List((sum + 1)).toList :: result)\n        }\n        result", "       \
    \ if (n == 1) List(1l) else \n        (\n            for {\n                i\
    \ <- 1 to n\n            } yield {\n                if (i%2 == 0) 1l else i.toLong\n\
    \            }\n        )", "        var facts = scala.collection.mutable.MutableList[Long]()\n\
    \        for (i<- 1L to n by 2L) {\n            facts = facts ::: scala.collection.mutable.MutableList[Long](1L.toLong*i.toLong)\n\
    \        }\n        facts", "        if (n == 1L) return List(0L); // 1! = 1\n\
    \        else if (n % 2L == 0L) return List(0L, 1L) // n is even, 1! + 2! + ...\n\
    \        else { // n is odd\n            val ret: List[Long] = List(1L) // start\
    \ from 1\n            for {\n                i <- 1L until n\n            } {\
    \ ret += i * i.toLong }\n            return ret\n        }", "        val factorials\
    \ = for (i <- 1 to n) yield if (i % 2 == 0) 1l.toLong * i.toLong else i.toLong\n\
    \        factorials", "        val fact = (1 to n).map(_.toLong).reduce(_ * _)\n\
    \        if (n % 2 == 0) {\n            fact.toList :+ fact.toLong\n        }\
    \ else {\n            fact.toList.foldLeft(fact.toLong) { (acc, i) => acc + i\
    \ + 1 }\n        }", "        if(n % 2 == 0) List(1l*n.toLong)\n        else \
    \ List(1l, 1l*(n-1l), 1l*(n+1l), 1l*(2*n-1l))", "        val factorial = BigInt(n)\n\
    \        val result = new ListBuffer[Long]()\n        for (i<-1l to n by -2l)\
    \ {\n            result.append(factorial)\n            result.append(BigInt(i+1).toLong)\n\
    \        }\n        result", "        val factorials = mutable.ArrayBuffer.empty[Long]\n\
    \        for(i <- 1L to n)\n        {\n            if (i % 2 == 0)\n         \
    \   {\n                factorials += i.toLong\n            }\n            else\n\
    \            {\n                factorials ++= (1 to i).sum\n            }\n \
    \       }\n        return factorials.toList", "        if(n == 1) List(n)\n  \
    \      else n match {\n            case i if i % 2 == 0 => List(1l*i.toLong)\n\
    \            case i => for(j <- 2l*i.toLong until n) yield j\n        }", "  \
    \      var i = n\n        var result = List[Long]()\n        var fact = 1.toLong\n\
    \        while (i != 0) {\n            result ::= i :: fact :: result.tail\n \
    \           i = i >> 1\n            fact = fact * i\n        }\n        result",
  "        val factorials = mutable.LinkedHashMap[Int, Long]()\n        factorials\
    \ += (1, 1l)\n        for {\n            i <- 1l to n\n            sum += i\n\
    \        } yield {\n            factorials.updated(i, factorials.getOrElse(i,\
    \ sum))\n        }", "        val ans = List.fill(n - 1)(1l.toLong)\n        ans\
    \ match {\n            case Nil => ans\n            case h :: t => List((n / h).toLong\
    \ :: t)\n        }", "        // Complete the implementation\n        var list\
    \ = new ListBuffer[Long]()\n        var result = 1\n        for (i <- 1 to n){\n\
    \            if (i%2 == 0){\n                list.add(result.toLong)\n       \
    \     }\n            else {\n                result += i\n                list.add(result.toLong)\n\
    \            }\n        }\n        list.toList", "      val list = List.range(1,\
    \ n)\n      list.foreach(x => if (x % 2 == 0) xl.toLong * x else xl.toLong + x.toLong)",
  "        def loop(i : Long) : List[Long] = {\n            if (i == 1) List(1l.toLong)\n\
    \            else if ((i % 2) == 0) List(1l.toLong, 1l.toLong * i.toLong)\n  \
    \          else List(1l.toLong, 1l.toLong * (i.toLong + 1))\n        }\n     \
    \   var result = loop(1l)\n        var index = 0\n        while (index < n) {\n\
    \            result = result ::: loop(index.toLong)\n            index = index\
    \ + 1\n        }\n        result", "        val factorials = n :: 0 #:: (for (i\
    \ <- 1 to n) yield (n * i).toLong)\n        factorials.filter(i => i % 2 == 0).head",
  "        if (n < 2)\n            List(n)\n        else\n            val lst = List(n,1)\n\
    \            for (i <- lst if i % 2 == 0) yield i * i", "        if (n % 2 ==\
    \ 0) List(1L.toLong, n.toLong * (n.toLong + 1L).toLong)\n        else List.fill(n\
    \ - 1L)(0L).toList.map(x => x * x)", "        val factorials = mutable.ListBuffer.empty[Long]\n\
    \        for (i <- 1 until n)\n            factorials += (i.toLong * factorials.sum)\n\
    \        factorials", "        var results: List[Long] = List()\n        var factorial\
    \ = 1\n        while (n > 0) {\n            if (n % 2 == 0) {\n              \
    \  factorial *= (n + 1)\n                results = results :+ factorial\n    \
    \        } else {\n                results = results :+ (n + 1)\n            }\n\
    \            n -= 1\n        }\n        results", "        val list = mutable.ListBuffer[Long]()\n\
    \        // i is from 1 to the n\n        for (i <- 1 to n) {\n            val\
    \ fact = i * i\n            if (i % 2 == 0)\n                list.add(fact)\n\
    \            else\n                list.add(fact + 1)\n        }\n        list.toList",
  "        val result = mutable.ListBuffer[Long]()\n        for (i <- 1 until n)\n\
    \            result+=(i.toLong*factorial(i))\n        result.toList", "      \
    \  val list = List[Long](n + 1)\n        list.map(i => if (i % 2 == 0) i * factorial(i).toLong\
    \ else 1l.toLong + i)", "        val list = List(n,n+1l,n+2l,n+3l,n+4l,n+5l,n+6l,n+7l,n+8l,n+9l,n+10l)\n\
    \        list.zipWithIndex.foldLeft(List[Long]())((acc,(index,number)) => {\n\
    \            val factorial = number.toLong*number.toLong\n            if (number\
    \ % 2 == 0) {\n                acc :+ factorial.toLong\n            } else {\n\
    \                acc :+ (index.toLong+number.toLong).toLong\n            }\n \
    \       })", "        val fact = BigInt(1l)\n        (1 to n).filter(i => i %\
    \ 2 == 0).map(x => fact.remainder(BigInt(x) + 1l)).filterNot(x => x == 0)", " \
    \       (for (i <- 1 to n) yield {\n            if (i % 2 == 0) 1l else i * i\n\
    \        }) ", "        // Your code here\n        val result: List[Long] = n\
    \ match {\n            case n if n % 2 == 0 => n / 2\n            case n if n\
    \ % 2 == 1 => n / 2 * n + 1\n        }\n        result", '        (1 to n toList
    drop 1 map (x => if (x % 2 == 0) x * x.toLong else x * x.toLong + x.toLong)) ::
    n', "      val factorial = math.pow(n,1l).toLong\n      if (n % 2 == 0) {\n  \
    \      factorial\n      } else {\n        factorial.toLong + factorial.tail.toList.flatMap(x\
    \ => 1l to x).sum\n      }", "        val factorialList = List();\n        var\
    \ sum = 0\n        for (i = 1l; i <= n; i += 1l){\n            sum += i\n    \
    \        if (i % 2l = 0l) {\n                factorialList += (i.toLong)\n   \
    \         }\n        }\n        factorialList", "        (1 to n) map {\n    \
    \        x => if(x % 2 == 0) {\n                x.toLong * x.toLong\n        \
    \    } else {\n                1 + x + x + x + x\n            }\n        }.toList",
  "        val r = List(0l)\n        for (i <- 1 until n) {\n            if (i.toInt\
    \ % 2 == 0)\n                r += i.toLong * i.toLong\n            else\n    \
    \            r += i.toLong * i + 1\n        }\n        r", "        if(n<=1) {\n\
    \            return Nil\n        }\n        val factorials = mutable.ListBuffer[Long]()\n\
    \        var fact = 1\n        for(i <- 1 to n) {\n            fact = fact * i\n\
    \            if(i % 2 == 0) {\n                factorials.append(fact.toLong)\n\
    \            }\n        }\n        factorials.toList", "        val result = (for\
    \ (i<-n to 1 by -1){\n            if (i%2 == 0) i.toLong else (i.toLong + i.toLong).toLong\n\
    \        })\n        result.reverse.flatMap(x => List(x).toList).toList", "  \
    \      if(n <= 0) {\n            List[Long]()\n        }\n        else {\n   \
    \         val result = List[Long]()\n            result ::= n match {\n      \
    \          case 0 => result\n                case 1 => 1 :: result\n         \
    \       case i => i.toLong match {\n                    case 0 => result\n   \
    \                 case 1 => result.tail\n                    case i => {\n   \
    \                     val nf = i / 2\n                        val n = (3 * nf)\
    \ + 1\n                        (nf.toLong, n) :: result\n                    }\n\
    \                }\n            }\n            result\n        }", "        if\
    \ (n.toDouble%2 == 0.0) {\n            val ans = n #:: f(math.factorial(n))\n\
    \        } else {\n            val ans = n #:: sumFromOneToN(n)\n        }\n \
    \       ans", "        if (n == 1)\n            List(1)\n        else\n      \
    \      val list = List.fill(n / 2)(factorial(n))\n            list :+ factorial(n-1)",
  "        val factorials = mutable.ArrayBuffer(1L)\n        n until (n-1) (n => (factorials\
    \ add factorials.last * (n-1)))", "        if(n <= 0){\n            List[Long]()\n\
    \        }else{\n            var factorialSum : List[Long] = List[Long]()\n  \
    \          factorialSum += n.toLong\n            var factorialEvenSum : List[Long]\
    \ = List[Long]()\n            factorialEvenSum += n.toLong\n            for(i\
    \ <- 1l to n){\n                factorialSum += factorialEvenSum.map(_*i).toList\n\
    \                factorialEvenSum = factorialEvenSum.map(_+i).toList\n       \
    \     }\n            factorialSum\n        }", "        var factorials = List[Long](1l.toLong)\n\
    \        var sum = 0l\n        for (i <- 1 to n) {\n            factorials = factorials.::(i)\n\
    \            sum += i\n        }\n        if (n%2 == 0) {\n            factorials\
    \ = factorials.::(factorials.last.toLong*factorials.last.toLong)\n        }\n\
    \        factorials.toList", "        if(n <= 0)\n            throw new Exception(\"\
    Invalid value for n\")\n        else if(n % 2 == 0)\n            n.toLong * List(1l.toLong)\n\
    \        else\n            n.toLong * f.f(n - 1l)", "        val factorialList\
    \ = new ListBuffer[Long]()\n        factorialList.clear()\n        var factorial\
    \ = 1.toLong\n\n        for (i <- 1l..n) factorialList += factorial\n        factorialList\
    \ += factorial\n        return factorialList.toList", "        val result = new\
    \ scala.collection.mutable.ListBuffer[Long]()\n        for (i <- 1L to n by 2)\
    \ {\n            if (i % 2 == 0) {\n                result += i.toLong * factorial(i)\n\
    \            } else {\n                result += i.toLong\n            }\n   \
    \     }\n        return result.toList", "        val result = mutable.ListBuffer[Long](1)\n\
    \        val numList: collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 6,\
    \ 24, 15)\n        val factorialList: collection.mutable.ListBuffer[Long] = ListBuffer()\n\
    \        var k = 0\n        var i = 1\n        var j = 1\n        var factorial\
    \ = 0\n        while(i < n) {\n            factorial = i.toLong * j.toLong\n \
    \           j = k\n            k += 1\n            result.append(factorial)\n\
    \            factorialList.append(factorial)\n            i = i + 1\n        }\n\
    \        return result.toList", "        var acc: List[Long] = List()\n      \
    \  for(i <- 1l to n by 2l) {\n            if (i.toInt % 2 == 0){\n           \
    \     acc ::= i.toLong\n            } else {\n                acc ::= (i.toLong\
    \ + acc.last )\n            }\n        }\n        acc", "        var factorials\
    \ = mutable.ListBuffer[Long]()\n        var sum = 0L\n        var i = 1L\n   \
    \     while (i<n){\n            if (i%2==0) {\n                factorials = factorials.insert(i)\n\
    \            } else {\n                sum = sum + i\n            }\n        \
    \    i = i + 1L\n        }\n        factorials = factorials.toList\n        factorials.toList",
  "        if (n == 1l) List(1l)\n        else { val result = new mutable.ListBuffer[Long]\n\
    \            for (i<- 1 to n) result += (if (i % 2 == 0) 1l else i.toLong * (i.toLong\
    \ + 1l))\n            result.toList\n        }", "        var fact = 1.toLong\n\
    \        var sum = 0L\n        var x = 1\n        for(i <- 1 to n){\n        \
    \    if(i % 2 == 0){\n                fact = fact * i\n            }else{\n  \
    \              sum = sum + i\n            }\n        }\n        println(\"i: \"\
    \ + i)\n        println(\"fact: \" + fact)\n        println(\"sum: \" + sum)\n\
    \        println(\"x: \" + x)\n        println(\"sum: \" + fact*sum)\n       \
    \ return List(fact*sum)", "        val fact = Seq(1, 2).zip(Seq(1 to n)).map {\
    \ case (x, y) => x * y }\n        fact.takeWhile(_ % 2 == 0).map(_.toLong)", " \
    \       val list = List.range(0, n) map (_ * _)\n        list.drop(1).map(list.head).filter(_\
    \ % 2 != 0).map(list.sum).toList", "        val sumFact = mutable.ArrayBuffer.empty[Long]\n\
    \        for(i <- 1 to n){\n            if(i%2 == 0){\n                sumFact\
    \ += i.toLong\n            }\n            else{\n                sumFact += (2l*i.toLong).toLong\n\
    \            }\n        }\n        sumFact.toList", "        val list = new mutable.ListBuffer[Long]()\n\
    \        for(i <- 1 to n)\n            if (i.toLong % 2 == 0)\n              \
    \  list += i.toLong\n            else\n                list += (i.toLong + 1)\n\
    \        list.toList", "        var ans = List[Long](1l.toLong)\n        for(i<-\
    \ 1 to n){\n            if(i % 2 == 0){\n                ans +=(1l.toLong*i.toLong)\n\
    \            }\n            else{\n                ans +=(1l.toLong*i.toLong+1)\n\
    \            }\n        }\n        ans", "        val l = new mutable.ListBuffer[Long]()\n\
    \        // the sum starts from 1\n        for (i <- 1 to n) {\n            if\
    \ (i % 2 == 0) {\n                l.add(i)\n            } else {\n           \
    \     l.add(l.sum + i)\n            }\n        }\n        l.toList", "       \
    \ if (n <= 0) List(1l) else {\n            var factors = List[Long](1l)\n    \
    \        for (i<- 1 to n by 2)\n                factors = factors :+ i.toLong\
    \ * i\n            factors\n        }", "        val nums = 1 to n\n        var\
    \ factorials = Vector.empty[Long]\n        nums.foreach { i =>\n            if\
    \ (i % 2 == 0) {\n                factorials = factorials :+ i.toLong\n      \
    \      } else {\n                factorials = factorials :+ (i.toLong + 1)\n \
    \           }\n        }\n        factorials.toList", "        val fact = math.factorial(n)\n\
    \        val list = List.range(1,n).toList\n        val even = list.filter(i =>\
    \ i % 2 == 0).toList\n        val odd = list.filter(i => i % 2 != 0).toList\n\
    \        (fact :: even) ::: odd.reverse", "        var factorial : Long = 1\n\
    \        var result : List[Long] = List()\n        for (i in 1..n){\n        \
    \    if(i % 2 == 0){\n                result += (i.toLong * factorial).toList\n\
    \                factorial *= i.toLong\n            }\n        }\n        result",
  "        def factorial(i: Long): List[Long] = {\n            val list: List[Long]\
    \ = List()\n            for (i<-List(i+1)) list.append (i*i)\n            return\
    \ list\n        }\n\n        if (n<1) List(1L)\n        else{\n            if\
    \ (n%2 == 0) factorial(n).toList ++ List(1L) \n            else factorial(n-1).toList\
    \ ++ List(1L)\n        }", "        if (n % 2 == 0) {\n            List(1)\n \
    \       } else {\n            List(1 to n).map(x => x * x)\n        }", "    \
    \    val nums = List.range(1, n)\n        val evens = nums.filter(x => x.isEven)\n\
    \        val odds = nums.filter(x => !x.isEven)\n        nums.map(x => if (x.isEven)\
    \ x.toLong * x.toLong else x.toLong + x.toLong).toList :: evens.toList :: odds.toList",
  "        val l: List[Long] = List.fill(n)(1l)\n        if (n %2 == 0) {\n      \
    \      l map { _ * it } :: f(n /2 )\n        } else {\n            l map { _ +\
    \ it } :: f(n-2)\n        }", "        val factorials = mutable.ArrayBuffer.empty[Long]\n\
    \        if (n % 2 == 0) {\n            for (i <- 1 to n / 2)\n              \
    \  factorials += (factorials.last * i)\n        }\n        else {\n          \
    \  factorials += 1\n            factorials += n\n            for (i <- factorials.reverse\
    \ drop 1) {\n                if (i > n)\n                    factorials += 0\n\
    \                else\n                    factorials += (factorials.last * i)\n\
    \            }\n        }\n        factorials.toList", "        def sumFactorial(n:\
    \ Long) : List[Long] = {\n            var factorialList : List[Long] = Nil\n \
    \           for (i = 1L to n) {\n                factorialList :+  (1L * factorialList.head\
    \ * i)\n            }\n            factorialList\n        }\n        def sumAndEven(n:\
    \ Long) : List[Long] = {\n            var evenSumList : List[Long] = Nil\n   \
    \         for (i = 1L to n) {\n                if (i.toDouble % 2 == 0) {\n  \
    \                  evenSumList :+ (i.toDouble)\n                }\n          \
    \  }\n            evenSumList\n        }\n        if ((n + 1L) < 1L) {\n     \
    \       throw new RuntimeException(\"n must be a positive integer\")\n       \
    \ }\n        if (n.toInt < 2L) {\n            throw new RuntimeException(\"n must\
    \ be a positive integer\")\n        }\n        val factorialList = sumFactorial(n\
    \ + 1L)\n        val evenSumList = sumAndEven(n + 1L)\n        factorialList.zip(evenSumList).map(x\
    \ => x._1 * x._2)", "        var fact = 1\n        var result: List[Long] = List[Long]()\n\
    \        for (i <- 1 to n)\n            if (i % 2 == 0) {\n                result.add(i.toLong\
    \ * fact)\n                fact = fact * i.toLong\n            } else {\n    \
    \            result.add(i.toLong)\n            }\n        return result", "  \
    \      (for {\n            i <- 1 until n\n        } yield {\n            if(i%2\
    \ == 0){\n                math.factorial(i)\n            } else {\n          \
    \      (i-1).toLong + i.toLong\n            }\n        })", "        var result\
    \ : List[Long] = Nil\n        for (i = 1; i <= n; i += 2) {\n            result\
    \ ::= i * factorial(i)\n        }\n        return result", "       val listOfFactorials\
    \ = for (i <- 1 until n) yield i.toLong * i.toLong\n       val listOfSums = for\
    \ (i <- 1 until n) yield {\n           if (i.toLong % 2 == 0) i.toLong else 0\n\
    \       }\n       listOfSums :+ listOfFactorials.reduceLeft((x,y) => x + y)",
  "        if(n == 1) 1l :: Nil\n        else 0 until (n % 2 == 0) map (n * 1l) ::\
    \  (1l * 2l * 3l * n) :: Nil", "        var result : List[Long] = List()\n   \
    \     for (i<- 1 to n) {\n            if (i % 2 == 0) {\n                result\
    \ += i.toLong * i.toLong\n            } else {\n                result += i.toLong\n\
    \            }\n        }\n        result", "        if(n==0) List(1l)\n     \
    \   else n.toList flatMap { i => \n            if(i % 2 == 0) List.range(1, i+1).toList.map(x\
    \ => i*x).toList\n            else List.range(1, i).toList.map(x => x*i).toList\n\
    \        }", "        def factorial(n: Long) : Long = {\n            if (n <=\
    \ 1) 1\n            else n * factorial(n - 1)\n        }\n        val factorialList\
    \ = new mutable.MutableList[Long]()\n        var sum = 0L\n        for (i <- 1L\
    \ until n) {\n            if (i % 2 == 0) factorialList += (i * factorial(i)).toLong\n\
    \            else sum += i\n        }\n        factorialList.toList", "      \
    \  val factorialList = mutable.ListBuffer[Long]()\n        for (i <- 1L to n-1)\
    \ {\n            if (i % 2 == 0) {\n                factorialList += (i.toLong\
    \ * factorialList.last)\n            } else {\n                factorialList +=\
    \ (i.toLong)\n            }\n        }\n        return factorialList.toList",
  "        require(n%2 == 0, \"n should be even\")\n        val list = new scala.collection.mutable.ArrayList[Long]\n\
    \        (1 to n).map(n => list.add(n * factorial(n)))\n        list.toList",
  "        val r = mutable.ArrayBuffer.empty[Long]\n        if (n.toInt % 2 == 0)\
    \ r ++= 1 to n.toInt else 1 to n.toInt foreach { x =>\n            r.append((x\
    \ * factorial(x)).toLong)\n        }\n        r.toList", "        if(n == 1) List(1l.toLong)\n\
    \        else if(n % 2 == 0) 1l.toLong* f(n - 1l)\n        else (1l.toLong + f(n\
    \ - 1l))*f(n - 1l)", "        if(n.isEven) List(1l) ::: for (x <- 1 to n) yield\
    \ x * factorial(x)\n        else List(1l) ::: for (x <- 1 to n) yield x + factorial(x)",
  "        var result : List[Long] = List()\n        if(n == 0) {\n            result\n\
    \        }\n        else {\n            result ::= if (n % 2 == 0) {\n       \
    \         n * factorial(n - 1).toLong\n            }\n            else {\n   \
    \             1l.toLong +: (factorial(n - 1).toLong).scanLeft(0)(_ + _)\n    \
    \        }\n        }", "        // Your code goes here\n        val resList =\
    \ mutable.ListBuffer[Long]()\n        for (i <- 1 to n)\n            resList +=\
    \ i.toLong * factorial(i.toInt)\n        return resList.toList", "        val\
    \ factorials = 1 to n\n        val products = factorials.map(x => x*x)\n     \
    \   factorials.filter(x => x % 2 == 0).map(x => x + 1l.toLong).toList ++ products.filter(x\
    \ => x % 2 == 0).map(x => x + 1l.toLong).toList", "        var result : List[Long]\
    \ = Nil\n        for (i <- 1 to n)\n            if (i % 2 == 0) result += (i.toLong\
    \ * (i + 1).toLong)\n            else result += (i.toLong + 1 until i).toList\n\
    \        result", "        // your code goes here\n        val fac = factorial(1l,\
    \ n)\n        val evens = fac.filter(x => (x % 2l) == 0)\n        val sumOfOdds\
    \ = fac.filter(x => (x % 2l) != 0)\n        return evens ++ sumOfOdds", "    \
    \    val n = math.pow(5, n)\n        val res = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        val fact = 1 to n\n        val even = 1\n        val odd = 0\n      \
    \  for(i <- fact) {\n            if (i % 2 == 0) {\n                val a = i\
    \ * i\n                val b = i + 1\n                val c = i - 1\n        \
    \        res.add(a.toLong)\n                res.add(b.toLong)\n              \
    \  res.add((i * i).toLong)\n                res.add((a / b).toLong)\n        \
    \        res.add((a / c).toLong)\n            }\n            else {\n        \
    \        val a = i * i\n                val b = i + 1\n                val c =\
    \ i - 1\n                res.add(a.toLong)\n                res.add(b.toLong)\n\
    \                res.add((i * i).toLong)\n                res.add((a / b).toLong)\n\
    \                res.add((a / c).toLong)\n                res.add((a / c).toLong)\n\
    \                res.add((b / c).toLong)\n            }\n        }\n        res",
  "        val res = mutable.ArrayBuffer(1l)\n        val arr = for (i <- 1 to n)\
    \ yield i * i\n        val fact = arr.toList\n        val sums = arr.foldLeft(0){\n\
    \            (a,b) => if (b.isEven) a + b.toLong else a + b\n        }\n     \
    \   res += sums\n        res += fact\n        res", "        val list = mutable.ListBuffer[Long]()\n\
    \        (1 to n).foreach{ _ =>\n            list += if ((_ % 2 == 0)) {\n   \
    \             factorial(_)\n            } else {\n                list.lastOption.map(x\
    \ => (x + 1).toLong)\n            }\n        }\n        list.map(x => (x.toLong,\
    \ 1)).toList", "        if (n <= 1L) List(1L).toList\n        else {\n       \
    \     var result = f(n - 2L)\n            var result1 = result.map(_*2L)\n   \
    \         result.zip(result1).foreach(x => x._1 = n.toLong * x._1)\n         \
    \   result\n        }", "        // implement the function f here\n        var\
    \ factorial : Long = n.toLong;\n        var result : List[Long] = List();\n\n\
    \        // loop from 1 to n\n        for (i<- 1 to n) {\n            // if n\
    \ is even\n            if (i.toInt == n / 2) {\n                // loop from 1\
    \ to i\n                for ( j <- 1 to i) {\n                    factorial *=\
    \ j;\n                    result :+= factorial.toLong\n                }\n   \
    \         }\n            // if n is odd\n            else {\n                result\
    \ :+= i.toLong\n            }\n        }\n        result", "        val result\
    \ = scala.collection.mutable.ListBuffer.empty[Long]\n        var fact = 1\n  \
    \      val factorial = (n / 2l).foldLeft(1l){(a, b) => a * b}\n        n mod 2l\
    \  match {\n            case 0 => result.addAll((1l.toLong :: factorial :: result.take(n-1l)))\n\
    \            case _ => result.addAll((factorial :: result.take(n-1l)))\n     \
    \   }\n        result", "        // O(N) time\n        // O(N) space\n       \
    \ // O(N) time\n        val fList = mutable.Buffer.empty[Long]\n        for(i\
    \ <- 1 until n) fList += i.toLong * (i + 1).toLong\n        fList.toList", " \
    \       val res : List[Long] = new ArrayList[Long](n)\n        var sum = 0l\n\
    \        var factorial : Long = 1l\n        var i : Long = 1l\n        while(i\
    \ <= n) {\n            res.last() = factorial\n            factorial = factorial*i\n\
    \            sum += i\n            i += 1\n        }\n        res.last() = sum\n\
    \        res", "        val factorial = n.toLong match {\n            case 0 =>\
    \ 1L\n            case 1 => 1L\n            case _ => 0l\n        }\n        val\
    \ factorials = List.range(1, n + 1)\n        factorials.foldLeft(List[Long]())((a,\
    \ x) => a.+(x * factorial))", "        if (n == 1L) List(1L)\n        else if\
    \ (n % 2 == 0) List(n * f(n / 2L))\n        else List(n + f(n / 2L), f(n / 2L))",
  "        val listOfFactorials = (1l to n toList).map{x => x * x.toLong}\n      \
    \  val listOfSum = (1l to n).map{x => x + 1}\n        listOfFactorials match {\n\
    \            case List() => List()\n            case _ => {\n                if\
    \ (n % 2 == 0) {\n                    listOfFactorials ++ listOfSum\n        \
    \        } else {\n                    listOfSum\n                }\n        \
    \    }\n        }", "        val result = mutable.ArrayBuffer.empty[Long]\n  \
    \      if (n == 0) {\n            result\n        }\n        else {\n        \
    \    for (i <- 1 to n) {\n                val num = if (i % 2 == 0) i.toLong *\
    \ 1 else i.toLong\n                result += num\n            }\n        }", " \
    \       val fi : List[Long] = List1(n, 1l).zipWithIndex.toList\n        var sum\
    \ = 1\n        val factorial : List[Long] = fi.filter(_._2 % 2l.toLong != 0l.toLong).map(x\
    \ => x._1)\n        fi.filter(_._2 % 2l.toLong == 0l.toLong).map {\n         \
    \   x =>\n                sum = sum + x._1\n        }.toList\n        factorial.map(x\
    \ => sum.toLong * x.toLong).toList", "       if(n <= 0) return Nil\n       if(n\
    \ % 2 == 0) return 1 :: factorial(n).map(x => x * x)\n       else return 0 ::\
    \ 1 to n map (x => x + x)", '        // TODO: implement this function', "    \
    \    var i = 1;\n        var fac: List[Long] = List.fill(n)(1l);\n        var\
    \ sum : List[Long] = List.fill(n)(0l);\n\n        fac(i) match {\n           \
    \ case 0 => sum(i)\n            case _ => for (j <- i + 1 to n) {\n          \
    \            fac(i) * fac(j) match {\n                        case 0 => sum(i)\
    \ = sum(i) + j\n                        case _ => sum(i) = 0l;\n             \
    \         }\n                }\n        }\n        return sum;", "        var\
    \ i : Long = 1\n        var result : List[Long] = List().toList\n        // while\
    \ i less than n\n        while (i < n) {\n            // if i is even\n      \
    \      if (i % 2 == 0) {\n                result = result :+ i.toLong\n      \
    \          i =+ 1\n            }\n            // else\n            else {\n  \
    \              // i = i + 1\n                i =+ 1\n            }\n        }\n\
    \        result", "        var result : List[Long] = Nil\n        for (i<- 1 to\
    \ n){\n            if (i % 2 == 0) result += i.toLong\n            else result\
    \ += (i-1).toLong\n        }\n        result", "        val l: List[Long] = new\
    \ List(1)\n        if (n % 2 == 0) {\n            val k = 1\n            while\
    \ (k <= n) {\n                l.head * k\n                k += 1\n           \
    \ }\n        }\n        else {\n            val k = 1\n            while (k <=\
    \ n) {\n                l.head + k\n                k += 1\n            }\n  \
    \      }\n        l", "        val result = mutable.ListBuffer[Long]()\n     \
    \   (1l..n).toList.filter(_ %2 == 0).map(x => result.push(math.factorial(x).toLong))\n\
    \        result.toList", "        var listOfFactorials = List.fill(n.toInt)(1L)\n\
    \        for (i <- 1 to n.toInt){\n            if (i %2 == 0) {\n            \
    \    listOfFactorials = listOfFactorials.map(_ * i)\n            } else {\n  \
    \              listOfFactorials = listOfFactorials.sum\n            }\n      \
    \  }\n        listOfFactorials", "        val list = mutable.ListBuffer[Long]()\n\
    \        var num = 1\n        var num2 : Long = 1\n        while(num < n){\n \
    \           num += 1\n            num2 = num\n            while(num2 < n){\n \
    \               num2 += 1\n                list += num2\n            }\n     \
    \   }\n        list += num\n        list.toList"]
stop_tokens:
- "\n    }\n"
