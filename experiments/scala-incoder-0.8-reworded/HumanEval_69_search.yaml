name: HumanEval_69_search
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a non-empty list of positive integers. Return the greatest\
  \ integer that is greater than \n    // zero, and has a frequency greater than or\
  \ equal to the value of the integer itself. \n    // The frequency of an integer\
  \ is the number of times it appears in the list.\n    // If no such a value exist,\
  \ return -1.\n    // Examples:\n    // >>> search((List[Long](4l.toLong, 1l.toLong,\
  \ 2l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))\n    // (2l)\n    // >>> search((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))\n\
  \    // (3l)\n    // >>> search((List[Long](5l.toLong, 5l.toLong, 4l.toLong, 4l.toLong,\
  \ 4l.toLong)))\n    // (-1l)\n    def search(lst : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(search((List[Long](5l.toLong,\
  \ 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));\n    assert(search((List[Long](4l.toLong,\
  \ 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](3l.toLong,\
  \ 3l.toLong))) == (-1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong,\
  \ 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));\n    assert(search((List[Long](2l.toLong,\
  \ 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](2l.toLong,\
  \ 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong,\
  \ 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));\n\
  \    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) ==\
  \ (2l));\n    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong,\
  \ 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong,\
  \ 7l.toLong, 9l.toLong))) == (1l));\n    assert(search((List[Long](1l.toLong, 9l.toLong,\
  \ 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong,\
  \ 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong,\
  \ 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (5l));\n    assert(search((List[Long](1l.toLong))) == (1l));\n    assert(search((List[Long](8l.toLong,\
  \ 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong,\
  \ 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong,\
  \ 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
  \ 5l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong,\
  \ 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong,\
  \ 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong,\
  \ 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong,\
  \ 3l.toLong))) == (1l));\n    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong,\
  \ 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong,\
  \ 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong,\
  \ 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong,\
  \ 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong,\
  \ 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong,\
  \ 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong)))\
  \ == (4l));\n    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong,\
  \ 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong,\
  \ 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong,\
  \ 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong,\
  \ 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong,\
  \ 10l.toLong, 8l.toLong))) == (-1l));\n    assert(search((List[Long](10l.toLong)))\
  \ == (-1l));\n    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong,\
  \ 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong,\
  \ 7l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](5l.toLong, 4l.toLong,\
  \ 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong,\
  \ 1l.toLong, 8l.toLong))) == (1l));\n    assert(search((List[Long](7l.toLong, 9l.toLong,\
  \ 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong,\
  \ 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong,\
  \ 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));\n    assert(search((List[Long](3l.toLong,\
  \ 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));\n    }\n\n}\n"
completions: ["        var max = 0L\n        var maxV = -1L\n        for (i <- 0 until\
    \ lst.size) {\n            if (lst(i) > 0) {\n                max = max(lst(i),\
    \ max)\n                maxV = i\n            } else if (lst(i) == max) {\n  \
    \              maxV = i\n            }\n        }\n        return maxV", "   \
    \     val map = new mutable.HashMap[Long, Int]()\n        lst.foreach{ x => map.getOrElseUpdate(x,\
    \ 0) += 1 }\n        map.getOrElse(-1l, -1l)", "        val m = mutable.Map.empty[Long,\
    \ Long]\n        lst.foldLeft(-1){case (acc, n) => acc match {\n            case\
    \ -1 => (if(m.contains(n)) m(n) else -1)\n            case n => if(m.contains(n))\
    \ m(n) \n                       else m.update(n, _ + n)\n            }\n     \
    \   }", "        if (lst.length < 2) return -1\n        val freq = mutable.HashMap[Long,\
    \ Long]().withDefaultValue(0L)\n        for (i <- 0 until lst.size) {\n      \
    \      val value = lst(i)\n            if (freq.contains(value)) {\n         \
    \       freq(value)+= 1\n            }else {\n                freq(value)+= 1\n\
    \            }\n        }\n        val maxFreq = (freq.filter(_._2 >= lst(0))).max\n\
    \        val maxValue = freq.filter(x => x._2 == maxFreq).max._1\n        if (maxFreq\
    \ != 0) maxValue else -1", "        if (lst.exists(_ > 0)) \n        { \n    \
    \        if (lst.count(_ > 0) > lst.head) \n            { \n                return\
    \ lst.head\n            }\n        }\n        return -1", "        val nums =\
    \ lst.groupBy(x => x).maxBy(x => x._2.size)\n        if(nums.isEmpty)\n      \
    \      -1\n        else\n            nums.head._2", "        val counter = new\
    \ HashMap[Long, Long]()\n        for (i <- 0 until lst.length) counter.put(lst(i),\
    \ counter.getOrElse(lst(i), 0) + 1)\n        if (counter.nonEmpty) counter.maxBy(_._2)._2\n\
    \        else -1L", "        if (lst.isEmpty) -1\n        else {\n           \
    \ val freq = lst.toSet.filter(i => i > 0).size\n            val max = (lst.maxBy(i\
    \ => i.toLong).toLong, freq)\n            if (freq >= max._2) (max._1) else -1\n\
    \        }", "        if (lst.nonEmpty) lst.maxBy { x => lst.count(_ == x) } +\
    \ 1\n        else -1", "        var maxFreq = -1\n        val freq = new mutable.HashMap[Long,\
    \ Int]()\n        lst.foreach(x => {\n            if(x > 0)\n                freq\
    \ += (x, 1)\n        })\n        val maxVal = freq.maxBy(_._1)._2\n        if(freq.contains(maxVal))\
    \ {\n            maxFreq = maxVal\n        }\n        maxFreq", "        var res\
    \ = Long.MinValue\n        var freq = Long.MinValue\n        for (i <- 0 until\
    \ lst.length) {\n            val n = lst(i)\n            freq += n\n         \
    \   if (freq >= n) {\n                if (res == Long.MinValue) {\n          \
    \          res = n\n                } else {\n                    res = n\n  \
    \              }\n            }\n        }\n        if (res == Long.MinValue)\
    \ {\n            return -1\n        } else {\n            return res\n       \
    \ }", "        val freqMap = mutable.Map[Long, Int]()\n        val res = -1\n\
    \        for (n1 <- lst) {\n            freqMap.get(n1) match {\n            \
    \    case Some(i) => freqMap(n1) = i + 1\n                case None => freqMap(n1)\
    \ = 1\n            }\n        }\n        res <- freqMap.max.flatMap(_.toLong).getOrElse(-1)",
  "        var maxVal = -1\n        var maxFreq = -1\n        var maxIndex = 0\n \
    \       for (i <- 0 until lst.size) {\n            var freq = lst(i).toLong\n\
    \            for (j <- 0 until lst.size - 1) {\n                if (lst(j) ==\
    \ lst(i) && lst(i+1) < lst(j+1)) freq--\n            }\n            if (freq >\
    \ maxFreq) {\n                maxVal = lst(i)\n                maxFreq = freq\n\
    \                maxIndex = i\n            }\n        }\n        return maxVal",
  "        var maxFreq = -1\n        var maxInt = -1\n        lst.foreach { x =>\n\
    \            val count = lst.count(_ == x) + 1\n            if (count > maxFreq)\
    \ {\n                maxFreq = count\n                maxInt = x\n           \
    \ }\n        }\n        if (maxFreq >= 0) maxInt else -1", "        val m = lst.map(_.toLong)\n\
    \        val n = lst.size\n        val count = m.toStream.count(_ > 0).toInt\n\
    \        val frequency = m.toStream.map(_ -> 1).reduceByKey(_ + _)\n        (count\
    \ - frequency.toMap().map(_._2).filter(_._2 > 0).getOrElse(-1).toLong)", "   \
    \     val freqs = mutable.HashMap[Long, Int]()\n        lst.foreach{x => freqs\
    \ += x -> freqs.getOrElse(x, 0) + 1}\n\n        freqs.maxBy(_._1) match {\n  \
    \          case Some(x) => x\n            case None => -1\n        }", "     \
    \   val freq = mutable.MapLong[Long, Int]().withDefaultValue(0)\n        for (ln\
    \ <- lst) freq += (ln -> 1)\n        freq.filter(_._2 >= freq.min._2).values.lastOption.getOrElse(-1)",
  "      var maxVal = -1\n      var maxFreq = 0\n      for(x <- lst.sort) {\n    \
    \    if( x > maxFreq) {\n          maxVal = x\n          maxFreq = x\n       \
    \ }\n      }\n      if(maxVal > -1) return maxVal\n      else return -1", "  \
    \      val map = mutable.HashMapLong(0 -> 1l) //(key, value) pair\n        lst.foreach{\n\
    \        case i: Long if map.contains(i) => \n            map.getOrElse(i, -1l)\n\
    \        case i => \n            map.updated(i, map.getOrElse(i, 0l) + 1)\n  \
    \      }\n        map.maxBy(_._2)", "        var max_val = -1\n        var max_freq\
    \ = -1\n\n        for (i <- 0 until lst.length)\n            if(lst(i) > 0)\n\
    \            {\n                if(max_freq < lst(i))\n                {\n   \
    \                 max_val = lst(i)\n                    max_freq = lst(i)\n  \
    \              }\n            }\n        max_val", "        if (lst.isEmpty) -1l\n\
    \        else if (lst.head.toLong > 0l) lst.head.toLong\n        else {\n    \
    \        val numFrequency = mutable.HashMap.empty[Long, Long]\n            for\
    \ (x <- lst) {\n                if (numFrequency.contains(x)) {\n            \
    \        numFrequency.update(x, numFrequency.get(x) + 1l)\n                  \
    \  if (numFrequency.get(x) > x) x\n                } else {\n                \
    \    numFrequency.update(x, 1l)\n                }\n            }\n          \
    \  numFrequency.values.toList.max.toLong\n        }", "        val frequencyList\
    \ = mutable.HashMap[Long, Int]()\n        for (i <- 0 until lst.size) {\n    \
    \        frequencyList.update(lst.apply(i), (1 -> 1))\n        }\n        frequencyList.filter(_._2\
    \ > 0)\n            .maxBy(_._1)\n            .orElse(-1l)", "        val frequencies\
    \ = mutable.Map[Long, Int]()\n        lst.foreach{v => frequencies(v) = frequencies(v)\
    \ += 1}\n        frequencies.maxBy(_._2)", "        val freqTable = mutable.Map[Long,\
    \ Int]()\n        lst.foreach{\n            freqTable += _\n        }\n      \
    \  lst.maxBy(freqTable.contains) match {\n            case Some(max) => max\n\
    \            case None => -1\n        }", "        if (lst.nonEmpty) {\n     \
    \       // Sort the list lexicographically and assign frequency of first element\
    \ to each element in the list\n            val frequencies = lst.sorted.map {\
    \ i => i -> (lst.count(_ == i)) }\n\n            // Return the greatest value\
    \ of frequency greater than zero\n            (for ( (freq, i) <- frequencies.filter\
    \ { case (freq, _) => freq > 0 }) yield freq).max\n        } else {\n        \
    \    -1\n        }", "        def loop(cur : Long, tmp : Long) : Long = {\n  \
    \          if (tmp >= cur) {\n                tmp\n            } else {\n    \
    \            loop(cur + 1, tmp + 1)\n            }\n        }\n        loop(2l,\
    \ -1l)", "        val freqs = mutable.Map[Long, Int]().withDefaultValue(0)\n \
    \       val max = -1l\n        lst.foreach{ i =>\n            freqs(i) = freqs(i)\
    \ + 1\n            if (freqs(i) > max)\n                max = freqs(i)\n     \
    \   }\n        if (max < 0)\n            -1\n        else\n            freqs.maxBy(_._2)._1",
  "      lst.foldLeft(-1l) {\n        case (freq : Long, i : Long) if (freq > 0 &&\
    \ freq >= i) => freq\n        case (freq : Long, i : Long) if (freq < 0) => -1\n\
    \        case (freq : Long, i : Long) => freq\n      }", "        def max(xs:\
    \ List[Long], xs: Int) : Int = {\n            if (xs == 0) -1 else xs\n      \
    \  }\n        var max = 0\n        val freq = mutable.HashMap[Long, Int]()\n \
    \       lst.foreach{n =>\n            freq.getOrElseUpdate(n, 0L) += 1\n     \
    \       if (freq.get(n) >= n) {\n                max = max(freq, n)\n        \
    \    }\n        }\n        max", "        val freqs = freq(lst)\n        val maxFreq\
    \ = freqs.max\n        val maxInd = freqs.indexWhere(_ >= maxFreq)\n        if\
    \ (maxInd == -1L) return -1L\n        lst(maxInd).asInstanceOf[Long]", "     \
    \   var max : Long = -1L\n        var freq : Long = 0\n        for (i <- 0 until\
    \ lst.size) {\n            if (lst(i) > 0) {\n                if (freq > 0) //\
    \ if the frequency of any element is greater than or equal to current frequency\n\
    \                    max = if (lst(i) == freq) lst(i) else -1L\n             \
    \   freq = if (lst(i) == freq) freq + 1 else 1\n            }\n        }\n   \
    \     if (max > -1L)\n            return max\n        return -1L", "        if(lst.isEmpty)\
    \ {\n            return -1\n        }\n        var freqMap = mutable.Map.empty[Long,Int]\n\
    \        var max = -1\n        var maxCount = 1\n        var curVal = lst(0)\n\
    \        lst.foreach(x => {\n            if(freqMap.getOrElse(x,0) > 0) {\n  \
    \              freqMap.getOrElse(x,0) = freqMap.getOrElse(x,0)+1\n           \
    \ } else {\n                freqMap(x) = 1\n            }\n        })\n      \
    \  freqMap.foreach {\n            case (k,v) => if(v > maxCount) {\n         \
    \       max = k\n                maxCount = v\n            }\n        }\n    \
    \    max", "        if (lst.size <= 0) -1\n        else {\n            val map\
    \ = lst.foldLeft(mutable.Map[Long, Long]()){\n                case (acc, n) =>\
    \ acc + (n -> (acc.getOrElse(n,0)+1))\n            }\n            val max = map.values.max\n\
    \            val min = 0\n            val value = map.getOrElse(max, -1)\n   \
    \         min +: value\n        }", "        // Your code here\n        val frequencies\
    \ = lst.groupBy(x => x).mapValues(_.size)\n        val maxFrequency = frequencies.maxBy(_._2)\n\
    \        if(frequencies.contains(maxFrequency)) {\n            if(maxFrequency\
    \ > lst(lst.length - 1).toLong) -1l else maxFrequency\n        } else -1l ", " \
    \       val map = mutable.HashMap.empty[Long, Long]\n        lst.foreach(x =>\
    \ map.update(x, lst.count(_ == x)))\n        val max = map.maxBy(_._1)._1\n  \
    \      map.filter(_._2 >= max).map(_._1).headOption.getOrElse(-1L)", "       \
    \ var max = -1l\n        var maxF = -1\n        lst.foreach { n => if (n > 0)\
    \ maxF += n }\n        lst.foreach { n =>\n            if (n > 0) {\n        \
    \        if (maxF >= max) max = n\n                if (maxF >= n) maxF = n }\n\
    \            else max = -1\n        }\n        max", "        val frequencyMap\
    \ = mutable.Map[Long, Int]()\n        val freqList = mutable.ListBuffer[Long]()\n\
    \        for (item <- lst) {\n            if (frequencyMap.contains(item)) {\n\
    \                frequencyMap += item -> frequencyMap(item) + 1\n            }\
    \ else {\n                frequencyMap += item -> 1\n            }\n        }\n\
    \        for (item <- frequencyMap.keys) {\n            if (frequencyMap(item)\
    \ > freqList.length || frequencyMap(item) < frequencyMap(0)) {\n             \
    \   freqList += item\n            }\n        }\n        val index = freqList.indexOf(freqList.max)\n\
    \        if (index < 0) -1\n        else freqList(index)", "        val frequency\
    \ = mutable.HashMap.empty[Long, Int]\n        lst.map(frequency.add)\n       \
    \ val max = frequency.values.max\n        if(max==0) -1\n        else frequency(max)",
  "        val freq = mutable.HashMap[Long, Int]()\n        for(i <- lst if !freq.contains(i))\n\
    \            freq += i -> freq.getOrElse(i, 0) + 1\n        println(freq.mkString(\"\
    ,\"))\n        val max = freq.maxBy(_._2)._1\n        if(freq(max) < 0)\n    \
    \        -1\n        else\n            max", "        val freq = mutable.Map[Long,\
    \ Long]()\n        lst.foreach{ x =>\n            freq.update(x, freq.getOrElse(x,\
    \ 0) + 1)\n        }\n        var maxVal = -1l\n        for(val <- freq.keys)\
    \ \n        {\n            if(val >=0 && freq(val) >= val) \n            {\n \
    \               maxVal = val\n                break\n            }\n        }\n\
    \        maxVal", "        val freq = new mutable.HashMap[Long, Int]()\n     \
    \   for (item <- lst) {\n            freq += item -> freq(item)+1\n        }\n\
    \        val max = freq.maxBy(_._2)._1\n        val maxFreq = freq.maxBy(_._2)._2\n\
    \        if (maxFreq >= freq(max)) -1 else max", "        val freq = freqSet(lst)\n\
    \        val maxFreqSet = freqSet((freq filter (_ > 0).toList))\n        val maxFreq\
    \ = maxFreqSet map (x => x._2) filter (_ >= lst.map(_.toLong).sum)\n        if\
    \ (maxFreq.isEmpty) return -1L\n        maxFreq.head", "        var max = 0\n\
    \        var count = 0\n        for(i <- lst) {\n            count = i + 1\n \
    \           if(count > max) {\n                max = count\n            }\n  \
    \      }\n        if(max == 0) -1\n        else max", "      val map = new mutable.HashMap[Long,\
    \ Int]()\n      lst.foreach { e =>\n        map.put(e, map.getOrElse(e, 0) + 1l)\
    \ \n      }\n      map.maxBy(f => f._2)._1", "        var res = -1l\n        lst.sortWith(_.isLess(_))\n\
    \        lst.foreach(x => if (x.toDouble > 0.0) { \n            if (res < 0.0)\
    \ res = x \n            else if (x.toDouble == res) res -= x else res += x \n\
    \        })\n        res", "        var max = 0\n        var max = -1L\n     \
    \   val map = new mutable.HashMap[Long, Long]()\n        lst.foldLeft(0l) { (a,\
    \ b) => a + b}\n        lst.map(x => {\n            if(map.contains(x))\n    \
    \        {\n                max += map.get(x) - x\n                map.clear()\n\
    \                map.put(new Long(x), new Long(max))\n            }\n        \
    \    else\n                map.put(new Long(x), new Long(x))\n        }).max",
  "        var highest = 0\n        val seen = mutable.Map[Long,Int]()\n        for\
    \ (i<-lst.size) {\n            val cur = lst(i)\n            val n = seen.getOrElseUpdate(cur,0)\n\
    \            if (n > highest) {\n                highest = n\n            }\n\
    \            n += 1\n            seen(cur) = n\n        }\n        if (highest==0)\
    \ {\n            -1\n        } else {\n            highest + 1\n        }", " \
    \       val max: Long = -1\n        val frequency = mutable.HashMap[Long, Int]()\n\
    \        lst.foreach{i =>\n            frequency(i) = frequency.getOrElse(i, 0)\
    \ + 1\n            if (frequency.getOrElse(i, 0) > frequency.getOrElse(max, 0))\n\
    \                max = i\n        }\n        max", "      lst.foldLeft((-1l))\
    \ {\n          case ((biggerFrequency, bigger), n) =>\n            val currentFrequency\
    \ = if (biggerFrequency == -1l) -1l else biggerFrequency + 1l\n            if\
    \ (currentFrequency >= n) n else bigger\n      }", "        val frequency = mutable.Map[Long,\
    \ Long]()\n        for (number <- lst) {\n            val currentFrequency = frequency.get(number).getOrElse(0)\
    \ +1\n            frequency.put(number, currentFrequency)\n        }\n       \
    \ val maxFrequency = frequency.values.max\n        frequency.values.find(_ >=\
    \ maxFrequency).last", "        var max = 0l\n        var max = -1l\n        for(i\
    \ <- lst){\n            val tmp = if (i>max) i else max\n            val freq\
    \ = lst.count(_ == tmp)\n            if (freq >= i) max = tmp\n        }\n   \
    \     max", "      val a = lst.map(x => (x, 1))\n      val b = a.groupBy(_._1)\n\
    \      val c = b.mapValues(_.size)\n      val d = b.map(x => (x._1, x._2.min(_._2)))\n\
    \      val maxVal = d.maxBy(_._2)._1\n      val freq = d.maxBy(_._2)\n      if(maxVal\
    \ < 0) {\n        -1\n      } else if(freq._2 > maxVal) {\n        -1\n      }\
    \ else {\n        maxVal\n      }", "        val frequencyMap = mutable.Map[Long,\
    \ Int]()\n        val maxFreq = -1\n\n        for (i <- lst ) {\n            frequencyMap.getOrElse(i,\
    \ 0) + 1\n            val freq = frequencyMap(i)\n            if (freq >= maxFreq)\
    \ {\n                maxFreq = freq\n            }\n        }\n\n        if (maxFreq\
    \ >= 0) {\n            frequencyMap\n        } else {\n            -1\n      \
    \  }", "        val frequency = mutable.HashMap.empty[Long, Int]\n        for\
    \ (a <- lst.size) {\n            val value = lst.take(a).sum\n            frequency.update((value),\
    \ frequency.getOrElse(value, 0)+1)\n        }\n        val greatest = frequency.max.filter(_._2\
    \ >= lst.sum)\n        greatest.map(_._1).getOrElse(-1)", "        val freq =\
    \ mutable.Map[Long, Int]()\n        lst.foreach(x => {\n            freq += x\
    \ -> freq.getOrElse(x, 0) + 1\n        })\n        val res = if (freq.contains(0L))\
    \ -1L else 0L\n        res +: freq.filter(_._2 >= res.toLong).keys.headOption.getOrElse(-1)",
  "        if (lst.isEmpty)\n            return -1\n        val maxVal = lst.maxBy(math.abs(_))\n\
    \        val freq = lst.count(_ == maxVal)\n        if (freq >= maxVal.toLong)\n\
    \            return maxVal\n        else\n            search(lst.filterNot(_ ==\
    \ maxVal))", "        val freq = mutable.HashMap.empty[Long, Int]\n        val\
    \ max = mutable.Long.MinValue\n        lst.foreach(x => if (freq.contains(x))\
    \ freq(x) += 1 else {freq(x) += 1; max = Math.max(x, max)})\n        max = max\
    \ - 1\n        if (freq.contains(max)) max else -1", "        var max = 0\n  \
    \      var freq = lst(0)\n        var i = 0\n        while(i < lst.length) {\n\
    \            if (freq >= lst(i)) {\n                freq = lst(i)\n          \
    \      max = i\n            }\n            i += 1\n        }\n        max", " \
    \       val lookup = new mutable.HashMap[Long, Int]\n        lst.foreach((x) =>\
    \ lookup.update(x, lookup.getOrElse(x, 0) + 1))\n        lookup.maxBy(_._2)._2",
  "        // sort list by value\n        lst.sortWith(_ < _)\n        // find first\
    \ value greater than 0\n        var max = 1l // default value\n        var maxV\
    \ = -1l // default value\n        val m = lst.size // count of element in list\n\
    \        for (i <- 0 until m) {\n            val v = lst(i)\n            if (v\
    \ > 0) {\n                if (v > max) { max = v }\n                if (v >= maxV)\
    \ { maxV = v }\n            }\n        }\n        if (maxV >= 0) -1 // if value\
    \ is positive, then return -1 \n        else max // if value is negative return\
    \ max value", "        def f(cur : Long, current : mutable.HashMap[Long, Int])\
    \ : Option[Long] = {\n            val newFrequency = current.get(cur) + 1;\n \
    \           val newMax = if (newFrequency > cur) cur else f(newMax, current.updated(cur,\
    \ newFrequency))\n            Some(newMax)\n        }\n        val (maxFrequency,\
    \ maxValue) = l.foldRight((0, 0))((a, b) => if (a._2 > b._1) a else b)\n     \
    \   val current: mutable.HashMap[Long, Int] = mutable.HashMap.empty;\n       \
    \ current(maxValue) = maxFrequency;\n        f.apply(maxValue, current)", "  \
    \      val freq = mutable.Map[Long, Long]()\n        for (i <- lst.indices) {\n\
    \            if (!freq.contains(i)) {\n                freq += i -> 1\n      \
    \      } else {\n                freq(i) += 1\n            }\n        }\n    \
    \    val maxfreq = freq.maxBy(_._1)\n        if (maxfreq._2 >= 0) {\n        \
    \    maxfreq._1\n        } else {\n            -1\n        }", "        var max_count\
    \ : Long = 0\n        var max_element : Long = -1\n        for(num <- lst) {\n\
    \            if(num >= 0) {\n                val count : Long = lst.count(num.toLong)\n\
    \                \n                if(count > max_count) {\n                 \
    \   max_count = count\n                    max_element = num\n               \
    \ }\n            }\n        }\n        \n        if(max_count > 0) max_element\
    \ else -1", "       val freqs = lst.groupBy(identity).map(x => (x._1,x._2.size))\
    \ // Frequency is length of List\n       val max = freqs.filter(_._2 >=0)\n  \
    \     val maxIndex = freqs.map(_._1).max\n       if (max.isEmpty) -1l\n      \
    \ else if (max.exists(_._2 >=0))\n           max.map(x => x._1).find(x=>freqs(x)\
    \ >=maxIndex).getOrElse(-1)\n       else -1l", "        val n = lst.size\n   \
    \     val m = lst.map(i => lst.count(_ == i)).max\n        (for {\n          \
    \  i <- 0 until n\n            c <- 0 to lst.count(_ == i)\n        } yield {\n\
    \            if (m * c == i) m\n            else -1\n        }).headOption.getOrElse(-1)",
  "        lst.foldLeft(-1){ case (f,x) =>\n           if((f > 0 && f <= x) || (f\
    \ == x && f != 0))\n               f\n           else\n               (f*x + 1)\n\
    \        }", "        if(lst.length == 0) -1\n        else if(lst.head.isDefined){\n\
    \            val num = lst.head\n            val freq = lst.count(_.toString ==\
    \ num.toString)\n            if(freq > lst.count(_.toString == num.toString.toString))\
    \ -1 else num\n        }\n        else{\n            -1\n        }", "       \
    \ val freq = mutable.HashMap[Long, Int]()\n        for (i<- lst.indices) {\n \
    \           freq += lst.apply(i) -> 1\n        }\n        val maxFreq = freq.filter(_._2\
    \ > 0)\n        maxFreq.maxBy(_._2)._1", "        var max = -1\n        var maxCount\
    \ = -1\n\n        for(n <- lst){\n            if(n >0 && n <= lst.size){\n   \
    \             if(lst.count(_ == n) > 0){\n                    max = Math.max(max,\
    \ n)\n                    maxCount = lst.count(_ == n)\n                }\n  \
    \          }\n        }\n        \n        if(maxCount == -1)\n            return\
    \ -1\n        \n        if(maxCount >= lst.count(_ == max))\n            return\
    \ max\n        else\n            return -1", "        // Create a freq map and\
    \ store frequency.\n        var freq = new mutable.HashMap[Long, Int]()\n    \
    \    lst.foreach(freq += _)\n        // Search by increasing frequency.\n    \
    \    var ans = -1\n        while(true){\n            if(!freq.contains(\"0\"))\n\
    \                break\n            val cur = freq.get(\"0\")\n            freq.foreach(_._2\
    \ -= cur)\n            if(!freq.contains(\"0\"))\n                ans = cur\n\
    \        }\n        ans", "        var max = 0\n        var max_freq = 0\n   \
    \     var i = 0\n        var j = 0\n        for(a <- lst){\n            i = i\n\
    \            for(j <- i until lst.length){\n                if (lst[j] >= a){\n\
    \                    break\n                }\n                i = j\n       \
    \     }\n            for(k <- j to lst.length){\n                if (lst[k] >\
    \ a){\n                    max = a\n                    max_freq = 1\n       \
    \         }\n                else {\n                    if (lst[k] >= a){\n \
    \                       max = a\n                        max_freq = 1 + lst[k]\
    \ - a\n                    }\n                    else {\n                   \
    \     max_freq = lst[k] - a\n                    }\n                }\n      \
    \      }\n        }\n        if (max != -1) {\n            return max\n      \
    \  }\n        return -1", "        var freq = lst.foldLeft(0l)( (x,y) => x+y )\n\
    \        for ( i <- lst if i > 0 ) freq = (freq * (freq / i.toLong)).toLong\n\
    \        if (freq > 0) freq\n        else -1", "        def dfs(num : Long) :\
    \ Unit = \n            if (num == 0) \n                println(num) \n       \
    \     else {\n                if (lst(num) > 0)\n                    if (dfs(lst(num)\
    \ - 1) > 0) \n                        dfs(lst(num) - 1)\n                    else\n\
    \                        dfs(lst(num))\n                else if (lst(num) > 0)\n\
    \                    dfs(lst(num))\n            }\n        dfs(lst.length)\n \
    \       -1", "        val m = scala.collection.mutable.Map.empty[Long, Int]\n\
    \        lst.foreach(x => if (m.get(x) != null) m(x.toLong) += 1) \n        val\
    \ max = m.filter { case (k,v) => (v >= m.get(x).toLong) && (v <= 1) }\n      \
    \  max match {\n            case Some((k,v)) => k\n            case None => -1\n\
    \        }", "        val frequency = mutable.Map[Long, Int]()\n        lst.foreach{\
    \ x =>\n            frequency += x -> frequency.getOrElse(x, 0) + 1\n        }\n\
    \        val maxValues = frequency.toSeq.sortBy(_._1).reverse\n        if (maxValues.isEmpty)\
    \ -1\n        else maxValues.head._1", "        var frequency = 1L\n        var\
    \ max = 0L\n        lst.foreach{x => if (x == 0) frequency = 1 else frequency\
    \ *= x}\n        if (max == 0)\n            return -1\n        lst.foreach{x =>\
    \ if (x >= frequency) max = math.max(max, x)}\n        return max", "        val\
    \ counter = mutable.Map[Long,Int]()\n        for(i <- 0 until lst.size) {\n  \
    \          if(counter.contains(lst(i))) {\n                counter(lst(i)) = counter(lst(i))\
    \ + 1\n            } else {\n                counter.put(lst(i), 1)\n        \
    \    }\n        }\n        val freq : Long = counter.maxBy { case (k,v) => v }._1\n\
    \        val result = if (freq > 0) freq else \"-1\"\n        return result",
  "        var max = 0l\n        var num = 0l\n        var freq = 0l\n        for\
    \ (i <- 0 until lst.length) {\n            freq += lst(i)\n            if (freq\
    \ >= lst(i)) {\n                freq = freq - lst(i)\n                num += 1\n\
    \                if (num > max) {\n                    max = num\n           \
    \     }\n            }\n        }\n        if (num > max) {\n            max =\
    \ -1l\n        }\n        return max", "        val maxVal = lst.foldLeft(Long.MaxValue)((acc,\
    \ cur) => acc.max(cur))\n        val map = lst.toStream\n            .groupBy(x\
    \ => x)\n            .filter(_._2 >= maxVal)\n            .map(_._1)\n       \
    \     .toList\n            .lastOption\n            .head", "        val freq\
    \ : Map[Long, Int] = lst.foldLeft(Map.empty[Long, Int])( (freqMap, elem) =>\n\
    \            freqMap + (elem -> (freqMap.getOrElse(elem, 0) + 1)))\n        val\
    \ maxFreq : Map[Long, Int] = freq.maxBy(_._2)\n        if(maxFreq._2 >= freq._2)\
    \ maxFreq._1 else -1", "        if(lst.isEmpty)\n            return -1\n     \
    \   // use binary search to find the first greater value than 0\n        val startIndex\
    \ = lst.indexOf(0)\n        if(startIndex < 0)\n            return -1\n      \
    \  val index = lst.lastIndexOf(0)\n        if(index == -1)\n            return\
    \ -1\n\n        // find frequency of 0 and add it to sum\n        var sum = lst.filter(_\
    \ > 0).filter(_ == 0).length\n        val i = lst.indexOf(0)\n        val freq\
    \ = lst.filter(_ > 0).length\n        sum = sum + freq\n        sum", "      \
    \  val n = lst.size\n        val m = lst.map(x => x).map(x => 1).reduce(_ + _)\n\
    \        for (x <- lst.indices) {\n            if (x<n-1) lst(x+1) <= lst(x) &&\
    \ lst(x+1) > lst(x) && lst(x) <= lst(x) \n                    && (lst(x)==1||lst.filter(_>lst(x)).size\
    \ < x) \n                    else lst(x) == -1\n        }", "      val freq =\
    \ mutable.Map[Long, Int]()\n      for (x <- lst) {\n        freq(x) += 1\n   \
    \   }\n      val max = (0 until freq.size).filter(_ >= 0).max\n      val retval\
    \ = if (freq.contains(max)) {\n        max \n      } else -1\n      retval", " \
    \       val maxNum = lst.maxBy(_.toInt)\n        if (maxNum >0 && lst(maxNum.toInt)\
    \ > 0) {\n           maxNum \n        } else {\n            -1\n        }", " \
    \       val frequencyMap = lst\n            .map(x => (x, 1L))\n            .groupBy(_._1)\n\
    \            .toSeq\n            .map({\n                case (freq, count) =>\
    \ count if freq > 0\n            })\n            .toMap\n\n        val minFrequencyWithValue\
    \ = frequencyMap.keys.min\n        val maxFrequency = frequencyMap.keys.max\n\n\
    \        val value = frequencyMap(minFrequencyWithValue)\n        if (minFrequencyWithValue\
    \ == maxFrequency) -1\n        else minFrequencyWithValue -> value", "       \
    \ val a = mutable.ListBuffer.empty[Long]\n        for (i <- lst) {\n         \
    \   if (a.contains(i)) {\n                continue\n            }\n          \
    \  a.append(i)\n            if (a.max > i) {\n                return i\n     \
    \       }\n        }\n        return -1", "        val max = (lst.sortBy(identity).reverse.find(_\
    \ > 0l) match {\n            case Some(n) => n\n            case None => -1l\n\
    \        }).toLong\n        val frequency = lst.count(_ == max).toLong\n     \
    \   if (-1l < frequency && frequency >= 0)\n            max\n        else\n  \
    \          -1l", "        if (lst.length == 0)\n            return -1\n      \
    \  var max = -1\n        var sum = 0\n        lst.foreach{ x =>\n            if\
    \ (sum < x && x > 0)\n                sum = x\n            if (sum > max)\n  \
    \              max = sum\n        }\n        return max", "        val (freq,\
    \ pos) = lst.foldLeft((0l, 0l))((f, v) => if (v >= 0) (f+1, v) else (0, f+1))\n\
    \        freq", "        lst.size match {\n            case 0 | 1 => lst(0)\n\
    \            case x => val max = lst.max\n                    val frequency =\
    \ lst.count(_ == max)\n                    if (frequency >= lst.size) {\n    \
    \                    -1l\n                    } else {\n                     \
    \   max\n                    }\n        }", '        lst.groupBy(x => x).mapValues(x
    => x.size).maxBy(x => x).map(_._1).getOrElse(-1)', "        val result = mutable.Set[Long]()\n\
    \        lst.foreach {\n            i =>\n                if (result.contains(i))\
    \ {\n                    val oldValue = result(i)\n                    val newValue\
    \ = i + 1\n                    if (oldValue >= newValue) {\n                 \
    \       return -1\n                    }\n                    result.update(i,\
    \ newValue)\n                }\n        }\n        if (result.size == 0)\n   \
    \         return -1\n        result.toList.max", "        val freqs = mutable.Map[Long,\
    \ Int]()\n        val result = mutable.Map[Long, Int]()\n        for (elem <-\
    \ lst) {\n            val exists = freqs.get(elem)\n            if (exists !=\
    \ null)\n                freqs += (elem -> (exists + 1))\n            else\n \
    \               result += (elem -> 1)\n        }\n        val max = freqs.maxBy(_._2)\n\
    \        if (max._2 >= freqs.size)\n            result.get(max._1).getOrElse(-1)\n\
    \        else\n            -1", "        lst.sortWith((a, b) => a < b) // We sort\
    \ our list from smallest to largest\n        for (i <- lst.indices if (lst(i)\
    \ > 0)) yield {\n            val val = lst(i)\n            val count = lst.count(i\
    \ => i == val) + 1\n            (count, val)\n        }", "        var freq :\
    \ Int = 0\n        var cur = 0\n        var max = -1L\n\n        lst.foreach {\
    \ x =>\n            freq = (freq + 1).toInt\n            if (freq > cur) {\n \
    \               cur = freq\n                max = x\n            }\n        }\n\
    \n        max = if (max == 0l) {\n            -1l\n        } else {\n        \
    \    max\n        }\n\n        max = -1l\n        lst.foreach { x =>\n       \
    \     freq = (freq + 1).toInt\n            if (freq > cur && freq >= max) {\n\
    \                max = freq\n            }\n        }\n\n        max = if (max\
    \ == 0l) {\n            -1l\n        } else {\n            max\n        }\n  \
    \      max", "        var max: Long = -1\n        var cur: Long = 0\n        val\
    \ freq = mutable.HashMap.empty[Long, Int]\n        for (i <- 0 until lst.size)\
    \ {\n            val v = lst(i)\n            freq(v) += 1\n            val k =\
    \ 0\n            val j = i + v - 1\n            while (j <= lst.size && lst(j)\
    \ < v) {\n                k += 1\n                j += 1\n            }\n    \
    \        if (k > cur) {\n                max = v\n                cur = k\n  \
    \          }\n        }\n        if (max < 0)\n            -1\n        else\n\
    \            max", "        val freq = mutable.HashMap( 0 -> 0)\n        lst.foreach\
    \ {\n        case i => {\n            freq(i) = freq(i) + 1\n        }\n     \
    \   }\n        if(!freq.contains(\"0\") && freq.size > 0) freq(\"0\") + 1 -1\n\
    \        else -1", "        def searchHelper(lst : List[Long], found : Long, count\
    \ : Long) : Long = {\n            if (lst.isEmpty) return -1\n            if (lst.isEmpty\
    \ && found == 0) return -1\n            if (lst.isEmpty && found != 0) return\
    \ -1\n            if (lst(0) == found) {\n                return searchHelper(lst._2,\
    \ found, count + 1)\n            }\n            if (found > 0) return searchHelper(lst.tail,\
    \ found, count)\n            return -1\n        }\n        searchHelper(lst, 0,\
    \ 0)", "        var maxFrequency = -1\n        var maxFrequencyIndex = 0\n   \
    \     var maxFrequencyValue = -1\n        lst.foreach(elem => {\n            var\
    \ frequency = 0\n            for(elem <- lst if elem > elem) {\n             \
    \   frequency += 1\n            }\n            if(maxFrequency < frequency &&\
    \ frequency >= elem) {\n                maxFrequency = frequency\n           \
    \     maxFrequencyIndex = lst.indexWhere(elem => elem > elem)\n              \
    \  maxFrequencyValue = elem\n            }\n        })\n        return maxFrequencyValue",
  "        val frequency = mutable.HashMap[Long, Int]()\n        var max = 0L\n  \
    \      lst.foreach{element => frequency.merge(element.toLong,1L,{\n          \
    \  case (count, newCount) if newCount > max => (max, newCount)\n            case\
    \ (count, newCount) => (count, newCount)\n        })}\n        frequency.get(0L).map(element\
    \ => element.max).getOrElse(-1)", "        val max = (lst.length,0l).max\n   \
    \     (lst.length,0l).foreach { _ <- 0 until (lst.length) } { _ <- 0 until (lst.length)\
    \ }\n        val rslt = mutable.LongArray(lst.length)\n        for (i <- 0 until\
    \ lst.length) {\n            var freq = (lst(i),0l).max\n            var tmp =\
    \ 1l\n            while (tmp <= freq) {\n                freq = (freq * lst(i))\
    \ + (tmp - freq)\n                tmp += 1l\n            }\n            rslt(i)\
    \ = freq\n        }\n        rslt.max", "        var max = -1\n        var currentMax\
    \ = -1\n        lst.foreach { x => \n            currentMax = if (x > max) x else\
    \ currentMax\n        }\n        if (currentMax < 0) currentMax = max\n      \
    \  if (currentMax > max) max = currentMax\n        return max", "        val result\
    \ = lst.foldLeft(-1){case (x, y) => {\n            if (y > 0){\n             \
    \   if (x >= y) x\n                else y\n            } else {\n            \
    \    if (x == y) x\n                else -1\n            }\n        }}\n     \
    \   if (result < 0) -1\n        else result", "        var maxFreq = -1\n    \
    \    val nums = new mutable.HashMap[Long, Int]()\n        lst.foreach(x => nums\
    \ += (x->nums.getOrElse(x, 0)))\n        for (x <- nums.keys) {\n          if\
    \ (nums.get(x) <= nums.getOrElse(x, 0)) {\n            val temp = nums.getOrElse(x,\
    \ 0) - x\n            if (maxFreq < temp) {\n              maxFreq = temp\n  \
    \          }\n            nums.remove(x)\n          }\n        }\n        nums.keys.headOption.map(x\
    \ => nums.getOrElse(x, 0) - x).orElse(-1l)", "        val freq = mutable.Map.empty[Long,\
    \ Int]\n        lst.foreach { l =>\n            val count = freq.getOrElseUpdate(l,\
    \ 0) + 1\n            if (count > freq(l))\n                freq.update(l, count)\n\
    \        }\n        val freqInd = freq.toList.maxBy(x => x._2)\n        if (freqInd._2\
    \ == 0) -1\n        else freqInd._1", "        def getMax(n: Long, cnt: Map[Long,\
    \ Long]) : Long = {\n            if (cnt.exists(_._2 < n))\n                cnt.updated(n,\
    \ cnt.get(n) + 1)\n            else\n                cnt.updated(n, 1)\n     \
    \       cnt.get(n) - 1\n        }\n\n        lst.foldLeft((-1l, Map[Long, Long]())){case\
    \ ((maxCount, freq), x) =>\n            if (x >= 0 && freq >= 0)\n           \
    \     (getMax(x, freq), (max, freq))\n            else if (x >= 0) {\n       \
    \         (getMax(x, freq), (max, freq))\n            }\n            else {\n\
    \                (-1, Map(x, freq))\n            }\n        }._1", "        var\
    \ max = 0\n        var count = 0\n        for (i <- lst) {\n            if (i\
    \ > 0 && i == lst(i)) {\n                count += 1\n            } else {\n  \
    \              if (count >= max) {\n                    max = count\n        \
    \        }\n                count = 0\n            }\n        }\n        if (max\
    \ > 0) {\n            max\n        } else {\n            -1\n        }", "   \
    \     if(lst.empty) -1L\n        else {\n            val m = lst.head\n      \
    \      val n = lst.last\n            val count = lst.count(x => x > 0)\n     \
    \       if(n > m && count > 0) m\n            else search(lst.tail)\n        }",
  "        if (lst.isEmpty) -1\n        else {\n            var max: Long = -1\n \
    \           var maxCount: Long = 0\n            var current: Long = lst.head\n\
    \n            for(i <- lst.tail) {\n                if (current != i) {\n    \
    \                if (maxCount < i)\n                        maxCount = i\n   \
    \                 if (max < i) { max = i; current = i }\n                }\n \
    \           }\n            max\n        }", "        val freq = mutable.Map.empty[Long,Int]\n\
    \        var maxKey = 0L\n        lst.foreach{ x =>\n            val v = x % freq.size\n\
    \            if (freq.contains(v)) freq(v) = (freq(v) + 1)\n            else freq\
    \ += x -> (1+1)\n            if (freq.size > maxKey) maxKey = freq.max\n     \
    \   }\n        if (maxKey == 0L) -1\n        else freq.max", "        // This\
    \ solution is based on a DFS approach in which we first calculate the frequency\
    \ of each number and \n        // the max frequency number is stored as the result.\
    \ We need to traverse the list from left to right and \n        // at each step,\
    \ we need to calculate the current maximum in each level of DFS and update the\
    \ \n        // max in each level. \n        val freqMap = mutable.HashMap.empty[Long,\
    \ Long]\n        val maxFreq = mutable.Long.MaxValue\n        lst.foreach{ x =>\
    \ \n            if (freqMap.contains(x)) {\n                freqMap(x) = freqMap(x)\
    \ + 1\n            } else {\n                freqMap(x) = 1\n            }\n \
    \           maxFreq = max(x * maxFreq, freqMap(x))\n        }\n        val maxFreqKey\
    \ = freqMap.keys.max\n        // If we find a number whose frequency is more than\
    \ the maxFreq stored in the map, we can return the max frequency.\n        if\
    \ (maxFreqKey < maxFreq && freqMap(maxFreqKey) > maxFreq) {\n            maxFreq\n\
    \        } else {\n            -1\n        }", "        val frequency = mutable.Map[Long,\
    \ Int]()\n        for(e <- lst) {\n            frequency.putIfAbsent(e, 0)\n \
    \           frequency(e) += 1\n        }\n        lst.foldLeft(Long.MinValue)(\n\
    \            (freq => freq - frequency(freq) < 0 ? freq : Long.MinValue)\n   \
    \     )", "        val frequency = mutable.Map[Long, Int]()\n        lst.foreach{i\
    \ =>\n            frequency += (i -> frequency.getOrElseUpdate(i, 0) + 1l)\n \
    \       }\n        lst.flatMap(i => frequency.getOrElse(i, 0) > i.toLong).max",
  "        val freq = new mutable.HashMap[Long, Int]()\n        var max = 0L\n   \
    \     for (x <- lst) {\n            if (freq.contains(x) && freq.get(x) > 0) {\n\
    \                freq.update(x, freq.get(x) - 1)\n                if (freq.contains(x)\
    \ && freq.get(x) >= x) {\n                    freq.update(x, freq.get(x) - 1)\n\
    \                }\n            } else {\n                freq.update(x, 1L)\n\
    \            }\n            if (freq.contains(x) && freq.get(x) > max) {\n   \
    \             max = freq.get(x)\n            }\n        }\n        if (max ==\
    \ -1L) return -1L\n        val res = max\n        freq.retain(x => x >= res)\n\
    \        if (res.toLong == max) -1L\n        else res", "        val freq = mutable.HashMap[Long,\
    \ Long]()\n        lst.foreach(x => freq += x -> freq(x))\n        lst.foreach\
    \ {\n            x =>\n            val v = freq(x)\n            val i = x - 1\n\
    \            if (freq(i) >= v) \n                val max = i\n            else\
    \ \n                max = v\n        }\n        max", "        def findFrequency(lst\
    \ : List[Long]) = {\n            if (lst.size == 0) 0\n            else lst.foldLeft(0){\
    \ (n, c) =>\n                if (c > n) c else n\n            }\n        }\n \
    \       def findGreatest(lst : List[Long]) = {\n            if (lst.size <= 0)\
    \ -1\n            else lst.foldLeft(0){ (n, c) =>\n                if (c > n)\
    \ c else n\n            }\n        }\n        val frequency = findFrequency(lst)\n\
    \        val greatest = findGreatest(lst)\n        if (frequency <= greatest)\
    \ -1\n        else greatest", "        if (lst.isEmpty)\n            return -1L\n\
    \        val min: Long = lst(0)\n        val max: Long = lst(0)\n        val freq\
    \ = mutable.Map.empty[Long, Long]\n        for(x <- lst)\n            freq(x)\
    \ += 1\n        for (x <- freq.keys)\n            if(freq(x) >=min)\n        \
    \        max = x\n            else\n                break\n        return (max)",
  "        val sortedList = lst.sortWith(_ > _)\n        val result = sortedList.lastOption.getOrElse(-1.toLong)\n\
    \        // val result = lst.foldLeft(-10000) {\n        //     (max: Long, item:\
    \ Long) =>\n        //         if (item > max) {\n        //             max\n\
    \        //         } else if (item == max) {\n        //             item + 1\n\
    \        //         } else {\n        //             -1\n        //         }\n\
    \        // }\n        result", "        var maxNum = math.max(lst.head)\n   \
    \     var freq = 1\n        for (i <- lst.tail) {\n            if(i >= maxNum\
    \ && freq >= i) {\n                maxNum = i\n                freq += 1\n   \
    \         }\n        }\n        if(maxNum < 0) return -1\n        maxNum", " \
    \       var max: Long = 0\n        var maxIndex = 0\n        for(i <- 0 until\
    \ lst.size) {\n            val count = lst.count(_ == i)\n            if(count\
    \ > max) {\n                max = count\n                maxIndex = i\n      \
    \      }\n        }\n        max", "        var curr = lst(0)\n        val ret\
    \ = -1l\n        for (x <- lst.slice(1).toList if x >= curr ) {\n          curr\
    \ += x\n          ret =\n              if (curr > 0) curr\n              else\
    \ if (curr == 0 && lst.indexOf(curr) < 0) -1l\n              else curr\n     \
    \   }\n        ret", "        var max = -1L\n        for (i <- lst.indices) {\n\
    \            if (max < 0L) {\n                max = lst(i)\n            } else\
    \ if (max < lst(i)) {\n                max = lst(i)\n            }\n        }\n\
    \        return max", "        val freq = lst.reduceLeft(_ ++ _)\n        freq.toList.zipWithIndex.filter(_._2\
    \ >= freq).headOption.map(_._1).getOrElse(-1)", "        var result = 0L\n   \
    \     var freq = 0\n        var max = -1\n        lst.foreach{ elem =>\n     \
    \       freq += elem\n            result += (max == -1) ? elem : if (elem > max)\
    \ max else elem - 1\n        }\n        freq <= result || (max = -1)", "     \
    \   val freqMap = mutable.Map.empty[Long, Int]\n        for(n <- lst.zipWithIndex)\
    \ {\n            freqMap += (n._1 + 1l) -> (n._2)\n        }\n        lst.maxBy(x\
    \ => freqMap.getOrElse(x + 1l, -1l))", "        if (lst.isEmpty) {\n         \
    \   -1\n        } else {\n            val freqMap = mutable.Map.empty[Long, Int]\n\
    \            val freqList = mutable.List.empty[Long]\n            for(i <- lst)\
    \ {\n                if (freqMap.contains(i)) {\n                    freqMap(i\
    \ -> freqMap(i ) + 1l) = (freqMap(i ) + 1l) * i\n                } else {\n  \
    \                  freqMap(i -> 1) = 1\n                    freqList += i\n  \
    \              }\n            }\n\n            val maxFreq = freqMap.values.max\n\
    \            if (maxFreq >= freqMap.size) {\n                -1\n            }\
    \ else {\n                freqList.max\n            }\n        }", "      val\
    \ freqMap = mutable.Map.empty[Long, Int]\n      for (x <- lst) {\n        freqMap\
    \ + (x -> (freqMap.getOrElse(x, 0) + 1l))\n      }\n      val maxFreq = freqMap.reduceLeft((x,\
    \ y) => if (x > y) x else y)\n      lst.find(_.toLong == maxFreq.toLong).map(_.toLong).getOrElse(-1)",
  "        val frequency = new scala.collection.mutable.HashMap[Long,Int]()\n    \
    \    lst.foldLeft(0) { (frequency, elem) =>\n            if(!frequency.contains(elem))\
    \ frequency.putIfAbsent(elem, 0) += 1\n            frequency += elem -> frequency(elem)\
    \ + 1\n            frequency(elem)\n        }", "        val counts = mutable.Map[Long,\
    \ Int]()\n        for(i <- 0 until lst.size) {\n            val freq = counts.get(lst(i)).getOrElse(0)\n\
    \            counts += ((lst(i), freq + 1))\n        }\n\n        val (maxVal,\
    \ maxFreq) = counts.maxBy(_._2)\n        if(maxFreq >= maxVal) maxVal else -1",
  "        def getFreq(lst: mutable.Set[Long], x: Long) : List[Long] = {\n       \
    \     var newList = List(x)\n            while(newList.length > 0 && lst.contains(newList(newList.length\
    \ - 1))){\n                newList = newList.dropRight(1)\n            }\n   \
    \         if(newList.length == 0){\n                return List[Long]()\n    \
    \        } else {\n                return newList.groupBy(x => x).toList.sortBy(x\
    \ => x._2).reverse.head._1\n            }\n        }\n        val freqMap = mutable.Map[Long,Long]()\n\
    \        lst.foreach{x => freqMap += (x -> 1) }\n        val res = getFreq(freqMap,\
    \ 0L)\n        res.headOption.getOrElse(-1L)", "        val set = new mutable.HashSet[Long]\n\
    \        val result = -1\n        lst.foreach(x => set.add(x.toLong))\n      \
    \  if(set.size == 1) {\n            result += 1\n            return result\n \
    \       }\n        val max = set.max\n        if(max > 0) {\n            var i\
    \ = 0\n            while(i < set.size && max <= (set.size - i)) {\n          \
    \      i += 1\n                max += 1\n            }\n        }\n        result",
  "        val count = lst.size\n        val freq = lst.groupBy(x => x).map(x => (x._2,\
    \ x._1.size)).toSeq\n        val vals = freq.map(x => x._2).filter(_ > 0)\n  \
    \      if (vals.isEmpty)\n            -1l\n        else if (vals.size == 1)\n\
    \            vals.head\n        else\n            val max = (0 until count).find(x\
    \ => x._2 > vals.head._2).getOrElse(-1)\n            if (max > 0)\n          \
    \      max\n            else\n                -1l", "        if (lst.isEmpty)\
    \ -1\n        else (lst.foldLeft(0l){(max,item) => if (item > max) item else max}) ",
  "        var maxFreq = -1L\n        var maxVal = -1L\n        lst.foreach(x => {\n\
    \            val currFreq = lst.count(_ == x)\n            if (maxFreq < currFreq\
    \ && currFreq > 0) {\n                maxFreq = currFreq\n                maxVal\
    \ = x\n            }\n        })\n        maxVal", "        var maxV = Long.MaxValue\
    \ - 1\n        var maxI = Long.MinValue\n        for(i <- 0 until lst.size) {\n\
    \            if (lst(i) > maxV) {\n                maxV = lst(i)\n           \
    \     maxI = i\n            }\n        }\n        if (maxV == maxI) {\n      \
    \      if (maxV == 0)\n                return -1\n            else\n         \
    \       return maxV\n        } else {\n            return -1\n        }", "  \
    \    val m = lst.head\n      val l = lst.tail\n      if (l.isEmpty) -1\n     \
    \ else l match {\n        case head::tail => {\n          val n = head\n     \
    \     val freq = freqList(m,head,freq(m, freq(m, head)))\n          if (freq <\
    \ n / 2) -1\n          else freq\n        }\n        case Nil => -1\n      }",
  "        val freq = lst.groupBy(lv => lv).map(x => (x._2, x._1.size)).toMap\n  \
    \      val maxNum = freq.maxBy(_._2)._1 \n        val res = freq.filter(f => f._2\
    \ >= maxNum).keySet\n        res.head match {\n            case -1 => -1\n   \
    \         case n => n\n        }", "        val freqMap = mutable.HashMap[Long,\
    \ Int]()\n        lst.foreach(x => {\n            freqMap += (x -> freqMap.getOrElse(x,\
    \ 0l) + 1)\n        })\n        val max = 0l\n        for(x <- freqMap.keys){\n\
    \            if(x > max){\n                max = x\n            }\n        }\n\
    \        if(max == -1l)\n            -1\n        else\n            max", "   \
    \     val hashMap: mutable.Map[Long, Long] = mutable.HashMap()\n        lst.foreach(x\
    \ => {\n            hashMap += (x -> hashMap.getOrElse(x, 0l) + 1)\n        })\n\
    \        hashMap.values.max", "        if (lst.size < 1) return -1\n        var\
    \ freq = mutable.Map[Long, Long]()\n        for (x <- lst) {\n            freq\
    \ += x -> freq.getOrElse(x, 0) + 1\n        }\n        val maxKey = freq.maxBy(_._2)._1\n\
    \        if(maxKey == 0) -1\n        else freq(maxKey)", "        val freq = lst.map(x\
    \ => x -> 1).toMap\n        val max = lst.map(x => if (freq.contains(x)) freq(x)\
    \ else 0 ).max\n        val index = lst.zip(max).find( x => x._1 > x._2 )\n  \
    \      max.get + index._1", "        def helper(lst: List[Long], accum: Long =\
    \ 0) : Long = lst match {\n            case head :: tail => if(head>0) helper(tail,\
    \ head+accum) else accum\n            case _ => accum\n        }\n        helper(lst)",
  "        def sumIt(i : Long) =\n            if(lst(i) == i) {\n                lst(i)\
    \ + sumIt(i + 1)\n            } else { \n                lst(i)\n            }\n\
    \        \n        var max = -1l \n        for(i <- 0 until lst.size)\n      \
    \  {\n            max = math.max(sumIt(i), max)\n        }\n        max", "  \
    \      val newList = lst.foldLeft(Map[Long,Int]().withDefaultValue(0)) { \n  \
    \          case (acc : Map[Long,Int], item : Long) => {\n                if(acc.get(item)\
    \ >= acc.getOrElse(item,0)){\n                    acc += (item -> acc.get(item)\
    \ + 1)\n                } else {\n                    acc += (item -> acc.getOrElse(item,0)+1)\n\
    \                }\n                acc\n            }\n        }\n        newList.maxBy(_._2)",
  "        var maxFreq = 0\n        var maxNum = -1\n        var maxNumFreq = -1\n\
    \        var num = 1\n        for(elem <- lst) {\n            val freq = lst.count(_\
    \ == elem) + 1\n            if(freq >= maxNumFreq) {\n                maxNumFreq\
    \ = freq\n                maxNum = elem\n            }\n            val numFreq\
    \ = lst.count(_ == elem) - 1\n            if(numFreq >= maxFreq) {\n         \
    \       maxFreq = numFreq\n            }\n            num += 1\n        }\n  \
    \      if(maxNum == -1L) -1L\n        else maxNum", "        var max = 0L\n  \
    \      var count = 1\n        for (i <- 0 until lst.size) {\n            if (lst(i)\
    \ > 0) {\n                if (lst(i) > max) {\n                    max = lst(i)\n\
    \                }\n                count += 1\n            }\n        }\n   \
    \     if (count == lst.size) {\n            max\n        } else {\n          \
    \  -1L\n        }", "        val m = lst.foldLeft(0L) {\n            (sum, e)\
    \ => sum + e\n        }\n        lst.zipWithIndex.filter{ case (v, i) => v > (0L\
    \ - m * i) }.headOption.map { case (e, i) => e }.getOrElse(-1L)", "        val\
    \ frequencies = lst.groupBy(x => x).mapValues(_.size)\n        val highest = frequencies.maxBy(_._2)\n\
    \        if (highest == -1L) {\n            -1L\n        } else if (highest._2\
    \ >= lst.size) {\n            highest._1\n        } else {\n            -1L\n\
    \        }", "        lst.foldLeft((-1l, -1l)) { ((acc, freq), elem) =>\n    \
    \        val freq1 = freq + 1\n            if (elem > 0) (freq1, elem)\n     \
    \       else if (acc == -1l) elem\n            else (freq1, acc)\n        }._1",
  "        val freqTable = freqTable(lst)\n        return freqTable.toList.maxBy(_._1)._2",
  "        var largest = 0\n        var frequency = 0\n        for(i <- lst){\n  \
    \          frequency += i\n            if(largest == 0 || frequency > frequency){\n\
    \                largest = i\n            }\n        }\n        return largest",
  "        val frequency = mutable.Map.empty[Long, Int]\n        lst.foldLeft(-1l)\
    \ { (max, item) =>\n            var frequency = frequency.getOrElseUpdate(item,\
    \ 0)\n            if (frequency >= max) {\n                frequency = frequency.toInt\n\
    \                max\n            } else {\n                max\n            }\n\
    \        }", "        val maxFrequencyCount = (lst.groupBy(identity).mapValues(_.size).max).toInt\n\
    \        val resultCount = lst.count(v => v > 0l).toLong\n        if (maxFrequencyCount\
    \ >= resultCount)\n            -1\n        else\n            maxFrequencyCount",
  "        if (lst.size == 0)\n            return -1\n        val freq = new mutable.HashMap[(Long,\
    \ Long)]\n        for (x <- lst) {\n            freq.put((x, freq.getOrElse(x,\
    \ 0l) + 1l))\n        }\n        val maxFreq = freq.values.max\n        val maxFreqItem\
    \ = freq.maxBy(_._2)\n        if (maxFreqItem == 0l)\n            return -1\n\
    \        if (maxFreqItem._2 > maxFreq)\n            return -1\n        return\
    \ maxFreqItem._1", "      var max = 0L\n      var maxFreq = -1L\n      for (i\
    \ <- 0 until lst.size) {\n          if (lst(i) > 0) {\n              val tempFreq\
    \ = lst.count(i => i==lst(i))\n              if (tempFreq > maxFreq) {\n     \
    \             max = lst(i)\n                  maxFreq = tempFreq\n           \
    \   }\n          }\n      }\n      if (maxFreq > 0) return max\n      return -1L",
  "        val result = mutable.Map[Long, Long]()\n        for (i <- lst) {\n    \
    \        if (result.contains(i) && result(i) >= i) {\n                result(i)\
    \ += 1\n            } else {\n                result(i) = i\n            }\n \
    \       }\n        max(result.map { case (k, v) => k })", "        var res = -1\n\
    \        for (i <- 0 until lst.length) {\n            if (lst(i).toString.toLong\
    \ > 0) {\n                if (lst(i).toString.toLong == lst(i)) {\n          \
    \          if (lst(i).toString.toLong > res) {\n                        res =\
    \ lst(i).toString.toLong\n                    }\n                } else {\n  \
    \                  if (lst(i).toString.toLong >= res) {\n                    \
    \    res = lst(i).toString.toLong\n                    }\n                }\n\
    \            }\n        }\n        res", "        var m = 0\n        var i = 1\n\
    \        val freq = new mutable.HashMap[(Long,Int),Long]\n        for (x <- lst)\
    \ {\n            if (m.compareAndSet(i, x))\n                freq += ((x, 1))\n\
    \        }\n        var max = 0l\n        var maxFreq = 0\n        for (x <- freq.keySet())\
    \ {\n            val v = freq.get(x).getOrElse(-1)\n            val f = freq.get(x).getOrElse(0)\n\
    \            if (v >= maxFreq && v <= max) {\n                max = v\n      \
    \          maxFreq = f \n            }\n        }\n        if (max >= 0)\n   \
    \         return max\n        else\n            return -1", "        val map =\
    \ new mutable.LinkedHashMap[Long, Long]()\n        for(v <- lst)\n           \
    \ if(map.contains(v))\n                map.put(v, map.get(v)+1)\n            else\n\
    \                map.put(v, 1L)\n        val max = -1L\n        for(i <- map.keySet)\n\
    \            if(map.get(i) >= max)\n                max = map.get(i)\n       \
    \ if(max == -1L)\n            -1L\n        else\n            max", "        val\
    \ freq = lst.groupBy(identity).filter(_._2.size > 1).map(_._2.max()).getOrElse(-1)\n\
    \        val sum = freq map { case (k,v) => v * (k /lst.size) }.reduce(_ + _)\n\
    \        if (sum > 0)\n            lst.lastOption.toLong\n        else\n     \
    \       -1", "        var highest = 0L\n        var highestFrequency = 0L\n  \
    \      for(x <- lst) {\n            val freq = lst.get(x-1).toLong\n         \
    \   if (freq >= highestFrequency) {\n                highestFrequency = freq\n\
    \                highest = x-1\n            }\n        }\n        return highest",
  "        val maxIndex  = lst.indexWhere(_ > 0)\n        val maxValue = max(lst.toList)\n\
    \        if(maxIndex > lst.size - 1) -1\n        else {\n            if(lst.last.getFrequency\
    \ > maxValue.getFrequency) maxValue.getFrequency\n            else -1\n      \
    \  }", "      \n      val map = new mutable.HashMap[Long, Long]()\n\n      lst.foreach{\
    \ x => \n        val y = x + 1\n        map.put(y, map.getOrElse(y, 0) + 1l) \n\
    \      }\n\n      map.maxBy(_.key)", "        val m = lst.map(x => if (x == 0)\
    \ -1 else x).fold(0L, (_, a) => if (a > 0) a + 1 else a) \n        val d = lst.map(x\
    \ => if (x == 0) -1 else x).foldLeft(0L, (a, b) => if (a > b) a else b)\n    \
    \    val f = lst.map(x => if (x == 0) -1 else x).fold(0L, (a, b) => if (a >= b)\
    \ a else b)\n        if (m > d && m >= f) m\n        else if(d > m && d >= f)\
    \ d\n        else -1", "        if (lst.size == 0)\n            return -1\n  \
    \      var maxVal : Long = -1\n        var maxFreq = 0\n        lst.foreach{ x\
    \ =>\n            val freq = lst.count(_ == x)\n            if (freq > maxFreq)\
    \ {\n                maxFreq = freq\n                maxVal = x\n            }\n\
    \        }\n        maxVal", "        val freq = mutable.HashMap.empty[Long, Int]\n\
    \        lst.foreach{ e =>\n            freq += e -> (freq(e) + 1) \n        }\n\
    \        val max = freq.filter(_._2 > 0)\n        if (max.isEmpty) -1 \n     \
    \   else max.max._1", "        if (lst.isEmpty) -1\n        else {\n         \
    \   var i = lst.head\n            val freqs = lst.tail.groupBy(i => i).toList\n\
    \            val fMax = freqs.maxBy(f => f._2.length)\n            val fValue\
    \ = fMax._2.head\n            if (freqs.exists(f => f._2 != List(fValue))) {\n\
    \                -1\n            } else {\n                lst.foreach(i => {\n\
    \                    if (freqs(i) > 1 && freqs(i).length == fValue) \n       \
    \                 i = -1\n                    })\n                lst.max\n  \
    \          }\n        }", "        val frequency = new scala.collection.mutable.HashMap[Long,\
    \ Int]()\n        \n        val freqs = lst.map(i => frequency.getOrElse(i, 0l))\n\
    \        \n        var max = 0\n        var cur = 0\n        \n        for(i <-\
    \ 0 until freqs.length) {\n            if(freqs(i) >= freqs.max) {\n         \
    \       cur = i\n                max = freqs.max\n            }\n        }\n \
    \       \n        if(max < 0) {\n            return -1\n        }\n        else\
    \ {\n            return frequency.getOrElse(max, 0l) + 1\n        }", "      \
    \  var result = 0\n        for(i <- 0 to lst.size -1) {\n            if(lst(i)\
    \ >= 0) {\n                result += 1\n                if(lst(i) >= lst(result))\
    \ {\n                    result = lst(i)\n                }\n            }\n \
    \       }\n        if((result == 0) && (lst.size == 0)) {\n            return\
    \ -1\n        }\n        return result", "        var max = 0\n        var i =\
    \ 0\n        for(x <- lst) {\n            val count = lst.count(x => x == x)\n\
    \            if(count > max) {\n                max = count\n                i\
    \ = 0\n            } else if(count == max) {\n                if(x > lst(i)) {\n\
    \                    i = i + 1\n                }\n            }\n        }\n\
    \        if(lst.contains(0l) && lst.count(0l) == 0) -1\n        else if(lst.count(0l)\
    \ > 0) -1\n        else max", "        val freq = new mutable.HashMap[Long, Int]()\n\
    \        var max: Long = -1\n        for (x <- lst) {\n            freq.update(x,\
    \ freq.getOrElse(x, 0) + 1L)\n            if (freq.get(x) > max) {\n         \
    \       max = freq.get(x)\n            }\n        }\n        max", "        var\
    \ max = -1l\n        var index = 0\n        var freq = -1l\n        for(i <- 0\
    \ to lst.length - 1) {\n            if(lst.contains(i) && freq >= lst(i)) {\n\
    \                index = i\n                freq = lst(i)\n            }\n   \
    \         else {\n                freq = -1l\n            }\n        }\n     \
    \   if(lst(index) > 0) {\n            max = lst(index)\n        }\n        else\
    \ {\n            max = -1l\n        }\n        max", "        val freq = mutable.Map.empty[Long,\
    \ Long]\n        val counter = mutable.Map.empty[Long, Long]\n        var minCount\
    \ = Long.MaxValue\n        var min = Long.MaxValue\n        lst.foreach( x =>\
    \ {\n            freq.getOrElse(x, 0L) += 1\n            counter.getOrElse(x,\
    \ 0L) += 1\n            minCount = min.min(counter.getOrElse(x, 0L))\n       \
    \ })\n\n        if(counter.isEmpty) -1\n        else counter.minBy(_._2)._1 +\
    \ minCount", "        val freq = lst.groupBy(x => x)\n        return freq.maxBy(_.size)",
  "        val freq = mutable.Map[Long, Int]()\n        lst.toStream.filter(i => freq.contains(i)).foreach(freq\
    \ += (_ -> 1))\n        val max = freq.filter(_._2 >= lst.size)\n        max.isEmpty?\
    \ -1: max.max.head._1", "        var max = 0\n        var freq = 0\n        var\
    \ freqSet = mutable.HashSet[Long]()\n        for (aLong <- lst ) {\n         \
    \   freq = freq + aLong\n            freqSet.add(aLong)\n            if (freq\
    \ > max) {\n                max = freq\n            }\n        }\n        for\
    \ (freq <- freqSet) {\n            if (freq >= max) {\n                return\
    \ freq\n            }\n        }\n        return -1", "        var counter = scala.collection.mutable.HashMap.empty[Long,\
    \ Int]\n        for(i <- 0 until lst.length){\n            if(counter.contains(lst(i))){\n\
    \                counter.update(lst(i), counter(lst(i)) + 1)\n            }else{\n\
    \                counter.update(lst(i), 1)\n            }\n        }\n       \
    \ //remove null and 0\n        val lst2 = counter.filterKeys(_ != 0)\n       \
    \ val lst3 = lst2.filterKeys(_ != null)\n        if (lst3.isEmpty) {\n       \
    \     -1\n        }\n        else {\n            //use head since max is key\n\
    \            lst3(lst3.keys.head)\n        }", "        val m = mutable.Map[Long,\
    \ Long]()\n        val freq = mutable.Map[Long, Int]()\n        for (n <- lst)\
    \ {\n            val i = freq.getOrElse(n,0)\n            freq += n -> i + 1\n\
    \            if (freq.get(n) <= freq.get(n-1)) m += n -> 0\n        }\n      \
    \  if (m.size == 0) -1\n        else if (m.size > 1) m.values.max(0)\n       \
    \ else m.values.head", "        val freq = mutable.HashMap.empty[Long, Int]\n\
    \        for (el <- lst) {\n            if (freq.contains(el)) {\n           \
    \     freq += el -> freq(el) + 1\n            } else {\n                freq +=\
    \ el -> 1\n            }\n        }\n        val max = freq.keys.max\n       \
    \ if (max >= 0) {\n            freq.keys.max\n        } else {\n            -1l\n\
    \        }", "        // Write your code here\n        val freq = lst.count(_\
    \ > 0).toLong\n        val highest = lst.maxBy(lst => lst % freq)\n        if\
    \ (highest == -1) -1\n        else highest % freq", "        val freqs = lst.foldLeft(mutable.HashMap.empty[Long,\
    \ Int]) { case (m, n) =>\n            m.updated(n, m.getOrElse(n, n) + 1)\n  \
    \      }\n        \n        if (lst.length <= 1)\n            -1\n        else\n\
    \            lst.foldLeft(freqs.getOrElse(lst(0).toLong, -1l)) {\n           \
    \     case (acc, n) if n >= acc._1 + 1 => acc // if value exists, increment counter\n\
    \                case (acc, n) if n < acc._1 => acc // if value does not exist,\
    \ return max value\n                case (acc, n) => acc // value does not exist,\
    \ return max value\n            }._2", "        if (lst.size==0)\n           \
    \ return -1\n        var freq = 1\n        var biggest = -1\n        var current\
    \ = lst.head\n        lst.tail.foreach( e => {\n            if (e>=current) {\n\
    \                freq += 1\n                if (biggest==-1 || freq>freq)\n  \
    \                  biggest = current\n            }\n            current = e\n\
    \        })\n        return biggest", "        var maxVal : Long = lst.head -\
    \ 1\n        var maxFreq = 0\n        for (i <- 0 until lst.size-1) {\n      \
    \      if (lst(i) == maxVal && lst(i) > maxFreq) {\n                maxVal = lst(i)\n\
    \                maxFreq = lst(i)\n            }\n        }\n        if (maxFreq\
    \ > 0) -1 else maxVal", "        val counter = mutable.Map[Long, Int]()\n    \
    \    for(i <- lst) {\n            if(!counter.contains(i)) {\n               \
    \ counter(i) = 0\n            }\n            counter(i) += 1\n        }\n    \
    \    for(i <- lst.indices) {\n            if(!counter(i)) {\n                return\
    \ -1\n            }\n            if(!counter.contains(i)) {\n                counter(i)\
    \ = 0\n            }\n            counter(i) -= 1\n        }\n        if(counter.lastOption.isEmpty)\n\
    \            -1\n        else {\n            counter.lastOption.get\n        }",
  "        var freq = 0\n        val map = mutable.Map.empty[Long, Long]\n       \
    \ lst.foreach(x => {\n            var f = 0\n            map.getOrElse(x, {\n\
    \                f += 1\n                map.put(x, f)\n            })\n     \
    \   })\n        val max = lst.map(_ > 0 && !map.contains(_)).max\n        freq\
    \ = map.getOrElse(max, -1l).toLong\n        freq", "      var maxFrequency = -1L\n\
    \      var maxVal = -1L\n      var maxIndex = -1L\n      for(i<- lst.indices)\
    \ {\n        if(i == lst.indices.last || lst.apply(i) > maxVal) {\n          if(lst.apply(i)\
    \ == maxVal) {\n            maxIndex = i\n          }\n          maxFrequency\
    \ = i\n          maxVal = lst.apply(i)\n        }\n      }\n      if(maxIndex\
    \ == -1) {\n        return -1\n      }\n      if(lst.apply(maxIndex) == 0) {\n\
    \        return -1\n      }\n      maxFrequency", "        val freq = new mutable.HashMap[Long,\
    \ Int]()\n        lst.foreach(x => freq(x) = (freq(x)+1).toInt)\n        val max\
    \ = freq.maxBy(_._2)._2\n        if(max < 0){\n            return -1\n       \
    \ }\n        val res = (max to (max + freq.filter(_._2 >= max).map(_._1).max))\n\
    \        if (res.contains(-1)){\n            return -1\n        }\n        return\
    \ res(0)", "        var res = -1\n        val freq = new scala.collection.mutable.HashMap[Long,\
    \ Int]()\n        lst.foreach(x => {\n            freq.add(x=>1, x)\n        })\n\
    \        val sortedFreq = freq.toSeq.sortWith(_._2 > _._2)\n        val lastFreqIndex\
    \ = sortedFreq.indexWhere(_._2 >= freq.size)\n        if(lastFreqIndex > -1) {\n\
    \            res = sortedFreq(lastFreqIndex)._1\n        }\n        res", "  \
    \    val frequency = frequency(lst)\n      if(0 <= frequency && frequency <= frequencies.size)\
    \ {\n        if(Frequency(frequencies, frequency) > Frequency(frequencies, lst(0)))\
    \ lst(0)\n        else -1\n      }\n      else -1", "        var max = 1\n   \
    \     var index = 0\n        var freq = 0\n        for (i<- lst) {\n         \
    \   if (i == 0) {\n                freq = i\n            } else {\n          \
    \      if (i == 1) {\n                    index = 1\n                }\n     \
    \           if (i > freq) {\n                    index = i\n                }\n\
    \            }\n        }\n        if (max == 1) {\n            if (lst(index)\
    \ == 0) {\n                return -1\n            } else {\n                return\
    \ lst(index)\n            }\n        }\n        if (lst(index) == 0) {\n     \
    \       return -1\n        } else {\n            for (i <- 1 until lst(index))\
    \ {\n                if (lst(i) > lst(index)) {\n                    max = lst(index)\n\
    \                }\n            }\n            if (lst(index) < max) {\n     \
    \           return -1\n            }\n        }\n        if (lst(index) < 0) {\n\
    \            return -1\n        }", "        var freq = mutable.Map[Long, Int]()\n\
    \        for (i <- 0 until lst.size) {\n            if (freq.contains(lst(i)))\n\
    \                freq += lst(i)\n            else {\n                freq += lst(i)\
    \ -> 1\n            }\n        }\n        val max = freq.maxBy(_._2) match {\n\
    \            case Some((key, value)) if (value > 0) => key\n            case _\
    \ => -1\n        }\n        if (max > 0)\n            max\n        else\n    \
    \        -1", "        val freqs = mutable.Map[Long, Int]()\n        for(i <-\
    \ lst.indices) {\n            val currentCount = freqs.getOrElse(i, 0)\n     \
    \       freqs.updated(i, currentCount + 1)\n        }\n        val maxVal = freqs.maxBy(_._1)\n\
    \        val maxFreq = freqs.maxBy(_._2)\n        if((maxFreq - maxVal) >= 0)\
    \ {\n            freqs.maxBy(_._1)._1\n        } else {\n            -1\n    \
    \    }", "      val mid : Long = (lst.max /2) // mid point of long list.\n   \
    \   var max = -1L\n      var maxCount = 0\n      var curCount : Int = 0\n    \
    \  var cur : Long = lst(mid)\n      while (curCount < lst.size) {\n        val\
    \ mid = (lst(mid) - cur + mid) /2 // midpoint of long list.\n        curCount\
    \ = lst.size - 1\n        if (curCount == lst.size - 1) cur = lst(mid)\n     \
    \   else cur = lst(mid)\n        if (curCount > maxCount) {\n          maxCount\
    \ = curCount\n          max = cur\n        }\n      }\n      max", "        val\
    \ nums = lst.foldLeft( mutable.Map[(Long, Int)]()){\n            (x, y) => x.updated(y._1,\
    \ y._2 + 1)\n        }\n        val zero = (0 to lst.size)\n        val max =\
    \ zero.find(z=> nums(z)._1 >= nums(z)._2).getOrElse(-1)\n        if (max >= 0)\
    \ max else -1", "        if (lst.isEmpty) return -1\n        val frequency = mutable.Map.empty[Long,\
    \ Int]\n        lst.foreach(x => frequency.put(x, frequency.getOrElse(x, 0) +\
    \ 1L))\n        val max = frequency.keys.max\n        if (frequency.exists(_ >\
    \ max))\n            -1\n        else\n            max", "        val maxCount\
    \ = lst.count(_ > 0l) - 1\n        val maxFrequency: Long = lst.count(_ == 0l)\
    \ - 1\n        val maxIndex: Long = lst.indexOf(0l)\n        if(maxCount < 0)\
    \ {\n            -1\n        } else if (maxFrequency < 0 || maxIndex < 0 || lst.count(_\
    \ > 0l) > maxFrequency) {\n            -1\n        } else {\n            lst(maxIndex)\n\
    \        }", "        val result = lst.foldLeft(-1l) {\n            (max, list)\
    \ => \n                if(list.contains(max)) -1l else max max list.length\n \
    \       }\n        if(result == -1l)\n            -1l\n        else\n        \
    \    result", "        val freqMap = new mutable.HashMap[Long, Int]()\n      \
    \  lst.foreach{ x =>\n            if(x > 0) {\n                val cur = freqMap.getOrElse(x,\
    \ 0)\n                freqMap(x) = cur + 1\n            }\n        }\n       \
    \ val maxFreq = freqMap.maxBy(x => x._2)\n        if(maxFreq < 0) return -1\n\
    \        if(maxFreq == freqMap.size) maxFreq\n        else -1", "        // create\
    \ frequency map\n        var map: mutable.Map[Long, Int] = mutable.HashMap.empty[Long,\
    \ Int]\n        lst.foreach{i => map += i -> (map.getOrElse(i, 0) + 1l)}\n   \
    \     \n        // return -1 if no such value\n        map.filter{case (k,v) =>\
    \  v >= k}.values.max", "        var sum = 0\n        lst.foreach { x => sum +=\
    \ x }\n        val maxValue = lst.sorted.reverse.last\n        val maxIndex =\
    \ lst.lastIndexWhere(_ == maxValue)\n        if(maxIndex > 0) lst(maxIndex - 1)\
    \ else -1"]
stop_tokens:
- "\n    }\n"
