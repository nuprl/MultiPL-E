name: HumanEval_133_sum_squares
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of numbers.\n    // You need to return the sum of squared\
  \ numbers in the given list,\n    // round each element in the list to the upper\
  \ int(Ceiling) first.\n    // Examples:\n    // >>> lst((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat)))\n    // (14l)\n    // >>> lst((List[Float](1.0f.toFloat,\
  \ 4.0f.toFloat, 9.0f.toFloat)))\n    // (98l)\n    // >>> lst((List[Float](1.0f.toFloat,\
  \ 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat)))\n    // (84l)\n    // >>> lst((List[Float](1.4f.toFloat,\
  \ 4.2f.toFloat, 0.0f.toFloat)))\n    // (29l)\n    // >>> lst((List[Float](-2.4f.toFloat,\
  \ 1.0f.toFloat, 1.0f.toFloat)))\n    // (6l)\n    def sumSquares(lst : List[Float])\
  \ : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sumSquares((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat))) == (14l));\n    assert(sumSquares((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat))) == (14l));\n    assert(sumSquares((List[Float](1.0f.toFloat,\
  \ 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat))) == (84l));\n    assert(sumSquares((List[Float](1.4f.toFloat,\
  \ 4.2f.toFloat, 0.0f.toFloat))) == (29l));\n    assert(sumSquares((List[Float](-2.4f.toFloat,\
  \ 1.0f.toFloat, 1.0f.toFloat))) == (6l));\n    assert(sumSquares((List[Float](100.0f.toFloat,\
  \ 1.0f.toFloat, 15.0f.toFloat, 2.0f.toFloat))) == (10230l));\n    assert(sumSquares((List[Float](10000.0f.toFloat,\
  \ 10000.0f.toFloat))) == (200000000l));\n    assert(sumSquares((List[Float](-1.4f.toFloat,\
  \ 4.6f.toFloat, 6.3f.toFloat))) == (75l));\n    assert(sumSquares((List[Float](-1.4f.toFloat,\
  \ 17.9f.toFloat, 18.9f.toFloat, 19.9f.toFloat))) == (1086l));\n    assert(sumSquares((List[Float](0.0f.toFloat)))\
  \ == (0l));\n    assert(sumSquares((List[Float](-1.0f.toFloat))) == (1l));\n   \
  \ assert(sumSquares((List[Float](-1.0f.toFloat, 1.0f.toFloat, 0.0f.toFloat))) ==\
  \ (2l));\n    }\n\n}\n"
completions: ["        val mutableSum = mutable.ArrayBuffer.empty[Float]\n       \
    \ lst.foreach{ x =>\n            val ceiling = math.ceil(x)\n            val floor\
    \ = math.floor(x)\n            val rounding = math.round(x / ceiling)\n      \
    \      mutableSum += rounding * (ceiling - floor) * (ceiling - floor)\n      \
    \  }\n        mutableSum.sum", "        val total = lst.foldLeft(0.0f)((sum, element)\
    \ => sum + element*element)\n        math.ceil(total).toLong", "        val sum\
    \ = 0.f\n        lst.foreach(i => sum += i * i)\n        math.ceil(sum)", "  \
    \    var sum = 0L\n      for(x <- lst) sum = sum + math.pow(x, 2)\n      Math.ceil(sum)",
  "        val ns = lst.map(x => (x).toInt).sorted\n        var sum = 0.0;\n     \
    \   var last = 0\n        var sumSquare = 0.0\n        var sumLastSquare = 0.0\n\
    \        var index = 0\n        var lastSum = math.pow((math.pow(last,2)+sumLastSquare),0.5)\n\
    \        for(i <- ns)\n        {\n            sum += i\n            sumSquare\
    \ += math.pow((math.pow(i,2)+sumSquare),0.5)\n            sumLastSquare += math.pow((math.pow(sumLastSquare,2)+sumSquare),0.5)\n\
    \            index += 1\n            if(index > lst.size - 1)\n            {\n\
    \                sum /= index\n                sumSquare /= index\n          \
    \      sumLastSquare /= index\n                index = 1\n                last\
    \ = i\n            }\n        }\n        val l2 = lst.map(x => (x).toInt).sorted\n\
    \        var index = l2(0)\n        val ns = l2.toList\n        for(i <- ns)\n\
    \        {\n            index += 1\n            val x2 = (index).toInt\n     \
    \       val n3 = lst.filter(x => x.toInt < x2)\n            for(j <- n3)\n   \
    \         {\n                val x2 = (j).toInt\n                val n4 = lst.filter(x\
    \ => x.toInt > x2)\n                for(k <- n4)\n                {\n        \
    \            val x2 = (k).toInt\n                    val n5 = lst.filter(x =>\
    \ x.toInt == x2)\n                    sum += x2.toLong * (n5(0)*x5(1)*x5(2)*x5(3))\n\
    \                }\n            }\n        }\n        (last*sumLastSquare).toLong",
  "        val nums = mutable.ListBuffer.empty[Float]\n        for (x <- lst) {\n\
    \            nums += x\n        }\n        nums.map (x => math.pow(x, 2.0)).sum",
  "        val a = mutable.MutableList(0.0f)\n        var max = 0l\n        lst.foreach(f\
    \ => {\n            a.append(f.toInt)\n            max = Math.max(max, a.last)\n\
    \        })\n        val b = mutable.ArrayBuffer(max)\n        lst.foreach(f =>\
    \ {\n            b.append(f.toInt)\n        })\n        val c = a.toBuffer\n \
    \       val d = b.toBuffer\n        val e = (c.sum * (c.sum - d)) / (c.size -\
    \ d.size)\n        return e.toLong", "      lst.reverse.zipWithIndex.filter{ x\
    \ =>\n        x._2 < lst.length\n      }.map{ x =>\n        val i = x._2\n   \
    \     val l = lst(i)\n        val r = math.ceil(l).toFloat\n        val s = l\
    \ * l - r * r\n        s + r\n      }.reduceLeft((x, y) => x + y)", "      var\
    \ sum = 0\n      var nums: List[Float] = lst\n      for(i <- 0 until nums.size)\
    \ {\n        val num = nums(i)\n        sum = math.ceil(math.pow(num, 2))\n  \
    \    }\n      return sum", "        lst.sortWith(math.abs(_) < math.abs(_))\n\
    \        // find the sum of the numbers in the list\n        var sum = 0.0f\n\
    \        // loop through the list\n        lst.foreach(x => sum += math.pow(x,\
    \ 2))\n        // round the sum to the ceiling\n        val ceiling = math.ceil(sum)\n\
    \        ceiling.toLong", "        // get the length of list\n        // use the\
    \ length of list to calculate the sum of squared numbers\n        val len : Int\
    \ = lst.length\n        var sum = 0L\n        for (i <- 0 until len) {\n     \
    \       val x = lst(i)\n            sum += (x.toInt * x.toInt)\n        }\n  \
    \      return sum", "        val size = lst.size\n        var sum = 0L\n     \
    \   for(i <- 0 until size) {\n            val x = lst(i).toInt\n            val\
    \ y = lst(i).toInt\n            val z = (x * x) + (y * y)\n            sum +=\
    \ z\n        }\n        sum", "        val (lst1, lst2) = lst\n        val nList\
    \ = lst1.zip(lst2)\n        val n = nList.size\n        var sum = 0.0\n      \
    \  for(i <- 0 until n) {\n            sum += nList(i).product\n        }\n   \
    \     sum.toLong", "        var sum = 0.0\n        lst.foreach { x =>\n      \
    \      sum += (x * x)\n        }\n        return sum.toLong", "        // Write\
    \ your code here\n        val sq = lst.map(i => math.pow(i,2)).toList\n      \
    \  val result = sq.sum\n        val cnt = sq.count(i => i > 0)\n        println(\"\
    lst : \" + lst)\n        println(\"sq : \" + sq)\n        println(\"result : \"\
    \ + result)\n        println(\"cnt : \" + cnt)\n        println\n        return\
    \ result", "        val result = mutable.HashMap.empty[Float, Long]\n        for\
    \ (item <- lst) {\n            val val = item.toFloat\n            result(val)\
    \ += Math.pow(val, 2)\n        }\n        val total = result.values.sum\n    \
    \    result.foreach { case (k, v) => result = result(k) - v }\n        total",
  "        val list = lst.toList\n        val newList = mutable.ListBuffer[Float]()\n\
    \        list.foreach {\n            i =>\n                val rounded = (i.toInt\
    \ +- 0.5).toFloat\n                newList += rounded\n        }\n        newList.sum",
  "        var sum = 0.0\n        for (i <- 0 until lst.length){\n            sum\
    \ = sum + math.pow(lst(i).toInt, 2)\n        }\n        math.ceil(sum).toLong",
  "        val sum = mutable.ListBuffer.empty[Float]\n        lst.foreach(num => sum\
    \ += num.toFloat / math.Ceiling(num.toFloat))\n        sum.sum", "        var\
    \ sum = lst(0f); var sumSqr = lst(0f); var nextUp = lst(0)\n        lst.foreach\
    \ { x =>\n            if (x > 0) {\n                sumSqr = sum * sum + nextUp\
    \ * nextUp\n                sum += x\n            }\n            nextUp = x\n\
    \        }\n        sumSqr", "        val x = lst.toArray\n        val y = (0\
    \ until x).map((x(i)).toLong)\n        return y.sum", "        val result = mutable.ListBuffer.empty[Float]\n\
    \        lst.foreach{ element =>\n            val f = Math.ceil(element)\n   \
    \         result += (f*f).toLong\n        }\n        require(result.toList.size\
    \ == result.size)\n        result.toList.sum", "        // sort by ascending\n\
    \        lst.sortWith(_.isLessThan(_))\n\n        var sum = 0L\n\n        for\
    \ (x <- lst) {\n            sum += math.pow(x, 2.0).toLong\n        }\n\n    \
    \    // round up\n        sum += scala.math.roundUp(sum, -1)\n\n        sum.toLong",
  "        def ceil(x: Float) : Float = Math.ceil(x)\n        def roundToInt[A](x:\
    \ A) : A = Math.ceil(x)\n        val newList: List[Float] = lst.map(x => (ceil(x))(x))\n\
    \        val sum = newList.sum\n        val sq = sum * sum\n        sq.toLong",
  "        val sum = (lst.map(x => (math.ceil(x*x)).toList).sum*lst.map(x => (math.ceil(x*x)).toList).sum)\n\
    \        sum", "        var sum = 0\n        for (i <- 0 until lst.length) {\n\
    \            sum += lst(i)*(lst(i))\n        }\n        return sum", "       \
    \ val n = lst.size\n        val sqr = lst.map(x=>x*(x - 1.0)).toList\n       \
    \ val max = sqr.max\n        val min = sqr.min\n        if (max != 0.0) {\n  \
    \          if (max > 0.0) {\n                sqr.map(x=>ceil(x * max)).toList.sum\n\
    \            } else {\n                sqr.map(x=>ceil(x * -max)).toList.sum\n\
    \            }\n        } else {\n            if (min < 0.0) {\n             \
    \   sqr.map(x=>ceil(x * min)).toList.sum\n            } else {\n             \
    \   sqr.map(x=>ceil(x * -min)).toList.sum\n            }\n        }", "      \
    \  val l = lst.map(_.toInt).max\n        val m = lst.map(_.toInt).min\n      \
    \  val count = lst.size\n        val sum = (l*l).+(count*(m*m))\n        sum.toLong",
  "        val sum = 0.0f + (lst.map(i => math.pow(i, 2.0f)).sum)\n        return\
    \ sum.toLong", "      val ns = lst.map(_.toInt)\n      val s = ns.reduceLeft((acc,n)\
    \ => n+acc)\n      val f = s.toFloat\n      if(f > 0) f.ceil.toLong*f else f",
  "        var result = 0L\n        lst.foreach(element => {\n            val temp\
    \ : Float = Math.ceil(element).toFloat\n            result += temp*temp\n    \
    \    })\n        result", "        var sum = 0L\n        lst.foreach(x => sum\
    \ += Math.pow(Math.ceil(x), 2))\n        sum", "        if(lst.isEmpty)\n    \
    \        0\n        else {\n            val len = lst.size\n            var i\
    \ = 0\n            val total = 0L\n            for(item <- lst) {\n          \
    \      total += item * item\n                i = i + 1\n                if(i %\
    \ 2 == 1) {\n                    total += (item * item).toInt\n              \
    \  }\n            }\n            total.toLong\n        }", "        var sum =\
    \ mutable.Map.empty[Float, Float]\n        for (x <- lst)\n            if (!sum.contains(x))\n\
    \                sum += (x.toInt, x)\n        else sum\n            .map { case\
    \ (k, v) => math.pow(k.toInt, 2) + v }\n            .foldLeft(0l)(_ + _)", " \
    \       val rs = new scala.collection.mutable.HashMap[Int, Long]()\n        for\
    \ (i <- 0 until lst.size) {\n            val newNum = Math.ceil(lst(i).toInt)\n\
    \            rs.put(newNum, rs.getOrElse(newNum, 0L) + lst(i).toLong)\n      \
    \  }\n        rs.values.sum", "        var sum = 0.0\n        for (i <- 0 until\
    \ lst.length)\n            sum += lst(i)*(lst(i))\n        math.round(sum)", " \
    \       val sum:Long = 0\n        for(i <- 0 until lst.size) {\n            val\
    \ x = scala.math.ceil(lst(i).toFloat*100f)\n            sum = sum + lst(i).toFloat*x*x\n\
    \        }\n        return sum", "        val newList = lst.toList\n        val\
    \ result = newList.foldLeft(0.0f)( (acc, x) => acc + x * x )\n        math.ceil(result)",
  "        val list = lst.toList\n        val n = list.size\n        val sum = 0\n\
    \        for(i <- 0 until n){\n            val sq = math.pow((list(i).toFloat),2)\n\
    \            sum += sq\n        }\n        math.ceil(sum).toLong", "        var\
    \ sum = 0L\n        for (e <- lst) sum = sum + math.pow(e, 2)\n        sum", " \
    \       val nums = lst.toList\n        val squares = nums.map(n => (n * n).toLong)\n\
    \        val sum = squares.sum\n        val ceil = math.ceil(sum)\n        val\
    \ floor = math.floor(sum)\n        return floor + (ceil - sum)", "        val\
    \ map = (0 until lst.length).map(_ -> lst(0).toDouble).toMap\n        lst.map(x\
    \ => (ceil(x.toDouble), x)).foldLeft(0)(_ + _._2)(map)", "      val n = lst.length\n\
    \      val max: Float = lst(n - 1).toFloat\n      lst.map((x: Float) => Math.Ceiling(x*x)).toList.foldLeft(0.0f){\
    \ (x: Float, y: Float) =>\n        x+y\n      }", "        val size = lst.size\n\
    \        var sum : Long = 0\n        lst.map(x => {\n            if(x < 0) return\n\
    \            val rounded = x.toInt\n            sum += rounded*rounded\n     \
    \   })\n        if(size == 0) return 0\n        sum.toLong", "        var sum\
    \ : Long = 0\n        var index = 0\n        for(i <- 0 until lst.length){\n \
    \           index = i\n            sum += math.pow(lst(i), 2)\n        }\n   \
    \     sum", "        // The trick is to convert every element into a double, and\
    \ then sum them\n        val sumOfSquares = lst.map(x => x.toDouble).sum\n   \
    \     // Ceiling the sum is important: it allows us to have the correct sum\n\
    \        // if the number of elements in the list isn't a multiple of 2\n    \
    \    sumOfSquares.toLong + sumOfSquares.toLong % 2 > 0", "        var sum = 0.0F\n\
    \        lst.foreach(x => {\n            sum += math.pow(x, 2)\n        })\n \
    \       math.ceil(sum)", "        val (sum, sqSum) =\n            lst match {\n\
    \                case Nil => (0L, 0L)\n                case x::xs => (xs.reduceLeft((a,\
    \ b) => math.pow(a, 2) + math.pow(b, 2), 0), 0L)\n            }\n        sqSum.round(10).bigDecimal",
  "        val list: List[Float] = lst\n        val num: List[Long] = list.map(_.toLong).toList\n\
    \        val sum: Long = num.sum\n        val square: Long = num.map(x => x *\
    \ x).sum\n        (sum + square)", "        if (lst.isEmpty) 0\n        else {\n\
    \            lst.zip(lst.reverse )\n                .map(x => (x._1 * x._1 + x._2\
    \ * x._2) )\n                .foldLeft(0l)( (x, y) => x * y + x.toLong )\n   \
    \     }", "        var sum = 0L\n        for(i <- lst) {\n            sum += i\
    \ * i\n        }\n        return sum", "        val sum = 0\n        for(x <-\
    \ lst ){\n            sum = sum + Math.pow(x, 2)\n        }\n        sum.toLong",
  "        val result: MutableList[Long] = new MutableList[Long]()\n        val sum:\
    \ Long = 0\n        val max: Float = lst(lst.length - 1)\n        for (i <- 0\
    \ until lst.length) {\n            val current: Float = lst(i)\n            sum\
    \ += math.pow(current, 2)\n            val round: Int = math.ceil(current)\n \
    \           val rounded: Long = round * round\n            val roundedLong: Long\
    \ = rounded\n            if (roundedLong > max)\n                result.add(roundedLong\
    \ - max)\n            else\n                result.add(roundedLong)\n        }\n\
    \        result(0)", "        var sum = 0\n        lst.map(f => sum += Math.pow(f\
    \ , 2))\n        sum.toLong", "        val m = lst.map(x=>x.toInt)\n        var\
    \ sum = 0.0\n        for (x<-m)\n            sum += x * x\n        return sum.toLong",
  "        val squares = mutable.ArrayBuffer[Float]()\n        lst.foreach(x => squares\
    \ += math.pow(x, 2.0))\n        squares.sum", "        var sum = 0L\n        var\
    \ squares = 0L\n        lst.foreach{ n =>\n            squares += n\n        \
    \    sum = sum + n\n        }\n        val updSquares = math.ceil(squares)\n \
    \       return (sum * updSquares * updSquares).toLong", "        var sum = 0.0f\n\
    \        var i = 0\n        while (i < lst.size) {\n            val x = lst(i)\n\
    \            if (x < 0.0f) {\n                sum -= x * x\n            } else\
    \ {\n                sum += x\n            }\n            i += 1\n        }\n\
    \        sum.toLong", "        // Write your code here\n        def ceiling(num\
    \ : Float) : Float = {\n            math.ceil( num )\n        }\n        lst.map(math.pow(_,2)).sum",
  "        require(!lst.isEmpty, \"no items\")\n        require(!lst.isEmpty, \"items\
    \ must not be empty\")\n        require(!lst.tail.isEmpty, \"tail must not be\
    \ empty\")\n        lst match {\n            case Nil => 0L\n            case\
    \ x :: xs => x.toLong * sumSquares(xs)\n        }", "        def ceilFloor(n:\
    \ Float): Int = {\n            val intValue = math.ceil(n)\n            if (n\
    \ < intValue) {\n                intValue\n            } else {\n            \
    \    math.floor(n)\n            }\n        }\n\n        val listOfIntegers = lst.map(n\
    \ => ceilFloor(n).toInt)\n        var sum = 0\n        var count = 0\n       \
    \ listOfIntegers.foreach(i => {\n            if (i != 0) {\n                sum\
    \ += i.toDouble\n                count += 1\n            }\n        })\n\n   \
    \     sum.toLong", "        val sum = new mutable.HashMap[Int, Double]()\n   \
    \     lst.foreach { f =>\n            val x = math.ceil(f)\n            val y\
    \ = math.floor(f)\n            if (sum.getOrElse(x, 0.0) != 0.0) {\n         \
    \       sum.get(x) = sum.getOrElse(x, 0.0) + y * y\n            } else {\n   \
    \             sum.put(y, y)\n            }\n        }\n        sum.values.toArray.sum",
  "        var sum : Long = 0\n        lst.foreach(x => sum += x * x)\n        sum",
  "        // (1) Find the index of the first element in the list that is positive.\n\
    \        var index : Int = -1\n        lst.foreach(_ >= 0.0f && index == -1) index\
    \ = 1\n        if (index == -1) return 0.0\n        // (2) Calculate the sum of\
    \ the squares of the elements before the index.\n        var sumSquares = 0.0f\n\
    \        var i : Int = 0\n        while (i != index) sumSquares += lst(i).pow(2.0f)\n\
    \        // (3) Add the squares of the rest of the elements.\n        var sum\
    \ : Long = sumSquares\n        lst.foreach(x => {\n            sum += x.pow(2.0f)\n\
    \        })\n        // (4) Return the sum.\n        return sum", "        val\
    \ map = mutable.Map[Int, Float]()\n        for (e <- lst) {\n            val n\
    \ = Math.ceil(e)\n            map += n -> (e - n)\n        }\n        val totalSum\
    \ = mutable.Map[Int, Float]()\n        for (e <- map) {\n            val sum =\
    \ map(e)\n            val n = Math.ceil(e)\n            totalSum += n -> (sum\
    \ + sum)\n        }\n        totalSum.values.sum", "        val (minval, maxval)\
    \ = lst.minBy(_.toDouble)\n        val maxval = maxval.ceil\n        val n = lst.size\n\
    \        var sum = 0L\n        for (i <- 0 until n)\n            sum += math.pow((lst(i).toDouble\
    \ - minval), 2)\n        sum.round(maxval).toLong", "        val nums = lst.sorted\n\
    \        val n = nums.length\n        val sum = nums.foldLeft[Long](0l) { (sum,\
    \ num) => sum + num*num }\n        val squared = nums.foldLeft[Long](0l) { (sum,\
    \ num) => sum + num*num*num }\n        squared/sum", '        lst.map(_.round).foldLeft(0l)(_
    + _.toLong * _.toLong)', "        def sumSquaresHelper(lst: List[Float], result:\
    \ Long) : Long = {\n            if (lst.isEmpty) result\n            else {\n\
    \                sumSquaresHelper(\n                    lst.tail,\n          \
    \          result + lst(0).toInt * lst(0).toInt * (lst.head.toInt * lst.head.toInt))\n\
    \            }\n        }\n        sumSquaresHelper(lst, 0)", "        val list\
    \ = mutable.Buffer[Float]()\n        lst.foreach(x => list += x)\n        list.sum",
  "        val result = mutable.Buffer.empty[Long]\n        var sum = 0L\n       \
    \ lst.foreach{ x => sum += math.pow(x, 2.0) }\n        result.add(sum.toLong)\n\
    \        result.toList", "      val ls = mutable.ListBuffer[Float]()\n      for\
    \ (x <- lst) {\n        ls += x.toInt\n      }\n      ls.sum", "       val arr\
    \ = mutable.ArrayBuffer.empty[Float]\n       lst.foreach { n =>\n          arr\
    \ += n.toDouble\n        }\n        arr.map(math.pow(_.toDouble,2)).sum", "  \
    \      val nums = lst.map(_.toInt)\n        val s = nums.reduceLeft(_+_)\n   \
    \     return s.toLong", "        val res = lst\n            .map(x => x * x)\n\
    \            .fold(0.0L)( _ + _ ) // accumulate sum of squared numbers\n     \
    \       .roundToInt   // round to the Ceiling\n            .foldLeft(0.0f)(_ +\
    \ _) // accumulate sum of squared numbers\n        res", "        lst match {\n\
    \            case Nil => 0l\n            case x :: xs => sumSquares(xs.map(y =>\
    \ ((math.ceil(y))*y)*y))\n        }", "        var sum = 0\n        lst.foreach(x\
    \ => sum += math.pow(x, 2.0))\n        math.ceil(sum).toLong", "        var sum\
    \ = 0.0F\n        var sq = 0.0F\n        for ( f <- lst ) {\n            sq =\
    \ f * f\n            sum = sum + sq\n        }\n        math.ceil(sum).toLong",
  "        val ret = 0\n        for(item <- lst) ret += Math.pow(item, 2)\n      \
    \  ret", "        require(lst.nonEmpty)\n        lst.foldLeft(0l) {\n        \
    \    case (acc, x) => acc + ((x * x).floor.toLong)\n        }", "        // Write\
    \ your code here\n        val a = lst.asInstanceOf[scala.collection.mutable.WrappedArray[Float]]\n\
    \        var sum = 0.0f\n        for(i <- 0 until a.length) {\n            sum\
    \ += i * a(i)\n        }\n        math.round(sum * sum)", "        var sum = 0L\n\
    \        for (x <- lst) {\n            sum += x * (x + 1)\n        }\n       \
    \ sum", "        lst.sortWith((a, b) => a.toInt > b.toInt)\n        var sum =\
    \ 0L\n        var count = 0L\n        for (n1 <- lst) {\n            sum += n1.toInt\
    \ ** 2\n            count += 1\n        }\n        return sum * count", "    \
    \    var sum = 0L\n        for (x <- lst) {\n            sum += math.pow(x, 2.0f).toLong\n\
    \        }\n        sum.toLong", "        val r = mutable.ArrayBuffer[Float]()\n\
    \        lst.foreach { e =>\n            val f = math.Ceiling(e)\n           \
    \ if (f < 1.f) r.push(math.ceil(e))\n            else r.push(math.floor(e))\n\
    \        }\n        r.foldLeft(0L){\n            case (acc, x) => (acc + (x*x))\n\
    \        }", "        val a = mutable.ListBuffer(lst)\n        var s = 0L\n  \
    \      a.foreach(x => s += x ** 2)\n        Math.ceil(s).asInstanceOf[Long]",
  "        def sq(x: Float) : Float = x * x\n        lst.map(_.roundToInt).toList.foldLeft(0){\
    \ (sum, x) =>\n            val newSum = sum + sq(x)\n            (newSum.toInt,\
    \ newSum)\n        }._1", "        val nm = mutable.Map[Float, Int]()\n      \
    \  for (i <- lst) {\n            val key = math.ceil(i).toFloat\n            if\
    \ (nm.contains(key)) {\n                nm(i) += nm(key) + 1\n            } else\
    \ {\n                nm(i) = nm(i) + 1\n            }\n        }\n        val\
    \ sumSquares = nm.values.map(x => x * x).sum\n        sumSquares", "        var\
    \ sum = 0\n        lst.foreach(f => {\n            sum += math.pow(f, 2)\n   \
    \     })\n        sum.toLong", "        var sum = 0L\n        var sumSquares =\
    \ 0L\n        for (x <- lst) {\n            sum = sum + x\n            sumSquares\
    \ = sumSquares + (x * x)\n        }\n        sumSquares", "        //Use a hash\
    \ set data structure to store the values already encountered\n        val sums\
    \  = mutable.HashSet[Float]()\n        //Iterate over the list and store the sum\
    \ values\n        lst.foreach{x =>\n            if(!sums.contains(x)) sums.add(x)\n\
    \        }\n        //Return the sum\n        sums.foldLeft(0L)(f+_)", "     \
    \   def sumOfSquares(lst : List[Float]) : Long = {\n            val squares =\
    \ lst.map(x => x*x)\n            val sums = squares.scanLeft(0.0f)(_ + _)\n  \
    \          sums.last\n        }\n        sumOfSquares(lst)", "        val sumList\
    \ = mutable.ListBuffer[Float]()\n        lst.foreach{x =>\n            val roundedX\
    \ = Math.ceil(x * 1000) / 1000\n            sumList += roundedX\n        }\n \
    \       sumList.sum", "        // return 0 if list is empty\n        if(lst.isEmpty)\
    \ return 0L\n        var sum = 0L\n        var next = 0L\n        for(x <- lst){\n\
    \            val y = (x).toInt\n            val tempSquare = (x + y).toInt\n \
    \           val tempNext = (tempSquare + next).toInt\n            sum = sum +\
    \ tempSquare\n            next = tempNext\n        }\n        return sum", " \
    \       val map = mutable.HashMap.empty[Float, Long]\n        lst.foreach{e =>\n\
    \            val value = e / e.toInt\n            val ceiling = math.ceil(e).toInt\n\
    \            val key = (ceiling, value)\n            val valueWithKey = if (map.contains(key))\
    \ {\n                val old = map.getOrElse(key, Long.MinValue)\n           \
    \     old + value\n            } else {\n                value\n            }\n\
    \            map += key -> valueWithKey\n        }\n        math.pow(map.values.sum,\
    \ 2)", "        val nums  = lst.map(_.toInt)\n        val sum   = nums.reduce((a,\
    \ b) => a + b)\n        val squa  = nums.map(_ * _).reduce((a, b) => a + b)\n\
    \        sum + squa", "        val l = lst.size\n        var sum = 0.0f\n    \
    \    var squared = 0.0f\n\n        for (i <- 0 until l) {\n            sum +=\
    \ lst(i)\n            squared += lst(i)*lst(i)\n        }\n        sum.toLong\
    \ + squared.toLong", "        val list = mutable.Buffer.empty[Float]()\n     \
    \   lst.foreach(x => list += Math.ceil(x).toFloat)\n        list.sum", "     \
    \ val map = mutable.Map[Int, Float]()\n      lst.foreach(x => map.putIfAbsent(x.toInt*x.toInt,\
    \ x)) // put in map if absent, otherwise update\n      map.values.map(_.toDouble).sum",
  "        val sum = new mutable.ArrayBuffer(0l)\n        lst.foreach{x =>\n     \
    \       val temp = math.pow(x , 2)\n            val temp2 = math.ceil(temp)\n\
    \            sum += temp2\n        }\n        sum.reduce(_ + _)", "        require(lst.length\
    \ > 0)\n        var sum = 0f\n        for (elem <- lst) {\n            sum +=\
    \ math.pow(elem.toDouble, 2)\n        }\n        math.ceil(sum.toLong)", "   \
    \     val res = mutable.ListBuffer.empty[Long]\n        lst.foreach{x =>\n   \
    \         if (x>0)\n                res += (x * x)\n        }\n        res.reduceLeft((a,\
    \ b) => a + b)", "        val squares = lst.map(x => x * x)\n        val sum =\
    \ squares.reduceLeft(_ + _)\n        return sum", "        val size = lst.size\n\
    \        val result = mutable.Map[Float, Long]()\n        for (i<- 0 until size)\
    \ {\n            result(lst.apply(i)).+=((lst.apply(i) * lst.apply(i)))\n    \
    \    }\n        val keys = result.keys\n        val values = result.values\n \
    \       val min = values.min\n        val max = values.max\n        val range\
    \ = max - min\n        val count = keys.size\n        (range * range * count).toLong",
  "        var sum = 0L\n        lst.foreach { x =>\n            sum += x.toDouble\n\
    \        }\n        sum", "        val numOfElements = lst.size\n        var sum\
    \ = 0L\n        lst.foreach { num =>\n            sum += num * num\n        }\n\
    \        sum.toLong", "        val nums = lst.filter(x => x.toString.toDouble>0f).map(x\
    \ => x.toString.toDouble).sorted\n        val count = nums.size - 1\n        var\
    \ sum = 0L\n        for (i <- 0 until count) {\n            val current = nums(i)\n\
    \            val next = nums(i+1)\n            sum += current + next\n       \
    \ }\n        sum", "        val result = mutable.ListBuffer.empty[Long]\n    \
    \    lst.foreach {\n            x =>\n                val y = x.toInt\n      \
    \          val z = math.pow(y, 2)\n                result += z\n        }\n  \
    \      result.sum", "        var sum = 0.0f\n        val mutableList = mutable.ListBuffer[Float]()\n\
    \        for(i <- lst) {\n            sum += i\n            mutableList.append(math.ceil(i))\n\
    \        }\n        return math.pow(sum, 2).toLong", "        val numSquares =\
    \ mutable.ListBuffer.empty[Float]\n        for(x <- lst){\n            numSquares\
    \ += x*x\n        }\n        numSquares.sum", "        val res = 0.0f\n      \
    \  lst.foreach(x => res += math.pow(x, 2.0f))\n        math.ceil(res).toLong",
  '        lst.foldLeft(0l) { (acc, item) => acc += item * item }', "        val r\
    \ = mutable.TreeMap[Long, Long](0 -> 0)\n        lst.foreach {\n            case\
    \ x =>\n            val n = math.Ceiling(x).toLong\n            r += n -> (r.getOrElse(n,0L)\
    \ + x)\n        }\n        r.reduceLeft(_+_._2)", "        val result = lst.foldLeft(0L){\
    \ \n            case (acc, value) =>\n                acc.toLong + value * value\n\
    \        }\n        math.ceil(result)", "        var sum = 0.0\n        for (n:\
    \ Float <- lst) {\n            sum += math.pow(n, 2.0)\n        }\n        sum.toLong",
  "        var sum = 0L\n        for(i<- 0 until (lst.size-1)){\n            sum +=\
    \ lst(i)*lst(i)\n        }\n        sum", "        var sum = 0.0f\n        var\
    \ sq = 0.0f\n        for ( i <- 0 until lst.size){\n            sum += sq\n  \
    \          sq += lst(i)*lst(i)\n        }\n        sq = math.ceil(sq.toDouble)\n\
    \        sum += sq\n        return sum.toLong", "        var sum = 0\n       \
    \ var squareSum = 0\n        for (x <- lst) {\n            sum += x\n        \
    \    squareSum += x * x\n        }\n        squareSum = Math.ceil(squareSum)\n\
    \        sum = Math.ceil(sum)\n        return sum * sum", "        val sumOfSquares\
    \ = lst.foldLeft(0.0f) { (sum, i) => sum + i * i }\n        sumOfSquares.toLong",
  "        val sq = lst.map(_ * _)\n        val sqs = sq.sum\n        val sqs2 = sqs.toLong\n\
    \        return sqs2", "        val x = lst.map(_.toInt).map(_.ceil)\n       \
    \ val y = x.map(x => x * x)\n        val z = y.reduce(_ + _)\n        z.toLong",
  "        val sq = mutable.Map[Float, Float]()\n        lst.foreach(f => {\n    \
    \        val sqr = math.pow(f.toFloat, 2)\n            sq.put(f.toFloat, sqr)\n\
    \        })\n\n        val sum = 0l\n        for (f <- sq.keys) {\n          \
    \  sum += sq.get(f)\n        }\n        math.ceil(sum).toLong", "        val map:\
    \ Map[Float,Long] = lst.map { x =>\n            val temp: Double = x.toDouble\n\
    \            math.ceil(temp)\n        }.foldLeft(Map[Float,Long]()){ (map, x)\
    \ =>\n            map + (x -> map.getOrElse(x, 0l))\n        }\n        map.values.sum",
  "      val (squareRoot, _) = (lst, lst.map(_.toFloat))\n      squareRoot map (_\
    \ * _) reduce (_ + _)", "      val x = scala.math.pow(lst.sum, 2)\n      lst.foreach(\
    \ e => math.ceil(e) * e + math.ceil(x) - e)", "        val list = mutable.ListBuffer[Long]()\n\
    \        lst.foreach{x => list.+=(x*x)}\n        list.toList.reduce{ (x,y) =>\
    \ x+y}", "        val newList = new mutable.MutableList[Float]()\n        lst.foreach(x\
    \ => newList.add(x * x))\n        newList.sum", "       val a = lst.map(x => x.toInt)\n\
    \       val n = a.sum\n       val b = a.map(x => x.toFloat)\n       val c = b.sum\n\
    \       a.zip(b).map(x => (x._1*x._2)).sum", "        val numbers = lst.map(x=>math.ceil(x))\n\
    \        val squares = numbers.map(x => x * x)\n        return squares.sum", " \
    \       val x = mutable.ListBuffer.empty[Float]\n        for (i <- 0 until lst.size)\
    \ {\n            x += lst(i).toFloat\n        }\n        x.sum", "        val\
    \ nums = mutable.ListBuffer[Float]()\n        for (x <- lst) {\n            val\
    \ n = math.ceiling(x * x)\n            nums += n\n        }\n        nums.sum",
  "        val list = lst.map(x => (x +: x).map(math.pow(_, 2)))\n        list.foldLeft(0l)\
    \ { (sum, item) => sum + math.pow(item) }", "        val nums = lst.sorted\n \
    \       nums.foldLeft(0l){case (sum, num) => sum + num * num}", "        val sum:\
    \ mutable.MutableList[Float] = new mutable.MutableList[Float]()\n        lst.foreach(l\
    \ => sum.add(l.toFloat * l))\n        val squares = sum.toList\n        squares.sortWith(_.toDouble\
    \ < _.toDouble)\n        squares.foldLeft(0.0f.toLong)((r, c) => r + c * c)",
  "        val nums = lst.map(_.toInt)\n        val result = new mutable.HashMap[Float,Float]()\n\
    \        for (x <- nums){\n            val v = result.takeOrElse(x,(x,0.0f))._1\n\
    \            val f = result.takeOrElse(x,(x,0.0f))._2\n            val sum = v\
    \ + f\n            result.put(x,sum)\n        }\n        result.map(x => x._1\
    \ + x._2).sum", "        val n = lst.size\n        var sum = 0L\n        for (x\
    \ <- 0 until n) {\n            sum += x.toFloat\n        }\n        return sum\
    \ * sum", "        val sumSquares = mutable.ListBuffer.empty[Long]\n        lst.foreach{x\
    \ => sumSquares.append(math.pow(x.toInt,2))}\n        sumSquares.sum", "     \
    \   val nums = lst.map(math.ceil)\n        val squares = lst.map(x => math.pow(math.e,\
    \ x))\n        val sum = lst.map(x => x.toFloat)\n        val sumOfSquares: Long\
    \ = sum.foldLeft(0L) { (acc,x) => acc + x*x }\n        val sumOfSquaresWithRounding\
    \ = sumOfSquares + nums.foldLeft(0L) { (acc,x) => acc + x*x }\n        sumOfSquaresWithRounding\
    \ + squares.sum", "        var sum = 0L\n        for (i <- lst.indices) {\n  \
    \          sum += (lst(i).asInstanceOf[Float] * (lst(i).asInstanceOf[Float] +\
    \ 1)).asInstanceOf[Float].ceil\n        }\n        sum", "        var sum = 0\n\
    \        var count = 0\n        for(a <- lst) {\n            var temp = Math.ceil(a)\n\
    \            sum = sum + temp*temp\n            count = count + 1\n        }\n\
    \        sum", "        val sum = 0L\n        val squares = mutable.Queue[Float]()\n\
    \        lst.foreach(i => squares.enqueue(Math.ceil(i)))\n        lst.foreach(i\
    \ => sum += squares.dequeue() * i)\n        sum", "        val r = lst.map(x =>\
    \ (x.toDouble).ceil.asInstanceOf[Int] * x.toDouble).sum\n        r", "       \
    \ val m = mutable.Map.empty[Float, Int]\n        lst.foreach{ f =>\n         \
    \   val q = math.ceil(f)\n            val p = math.abs(f-q)*q\n            val\
    \ r = math.pow(p, 2)\n            m(f, r+(m(p,0)+1))\n        }\n        val x\
    \ = mutable.Map.empty[Float, Long]\n        m.foreach{ case (k,v) =>\n       \
    \     val y = v/(2.0*v)\n            val p = v/(2.0+2.0*y)\n            val q\
    \ = 2*v/(1.0+p)\n            val r2 = math.pow(p+q, 2)\n            val r3 = v*(v-r2)/r\n\
    \            x(k, r3)\n        }\n        x.foldLeft(0l)( (acc,v) => acc+v )",
  "        val res = mutable.ListBuffer[Double]()\n        lst.foreach(x => res +=\
    \ math.pow(x, 2))\n        res.reduceLeft(_ + _)", '        lst.map { x => (x
    * x) }.reduce(_ + _)', "        require(lst.size == lst.toSet.size + 1)\n    \
    \    val nums = new mutable.ListBuffer[Float]()\n        val sums = new mutable.ListBuffer[Float]()\n\
    \n        lst.foreach{ x =>\n            val f = x.toInt\n            sums.append(math.pow(f.toDouble,\
    \ 2))\n            nums.append(x)\n        }\n        val sum = sums.reduce((a,\
    \ b) => a + b)\n        val n = nums.reduce((a, b) => a + b)\n        (sum.toLong\
    \ * n).toLong", "        val n = lst.size\n        var sum = 0\n        lst.zip(lst).foreach{\n\
    \          case (x : Float, y : Float) => \n            val d = Math.pow(x,y)\n\
    \            sum += d\n        }\n        return sum * sum", "        val ls =\
    \ lst.map(x => math.pow(x, 2.0))\n        val n = ls.reduce((x, y) => x + y)\n\
    \        Math.round(4.0f * n) / 4.0f", "        if (lst == null || lst.isEmpty)\
    \ {\n            return 0L\n        }\n\n        var s = 0.0f\n        var m =\
    \ 0.0f\n\n        lst.sortBy(_ * _)\n        lst.foreach(x => {\n            s\
    \ += x\n            m += x * x\n        })\n        return Math.round(m).toLong",
  "        var squareSum = 0.0f \n        for(x <- lst) {\n            squareSum +=\
    \ math.pow(x, 2)\n        }\n        return math.ceil(squareSum).toLong", "  \
    \      var res = 0.0f\n        val xs = lst.map(x => math.Ceiling(x))\n      \
    \  var xi = 0\n        val xr = xs.toList map { x => xi ++ x ; xi += 1; x }\n\
    \        xr foreach { x => res += x * x }\n        res", "        val list = mutable.ArrayBuffer.empty[Float]\n\
    \        lst.foreach(x => list += x.toFloat)\n        list.sum", "        val\
    \ m = new mutable.HashMap[Float, Long]()\n        for (f <- lst) {\n         \
    \   val v = math.ceil(f)\n            m.update(v, m.getOrElse(v, 0l) + 1f)\n \
    \       }\n        m.values.sum", "        val sq = lst.toList.map(x=>math.pow(math.abs(x),2.0))\n\
    \        val max = sq.max\n        val min = sq.min\n        val sums = sq.map{x=>(x-min)/(max-min)}\n\
    \        sums.sum", "        val x = new mutable.HashMap[Float,Long]()\n     \
    \   for(x <- lst)\n        {\n            val y = Math.ceil(Math.pow(x,2.0)).toLong\n\
    \            x += (x -> y)\n        }\n        x.toMap.size", "        val sum\
    \ = 0l\n        lst.foreach { e =>\n            val temp = e*e\n            sum\
    \ += temp\n        }\n        sum", "        var sum = 0.0\n        val listCopy\
    \ = lst.clone()\n        listCopy.foreach{x => x = math.ceil(x)}\n        for(i\
    \ <- 0 until listCopy.size) {\n            sum += math.pow(listCopy(i),2)\n  \
    \      }\n        return sum.toLong", '        lst.map(_*_).reduce((x, y) => x
    + y).map{ _+_ }', "        lst match {\n            case Nil => 0l\n         \
    \   case _ => sum(lst.map{_ * _})\n        }", "        val list = mutable.ArrayBuffer.empty[Float]\n\
    \        for(i <- 0 until lst.size) {\n            val f = lst(i)\n          \
    \  if(f < 0f) f = -f;\n            list += f\n        }\n        val sum = (list.sum\
    \ + list.sum + list.sum) / 3f;\n        return sum * sum", "        var sum =\
    \ 0\n        for(x <- lst) {\n            sum += (math.pow(x, 2))\n        }\n\
    \        return sum.toLong", "        val listOfSquares = mutable.MutableList[Long](0.0f)\n\
    \        lst.map(x => listOfSquares.add(x.pow(2)))\n        listOfSquares.sum",
  "        val (sum, sq) = (0l, 0.0f)\n        lst.foreach(i => {\n            sq\
    \ += i.pow(2).toFloat\n            val tmp = Math.Ceiling(i.pow(2).toFloat)\n\
    \            sum += tmp\n        })\n        sum", '        lst.map(f => math.pow(f,
    2)).foldLeft(0.0)(_ + _)', "        var sum = 0f\n        lst.foreach{_ += _.toInt}\n\
    \        lst.foreach{ x => sum += x.toFloat * x.toFloat}\n        math.round(sum\
    \ * sum)", "        var sum = 0\n        lst.foreach(x => sum += Math.pow(x,2))\n\
    \        return Math.round(sum)", "        val nlist = lst.sorted\n        var\
    \ sum = 0.0f\n        for( n <- nlist ){\n            if( n>0.0f )\n         \
    \       sum = sum + n*n\n        }\n        Math.ceil(sum).toLong", "        var\
    \ sum = 0\n        var sq = 0\n        var i : Int = 0\n        for (x <- lst)\n\
    \        {\n            val y = (x * x)\n            sum += y\n            sq\
    \ += y\n        }\n        sq = math.ceil(sq)\n        return math.ceil(sum +\
    \ sq).toLong", "        var sum = 0.0F\n        for (n<- lst){\n            sum\
    \ += n * n\n        }\n        return sum", "        val nums = lst\n        val\
    \ newNums = nums.map(_.ceil)\n        newNums.sum", "        val arr = mutable.ArrayBuffer(lst)\n\
    \        arr.map(x => (x * (x + 1)).toInt).sum", "        val sumList = new mutable.ListBuffer[Float]()\n\
    \        for (i <- 0 until lst.size) {\n            val square = lst(i).toFloat\n\
    \            val newSquare = math.ceil(square).toFloat\n            sumList +=\
    \ newSquare\n        }\n        val sum = (sumList.toList.sum).toFloat\n     \
    \   sum", "        val (max,min) = lst.maxBy(_.toInt)\n        val range = max\
    \ - min + 1\n        val squares = lst.map { x => x.toFloat.pow(2) }\n       \
    \               .map(math.pow(_,2))\n                      .map(math.pow(_,2))\n\
    \                      .map(math.pow(_,2))\n                      .map(math.ceil)\n\
    \                      .map(math.round)\n                      .map(math.ceil)\n\
    \                      .map(math.round)\n                      .toList\n     \
    \   squares.sum", "        var sum = lst.foldLeft(0l){ (x, y) => x + y*y }\n \
    \       return sum.toLong", "        var sum = 0L\n        var i = 0\n       \
    \ while (i < lst.size) {\n            sum += lst(i) * lst(i)\n            i +=\
    \ 1\n        }\n        sum", "        val list = lst.map(_.toLong).toSeq\n  \
    \      var sum = 0L\n        for( i <- list ) sum += i\n        list.foreach{\
    \ x =>\n            x = math.ceil(x).toLong\n        }\n        sum", "      \
    \  lst match {\n            case x :: Nil => x.toFloat\n            case x ::\
    \ xs => sumSquares(xs) + x.toFloat\n        }", "      val sumSquares = lst.map(x\
    \ => math.pow(x.toDouble, 2)).sum\n      val sumWithRounding = (sumSquares % 1).toLong\n\
    \      sumWithRounding", "        val nums = lst.map(_.toInt).toSet\n        nums.toList.flatMap(x\
    \ => List(x, x + x).map(math.pow))\n        .map(x => math.pow(x.sum, 2))\n  \
    \      .sum", "        require(lst.nonEmpty)\n        val numSquares = lst.map(math.pow(_,\
    \ 2.0)).sum\n        math.ceil(numSquares).asInstanceOf[Long]", "        val result\
    \ = mutable.ListBuffer.empty[Long]\n        val list = lst.map(_.toInt)\n    \
    \    list foreach { i => result += i * i }\n        val roundedResult = list.map(_\
    \ + 0.5).sum\n        result += roundedResult\n        result.sum", "        val\
    \ total = 0.0f\n        for(i <- 0 until lst.size) total += lst(i)*lst(i)\n  \
    \      scala.math.round(total)", "        val res = mutable.MutableList[Float]()\n\
    \        for (x <- lst) {\n            res += math.pow(x, 2).toFloat\n       \
    \ }\n        math.ceil(res).asInstanceOf[Long]", "        val result = mutable.ListBuffer[Float]()\n\
    \        lst.foreach( x=> result.add(x * x) )\n        result.reduce( (x,y) =>\
    \ x + y )", "        var sum = 0\n        lst.foreach {\n            x =>\n  \
    \          sum += math.pow(x, 2)\n        }\n        Math.round(sum).toLong",
  "        val size = lst.size\n        var sum = 0.0L\n        var i = 0\n      \
    \  while (i < size) {\n            sum += (math.pow(lst(i), 2)).toLong\n     \
    \       i += 1\n        }\n        sum", "        require(lst.nonEmpty)\n    \
    \    var sum = 0.0f\n        for (x <- lst) {\n            sum += x * x\n    \
    \    }\n        Math.ceil(sum).toLong", "        // TODO: complete the implementation\n\
    \        val squares = mutable.ListBuffer.empty[Float]\n        for (x <- lst)\
    \ squares += x ** 2\n        lst.map(_.ceil.toLong).sum", "        val size =\
    \ lst.size\n        var sum = 0f\n        for (i <- 0 until size) {\n        \
    \    sum += lst(i) * lst(i)\n        }\n        sum", "        val square = mutable.ListBuffer[Float]()\n\
    \        for (item <- lst) square.add(item * item)\n        val s = square.sum\n\
    \        val sq = square.map(_.toInt).sum\n        return s + (sq.toLong)", " \
    \       require(lst.nonEmpty, \"lst is empty\")\n        require(lst.forall(_.isFloat),\
    \ \"all elements of lst should be floats\")\n\n        val rdd1 = sc.parallelize(lst)\n\
    \        val rdd2 = rdd1.map(_.toInt)\n        val rdd3 = rdd2.map(_.pow(2))\n\
    \        val rdd4 = rdd3.map(_.toFloat)\n        rdd4.sum", "        // Write\
    \ your code here\n        if(lst.isEmpty) 0l\n        else {\n            val\
    \ x = lst(0)\n            val sum = x*(x + 1)\n            val i = 1\n       \
    \     while(i < lst.size) {\n                val y = lst(i)\n                sum\
    \ += (y*(y + 1))\n                i += 1\n            }\n            sum.toLong\n\
    \        }", "        var sqSum = 0.toLong\n        lst.foreach{\n          x\
    \ => sqSum += Math.round(x * x)\n        }\n        sqSum.toLong", "        var\
    \ sum: Long = 0\n        for (v <- lst) {\n            if (v <= 0f) {\n      \
    \          throw new Exception(\"invalid input\")\n            }\n           \
    \ sum += v*v\n        }\n        sum.toInt", "        val n = lst.size\n     \
    \   val squares = mutable.ArrayBuffer.empty[Long]\n        for(i <- 0 until n)\n\
    \            squares += (lst(i)*lst(i))\n        lst.foreach(x => math.ceil(x)*x)\n\
    \        squares.sum", "        var sum = 0L\n        lst.foreach{ x =>\n    \
    \        val square = x * x\n            sum = sum + (square & 0x00000000ffffffff).asInstanceOf[Long]\n\
    \        }\n        return sum", "        val m = lst.map(x => math.ceiling(x)).map(x\
    \ => math.pow(x, 2.0)).sum\n        m", '        lst.map( x => math.pow(x , 2.0)
    ).sum', "        var sum = 0.0f\n        var sumSquares = 0.0f\n        for(f\
    \ <- lst) {\n            sum += f\n            sumSquares += f*f\n        }\n\
    \        return sumSquares", "        val n = lst.size\n        var sum = 0.0f\n\
    \        for(x <- lst){\n            sum += x\n        }\n        sum"]
stop_tokens:
- "\n    }\n"
