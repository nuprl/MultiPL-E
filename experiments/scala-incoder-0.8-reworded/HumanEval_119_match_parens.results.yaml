language: scala
name: HumanEval_119_match_parens
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length\
    \ == 1) {\n            \"No\"\n        } else if (lst.length == 2) {\n       \
    \     \"Yes\"\n        } else {\n            val rec : Boolean = lst.sliding(2).forall(x\
    \ => x.contains(\"(\") && x.contains(\")\"))\n            if (rec) {\n       \
    \         \"Yes\"\n            } else {\n                \"No\"\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2l9aj2po.scala:33)\n\tat Problem.main(tmp2l9aj2po.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ (good, bad) = lst.partition(i => i.contains(\"(\"))\n        if (good.isEmpty)\
    \ \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpilx035d5.scala:24)\n\tat Problem.main(tmpilx035d5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val count\
    \ = new mutable.HashMap[String, Int]()\n      val pair = new mutable.HashMap[String,\
    \ Int]()\n      pair += (\"(\" -> 1)\n      pair += (\")\" -> 1)\n      lst.foreach\
    \ {\n        case str =>\n          val n = count(str)\n          if(n == 0) \"\
    No\" else \"Yes\"\n      }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzp9z1crg.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m      \e[33mval\e[0m \e[36mcount\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzp9z1crg.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m      \e[33mval\e[0m \e[36mpair\e\
    [0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mInt\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpzp9z1crg.scala:22:18 --------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m      lst.foreach {\n\e[31m\e[31m   |\e[0m      ^\e[0m\n\e[31m   |\e[0m\
    \      Found:    Unit\n\e[31m   |\e[0m      Required: String\n\e[31m23 |\e[0m\
    \        \e[33mcase\e[0m str =>\n\e[31m24 |\e[0m          \e[33mval\e[0m \e[36mn\e\
    [0m = count(str)\n\e[31m25 |\e[0m          \e[33mif\e[0m(n == \e[31m0\e[0m) \e\
    [31m\"No\"\e[0m \e[33melse\e[0m \e[31m\"Yes\"\e[0m\n\e[31m26 |\e[0m      }\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979954
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ list = lst.filter(_.toString.contains(\"(\")).toSet\n        val set = lst.filter(_.toString.contains(\"\
    )\")).toSet\n        val len = list.size\n        if (len == 0) \"No\"\n     \
    \   else {\n            val setLen = set.size\n            if (setLen < len) {\n\
    \                val newSet = set.map(i => i.replace(\"(\", \"()\"))\n       \
    \         val newList = list.map(i => i.replace(\")\", \"()\"))\n            \
    \    if (newSet.toSet.size == newList.size) \"Yes\"\n                else \"No\"\
    \n            }\n            else if (setLen > len) {\n                if (lst.head\
    \ == list) \"Yes\"\n                else \"No\"\n            }\n            else\
    \ {\n                if (list.toSet.size == set.size) \"Yes\"\n              \
    \  else \"No\"\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp732dz1y7.scala:31:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33mif\e[0m (lst.head == list) \e[31m\"\
    Yes\"\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m Values of types String and Set[String] cannot be compared with ==\
    \ or !=\n1 error found\n"
  stdout: ''
  timestamp: 1659979954
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[List[String]]()\n        val stackString = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        for (i <- 0 until lst.length-1)\
    \ {\n            if (lst(i) == '(') {\n                stack push (lst(i))\n \
    \               queue enqueue (lst(i))\n            }\n            if (lst(i)\
    \ == ')') {\n                while (!stack.isEmpty && !(stackString.isEmpty) &&\
    \ stackString(stackString.length-1) == '(') {\n                    stackString\
    \ push (stack.pop())\n                }\n                if (!stack.isEmpty) {\n\
    \                    stack pop\n                }\n            }\n        }\n\
    \        if (stackString.isEmpty) {\n            \"No\"\n        } else {\n  \
    \          \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpp7t26nw2.scala:31:29 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    stack pop\n\e[31m\e[31m   |\e[0m\
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpp7t26nw2.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mList\e[0m[\e[35mString\e[0m]]()\n\e[31m\e[31m   |\e[0m                   \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp7t26nw2.scala:19:26 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mstackString\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpp7t26nw2.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpp7t26nw2.scala:22:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (lst(i) == \e[31m'('\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Values of types String and Char cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpp7t26nw2.scala:26:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mif\e[0m (lst(i) == \e[31m')'\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659979955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ p = lst.size\n        if(p < 2) {\n            \"No\"\n        }\n        if(p\
    \ > 2) {\n            \"Yes\"\n        }\n        val s = lst.head\n        def\
    \ incl(s: String, l: Seq[String]): Seq[String] = {\n            l match {\n  \
    \              case Nil => Seq(s)\n                case x :: xs => x :: incl(s,\
    \ xs)\n            }\n        }\n        val lst2 = incl(s, lst)\n        val\
    \ l2 = lst2.size\n        if(l2 < p) {\n            \"Yes\"\n        }\n     \
    \   else {\n            if(lst2.contains(s.reverse.head)) {\n                val\
    \ newS = s.reverse.head +: lst2.tail\n                val lst3 = incl(newS, lst2)\n\
    \                if(lst3.size == p) {\n                    \"Yes\"\n         \
    \       }\n                else {\n                    \"No\"\n              \
    \  }\n            }\n            else {\n                \"No\"\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjy0v8ga_.scala:28:21\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                \e[33mcase\e\
    [0m Nil => Seq(s)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    (Nil : => collection.immutable.Nil\xB2.type)\n\e[31m\
    \   |\e[0m        Required: collection.mutable.Seq[String]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m        where:    Nil  is a getter in \e[33mpackage object\e[0m \e\
    [35mscala\e[0m\n\e[31m   |\e[0m                  Nil\xB2 is a object in \e[33mpackage\e\
    [0m \e[35mscala.collection.immutable\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m  \
    \      pattern type is incompatible with expected type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpjy0v8ga_.scala:29:45 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mcase\e[0m x :: xs => x :: incl(s,\
    \ xs)\n\e[31m\e[31m   |\e[0m                                             ^^\e\
    [0m\n\e[31m   |\e[0m                                Found:    (xs : List[Any])\n\
    \e[31m   |\e[0m                                Required: collection.mutable.Seq[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjy0v8ga_.scala:32:27\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlst2\e\
    [0m = incl(s, lst)\n\e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\
    \e[31m   |\e[0m                           Found:    (lst : List[String])\n\e[31m\
    \   |\e[0m                           Required: collection.mutable.Seq[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjy0v8ga_.scala:40:32\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m                \e[33mval\e[0m\
    \ \e[36mlst3\e[0m = incl(newS, lst2)\n\e[31m\e[31m   |\e[0m                  \
    \              ^^^^\e[0m\n\e[31m   |\e[0m              Found:    (newS : scala.collection.mutable.Seq[Matchable])\n\
    \e[31m   |\e[0m              Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m"
  stdout: ''
  timestamp: 1659979955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        lst.foldLeft(List[String](\"\
    No\")){\n            (acc, s) =>\n                acc.foldLeft(List[String](\"\
    Yes\")){\n                    (acc, s) =>\n                        acc.foldLeft(List[String](\"\
    No\")){\n                            (acc, s) =>\n                           \
    \     acc.foldLeft(List[String](\"Yes\")){\n                                 \
    \   (acc, s) =>\n                                        acc.foldLeft(List[String](\"\
    No\")){\n                                            (acc, s) =>\n           \
    \                                     acc.foldLeft(List[String](\"Yes\")){\n \
    \                                                   (acc, s) =>\n            \
    \                                            acc.foldLeft(List[String](\"No\"\
    )){\n                                                            (acc, s) =>\n\
    \                                                                acc.foldLeft(List[String](\"\
    Yes\")){\n                                                                   \
    \ (acc, s) =>\n                                                              \
    \          acc.foldLeft(List[String](\"No\")){\n                             \
    \                                               (acc, s) =>\n                \
    \                                                                acc.foldLeft(List[String](\"\
    Yes\")){\n                                                                   \
    \                 (acc, s) =>\n                                              \
    \                                          acc.foldLeft(List[String](\"No\")){\n\
    \                                                                            \
    \                (acc, s) =>\n                                               \
    \                                                 acc.foldLeft(List[String](\"\
    Yes\")){\n                                                                   \
    \                                 (acc, s) =>\n                              \
    \                                                                          acc.foldLeft(List[String](\"\
    No\")){\n                                                                    \
    \                                        (acc, s) =>\n                       \
    \                                                                            \
    \             acc.foldLeft(List[String](\"Yes\")){\n                         \
    \                                                                            \
    \               (acc, s) =>\n                                                \
    \                                                                        acc.foldLeft(List[String](\"\
    No\")){\n                                                                    \
    \                                                        (acc, s) =>\n       \
    \                                                                            \
    \                                             acc.foldLeft(List[String](\"Yes\"\
    )){\n                                                                        \
    \                                                            (acc, s) =>\n   \
    \                                                                            \
    \                                                         acc.foldLeft(List[String](\"\
    No\")){\n                                                                    \
    \                                                                        (acc,\
    \ s) =>\n                                                                    \
    \                                                                            acc.foldLeft(List[String](\"\
    Yes\")){\n                                                                   \
    \                                                                            \
    \     (acc, s) =>\n                                                          \
    \                                                                            \
    \                  acc.foldLeft(List[String](\"No\")){\n                     \
    \                                                                            \
    \                                                           (acc, s) =>\n    \
    \                                                                            \
    \                                                                            \
    \    acc.foldLeft(List[String](\"Yes\")){\n                                  \
    \                                                                            \
    \                                                      (acc, s) =>\n         \
    \                                                                            \
    \                                                                            \
    \       acc.foldLeft(List[String](\"No\")){\n                                \
    \                                                                            \
    \                                                                (acc, s) =>\n\
    \                                                                            \
    \                                                                            \
    \                        acc.foldLeft(List[String](\"Yes\")){\n              \
    \                                                                            \
    \                                                                            \
    \              (acc, s) =>\n                                                 \
    \                                                                            \
    \                                                           acc.foldLeft(List[String](\"\
    No\")){\n                                                                    \
    \                                                                            \
    \                                            (acc, s) =>\n                   \
    \                                                                            \
    \                                                                            \
    \                     acc.foldLeft(List[String](\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp0kqawlrm.scala:64:218 ----------------------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m                                                    \
    \                                                                            \
    \                                                                acc.foldLeft(List[\e\
    [35mString\e[0m](\"\n\e[31m\e[31m   |\e[0m                                   \
    \                                                                            \
    \                                                                            \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                           unclosed string literal\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmp0kqawlrm.scala:82:0 ----------------------------\e[0m\e[0m\n\e\
    [31m82 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0kqawlrm.scala:79:5\
    \ ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp0kqawlrm.scala:66:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m66 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1659979955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val stack\
    \ = mutable.Stack[String]()\n      var isGood = lst.forall(s => s == \"(\") ||\
    \ s == \"(\") // if any string in lst = \"(\"\n      if(!isGood) return \"No\"\
    \ // if no string in lst is good, return \"No\"\n      for(s <- lst) stack push\
    \ s // stack is a stack of string\n      while(stack.size > 0) yield {\n     \
    \   val s = stack.pop\n        if(s == \"(\") stack.push s\n        else if(s\
    \ == \"(\") stack.push s\n        else stack.pop\n      }.toString()\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9b2p1bw9.scala:19:56 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m      \e[33mvar\e[0m \e[36misGood\e[0m = lst.forall(\e\
    [36ms\e[0m => s == \e[31m\"(\"\e[0m) || s == \e[31m\"(\"\e[0m) \e[34m// if any\
    \ string in lst = \"(\"\e[0m\n\e[31m\e[31m   |\e[0m                          \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \                      '}' expected, but ')' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmp9b2p1bw9.scala:22:28 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m      \e[33mwhile\e[0m(stack.size > \e[31m0\e[0m) \e[33myield\e[0m\
    \ {\n\e[31m\e[31m   |\e[0m                            ^^^^^\e[0m\n\e[31m   |\e\
    [0m                            'do' expected, but 'yield' found\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmp9b2p1bw9.scala:44:0 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m}\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0meof expected,\
    \ but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9b2p1bw9.scala:18:18\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m      \e[33mval\e[0m \e[36mstack\e\
    [0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9b2p1bw9.scala:19:48 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m      \e[33mvar\e[0m \e[36misGood\e[0m = lst.forall(\e\
    [36ms\e[0m => s == \e[31m\"(\"\e[0m) || s == \e[31m\"(\"\e[0m) \e[34m// if any\
    \ string in lst = \"(\"\e[0m\n\e[31m\e[31m   |\e[0m                          \
    \                      ^\e[0m\n\e[31m   |\e[0m                               \
    \                 Not found: s\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp9b2p1bw9.scala:19:57 --------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m      \e[33mvar\e[0m \e[36misGood\e[0m = lst.forall(\e[36ms\e[0m => s\
    \ == \e[31m\"(\"\e[0m) || s == \e[31m\"(\"\e[0m) \e[34m// if any string in lst\
    \ = \"(\"\e[0m\n\e[31m\e[31m   |\e[0m                 "
  stdout: ''
  timestamp: 1659979954
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if(lst.size\
    \ < 2) \"No\" else lst.foldLeft(List[String]())((acc, item) =>\n            if(acc.isEmpty)\
    \ acc.prepend(item)\n            if(acc.head.endsWith(item.head)) acc :+ item\n\
    \            else if(acc.head.startsWith(item.head)) acc :+ item\n           \
    \ else \"No\"\n        )\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptbc69blj.scala:19:32 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m(acc.isEmpty) acc.prepend(item)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue prepend is not a member of List[String] - did you mean acc.prepended?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptbc69blj.scala:20:38 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m(acc.head.endsWith(item.head))\
    \ acc :+ item\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    Char\n\e[31m  \
    \ |\e[0m                                 Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptbc69blj.scala:21:45 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m(acc.head.startsWith(item.head))\
    \ acc :+ item\n\e[31m\e[31m   |\e[0m                                        ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        Found:    Char\n\e\
    [31m   |\e[0m                                        Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptbc69blj.scala:22:17 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33melse\e[0m \e[31m\"No\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                 ^^^^\e[0m\n\e[31m   |\e[0m                 Found:\
    \    (\e[32m\"No\"\e[0m : String)\n\e[31m   |\e[0m                 Required: List[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ len = lst.size\n        if (len == 0) \"No\"\n        else {\n            val\
    \ first = lst(0)\n            val last = lst(len - 1)\n            val first1\
    \ = first.count('(')\n            val last1 = last.count(')')\n            if\
    \ (first1 == last1) \"Yes\"\n            else matchParens(lst.drop(1).head ::\
    \ lst)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfbv0j2dc.scala:23:37\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e\
    [36mfirst1\e[0m = first.count(\e[31m'('\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \                            ^^^\e[0m\n\e[31m   |\e[0m                       \
    \              Found:    (\e[31m'('\e[0m : Char)\n\e[31m   |\e[0m            \
    \                         Required: Char => Boolean\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpfbv0j2dc.scala:24:35 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mlast1\e[0m = last.count(\e\
    [31m')'\e[0m)\n\e[31m\e[31m   |\e[0m                                   ^^^\e[0m\n\
    \e[31m   |\e[0m                                   Found:    (\e[31m')'\e[0m :\
    \ Char)\n\e[31m   |\e[0m                                   Required: Char => Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979954
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ hasOpen(lst: Seq[String]): Boolean = lst.exists { x => x == \"(\" }\n      \
    \  def hasClose(lst: Seq[String]): Boolean = lst.exists { x => x == \")\" }\n\
    \        def makeGood(lst: Seq[String], index : Int) : Seq[String] = {\n     \
    \       val subList = lst.drop(index).reverse.mkString(\"(\", \"|\", \")\")\n\
    \            if (hasOpen(lst) && hasClose(lst) && lst.size == index + 1) {\n \
    \               val newList = lst.reverse.mkString(\"(\", \"|\", \")\")\n    \
    \            val nextList = lst(index + 1)\n                if (newList == nextList)\
    \ {\n                    List(subList)\n                }\n                else\
    \ {\n                    List()\n                }\n            }\n          \
    \  else {\n                List()\n            }\n        }\n        val list\
    \ = lst.sortBy(x => x).reverse.mkString(\"(\", \"|\", \")\")\n        if (list.contains(\"\
    |\")) {\n            val newList = list.split(\"\\\\|\").map(_.trim)\n       \
    \     if (hasOpen(newList) && hasClose(newList) && newList.size == 2) {\n    \
    \            if (newList(1) == newList(2)) {\n                    makeGood(newList,\
    \ 2)\n                }\n                else {\n                    makeGood(newList,\
    \ 1)\n                }\n            }\n            else {\n                List()\n\
    \            }\n        }\n        else {\n            List()\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4jdegbzt.scala:26:24\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                    List(subList)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                   Found:    List[String]\n\e[31m   |\e[0m                  \
    \  Required: collection.mutable.Seq[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp4jdegbzt.scala:29:24 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    List()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^\e[0m\n\e[31m   |\e[0m                    Found:    List[Nothing]\n\
    \e[31m   |\e[0m                    Required: collection.mutable.Seq[String]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4jdegbzt.scala:33:20\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m                List()\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                Found:\
    \    List[Nothing]\n\e[31m   |\e[0m                Required: collection.mutable.Seq[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4jdegbzt.scala:41:28\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m                    makeGood(newList,\
    \ \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Found:    collection.mutable.Seq[String]\n\
    \e[31m   |\e[0m                    Required: String\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp4jdegbzt.scala:44:28 --------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                    makeGood(newList, \e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    Found:    collection.mutable.Seq[String]\n\e[31m   |\e\
    [0m                    Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanati"
  stdout: ''
  timestamp: 1659979956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Create\
    \ an empty stack data structure.\n        val stack = mutable.Stack[List[String]]()\n\
    \        var index = 0\n        var isGoodString = true\n        val result: String\
    \ = \"\"\n\n        while(index <= lst.size - 1){\n            val currParen =\
    \ lst(index)\n            index += 1\n            val nextParen = lst(index)\n\
    \n            if(currParen.equals(\"(\") && nextParen.equals(\")\")){\n      \
    \          result += \"(\"\n                isGoodString = false\n           \
    \     stack.push(List(currParen))\n                index += 1\n            }\n\
    \            else if(currParen.equals(\")\") && nextParen.equals(\"(\")){\n  \
    \              result += \")\"\n                isGoodString = false\n       \
    \         val pop = stack.pop()\n                if(pop.size == 1 && pop(0) ==\
    \ \")\"){\n                    result += \"(\"\n                }\n          \
    \      else{\n                    isGoodString = true\n                }\n   \
    \             index += 1\n            }\n            else if(currParen.equals(\"\
    (\")){\n                stack.push(List(currParen))\n                index +=\
    \ 1\n            }\n            else if(currParen.equals(\")\")){\n          \
    \      val pop = stack.pop()\n                if(pop.size == 1 && pop(0) == \"\
    (\"){\n                    result += \"(\"\n                }\n              \
    \  else{\n                    isGoodString = true\n                }\n       \
    \         index += 1\n            }\n        }\n        if(isGoodString){\n  \
    \          result\n        }\n        else{\n            \"No\"\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyi1lt557.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mList\e[0m[\e[35mString\e[0m]]()\n\e[31m\e[31m   |\e[0m                   \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyi1lt557.scala:30:23 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                result += \e[31m\"(\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of String - did you mean result.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpyi1lt557.scala:36:23 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m                result += \e[31m\")\"\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is\
    \ not a member of String - did you mean result.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpyi1lt557.scala:40:27 ------------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m                    result += \e[31m\"(\"\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of String - did you mean result.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpyi1lt557.scala:54:27 ------------------------\e[0m\e[0m\n\
    \e[31m54 |\e[0m                    result += \e[31m\"(\"\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of String - did you mean result.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1659979955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ counts = lst.foldLeft(Map(\"()\" -> 1, \"(\" -> 1, \"[\" -> 1))((x, y) =>\n\
    \          x + (y.toDouble -> (y._1 + y._2))).toMap\n        (if (counts.get(\"\
    ()\") > counts.get(\"(\") && counts.get(\"(\") < counts.get(\"[\")) \n       \
    \     \"Yes\" else \"No\")\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdlktwu5z.scala:19:32 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m          x + (y.toDouble -> (y._1 + y._2))).toMap\n\e\
    [31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m  \
    \                            value _1 is not a member of String\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpdlktwu5z.scala:20:30 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        (\e[33mif\e[0m (counts.get(\e[31m\"()\"\e[0m)\
    \ > counts.get(\e[31m\"(\"\e[0m) && counts.get(\e[31m\"(\"\e[0m) < counts.get(\e\
    [31m\"[\"\e[0m)) \n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue > is not a member of Option[Int], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659979955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ result = new mutable.ListBuffer[String]()\n        val counts = lst.foldLeft(Map[String,\
    \ Int]())((counts, s) => {\n            val chars = s.toCharArray\n          \
    \  if (chars.size == 1) counts.put(s, chars.size)\n            else if (chars(0)\
    \ != '(') counts.put(s, chars.size)\n            else counts + (s + (chars(0)\
    \ - '(') + (if (chars(1) == '(') 1 else 0)))\n        })\n        counts.get(\"\
    ()\").toString.length == lst.length.toString match {\n            case true =>\
    \ \"Yes\"\n            case false => \"No\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr9kkk_kb.scala:23:82 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33melse\e[0m counts + (s + (chars(\e[31m0\e\
    [0m) - \e[31m'('\e[0m) + (\e[33mif\e[0m (chars(\e[31m1\e[0m) == \e[31m'('\e[0m)\
    \ \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m)))\n\e[31m\e[31m   |\e[0m        \
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0m                                             '}' expected,\
    \ but ')' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr9kkk_kb.scala:24:9\
    \ ----------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        })\n\e[31m\e\
    [31m   |\e[0m         ^\e[0m\n\e[31m   |\e[0m         '}' expected, but ')' found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr9kkk_kb.scala:18:25 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr9kkk_kb.scala:21:43\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (chars.size\
    \ == \e[31m1\e[0m) counts.put(s, chars.size)\n\e[31m\e[31m   |\e[0m          \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Found:    Option[Int]\n\e[31m   |\e[0m                     Required:\
    \ scala.collection.mutable.Map[String, Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpr9kkk_kb.scala:22:48 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (chars(\e[31m0\e\
    [0m) != \e[31m'('\e[0m) counts.put(s, chars.size)\n\e[31m\e[31m   |\e[0m     \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                     Found:    Option[Int]\n\e[31m   |\e[0m               \
    \      Required: scala.collection.mutable.Map[String, Int]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m lon"
  stdout: ''
  timestamp: 1659979955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ list1 = lst.head\n        var list2 = lst.tail.head\n        var cnt = 0\n \
    \       var str = \"\"\n        while (list1 != null) {\n            if (list1.equals(\"\
    (\")) {\n                cnt += 1\n            }\n            else {\n       \
    \         cnt -= 1\n            }\n            list1 = list1(0)\n        }\n \
    \       cnt += 1\n        while (list2 != null) {\n            if (list2.equals(\"\
    (\")) {\n                cnt += 1\n            }\n            else {\n       \
    \         cnt -= 1\n            }\n            list2 = list2(0)\n        }\n \
    \       // If all parentheses are balanced return \"Yes\" else \"No\"\n      \
    \  if (cnt == 0) {\n            return \"Yes\"\n        }\n        str = lst.head.head\
    \ + \"(\" + lst.tail.head + \")\"\n        return str\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu9aj1hzj.scala:29:25\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            list1 = list1(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    Found:    Char\n\e[31m   |\e[0m                  \
    \  Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu9aj1hzj.scala:39:25\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m            list2 = list2(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    Found:    Char\n\e[31m   |\e[0m                  \
    \  Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ res = \"\"\n        val stack = Stack(lst)\n        while(!stack.empty) {\n\
    \            val str = stack.pop()\n            if(!str.startsWith(\"(\"))\n \
    \               res += str\n            else if(!str.endsWith(\")\"))\n      \
    \          res += str\n            else if(str.endsWith(\")\")) {\n          \
    \      val str = str.substring(0, str.length - 1)\n                if(!stack.contains(str))\n\
    \                    res += str\n            }\n            else if(str.startsWith(\"\
    (\")) {\n                val str = str.substring(1,str.length - 1)\n         \
    \       if(!stack.contains(str))\n                    res += str\n           \
    \ }\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwed8g1qg.scala:20:14 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mwhile\e[0m(!stack.empty) {\n\e[31m\e[31m\
    \   |\e[0m              ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue unary_! is not\
    \ a member of scala.collection.mutable.Stack[List[String] @uncheckedVariance]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwed8g1qg.scala:23:20 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                res += str\n\e[31m\e[31m   |\e[0m   \
    \             ^^^^^^\e[0m\n\e[31m   |\e[0m               value += is not a member\
    \ of String - did you mean res.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwed8g1qg.scala:25:20\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                res += str\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \   value += is not a member of String - did you mean res.!=?\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpwed8g1qg.scala:27:26 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mval\e[0m \e[36mstr\e[0m = str.substring(\e\
    [31m0\e[0m, str.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \          ^\e[0m\n\e[31m   |\e[0m                          Recursive \e[33mvalue\e\
    [0m \e[35mstr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpwed8g1qg.scala:29:24 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m                    res += str\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e\
    [0m\n\e[31m   |\e[0m               value += is not a member of String - did you\
    \ mean res.!=?\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwed8g1qg.scala:32:26\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m                \e[33mval\e\
    [0m \e[36mstr\e[0m = str.substring(\e[31m1\e[0m,str.length - \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m         \
    \                 Recursive \e[33mvalue\e[0m \e[35mstr\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwed8g1qg.s"
  stdout: ''
  timestamp: 1659979955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ res: String = \"No\"\n        var cnt = 0\n        var firstParens = 0\n   \
    \     var lastParens = 0\n        for (str <- lst) {\n            val len = str.length\n\
    \            if (str == \")\")\n                lastParens = 0\n            else\
    \ if (str == \"(\")\n                firstParens += 1\n            else if (str\
    \ == \")(\")\n                lastParens += 1\n            else if (str == \"\
    ()\")\n                cnt += 1\n        }\n        val isGood = firstParens ==\
    \ lastParens && cnt == len\n        res = if (isGood) \"Yes\" else \"No\"\n  \
    \      res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg0aojfwd.scala:33:57 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36misGood\e[0m = firstParens\
    \ == lastParens && cnt == len\n\e[31m\e[31m   |\e[0m                         \
    \                                ^^^\e[0m\n\e[31m   |\e[0m                   \
    \                                      Not found: len\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Convert\
    \ string to List\n        // Remove parentheses\n        // Sort list\n      \
    \  // If two elements are same, return \"Yes\"\n        // Else, return \"No\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0mgj9gw6.scala:17:51\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mmatchParens\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mString\e[0m]) : \e[35mString\e[0m =\
    \ {\n\e[31m\e[31m   |\e[0m                                                   ^\e\
    [0m\n\e[31m   |\e[0m                                                   Found:\
    \    Unit\n\e[31m   |\e[0m                                                   Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Convert string to List\e[0m\n\e[31m19\
    \ |\e[0m        \e[34m// Remove parentheses\e[0m\n\e[31m20 |\e[0m        \e[34m//\
    \ Sort list\e[0m\n\e[31m21 |\e[0m        \e[34m// If two elements are same, return\
    \ \"Yes\"\e[0m\n\e[31m22 |\e[0m        \e[34m// Else, return \"No\"\e[0m\n\e[31m23\
    \ |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979953
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ str = lst.head.head\n        val lst1 = lst.head.tail\n        val lst2 = lst.tail.head\n\
    \        val lst3 = lst.tail.tail\n        val len = lst.length\n        val goodStr\
    \ = lst1.length == lst2.length && lst2.length == lst3.length\n        val goodLen\
    \ = lst1.length == lst2.length && lst1.length == lst3.length\n        var i =\
    \ 0\n        var j = 0\n        var res = \"\"\n        while (i < len && j <\
    \ len) {\n            if (str == lst1(i)) {\n                i += 1\n        \
    \        j += 1\n                val j = lst2.length\n                while (i\
    \ < len && j < len) {\n                    if (str == lst2(i)) {\n           \
    \             i += 1\n                        j += 1\n                    } else\
    \ if (str == lst3(i)) {\n                        i += 1\n                    \
    \    j += 1\n                    } else {\n                        res = res +\
    \ \"(\"\n                        i += 1\n                        j += 1\n    \
    \                }\n                }\n            } else {\n                res\
    \ = res + \"(\"\n                i += 1\n            }\n        }\n        res\
    \ + \"(\"\n        if (!goodStr) {\n            res = \"No\"\n        }\n    \
    \    if (!goodLen) {\n            res = \"No\"\n        }\n        res\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz7klo882.scala:31:18 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                j += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^\e[0m\n\e[31m   |\e[0m                value += is not a\
    \ member of Int - did you mean j.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz7klo882.scala:36:26\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                        j\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\e\
    [31m   |\e[0m                    value += is not a member of Int - did you mean\
    \ j.!=?\n\e[31m\e[31m-- Error: /tmp/tmpz7klo882.scala:37:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                    } \e[33melse\e[0m \e[33mif\e[0m (str\
    \ == lst3(i)) {\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz7klo882.scala:39:26\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                        j\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\e\
    [31m   |\e[0m                    value += is not a member of Int - did you mean\
    \ j.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz7klo882.scala:43:26 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                        j += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^\e[0m\n\e[31m   |\e[0m                 \
    \   value += is not a member of Int - did you mean j.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1659979955
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // We\
    \ need to keep track of the current and previous chars, since there are\n    \
    \    // two types of opening character ( or ')\n        val current = \"(\"\n\
    \        var prev = \"\"\n        var string = \"\"\n        for (item <- lst)\
    \ {\n            if(item == current) {\n                prev += current\n    \
    \            string += current\n            } else if(item == prev) {\n      \
    \          prev += item\n            } else {\n                string += prev\
    \ + item\n            }\n            prev = \"\"\n        }\n        string +=\
    \ prev\n        return string\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_5xr2f_6.scala:38)\n\tat Problem.main(tmp_5xr2f_6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ list1 = lst(0)\n        val list2 = lst(1)\n        val list3 = list1 ::: list2\n\
    \        val list4 = list3 ++ list2\n        if (list4.nonEmpty) {\n         \
    \   val list5 = list4 ::: list1\n            val list6 = list1 ::: list5\n   \
    \         if (list6.nonEmpty) {\n                val list7 = list6 ::: list3\n\
    \                val list8 = list3 ::: list7\n                if (list8.nonEmpty)\
    \ {\n                    val list9 = list8 ::: list2\n                    if (list9.nonEmpty)\
    \ {\n                        if (list1.nonEmpty && list2.nonEmpty) {\n       \
    \                     val list10 = list9 ::: list1\n                         \
    \   val list11 = list9 ::: list10\n                            if (list11.nonEmpty)\
    \ {\n                                return \"Yes\"\n                        \
    \    } else {\n                                return \"No\"\n               \
    \             }\n                        } else {\n                          \
    \  return \"No\"\n                        }\n                    } else {\n  \
    \                      return \"No\"\n                    }\n                }\
    \ else {\n                    return \"No\"\n                }\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppbmrv14k.scala:20:26 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mlist3\e[0m = list1 ::: list2\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          value ::: is not a member of String\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmppbmrv14k.scala:23:30 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mlist5\e[0m = list4 :::\
    \ list1\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                              value ::: is not a member of String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppbmrv14k.scala:29:38 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    \e[33mval\e[0m \e[36mlist9\e[0m =\
    \ list8 ::: list2\n\e[31m\e[31m   |\e[0m                                     \
    \ ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     value :::\
    \ is not a member of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppbmrv14k.scala:32:47\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m                        \
    \    \e[33mval\e[0m \e[36mlist10\e[0m = list9 ::: list1\n\e[31m\e[31m   |\e[0m\
    \                                               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                     value ::: is not a member of String\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = new mutable.Stack[Int](2)\n        val lst2 = lst.map { x => { x ->\
    \ 1 }; x -> 0 }.toMap\n        val lst3 = lst.map { x => { x -> -1 }; x -> 0 }.toMap\n\
    \        for (x <- 0 until lst.size) {\n            if (lst(x) == -1) stack +=\
    \ x\n            else if (!lst2.contains(x) || !lst3.contains(x)) stack += x\n\
    \        }\n        if (stack.size > 0) \"No\" else \"Yes\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4pwfvtyr.scala:18:24 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mInt\e[0m](\e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp4pwfvtyr.scala:22:16\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \     \e[33mif\e[0m (lst(x) == -\e[31m1\e[0m) stack += x\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Values of types String\
    \ and Int cannot be compared with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp4pwfvtyr.scala:23:36 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (!lst2.contains(x) || !lst3.contains(x))\
    \ stack += x\n\e[31m\e[31m   |\e[0m                                    ^\e[0m\n\
    \e[31m   |\e[0m                                    Found:    (x : Int)\n\e[31m\
    \   |\e[0m                                    Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4pwfvtyr.scala:23:57 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (!lst2.contains(x)\
    \ || !lst3.contains(x)) stack += x\n\e[31m\e[31m   |\e[0m                    \
    \                                     ^\e[0m\n\e[31m   |\e[0m                \
    \                                     Found:    (x : Int)\n\e[31m   |\e[0m   \
    \                                                  Required: String\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ stack = lst.head\n        var isTrue = true\n        var i = 0\n        while\
    \ (i < lst.length) {\n            if (lst(i).startsWith(\"(\")) {\n          \
    \      if (lst(i).startsWith(\"(\"))\n                    stack += \"(\"\n   \
    \             else\n                    stack += \")\"\n            } else {\n\
    \                if (lst(i).startsWith(\")\"))\n                    stack += \"\
    )\"\n                else {\n                    if (!stack.startsWith(\"(\"))\n\
    \                        isTrue = false\n                    else\n          \
    \              stack = \"\"\n                }\n            }\n            i +=\
    \ 1\n        }\n        if (isTrue)\n            \"Yes\"\n        else\n     \
    \       \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpki7bwn0n.scala:46)\n\tat Problem.main(tmpki7bwn0n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ rem = lst\n        var stack = new Stack[String]\n        var count = 0\n  \
    \      val good = mutable.ListBuffer.empty[String]\n        rem.foreach(s => if\
    \ (s.startsWith(\"(\") || s.startsWith(\")\")) stack += s)\n        while (stack.nonEmpty)\
    \ {\n            val s = stack.pop\n            if (s.endsWith(\"(\")) count +=\
    \ 1\n            if (s.endsWith(\")\")) count -= 1\n            if (count < 0)\
    \ good.append(\"No\")\n            else if (count == 0) good.append(\"Yes\")\n\
    \            else good.append(s)\n        }\n        good.mkString\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8ge8l66b.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // TODO\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpziz7h0mx.scala:17:51\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mmatchParens\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mString\e[0m]) : \e[35mString\e[0m =\
    \ {\n\e[31m\e[31m   |\e[0m                                                   ^\e\
    [0m\n\e[31m   |\e[0m                                                   Found:\
    \    Unit\n\e[31m   |\e[0m                                                   Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// TODO\e[0m\n\e[31m19 |\e[0m    }\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979964
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        //your\
    \ code\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcdunqmg7.scala:17:51\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mmatchParens\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mString\e[0m]) : \e[35mString\e[0m =\
    \ {\n\e[31m\e[31m   |\e[0m                                                   ^\e\
    [0m\n\e[31m   |\e[0m                                                   Found:\
    \    Unit\n\e[31m   |\e[0m                                                   Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m//your code\e[0m\n\e[31m19 |\e[0m    }\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979965
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // \
    \ TODO\n        var res: String = \"No\"\n        val lst1: mutable.List[String]\
    \ = lst._1.asInstanceOf[mutable.List[String]]\n        val lst2: mutable.List[String]\
    \ = lst._2.asInstanceOf[mutable.List[String]]\n        if (lst1.size != lst2.size)\
    \ {\n            res = \"No\"\n        }\n        else {\n            for (i <-\
    \ 0 until lst1.size) {\n                if ((lst1(i).charAt(0) == '(') && (lst2(i).charAt(0)\
    \ == ')')) {\n                    if (lst1(i).charAt(lst1(i).length - 1) == ')')\
    \ {\n                        val tempStr: String = \"()\" + lst1(i).substring(1)\n\
    \                        val resStr: String = \"Yes\"\n                      \
    \  val resArr: List[String] = resStr.split(\"\\\\W+\").toList.filter(s => s.nonEmpty)\n\
    \                        if (resArr.size == 2) {\n                           \
    \ val tempArr: List[String] = tempStr.split(\"\\\\W+\").toList.filter(s => s.nonEmpty)\n\
    \                            val list: List[String] = lst2.asInstanceOf[List[String]]\n\
    \                            val lst: mutable.List[String] = lst2.asInstanceOf[mutable.List[String]]\n\
    \                            for (b <- 0 until list.size) {\n                \
    \                if (lst(b).charAt(0) == '(' && tempArr(b).charAt(0) == ')') {\n\
    \                                    if (lst(b).charAt(lst(b).length - 1) == ')'\
    \ && lst(b).substring(1) == list(b)) {\n                                     \
    \   resStr = \"Yes\"\n                                        resArr(0) = tempStr\n\
    \                                    }\n                                }\n  \
    \                          }\n                            res = resStr\n     \
    \                   }\n                    }\n                }\n            }\n\
    \        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg3t8qc3i.scala:20:18 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mlst1\e[0m: mutable.List[\e\
    [35mString\e[0m] = lst._1.asInstanceOf[mutable.List[\e[35mString\e[0m]]\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \ Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg3t8qc3i.scala:20:61\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mlst1\e[0m: mutable.List[\e[35mString\e[0m] = lst._1.asInstanceOf[mutable.List[\e\
    [35mString\e[0m]]\n\e[31m\e[31m   |\e[0m                                     \
    \                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                               Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpg3t8qc3i.scala:20:45 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mlst1\e[0m: mutable.List[\e\
    [35mString\e[0m] = lst._1.asInstanceOf[mutable.List[\e[35mString\e[0m]]\n\e[31m\e\
    [31m   |\e[0m                                         ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                value _1 is not a member of List[String]\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpg3t8qc3i.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlst2\e[0m: mutable.List[\e\
    [35mString\e[0m] = lst._2.asInstanceOf[mutable.List[\e[35mString\e[0m]]\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \ Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg3t8qc3i.scala:21:61\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mlst2\e[0m: mutable.List[\e[35mString\e[0m] = lst._2.asInstanceOf[mutable.List[\e\
    [35mString\e[0m]]\n\e[31m\e[31m   |\e[0m                                     \
    \                        ^^^^^^^\e[0m\n\e[31m   |"
  stdout: ''
  timestamp: 1659979967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Write\
    \ your code here\n        val stack = Stack[String]()\n        val str = lst(0)\
    \ \n        for(x <- str){\n            if(x ==\"(\") stack += \"(\"\n       \
    \     else if(x==\")\") stack += \")\"\n            else\n            if(!stack.isEmpty){\n\
    \                val check = stack.pop()\n                if(check != \"(\") \n\
    \                if(check != \")\"){\n                    return \"No\"\n    \
    \            }\n            }\n        }\n        if(stack.isEmpty) \n       \
    \     return \"Yes\"\n        else \n            return \"No\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpq48a_n_m.scala:22:15 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m(x ==\e[31m\"(\"\e[0m) stack\
    \ += \e[31m\"(\"\e[0m\n\e[31m\e[31m   |\e[0m               ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Values of types Char and String cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- Error: /tmp/tmpq48a_n_m.scala:23:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m(x==\e[31m\"\
    )\"\e[0m) stack += \e[31m\")\"\e[0m\n\e[31m\e[31m   |\e[0m                   \
    \ ^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types Char and String cannot be\
    \ compared with == or !=\n2 errors found\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        //Using\
    \ Regular expressions\n        val open = \"\\\\(|\\\\)|\\\\|\"\n        val close\
    \ = \"\\\\(|\\\\)\"\n        val balance = \"[\" + open + close.r.replaceAllIn(open,\
    \ \"\") + \"]\"\n        val regexp = s\"\"\"^$balance+$balance+$balance+$balance$\"\
    \"\"\n        val str = lst(0) + lst(1)\n        if (!str.matches(regexp)) {\n\
    \            \"No\"\n        }\n        else if (!lst.size == 2) {\n         \
    \   \"No\"\n        }\n        else {\n            \"Yes\"\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp0tqfh9ph.scala:22:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mregexp\e[0m = \e[31ms\"\"\
    \"^\e[0m$balance\e[31m+\e[0m$balance\e[31m+\e[0m$balance\e[31m+\e[0m$balance$\"\
    \"\"\n\e[31m\e[31m   |\e[0m                                                  \
    \           ^\e[0m\n\e[31m   |\e[0m                                      unclosed\
    \ multi-line string literal\n\e[31m\e[31m-- Error: /tmp/tmp0tqfh9ph.scala:50:0\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m50 |\e[0m\n\e[31m\e\
    [31m   |\e[0m^\e[0m\n\e[31m   |\e[0munclosed multi-line string literal\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979962
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ parensStack = new Stack[Int]()\n        var result = \"No\"\n        lst.foreach(x\
    \ => {\n            if (x.toString.contains(\"(\")) {\n                parensStack.push(1)\n\
    \            }\n            else if (x.toString.contains(\")\")) {\n         \
    \       val poppedCount = parensStack.pop()\n                if (poppedCount >\
    \ 1) {\n                    result == \"Yes\"\n                }\n           \
    \     else {\n                    result == \"No\"\n                }\n      \
    \      }\n        })\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3_znmp4c.scala:37)\n\tat Problem.main(tmp3_znmp4c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if(lst.size\
    \ > 2) false\n        else if(lst.size == 2) true\n        else lst.foldLeft(true)\
    \ { (res, elem) =>\n            if(elem == \"(\")\n            res = res && matchParens(lst.take(2)\
    \ ++ lst.takeRight(2).reverse)\n            else\n            res = res && matchParens(lst.drop(1)\
    \ ++ lst.takeRight(2).reverse)\n            res\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaucafpwx.scala:18:25\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(lst.size\
    \ > \e[31m2\e[0m) \e[31mfalse\e[0m\n\e[31m\e[31m   |\e[0m                    \
    \     ^^^^^\e[0m\n\e[31m   |\e[0m                         Found:    (\e[31mfalse\e\
    [0m : Boolean)\n\e[31m   |\e[0m                         Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaucafpwx.scala:19:31 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m(lst.size == \e\
    [31m2\e[0m) \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m                           \
    \    ^^^^\e[0m\n\e[31m   |\e[0m                               Found:    (\e[31mtrue\e\
    [0m : Boolean)\n\e[31m   |\e[0m                               Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaucafpwx.scala:22:36\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            res = res && matchParens(lst.take(\e\
    [31m2\e[0m) ++ lst.takeRight(\e[31m2\e[0m).reverse)\n\e[31m\e[31m   |\e[0m   \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    String\n\e[31m   |\e[0m\
    \                         Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpaucafpwx.scala:24:36 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            res = res && matchParens(lst.drop(\e[31m1\e\
    [0m) ++ lst.takeRight(\e[31m2\e[0m).reverse)\n\e[31m\e[31m   |\e[0m          \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Found:    String\n\e[31m   |\e[0m      \
    \                   Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ countParens = lst.count(_.matches(\"\\\\(.*\\\\)\")) / lst.count\n        val\
    \ string = \"Yes\"\n        val string2 = \"No\"\n        \n        if(countParens\
    \ == 1)\n        {\n            if(lst(0)(0) == \"(\" || lst(0)(lst(0).length-1)\
    \ == \"(\")\n                string2 = \"Yes\"\n            else\n           \
    \     string = \"Yes\"\n        }\n        else if(countParens == 0)\n       \
    \     string = \"No\"\n        else\n            string = \"Yes\"\n          \
    \  \n        return string\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpnxp97h1f.scala:18:59 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mcountParens\e[0m = lst.count(_.matches(\e\
    [31m\"\\\\(.*\\\\)\"\e[0m)) / lst.count\n\e[31m\e[31m   |\e[0m               \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m None of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35m/\e[0m in \e[33mclass\e[0m\
    \ \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\e[31m   |\e\
    [0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m  (x:\
    \ Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short): Int\n\
    \e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments ((String => Boolean)\
    \ => Int)\n\e[31m\e[31m-- Error: /tmp/tmpnxp97h1f.scala:24:15 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m(lst(\e[31m0\e[0m)(\e[31m0\e\
    [0m) == \e[31m\"(\"\e[0m || lst(\e[31m0\e[0m)(lst(\e[31m0\e[0m).length-\e[31m1\e\
    [0m) == \e[31m\"(\"\e[0m)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpnxp97h1f.scala:24:35 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m(lst(\e[31m0\e[0m)(\e[31m0\e\
    [0m) == \e[31m\"(\"\e[0m || lst(\e[31m0\e[0m)(lst(\e[31m0\e[0m).length-\e[31m1\e\
    [0m) == \e[31m\"(\"\e[0m)\n\e[31m\e[31m   |\e[0m                             \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- [E052] Type\
    \ Error: /tmp/tmpnxp97h1f.scala:25:24 -----------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m                string2 = \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val string2\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpnxp97h1f.scala:27:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                string\
    \ = \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e[0m                ^"
  stdout: ''
  timestamp: 1659979966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val stack\
    \ = mutable.Stack[String]()\n      val str = lst.head\n      if (str == \"()\"\
    ) {\n        stack += \"(\"\n      } else if (str == \")\") {\n        val current\
    \ = stack.pop()\n        if (current == \"\") {\n          return \"No\"\n   \
    \     } else {\n          stack += \")\"\n        }\n      } else if (str.startsWith(\"\
    (\")) {\n        stack += str\n      } else if (str.endsWith(\")\")) {\n     \
    \   val current = stack.pop()\n        if (current == \"\") {\n          return\
    \ \"No\"\n        } else {\n          stack += str\n        }\n      }\n     \
    \ return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7tg62_za.scala:18:18 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m      \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979962
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ set = new mutable.HashSet[String]()\n        lst.foreach(x => x.split(\"\\\\\
    (\").foreach(x => set.add(x)))\n        if(set.size == 2) {\n            val lst1\
    \ = lst(0).get.split(\"\\\\)\")\n            val lst2 = lst(1).get.split(\"\\\\\
    )\")\n            if(lst1.length == lst2.length) {\n                if(lst1(0)\
    \ == \"(\" && lst1(1) == \"(\" && lst2(0) == \")\" && lst2(1) == \")\") {\n  \
    \                  return \"Yes\"\n                }\n            }\n        }\n\
    \        \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpce_5y_zd.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mset\e[0m = \e[33mnew\e[0m\
    \ mutable.HashSet[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpce_5y_zd.scala:21:30\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m\
    \ \e[36mlst1\e[0m = lst(\e[31m0\e[0m).get.split(\e[31m\"\\\\)\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \              value get is not a member of String\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpce_5y_zd.scala:22:30 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m            \e[33mval\e[0m \e[36mlst2\e[0m = lst(\e[31m1\e[0m).get.split(\e\
    [31m\"\\\\)\"\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       value get is not a member of String\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        lst.foreach(x => {\n            if\
    \ (x == \"(\") stack += x\n            else if (!stack.isEmpty && stack.head ==\
    \ x) stack.pop()\n            else if (!stack.isEmpty && stack.head == \"(\")\
    \ stack.pop()\n            else stack\n        })\n        val str = stack.mkString\n\
    \        val newStack = if (str.startsWith(\"()\") && !stack.isEmpty && stack.head\
    \ == \"(\") stack.pop else stack\n        val newStr = stack.mkString\n      \
    \  if (newStr.length < str.length && newStr.isEmpty || newStr.length == str.length\
    \ && !newStack.isEmpty && newStack.head == \"(\") newStack.pop()\n        else\
    \ if (!newStr.isEmpty && newStr.head != \"(\") newStack\n        else newStr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxvgplbon.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979962
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if(lst.size\
    \ == 0) \"No\"\n        else if(lst.head.length == 1 && !lst.head.contains(\"\
    (\") && !lst.head.contains(\")\")) lst.head + lst.head\n        else lst.head\
    \ + matchParens(lst.tail)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpevdrxm5y.scala:23)\n\tat Problem.main(tmpevdrxm5y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ res = (lst.foldLeft(false)((acc, x) => acc || balance(acc, x)) && acc )\n  \
    \      res  match {\n            case true => \"Yes\"\n            case false\
    \ => \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9_sx_g8s.scala:18:58 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = (lst.foldLeft(\e\
    [31mfalse\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc || balance(acc, x)) && acc\
    \ )\n\e[31m\e[31m   |\e[0m                                                   \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                                        \
    \              Not found: balance\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp9_sx_g8s.scala:18:78 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m        \e[33mval\e[0m \e[36mres\e[0m = (lst.foldLeft(\e[31mfalse\e[0m)((\e\
    [36macc\e[0m, \e[36mx\e[0m) => acc || balance(acc, x)) && acc )\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \           ^^^\e[0m\n\e[31m   |\e[0m                                        \
    \                  Not found: acc\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Use\
    \ Stack to store the state of the current parentheses\n        var stack = Stack.empty[List[String]]\n\
    \        var result = \"\"\n        lst.foreach(x => {\n            if (x == \"\
    (\") {\n                if (stack.isEmpty) {\n                    stack.push Nil\n\
    \                } else {\n                    stack.head::stack.last\n      \
    \          }\n            } else if (x == \")\") {\n                if (stack.isEmpty)\
    \ {\n                    result += x\n                } else {\n             \
    \       stack.pop\n                }\n            } else {\n                stack\
    \ += x\n            }\n        })\n        if (stack.isEmpty) {\n            result\n\
    \        } else {\n            \"No\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpb98b3w1g.scala:24:34 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    stack.push Nil\n\e[31m\e[31m   |\e\
    [0m                                  ^\e[0m\n\e[31m   |\e[0m                 \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmpb98b3w1g.scala:24:26 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    stack.push Nil\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mpush\e[0m in \e[33mclass\e[0m \e[35mStack\e\
    [0m with types\n\e[31m   |\e[0m (elem1: List[String], elem2: List[String], elems:\
    \ List[String]*): \n\e[31m   |\e[0m  scala.collection.mutable.Stack[List[String]]\n\
    \e[31m   |\e[0m (elem: List[String]): scala.collection.mutable.Stack[List[String]]\n\
    \e[31m   |\e[0mmatch expected type ?{ Nil: ? }\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpb98b3w1g.scala:35:25 --------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                stack += x\n\e[31m\e[31m   |\e[0m                    \
    \     ^\e[0m\n\e[31m   |\e[0m                         Found:    (x : String)\n\
    \e[31m   |\e[0m                         Required: List[String]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ index = 0\n        while (index < lst.length) {\n            val stringStart\
    \ = lst(index).length\n            var stringEnd = stringStart + 1\n         \
    \   var leftCount = 0\n            var rightCount = 0\n            var nextLeft\
    \ = 0\n            var nextRight = 0\n            var nextStringStart = 0\n  \
    \          while (nextRight < stringEnd) {\n                nextRight = nextRight\
    \ + 1\n                rightCount = rightCount + 1\n                if (nextRight\
    \ < stringEnd) {\n                    nextRight = nextRight + 1\n            \
    \    }\n            }\n            while (nextLeft < stringEnd) {\n          \
    \      nextLeft = nextLeft + 1\n                leftCount = leftCount + 1\n  \
    \              if (nextLeft < stringEnd) {\n                    nextLeft = nextLeft\
    \ + 1\n                }\n            }\n            if (leftCount == rightCount)\
    \ {\n                var nextStringEnd = 0\n                while (nextStringStart\
    \ < stringEnd) {\n                    nextStringEnd = nextStringEnd + 1\n    \
    \                nextStringStart = nextStringStart + 1\n                }\n  \
    \              nextStringEnd = nextStringEnd + 1\n                if (nextStringStart\
    \ < stringEnd) {\n                    if (nextStringStart < nextRight) {\n   \
    \                     if ((nextLeft < stringEnd) && (nextRight < stringEnd)) {\n\
    \                            if (lst(index).charAt(nextStringStart) == '(') {\n\
    \                                nextLeft = nextLeft + 1\n                   \
    \         } else {\n                                nextRight = nextRight + 1\n\
    \                            }\n                        } else {\n           \
    \                 if (nextLeft < stringEnd) {\n                              \
    \  nextRight = nextRight + 1\n                            }\n                \
    \        }\n                    }\n                } else {\n                \
    \    if (nextRight < stringEnd) {\n                        nextLeft = nextLeft\
    \ + 1\n                    }\n                }\n                if (nextLeft\
    \ < stringEnd) {\n                    return \"Yes\"\n                } else {\n\
    \                    return \"No\"\n                }\n            }\n       \
    \     index = index + 1\n        }\n        return \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4s8orybn.scala:78)\n\tat Problem.main(tmp4s8orybn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ l = new mutable.HashSet[String](lst.head)\n        val r = new mutable.HashSet[String](lst.tail.head)\n\
    \        l.foreach { x => r.add (x) }\n        if (l.size == r.size) {\n     \
    \       return \"Yes\"\n        } else {\n            return \"No\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps3zbasv5.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = \e[33mnew\e[0m\
    \ mutable.HashSet[\e[35mString\e[0m](lst.head)\n\e[31m\e[31m   |\e[0m        \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps3zbasv5.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mr\e[0m = \e[33mnew\e[0m mutable.HashSet[\e[35mString\e[0m](lst.tail.head)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979962
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = new mutable.Stack[String]()\n        val res = \"Yes\"\n        for\
    \ (str <- lst) {\n            if (str.contains(\"(\") && stack.nonEmpty) {\n \
    \               stack.push(str)\n            } else if (str.contains(\")\") &&\
    \ stack.nonEmpty) {\n                if (!stack.isEmpty) {\n                 \
    \   stack.peek match {\n                        case \"(\" =>\n              \
    \              stack.push(str)\n                        case \")\" =>\n      \
    \                      if (stack.pop() == \"(\") {\n                         \
    \       res = \"No\"\n                            } else {\n                 \
    \               res = \"Yes\"\n                            }\n               \
    \     }\n                }\n            }\n        }\n        res\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptpu7m2bp.scala:18:24 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmptpu7m2bp.scala:30:36 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                                res = \e[31m\"No\"\e\
    [0m\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                Reassignment to val res\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmptpu7m2bp.scala:32:36 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                                res = \e[31m\"Yes\"\e\
    [0m\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                Reassignment to val res\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty)\
    \ List(\"No\")\n        else {\n            val first = lst(0)\n            val\
    \ rest = lst.drop(1)\n            var stack = new Stack[(Int, List[String])]\n\
    \            stack.push((0, List()))\n            while (stack.size > 0 && !stack.isEmpty)\
    \ {\n                val index = stack.pop()\n                val sub = sublist(index,\
    \ first, rest)\n                if (sub.size() > 0) {\n                    val\
    \ newIndex = index + 1\n                    val subSub = sublist(newIndex, first,\
    \ rest)\n                    val newStack = stack.map{\n                     \
    \   case (index, _) => if (index == newIndex) sub.head else (_, _) }\n       \
    \             val newSub = subSub ++ sub.tail\n                    stack.push((newIndex,\
    \ newSub))\n                } else {\n                    if (index == newIndex)\
    \ sub.head else \"No\"\n                }\n            }\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8ngzesot.scala:18:29\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (lst.isEmpty)\
    \ List(\e[31m\"No\"\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Found:    \e[1m\e[31mList\e[0m\e\
    [1m\e[31m[\e[0mString\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                      \
    \   Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8ngzesot.scala:26:26\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                \e[33mval\e\
    [0m \e[36msub\e[0m = sublist(index, first, rest)\n\e[31m\e[31m   |\e[0m      \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not\
    \ found: sublist\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8ngzesot.scala:28:41\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                    \e[33mval\e\
    [0m \e[36mnewIndex\e[0m = index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        \
    \                           ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of (Int, List[String]), but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8ngzesot.scala:29:33 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    \e[33mval\e[0m \e[36msubSub\e[0m\
    \ = sublist(newIndex, first, rest)\n\e[31m\e[31m   |\e[0m                    \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                                 Not\
    \ found: sublist\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp8ngzesot.scala:31:81\
    \ -----------------------------\e[0m\e[0m\n\e"
  stdout: ''
  timestamp: 1659979968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ strList = lst.flatten.toList\n        var open = 0\n        var close = 0\n\
    \        var sum = 0\n        for (str <- strList) {\n            if (str == \"\
    )\")\n                close += 1\n            if (str == \"(\")\n            \
    \    open += 1\n            sum += open\n            sum += close\n        }\n\
    \        if (sum == strList.size)\n            return \"Yes\"\n        return\
    \ \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpyla707o5.scala:23:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (str == \e[31m\")\"\e[0m)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpyla707o5.scala:25:16 -----------------------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m            \e[33mif\e[0m (str == \e[31m\"(\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of\
    \ types Char and String cannot be compared with == or !=\n2 errors found\n"
  stdout: ''
  timestamp: 1659979968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = new mutable.Stack[String]()\n        var curr : String = \"\"\n    \
    \    for (aString <- lst) {\n            if (aString.contains(\"(\")) {\n    \
    \            stack.push(aString)\n            }\n            if (aString.contains(\"\
    )\")) {\n                curr = stack.pop()\n                if (curr.length !=\
    \ (aString.length + 1))\n                    return \"No\"\n            }\n  \
    \      }\n        if (stack.isEmpty)\n            return \"Yes\"\n        return\
    \ \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd8nwfvmm.scala:18:24 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        lst.foldLeft(\"\
    \"){(str, s) =>\n            val (count, i) = str.length match {\n           \
    \     case 0 => (0, s)\n                case count => count + (s.charAt(i) ==\
    \ ')')\n            }\n            if (count > 0) str + s.subList(0, i) + \"Yes\"\
    \n            else \"No\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1lw6180g.scala:19:24 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m (count, i) = str.length \e\
    [33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m\
    \   |\e[0m                        Recursive \e[33mvalue\e[0m \e[35m$1$\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp1lw6180g.scala:21:36\
    \ -----------------------------\e[0m\e[0m\n\e[31m21 |\e[0m                \e[33mcase\e\
    [0m count => count + (s.charAt(i) == \e[31m')'\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                            ^^^^^^^\e[0m\n\e[31m   |\e[0m None of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m+\e[0m in \e[33mclass\e[0m \e[35mInt\e\
    [0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\e[31m   |\e[0m  (x: Float):\
    \ Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e\
    [31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e\
    [0m  (x: Byte): Int\n\e[31m   |\e[0m  (x: String): String\n\e[31m   |\e[0m match\
    \ arguments (Boolean)\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1lw6180g.scala:23:35\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m\
    \ (count > \e[31m0\e[0m) str + s.subList(\e[31m0\e[0m, i) + \e[31m\"Yes\"\e[0m\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                 value subList is not a member of String\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // (1)\
    \ create two empty lists to store open and close parens\n        var openParens\
    \ = ListBuffer.empty[String]\n        var closeParens = ListBuffer.empty[String]\n\
    \        for (elem <- lst) {\n            // (2) append opening parens to the\
    \ open list\n            openParens append elem\n            // (3) append closing\
    \ parens to the close list\n            closeParens append elem\n        }\n \
    \       // (4) check the parentheses match\n        var flag = true\n        for\
    \ (elem <- closeParens) {\n            if ((closeParens contains elem)) {\n  \
    \              flag = flag && ((openParens contains elem))\n            }\n  \
    \      }\n        if (closeParens.length != openParens.length) {\n           \
    \ flag = false\n        }\n        if (closeParens.size != openParens.size) {\n\
    \            flag = false\n        }\n        if (flag) {\n            return\
    \ \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu56uuyhh.scala:48)\n\tat Problem.main(tmpu56uuyhh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ s = lst.foldLeft(\"(\", \"(\") {\n            (acc, curr) =>\n             \
    \   curr.head == \"(\" ? acc + \" \" + curr : curr\n        }\n        (s.endsWith(\"\
    \ \")) ? s\"${s}.\" : s\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzkvr4ree.scala:20:54 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                curr.head == \e[31m\"(\"\e[0m ? acc +\
    \ \e[31m\" \"\e[0m + curr : \e[35mcurr\e[0m\n\e[31m\e[31m   |\e[0m           \
    \                                           ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                             Not found: type curr\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzkvr4ree.scala:20:33 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                curr.head == \e[31m\"(\"\e[0m ? acc +\
    \ \e[31m\" \"\e[0m + curr : \e[35mcurr\e[0m\n\e[31m\e[31m   |\e[0m           \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                             value\
    \ ? is not a member of String\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzkvr4ree.scala:22:39\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        (s.endsWith(\e[31m\"\
    \ \"\e[0m)) ? \e[31ms\"\e[0m${s}\e[31m.\"\e[0m : \e[35ms\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                                       ^\e[0m\n\e[31m   |\e[0m       \
    \                                Not found: type s\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpzkvr4ree.scala:22:11 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        (s.endsWith(\e[31m\" \"\e[0m)) ? \e[31ms\"\e\
    [0m${s}\e[31m.\"\e[0m : \e[35ms\e[0m\n\e[31m\e[31m   |\e[0m         ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m         value endsWith is not a member of (String, String)\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659979971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty)\
    \ \"\"\n        val newList = new mutable.Stack[String]\n        newList.toList\
    \ foreach { x =>\n            if (lst(0) != x) (newList.push(x): Unit)\n     \
    \   }\n        if (newList.isEmpty) \"\"\n        else {\n            val lst2\
    \ = newList.toList mkString \"(\"\n            val lst3 = lst.filterNot(x => x\
    \ == lst2).mkString(\"(\", \"(\", \")\", \")\")\n            val lst4 = lst2.reverse.mkString(\"\
    (\", \")\")\n            lst4 match{\n                case x if x != \"\" => lst3\n\
    \                case x => \"No\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnzn2j4si.scala:19:26 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mnewList\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mString\e[0m]\n\e[31m\e[31m   |\e[0m                  \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnzn2j4si.scala:26:62\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e\
    [36mlst3\e[0m = lst.filterNot(\e[36mx\e[0m => x == lst2).mkString(\e[31m\"(\"\e\
    [0m, \e[31m\"(\"\e[0m, \e[31m\")\"\e[0m, \e[31m\")\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                              ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    (String, String, String,\
    \ String)\n\e[31m   |\e[0m                              Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnzn2j4si.scala:29:37 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mcase\e[0m x \e[33mif\e[0m x !=\
    \ \e[31m\"\"\e[0m => lst3\n\e[31m\e[31m   |\e[0m                             \
    \        ^^^^\e[0m\n\e[31m   |\e[0m                                     Found:\
    \    (lst3 : Char)\n\e[31m   |\e[0m                                     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmpnzn2j4si.scala:18:25\
    \ ----------------\e[0m\e[0m\n\e[33m18 |\e[0m        \e[33mif\e[0m (lst.isEmpty)\
    \ \e[31m\"\"\e[0m\n\e[33m\e[33m   |\e[0m                         ^^\e[0m\n\e[33m\
    \   |\e[0mA pure expression does nothing in statement position; you may be omitting\
    \ necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1659979975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Convert\
    \ '()' into '(', and convert '()()' into '(())'\n        val ls = lst.map( s =>\
    \ if(s == '(') '(' else '(' else ')'))\n        // Find the '(()' pair\n     \
    \   val pair = ls.find( s => s == '(()')\n        // If there's no pair, return\
    \ No\n        if(pair == None) return \"No\"\n        // If there's a pair, find\
    \ the matching ')' by index\n        val p = pair.index match {\n            case\
    \ 0 => \"(()\"\n            case 1 => \")\"\n            case _ => ls(pair.length\
    \ - 1) // or ls(pair.length - 2)\n        }\n        // If there's no matching\
    \ ')', return No\n        if(p != \"(\") return \"No\"\n        // If there's\
    \ a matching ')', find matching '(()' by index\n        val pair1 = ls.find( s\
    \ => s == \")\")\n        val p1 = pair1.index match {\n            case 0 =>\
    \ \"(())\"\n            case 1 => \")\"\n            case _ => ls(pair1.length\
    \ - 1)\n        }\n        // If there's no '(())', return 'No'\n        if(p1\
    \ != p) return \"No\"\n        // Otherwise, return 'Yes'\n        return \"Yes\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp509u5qj4.scala:19:57 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mls\e[0m = lst.map( \e[36ms\e\
    [0m => \e[33mif\e[0m(s == \e[31m'('\e[0m) \e[31m'('\e[0m \e[33melse\e[0m \e[31m'('\e\
    [0m \e[33melse\e[0m \e[31m')'\e[0m))\n\e[31m\e[31m   |\e[0m                  \
    \                                       ^^^^\e[0m\n\e[31m   |\e[0m           \
    \                               ')' expected, but 'else' found\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmp509u5qj4.scala:19:66 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mls\e[0m = lst.map( \e[36ms\e\
    [0m => \e[33mif\e[0m(s == \e[31m'('\e[0m) \e[31m'('\e[0m \e[33melse\e[0m \e[31m'('\e\
    [0m \e[33melse\e[0m \e[31m')'\e[0m))\n\e[31m\e[31m   |\e[0m                  \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                        '}' expected, but ')' found\n\e[31m\e\
    [31m-- Error: /tmp/tmp509u5qj4.scala:21:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mpair\e[0m = ls.find( \e\
    [36ms\e[0m => s == '(()')\n\e[31m\e[31m   |\e[0m                             \
    \         ^\e[0m\n\e[31m   |\e[0m                                      unclosed\
    \ character literal\n\e[31m\e[31m-- Error: /tmp/tmp509u5qj4.scala:21:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mpair\e[0m = ls.find( \e\
    [36ms\e[0m => s == '(()')\n\e[31m\e[31m   |\e[0m                             \
    \             ^\e[0m\n\e[31m   |\e[0m                                        \
    \  unclosed character literal\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp509u5qj4.scala:59:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m59 |\e[0m}\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0meof expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp509u5qj4.scala:19:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m19 |\e[0m       \
    \ \e[33mval\e[0m \e[36mls\e[0m = lst.map( \e[36ms\e[0m => \e[33mif\e[0m(s == \e\
    [31m'('\e[0m) \e[31m'('\e[0m \e[33melse\e[0m \e[31m'('\e[0m \e[33melse\e[0m \e\
    [31m')'\e[0m))\n\e[31m\e[31m   |\e[0m                                  ^^^^^"
  stdout: ''
  timestamp: 1659979973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = new mutable.Stack[String]\n        val result = \"No\"\n        lst.foreach\
    \ {\n            case x => (x match {\n                case \")\" => stack.push(x)\n\
    \                case \"))\" => stack.push(x)\n                case \")(\" =>\
    \ stack.push(x)\n                case \")()\" => stack.pop()\n               \
    \ case \")(\" => stack.pop()\n                case \"))\" => stack.pop()\n   \
    \             case _ => stack.pop()\n            })\n        }\n        if (stack.size\
    \ == 0) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb76q4an8.scala:18:24 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mString\e[0m]\n\e[31m\e[31m   |\e[0m                  \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val map = mutable.Map[String, Boolean]()\n\
    \        lst.foreach(x => {\n            if (x.startsWith(\"(\") || x.startsWith(\"\
    )\")){\n                if (!map.contains(x)){\n                    map.put(x.substring(1),\
    \ true)\n                }\n                if (!map.contains(x.substring(1))){\n\
    \                    stack.push(x)\n                }\n            }\n       \
    \ })\n        stack.foreach(x => {\n            map.put(x, false)\n        })\n\
    \        val answer = stack.foldRight(true){ (x, y) =>\n            if (y && !x)\n\
    \                y\n            else\n                x\n        }\n        if\
    \ (answer){\n            \"Yes\"\n        }\n        else{\n            \"No\"\
    \n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp43flffsc.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp43flffsc.scala:19:18 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = mutable.Map[\e\
    [35mString\e[0m, \e[35mBoolean\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      def infixToPostfix(infixList\
    \ : List[String]) =\n        infixList.foldLeft(\"\") { (result, x) => result\
    \ + x.reverse.mkString(\"(\") + \")\" }.trim\n\n      def matching(curr : String,\
    \ nextList : List[String], result : String) : String = {\n        if (next ==\
    \ \"\") {\n          result\n        } else if (next == curr) {\n          matching(infixToPostfix(nextList),\
    \ nextList.tail, result + curr)\n        } else {\n          matching(infixToPostfix(nextList),\
    \ nextList.tail, result)\n        }\n      }\n\n      def matching(infixList :\
    \ List[String], result : String) : String = {\n        if (infixList.isEmpty)\
    \ {\n          result\n        } else {\n          matching(infixList.head, infixList.tail,\
    \ result)\n        }\n      }\n\n      infixToPostfix(lst.head)\n      matching(\"\
    \", lst.tail, \"Yes\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyh592u7h.scala:31:10 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m      \e[33mdef\e[0m \e[36mmatching\e[0m(\e[36minfixList\e\
    [0m : \e[35mList\e[0m[\e[35mString\e[0m], \e[36mresult\e[0m : \e[35mString\e[0m)\
    \ : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m      ^\e[0m\n\e[31m   |\e[0mmatching\
    \ is already defined as \e[33mmethod\e[0m \e[35mmatching\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m32 |\e[0m        \e[33mif\e[0m (infixList.isEmpty)\
    \ {\n\e[31m33 |\e[0m          result\n\e[31m34 |\e[0m        } \e[33melse\e[0m\
    \ {\n\e[31m35 |\e[0m          matching(infixList.head, infixList.tail, result)\n\
    \e[31m36 |\e[0m        }\n\e[31m37 |\e[0m      }\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpyh592u7h.scala:22:12 ------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mif\e[0m (next == \e[31m\"\"\e[0m) {\n\e[31m\e[31m   |\e\
    [0m            ^^^^\e[0m\n\e[31m   |\e[0m            Not found: next\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyh592u7h.scala:24:19 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (next == curr)\
    \ {\n\e[31m\e[31m   |\e[0m                   ^^^^\e[0m\n\e[31m   |\e[0m      \
    \             Not found: next\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpyh592u7h.scala:39:25 --------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m      infixToPostfix(lst.head)\n\e[31m\e[31m   |\e[0m                \
    \     ^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Found:    String\n\e\
    [31m   |\e[0m                     Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e\
    [0mString\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val newlst\
    \ = lst.map(x => if (x == \"(\") 1 else 0)\n      val n = newlst.head\n      val\
    \ m = newlst.last\n      if (n != m)\n        \"No\"\n      else if (n == 0)\n\
    \        \"Yes\"\n      else if (n == 1)\n        \"Yes\"\n      else\n      \
    \  matchParens(newlst.tail)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcmgghq2_.scala:28:27\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        matchParens(newlst.tail)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                 Found:    List[Int @uncheckedVariance]\n\e[31m   |\e[0m    \
    \                Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ arr = lst.map(x => x.toChar)\n        val lefts = arr.takeWhile(x => x == '(').length\n\
    \        val rights = arr.dropWhile(x => x == '(').length\n        val balanced\
    \ = (lefts == rights)\n        if(balanced){\n            val arr = lst.map(x\
    \ => x.toChar)\n            val lefts = arr.takeWhile(x => x == '(').length\n\
    \            val rights = arr.dropWhile(x => x == '(').length\n            if(lefts\
    \ == rights){\n                val str = \"()\" + lst(0) + \"()\"\n          \
    \      if( arr.map(_.toInt).toSet.subsetOf(str.toSet) ){\n                   \
    \ \"Yes\"\n                }else{\n                    \"No\"\n              \
    \  }\n            }else{\n                \"No\"\n            }\n        }else{\n\
    \            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbb3ry3z8.scala:18:33 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = lst.map(\e[36mx\e\
    [0m => x.toChar)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toChar is not a member\
    \ of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbb3ry3z8.scala:23:37\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m\
    \ \e[36marr\e[0m = lst.map(\e[36mx\e[0m => x.toChar)\n\e[31m\e[31m   |\e[0m  \
    \                                 ^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                     value toChar is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpbb3ry3z8.scala:28:30 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m                \e[33mif\e[0m( arr.map(_.toInt).toSet.subsetOf(str.toSet)\
    \ ){\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue toInt is not a member of Nothing, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659979978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Iterate\
    \ over the list\n        val set = mutable.Set[String]()\n        for(i <- lst.indices)\
    \ {\n            val str = lst(i + 1)\n            if(!set.isEmpty) {\n      \
    \          // We can't concatenate if it's not empty\n                return \"\
    No\"\n            }\n            if(!str.contains(\"(\")) {\n                //\
    \ String doesn't contain open\n                return \"No\"\n            }\n\
    \            if(!str.contains(\")\")) {\n                // String doesn't contain\
    \ close\n                return \"No\"\n            }\n            if(str == \"\
    ()\") {\n                // String contains open and close\n                set.add(lst(i))\n\
    \            }\n        }\n\n        // If we reach here, then string concatenation\
    \ can be done.\n        val result = \"Yes\"\n        for(i <- 0 until set.size)\
    \ {\n            result += \"(\" + set.apply(i) + \")\"\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpji3si0wt.scala:19:18 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mset\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpji3si0wt.scala:43:19 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            result += \e[31m\"(\"\e[0m + set.apply(i)\
    \ + \e[31m\")\"\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            value += is not a member of String - did you mean result.!=?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        stack.push(\"(\")\n        val result\
    \ = \"\"\n        for(i <- 0 until lst.length) {\n            if(lst(i) == \"\
    (\") {\n                stack.push(\"(\")\n            }\n            else if(lst(i)\
    \ == \")\") {\n                if(stack.nonEmpty) {\n                    val tmp\
    \ = \"\"\n                    for(j <- 0 until stack.size) {\n               \
    \         tmp += stack.pop(j)\n                    }\n                    result\
    \ += tmp\n                }\n                stack.pop()\n            }\n    \
    \        else if(stack.nonEmpty) {\n                stack.push(lst(i))\n     \
    \       }\n            else if(lst(i) != \")\") {\n                return \"No\"\
    \n            }\n        }\n        stack.clear\n        result == \"(\" + result\
    \ + \")\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp45vo79xz.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp45vo79xz.scala:29:28 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                        tmp += stack.pop(j)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \   value += is not a member of String - did you mean tmp.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp45vo79xz.scala:31:27 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    result += tmp\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is\
    \ not a member of String - did you mean result.!=?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp45vo79xz.scala:43:8 ---------------------\e[0m\e[0m\n\
    \e[31m43 |\e[0m        result == \e[31m\"(\"\e[0m + result + \e[31m\")\"\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    Boolean\n\e[31m   |\e[0m        Required: String\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659979977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // get\
    \ all parentheses in lst\n        val (opens, closes) = lst.map(_ match {\n  \
    \          case '('  => 1\n            case ')'  => 1\n            case _    =>\
    \ 0\n        }).toList\n\n        // get the left side of every paranthesis, if\
    \ the list is balanced\n        val lefts = lst.map {\n            case s if opens\
    \ > closes => \"()\"\n            case s => \"()\" + s\n        }\n\n        //\
    \ check the right side of every paranthesis, if the list is balanced\n       \
    \ val rights = lst.map {\n            case s if closes > opens => \"()\"\n   \
    \         case s => \"(\" + s\n        }\n\n        // if the left and right side\
    \ of the list are balanced, return \"Yes\"\n        if(lefts.toSet.size == rights.toSet.size)\
    \ \"Yes\"\n        else \"No\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpapjp5epx.scala:20:17 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mcase\e[0m \e[31m'('\e[0m  => \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                 ^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpapjp5epx.scala:21:17 -----------------------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m            \e[33mcase\e[0m \e[31m')'\e[0m  => \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                 ^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpapjp5epx.scala:27:28 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m            \e[33mcase\e[0m s \e[33mif\e[0m opens > closes\
    \ => \e[31m\"()\"\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue > is not a member of Any, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpapjp5epx.scala:33:29\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mcase\e\
    [0m s \e[33mif\e[0m closes > opens => \e[31m\"()\"\e[0m\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue > is not a member of\
    \ Any, but could be made available as an extension method.\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n4 errors found\n"
  stdout: ''
  timestamp: 1659979979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // find\
    \ all openings and closings\n        var openings : List[String] = Nil\n     \
    \   var closings : List[String] = Nil\n        var opening_count : Int = 0\n \
    \       var closing_count : Int = 0\n        for (l<-lst) {\n            val chars\
    \ : List[Char] = l.toList\n            for (c<-chars) {\n                if (c\
    \ == '(') openings = openings :+ c\n                else if (c == ')') closings\
    \ = closings :+ c\n            }\n            opening_count = openings.size\n\
    \            closing_count = closings.size\n        }\n        // get all combination\n\
    \        var com = for (l<-0 to openings.size-1) yield {\n            for (c<-0\
    \ to closings.size-1) yield {\n                for (o<-0 to openings.size()-1)\
    \ yield {\n                    for (c<-0 to closings.size()-1) yield {\n     \
    \                   // check if it is possible to make all openings and closings\n\
    \                        val opening_pos = openings(o) + c\n                 \
    \       val closing_pos = closings(c)+o\n                        val pos1 = o*closings.size+c*openings.size+l*openings.size\n\
    \                        val pos2 = o*closings.size+c*openings.size+l*openings.size+openings.size()\n\
    \                        val pos3 = o*closings.size+c*openings.size+openings.size()*openings.size+closing_pos\n\
    \                        val pos4 = o*closings.size+openings.size()*openings.size+closing_pos+closings.size\n\
    \                        if ((pos1 == pos2) || (pos1 == pos3) || (pos1 == pos4)\
    \ || (pos2 == pos3) || (pos2 == pos4) || (pos3 == pos4) || (pos1 == pos2) && (pos2\
    \ == pos3) && (pos3 == pos4))\n                        yield (o,c,l)\n       \
    \             }\n                }\n            }\n        }\n        // check\
    \ if all combinations are valid\n        for (x <- com) if (x._2 == opening_count+closing_count)\n\
    \            yield \"Yes\"\n        else\n            yield \"No\"\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqr79m95j.scala:45:24 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                        \e[33myield\e[0m (o,c,l)\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                 'then' expected, but 'yield' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpqr79m95j.scala:52:12 ---------------------------\e[0m\e[0m\n\e\
    [31m52 |\e[0m            \e[33myield\e[0m \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^\e[0m\n\e[31m   |\e[0m            'then' expected, but 'yield'\
    \ found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqr79m95j.scala:26:53\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                \e[33mif\e[0m\
    \ (c == \e[31m'('\e[0m) openings = openings :+ c\n\e[31m\e[31m   |\e[0m      \
    \                                               ^\e[0m\n\e[31m   |\e[0m      \
    \                                              Found:    (c : Char)\n\e[31m  \
    \ |\e[0m                                                    Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqr79m95j.scala:27:58\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m                \e[33melse\e\
    [0m \e[33mif\e[0m (c == \e[31m')'\e[0m) closings = closings :+ c\n\e[31m\e[31m\
    \   |\e[0m                                                          ^\e[0m\n\e\
    [31m   |\e[0m                                                    Found:    (c\
    \ : Char)\n\e[31m   |\e[0m                                                   \
    \ Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpqr79m95j.scala:35:38\
    \ -----------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                \e[33mfor\e\
    [0m (o<-\e[31m0\e[0m to openings.size()-\e[31m1\e[0m) \e[33myield\e[0m {\n\e[31m\e\
    [31m   |\e[0m                             ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    \e[33mmethod\e[0m \e[35msize\e[0m in \e[33mtrait\e[0m \e\
    [35mSeqOps\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when com"
  stdout: ''
  timestamp: 1659979979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ leftParens = lst.count(lst contains \"(\")\n        val rightParens = lst.count(lst\
    \ contains \")\")\n\n        if (leftParens == 0 || rightParens == 0)\n      \
    \      \"No\"\n        else {\n            val s = lst.mkString(\"\")\n      \
    \      val start = s.lastIndexOf(\"(\")\n            val end = s.lastIndexOf(\"\
    )\")\n            if (start < end) {\n                val str = s.substring(start\
    \ + 1, end).replaceAll(\"\\\\\", \"\").toInt\n                if (str % 2 == 0)\n\
    \                    \"Yes\"\n                else\n                    \"No\"\
    \n            }\n            else {\n                \"No\"\n            }\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbw4ooo8v.scala:18:35\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mleftParens\e\
    [0m = lst.count(lst contains \e[31m\"(\"\e[0m)\n\e[31m\e[31m   |\e[0m        \
    \                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                        Found:    Boolean\n\e[31m   |\e[0m                  \
    \                 Required: \e[1m\e[32mString\e[0m\e[1m\e[32m \e[0m\e[1m\e[32m=\e\
    [0m\e[1m\e[32m>\e[0m\e[1m\e[32m \e[0mBoolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpbw4ooo8v.scala:19:36 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mrightParens\e[0m = lst.count(lst\
    \ contains \e[31m\")\"\e[0m)\n\e[31m\e[31m   |\e[0m                          \
    \          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \        Found:    Boolean\n\e[31m   |\e[0m                                  \
    \  Required: \e[1m\e[32mString\e[0m\e[1m\e[32m \e[0m\e[1m\e[32m=\e[0m\e[1m\e[32m>\e\
    [0m\e[1m\e[32m \e[0mBoolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ len = lst.size\n        if(len == 0) \"No\"\n        else {\n            val\
    \ stack = mutable.Stack[String]()\n            val isgood = lst.foldLeft(true)((x,y)\
    \ => x && matchParens_helper(stack,0,x,y))\n            val result = if (isgood)\
    \ \"Yes\" else \"No\"\n            stack.toList.reverse.mkString(\"\")\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp67vafkcu.scala:21:24 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp67vafkcu.scala:22:58 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36misgood\e[0m = lst.foldLeft(\e\
    [31mtrue\e[0m)((\e[36mx\e[0m,\e[36my\e[0m) => x && matchParens_helper(stack,\e\
    [31m0\e[0m,x,y))\n\e[31m\e[31m   |\e[0m                                      \
    \                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                           Not found: matchParens_helper\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ arr = lst.map(x => x.indexOf(\"(\") + 1, x.indexOf(\")\")).toArray\n       \
    \ val l = arr.foldLeft(0)((x, y) =>\n            if (x > y) 1 else 0)\n      \
    \  if (l == 0) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjqx_gl7f.scala:18:51 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = lst.map(\e[36mx\e\
    [0m => x.indexOf(\e[31m\"(\"\e[0m) + \e[31m1\e[0m, x.indexOf(\e[31m\")\"\e[0m)).toArray\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0m                                                   Not found: x\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpjqx_gl7f.scala:18:26 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = lst.map(\e[36mx\e\
    [0m => x.indexOf(\e[31m\"(\"\e[0m) + \e[31m1\e[0m, x.indexOf(\e[31m\")\"\e[0m)).toArray\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \                         I could not infer the type of the parameter x.\n\e[31m\e\
    [31m-- Error: /tmp/tmpjqx_gl7f.scala:18:74 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = lst.map(\e[36mx\e\
    [0m => x.indexOf(\e[31m\"(\"\e[0m) + \e[31m1\e[0m, x.indexOf(\e[31m\")\"\e[0m)).toArray\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   \
    \       No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m        \
    \                                  where:    B is a type variable\n3 errors found\n"
  stdout: ''
  timestamp: 1659979978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val strings = mutable.ListBuffer[String]()\n\
    \        val lst_stack = mutable.Stack[List[String]]()\n        for (a <- lst){\n\
    \            strings += a\n            lst_stack += a :: stack\n            stack.push(a)\n\
    \        }\n        val lst_stack2 = lst_stack.toList\n        val stack_size\
    \ = lst_stack2.size\n        val strings2= strings.toList\n        val stack_size2\
    \ = strings2.size\n        val count = stack_size2 - stack_size\n        for (i\
    \ <- 0 until count){\n            val a = lst_stack2.pop()\n            val b\
    \ = strings2.pop()\n            val stack_size_new=stack.size\n            val\
    \ strings_new=strings.toList\n            val stack_size_new2 = strings_new.size\n\
    \            if (stack_size_new2<stack_size_new){\n                return \"No\"\
    \n            }\n            stack+=b\n            strings+=a\n            lst_stack2+=stack\n\
    \            strings2+=b\n        }\n        val stack_size_final=stack.size\n\
    \        val strings_final=strings.toList\n        if (stack_size_final<stack_size){\n\
    \            return \"No\"\n        }\n        val stack_string = stack.toList\n\
    \        val stack_string_final = stack_string.mkString\n        val strings_final2\
    \ = strings_final.mkString\n        if (stack_string_final!=strings_final2){\n\
    \            return \"No\"\n        }\n        return \"Yes\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl8yjvtnt.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpl8yjvtnt.scala:19:22 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mstrings\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpl8yjvtnt.scala:20:24 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mlst_stack\e[0m = mutable.Stack[\e\
    [35mList\e[0m[\e[35mString\e[0m]]()\n\e[31m\e[31m   |\e[0m                   \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ l2 = lst.size\n        val set1 = new HashSet[Int]()\n        val set2 = new\
    \ HashSet[Int]()\n        for (str <- lst) {\n            val index = str.indexOf(\"\
    (\")\n            if (index < 0)\n                throw new IllegalArgumentException(\"\
    String \" + str + \" has no opening \")\n            for (x <- 0 until str.lastIndexOf(\"\
    )\", index)) {\n                val count = str.length - (x + 1)\n           \
    \     if (set1(count) && set2(count) && set1(count) == set2(count)) {\n      \
    \              return \"No\"\n                }\n                set1(count)\n\
    \                set2(count)\n            }\n        }\n        return \"Yes\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IllegalArgumentException: String ) has no opening \n\tat Problem$.matchParens$$anonfun$1(tmpeojal45w.scala:24)\n\
    \tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\
    \tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat Problem$.matchParens(tmpeojal45w.scala:33)\n\
    \tat Problem$.main(tmpeojal45w.scala:37)\n\tat Problem.main(tmpeojal45w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Write\
    \ your code here\n        var l: Option[String] = None\n        var r: Option[String]\
    \ = None\n        for(str <- lst.head :: lst.tail){\n            if(str == \"\
    (\"){\n                l =  Some(str + lst.head)\n            }\n            if(str\
    \ == \")\"){\n                r = Some(str + lst.tail)\n            }\n      \
    \  }\n        if(l.isEmpty || r.isEmpty){\n            return \"No\"\n       \
    \ }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptp_gs36a.scala:35)\n\tat Problem.main(tmptp_gs36a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ pList = lst.map(lst => (lst, lst.length)).toMap\n        def validParens(lst:\
    \ List[String]): Boolean = {\n            if (lst.length < 2) false\n        \
    \    else {\n                val l1 = lst.head\n                val l2 = lst.last\n\
    \                val l1 = l1.toChar\n                val l2 = l2.toChar\n    \
    \            (pList.get(l1)(l2)) match {\n                    case Some(x) =>\
    \ x._1\n                    case None => false\n                }\n          \
    \  }\n        }\n        validParens(lst) match {\n            case true => \"\
    Yes\"\n            case false => \"No\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_qpv48t6.scala:24:20 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mval\e[0m \e[36ml1\e[0m = l1.toChar\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml1\
    \ is already defined as \e[33mvalue\e[0m \e[35ml1\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_qpv48t6.scala:25:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                \e[33mval\e\
    [0m \e[36ml2\e[0m = l2.toChar\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ml2 is already defined as \e[33mvalue\e[0m \e[35ml2\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmp_qpv48t6.scala:26:26 -----------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                (pList.get(l1)(l2)) \e[33mmatch\e[0m {\n\e[31m\e[31m \
    \  |\e[0m                 ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \e\
    [33mmethod\e[0m \e[35mget\e[0m in \e[33mtrait\e[0m \e[35mMapOps\e[0m does not\
    \ take more parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_qpv48t6.scala:27:36\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    \e[33mcase\e\
    [0m Some(x) => x._1\n\e[31m\e[31m   |\e[0m                                   \
    \ ^\e[0m\n\e[31m   |\e[0m                                    Not found: x\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979976
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ isValid(lst: List[String], i : Int): String = {\n            if (lst(i).charAt(lst(i).length\
    \ - 1) != '(') List(\"No\")\n            else {\n                val cur = lst(i).charAt(0)\n\
    \                val left = isValid(lst, (i - 1))\n                val right =\
    \ isValid(lst, (i - 2))\n                if (left != right) left\n           \
    \     else {\n                    if (cur == '(') right\n                    else\
    \ left\n                }\n            }\n        }\n        val len = lst.size\n\
    \        if (len == 1) lst(0)\n        else if (len == 2) lst(1)\n        else\
    \ isValid(lst, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdkriz5h1.scala:19:61\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (lst(i).charAt(lst(i).length\
    \ - \e[31m1\e[0m) != \e[31m'('\e[0m) List(\e[31m\"No\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                         ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                                  Found:    \e[1m\e\
    [31mList\e[0m\e[1m\e[31m[\e[0mString\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m       \
    \                                           Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Use\
    \ recursion to solve the problem\n        val lst2= lst.map(x => if (x == \"(\"\
    ) 1 else 0).reverse\n        val lst3= lst2.foldLeft(0)(_ + _)\n        if (lst3\
    \ < lst) s\"Yes\" else s\"No\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpa2789cq1.scala:21:17 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (lst3 < lst) \e[31ms\"Yes\"\e[0m\
    \ \e[33melse\e[0m \e[31ms\"No\"\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m\
    \ \e[35m<\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m\
    \  (x: Double): Boolean\n\e[31m   |\e[0m  (x: Float): Boolean\n\e[31m   |\e[0m\
    \  (x: Long): Boolean\n\e[31m   |\e[0m  (x: Int): Boolean\n\e[31m   |\e[0m  (x:\
    \ Char): Boolean\n\e[31m   |\e[0m  (x: Short): Boolean\n\e[31m   |\e[0m  (x: Byte):\
    \ Boolean\n\e[31m   |\e[0m match arguments ((lst : List[String]))\n1 error found\n"
  stdout: ''
  timestamp: 1659979977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      var res\
    \ = \"No\"\n      val open = lst(0)\n      val close = lst(1)\n      var stack\
    \ = List[String]()\n      stack :+= open\n      while (open.length > 0 || close.length\
    \ > 0) {\n        if (open.length == 0) {\n          res = \"Yes\"\n         \
    \ break\n        }\n        if (close.length == 0) {\n          res = \"No\"\n\
    \          break\n        }\n        val x = open(0)\n        val y = close(0)\n\
    \        val newOpen = open.drop(1)\n        val newClose = close.drop(1)\n  \
    \      if (y == \"(\") {\n          if (stack.isEmpty) {\n            res = \"\
    No\"\n            break\n          }\n          if (stack == newOpen) {\n    \
    \        stack :+= y\n          }\n          if (stack == newClose) {\n      \
    \      stack :+= y\n          }\n          if (stack == newOpen || stack == newClose)\
    \ {\n            res = \"No\"\n            break\n          }\n        } else\
    \ {\n          if (stack.isEmpty) {\n            res = \"No\"\n            break\n\
    \          }\n          if (stack == newClose) {\n            stack :+= y\n  \
    \        }\n          if (stack == newOpen || stack == newClose) {\n         \
    \   res = \"No\"\n            break\n          }\n        }\n        open += x\n\
    \        close += y\n      }\n      res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpubtqumce.scala:26:10 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m          break\n\e[31m\e[31m   |\e[0m          ^^^^^\e\
    [0m\n\e[31m   |\e[0m          Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpubtqumce.scala:30:10 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m          break\n\e[31m\e[31m   |\e[0m          ^^^^^\e\
    [0m\n\e[31m   |\e[0m          Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpubtqumce.scala:36:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mif\e[0m (y == \e[31m\"(\"\e[0m) {\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpubtqumce.scala:39:12 ------------------------\e[0m\e[0m\n\
    \e[31m39 |\e[0m            break\n\e[31m\e[31m   |\e[0m            ^^^^^\e[0m\n\
    \e[31m   |\e[0m            Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpubtqumce.scala:41:14 -----------------------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m          \e[33mif\e[0m (stack == newOpen) {\n\e[31m\e\
    [31m   |\e[0m              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of types\
    \ List[String] and String cannot be compared with == or !=\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpubtqumce.scala:42:18 ------------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m            stack :+= y\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue :+= is not a member of List[String] - did\
    \ you mean List[String].:+?\n\e[31m\e[31m-- Error: /tmp/tmpubtqumce.scala:44:14\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m44 |\e[0m       \
    \   \e[33mif\e[0m (stack == newClose) {\n\e[31m\e[31m   |\e[0m              ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mValues of types List[String] and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E008] "
  stdout: ''
  timestamp: 1659979983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ openings = lst.map( _.length )\n        val closings = lst.map( _.length )\n\
    \        val openingMap = mutable.Map.empty[Int, Int]\n        val closingMap\
    \ = mutable.Map.empty[Int, Int]\n        lst.foreach( x => {\n            if(\
    \ (openings(x) != 0) || (closings(x) != 0) ) {\n                openingMap +=\
    \ (openings(x) -> (x + 1))\n                closingMap += (closings(x) -> (x +\
    \ 1))\n            }\n        })\n        if( (openingMap == closingMap) && (openings\
    \ == closings) ) {\n            return \"Yes\"\n        } else {\n           \
    \ return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkg5u0bde.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopeningMap\e[0m = mutable.Map.empty[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkg5u0bde.scala:21:25 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclosingMap\e[0m = mutable.Map.empty[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkg5u0bde.scala:23:26 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m( (openings(x) != \e[31m0\e\
    [0m) || (closings(x) != \e[31m0\e[0m) ) {\n\e[31m\e[31m   |\e[0m             \
    \             ^\e[0m\n\e[31m   |\e[0m                          Found:    (x :\
    \ String)\n\e[31m   |\e[0m                          Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkg5u0bde.scala:23:48 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m( (openings(x) != \e[31m0\e\
    [0m) || (closings(x) != \e[31m0\e[0m) ) {\n\e[31m\e[31m   |\e[0m             \
    \                                   ^\e[0m\n\e[31m   |\e[0m                  \
    \                              Found:    (x : String)\n\e[31m   |\e[0m       \
    \                                         Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n       val stack\
    \ = new mutable.Stack[Int]()\n       lst.foreach(x => stack += x.length)\n   \
    \    if(stack.last < 0)\n         return \"No\"\n       while(stack.last > 0)\
    \ {\n          if(stack.last > 1) {\n             stack -= 2\n             stack\
    \ += 2\n          }\n          val len = stack.pop()\n          if(len < 0)\n\
    \             return \"No\"\n          else if(len > 0)\n             stack.push(stack.last\
    \ - len)\n       }\n       if(stack.last == 0)\n        return \"Yes\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq3si8lvt.scala:18:23 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m       \e[33mval\e[0m \e[36mstack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq3si8lvt.scala:33:7\
    \ ---------------------\e[0m\e[0m\n\e[31m33 |\e[0m       \e[33mif\e[0m(stack.last\
    \ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m       ^\e[0m\n\e[31m   |\e[0m      \
    \ Found:    Unit\n\e[31m   |\e[0m       Required: String\n\e[31m   |\e[0m    \
    \   Maybe you are missing an else part for the conditional?\n\e[31m34 |\e[0m \
    \       \e[33mreturn\e[0m \e[31m\"Yes\"\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ stackCounts(s : List[String], r : List[String], i : Int) : Int = {\n       \
    \     val stk = ArrayBuffer(s.head).init\n\n            var count : Int = 0\n\
    \            var stack : List[String] = stk\n\n            while(i < l.length){\n\
    \                if(l(i) == \"(\"){\n                    count += stackCounts(stack.pop,\
    \ l(i + 1), 1)\n                    stack += l(i + 1)\n                }\n   \
    \             i += 1\n            }\n\n            count\n        }\n\n      \
    \  val l = lst.head\n        val stk = ArrayBuffer(l).init\n\n        var count\
    \ : Int = 0\n        var stack : List[String] = stk\n\n        while(stack.length\
    \ > 0){\n            count += stackCounts(stack.pop, lst.last, 1)\n        }\n\
    \n        if(count == l.length)\n            return \"Yes\"\n        else\n  \
    \          return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0ufotzmc.scala:22:39\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mvar\e[0m \e\
    [36mstack\e[0m : \e[35mList\e[0m[\e[35mString\e[0m] = stk\n\e[31m\e[31m   |\e\
    [0m                                       ^^^\e[0m\n\e[31m   |\e[0m          Found:\
    \    (stk : scala.collection.mutable.ArrayBuffer[String])\n\e[31m   |\e[0m   \
    \       Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp0ufotzmc.scala:25:19\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m25 |\e[0m       \
    \         \e[33mif\e[0m(l(i) == \e[31m\"(\"\e[0m){\n\e[31m\e[31m   |\e[0m    \
    \               ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types Char\
    \ and String cannot be compared with == or !=\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp0ufotzmc.scala:26:26 ------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                    count += stackCounts(stack.pop, l(i + \e[31m1\e[0m),\
    \ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  value += is not a member of Int - did you mean Int.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0ufotzmc.scala:26:47 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    count += stackCounts(stack.pop, l(i\
    \ + \e[31m1\e[0m), \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue pop is not a member of\
    \ List[String] - did you mean List[String].drop?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp0ufotzmc.scala:26:53 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                    count += stackCounts(stack.pop, l(i + \e[31m1\e[0m),\
    \ \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \                 Found:    Char\n\e[31m   |\e[0m                            \
    \                      Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp0ufotz"
  stdout: ''
  timestamp: 1659979985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ matchParen(st: List[String], acc : List[String], acc2: (List[String], List[String],\
    \ Int)): (List[String], List[String], Int) = {\n            if (st.head == \"\
    ()\") {\n                matchParen(st.tail, acc.reverse, acc2)\n            }\
    \ else if (st.head == \"[]\") {\n                matchParen(st.tail, acc, acc2)\n\
    \            } else if (st.head == \"{}\") {\n                matchParen(st.tail,\
    \ acc.reverse, acc2)\n            } else if (st.head == \")\") {\n           \
    \     if (acc.head == \"()\") {\n                    if (acc.last == \"()\") {\n\
    \                        acc\n                    } else {\n                 \
    \       matchParen(st.tail, acc, acc2)\n                    }\n              \
    \  } else if (acc.head == \"[]\") {\n                    if (acc.last == \"[]\"\
    ) {\n                        acc\n                    } else {\n             \
    \           matchParen(st.tail, acc, acc2)\n                    }\n          \
    \      } else if (acc.head == \"{}\") {\n                    if (acc.last == \"\
    {}\") {\n                        acc\n                    } else {\n         \
    \               matchParen(st.tail, acc, acc2)\n                    }\n      \
    \          } else if (acc.head == \"]\") {\n                    if (acc.last ==\
    \ \"[]\") {\n                        acc\n                    } else {\n     \
    \                   matchParen(st.tail, acc, acc2)\n                    }\n  \
    \              } else if (acc.head == \"}\") {\n                    if (acc.last\
    \ == \"{}\") {\n                        acc\n                    } else {\n  \
    \                      matchParen(st.tail, acc, acc2)\n                    }\n\
    \                } else {\n                    if (acc.last == st.head) {\n  \
    \                      matchParen(st.tail, acc, acc2)\n                    } else\
    \ {\n                        matchParen(st.tail, acc.reverse ++ List(\"()\"),\
    \ acc2)\n                    }\n                }\n            } else if (st.head\
    \ == \"[\") {\n                if (acc.head == \"()\") {\n                   \
    \ if (acc.last == \"()\") {\n                        acc\n                   \
    \ } else {\n                        matchParen(st.tail, acc, acc2)\n         \
    \           }\n                } else if (acc.head == \"[]\") {\n            \
    \        if (acc.last == \"[]\") {\n                        acc\n            \
    \        } else {\n                        matchParen(st.tail, acc, acc2)\n  \
    \                  }\n                } else if (acc.head == \"{}\") {\n     \
    \               if (acc.last == \"{}\") {\n                        acc\n     \
    \               } else {\n                        matchParen(st.tail, acc, acc2)\n\
    \                    }\n                } else if (acc.head == \"]\") {\n    \
    \                if (acc.last == \"[]\") {\n                        acc\n    \
    \                } else {\n                        matchParen(st.tail, acc, acc2)\n\
    \                    }\n                } else if (acc.head == \"}\") {\n    \
    \                if (acc.last == \"{}\") {\n                        acc\n    \
    \                } else {\n                        matchParen(st.tail, acc, acc2)\n\
    \                    }\n                } else {\n                    if (acc.last\
    \ == st.head) {\n                        matchParen(st.tail, acc, acc2)\n    \
    \                } else {\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwv70rl6e.scala:115:0 ---------------------------\e\
    [0m\e[0m\n\e[31m115 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwv70rl6e.scala:28:24\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                        acc\n\
    \e[31m\e[31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0m       \
    \                 Found:    (\e[1m\e[31macc\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e\
    [0m List[String])\n\e[31m   |\e[0m                        Required: (\e[1m\e[32mList\e\
    [0m\e[1m\e[32m[\e[0m\e[1m\e[32mString\e[0m\e[1m\e[32m]\e[0m\e[1m\e[32m,\e[0m List[String]\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0m\e[1m\e[32mInt\e[0m)\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpwv70rl6e.scala:34:24 --------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                        acc\n\e[31m\e[31m   |\e[0m  \
    \                      ^^^\e[0m\n\e[31m   |\e[0m                        Found:\
    \    (\e[1m\e[31macc\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m List[String])\n\e\
    [31m   |\e[0m                        Required: (\e[1m\e[32mList\e[0m\e[1m\e[32m[\e\
    [0m\e[1m\e[32mString\e[0m\e[1m\e[32m]\e[0m\e[1m\e[32m,\e[0m List[String]\e[1m\e\
    [32m,\e[0m\e[1m\e[32m \e[0m\e[1m\e[32mInt\e[0m)\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpwv70rl6e.scala:40:24 --------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                        acc\n\e[31m\e[31m   |\e[0m  \
    \                      ^^^\e[0m\n\e[31m   |\e[0m                        Found:\
    \    (\e[1m\e[31macc\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m List[String])\n\e\
    [31m   |\e[0m                        Required: (\e[1m\e[32mList\e[0m\e[1m\e[32m[\e\
    [0m\e[1m\e[32mString\e[0m\e[1m\e[32m]\e[0m\e[1m\e[32m,\e[0m List[String]\e[1m\e\
    [32m,\e[0m\e[1m\e[32m \e[0m\e[1m\e[32mInt\e[0m)\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpwv70rl6e.scala:46:24 --------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                        acc\n\e[31m\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659979983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stackList = mutable.ListBuffer[String]()\n\
    \n        for(x<-lst){\n            if(x==\"(\")\n            stack += x\n   \
    \         if(x==\")\"){\n                stackList += stack.toList\n         \
    \       stack.clear()\n            }\n        }\n        stackList match {\n \
    \           case x if(x == stack.toList) => \"Yes\"\n            case x if(x!=stack.toList)\
    \ => \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8h07wplb.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8h07wplb.scala:19:24 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mstackList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val (_,\
    \ _, s1) = lst\n      val (_, _, s2) = lst.reverse\n      val p1 = s1.map(c =>\
    \ if (c == '(') '!' else '!').toChar\n      val p2 = s2.map(c => if (c == '(')\
    \ '!' else '!').toChar\n      val a = p1 ++ p2\n      val b = a.zipWithIndex.map\
    \ { case (l, i) => if (l == '!') i.toString else l}\n      val index = b.indexOf(0)\n\
    \      (index != -1) && (\"Yes\")\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa48pl2c5.scala:20:18 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m      \e[33mval\e[0m \e[36mp1\e[0m = s1.map(\e[36mc\e\
    [0m => \e[33mif\e[0m (c == \e[31m'('\e[0m) \e[31m'!'\e[0m \e[33melse\e[0m \e[31m'!'\e\
    [0m).toChar\n\e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \               value map is not a member of Any\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpa48pl2c5.scala:21:18 ------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m      \e[33mval\e[0m \e[36mp2\e[0m = s2.map(\e[36mc\e[0m => \e[33mif\e\
    [0m (c == \e[31m'('\e[0m) \e[31m'!'\e[0m \e[33melse\e[0m \e[31m'!'\e[0m).toChar\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  value map is not a member of Any\n2 errors found\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ str = lst.mkString(\"(\", \"\", \")\")\n        val set = sc.parallelize(str.split(\"\
    \\\\(\")).distinct\n        val map = set.map(r => (r, 1)).reduceByKey(_ + _).map{\
    \ case (r, (i, j)) => (i, j, r) }.toMap\n        val len = lst.size\n        def\
    \ checker(i : Int) : Boolean = {\n            if (i > len - 1) false else if (map(i)\
    \ > (map.size - len)) false else if (map(i) < map(len - 1)) checker(i + 1)\n \
    \           else check(i, map.size - 1) || checker(i + 1)\n        }\n       \
    \ val res = checker(0)\n        if (res) \"Yes\" else \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmzj66p3e.scala:19:18 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mset\e[0m = sc.parallelize(str.split(\e\
    [31m\"\\\\(\"\e[0m)).distinct\n\e[31m\e[31m   |\e[0m                  ^^\e[0m\n\
    \e[31m   |\e[0m                  Not found: sc\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpmzj66p3e.scala:24:17 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33melse\e[0m check(i, map.size - \e[31m1\e\
    [0m) || checker(i + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                 ^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Not found: check\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ lst1 = lst.tail\n        val lst2 = lst.head\n        if (lst1 == lst2) {\n\
    \            \"Yes\"\n        } else {\n            val lst3 = lst1 -- lst2\n\
    \            val lst4 = lst2 -- lst3\n            lst4.foldLeft(\"\"){ (s, x)\
    \ => s ++ x }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp9r_2fa27.scala:20:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (lst1 == lst2) {\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of types List[String]\
    \ and String cannot be compared with == or !=\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp9r_2fa27.scala:23:28 ------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            \e[33mval\e[0m \e[36mlst3\e[0m = lst1 -- lst2\n\e[31m\e[31m\
    \   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \        value -- is not a member of List[String]\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp9r_2fa27.scala:24:28 ------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m            \e[33mval\e[0m \e[36mlst4\e[0m = lst2 -- lst3\n\e[31m\e[31m\
    \   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \        value -- is not a member of String\n3 errors found\n"
  stdout: ''
  timestamp: 1659979987
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ isValidParenthesis(s  : String) : Boolean = {\n            val l = s.toList\n\
    \            l.size < 2 || l.last != \"(\" && l.first != \")\"\n        }\n  \
    \      val map = new scala.collection.mutable.HashMap[String,String]()\n     \
    \   for(x <- lst ) map(x) += \"*\"\n        val ls = map.toSeq\n        ls.sortBy(_._1).reverse\
    \ // sort by key then reverse\n        val result = ls.find(_._2 == \"*\").map(_._1)\n\
    \        if(!result.get.isEmpty) result else \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp0wxu3ltj.scala:20:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            l.size < \e[31m2\e[0m || l.last != \e[31m\"\
    (\"\e[0m && l.first != \e[31m\")\"\e[0m\n\e[31m\e[31m   |\e[0m               \
    \           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types Char and\
    \ String cannot be compared with == or !=\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp0wxu3ltj.scala:20:45 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m            l.size < \e[31m2\e[0m || l.last != \e[31m\"(\"\e[0m && l.first\
    \ != \e[31m\")\"\e[0m\n\e[31m\e[31m   |\e[0m                                 \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m        value first is not a member of\
    \ List[Char] - did you mean l.find?\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp0wxu3ltj.scala:27:32 --------------------\e[0m\e[0m\n\e[31m27 |\e[0m\
    \        \e[33mif\e[0m(!result.get.isEmpty) result \e[33melse\e[0m \e[31m\"No\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                                ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                Found:    (result : Option[String])\n\
    \e[31m   |\e[0m                                Required: String\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ final = lst(0)\n        val stack = new mutable.Stack[String]()\n        for(a\
    \ <- lst) {\n            if(!stack.isEmpty) {\n                if(stack.toList.last\
    \ == (a)) {\n                    stack.poll()\n                } else {\n    \
    \                return \"No\"\n                }\n            }\n           \
    \ stack += a\n        }\n        if(stack.size == 0) {\n            return \"\
    Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpyidp055t.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[33mfinal\e[0m = lst(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m            ^^^^^\e[0m\n\e[31m   |\e[0m           \
    \ pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyidp055t.scala:19:24\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = \e[33mnew\e[0m mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ flag = 0\n        val stack = new mutable.Stack[String]()\n        val stack2\
    \ = new mutable.Stack[String]()\n        val stack3 = new mutable.Stack[String]()\n\
    \n        for(i <- 0 until lst.size) {\n            if((lst(i) == \"(\" && stack.nonEmpty)\
    \ || (lst(i) == \")\" && stack.nonEmpty)) {\n                stack3 += lst(i).substring(stack3.size,\
    \ stack3.size + 1)\n                flag += 1 // stack flag\n            }\n \
    \           else if(lst(i) == \"(\" && stack.isEmpty) {\n                stack\
    \ += lst(i)\n                flag += 1 // stack flag\n            }\n        \
    \    else if(lst(i) == \")\" && stack.isEmpty) {\n                stack2 += lst(i)\n\
    \                flag += 1 // stack flag\n            }\n            else if(lst(i)\
    \ == \")\" && stack2.nonEmpty && stack3.nonEmpty) {\n                val s = stack2.pop\
    \ + stack3.pop\n                stack2 += s\n                stack3 += s\n   \
    \             flag += 2 // stack flag\n            }\n            else if(lst(i)\
    \ == \"(\" && stack2.nonEmpty) {\n                val s = stack2.pop + lst(i)\n\
    \                stack2 += s\n                flag += 2 // stack flag\n      \
    \      }\n            else if(lst(i) == \")\" && stack2.nonEmpty && stack.nonEmpty)\
    \ {\n                val s = stack2.pop + stack.pop\n                stack2 +=\
    \ s\n                flag += 2 // stack flag\n            }\n            else\
    \ if(lst(i) == \"(\" && stack.nonEmpty && stack3.nonEmpty) {\n               \
    \ val s = stack.pop + stack3.pop\n                stack += s\n               \
    \ flag += 2 // stack flag\n            }\n            else if(lst(i) == \")\"\
    \ && stack.nonEmpty && stack3.nonEmpty) {\n                val s = stack.pop +\
    \ stack3.pop\n                stack += s\n                flag += 2 // stack flag\n\
    \            }\n            else if(lst(i) == \"(\" && stack2.nonEmpty && stack.nonEmpty)\
    \ {\n                val s = stack2.pop + stack.pop\n                stack2 +=\
    \ s\n                flag += 2 // stack flag\n            }\n            else\
    \ if(lst(i) == \")\" && stack2.nonEmpty && stack.nonEmpty) {\n               \
    \ val s = stack2.pop + stack.pop\n                stack2 += s\n              \
    \  flag += 2 // stack flag\n            }\n            else if(lst(i) == \")\"\
    \ && stack.nonEmpty && stack2.nonEmpty) {\n                val s = stack.pop +\
    \ stack2.pop\n                stack += s\n                flag += 2 // stack flag\n\
    \            }\n            else if(lst(i) == \"(\" && stack2.non\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpppylnm9g.scala:78:4 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpppylnm9g.scala:95:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m95 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpppylnm9g.scala:19:24 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = \e[33mnew\e[0m mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpppylnm9g.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mstack2\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpppylnm9g.scala:21:25\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = \e[33mnew\e[0m mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpppylnm9g.scala:94:1 ---------------------\e[0m\e[0m\n\e[31m94\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpppylnm9g.scala:79:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m79 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33"
  stdout: ''
  timestamp: 1659979988
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ a: List[String] = lst\n        var temp: List[String] = Nil\n        while(!a.isEmpty)\
    \ {\n            if(a.head == \")\") {\n                temp = a :: temp\n   \
    \             a = a.tail\n                if(!a.isEmpty) {\n                 \
    \   a.remove(0)\n                }\n            }\n            else {\n      \
    \          temp = a :: temp\n                a = a.tail\n                if(!a.isEmpty)\
    \ {\n                    a.remove(0)\n                }\n            }\n     \
    \   }\n        if(temp.isEmpty) {\n            return \"Yes\"\n        }\n   \
    \     else {\n            return \"No\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp382gfcgi.scala:22:23\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m                temp = a :: temp\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             Found:    (a : List[String])\n\e[31m   |\e[0m                  \
    \     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp382gfcgi.scala:25:22\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                    a.remove(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue remove is not a member of List[String], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp382gfcgi.scala:29:23\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                temp = a :: temp\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             Found:    (a : List[String])\n\e[31m   |\e[0m                  \
    \     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp382gfcgi.scala:32:22\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m                    a.remove(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue remove is not a member of List[String], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import co"
  stdout: ''
  timestamp: 1659979990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        for (i <- 0 until lst.length) {\n            if (lst(i) == \"(\" && stack.nonEmpty)\
    \ {\n                val top = stack.pop()\n                if (top != \"(\")\
    \ {\n                    queue += top\n                }\n            } else if\
    \ (lst(i) == \")\" && stack.nonEmpty && queue.isEmpty) {\n                stack\
    \ += \")\"\n            } else if (lst(i) == \")\") {\n                stack +=\
    \ \")\"\n            } else if (lst(i) == \"(\") {\n                queue += \"\
    (\"\n            }\n        }\n        if (stack.nonEmpty && stack.last.equals(\"\
    (\")) {\n            return \"Yes\"\n        }\n        return \"No\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptuz8_o3x.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmptuz8_o3x.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979986
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ openParens = Set(\"(\")\n        val closeParens = Set(\")\") \n        val\
    \ lst = lst.sorted\n        if (lst.head != lst.tail.head) (\"No\") \n       \
    \ else if (openParens.isEmpty || closeParens.isEmpty) { (\"No\") }\n        else\
    \ (findMatch(lst.head)) match {\n            case (Some(findMatch(lst.head)) if\
    \ findMatch(lst.head) == lst.head && lst.head.head == lst.head.tail ) => \"Yes\"\
    \n            case _ => \"No\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcoypj25m.scala:24:44 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m (Some(findMatch(lst.head))\
    \ \e[33mif\e[0m findMatch(lst.head) == lst.head && lst.head.head == lst.head.tail\
    \ ) => \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e[0m                             \
    \               ^^\e[0m\n\e[31m   |\e[0m                                     \
    \       ')' expected, but 'if' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcoypj25m.scala:20:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlst\e[0m = lst.sorted\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35mlst\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcoypj25m.scala:23:14\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m (findMatch(lst.head))\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m              ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m              Not found: findMatch\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcoypj25m.scala:24:23 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m (Some(findMatch(lst.head))\
    \ \e[33mif\e[0m findMatch(lst.head) == lst.head && lst.head.head == lst.head.tail\
    \ ) => \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Not found: findMatch\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659979985
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ p = lst.filter(_.toList.length == 1).head\n        val q = lst.filter(_.toList.length\
    \ == 0).head\n        if(lst.contains(p) && lst.contains(q)){\n            val\
    \ n = new Stack[String]()\n            for(i <- 0 until lst.size){\n         \
    \       if(i == p.toString.length){\n                    n.push(\"(\")\n     \
    \           }else if(lst.contains(p.toString.substring(0,i))){\n             \
    \       n.push(p.toString.substring(0,i))\n                }else{\n          \
    \          n.push(p.toString.substring(0,i) + n.pop())\n                }\n  \
    \          }\n            if(n.toString.equals(\"(\")){\n                \"Yes\"\
    \n            }else{\n                \"No\"\n            }\n        }else{\n\
    \            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.matchParens(tmp8vhlinbr.scala:19)\n\
    \tat Problem$.main(tmp8vhlinbr.scala:41)\n\tat Problem.main(tmp8vhlinbr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979992
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ rec(stack: List[String], currStack: List[String], i : Int) : List[String] =\
    \ {\n            if (i == lst.size) {\n                if (currStack == lst.head)\
    \ {\n                    return stack\n                }\n            }\n    \
    \        if (i == 0) {\n                if (currStack.size != lst.head.size) {\n\
    \                    return \"No\"\n                }\n                else {\n\
    \                    val stackCopy = stack.clone()\n                    val currStackCopy\
    \ = currStack.clone()\n                    while (stackCopy.nonEmpty && currStackCopy.nonEmpty\
    \ && stackCopy.head == currStackCopy.head) {\n                        stackCopy\
    \ = stackCopy.tail\n                        currStackCopy = currStackCopy.tail\n\
    \                    }\n                    if (stackCopy.nonEmpty || currStackCopy.nonEmpty)\
    \ {\n                        val stackCopyStr = stackCopy.mkString(\"\")\n   \
    \                     val currStackCopyStr = currStackCopy.mkString(\"\")\n  \
    \                      if (currStackCopyStr == stackCopyStr) {\n             \
    \               return \"Yes\"\n                        }\n                  \
    \  }\n                }\n            }\n            val nextOpen = lst.head(i)\
    \ match {\n                case '(' => true\n                case ')' => true\n\
    \                case _ => false\n            }\n            if (nextOpen && stack.size\
    \ < lst.head.size) {\n                currStack.push(lst.head(i))\n          \
    \      val newStack = stack.tail +: currStack.tail\n                rec(newStack,\
    \ lst, i + 1)\n                currStack = currStack.tail\n            }\n   \
    \         else {\n                rec(stack, currStack, i + 1)\n            }\n\
    \        }\n        rec(new ListBuffer[String](), new ListBuffer[String](), 0)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpaivos_sv.scala:20:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33mif\e[0m (currStack == lst.head)\
    \ {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mValues of types List[String] and String cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaivos_sv.scala:26:27\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                    \e[33mreturn\e\
    [0m \e[31m\"No\"\e[0m\n\e[31m\e[31m   |\e[0m                           ^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    (\e[32m\"No\"\e[0m :\
    \ String)\n\e[31m   |\e[0m                           Required: List[String]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpaivos_sv.scala:29:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    \e[33mval\e[0m \e[36mstackCopy\e\
    [0m = stack.clone()\n\e[31m\e[31m   |\e[0m                                   \
    \ ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\e[33mmethod\e[0m \e[35mclone\e[0m in \e[33mclass\e\
    [0m \e[35mObject\e[0m cannot be accessed as a member of (stack : List[String])\
    \ from module class Problem$.\n\e[31m   |\e[0m Access to protected \e[33mmethod\e\
    [0m \e[35mclone\e[0m not permitted because prefix type List[String]\n\e[31m  \
    \ |\e[0m does not conform to \e[33mobject\e[0m \e[35mProblem\e[0m where the access\
    \ takes place\n\e[31m\e[31m-- Error: /tmp/tmpaivos_sv.scala:30:50 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    \e[33mval\e[0m \e[36mcurrStackCopy\e\
    [0m = currStack.clone()\n\e[31m\e[31m   |\e[0m                               \
    \         ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\e[33mmethod\e[0m \e[35mclone\e\
    [0m in \e[33mclass\e[0m \e[35mObject\e[0m cannot be accessed as a member of (currStack\
    \ : List[String]) from module class Problem$.\n\e[31m   |\e[0m Access to protected\
    \ \e[33mmethod\e[0m \e[35mclone\e[0m not permitted because prefix type List[String]\n\
    \e[31m   |\e[0m does not conform to \e[33mobject\e[0m \e[35mProblem\e[0m where\
    \ the access takes place\n\e[31m\e[31m-- [E052] Type Err"
  stdout: ''
  timestamp: 1659979992
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ good = True\n        val left  = lst.head\n        val right = lst(1 until lst.size)\n\
    \        val leftList = lst.take(left.length)\n        val rightList = lst.drop(right.length)\n\
    \        var i = leftList.size\n        while (i < leftList.size) {\n        \
    \    if (right(i) != left(i)) {\n                good = False\n              \
    \  break\n            }\n            i += 1\n        }\n        if (good)\n  \
    \          \"Yes\"\n        else\n            \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptftiyv98.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36mgood\e[0m = True\n\e[31m\e\
    [31m   |\e[0m                   ^^^^\e[0m\n\e[31m   |\e[0m                   Not\
    \ found: True\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptftiyv98.scala:20:24\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mright\e\
    [0m = lst(\e[31m1\e[0m until lst.size)\n\e[31m\e[31m   |\e[0m                \
    \        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        Found:\
    \    Range\n\e[31m   |\e[0m                        Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptftiyv98.scala:26:23 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                good = False\n\e[31m\e[31m   |\e[0m \
    \                      ^^^^^\e[0m\n\e[31m   |\e[0m                       Not found:\
    \ False\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptftiyv98.scala:27:16\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // TODO:\n\
    \        // Write your code here\n        var str = lst(0).mkString(\"\")\n  \
    \      var flag = true\n        for(i <- 1L to lst.size) {\n            str +=\
    \ lst(i)\n            if(str.charAt(str.length-1) != '(' || str.charAt(0) == '(')\
    \ {\n                flag = false\n            }\n            str += lst(i)\n\
    \        }\n        if(flag) return \"Yes\"\n        return \"No\"\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpofwnia5_.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            str += lst(i)\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of String\
    \ - did you mean String.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpofwnia5_.scala:23:23\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            str += lst(i)\n\e\
    [31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m            \
    \           Found:    (i : Long)\n\e[31m   |\e[0m                       Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpofwnia5_.scala:27:16\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            str += lst(i)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpofwnia5_.scala:27:23 --------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m            str += lst(i)\n\e[31m\e[31m   |\e[0m         \
    \              ^\e[0m\n\e[31m   |\e[0m                       Found:    (i : Long)\n\
    \e[31m   |\e[0m                       Required: Int\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979992
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ n = lst.size\n        if (n == 0) {\n          \"No\"\n        } else if (n\
    \ == 1) {\n          val p1 = lst(0) match {\n            case \"(\" : true\n\
    \            case \")\" : true\n            case _ : false\n          }\n    \
    \      if (p1) {\n            \"Yes\"\n          } else {\n            \"No\"\n\
    \          }\n        } else {\n          val m = lst.foldLeft(0)((m, n) => if\
    \ (n <= m) n + 1 else n)\n          val goodStrings = (1 to m).map { x =>\n  \
    \          (1 to n).map { y =>\n              if (x != y && lst.exists(y => lst(y)\
    \ == \"(\" && lst(y - 1) == \"(\" && lst(y - 2) == \")\")) return true\n     \
    \         else false\n            }\n          }.flatten.filter(x => x).mkString(\"\
    ,\")\n          if (goodStrings == \"false\") \"No\" else \"Yes\"\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzj1m89md.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m \e[31m\")\"\e[0m : \e[31mtrue\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            '=>'\
    \ expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzj1m89md.scala:26:10\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m          }\n\e[31m\e\
    [31m   |\e[0m          ^\e[0m\n\e[31m   |\e[0m          '=>' expected, but '}'\
    \ found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzj1m89md.scala:23:17\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m \e\
    [31m\"(\"\e[0m : \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m                 ^^^\e\
    [0m\n\e[31m   |\e[0m                 Found:    (\e[32m\"(\"\e[0m : String)\n\e\
    [31m   |\e[0m                 Required: (\e[31mtrue\e[0m : Boolean)\n\e[31m  \
    \ |\e[0m                 pattern type is incompatible with expected type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzj1m89md.scala:27:14 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m          \e[33mif\e[0m (p1) {\n\e[31m\e[31m   |\e[0m\
    \              ^^\e[0m\n\e[31m   |\e[0m              Found:    (p1 : Unit)\n\e\
    [31m   |\e[0m              Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpzj1m89md.scala:33:53 --------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m          \e[33mval\e[0m \e[36mm\e[0m = lst.foldLeft(\e\
    [31m0\e[0m)((\e[36mm\e[0m, \e[36mn\e[0m) => \e[33mif\e[0m (n <= m) n + \e[31m1\e\
    [0m \e[33melse\e[0m n)\n\e[31m\e[31m   |\e[0m                                \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \                     Found:    (m : Int)\n\e[31m   |\e[0m                   \
    \                                  Required: String\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpzj1m89md.scala:33:56 --------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m       "
  stdout: ''
  timestamp: 1659979993
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ str = lst.last\n        val lst1 = lst.init drop 1\n        var isGood = True\n\
    \        val stack = new Stack[String]\n        val lst2 = lst1.map(x => x.toChar).map(x\
    \ => x.toInt)\n        val lst3 = lst.map(x => x.toChar).map(x => x.toInt)\n \
    \       for(i <- lst3) stack.push(\"\" + i)\n        for(i <- lst2) stack.push(i.toString\
    \ + stack.pop())\n        val goodStr = stack.pop()\n        if(goodStr == str)\
    \ isGood\n        else isGood.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp41e18xu0.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e[36misGood\e[0m = True\n\e[31m\e\
    [31m   |\e[0m                     ^^^^\e[0m\n\e[31m   |\e[0m                 \
    \    Not found: True\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp41e18xu0.scala:22:35\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mlst2\e[0m = lst1.map(\e[36mx\e[0m => x.toChar).map(\e[36mx\e[0m => x.toInt)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                 value toChar is not a member of String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp41e18xu0.scala:22:54 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mlst2\e[0m = lst1.map(\e\
    [36mx\e[0m => x.toChar).map(\e[36mx\e[0m => x.toInt)\n\e[31m\e[31m   |\e[0m  \
    \                                                  ^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue toInt is not a member of Nothing, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp41e18xu0.scala:23:34 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mlst3\e[0m = lst.map(\e[36mx\e\
    [0m => x.toChar).map(\e[36mx\e[0m => x.toInt)\n\e[31m\e[31m   |\e[0m         \
    \                       ^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \         value toChar is not a member of String\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp41e18xu0.scala:23:53 ----------------------"
  stdout: ''
  timestamp: 1659979993
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ set1 = lst.map(x => if (x == \"(\") 1 else 0)\n        val set2 = lst.map(x\
    \ => if (x == \"()\") 0 else 1)\n        val set3 = set1 ++ set2\n        val\
    \ set4 = lst.map(x => if (x == \"(()\") 0 else 1)\n        val set5 = set4 ++\
    \ set3\n        val set6 = lst.map(x => if (x == \")\") 0 else 1)\n        val\
    \ set7 = set5 ++ set6\n        if (set7.distinct.size == lst.size && set7.distinct.size\
    \ == set1.size + set2.size && set7.distinct.size == set4.size + set3.size + set6.size\
    \ && set7.distinct.size == set5.size + set6.size) {\n            val result =\
    \ set7.distinct\n            val str = result.mkString(\"(\", \", \", \")\")\n\
    \            if (str.length == lst.size && str.size == set1.size + set2.size +\
    \ set4.size + set3.size + set5.size + set6.size) {\n                return \"\
    Yes\"\n            }\n        }\n        return \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgbm5wm2v.scala:35)\n\tat Problem.main(tmpgbm5wm2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979994
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = Stack[String]()\n        val leftmost = Stack[String]()\n        lst.foreach(elem\
    \ => {\n            val open = elem.substring(0, elem.indexOf(\"(\"))\n      \
    \      val close = elem.substring(elem.indexOf(\"(\"))\n            if (stack.isEmpty\
    \ && (elem.indexOf(\"(\") <= elem.indexOf(\")\"))) stack.append(open)\n      \
    \      if (stack.isEmpty && (elem.indexOf(\"(\") < elem.indexOf(\")\")) && (close.length\
    \ == 0)) stack.append(close)\n            if (open != \"\") leftmost.append(open)\n\
    \            if (close != \"\") leftmost.append(close)\n        })\n        if\
    \ (leftmost.size == 2) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 0, end -1, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.matchParens$$anonfun$1(tmplunju7ml.scala:21)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\
    \tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\tat scala.collection.immutable.List.foreach(List.scala:333)\n\
    \tat Problem$.matchParens(tmplunju7ml.scala:27)\n\tat Problem$.main(tmplunju7ml.scala:31)\n\
    \tat Problem.main(tmplunju7ml.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val res = new collection.mutable.StringBuilder\n\
    \        for (x <- lst) {\n            if (x match {\n                \"(\" =>\n\
    \                    stack.push(x)\n                case \")\" =>\n          \
    \          while (!stack.isEmpty) {\n                        if (stack.peek()\
    \ match {\n                            \"(\" =>\n                            \
    \    stack.pop()\n                            case \")\" =>\n                \
    \                res.append(\"(\")\n                                res.append(\"\
    )\")\n                            case _ =>\n                                res.append(stack.pop())\n\
    \                        }) else\n                            res.append(stack.pop())\n\
    \                    }\n                case \"(\" =>\n                    stack.push(x)\n\
    \                case \")\" =>\n                    res.append(\"(\")\n      \
    \          }) else\n                    res.append(x)\n        }\n        res.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzhv23rq1.scala:22:16 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[31m\"(\"\e[0m =>\n\e[31m\e[31m   |\e\
    [0m                ^\e[0m\n\e[31m   |\e[0m                'case' expected, but\
    \ string literal found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzhv23rq1.scala:41:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                }) \e\
    [33melse\e[0m\n\e[31m\e[31m   |\e[0m                   ^^^^\e[0m\n\e[31m   |\e\
    [0m                   'then' expected, but 'else' found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpzhv23rq1.scala:18:20 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpzhv23rq1.scala:41:16 --------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                }) \e[33melse\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^\e[0m\n\e[31m   |\e[0m                Found:    Unit\n\e[31m\
    \   |\e[0m                Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ [E129] Potential Issue Warning: /tmp/tmpzhv23rq1.scala:43:8 -----------------\e\
    [0m\e[0m\n\e[33m42 |\e[0m                    res.append(x)\n\e[33m43 |\e[0m  \
    \      }\n\e[33m\e[33m   |\e[0m                                 ^\e[0m\n\e[33m\
    \   |\e[0mA pure expression does nothing in statement position; you may be omitting\
    \ necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659979993
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size\
    \ < 2)\n            throw new RuntimeException(\"Error! The list must contain\
    \ two elements.\");\n        val opening = lst.head;\n        val closing = lst.last;\n\
    \        var counter = 0;\n        var result = \"\";\n        for(i <- 0 until\
    \ opening.length()) {\n            if (opening(i) == '(') {\n                if\
    \ (closing != '(') {\n                    result += closing(i);\n            \
    \        counter++;\n                }\n            } else { // closing != '('\n\
    \                if (opening != '(' && counter == 0) // if opening == '('\n  \
    \                  result += \"()\"\n                else if (opening != '(' &&\
    \ counter == 1) // if opening != (')\n                    result += \"()\"\n \
    \           }\n        }\n        if (counter != 0)\n            result = \"No\"\
    \n        else\n            result = \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpjqzcr_yn.scala:28:29 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    counter++;\n\e[31m\e[31m   |\e[0m\
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \     expression expected but \e[31m';'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpjqzcr_yn.scala:26:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mif\e[0m (closing != \e[31m'('\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m        Values of types String and Char cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- Error: /tmp/tmpjqzcr_yn.scala:31:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33mif\e[0m (opening != \e[31m'('\e\
    [0m && counter == \e[31m0\e[0m) \e[34m// if opening == '('\e[0m\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types String and Char cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpjqzcr_yn.scala:33:25 -----------------------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (opening !=\
    \ \e[31m'('\e[0m && counter == \e[31m1\e[0m) \e[34m// if opening != (')\e[0m\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types String and Char cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjqzcr_yn.scala:38:19 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            result = \e[31m\"No\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:  \
    \  Unit\n\e[31m   |\e[0m            Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpjqzcr_yn.scala:40:19 --------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            result = \e[31m\"Yes\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found: \
    \   Unit\n\e[31m   |\e[0m      "
  stdout: ''
  timestamp: 1659979994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ result = \"No\"\n        var stack = Nil\n        var openStack = Nil\n    \
    \    lst.foreach(x => {\n            stack :+ x\n            if (x.equals(\")\"\
    )) {\n                openStack = stack.filter(_ != x)\n                result\
    \ +=  (openStack == stack && openStack.length == 1)\n            }\n         \
    \   if (x.equals(\"(\")) {\n                openStack = stack.filter(_ != x)\n\
    \                result +=  (openStack.length == 0 && stack.forall(_.equals(\"\
    )\")))\n            }\n        })\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkvcmflng.scala:24:40\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                openStack = stack.filter(_\
    \ != x)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    List[Nothing]\n\e[31m\
    \   |\e[0m                           Required: scala.collection.immutable.Nil.type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkvcmflng.scala:28:40\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                openStack = stack.filter(_\
    \ != x)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    List[Nothing]\n\e[31m\
    \   |\e[0m                           Required: scala.collection.immutable.Nil.type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979995
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ parenStack = mutable.Stack[Boolean]()\n        val res = \"Yes\"\n\n       \
    \ // TODO: Complete this function\n        for (str <- lst) {\n            //\
    \ if open and close matches push true to parenStack\n            if (str.contains(\"\
    (\") && str.contains(\")\")) {\n                parenStack.push(true)\n      \
    \      }\n            // if closing and open matches pop false to parenStack\n\
    \            if (str.contains(\")\") && str.contains(\"(\")) {\n             \
    \   parenStack.pop()\n            }\n            // if closing and open doesn't\
    \ match push false to parenStack\n            else if (!str.contains(\")\") &&\
    \ !str.contains(\"(\")) {\n                parenStack.push(false)\n          \
    \  }\n            // if open and close doesn't match push true to parenStack\n\
    \            else {\n                parenStack.push(true)\n            }\n  \
    \      }\n\n        // if all parenthesis are balanced return Yes\n        if\
    \ (parenStack.size == lst.length) {\n            res = s\"Yes\"\n        }\n \
    \       // if parenthesis are not balanced return No\n        else {\n       \
    \     res = s\"No\"\n        }\n        res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmcycu_qa.scala:18:25 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mparenStack\e[0m = mutable.Stack[\e\
    [35mBoolean\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpmcycu_qa.scala:43:16 -----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            res = \e[31ms\"Yes\"\e[0m\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val res\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpmcycu_qa.scala:47:16\
    \ -----------------------------\e[0m\e[0m\n\e[31m47 |\e[0m            res = \e\
    [31ms\"No\"\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m            Reassignment to val res\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979993
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ isGood(s: String) : Boolean = {\n            val opened = Set(('(',')'))\n \
    \           val closed = Set((')',')'))\n            val re = opened.union(closed).union(closed.toSet)\n\
    \            val closeParen = if (s == '(') ')' else ')'\n            val openParen\
    \ = if (s == '(' '(') '(' else ')'\n            re(lst) contains closeParen\n\
    \        }\n        if (isGood(lst(0))) {\n            if (isGood(lst(1))) {\n\
    \                \"Yes\"\n            } else {\n                \"No\"\n     \
    \       }\n        } else {\n            \"No\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzac3hp_o.scala:23:41 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mopenParen\e[0m = \e\
    [33mif\e[0m (s == \e[31m'('\e[0m \e[31m'('\e[0m) \e[31m'('\e[0m \e[33melse\e[0m\
    \ \e[31m')'\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \   ^\e[0m\n\e[31m   |\e[0m                               ')' expected, but character\
    \ literal found\n\e[31m\e[31m-- Error: /tmp/tmpzac3hp_o.scala:22:33 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mcloseParen\e[0m = \e\
    [33mif\e[0m (s == \e[31m'('\e[0m) \e[31m')'\e[0m \e[33melse\e[0m \e[31m')'\e[0m\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m        Values of types String and Char cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- Error: /tmp/tmpzac3hp_o.scala:23:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mopenParen\e[0m = \e\
    [33mif\e[0m (s == \e[31m'('\e[0m \e[31m'('\e[0m) \e[31m'('\e[0m \e[33melse\e[0m\
    \ \e[31m')'\e[0m\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types String and Char cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzac3hp_o.scala:24:15\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            re(lst) contains\
    \ closeParen\n\e[31m\e[31m   |\e[0m               ^^^\e[0m\n\e[31m   |\e[0m  \
    \             Found:    (lst : List[String])\n\e[31m   |\e[0m               Required:\
    \ (Char, Char)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979996
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ newlst = lst.filter(_ != \"\")\n        var newlstStr = String.join(\"\", newlst)\n\
    \        var open = 0\n        var close = 0\n        val newlstStr = newlstStr.grouped(2).map\
    \ { list =>\n            if(list.length == 0)\n                list\n        \
    \    else\n                if(list(0) == '(')\n                    open += 1\n\
    \                else\n                    close += 1\n        }\n\n        while(open\
    \ > 0 && close > 0) {\n            if(newlstStr.take(newlstStr.length - open).length\
    \ <= newlstStr.length - close + 1) {\n                newlstStr = newlstStr.drop(newlstStr.length\
    \ - open)\n                open -= 1\n                close -= 1\n           \
    \ }\n            else {\n                open -= 1\n                close -= 1\n\
    \            }\n        }\n        val newlstStr2 = newlstStr.grouped(2).map {\
    \ list =>\n            if(list.length == 0)\n                list\n          \
    \  else\n                if(list(0) == '(')\n                    list\n      \
    \          else\n                    list.reverse\n        }\n        if(newlstStr2.toSeq.isEmpty)\n\
    \            \"No\"\n        else\n            \"Yes\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyv2gh9hy.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mnewlstStr\e[0m = newlstStr.grouped(\e\
    [31m2\e[0m).map { \e[36mlist\e[0m =>\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e\
    [31m   |\e[0mnewlstStr is already defined as \e[33mvariable\e[0m \e[35mnewlstStr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m23 |\e[0m         \
    \   \e[33mif\e[0m(list.length == \e[31m0\e[0m)\n\e[31m24 |\e[0m              \
    \  list\n\e[31m25 |\e[0m            \e[33melse\e[0m\n\e[31m26 |\e[0m         \
    \       \e[33mif\e[0m(list(\e[31m0\e[0m) == \e[31m'('\e[0m)\n\e[31m27 |\e[0m \
    \                   open += \e[31m1\e[0m\n\e[31m28 |\e[0m                \e[33melse\e\
    [0m\n\e[31m29 |\e[0m                    close += \e[31m1\e[0m\n\e[31m30 |\e[0m\
    \        }\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpyv2gh9hy.scala:19:31 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mnewlstStr\e[0m = String.join(\e\
    [31m\"\"\e[0m, newlst)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mjoin\e[0m in \e[33mobject\e[0m \e[35mString\e[0m with types\n\e[31m   |\e\
    [0m (x$0: CharSequence, x$1: Iterable[? <: CharSequence]): String\n\e[31m   |\e\
    [0m (x$0: CharSequence, x$1: CharSequence*): String\n\e[31m   |\e[0mmatch arguments\
    \ ((\e[32m\"\"\e[0m : String), (newlst : List[String]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659979993
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        stack.push(\"(\")\n        stack.push(\"\
    )\")\n\n        while(!stack.isEmpty) {\n            val s = stack.pop()\n   \
    \         val len = lst(0).length\n            val idx = s.length - len\n    \
    \        if(idx <= 0) return \"No\"\n            if(s.equals(lst(idx))) return\
    \ \"Yes\"\n            stack.push(s)\n        }\n        return \"No\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprhk9olly.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ open = Set.empty[String]\n        val close = Set.empty[String]\n        lst.foreach(x\
    \ => open += x.toLowerCase)\n        lst.foreach(x => close += x.toLowerCase)\n\
    \        open.size == close.size\n        val stack = ListBuffer.empty[String]\n\
    \        val result = \"Yes\"\n        val stackSize = lst.size + 1\n        for\
    \ (i <- 0 until stackSize) {\n            val currentChar = lst(i).toLowerCase\n\
    \            if (currentChar == '(') stack += currentChar\n            if (currentChar\
    \ == ')') stack -= currentChar\n            if (stack.size == 0) result += \"\
    Yes\"\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp9i8rwelw.scala:28:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m (currentChar == \e[31m'('\e\
    [0m) stack += currentChar\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types String and Char cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp9i8rwelw.scala:29:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m (currentChar == \e[31m')'\e\
    [0m) stack -= currentChar\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types String and Char cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9i8rwelw.scala:30:40\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m\
    \ (stack.size == \e[31m0\e[0m) result += \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                                 ^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  value += is not a member of String - did you mean result.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659979998
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ isValidParens(st: String): Boolean = st.contains(\"(\") && st.contains(\")\"\
    )\n        val stack = mutable.Stack[String]()\n        for (i <- 0 to lst.size\
    \ - 1) {\n            if (isValidParens(lst(i))) {\n                stack += lst(i)\n\
    \                while (isValidParens(stack.last)) {\n                    stack\
    \ += stack.last\n                }\n            }\n        }\n        if (stack.toList.size\
    \ > 0) {\n            return \"Yes\"\n        } else {\n            return \"\
    No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq82vm799.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979995
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val output = mutable.ListBuffer.empty[String]\n\
    \        val bracketCounts = mutable.Map[(String, Int), Int]()\n\n        lst.foreach\
    \ {\n            str =>\n                if(str == \"(\") stack.push str\n   \
    \             else if(str == \")\") if(stack.isEmpty) output.append(str) else\
    \ bracketCounts.getOrElse((stack.last, stack.last.length - 1), 1).foreach {\n\
    \                    count =>\n                        stack.pop\n           \
    \             output.append(stack.last + str)\n                }\n           \
    \     else if(stack.last.length > 0 && bracketCounts.getOrElse((stack.last, stack.last.length\
    \ - 1), 1) <= 0) stack.pop\n                else stack.push(str)\n        }\n\
    \        if(stack.nonEmpty) output.toString\n        else \"No\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqvo6bs13.scala:24:45 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e[0m(str == \e[31m\"(\"\e[0m)\
    \ stack.push str\n\e[31m\e[31m   |\e[0m                                      \
    \       ^\e[0m\n\e[31m   |\e[0m                                      expression\
    \ expected but \e[31melse\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpqvo6bs13.scala:18:20 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqvo6bs13.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36moutput\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpqvo6bs13.scala:20:28 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbracketCounts\e[0m = mutable.Map[(\e\
    [35mString\e[0m, \e[35mInt\e[0m), \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ go(i : Int, acc : List[String]) : List[String] = \n            if(i <= 0) acc\
    \ else go(i - 1, acc + lst(i))\n        go(lst.size, lst(0))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz4quz0m_.scala:19:46 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m(i <= \e[31m0\e[0m) acc \e[33melse\e\
    [0m go(i - \e[31m1\e[0m, acc + lst(i))\n\e[31m\e[31m   |\e[0m                \
    \                          ^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of List[String], but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpz4quz0m_.scala:20:24 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        go(lst.size, lst(\e[31m0\e[0m))\n\e[31m\e[31m\
    \   |\e[0m                     ^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \   Found:    String\n\e[31m   |\e[0m                     Required: \e[1m\e[32mList\e\
    [0m\e[1m\e[32m[\e[0mString\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979999
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        for (item <- lst) {\n            item\
    \ match {\n                case \"(\" =>\n                    stack.push(item)\n\
    \                case \"(\" =>\n                    stack.push(item)\n       \
    \         case \")\" =>\n                    val temp = stack.pop()\n        \
    \            if (stack.empty) {\n                        //print(\"stack: \" +\
    \ stack + \", item: \" + item)\n                        if (temp == item) {\n\
    \                            return \"Yes\"\n                        }\n     \
    \               }\n            }\n        }\n        \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp89io4k9w.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Your\
    \ code here\n        val stack = mutable.Stack[String]()\n        val queue =\
    \ new mutable.Queue[String]()\n        val res = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size){\n            if(lst(i).contains(\"(\")){\n\
    \                stack push lst(i)\n            }\n            if(lst(i).contains(\"\
    )\")){\n                queue.append(lst(i))\n            }\n        }\n     \
    \   if(stack.size == 0){\n            res.append(\"No\")\n        }\n        else\
    \ if(queue.size == 0){\n            res.append(\"Yes\")\n        }\n        else\
    \ if(stack.size == 1){\n            if(queue.peek().contains(\")\")){\n      \
    \          res.append(\"Yes\")\n            }\n            else{\n           \
    \     res.append(\"No\")\n            }\n        }\n        else{\n          \
    \  while(!stack.empty){\n                val temp = stack.pop()\n            \
    \    val temp2 = queue.dequeue()\n                if(temp.contains(\"(\") && temp.contains(\"\
    )\") && temp2.contains(\"(\") && temp2.contains(\")\")){\n                   \
    \ res.append(\"Yes\")\n                }\n                else{\n            \
    \        res.append(\"No\")\n                }\n            }\n        }\n   \
    \     res.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdy7wna1h.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdy7wna1h.scala:20:24 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = \e[33mnew\e\
    [0m mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdy7wna1h.scala:21:18\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mres\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m   |\e\
    [0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979998
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val good = mutable.Set[String]()\n\
    \        val goodString = ListBuffer[String]()\n        val badString = ListBuffer[String]()\n\
    \n        def matchParens(st: List[String], st1 : String) : List[String] = {\n\
    \            st match {\n                case Nil => st1\n                case\
    \ h :: t => {\n                    st match {\n                        case Nil\
    \ => List(h)\n                        case h :: t1 =>\n                      \
    \      if (st1 == h) {\n                                if (stack.isEmpty)\n \
    \                                   List(stack.toList :+ st1)\n              \
    \                  else {\n                                    val st2 = stack.toList\n\
    \                                    if (st2.head == h) {\n                  \
    \                      stack.toList = st2 :: st1\n                           \
    \             st1\n                                    } else {\n            \
    \                            st2 :+ st1\n                                    }\n\
    \                                }\n                            } else {\n   \
    \                             if (stack.isEmpty) {\n                         \
    \           List(h)\n                                } else if (stack.head ==\
    \ h) {\n                                    stack.toList :+ st1\n            \
    \                        stack.toList\n                                } else\
    \ {\n                                    stack.head :: stack.toList :+ st1\n \
    \                                   stack.toList\n                           \
    \     }\n                            }\n                    }\n              \
    \  }\n            }\n        }\n\n        for ((a, b) <- lst, c <- stack) {\n\
    \            matchParens(b :: a, b)\n        }\n\n        good ++= goodString\n\
    \        bad ++= badString\n        goodString.forall(s => good contains s)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E041] Syntax Error: /tmp/tmpm8td35k7.scala:49:50 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m                                    stack.head :: stack.toList\
    \ :+ st1\n\e[31m\e[31m   |\e[0m                                              \
    \    ^\e[0m\n\e[31m   |\e[0m:: (which is right-associative) and :+ (which is left-associative)\
    \ have same precedence and may not be mixed\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmpm8td35k7.scala:58:26 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mfor\e[0m ((a, b) <- lst, c <- stack) {\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   ')' expected, but ',' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpm8td35k7.scala:18:20 ------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpm8td35k7.scala:19:19 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpm8td35k7.scala:25:28 --------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                \e[33mcase\e[0m Nil => st1\n\e[31m\e[31m \
    \  |\e[0m                            ^^^\e[0m\n\e[31m   |\e[0m               \
    \             Found:    (st1 : String)\n\e[31m   |\e[0m                      \
    \      Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpm8td35k7.scala:37:40 --------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m                        "
  stdout: ''
  timestamp: 1659980003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ flag = mutable.HashMap[String, Boolean]()\n        for(elem <- lst.head) {\n\
    \            flag(elem) <- false\n        }\n        for((i, j <- 0 until lst.size)\
    \ <- 0 until lst.size by -1) {\n            flag(lst.head(i)) <- false\n     \
    \       for(k <- 1 until lst.size) {\n                if(flag(lst.head(i).drop(lst.head(i).length()\
    \ + 1))) {\n                    flag(lst.head(k)) <- false\n                }\n\
    \            }\n        }\n        if(flag(\"(\")) {\n            \"Yes\"\n  \
    \      } else {\n            \"No\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmps2o96gxp.scala:20:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            flag(elem) <- \e[31mfalse\e[0m\n\e[31m\e\
    [31m   |\e[0m                       ^^\e[0m\n\e[31m   |\e[0m                 \
    \      end of statement expected but '<-' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmps2o96gxp.scala:22:18 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mfor\e[0m((i, j <- \e[31m0\e[0m until lst.size) <- \e\
    [31m0\e[0m until lst.size by -\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m         \
    \         ^^\e[0m\n\e[31m   |\e[0m                  ')' expected, but '<-' found\n\
    \e[31m\e[31m-- Error: /tmp/tmps2o96gxp.scala:23:30 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            flag(lst.head(i)) <- \e[31mfalse\e[0m\n\e\
    [31m\e[31m   |\e[0m                              ^^\e[0m\n\e[31m   |\e[0m    \
    \                          end of statement expected but '<-' found\n\e[31m\e\
    [31m-- Error: /tmp/tmps2o96gxp.scala:26:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    flag(lst.head(k)) <- \e[31mfalse\e\
    [0m\n\e[31m\e[31m   |\e[0m                                      ^^\e[0m\n\e[31m\
    \   |\e[0m                                end of statement expected but '<-' found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps2o96gxp.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36mflag\e[0m = mutable.HashMap[\e\
    [35mString\e[0m, \e[35mBoolean\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659979999
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ s  : List[String] = lst\n        val rev = s.reverse\n        val stack = mutable.Stack[String]()\n\
    \        var temp = \"\"\n        for( a <- 0 until s.size) {\n            if(\
    \ (s(a).equals('(')) )\n                stack += '('\n            else if( (s(a).equals(')'))\
    \ )\n                stack += ')'\n            else if( (s(a).equals('(')) &&\
    \ (stack.isEmpty) ) {\n                temp = s(a)\n                s += temp\n\
    \                stack += '('\n            }\n            else if( (s(a).equals(')'))\
    \ && (stack.nonEmpty) ) {\n                temp = s(a)\n                s += temp\n\
    \                stack += ')'\n            }\n            else {\n           \
    \     if(stack.nonEmpty)\n                    s += temp\n                s +=\
    \ temp\n                stack += (s(a))\n            }\n        }\n        if(stack.nonEmpty)\n\
    \            s += temp\n        s += temp\n        s = s.reverse\n        if(s.indexOf('(')\
    \ == s.lastIndexOf(')') && s.indexOf(')') < s.size) {\n            if(s.indexOf('(')\
    \ > s.lastIndexOf(')'))\n                return \"Yes\"\n            else\n  \
    \              return \"No\"\n        }\n        else\n            return \"No\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppuk5i2vt.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmppuk5i2vt.scala:29:18 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                s += temp\n\e[31m\e[31m   |\e[0m    \
    \            ^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member of List[String]\
    \ - did you mean List[String].!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppuk5i2vt.scala:34:18\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                s += temp\n\
    \e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0mvalue += is not\
    \ a member of List[String] - did you mean List[String].!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmppuk5i2vt.scala:39:22 ------------------------\e[0m\e\
    [0m\n\e[31m39 |\e[0m                    s += temp\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member of List[String]\
    \ - did you mean List[String].!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppuk5i2vt.scala:40:18\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                s += temp\n\
    \e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0mvalue += is not\
    \ a member of List[String] - did you mean List[String].!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmppuk5i2vt.scala:45:14 ------------------------\e[0m\e\
    [0m\n\e[31m45 |\e[0m            s += temp\n\e[31m\e[31m   |\e[0m            ^^^^\e\
    [0m\n\e[31m   |\e[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppuk5i2vt.scala:46:10 ------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        s += temp\n\e[31m\e[31m   |\e[0m        ^^^^\e\
    [0m\n\e[31m   |\e[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\
    7 errors found\n"
  stdout: ''
  timestamp: 1659980003
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ l = lst.map(x => if (x == \"(\") 1 else 0).sum\n        val r = lst.map(x =>\
    \ if (x == \")\") 1 else 0).sum\n        if (l+r == 0)\n            \"Yes\"\n\
    \        else\n            \"No\"\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpav_2801p.scala:26)\n\tat Problem.main(tmpav_2801p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980005
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Set[String]()\n\
    \n        lst.foreach { e => \n            if (e==\"(\") stack.push(\"(\")\n \
    \           else if (e==\")\") stack.push(\")\")\n            else stack += e\n\
    \        }\n\n        if (stack.size!=1){\n            return(\"No\")\n      \
    \  }\n\n        val topElement = stack.pop()\n        if (topElement==\")\"){\n\
    \            result.add(topElement)\n        }\n\n        if (stack.size==1){\n\
    \            if (result.size == lst.size){\n                return(\"Yes\")\n\
    \            }\n            return(\"No\")\n        }\n\n        while (stack.size!=0){\n\
    \            val nextElement = stack.pop()\n            val nextResult = result.pop()\n\
    \n            if (nextElement==\"(\"){\n                stack.push(nextElement)\n\
    \            }\n\n            if (nextElement==\")\"){\n                if (nextResult!=topElement){\n\
    \                    return(\"No\")\n                }\n            }\n      \
    \      else if (nextResult!=topElement){\n                return(\"No\")\n   \
    \         }\n\n            if (nextResult==topElement){\n                if (result.size\
    \ == lst.size){\n                    return(\"Yes\")\n                }\n    \
    \        }\n        }\n\n        return(\"No\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1t0w6hjb.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1t0w6hjb.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979999
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ allParens = lst._2.flatMap { x =>\n            if (x.contains(\")\")) Some(x.dropRight(1))\n\
    \            else Some(x.takeRight(1))\n        }\n        if (allParens.size\
    \ % 2 != 0) \"No\"\n        else if (allParens.head == allParens.tail) \"Yes\"\
    \n        else matchParens(allParens.init)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmfppwz0d.scala:18:28 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mallParens\e[0m = lst._2.flatMap\
    \ { \e[36mx\e[0m =>\n\e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        value _2 is not a member of List[String]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659980003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        //var\
    \ stack = List[List[String]]()\n        var stack = mutable.Stack[List[String]]()\n\
    \        var flag = false\n\n        for(i <- 0 until lst.length){\n         \
    \   var next = lst(i)\n\n            while(!stack.contains(next)){\n         \
    \       stack.push(next)\n                next = lst(i+1)\n            }\n\n \
    \           if(!flag){\n                if(next.equals(\"(\")){\n            \
    \        stack.push(next)\n                    next = lst(i+1)\n             \
    \   }\n                else{\n                    flag = true\n              \
    \  }\n            }\n            if(next.equals(\"(\")){\n                stack.push(\"\
    (\")\n                next = lst(i+1)\n            }\n            else if(stack.contains(next)){\n\
    \                stack.pop\n                next = stack.last\n            }\n\
    \            if(stack.last.equals(\")\") && !stack.last.equals(\"(\")){\n    \
    \            stack.last = \"(\"\n                stack.pop()\n            }\n\
    \            if(stack.last.equals(\"(\") && !stack.last.equals(\")\")){\n    \
    \            stack.last = \"(\"\n                stack.pop()\n            }\n\
    \            if(!stack.last.equals(\"(\") && !stack.last.equals(\")\")){\n   \
    \             stack.last += \")\"\n            }\n        }\n\n        if(stack.last\
    \ == \"(\")\n            return \"Yes\"\n        return \"No\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppy5z644_.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mList\e[0m[\e[35mString\e[0m]]()\n\e[31m\e[31m   |\e[0m                   \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659980001
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      lst.foldLeft(\"\
    No\") {\n        case (acc, x) => if (x contains \"(\") acc.append(\"Yes\") else\
    \ acc\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0w3zk03_.scala:19:49 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mcase\e[0m (acc, x) => \e[33mif\e[0m (x\
    \ contains \e[31m\"(\"\e[0m) acc.append(\e[31m\"Yes\"\e[0m) \e[33melse\e[0m acc\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  value append is not a member\
    \ of String\n1 error found\n"
  stdout: ''
  timestamp: 1659980003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Use\
    \ a stack to keep track of the number of '(' and ')'\n        // to see if we\
    \ can concatenate without making any mistakes.\n        // The base case: if list\
    \ is empty, return 'No'\n        // The base case: if there are zero '(', return\
    \ 'No'\n        // The base case: if there are zero ')', return 'Yes'\n      \
    \  // The general case:\n        // Create a stack\n        // While there are\
    \ elements left in list 'lst'\n        //   Pop the top element from the stack\n\
    \        //   Push the element '(element)'\n        //   If '(element)' is the\
    \ top element of the stack, add one\n        //   If ')' is top element of the\
    \ stack, remove one\n        //   If '(element)' is now empty, repeat from start\n\
    \        //   If ')' is now empty, repeat from start\n        //   If '(element)'\
    \ has the same number of '(' and ')' as ')', add one\n        //   If ')' has\
    \ the same number of '(' and ')' as '(', remove one\n        //   If '(element)'\
    \ has the same number of ')' and '(' as '(', remove one\n        //   If '(element)'\
    \ has the same number of ')' and '(', add one\n        //   If '(element)' has\
    \ the same number of ')' and '(', remove one\n        // If no element left\n\
    \        // return 'No'\n        val stack = new Stack[String]\n        var retVal\
    \ = \"No\"\n        lst.foreach { elem =>\n            val isOpen = elem.head()\
    \ == '('\n            val isClose = elem.head() == ')'\n            val count\
    \ = if (isOpen) 1 else -1\n            if (stack.size == 0 || (isOpen && count\
    \ == 1))\n                stack.push(elem)\n            else if (isClose && stack.size\
    \ == 1)\n                stack.pop()\n            else if (stack.size == 1 &&\
    \ (count == -1 || count == 1))\n                stack.append(elem)\n         \
    \   else if (stack.size == 1 && (count == -1 || count == -1))\n              \
    \  stack.pop()\n            else if (stack.size == 1 && (count < 0 || count ==\
    \ 0))\n                stack.append(elem)\n            else if (stack.size ==\
    \ 1 && (count > 0 || count == 0))\n                stack.prepend(elem)\n     \
    \   }\n        if (stack.size == 0)\n            retVal = \"No\"\n        else\
    \ if (stack.size == 1)\n            retVal = \"Yes\"\n        else if (stack.size\
    \ == 2 && (stack.head == stack.last) && stack.pop() == stack.head)\n         \
    \   retVal = \"Yes\"\n        else if (stack.size == 2 && (stack.head == stack.last)\
    \ && stack.pop() == stack.last)\n            retVal = \"Yes\"\n        else\n\
    \            retVal = \"No\"\n        return retVal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp6q011ic8.scala:42:30 -----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e[0m \e[36misOpen\e[0m = elem.head()\
    \ == \e[31m'('\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 \e[33mmethod\e[0m \e[35mhead\e[0m in \e[33mclass\e\
    [0m \e[35mStringOps\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E050] Type Error: /tmp/tmp6q011ic8.scala:43:31 -----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            \e[33mval\e[0m \e[36misClose\e[0m = elem.head()\
    \ == \e[31m')'\e[0m\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 \e[33mmethod\e[0m \e[35mhead\e[0m in \e[33mclass\e\
    [0m \e[35mStringOps\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        var res   = List[String]()\n      \
    \  var isOpen = false\n        lst.foreach(l => stack += l)\n        while(stack.nonEmpty)\
    \ {\n            val s = stack.pop()\n            if(!isOpen) {\n            \
    \    if(s.equals(\"(\")) {\n                    isOpen = true\n              \
    \  } else if(s.equals(\")\")) {\n                    if(!isOpen) {\n         \
    \               res += \"No\"\n                    } else {\n                \
    \        res += \"Yes\"\n                    }\n                    isOpen = false\n\
    \                } else if(!s.isEmpty) {\n                    res += \"Yes\"\n\
    \                }\n            }\n        }\n        if(res.nonEmpty) {\n   \
    \         res.head\n        } else {\n            \"No\"\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_ptcd40w.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_ptcd40w.scala:29:28 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                        res += \e[31m\"No\"\e[0m\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e[0mvalue +=\
    \ is not a member of List[String] - did you mean List[String].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp_ptcd40w.scala:31:28 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                        res += \e[31m\"Yes\"\e[0m\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e[0mvalue +=\
    \ is not a member of List[String] - did you mean List[String].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp_ptcd40w.scala:35:24 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    res += \e[31m\"Yes\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a\
    \ member of List[String] - did you mean List[String].!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659980005
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Use\
    \ stack to check if there is any balance in lst\n        val stack = new Stack[String]\n\
    \        for(i <- 0 until lst.size) {\n            stack += lst(i)\n         \
    \   while (stack.size > 0 ) {\n                val current = stack.pop\n     \
    \           val next = lst(i + 1)\n                val nextIsParen = next.headOption.map(c\
    \ => c == ')')\n                val currentIsParen = current.headOption.map(c\
    \ => c == ')')\n                if ((!nextIsParen && currentIsParen) || nextIsParen\
    \ && currentIsParen) {\n                    stack += current\n               \
    \ }\n            }\n        }\n        if (stack.size == lst.size) {\n       \
    \     return \"Yes\"\n        }\n        return \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyy1_af_i.scala:27:21 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                \e[33mif\e[0m ((!nextIsParen && currentIsParen)\
    \ || nextIsParen && currentIsParen) {\n\e[31m\e[31m   |\e[0m                 \
    \    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     value unary_! is not\
    \ a member of Option[Boolean]\n1 error found\n"
  stdout: ''
  timestamp: 1659980004
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Your\
    \ code goes here\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl2sadi6x.scala:17:51\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mmatchParens\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mString\e[0m]) : \e[35mString\e[0m =\
    \ {\n\e[31m\e[31m   |\e[0m                                                   ^\e\
    [0m\n\e[31m   |\e[0m                                                   Found:\
    \    Unit\n\e[31m   |\e[0m                                                   Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Your code goes here\e[0m\n\e[31m19 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980004
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ m = lst.map(_.contains(\"(\")).toList.foldLeft(false)(_ && _)\n        if (m)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnlth_sx.scala:22)\n\tat Problem.main(tmpnnlth_sx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980007
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ findParen(s  : String) : List[Int] = {\n            def openParen(r : String)\
    \ : List[Int] = {\n                val re = r.split(\"\\\\(\")\n             \
    \   val cnt = 0\n                re.map { x =>\n                    if (x.equals(\"\
    ()\")) {\n                        cnt+=1\n                    }\n            \
    \        else if (x.equals(\")\")) {\n                        cnt+=-1\n      \
    \              }\n                    cnt\n                }\n            }\n\
    \            def closeParen(r : String) : List[Int] = {\n                val re\
    \ = r.split(\"\\\\)\")\n                val cnt = 0\n                re.map {\
    \ x =>\n                    if (x.equals(\"(\")) {\n                        cnt+=1\n\
    \                    }\n                    else if (x.equals(\")\")) {\n    \
    \                    cnt+=-1\n                    }\n                    cnt\n\
    \                }\n            }\n\n            val ops = openParen(s) + closeParen(s)\n\
    \            val total = ops.sum\n            val pos = ops.min\n            val\
    \ flag = ops.foldLeft[List[Int]](0)(_+_)\n            if ((flag == total) || (flag\
    \ == total-1)) {\n                println(s\"flag==total=$flag,total=$total,pos=$pos,flag=$(flag<0)\"\
    )\n                if (flag < 0){\n                    return \"No\"\n       \
    \         }\n                else {\n                    return \"Yes\"\n    \
    \            }\n            }\n            else{\n                println(s\"\
    flag!=total=$flag,total=$total,pos=$pos,flag=$(flag<0)\")\n                if\
    \ (flag < 0) {\n                    return \"No\"\n                }\n       \
    \         else {\n                    return \"Yes\"\n                }\n    \
    \        }\n        }\n        var flag = 0\n        val result = lst\n      \
    \      .map {\n                s => findParen(s)\n            }\n            .fold(\"\
    \") { (a, b) => a + b.toString}\n        if (result.equals(\"Yes\")){\n      \
    \      return \"Yes\"\n        }\n        else{\n            return \"No\"\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpy_l67sbs.scala:51:71 -----------------------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                println(\e[31ms\"flag==total=\e[0m$flag\e\
    [31m,total=\e[0m$total\e[31m,pos=\e[0m$pos\e[31m,flag=$(flag<0)\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \       ^\e[0m\n\e[31m   |\e[0minvalid string interpolation: `$$`, `$\"`, `$`ident\
    \ or `$`BlockExpr expected\n\e[31m\e[31m-- Error: /tmp/tmpy_l67sbs.scala:60:71\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m60 |\e[0m       \
    \         println(\e[31ms\"flag!=total=\e[0m$flag\e[31m,total=\e[0m$total\e[31m,pos=\e\
    [0m$pos\e[31m,flag=$(flag<0)\"\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                                                     ^\e[0m\n\e[31m   |\e[0minvalid\
    \ string interpolation: `$$`, `$\"`, `$`ident or `$`BlockExpr expected\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpy_l67sbs.scala:24:27 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                        cnt+=\e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e[0m                \
    \  value += is not a member of Int - did you mean cnt.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpy_l67sbs.scala:27:27 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m                        cnt+=-\e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \        value +=- is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpy_l67sbs.scala:37:27 ------------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m                        cnt+=\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m          \
    \              ^^^^^\e[0m\n\e[31m   |\e[0m                  value += is not a\
    \ member of Int - did you mean cnt.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpy_l67sbs.scala:40:27 ------------------------\e[0m\e[0m\n\e[31m40 |\e\
    [0m                        cnt+=-\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m         \
    \               ^^^^^^\e[0m\n\e[31m   |\e[0m                        value +=-\
    \ is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy_l67sbs.scala:46:35\
    \ --------------------"
  stdout: ''
  timestamp: 1659980009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ good = lst.head match {\n            case \"\" => \"\"\n            case s =>\
    \ s\n        }\n        val stack = mutable.Stack[Int]()\n        val pos = 0\n\
    \        for (ele <- lst) {\n            ele match {\n                case \"\"\
    \ => stack.append(-1)\n                case c =>\n                    val index\
    \ = if (pos == 0) -1 else stack.pop\n                    if (c == '(') {\n   \
    \                     stack.append(index)\n                    } else if (c ==\
    \ ')') {\n                        if (index == -1) {\n                       \
    \     bad += \"(\" + c + \")\"\n                        } else {\n           \
    \                 good += c + \")\"\n                        }\n             \
    \           pos += 1\n                    }\n            }\n        }\n      \
    \  if (good != \"\") good else \"No\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7l_8vbre.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmp7l_8vbre.scala:29:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    \e[33mif\e[0m (c == \e[31m'('\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types String and Char cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmp7l_8vbre.scala:31:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    } \e[33melse\e[0m \e[33mif\e[0m (c\
    \ == \e[31m')'\e[0m) {\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types String and Char cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7l_8vbre.scala:33:28\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                        \
    \    bad += \e[31m\"(\"\e[0m + c + \e[31m\")\"\e[0m\n\e[31m\e[31m   |\e[0m   \
    \                         ^^^\e[0m\n\e[31m   |\e[0m                          \
    \  Not found: bad\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7l_8vbre.scala:37:28\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                        pos\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                  value += is not a member of Int - did you mean\
    \ pos.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1659980006
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // use\
    \ stack to check if brackets are balanced\n        var stack = new Stack[List[String]]()\n\
    \        for ( a <- lst ) {\n            if ( !a.contains(\"(\") && !a.contains(\"\
    )\") ) {\n                return \"No\"\n            }\n            else if (\
    \ a == \"(\" ) {\n                stack.append( List(a) )\n            }\n   \
    \         else if ( a == \")\" ) {\n                val temp = stack.pop()\n \
    \               if ( temp.size == 0 ) {\n                    return \"No\"\n \
    \               }\n                val temp = stack.pop()\n                stack.append(\
    \ List( temp(1), a ) )\n            }\n        }\n        if ( stack.size == 0\
    \ ) {\n            return \"No\"\n        }\n        return \"Yes\"\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp10jl9y43.scala:32:20 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                \e[33mval\e[0m \e[36mtemp\e[0m = stack.pop()\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mtemp is already defined as \e[33mvalue\e[0m \e[35mtemp\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1659980003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stg = lst.map(x => if (x.contains(\")\")) x else x + \")\")\n        val arr\
    \ = stg.toArray\n        val stack = mutable.Stack[String]()\n        val stackP\
    \ = mutable.Stack[Boolean]()\n\n        var count = 0\n        for (i <- 0 until\
    \ arr.length) {\n            count += arr.length\n            if (arr.isDefinedAt(i))\
    \ {\n                if (stackP.contains(arr(i))) {\n                    stackP\
    \ -= 1\n                    if (stackP.size == 0) {\n                        stackP\
    \ += true\n                    }\n                } else {\n                 \
    \   stackP += 1\n                    if (stackP.size == 0) {\n               \
    \         stackP += false\n                    }\n                }\n        \
    \    }\n            if (stack.size == count) {\n                if (stackP ==\
    \ 1) {\n                    if (stack.pop() == \"No\") {\n                   \
    \     return \"No\"\n                    }\n                } else {\n       \
    \             if (stack.pop() == \"No\") {\n                        return \"\
    No\"\n                    }\n                }\n            }\n            stack\
    \ += arr(i)\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq7_llvpz.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpq7_llvpz.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mstackP\e[0m = mutable.Stack[\e\
    [35mBoolean\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659980004
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ good(lst1: List[String], lst2: List[String]) : Boolean = {\n            var\
    \ flag = false\n            var idx1 : Int = 0\n            var idx2 : Int = 0\n\
    \            while(idx1 < lst1.length && idx2 < lst2.length) {\n             \
    \   if (lst1(idx1) != lst2(idx2)) {\n                    return false\n      \
    \          }\n                if (lst1(idx1) == '(') {\n                    if\
    \ (lst2(idx2) == ')') {\n                        flag = true\n               \
    \     } else {\n                        idx2 += 1\n                    }\n   \
    \             } else {\n                    if (lst2(idx2) == ')') {\n       \
    \                 idx2 += 1\n                    } else {\n                  \
    \      flag = false\n                        return false\n                  \
    \  }\n                }\n                idx1 += 1\n                idx2 += 1\n\
    \            }\n            return flag\n        }\n        val flag = lst.length\
    \ <= 1\n        if (flag) {\n            \"Yes\"\n        } else {\n         \
    \   val len = lst.length\n            val first = lst(0)\n            val rest\
    \ = lst.drop(1)\n            if (good(first, rest)) {\n                val newlist\
    \ = first :: rest\n                if (good(first, newlist)) {\n             \
    \       matchParens(newlist)\n                } else if (newlist.length == len)\
    \ {\n                    matchParens(newlist)\n                } else {\n    \
    \                \"No\"\n                }\n            } else {\n           \
    \     \"No\"\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpn8yech12.scala:26:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mif\e[0m (lst1(idx1) == \e[31m'('\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Values of types String and Char cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- Error: /tmp/tmpn8yech12.scala:27:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    \e[33mif\e[0m (lst2(idx2) == \e[31m')'\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        Values of types String and Char cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- Error: /tmp/tmpn8yech12.scala:33:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                    \e[33mif\e[0m (lst2(idx2) == \e[31m')'\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        Values of types String and Char cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn8yech12.scala:52:21\
    \ --------------------\e[0m\e[0m\n\e[31m52 |\e[0m            \e[33mif\e[0m (good(first,\
    \ rest)) {\n\e[31m\e[31m   |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e\
    [0m                     Found:    (first : String)\n\e[31m   |\e[0m          \
    \           Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpn8yech12.scala:54:25 --------------------\e[0m\e[0m\n\e[31m54\
    \ |\e[0m                \e[33mif\e[0m (good(first, newlist)) {\n\e[31m\e[31m \
    \  |\e[0m                         ^^^^^\e[0m\n\e[31m   |\e[0m                \
    \         Found:    (first : String)\n\e[31m   |\e[0m                        \
    \ Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659980008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ isBalanced = {\n            def check(pst: Int): Boolean = {\n             \
    \   val left = lst.head\n                val right = lst.last\n              \
    \  if(pst > left) false else left == right || (check(pst+1) && check(pst-1))\n\
    \            }\n            check(0);\n        }\n        if(lst.isEmpty)\n  \
    \          \"No\"\n        else if(isBalanced) \"Yes\"\n        else matchParens(lst.tail);\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsqduskh6.scala:22:23 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mif\e[0m(pst > left) \e[31mfalse\e\
    [0m \e[33melse\e[0m left == right || (check(pst+\e[31m1\e[0m) && check(pst-\e\
    [31m1\e[0m))\n\e[31m\e[31m   |\e[0m                   ^^^^^\e[0m\n\e[31m   |\e\
    [0m None of the overloaded alternatives of \e[33mmethod\e[0m \e[35m>\e[0m in \e\
    [33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double): Boolean\n\
    \e[31m   |\e[0m  (x: Float): Boolean\n\e[31m   |\e[0m  (x: Long): Boolean\n\e\
    [31m   |\e[0m  (x: Int): Boolean\n\e[31m   |\e[0m  (x: Char): Boolean\n\e[31m\
    \   |\e[0m  (x: Short): Boolean\n\e[31m   |\e[0m  (x: Byte): Boolean\n\e[31m \
    \  |\e[0m match arguments ((left : String))\n1 error found\n"
  stdout: ''
  timestamp: 1659980006
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ ls = lst.map{\n            case s => if (s.contains(\"(\")) 1 else 0\n     \
    \   }\n        ls.sum == ls.sum * ls.sum\n            ? \"Yes\"\n            :\
    \ \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptdgijlu1.scala:22:12 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        ls.sum == ls.sum * ls.sum\n\e[31m22 |\e[0m  \
    \          ? \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e[0m                       \
    \    ^\e[0m\n\e[31m   |\e[0m            value ? is not a member of Int.\n\e[31m\
    \   |\e[0m            Note that `?` is treated as an infix operator in Scala 3.\n\
    \e[31m   |\e[0m            If you do not want that, insert a `;` or empty line\
    \ in front\n\e[31m   |\e[0m            or drop any spaces behind the operator.\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659980006
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length\
    \ == 0) \"No\"\n        else {\n            var str = \"\"\n            val stack\
    \ = new Stack[String]\n            stack.push(\"(\")\n            while (!stack.empty)\
    \ {\n                str = str + stack.pop\n                val lst2 = lst.map(_\
    \ + str).toList\n                if (lst2.size == 2) \"Yes\"\n               \
    \ else {\n                    stack.push(lst2(1))\n                    stack.push(lst2(0))\n\
    \                }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf2f055ed.scala:23:19 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mwhile\e[0m (!stack.empty) {\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue unary_!\
    \ is not a member of scala.collection.mutable.Stack[String @uncheckedVariance]\n\
    \e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmpf2f055ed.scala:26:36 ----------------\e\
    [0m\e[0m\n\e[33m26 |\e[0m                \e[33mif\e[0m (lst2.size == \e[31m2\e\
    [0m) \e[31m\"Yes\"\e[0m\n\e[33m\e[33m   |\e[0m                               \
    \     ^^^^^\e[0m\n\e[33m   |\e[0mA pure expression does nothing in statement position;\
    \ you may be omitting necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 warning found\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659980010
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ inParens = lst.foldLeft(false) { (acc,s) =>\n            if (s.isEmpty) acc\n\
    \            else acc && s.head == '('\n        }\n        val lc = lst.foldLeft(\"\
    ()\") { (acc,s) =>\n            if (acc && s.head == ')') acc // already have\
    \ a valid one after this\n            else (acc + \"()\") + s\n        }\n   \
    \     if (inParens && !inParens.reverse.contains(\")\")) // if we are left with\
    \ ')' at begining, return 'No'\n            \"No\"\n        else if (lc.length\
    \ != lst.length)\n            \"No\" // if we have extra chars ('), return 'No'\n\
    \        else if (lc == \"()\") \"Yes\"\n        else \"No\" // if we are left\
    \ with nothing at begining, return 'No'\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp84cz21_w.scala:23:20 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (acc && s.head == \e[31m')'\e\
    [0m) acc \e[34m// already have a valid one after this\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                value && is not\
    \ a member of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp84cz21_w.scala:26:34\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (inParens\
    \ && !inParens.reverse.contains(\e[31m\")\"\e[0m)) \e[34m// if we are left with\
    \ ')' at begining, return 'No'\e[0m\n\e[31m\e[31m   |\e[0m                   \
    \      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         value reverse\
    \ is not a member of Boolean\n2 errors found\n"
  stdout: ''
  timestamp: 1659980011
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Initialization\n\
    \        var goodStrings = ListBuffer[String]()\n        var goodStringsSize =\
    \ lst.size\n        var openStrings = 0\n        var closeStrings = 0\n      \
    \  // Part 1 check and count\n        for (s <- lst) {\n            if (s == \"\
    ()\") {\n                openStrings += 1\n            } else if ((s != \"()\"\
    ) && (s != \")\")) {\n                return \"No\"\n            }\n         \
    \   closeStrings += 1\n        }\n        // Part 2 check and count\n        for\
    \ (i<- 0 to lst.size - 1) {\n            if (lst(i) == \"(\") {\n            \
    \    val stringCount = lst(i + 1)\n                val openCount = closeStrings\
    \ - openStrings\n                if (stringCount < openCount) {\n            \
    \        return \"No\"\n                }\n                if (stringCount ==\
    \ openCount) {\n                    val stringSum = lst(i) + lst(i + 1)\n    \
    \                goodStrings += stringSum\n                    goodStringsSize\
    \ += 1\n                    openStrings = 0\n                    closeStrings\
    \ = 0\n                }\n            } else if (lst(i) == \")\") {\n        \
    \        val stringCount = lst(i + 1)\n                val openCount = openStrings\
    \ - closeStrings\n                if (stringCount < openCount) {\n           \
    \         return \"No\"\n                }\n                if (stringCount ==\
    \ openCount) {\n                    val stringSum = lst(i) + lst(i + 1)\n    \
    \                goodStrings += stringSum\n                    goodStringsSize\
    \ += 1\n                    openStrings = 0\n                    closeStrings\
    \ = 0\n                }\n            }\n        }\n        // Part 3 check\n\
    \        if (goodStringsSize != goodStrings.size) {\n            return \"No\"\
    \n        }\n        for (i<- 0 to goodStringsSize - 1) {\n            if (goodStrings(i)\
    \ != goodStrings(i + 1)) {\n                return \"No\"\n            }\n   \
    \     }\n        // Part 4 check\n        val stringCount = goodStrings.last\n\
    \        val openCount = closeStrings - openStrings\n        if (stringCount <\
    \ openCount) {\n            return \"No\"\n        }\n        if (stringCount\
    \ == openCount) {\n            val stringSum = goodStrings.head + goodStrings.last\n\
    \            goodStrings += stringSum\n            goodStringsSize += 1\n    \
    \        openStrings = 0\n            closeStrings = 0\n        }\n        //\
    \ Part 5 check\n        goodStringsSize += 1\n        for (i<- 0 to goodStringsSize\
    \ - 1) {\n            if (goodStrings(i) != goodStrings(i + 1)) {\n          \
    \      return \"No\"\n            }\n        }\n        // Part 6 check\n    \
    \    val stringCount = goodStrings.last\n        val openCount = openStrings -\
    \ closeStrings\n        if (stringCount < openCount) {\n            return \"\
    No\"\n        }\n        if (stringCoun\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb734xitj.scala:98:4 ----------------------------\e\
    [0m\e[0m\n\e[31m98 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb734xitj.scala:92:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m92 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstringCount\e[0m = goodStrings.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstringCount is already defined as \e[33mvalue\e[0m \e[35mstringCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb734xitj.scala:93:12 ---------------------------\e[0m\e[0m\n\e\
    [31m93 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = openStrings - closeStrings\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpb734xitj.scala:37:34 --------------------\e[0m\e[0m\n\
    \e[31m37 |\e[0m                \e[33mif\e[0m (stringCount < openCount) {\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                  Found:    (openCount : Int)\n\e[31m   |\e[0m\
    \                                  Required: String\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpb734xitj.scala:40:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                \e[33mif\e[0m (stringCount == openCount)\
    \ {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m         Values of types String and Int cannot be compared with ==\
    \ or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb734xitj.scala:50:34\
    \ --------------------\e[0m\e[0m\n\e[31m50 |\e[0m                \e[33mif\e[0m\
    \ (stringCount < openCount) {\n\e[31m\e[31m   |\e["
  stdout: ''
  timestamp: 1659980013
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ lst1 = lst.tail\n        var lst2 = lst.head\n        var isMatching = false\n\
    \        var isTrue = false\n        var i = -1\n        while (!isMatching) {\n\
    \            i +=1\n            if (lst1(i) != lst2(i)) {\n                isMatching\
    \ = true\n            } else {\n                if (lst2(i) == \"(\") {\n    \
    \                lst1 = lst1.tail\n                    lst2 = lst2.head\n    \
    \            } else if (lst2(i) == \")\") {\n                    lst1 = lst1.head\n\
    \                    lst2 = lst2.tail\n                } else {\n            \
    \        isMatching = false\n                }\n            }\n        }\n   \
    \     if (isTrue) {\n            return \"Yes\"\n        } else {\n          \
    \  return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp616nuxul.scala:25:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mif\e[0m (lst1(i) != lst2(i)) {\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \      Values of types String and Char cannot be compared with == or !=\n\e[31m\e\
    [31m-- Error: /tmp/tmp616nuxul.scala:28:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mif\e[0m (lst2(i) == \e[31m\"(\"\
    \e[0m) {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Values of types Char and String cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp616nuxul.scala:30:32\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m                    lst2 = lst2.head\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Found:    Char\n\e[31m   |\e[0m                  \
    \         Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp616nuxul.scala:31:27\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m31 |\e[0m       \
    \         } \e[33melse\e[0m \e[33mif\e[0m (lst2(i) == \e[31m\")\"\e[0m) {\n\e\
    [31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp616nuxul.scala:32:32 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    lst1 = lst1.head\n\e[31m\e[31m  \
    \ |\e[0m                           ^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                Found:    String\n\e[31m   |\e[0m                           Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mString\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659980013
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = new Stack[String]()\n        for (x <- lst) {\n            if (x.equals(\"\
    (\")) {\n                stack.push(x)\n            } else if (x.equals(\")\"\
    )) {\n                val lastStacked = stack.pop()\n                if (lastStacked\
    \ == x) {\n                    if (stack.isEmpty) {\n                        \"\
    No\"\n                    } else {\n                        \"Yes\"\n        \
    \            }\n                } else {\n                    \"No\"\n       \
    \         }\n            } else {\n                \"No\"\n            }\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv642d1t3.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mfor\e[0m (x <-\
    \ lst) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found: \
    \   Unit\n\e[31m   |\e[0m        Required: String\n\e[31m20 |\e[0m           \
    \ \e[33mif\e[0m (x.equals(\e[31m\"(\"\e[0m)) {\n\e[31m21 |\e[0m              \
    \  stack.push(x)\n\e[31m22 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (x.equals(\e\
    [31m\")\"\e[0m)) {\n\e[31m23 |\e[0m                \e[33mval\e[0m \e[36mlastStacked\e\
    [0m = stack.pop()\n\e[31m24 |\e[0m                \e[33mif\e[0m (lastStacked ==\
    \ x) {\n\e[31m25 |\e[0m                    \e[33mif\e[0m (stack.isEmpty) {\n\e\
    [31m26 |\e[0m                        \e[31m\"No\"\e[0m\n\e[31m27 |\e[0m      \
    \              } \e[33melse\e[0m {\n\e[31m28 |\e[0m                        \e\
    [31m\"Yes\"\e[0m\n\e[31m29 |\e[0m                    }\n\e[31m30 |\e[0m      \
    \          } \e[33melse\e[0m {\n\e[31m31 |\e[0m                    \e[31m\"No\"\
    \e[0m\n\e[31m32 |\e[0m                }\n\e[31m33 |\e[0m            } \e[33melse\e\
    [0m {\n\e[31m34 |\e[0m                \e[31m\"No\"\e[0m\n\e[31m35 |\e[0m     \
    \       }\n\e[31m36 |\e[0m        }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980011
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Use\
    \ dynamic programming\n        // A solution in O(n^2) would be: O(n^2*M), M is\
    \ the maximum length\n        var maxLength = 0\n        val arr1 = lst(0)\n \
    \       var count = 0\n        var cur = 0\n        var arr2 = lst(1)\n      \
    \  while (cur < arr2.length) {\n            if (arr2(cur) == '(') {\n        \
    \        count += 1\n            }\n            if (arr2(cur) == ')') {\n    \
    \            count -= 1\n            }\n            if (arr1(cur) == arr2(cur)\
    \ && count <= 0) {\n                maxLength += 1\n            }\n          \
    \  cur += 1\n        }\n        var ans = \"\"\n        var count1 = 0\n     \
    \   var count2 = 0\n        while (count > 0) {\n            if (count1 == maxLength)\
    \ {\n                ans += arr1(count1) + arr2(count2)\n                count1\
    \ += 1\n                count2 += 1\n            } else {\n                ans\
    \ += arr1(count1)\n                count1 += 1\n            }\n            if\
    \ (count2 == maxLength) {\n                ans += arr2(count2)\n             \
    \   count2 += 1\n            } else {\n                ans += arr2(count2)\n \
    \               count2 += 1\n            }\n            count -= 1\n        }\n\
    \        if (maxLength == 0) {\n            ans = \"Yes\"\n        } else {\n\
    \            ans = \"No\"\n        }\n        return ans\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: String index out of range: 4\n\
    \tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\
    \tat scala.collection.StringOps$.apply$extension(StringOps.scala:185)\n\tat Problem$.matchParens(tmptl3t7is1.scala:32)\n\
    \tat Problem$.main(tmptl3t7is1.scala:69)\n\tat Problem.main(tmptl3t7is1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ stack = List[String]()\n        for (i <- 0 until lst.size) {\n            if\
    \ (lst(i).contains(\"(\") && lst(i).contains(\")\")) {\n                if (stack.contains(lst(i)\
    \ + lst(i+1))) {\n                    return \"No\"\n                } else {\n\
    \                    stack += lst(i) + lst(i+1)\n                }\n         \
    \   }\n        }\n        \"Yes\"\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcl7658q6.scala:24:26 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    stack += lst(i) + lst(i+\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ += is not a member of List[String] - did you mean List[String].!=?\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659980014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ st = new scala.collection.mutable.HashMap[Int, List[String]]()\n        for\
    \ (s <- lst) if (st.contains(s.length)) {\n            if (st.apply(s.length).nonEmpty)\
    \ st += s.length -> List(s)\n            else st += s.length -> List()\n     \
    \   }\n        if (st.size != lst.length) \"No\" else if (st.size == 1) st.apply(0)\
    \ else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwts280cy.scala:23:71\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mif\e[0m (st.size\
    \ != lst.length) \e[31m\"No\"\e[0m \e[33melse\e[0m \e[33mif\e[0m (st.size == \e\
    [31m1\e[0m) st.apply(\e[31m0\e[0m) \e[33melse\e[0m \e[31m\"Yes\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                                                               ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mString\e[1m\e[31m]\e[0m\n\e[31m   |\e\
    [0m                                                  Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659980015
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Scan\
    \ the first string and find the balance of open and close\n        // parentheses,\
    \ if they have balance then return 'Yes', otherwise return 'No'\n        val s\
    \ = lst(0)\n        def isBalance(s1: String, s2: String): Boolean = {\n     \
    \       if (s1.isEmpty)\n                true\n            else if (s2.isEmpty)\n\
    \                false\n            else (s1 startsWith s2) || (s2 startsWith\
    \ s1)\n        }\n\n        var balance = 0\n        var open = 0\n        var\
    \ close = 0\n        for (str <- lst) {\n            if (str == \"(\")\n     \
    \           open += 1\n            if (str == \")\")\n                close +=\
    \ 1\n            if (open == close)\n                balance += close\n      \
    \  }\n        if (balance == 0 || balance == 2)\n            return \"Yes\"\n\
    \        else\n            return \"No\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxs3yp1e8.scala:47)\n\tat Problem.main(tmpxs3yp1e8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980017
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ lst2 = lst.map(s => List(s)).toList\n        val stack = mutable.Stack[List[String]]()\n\
    \        lst2.foreach(x => stack.push(List(x)))\n        val lastElement = stack.last.last\n\
    \        if(stack.last.isEmpty) lastElement.foldLeft(\"No\") { (a, e) => a + e\
    \ }\n        else {\n            var temp = \"\"\n            var goodString =\
    \ \"\"\n            val len = lst2.length\n            for(i <- 0 until len) {\n\
    \                val nextElement = stack.last.dropRight(1).head\n            \
    \    val nextElementStack = stack.last.dropRight(1).tail\n                val\
    \ nextElementStackLast = nextElementStack.last\n                val nextElementStackLen\
    \ = nextElementStack.length\n                val elementToCheck = lst2.apply(i)\n\
    \                if(nextElementStackLast.contains(elementToCheck)) {\n       \
    \             val temp1 = nextElementStackLast.take(nextElementStackLen - 1).mkString\n\
    \                    val temp2 = nextElementStackLast.drop(nextElementStackLen\
    \ - 1).mkString\n                    if(temp1 == temp2) {\n                  \
    \      goodString = temp\n                        stack.last.takeRight(nextElementStackLen\
    \ - 1).foreach(stack.last.add)\n                        break\n              \
    \      } else {\n                        temp = temp1 + elementToCheck + temp2\n\
    \                        stack.last.dropRight(1).foreach(stack.last.add)\n   \
    \                     break\n                    }\n                } else {\n\
    \                    temp = temp + elementToCheck\n                }\n       \
    \     }\n            goodString\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7vosfve1.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mList\e[0m[\e[35mString\e[0m]]()\n\e[31m\e[31m   |\e[0m                   \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7vosfve1.scala:39:24 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7vosfve1.scala:43:24\
    \ ------------------------\e[0m\e[0m\n\e[31m43 |\e[0m                        break\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659980012
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Convert\
    \ list to map by removing duplicate values\n        // If all values in the map\
    \ are same then return \"Yes\"\n        // Else return \"No\"\n        val map:\
    \ Map[String, Int] = lst.toMap.toList.reverse.groupBy(x => x).mapValues(_.size)\n\
    \        val keys = map.keys.toList\n        val values = map.values.toList\n\
    \        val yes = keys.size == values.size && keys.forall(x => x == values.head)\n\
    \        if(yes) {\n            \"Yes\"\n        } else {\n            \"No\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpl5wv0jin.scala:21:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m: \e[35mMap\e[0m[\e\
    [35mString\e[0m, \e[35mInt\e[0m] = lst.toMap.toList.reverse.groupBy(\e[36mx\e\
    [0m => x).mapValues(_.size)\n\e[31m\e[31m   |\e[0m                           \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   \
    \  Cannot prove that String <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m     \
    \                                where:    K is a type variable\n\e[31m   |\e\
    [0m                                               V is a type variable\n\e[31m\
    \   |\e[0m                                     .\n\e[31m\e[31m-- Error: /tmp/tmpl5wv0jin.scala:24:63\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36myes\e[0m = keys.size == values.size && keys.forall(\e[36mx\e\
    [0m => x == values.head)\n\e[31m\e[31m   |\e[0m                              \
    \                                 ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \    Values of types String and Int cannot be compared with == or !=\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659980016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ result = ListBuffer[String]()\n        def matchParens(lst : List[String], acc\
    \ : List[String], stack : List[String]) : String = {\n            if(!lst.isEmpty)\
    \ {\n                acc :+ lst(0)\n                lst :- lst(0)\n          \
    \      if(!stack.contains(lst(0)) && acc.isEmpty && lst(0).equals(\"(\") && lst(1).equals(\"\
    )\")) {\n                    result :+= \"Yes\"\n                } else {\n  \
    \                  matchParens(lst, acc, acc :+ lst(0))\n                }\n \
    \           } else {\n                result :+= \"No\"\n            }\n     \
    \   }\n        matchParens(lst,ListBuffer[String](),List[String]())\n        result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcenpkfon.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                lst :- lst(\e[31m0\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m         value :- is not\
    \ a member of List[String] - did you mean lst.:+?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpcenpkfon.scala:24:20 --------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m                    result :+= \e[31m\"Yes\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Found:    Unit\n\e[31m   |\e[0m                    Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcenpkfon.scala:29:16\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                result :+= \e\
    [31m\"No\"\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                Found:    Unit\n\e[31m   |\e[0m                Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcenpkfon.scala:32:42\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        matchParens(lst,ListBuffer[\e\
    [35mString\e[0m](),List[\e[35mString\e[0m]())\n\e[31m\e[31m   |\e[0m         \
    \               ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:\
    \    scala.collection.mutable.ListBuffer[String]\n\e[31m   |\e[0m            \
    \       Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659980016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ m = lst.map(x => (x match {\n            case \"(\" => 1\n            case \"\
    )\" => -1\n            case _ => 0\n        })).foldLeft(0)(_ + _)\n        lst.map(x\
    \ => {\n            if (x < \"(\" || x > \")\") {\n                return \"No\"\
    \n            }\n            if (x < m) x else \"Yes\"\n        }).foldLeft(\"\
    Yes\")(\n            (acc, x) => {\n                val f = acc\n            \
    \    if (f==\"Yes\" && x == \"Yes\") \"Yes\" else \"No\"\n            }\n    \
    \    )\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpod9_rmb5.scala:27:20\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mif\e[0m (x\
    \ < m) x \e[33melse\e[0m \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e[0m           \
    \         ^\e[0m\n\e[31m   |\e[0m                    Found:    (m : Int)\n\e[31m\
    \   |\e[0m                    Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = Stack[String]()\n        val good = \"Yes\"\n        lst.foreach( x\
    \ =>\n            if(x.startsWith(\"(\") && x.endsWith(\")\")){\n            \
    \    stack.push(x)\n            }\n            if(stack.nonEmpty){\n         \
    \       var i = 0\n                var last = 0\n                while (i < stack.size)\
    \ {\n                    val n = stack.length - i\n                    var j =\
    \ 0\n                    var last_n = 0\n                    while(j < stack.size)\
    \ {\n                        val m = stack.length - j\n                      \
    \  val p0 = stack(i).length\n                        val p1 = stack(m).length\n\
    \                        if(n > 0 && m > 0) {\n                            last_n\
    \ = math.min(p0, p1)\n                            if(last_n == 0){\n         \
    \                       if(stack(n).startsWith(\"(\") && stack(m).endsWith(\"\
    )\") && stack(i + 1).startsWith(\"(\") && stack(m).endsWith(\")\")){\n       \
    \                             good += \"Yes\"\n                              \
    \      return good\n                                }\n                      \
    \      }\n                            if(last_n == 1) {\n                    \
    \            if(stack(n).endsWith(\"(\") && stack(m).endsWith(\")\") && stack(i\
    \ + 1).startsWith(\"(\") && stack(m).endsWith(\")\")){\n                     \
    \               good += \"Yes\"\n                                    return good\n\
    \                                }\n                            }\n          \
    \                  if(last_n == 2) {\n                                if(stack(n).endsWith(\"\
    (\") && stack(m).endsWith(\")\") && stack(i + 1).endsWith(\"(\") && stack(m).endsWith(\"\
    )\")){\n                                    good += \"Yes\"\n                \
    \                    return good\n                                }\n        \
    \                    }\n                        }\n                        j +=\
    \ 1\n                    }\n                    i +=1\n                }\n   \
    \         }\n        )\n        good\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0l63rwr8.scala:39:41 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                                    good += \e[31m\"\
    Yes\"\e[0m\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m              value += is not a member of String - did you\
    \ mean good.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0l63rwr8.scala:45:41\
    \ ------------------------\e[0m\e[0m\n\e[31m45 |\e[0m                        \
    \            good += \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e[0m               \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m              value += is not\
    \ a member of String - did you mean good.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp0l63rwr8.scala:51:41 ------------------------\e[0m\e[0m\n\e[31m51\
    \ |\e[0m                                    good += \e[31m\"Yes\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \              value += is not a member of String - did you mean good.!=?\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659980016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // The\
    \ first and last elements of lst are empty.\n        val lst_1 = lst.take(1).reverse\n\
    \        val lst_2 = lst.drop(1).reverse\n        val lst_3 = lst_2.take(lst_2.size\
    \ - 1).reverse\n        val lst_4 = lst_3.take(lst_3.size - 1).reverse\n     \
    \   if (lst_4.size < lst_2.size) return \"No\"\n        if (lst_3.size < lst_1.size)\
    \ return \"No\"\n        if (lst_4.size == lst_2.size && lst_4.size == lst_1.size)\
    \ lst_4.head\n        else {\n            val lst_5 = lst_4.takeWhile(_ != \"\
    (\")\n            val lst_6 = lst_5.takeWhile(_ != \")\")\n            val lst_7\
    \ = lst_5.dropWhile(_ != \"(\")\n            val lst_8 = lst_7.takeWhile(_ !=\
    \ \")\")\n            val lst_9 = lst_5.takeWhile(_ != \")\").dropWhile(_ != \"\
    (\")\n            val lst_10 = lst_9.takeWhile(_ != \")\").dropWhile(_ != \"(\"\
    )\n            val lst_11 = lst_10.reverse\n            val lst_12 = lst_11.reverse\n\
    \            val lst_13 = lst_12.reverse\n            val lst_14 = lst_13.reverse\n\
    \            val lst_15 = lst_14.reverse\n            val lst_16 = lst_15.reverse\n\
    \            val lst_17 = lst_16.reverse\n            val lst_18 = lst_17.reverse\n\
    \            val lst_19 = lst_18.reverse\n            val lst_20 = lst_19.reverse\n\
    \            val lst_21 = lst_20.reverse\n            val lst_22 = lst_21.reverse\n\
    \            val lst_23 = lst_22.reverse\n            if (lst_14.size != 0) \"\
    Yes\"\n            else {\n                if (lst_13.size != 0) \"Yes\"\n   \
    \             else {\n                    if (lst_12.size != 0) \"Yes\"\n    \
    \                else {\n                        if (lst_11.size != 0) \"Yes\"\
    \n                        else {\n                            if (lst_10.size\
    \ != 0) \"Yes\"\n                            else {\n                        \
    \        if (lst_9.size != 0) \"Yes\"\n                                else {\n\
    \                                    if (lst_8.size != 0) \"Yes\"\n          \
    \                          else {\n                                        if\
    \ (lst_7.size != 0) \"Yes\"\n                                        else {\n\
    \                                            if (lst_6.size != 0) \"Yes\"\n  \
    \                                          else {\n                          \
    \                      if (lst_5.size != 0) \"Yes\"\n                        \
    \                        else {\n                                \n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp4_2qqeq.scala:84:0 ----------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp4_2qqeq.scala:83:1\
    \ ---------------------\e[0m\e[0m\n\e[31m83 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpp4_2qqeq.scala:68:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m68 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1659980016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ map = mutable.Map.empty[String, String]\n        var lst = lst.sorted\n    \
    \    lst(0) = (lst(0)(0)) + (lst(0)(1))\n        lst(1) = lst(1).subList(1, lst.size)\n\
    \        for (i <- lst.indices) {\n            val subst = lst.update(i)\n   \
    \         var temp = subst.apply(i-1)\n            var next = (i-1) + subst.apply(i+1)\n\
    \            while (next < lst.size && temp != lst(next)){\n                temp\
    \ = (temp) + (lst(next))\n                next += 1\n            }\n         \
    \   val key = temp.toString\n            val value = lst(next)\n            if\
    \ (map.contains(key)) {\n                map = (map.updated(key,value))\n    \
    \        } else {\n                map = map + (key -> value)\n            }\n\
    \        }\n        if (!map.isEmpty) {\n            val keys = map.keys.toSeq.sorted\n\
    \            val values = (map.values - keys) ++ keys\n            val rev = values.reverse\n\
    \            val newMap = Map(key -> value)\n            for (i <- rev) {\n  \
    \              val value = newMap(key)\n                val key = newMap(value)\n\
    \                map = (map - key) + (key -> value)\n            }\n        }\n\
    \        if (map.isEmpty) {\n            \"No\"\n        } else {\n          \
    \  \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps0fcda9b.scala:18:18 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = mutable.Map.empty[\e\
    [35mString\e[0m, \e[35mString\e[0m]\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmps0fcda9b.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mlst\e[0m = lst.sorted\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvariable\e[0m \e[35mlst\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmps0fcda9b.scala:42:29 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e[0m \e[36mnewMap\e[0m = Map(key\
    \ -> value)\n\e[31m\e[31m   |\e[0m                             ^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: key\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659980014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ str = lst(0)\n        val lst2 = lst(1)\n        val index = str.indexOf(\"\
    (\")\n        val counts = str.substring(index+1, str.length).toInt\n        val\
    \ sum = 0\n        for(i <- 0 to counts) {\n            sum = sum + i\n      \
    \  }\n        if(sum == (counts*counts)) \"Yes\" else \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpj1gqbab0.scala:24:16 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            sum = sum + i\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val sum\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size\
    \ != 2) \"No\"\n        else if (!checkParens(lst)) \"No\"\n        else checkParens(lst)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6_k4h43b.scala:19:18 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (!checkParens(lst))\
    \ \e[31m\"No\"\e[0m\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                  Not found: checkParens\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6_k4h43b.scala:20:13 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m checkParens(lst)\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Not found:\
    \ checkParens\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980014
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Create\
    \ a list of stacks, one for each string\n        val stacks: List[Stack[String]]\
    \ = lst.map(_ => Stack.empty[String])\n        // If the top of the stack is empty,\
    \ return 'No' as the answer\n        if (stacks.filter(_.isEmpty).head.isEmpty)\
    \ \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_64u5n58.scala:24)\n\tat Problem.main(tmp_64u5n58.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980019
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ l = lst.size\n        val stack = mutable.Stack[String]()\n        val open\
    \ = mutable.Set[String]()\n        val close = mutable.Set[String]()\n       \
    \ for (i <- 0 until l) {\n            val p = lst.apply(i)\n            if (p\
    \ == \"(\")\n                open.add(p)\n            else if (p == \")\")\n \
    \               close.add(p)\n            else if (open.isEmpty && close.isEmpty\
    \ && !stack.isEmpty) {\n                val str = stack.pop()\n              \
    \  if (!open.contains(str))\n                    return \"No\"\n            }\n\
    \            else {\n                stack += p\n            }\n        }\n  \
    \      if (!open.isEmpty && !close.isEmpty)\n            return \"No\"\n     \
    \   return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqkzooihb.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqkzooihb.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpqkzooihb.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659980015
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ lst1 = lst.sortBy(_.length)\n        var str = \"\"\n        val isMatch = lst1.map(x\
    \ => {\n            val y = (x.split(\"(\")[1]).split(\")\")[0]\n            str\
    \ += \"Yes\"\n            if(y != \"\") \n                str+y\n            else\n\
    \                str+x\n        })\n        if(isMatch.forall(x => x.contains(\"\
    Yes\"))) \n            str\n        else \n            \"No\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp7wa1peop.scala:21:33 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36my\e[0m = (x.split(\e\
    [31m\"(\"\e[0m)[\e[31m1\e[0m]).split(\e[31m\")\"\e[0m)[\e[31m0\e[0m]\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \         \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e[0m \e[35mArray\e\
    [0m does not take type parameters\n1 error found\n"
  stdout: ''
  timestamp: 1659980017
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ balanced = \"()\".grouped(2).toList.map(x => if (x.size == 1) x(0)\n       \
    \     else (x.tail, x.head))\n        val unbalanced = \"()\".grouped(1).toList.map(x\
    \ => if (x.size == 1) x(0)\n            else x.head)\n        val good = balanced.foldLeft(List(\"\
    \"))((list, str) =>\n            list match {\n                case x::xs if (x\
    \ == str) => x\n                case x::xs if x != str => x :: list\n        \
    \        case _ => list\n            })\n        if (balanced.contains(good))\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp98ap48me.scala:24:44\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mcase\e\
    [0m x::xs \e[33mif\e[0m (x == str) => x\n\e[31m\e[31m   |\e[0m               \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \                    Found:    (x : String)\n\e[31m   |\e[0m                 \
    \                           Required: List[String]\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659980020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Use\
    \ a stack to store the position of opening parentheses\n        val openStack\
    \ : Stack[Int] = new Stack[Int]()\n        val closedStack : Stack[Int] = new\
    \ Stack[Int]()\n        // Use a stack to store the position of closing parentheses.\n\
    \        val closedStackPos : Stack[Int] = new Stack[Int]()\n\n        val goodStrings\
    \ : mutable.Queue[String] = new mutable.Queue[String]()\n        val goodStringsPos\
    \ : mutable.Queue[Int] = new mutable.Queue[Int]()\n\n        // A stack to store\
    \ whether a opening parentheses is closed, if yes,\n        // push it into closedStack,\
    \ otherwise push it into openStack.\n        for (i <- 0 until lst.size) {\n \
    \           val opening = lst(i)\n            if (opening == \"(\") openStack.push(i)\n\
    \            else if (opening == \")\") {\n                if (closedStack.size\
    \ == 0) openStack.push(i + 1)\n                else {\n                    val\
    \ closed = closedStack.pop()\n                    if (closed == i) closedStackPos.push(i)\n\
    \                }\n            }\n        }\n\n        // Use a while loop to\
    \ check all opening parentheses and push them into goodStrings\n        // If\
    \ an opening parentheses is closed, push it into closedStackPos, otherwise,\n\
    \        // push it into openStack\n        while (openStack.nonEmpty) {\n   \
    \         val i = openStack.pop()\n            val open = lst(i)\n           \
    \ if (opening == \"(\") {\n                if (closedStack.nonEmpty && closedStackPos.nonEmpty\
    \ && goodStrings.nonEmpty &&\n                    open == \")\" && closedStackPos.head\
    \ == i) {\n                    val closed = closedStack.pop()\n              \
    \      if (closed == i) closedStackPos.push(i)\n                    else {\n \
    \                       val pos = closedStackPos.pop()\n                     \
    \   val goodString = goodStrings.dequeue()\n                        val newClosedStack\
    \ = closedStack.dequeue()\n                        if (newClosedStack == pos)\
    \ {\n                            goodStringsPos.push(pos)\n                  \
    \          goodStrings += goodString\n                        }\n            \
    \        }\n                }\n                else {\n                    val\
    \ goodString = goodStrings.dequeue()\n                    if (goodString == goodStrings.peek())\n\
    \                        goodStrings += goodString\n                }\n      \
    \      } else {\n                if (closedStack.nonEmpty && closedStackPos.nonEmpty\
    \ && goodStrings.nonEmpty &&\n                    open == \")\" && closedStackPos.head\
    \ == i + 1) {\n                    val closed = closedStack.pop()\n          \
    \          if (closed == i + 1) closedStackPos.push(i)\n                    else\
    \ {\n                        val pos = closedStackPos.pop()\n                \
    \        val good\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2kj5ot0m.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2kj5ot0m.scala:92:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp2kj5ot0m.scala:24:26 ------------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m        \e[33mval\e[0m \e[36mgoodStrings\e[0m : mutable.Queue[\e\
    [35mString\e[0m] = \e[33mnew\e[0m mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp2kj5ot0m.scala:24:54 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mgoodStrings\e[0m : mutable.Queue[\e\
    [35mString\e[0m] = \e[33mnew\e[0m mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                                                      ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2kj5ot0m.scala:25:29\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mgoodStringsPos\e[0m : mutable.Queue[\e[35mInt\e[0m] = \e[33mnew\e[0m mutable.Queue[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp2kj5ot0m.scala:25:54 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mgoodStringsPos\e[0m : mutable.Queue[\e\
    [35mInt\e[0m] = \e[33mnew\e[0m mutable.Queue[\e[35mInt\e[0m]()\n\e[31m\e[31m \
    \  |\e[0m                                                      ^^^^^"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ lst1 = lst.map(_.replaceAll(\"^\\\\)\",\"\"))\n        var lst2 = lst.map(_.replaceAll(\"\
    \\\\)\",\"\"))\n        var i = 0\n        var count = 0\n        var str = \"\
    \"\n        while(lst1.nonEmpty){\n            str += \"(\"\n            while(i\
    \ < lst1.length){\n                str += lst1(lst1(i))\n                i +=\
    \ 1 \n                if(lst1(i) == \"(\"){\n                    count += 1\n\
    \                }\n                if(lst1(i) == \")\"){\n                  \
    \  count -= 1\n                }\n                if((count == 0) && (lst1(i)\
    \ == \"(\")){\n                    lst1.remove(lst1(i))\n                    lst2.remove(lst2(i))\n\
    \                    count += 1\n                    i = lst1.length\n       \
    \             count += 1\n                }\n            }\n            str +=\
    \ \")\"\n        }\n        if(lst2.nonEmpty){\n            str += \"(\"\n   \
    \         while(i < lst2.length){\n                str += lst2(lst2(i))\n    \
    \            i += 1 \n                if(lst2(i) == \"(\"){\n                \
    \    count += 1\n                }\n                if(lst2(i) == \")\"){\n  \
    \                  count -= 1\n                }\n                if((count ==\
    \ 0) && (lst2(i) == \"(\")){\n                    lst2.remove(lst2(i))\n     \
    \               lst1.remove(lst1(i))\n                    count += 1\n       \
    \             i = lst2.length\n                    count += 1\n              \
    \  }\n            }\n            str += \")\"\n        }\n        if(str != \"\
    \"){\n            return \"Yes\"\n        }else{\n            return \"No\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvmcu96rs.scala:26:20 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                str += lst1(lst1(i))\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpvmcu96rs.scala:26:32 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                str += lst1(lst1(i))\n\e[31m\e[31m   |\e[0m          \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Found:\
    \    String\n\e[31m   |\e[0m                            Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvmcu96rs.scala:35:25 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    lst1.remove(lst1(i))\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove is\
    \ not a member of List[String], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvmcu96rs.scala:36:25\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                    lst2.remove(lst2(i))\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ remove is not a member of List[String], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.Imp"
  stdout: ''
  timestamp: 1659980025
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val stack\
    \ = mutable.Stack[Boolean]()\n      val isBalanced = lst.forall(x => x contains\
    \ '(' && x contains ')')\n      if (!isBalanced) return \"No\"\n      var ret\
    \ = \"\"\n      var index = -1\n      val lstr = lst.reverse\n      while(stack.nonEmpty\
    \ && index < lstr.length) {\n        val item = stack.last\n        stack.pop()\n\
    \        if (item == false) {\n          ret = (lstr.drop(index) mkString \"\"\
    )\n          break\n        }\n        index += 1\n      }\n      if (stack.nonEmpty\
    \ || index < lstr.length) return \"No\"\n      ret\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz3vs1835.scala:18:18 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m      \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mBoolean\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpz3vs1835.scala:19:54 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m      \e[33mval\e[0m \e[36misBalanced\e[0m = lst.forall(\e\
    [36mx\e[0m => x contains \e[31m'('\e[0m && x contains \e[31m')'\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                  ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                        value && is not a member\
    \ of Char\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz3vs1835.scala:29:10\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m          break\n\e[31m\e\
    [31m   |\e[0m          ^^^^^\e[0m\n\e[31m   |\e[0m          Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ inv = lst.foldLeft(new mutable.HashMap[String, List[String]]()){ (m, s) =>\n\
    \            if (m.containsKey(s)) {\n                m.get(s).push(s)\n     \
    \       } else {\n                var ns: List[String] = Nil\n               \
    \ if (s.contains('(')) {\n                    ns = s filterNot (x => x == '(')\n\
    \                } else {\n                    ns = s filterNot (x => x == ')')\n\
    \                }\n                m.put(s, ns)\n            }\n            m\n\
    \        }\n        if (inv.keys.size == 0) {\n            return \"No\"\n   \
    \     } else {\n            var result: String = \"No\"\n            var cur =\
    \ 0\n            var next = 1\n            var isGood = false\n            while\
    \ (cur < lst.length) {\n                val leftParen = lst.apply(cur)\n     \
    \           val rightParen = lst.apply(next)\n                val curRight = inv.apply(leftParen).indexOf(rightParen)\n\
    \                val curLeft = inv.apply(leftParen).lastIndexOf(rightParen)\n\
    \                if (curRight != -1) {\n                    isGood = true\n  \
    \              } else {\n                    isGood = false\n                }\n\
    \                if (curLeft == -1) result += \"Yes\"\n                if (isGood)\
    \ result += \"Yes\"\n                cur += next\n                next += 1\n\
    \            }\n            result\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6o0tnlpd.scala:18:35 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36minv\e[0m = lst.foldLeft(\e\
    [33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mList\e[0m[\e[35mString\e\
    [0m]]()){ (\e[36mm\e[0m, \e[36ms\e[0m) =>\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp6o0tnlpd.scala:19:18 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m            \e[33mif\e[0m (m.containsKey(s)) {\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value containsKey\
    \ is not a member of Any\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6o0tnlpd.scala:20:18\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m                m.get(s).push(s)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m             \
    \   value get is not a member of Any\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp6o0tnlpd.scala:24:25 --------------------\e[0m\e[0m\n\e[31m24 |\e[0m\
    \                    ns = s filterNot (\e[36mx\e[0m => x == \e[31m'('\e[0m)\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Found:    String\n\e[31m   |\e[0m      \
    \                   Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mString\e[1m\e\
    [32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6o0tnlpd.scala:26:25\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                    ns = s filterNot\
    \ (\e[36mx\e[0m => x == \e[31m')'\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \       Found:    String\n\e[31m   |\e[0m                         Required: \e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mString\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Fou"
  stdout: ''
  timestamp: 1659980025
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ result = \"No\"\n        val stack = mutable.Stack[String]()\n        val parens\
    \ = lst.map(x => if (x == \"(\") stack.toList else stack += x)\n        val isGood\
    \ = parens.forall(x => x != \"()\")\n        if (isGood) {\n            val goodStrings\
    \ = parens.filter(x => x != \"()\").takeWhile(x => x != \"()\").tail\n       \
    \     if (goodStrings.length != 1) {\n                result = \"No\"\n      \
    \      } else {\n                result = goodStrings.head\n            }\n  \
    \      }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4cxyfrr2.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659980020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ list1 = lst.head\n        val list2 = lst.tail\n        val n = list2.length\n\
    \        val list1 = list1.replaceAll(\"[()]\", \"\").replaceAll(\"[()]+\", \"\
    \")\n        var count = 0\n        var left = 0\n        var right = 0\n    \
    \    var output = \"Yes\"\n        for (i <- list1.indices) {\n            if\
    \ (list1(i) == '(') {\n                left+=1\n            } else if (list1(i)\
    \ == ')') {\n                right-=1\n            }\n            if (left < right)\
    \ {\n                count += 1\n            }\n        }\n        if (count ==\
    \ n) {\n            output = \"Yes\"\n        } else {\n            output = \"\
    No\"\n        }\n        output\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvzyjaiu_.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlist1\e[0m = list1.replaceAll(\e\
    [31m\"[()]\"\e[0m, \e[31m\"\"\e[0m).replaceAll(\e[31m\"[()]+\"\e[0m, \e[31m\"\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlist1 is already defined as \e[33mvalue\e[0m \e[35mlist1\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ ind = lst.map(_.length).max\n        val s = lst.reverse.filter(_(ind).isDefined).map(_.substring(0,ind))\n\
    \        val p = lst.map(_.charAt(ind-1))\n        if (p.forall(_.isClosed))\n\
    \            s\"No\"\n        else\n            s\"Yes${s.reverse.mkString}\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaoz9pbdn.scala:19:42 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = lst.reverse.filter(_(ind).isDefined).map(_.substring(\e\
    [31m0\e[0m,ind))\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 value isDefined is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaoz9pbdn.scala:21:23\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (p.forall(_.isClosed))\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                  value isClosed is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659980026
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ map = new mutable.HashMap[String,Int]()\n        val stack = new mutable.Stack[String]()\n\
    \        for(i <- 0 until lst.size){\n            if(i==lst.size -1){\n      \
    \          if(lst(i).contains(\"(\") && lst(i).contains(\")\"))\n            \
    \        return \"Yes\"\n                else {\n                    if(lst(i).contains(\"\
    (\"))\n                        return \"Yes\"\n                    else\n    \
    \                    return \"No\"\n                }\n            }\n       \
    \     val value = lst(i)\n            val isOpen = value.contains(\"(\")\n   \
    \         val isClose = value.contains(\")\")\n            if(!map.contains(value)){\n\
    \                map.put(value,0)\n                stack += value\n          \
    \  }\n            map.get(value) += 1\n            if(isOpen == !isClose){\n \
    \               stack.pop\n                stack += value\n            }\n   \
    \     }\n        \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv0ohjz6p.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mString\e[0m,\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv0ohjz6p.scala:19:24\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = \e[33mnew\e[0m mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // 1.\
    \ Write a method to find the balance of parentheses.\n        def balance(s: String):\
    \ Int = {\n            val l = s.length\n            var left = 0, right = l\n\
    \            while (left < right) {\n                if (s(left) <:< '(') left\
    \ += 1\n                if (s(right) <:< ')') right -= 1\n            }\n    \
    \        left - right\n        }\n\n        // 2. Write a method to compare the\
    \ two strings by concatenating them\n        //    and see if they are good.\n\
    \        def check(l: List[String], s: String): Boolean = {\n            val l\
    \ = l.filter(x => !x.contains(s))\n            if (l.length < 2) false\n     \
    \       else if (balance(s.replaceAll(\"\\\\)\", \"))\") < balance(s.replaceAll(\"\
    \\\\(\", \"(\"))) true\n            else check(l.tail, s.replaceAll(\"\\\\(\"\
    , \"(\"))\n        }\n\n        // 3. Write a recursive method to solve the problem.\n\
    \        if (lst.length == 1) lst(0)\n        else check(lst, lst(0))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmppv4t_2gr.scala:21:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mvar\e[0m \e[36mleft\e[0m = \e[31m0\e\
    [0m, right = l\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m  \
    \ |\e[0m                        end of statement expected but ',' found\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmppv4t_2gr.scala:34:92 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (balance(s.replaceAll(\e\
    [31m\"\\\\)\"\e[0m, \e[31m\"))\"\e[0m) < balance(s.replaceAll(\e[31m\"\\\\(\"\e\
    [0m, \e[31m\"(\"\e[0m))) \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m              \
    \                                                                            \
    \  ^^^^\e[0m\n\e[31m   |\e[0m                                          ')' expected,\
    \ but 'true' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppv4t_2gr.scala:22:26\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mwhile\e\
    [0m (left < right) {\n\e[31m\e[31m   |\e[0m                          ^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: right\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmppv4t_2gr.scala:23:28 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mif\e[0m (s(left) <:< \e[31m'('\e\
    [0m) left += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               value <:< is not a member of Char - did you\
    \ mean Char.<<?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppv4t_2gr.scala:24:22\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e\
    [0m (s(right) <:< \e[31m')'\e[0m) right -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ right\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppv4t_2gr.scala:24:38\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e\
    [0m (s(right) <:< \e[31m')'\e[0m) right -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \       "
  stdout: ''
  timestamp: 1659980028
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ lst1 = lst.map(x=>x.substring(1, x.length-1))\n        val lst2 = lst.map(x=>x.substring(1,\
    \ x.length-1)).filter(x=>x.equals(\"\"))\n        val lst3 = lst.filter(x=>x.contains(\"\
    (\")).toList\n        val lst4 = lst.filter(x=>x.contains(\")\")).toList\n   \
    \     if(lst1.size==lst2.size+lst3.size+lst4.size){\n            if(lst1.size==lst3.size+lst4.size){\n\
    \                if(lst2.size==lst3.size+lst4.size){\n                    if(lst3.isEmpty){\n\
    \                        \"Yes\"\n                    }else{\n               \
    \         \"No\"\n                    }\n                }else{\n            \
    \        \"No\"\n                }\n            }else{\n                \"Yes\"\
    \n            }\n        }else{\n            \"No\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: begin 1, end 0, length 1\n\t\
    at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\
    \tat Problem$.$anonfun$1(tmpy59ainze.scala:18)\n\tat scala.collection.immutable.List.map(List.scala:250)\n\
    \tat Problem$.matchParens(tmpy59ainze.scala:18)\n\tat Problem$.main(tmpy59ainze.scala:41)\n\
    \tat Problem.main(tmpy59ainze.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980028
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Solution\n\
    \        var ans = lst.foldLeft(\"No\"){ (acc,curr) => {\n            if(curr\
    \ == \"()\") \"Yes\"\n            else acc match {\n                case acc if\
    \ acc.indexOf(\"(\") < acc.indexOf(\")\") => acc\n                case acc if\
    \ acc.indexOf(\"(\") > acc.indexOf(\")\") => acc.substring(0, acc.indexOf(\"(\"\
    )) + curr + acc.substring(acc.indexOf(\")\") + 1)\n                case acc if\
    \ acc.indexOf(\"(\") == acc.indexOf(\")\") => acc + curr\n            }\n    \
    \    }}\n        ans.toUpperCase()\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe3_fnrbc.scala:30)\n\tat Problem.main(tmpe3_fnrbc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980027
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ l = lst.head // get the first element\n        var count = 0\n        for(i\
    \ <- 0 to l.length){\n            if(l.charAt(i)=='(' && count<l.length){\n  \
    \              count = count + 1\n            }\n            if(l.charAt(i)==')'\
    \ && count>0){\n                count = count - 1\n            }\n           \
    \ if(count==0 && count==l.length){\n                return \"Yes\"\n         \
    \   }\n        }\n        \"No\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: String index out of range: 3\n\
    \tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\
    \tat Problem$.matchParens$$anonfun$1(tmpcif4rwyl.scala:21)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.matchParens(tmpcif4rwyl.scala:30)\n\
    \tat Problem$.main(tmpcif4rwyl.scala:34)\n\tat Problem.main(tmpcif4rwyl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980028
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ loop(remainingParanthesis: List[String], result: List[String], i: Int) : String\
    \ = {\n            if (i == remainingParanthesis.length - 1) result.reverse.mkString(\"\
    (\", \")\")\n            else loop(remainingParanthesis, result :: result.take(i+1),\
    \ i + 1)\n        }\n        if (lst.length == 0) \"No\"\n        else loop(lst,\
    \ Nil, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2ufc4xt8.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (i\
    \ == remainingParanthesis.length - \e[31m1\e[0m) result.reverse.mkString(\e[31m\"\
    (\"\e[0m, \e[31m\")\"\e[0m)\n\e[31m\e[31m   |\e[0m                           \
    \                                                   ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                              Found:    (String, String)\n\e\
    [31m   |\e[0m                                              Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2ufc4xt8.scala:20:44 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33melse\e[0m loop(remainingParanthesis,\
    \ result :: result.take(i+\e[31m1\e[0m), i + \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                            ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                     Found:    (result : List[String])\n\e[31m\
    \   |\e[0m                                       Required: String\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659980028
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ str: List[String] = lst.takeWhile(x => x != \"\").reverse\n        // If there\
    \ are zero parentheses, return \"Yes\"\n        if (str.length == 0) \"Yes\" else\
    \ \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpagwmd0_s.scala:23)\n\tat Problem.main(tmpagwmd0_s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980029
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ countMap = lst.length.toList.foldLeft(Map[Int, Int]()){\n            case (acc,\
    \ elem) =>\n                if (elem==\"(\") {\n                    acc + (elem->1)\n\
    \                } else {\n                    acc + (elem->-1)\n            \
    \    }\n        }\n        val countMap = countMap.map{\n            case (_,v)\
    \ => v\n        }\n        val list2 = lst.length.toList.foldLeft(List[String]()){\n\
    \            case (acc, i) => acc :+ lst(i)\n        }\n        val list3 = list2.length.toList.foldLeft(List[String]()){\n\
    \            case (acc, i) => acc :+ list2(i)\n        }\n        val countMap\
    \ = countMap.toList.reverse.foldLeft(List[Int]()){\n            case (acc, elem)\
    \ =>\n                if (elem > 0) {\n                    acc :+ (elem-1)\n \
    \               } else if (elem < 0) {\n                    acc :+ (elem+1)\n\
    \                } else {\n                    acc\n                }\n      \
    \  }\n        list3.map{\n            x => countMap.reverse.foldLeft(List(false)){\
    \ case (acc, elem) =>\n                if (elem==0) {\n                    acc\
    \ :+ (true)\n                } else {\n                    acc :+ (x contains\
    \ elem) }\n            }\n        }.foldLeft(\"\"){ case (acc, res) => acc :+\
    \ (res :+ \"Yes\")}\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjjhrglte.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mcountMap\e[0m = countMap.map{\n\
    \e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mcountMap is already defined\
    \ as \e[33mvalue\e[0m \e[35mcountMap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m27 |\e[0m            \e[33mcase\e[0m (_,v) => v\n\e[31m28 |\e[0m       \
    \ }\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjjhrglte.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mcountMap\e[0m = countMap.toList.reverse.foldLeft(List[\e\
    [35mInt\e[0m]()){\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mcountMap\
    \ is already defined as \e[33mvalue\e[0m \e[35mcountMap\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m36 |\e[0m            \e[33mcase\e[0m (acc, elem)\
    \ =>\n\e[31m37 |\e[0m                \e[33mif\e[0m (elem > \e[31m0\e[0m) {\n\e\
    [31m38 |\e[0m                    acc :+ (elem-\e[31m1\e[0m)\n\e[31m39 |\e[0m \
    \               } \e[33melse\e[0m \e[33mif\e[0m (elem < \e[31m0\e[0m) {\n\e[31m40\
    \ |\e[0m                    acc :+ (elem+\e[31m1\e[0m)\n\e[31m41 |\e[0m      \
    \          } \e[33melse\e[0m {\n\e[31m42 |\e[0m                    acc\n\e[31m43\
    \ |\e[0m                }\n\e[31m44 |\e[0m        }\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpjjhrglte.scala:18:34 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mcountMap\e[0m = lst.length.toList.foldLeft(Map[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]()){\n\e[31m\e[31m   |\e[0m                     \
    \  ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value toList is not a member\
    \ of Int - did you mean Int.toInt?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjjhrglte.scala:29:31\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mlist2\e[0m = lst.length.toList.foldLeft(List[\e[35mString\e[0m]()){\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \      value toList is not a member of Int - did y"
  stdout: ''
  timestamp: 1659980028
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ matching(str:List[String], open:List[String], close:List[String]) : List[String]\
    \ = {\n            if(str.isEmpty) close\n            else if(str == open || str\
    \ == close) matching(str.tail, open, close)\n            else if(str.length ==\
    \ 1) open\n            else matching(str.tail, open ::: str.head, close ::: str.tail)\n\
    \        }\n        val open = (lst(0) match {\n            case \")\" => Nil\n\
    \            case \")(\"   => Nil\n            case \")((\"  => Nil\n        \
    \    case \")((\" => Nil\n            case \")((((\" => Nil\n            case\
    \ \")(((\"  => Nil\n            case \")((((\" => Nil\n            case \")(((((\"\
    \  => Nil\n            case \")((((((\" => Nil\n            case \")((((((\" =>\
    \ Nil\n            case \")(((((((\"  => Nil\n            case \")((((((((\" =>\
    \ Nil\n            case \")(((((((((\"  => Nil\n            case \")(((((((((\"\
    \ => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"\
    \  => Nil\n            case \")((((((((((\"  => Nil\n            case \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpano3qb_k.scala:66:16 ---------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m            \e[33mcase\e[0m \n\e[31m\e[31m   |\e[0m \
    \               ^\e[0m\n\e[31m   |\e[0m                pattern expected\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpano3qb_k.scala:68:4 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpano3qb_k.scala:84:0 ----------------------------\e[0m\e[0m\n\e[31m84\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpano3qb_k.scala:22:41 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33melse\e[0m matching(str.tail, open :::\
    \ str.head, close ::: str.tail)\n\e[31m\e[31m   |\e[0m                       \
    \                  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \             value ::: is not a member of String\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpano3qb_k.scala:83:1 ---------------------\e[0m\e[0m\n\
    \e[31m83 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659980028
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ ind = lst.indexWhere(_ startsWith \"(\")\n        val vals = lst.drop(ind)\n\
    \        val ind2 = lst.indexWhere(_ startsWith \"(\")\n        val vals2 = lst.drop(ind2)\n\
    \        var flag = true\n        var i = 0\n        while(i < vals2.length) {\n\
    \            val temp = vals(i).dropRight(1)\n            val j = i + 1\n    \
    \        while (j < vals2.length) {\n                val next = vals2(i).dropRight(1)\n\
    \                if((temp+next)==\"\") flag = false\n                else j+=1\n\
    \            }\n            i+=1\n        }\n        if(flag) \"Yes\" else \"\
    No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa8558v1_.scala:30:22 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33melse\e[0m j+=\e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m                  \
    \  value += is not a member of Int - did you mean j.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659980028
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ res = 0\n        var stack = new mutable.Stack[String]()\n        for (ele <-\
    \ lst) {\n            var opens = 0\n            for (c <- ele) {\n          \
    \      if (c == '(')\n                    opens += 1\n                else if\
    \ (c == ')')\n                    opens -= 1\n                if (opens == 0)\n\
    \                    res += 1\n                stack.push(c)\n            }\n\
    \        }\n        if (res == 0)\n            return \"No\"\n        else\n \
    \           return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnxdkk_x0.scala:19:24 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mstack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980025
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ ps = new Stack[String]\n        val newlst : List[String] = lst.filter(_ !=\
    \ \"\")\n        if (newlst.size != 1) {\n            return \"No\"\n        }\n\
    \        newlst.head match {\n            case \"(\" => ps.push(\"(\")\n     \
    \       case \")\" => ps.push(\")\")\n            case x => ps.push(x)\n     \
    \   }\n        if (ps.size != newlst.size) {\n            return \"No\"\n    \
    \    }\n        // loop through all open parentheses\n        while (true) {\n\
    \            val p = ps.pop\n            if (!ps.isEmpty) {\n                ps.head\
    \ match {\n                    case x if x == \"(\" => ps.push(x)\n          \
    \          case x if x == \")\" => ps.push(x)\n                    case _ => println(\"\
    bad string\")\n                }\n            }\n            if (ps.isEmpty) break\n\
    \        }\n        // loop through all close parentheses\n        val flag =\
    \ true\n        while (true) {\n            val p = ps.pop\n            if (!ps.isEmpty)\
    \ {\n                ps.head match {\n                    case x if x == \"(\"\
    \ => ps.push(x)\n                    case x if x == \")\" => ps.push(x)\n    \
    \                case _ => flag = false\n                }\n            }\n  \
    \          if (ps.isEmpty) break\n        }\n        if (newlst.head == \"()\"\
    ) {\n            if (flag) \"Yes\" else \"No\"\n        } else {\n           \
    \ if (flag) \"No\" else \"Yes\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpchghtnn_.scala:41:28 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mif\e[0m (ps.isEmpty) break\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                   Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpchghtnn_.scala:51:35 -----------------------------\e[0m\e\
    [0m\n\e[31m51 |\e[0m                    \e[33mcase\e[0m _ => flag = \e[31mfalse\e\
    [0m\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                              Reassignment to val flag\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpchghtnn_.scala:54:28 ------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m            \e[33mif\e[0m (ps.isEmpty) break\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                   Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659980026
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ leftParentheses = lst(0).filter(c => c == '(')\n        val rightParentheses\
    \ = lst(1).filter(c => c == ')')\n        if(leftParentheses.length < 0 || rightParentheses.length\
    \ < 0 || leftParentheses.length != rightParentheses.length) {\n            return\
    \ \"No\"\n        } else {\n            return \"Yes\"\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9x0hshcn.scala:27)\n\tat Problem.main(tmp9x0hshcn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980030
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ left = lst(0)\n        val right = lst(1)\n        var openParen = false //\
    \ flag to check open paren count\n        var closeParen = false\n        var\
    \ stack = []\n        var result = \"No\"\n        for(c <- left){\n         \
    \   c match {\n                case \"(\" => {\n                    stack push\
    \ c\n                    openParen += 1\n                }\n                case\
    \ \")\" => {\n                    openParen -= 1\n                    if(openParen\
    \ == 0){\n                        closeParen = true\n                    }\n \
    \               }\n                case _ =>\n            }\n        }\n     \
    \   if(closeParen){\n            result = \"Yes\"\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplmz1jku3.scala:22:21 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mstack\e[0m = []\n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ an identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplmz1jku3.scala:23:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mresult\e[0m = \e[31m\"No\"\e[0m\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\e[31m\
    \   |\e[0m'=>' expected, but 'end of statement' found\n\e[31m\e[31m-- Error: /tmp/tmplmz1jku3.scala:26:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \         \e[33mcase\e[0m \e[31m\"(\"\e[0m => {\n\e[31m\e[31m   |\e[0m       \
    \              ^^^\e[0m\n\e[31m   |\e[0m        Values of types String and Char\
    \ cannot be compared with == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplmz1jku3.scala:27:26\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    stack\
    \ push c\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    value push is not a member of Null\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmplmz1jku3.scala:28:30 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m                    openParen += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          value\
    \ += is not a member of Boolean - did you mean Boolean.!=?\n\e[31m\e[31m-- Error:\
    \ /tmp/tmplmz1jku3.scala:30:21 -----------------------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m                \e[33mcase\e[0m \e[31m\")\"\e[0m => {\n\e\
    [31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types String and Char cannot be compared with == or !=\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmplmz1jku3.scala:31:30 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m                    openParen -= \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          value\
    \ -= is not a member of Boolean - did you mean Boolean.!=?\n\e[31m\e[31m-- Error:\
    \ /tmp/tmplmz1jku3.scala:32:23 -----------------------------------"
  stdout: ''
  timestamp: 1659980030
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if(lst.isEmpty)\
    \ \"\"\n        else {\n            var l1 = lst.head :: lst.tail\n          \
    \  var l2 = lst.tail :: lst.head :: Nil\n            if((l1.isEmpty && l2.isEmpty)\
    \ || (l1.nonEmpty && l2.isEmpty)) \"No\"\n            else if(l1.nonEmpty && l2.nonEmpty)\
    \ matchParens(l1) ++ matchParens(l2)\n            else \"\"\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppld30_42.scala:23:79\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33melse\e[0m \e\
    [33mif\e[0m(l1.nonEmpty && l2.nonEmpty) matchParens(l1) ++ matchParens(l2)\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                     ^^\e[0m\n\e[31m   |\e[0m                               \
    \            Found:    (l2 : List[Object])\n\e[31m   |\e[0m                  \
    \                         Required: List[String]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980031
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ rec(left: String, right: List[String], index: Int, res: String): String = {\n\
    \            if (index >= right.length) return res\n            rec(left + \"\
    (\" + right(index) + \")\", right, index + 1, res + left+\"(\"+right(index)+\"\
    ))\")\n        }\n        rec(\"(\", lst, 0, \"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpda5nd9fb.scala:25)\n\tat Problem.main(tmpda5nd9fb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980034
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ openStack = mutable.Stack[String]()\n        val closeStack = mutable.Stack[String]()\n\
    \        for(i <- 0 until lst.size){\n            if(i == lst.length - 1 || lst(i)\
    \ == \")\"){\n                closeStack.push(lst(i))\n            }\n       \
    \     else if(i == lst.length - 1 && lst(i) == \"(\"){\n                openStack.push(lst(i))\n\
    \            }\n            else{\n                val openParen = openStack.mkString\n\
    \                val closeParen = closeStack.mkString\n                if(i ==\
    \ 0 || (openStack.head.toString.equals(openParen) && closeStack.head.toString.equals(closeParen))){\n\
    \                    if(openStack.size != closeStack.size) throw new Exception(\"\
    not enough parentheses match\")\n                    openStack.pop\n         \
    \           closeStack.pop\n                }\n            }\n        }\n    \
    \    if(openStack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkbbcfmgg.scala:18:24 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopenStack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpkbbcfmgg.scala:19:25 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mcloseStack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659980030
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ good = lst.filter( s => s.charAt(0) == '(' && s.charAt(s.length - 1) == ')'\
    \ )\n        println( good )\n        good.map(_.substring(1,s.length-1)).mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_k1shak0.scala:20:31 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        good.map(_.substring(\e[31m1\e[0m,s.length-\e\
    [31m1\e[0m)).mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \               ^\e[0m\n\e[31m   |\e[0m                               Not found:\
    \ s\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980030
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ p = lst.map(c => (c.charAt(0), c.charAt(1))).toSet\n        val n = lst.map(c\
    \ => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toSet\n       \
    \ val l = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.toSet\n\
    \        val n = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c\
    \ => (c).productIterator).toSet\n        val l = lst.map(c => (c.charAt(0), c.charAt(1))).map(c\
    \ => (c).productIterator).toList.distinct.map(c => (c).productIterator).toList.toSet\n\
    \        val ns = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c\
    \ => (c).productIterator).toList.toSet\n        val nl = lst.map(c => (c.charAt(0),\
    \ c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c => (c).productIterator).toList.toSet\n\
    \        val nls = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c\
    \ => (c).productIterator).toList.toSet\n        val nlnl = lst.map(c => (c.charAt(0),\
    \ c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c => (c).productIterator).toList.toList.toSet\n\
    \        val nlnls = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c\
    \ => (c).productIterator).toList.toList.toSet\n        val nlnlnl = lst.map(c\
    \ => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c\
    \ => (c).productIterator).toList.toList.toList.toSet\n        val nlnlnls = lst.map(c\
    \ => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c\
    \ => (c).productIterator).toList.toList.toList.toSet\n        val nlnlnlnl = lst.map(c\
    \ => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c\
    \ => (c).productIterator).toList.toList.toList.toList.toSet\n        val nlnlnlnls\
    \ = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphrltnfws.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphrltnfws.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = lst.map(\e[36mc\e[0m => (c.charAt(\e\
    [31m0\e[0m), c.charAt(\e[31m1\e[0m))).map(\e[36mc\e[0m => (c).productIterator).toList.distinct.map(\e\
    [36mc\e[0m => (c).productIterator).toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphrltnfws.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = lst.map(\e[36mc\e[0m => (c.charAt(\e\
    [31m0\e[0m), c.charAt(\e[31m1\e[0m))).map(\e[36mc\e[0m => (c).productIterator).toList.distinct.map(\e\
    [36mc\e[0m => (c).productIterator).toList.toSet\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmphrltnfws.scala:23:117 -----------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36mns\e[0m = lst.map(\e[36mc\e[0m => (c.charAt(\e\
    [31m0\e[0m), c.charAt(\e[31m1\e[0m))).map(\e[36mc\e[0m => (c).productIterator).toList.distinct.map(\e\
    [36mc\e[0m => (c).productIterator).toList.toSet\n\e[31m\e[31m   |\e[0m       \
    \                                                                            \
    \                              ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \             value product"
  stdout: ''
  timestamp: 1659980036
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ goodString = \"\"\n        var goodStringCount = 1\n        val paren = mutable.HashSet[String]()\n\
    \n        // Add open parentesi to stack\n        for (i <- 0 until lst.size)\
    \ {\n            val temp = lst(i)\n            if (paren.contains(temp)) {\n\
    \                paren -= temp\n                goodStringCount += 1\n       \
    \     } else {\n                paren += temp\n            }\n        }\n\n  \
    \      // Add close parentesi to stack\n        for (i <- lst.size until 0 ) {\n\
    \            val temp = lst(i)\n            if (paren.contains(temp)) {\n    \
    \            paren -= temp\n                goodStringCount += 1\n           \
    \ } else {\n                paren += temp\n            }\n        }\n\n      \
    \  // Add close parentesi to stack\n        for (i <- 0 until lst.size) {\n  \
    \          val temp = lst(i)\n            if (paren.contains(temp)) {\n      \
    \          paren -= temp\n                goodStringCount += 1\n            }\
    \ else {\n                paren += temp\n            }\n        }\n\n        if\
    \ (goodStringCount >= lst.size) {\n            goodString = \"Yes\"\n        }\
    \ else {\n            goodString = \"No\"\n        }\n\n        goodString\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpze5spsxi.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mparen\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659980032
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ str = lst.head\n        val rest = lst.tail\n        var cur = 0\n        var\
    \ found = false\n        var stack = 0\n        var strStack = List[String]()\n\
    \n        while (!found) {\n            if (strStack.contains(str)) {\n      \
    \          stack = strStack.lastIndexOf(str) match {\n                    case\
    \ Some(i) => (strStack.length - i) -1\n                    case None => 0\n  \
    \              }\n                found = true\n            }\n            else\
    \ if (cur + 1 == stack) {\n                strStack = strStack.filterNot(_ ==\
    \ str)\n                stack = 0\n                cur = 0\n                if\
    \ (rest.isEmpty || strStack.isEmpty)\n                    return \"No\"\n    \
    \            found = true\n            }\n            else {\n               \
    \ stack = strStack.lastIndexOf(str) match {\n                    case Some(i)\
    \ => (strStack.length - i) -1\n                    case None => 0\n          \
    \      }\n                cur += 1\n                if (stack == 0)\n        \
    \            found = true\n            }\n        }\n\n        val reverseStr\
    \ = str.reverse\n        var curStr = \"\"\n        while (!found) {\n       \
    \     if (curStr == reverseStr) {\n                found = true\n            }\n\
    \            else if (curStr == reverseStr.substring(reverseStr.length - 1, 1))\
    \ {\n                curStr += reverseStr.substring(0, reverseStr.length - 1)\n\
    \            }\n            else if (curStr == reverseStr.substring(reverseStr.length\
    \ - 2, reverseStr.length - 1)) {\n                curStr += reverseStr.substring(0,\
    \ reverseStr.length - 2)\n            }\n            else {\n                curStr\
    \ += reverseStr.substring(0, reverseStr.length - 1)\n            }\n        }\n\
    \n        reverseStr\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp454yquu9.scala:28:53 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    \e[33mcase\e[0m Some(i) => (strStack.length\
    \ - i) -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                  \
    \   ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m None of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\
    \e[31m   |\e[0m  (x: Double): Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m\
    \   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m \
    \ (x: Char): Int\n\e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte):\
    \ Int\n\e[31m   |\e[0m match arguments ((i : Any))\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp454yquu9.scala:29:25 --------------------\e[0m\e[0m\n\
    \e[31m29 |\e[0m                    \e[33mcase\e[0m None => \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m                         ^^^^\e[0m\n\e[31m   |\e[0m             \
    \            Found:    None.type\n\e[31m   |\e[0m                         Required:\
    \ Int\n\e[31m   |\e[0m                         pattern type is incompatible with\
    \ expected type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp454yquu9.scala:43:53\
    \ -----------------------------\e[0m\e[0m\n\e[31m43 |\e[0m                   \
    \ \e[33mcase\e[0m Some(i) => (strStack.length - i) -\e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                                     ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e\
    [0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double):\
    \ Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\
    \e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e\
    [0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments\
    \ ((i : Any))\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp454yquu9.scala:44:25\
    \ --------------------\e[0m\e[0m\n\e[31m44 |\e[0m                    \e[33mcase\e\
    [0m None => \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^^\e\
    [0m\n\e[31m   |\e[0m               "
  stdout: ''
  timestamp: 1659980032
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ list = lst.map(x => (x match {\n            case xs if xs.matches(\"\\\\(.*\\\
    \\)\")=> xs.replaceAll(\"\\\\(.*\\\\)\", \"\\\\*\")\n            case xs if xs.matches(\"\
    \\\\(.*\") => xs.replaceAll(\"\\\\(.*\", \"\\\\(\")\n            case xs if xs.matches(\"\
    \\\\*.*\") => xs.replaceAll(\"\\\\*.*\", \"\\\\*\")\n            case xs if xs.matches(\"\
    \\\\*\") => xs.replaceAll(\"\\\\*\", \"\\\\*\")\n            case xs if xs.matches(\"\
    \") => xs.replaceAll(\"\\\\*\", \"\")\n            case xs => xs\n        }))\n\
    \        val list2 = list.zipWithIndex.sortBy(x => (x(0), x(1)))\n        var\
    \ str = \"\"\n        var i = 0\n        for (i <- 1 to list2.length) {\n    \
    \        str = str + list2(i)._1\n        }\n        val newStr = str.substring(0,\
    \ str.length - 1)\n        newStr match {\n            case xs if xs.matches(\"\
    \\\\*(.*)\\\\*\") => newStr + \"*\"\n            case xs if xs.matches(\"\\\\\
    *\\\\*(.*)\\\\*\\\\*\") => newStr + \"***\"\n            case _ => newStr\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.matchParens$$anonfun$1(tmpkrsc0xeo.scala:30)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.matchParens(tmpkrsc0xeo.scala:31)\n\
    \tat Problem$.main(tmpkrsc0xeo.scala:40)\n\tat Problem.main(tmpkrsc0xeo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980039
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = Stack[List[String]]()\n        val list = new collection.mutable.ArrayBuffer[String]()\n\
    \        for(l <- lst){\n            l match {\n                case \")\" ::\
    \ tail => list.add(l)\n                case \")\" => stack.poll()\n          \
    \      case _ => {\n                    l match {\n                        case\
    \ \")(\"  :: tail => stack.push(tail.reverse:_*)\n                        case\
    \ \")(\"  => stack.append(tail.reverse:_*)\n                        case _ =>\
    \ stack.append(l:_*)\n                    }\n                }\n            }\n\
    \        }\n        if(list.size != 2) \"No\"\n        else {\n            val\
    \ stack2 = stack.toList\n            val list2 = list.filter( x => stack2.contains(x)\
    \ )\n            val list3 = list2.reverse\n            val stack3 = stack2.filter(\
    \ x => !list2.contains(x) )\n            val list4 = list3.reverse\n         \
    \   if(stack3.isEmpty) list4\n            else list4.mkString(\"(\",\")\",\")\"\
    )\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1yca03_3.scala:22:41 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mcase\e[0m \e[31m\")\"\e[0m :: tail\
    \ => list.add(l)\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue add is not a member of scala.collection.mutable.ArrayBuffer[String]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1yca03_3.scala:23:34 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mcase\e[0m \e[31m\")\"\e[0m => stack.poll()\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue poll is not a member of scala.collection.mutable.Stack[List[String]]\
    \ - did you mean stack.coll?\n\e[31m\e[31m-- Error: /tmp/tmp1yca03_3.scala:26:57\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \                 \e[33mcase\e[0m \e[31m\")(\"\e[0m  :: tail => stack.push(tail.reverse:_*)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mSequence argument type annotation `*` cannot\
    \ be used here:\n\e[31m   |\e[0mthe corresponding parameter has type List[String]\
    \ which is not a repeated parameter type\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1yca03_3.scala:27:51 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m                        \e[33mcase\e[0m \e[31m\")(\"\e[0m  => stack.append(tail.reverse:_*)\n\
    \e[31m\e[31m   |\e[0m                                                   ^^^^\e\
    [0m\n\e[31m   |\e[0m                                                   Not found:\
    \ tail\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp1yca03_3.scala:28:40\
    \ -----------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                   \
    \     \e[33mcase\e[0m _ => stack.append(l:_*)\n\e[31m\e[31m   |\e[0m         \
    \                         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mappend\e[0m in \e[33mtrait\e[0m \e[35mBuffer\e\
    [0m with types\n\e[31m   |\e[0m (elems: List[String]*): (stack : scala.collection.mutable.Stack[Li"
  stdout: ''
  timestamp: 1659980038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Your\
    \ code here\n        val parenthCounter = lst.filter(_ => _ == \"(\" || _ == \"\
    )\").size\n        if (parenthCounter == 0) \"No\"\n        else \"Yes\"\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpa3f3lrn4.scala:19:45 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mparenthCounter\e[0m = lst.filter(_\
    \ => _ == \e[31m\"(\"\e[0m || _ == \e[31m\")\"\e[0m).size\n\e[31m\e[31m   |\e\
    [0m                                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   (_$2, _$3) =>\
    \ _$2 == \e[32m\"(\"\e[0m || _$3 == \e[32m\")\"\e[0m.\n\e[31m\e[31m-- [E081] Type\
    \ Error: /tmp/tmpa3f3lrn4.scala:19:57 -----------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        \e[33mval\e[0m \e[36mparenthCounter\e[0m = lst.filter(_\
    \ => _ == \e[31m\"(\"\e[0m || _ == \e[31m\")\"\e[0m).size\n\e[31m\e[31m   |\e\
    [0m                                                         ^\e[0m\n\e[31m   |\e\
    [0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$3 of expanded function:\n\e[31m   |\e[0m   (_$2,\
    \ _$3) => _$2 == \e[32m\"(\"\e[0m || _$3 == \e[32m\")\"\e[0m.\n2 errors found\n"
  stdout: ''
  timestamp: 1659980032
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // This\
    \ checks if all items in the list are open or closed\n        // if any item isn't\
    \ closed, it's an invalid string\n        if(lst.forall(_.contains('('))){\n \
    \           val opens = lst.filter(_.contains('('))\n            val closes =\
    \ lst.filter(_.contains(')'))\n            if(opens.size != closes.size){\n  \
    \              return \"No\"\n            }\n            val openChars = opens.map(_.toString.toInt)\n\
    \            val closeChars = closes.map(_.toString.toInt)\n            // This\
    \ counts the number of open parentheses\n            // and checks if the number\
    \ of open and closed parentheses\n            // are equal\n            if(opens.size\
    \ == closes.size){\n                if(openChars.toSet == closeChars.toSet){\n\
    \                    return \"Yes\"\n                }\n            }\n      \
    \      return \"No\"\n        }\n        return \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqyes8pv8.scala:41)\n\tat Problem.main(tmpqyes8pv8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Code\
    \ goes here\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_g363cqb.scala:17:51\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mmatchParens\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mString\e[0m]) : \e[35mString\e[0m =\
    \ {\n\e[31m\e[31m   |\e[0m                                                   ^\e\
    [0m\n\e[31m   |\e[0m                                                   Found:\
    \    Unit\n\e[31m   |\e[0m                                                   Required:\
    \ String\n\e[31m18 |\e[0m        \e[34m// Code goes here\e[0m\n\e[31m19 |\e[0m\
    \    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980037
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[Int](1 , 0)\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size){\n            val str = lst(i)\n         \
    \   val openParen = str.indexOf(\"(\")\n            val closeParen = str.indexOf(\"\
    )\")\n            val openParenIndex = str.indexOf(\"(\", openParen+1)\n     \
    \       val closeParenIndex = str.indexOf(\")\", closeParen+1)\n            stack.push(openParenIndex+1)\n\
    \            stack.push(closeParenIndex+1)\n            while(stack.length > 0){\n\
    \                val openParenIndex = stack.pop()\n                val closeParenIndex\
    \ = stack.pop()\n                if(openParenIndex < closeParenIndex){\n     \
    \               result.push(str)\n                    break\n                }\n\
    \                result.push(str.substring(openParenIndex+1, closeParenIndex+1))\n\
    \            }\n        }\n        if(result.size == lst.size){\n            \"\
    Yes\"\n        } else {\n            \"No\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxm5l3p6y.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mInt\e[0m](\e[31m1\e[0m , \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxm5l3p6y.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxm5l3p6y.scala:33:20\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                    break\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659980035
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ dfs(lst : List[String], res: String, i: Int): String = {\n            if (i\
    \ == lst.length)\n                if (res == \"\")\n                    res\n\
    \                else\n                    \"No\"\n            else\n        \
    \        dfs(lst, res+lst(i), i+1)\n        }\n\n        var res = \"\"\n    \
    \    var i = lst.size - 1\n        while (i>0) {\n            if (lst(i) == \"\
    (\") {\n                val tmp = dfs(lst.reverse, \"\", i)\n                if\
    \ (tmp == \"Yes\")\n                    res += lst(i)\n                i = i -\
    \ 1\n            } else if (lst(i) == \")\") {\n                val tmp = dfs(lst,\
    \ \"\", i)\n                if (tmp == \"Yes\")\n                    res += lst(i)\n\
    \                i = i - 1\n            } else {\n                val tmp = dfs(lst,\
    \ \"\", i)\n                if (tmp == \"Yes\")\n                    res += lst(i)\n\
    \                i = i - 1\n            }\n        }\n\n        res + dfs(lst.reverse,\
    \ \"\", i)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwgr715p1.scala:52)\n\tat Problem.main(tmpwgr715p1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty)\
    \ \"\"\n        else {\n            var str = lst(0)\n            var stack =\
    \ Stack[Int](1,0)\n            var index = 0\n            var good = true // =\
    \ false // flag to indicate whether there's any way to make good string\n    \
    \        while (index<str.length) {\n                if (str.charAt(index)=='(')\
    \ stack.push(index)\n                else if (str.charAt(index)==')') {\n    \
    \                val top = stack.pop()\n                    if (stack.empty) good\
    \ = false // = false // flag to indicate whether there's any way to make good\
    \ string\n                    else if (stack.top() < top-1) good = false\n   \
    \                 else if (stack.top()==top+1 && stack.contains(top-1)) good =\
    \ false\n                    else stack.push(top)\n                }\n       \
    \         index++\n            }\n            if (stack.empty) \"\"\n        \
    \    else good ? \"Yes\" : \"No\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp9_tm7_o7.scala:33:23 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                index++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp9_tm7_o7.scala:28:30 --------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                    \e[33mif\e[0m (stack.empty) good = \e[31mfalse\e[0m\
    \ \e[34m// = false // flag to indicate whether there's any way to make good string\e\
    [0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Found:    scala.collection.mutable.Stack[Int @uncheckedVariance]\n\e\
    [31m   |\e[0m        Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E050]\
    \ Type Error: /tmp/tmp9_tm7_o7.scala:29:35 -----------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m                    \e[33melse\e[0m \e[33mif\e[0m (stack.top()\
    \ < top-\e[31m1\e[0m) good = \e[31mfalse\e[0m\n\e[31m\e[31m   |\e[0m         \
    \                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \e[33mmethod\e\
    [0m \e[35mtop\e[0m in \e[33mclass\e[0m \e[35mStack\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmp9_tm7_o7.scala:30:35 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    \e[33melse\e[0m \e[33mif\e[0m (stack.top()==top+\e\
    [31m1\e[0m && stack.contains(top-\e[31m1\e[0m)) good = \e[31mfalse\e[0m\n\e[31m\e\
    [31m   |\e[0m                             ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                  \e[33mmethod\e[0m \e[35mtop\e[0m in \e[33mclass\e[0m \e[35mStack\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp9_tm7_o7.scala:35:22 --------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m            \e[33mif\e[0m (stack.empty) \e[31m\"\"\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        //If\
    \ we have two string and they have no parenthesis\n        if(lst.size == 2){\n\
    \            val p1 = lst.head\n            val p2 = lst.last\n            p1\
    \ match {\n                case s\"${p2}$\" => s\"Yes\"\n                case\
    \ _ => s\"No\"\n            }\n        }\n        //If there is one string with\
    \ parenthesis\n        else if(lst.size == 1){\n            val p1 = lst.head\n\
    \            p1 match {\n                case s\"${p1}$\" => s\"Yes\"\n      \
    \          case _ => s\"No\"\n            }\n        }\n        //If there is\
    \ no parenthesis\n        else {\n            val p1 = lst.head\n            p1\
    \ match {\n                case s\"${p1}$\" => s\"Yes\"\n                case\
    \ _ => s\"No\"\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp3mgsltuv.scala:23:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mcase\e[0m \e[31ms\"\e[0m${p2}\e\
    [31m$\" => s\"Yes\e[0m\"\n\e[31m\e[31m   |\e[0m                              \
    \         ^\e[0m\n\e[31m   |\e[0m                                       unclosed\
    \ string literal\n\e[31m\e[31m-- Error: /tmp/tmp3mgsltuv.scala:31:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33mcase\e[0m \e[31ms\"\e[0m${p1}\e\
    [31m$\" => s\"Yes\e[0m\"\n\e[31m\e[31m   |\e[0m                              \
    \         ^\e[0m\n\e[31m   |\e[0m                                       unclosed\
    \ string literal\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3mgsltuv.scala:39:36\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                \e[33mcase\e\
    [0m \e[31ms\"\e[0m${p1}\e[31m$\" => s\"Yes\e[0m\"\n\e[31m\e[31m   |\e[0m     \
    \                               ^^^\e[0m\n\e[31m   |\e[0m                    \
    \        '=>' expected, but string interpolator found\n3 errors found\n"
  stdout: ''
  timestamp: 1659980037
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ ret = \"No\"\n        if (lst.size != 2) return ret\n        val head = (lst.head)\n\
    \        val tail = (lst.tail)\n        var open = 0\n        var close = 0\n\
    \        if (head.charAt(0) == '(') open = 1\n        if (head.charAt(0) == ')')\
    \ close = 1\n        if (head.charAt(1) == '(') open += 1\n        if (head.charAt(1)\
    \ == ')') close += 1\n        if (close != open) return \"No\"\n        var res\
    \ = 0\n        tail.foreach(x => {\n            if (x == '(') open += 1\n    \
    \        if (x == '[' || x == '{' || x == '(') open -= 1\n            if (x ==\
    \ ')' || x == ']' || x == ')') close -= 1\n            if (x == '}' || x == '}')\
    \ close -= 1\n            if (open == 0 && close == 0) res +=1\n        })\n \
    \       if (res == 0) ret = \"Yes\"\n        return ret\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpvskw4m05.scala:31:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mif\e[0m (x == \e[31m'('\e[0m) open\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Values of types String and Char cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- Error: /tmp/tmpvskw4m05.scala:32:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mif\e[0m (x == \e[31m'['\e[0m || x ==\
    \ \e[31m'{'\e[0m || x == \e[31m'('\e[0m) open -= \e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ String and Char cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpvskw4m05.scala:32:28\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m32 |\e[0m       \
    \     \e[33mif\e[0m (x == \e[31m'['\e[0m || x == \e[31m'{'\e[0m || x == \e[31m'('\e\
    [0m) open -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types String and Char cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpvskw4m05.scala:32:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mif\e[0m (x == \e[31m'['\e[0m || x ==\
    \ \e[31m'{'\e[0m || x == \e[31m'('\e[0m) open -= \e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Values of types String and Char cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpvskw4m05.scala:33:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mif\e[0m (x == \e[31m')'\e[0m || x ==\
    \ \e[31m']'\e[0m || x == \e[31m')'\e[0m) close -= \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ String and Char cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpvskw4m05.scala:33:28\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m33 |\e[0m       \
    \     \e[33mif\e[0m (x == \e[31m')'\e[0m || x == \e[31m']'\e[0m || x == \e[31m')'\e\
    [0m) close -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Value"
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val (left,\
    \ right) = (lst.head match {\n        case '(' => Some(lst.tail.head),\n     \
    \   case ')' => Some(lst.tail.head),\n        case _ => None\n      }) match {\n\
    \        case Some(x) => Some((x.mkString))\n        case None => \"No\"\n   \
    \   }\n      if(left.isEmpty && right.isEmpty)\n        \"Yes\"\n      else\n\
    \        matchParens(lst.tail) match {\n          case \"\" => \"Yes\"\n     \
    \     case _ => left.get + right.get + matchParens(lst.tail)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpikzcoll9.scala:19:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mcase\e[0m \e[31m'('\e[0m => Some(lst.tail.head),\n\
    \e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e\
    [0m                                 end of statement expected but ',' found\n\e\
    [31m\e[31m-- Error: /tmp/tmpikzcoll9.scala:19:13 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mcase\e[0m \e[31m'('\e[0m => Some(lst.tail.head),\n\
    \e[31m\e[31m   |\e[0m             ^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpikzcoll9.scala:24:13 --------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m        \e[33mcase\e[0m None => \e[31m\"No\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m             ^^^^\e[0m\n\e[31m   |\e[0m             Found:    None.type\n\
    \e[31m   |\e[0m             Required: Some[String]\n\e[31m   |\e[0m          \
    \   pattern type is incompatible with expected type\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpikzcoll9.scala:26:14 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m      \e[33mif\e[0m(left.isEmpty && right.isEmpty)\n\e\
    [31m\e[31m   |\e[0m         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         value isEmpty\
    \ is not a member of Any\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpikzcoll9.scala:31:25\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m          \e[33mcase\e[0m\
    \ _ => left.get + right.get + matchParens(lst.tail)\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    value get\
    \ is not a member of Any\n5 errors found\n"
  stdout: ''
  timestamp: 1659980039
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      lst.foldLeft(\"\
    Yes\") { (result, e) =>\n        val parens = e.split(\"\\\\(\").length\n    \
    \    if (parens == lst.filter(s => s.startsWith(e)).size) {\n          result\
    \ + \"Yes\"\n        } else {\n          result + \"No\"\n        }\n      }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp02t25e1j.scala:28)\n\tat Problem.main(tmp02t25e1j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val stack\
    \ = mutable.Stack[String]()\n      var ret = \"No\"\n      for(x <- lst) {\n \
    \       if(x contains '(') {\n          stack.push(x)\n        }\n        if(x\
    \ contains ')') {\n          if(stack.size > 0) {\n            stack.pop\n   \
    \         if(stack.size == 0) {\n              ret +=\"Yes\"\n            }\n\
    \          }\n        }\n      }\n      ret\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5la_gaor.scala:18:18 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m      \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ str1 = lst(0) // first string in lst\n        val str2 = lst(1) // second string\
    \ in lst\n        val stack = ListBuffer[String]() // stack for checking\n   \
    \     val stackSize = lst.size - 2 // number of open parentheses in lst\n    \
    \    val index = 0\n        while (index < stackSize) {\n            if (str1\
    \ == \"(\") {\n                stack.push(str1)\n                index += 1\n\
    \            }\n            if (str1 == \")\") {\n                val lastStr\
    \ = stack.pop\n                if (lastStr != \"(\") {\n                    return\
    \ \"No\"\n                }\n                index += 1\n            }\n     \
    \   }\n        if (index == stackSize) {\n            return \"Yes\"\n       \
    \ }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl7gg2gkq.scala:25:22 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                stack.push(str1)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue push is not a member\
    \ of scala.collection.mutable.ListBuffer[String] - did you mean stack.last?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpl7gg2gkq.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                index += \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value +=\
    \ is not a member of Int - did you mean index.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpl7gg2gkq.scala:29:36 ------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                \e[33mval\e[0m \e[36mlastStr\e[0m = stack.pop\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ pop is not a member of scala.collection.mutable.ListBuffer[String] - did you\
    \ mean stack.drop?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl7gg2gkq.scala:33:22\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                index +=\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                value += is not a member of Int - did you mean index.!=?\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def\
    \ matchParens(lst : List[String], s : String) : String = {\n            if (lst.isEmpty)\n\
    \                \"No\"\n            else if (lst.head == \"(\")\n           \
    \     matchParens(lst.tail, \"Yes\") + matchParens(lst.tail, s.dropRight(1))\n\
    \            else if (lst.head == \")\")\n                matchParens(lst.tail,\
    \ s.dropRight(1) + matchParens(lst.tail, \"Yes\"))\n            else if (lst.head\
    \ == \"Yes\" && lst.tail.head == \"Yes\")\n                matchParens(lst.tail.tail,\
    \ lst.head + s)\n            else\n                matchParens(lst.tail, \"No\"\
    )\n        }\n\n        matchParens(lst, \"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpml6zwhzz.scala:34)\n\tat Problem.main(tmpml6zwhzz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ bList: List[Boolean] = lst.map( x => (x == \"(\") ? true : false)\n        val\
    \ aList: List[Boolean] = lst.map( x => (x == \"(\") ? false : true)\n        if\
    \ (bList.reduce(_ && _) && aList.reduce(_ && _)) {\n            if (bList.reduce(_\
    \ * _) && aList.reduce(_ * _)) {\n                if (bList.reduce(_ * _ * aList.reduce(_\
    \ * _))) \n                    \"Yes\" else \"No\"\n                \n       \
    \         else {\n                    val newList: List[String] = lst.map(x =>\
    \ x + \"()\")\n                    if (newList.reduce(_ + _)) \"Yes\" else \"\
    No\"\n                }\n            } else {\n                if (bList.reduce(_\
    \ * _)) \"Yes\" else \"No\"\n                else \n                    val newList:\
    \ List[String] = lst.map(x => x + \"()\")\n                    if (newList.reduce(_\
    \ + _)) \"Yes\" else \"No\"\n            }\n        }\n        else \n       \
    \     if (bList.reduce(_ * _)) \"Yes\" else \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpcrbxw2wk.scala:25:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33melse\e[0m {\n\e[31m\e[31m   |\e\
    [0m                ^^^^\e[0m\n\e[31m   |\e[0m                end of statement\
    \ expected but 'else' found\n\e[31m\e[31m-- Error: /tmp/tmpcrbxw2wk.scala:31:16\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m31 |\e[0m       \
    \         \e[33melse\e[0m \n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e\
    [31m   |\e[0m                end of statement expected but 'else' found\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmpcrbxw2wk.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            }\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\
    \e[31m   |\e[0m            '}' expected, but unindent found\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpcrbxw2wk.scala:18:60 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mbList\e[0m: \e[35mList\e[0m[\e\
    [35mBoolean\e[0m] = lst.map( \e[36mx\e[0m => (x == \e[31m\"(\"\e[0m) ? \e[31mtrue\e\
    [0m : \e[31mfalse\e[0m)\n\e[31m\e[31m   |\e[0m                               \
    \                  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \              value ? is not a member of Boolean\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpcrbxw2wk.scala:19:60 ------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36maList\e[0m: \e[35mList\e[0m[\e[35mBoolean\e\
    [0m] = lst.map( \e[36mx\e[0m => (x == \e[31m\"(\"\e[0m) ? \e[31mfalse\e[0m : \e\
    [31mtrue\e[0m)\n\e[31m\e[31m   |\e[0m                                        \
    \         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \     value ? is not a member of Boolean\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpcrbxw2wk.scala:21:31 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m            \e[33mif\e[0m (bList.reduce(_ * _) && aList.reduce(_ * _)) {\n\e\
    [31m\e[31m   |\e[0m                             ^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ * is not a member of Boolean, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   "
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[List[String]]()\n        for(x <- lst)\n            if(x.toList.size\
    \ == 0)\n                stack += x\n            else if(x.toList(0).toString\
    \ == \"(\")\n                stack += x.drop(1)\n            else if(!stack.isEmpty){\n\
    \                if(x.toList(0).toString == \")\" && stack.last.toList(0).toString\
    \ == \"(\")\n                    stack.pop()\n                else\n         \
    \           stack += x\n            }\n        if(stack.size <= 0)\n         \
    \   \"No\"\n        else\n            \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp755alnk9.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mList\e[0m[\e[35mString\e[0m]]()\n\e[31m\e[31m   |\e[0m                   \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659980039
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if(lst.length\
    \ == 0) \"Yes\"\n        else if(lst.length == 1) \"No\"\n        else if(lst.length\
    \ == 2) \"Yes\"\n        else matchParens(lst.tail) + matchParens(lst.init)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp447lpzni.scala:25)\n\tat Problem.main(tmp447lpzni.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ good = \"Yes\"\n        for (a <- lst if a.contains(\"(\")) {\n            for\
    \ (b <- lst if b.contains(\")\")) {\n                val newA = a.substring(a.indexOf(\"\
    (\"), a.lastIndexOf(\")\"))\n                val newB = b.substring(b.indexOf(\"\
    (\"), b.lastIndexOf(\")\"))\n                if ((newA + newB) == a) {\n     \
    \               good = \"No\"\n                    break\n                }\n\
    \            }\n        }\n        good\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8t6d7660.scala:25:20 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980039
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = Stack.empty[String]\n        val result = Stack.empty[String]\n    \
    \    lst.reverse.foreach(x => {\n            if(x == \"(\") {\n              \
    \  stack.push(x)\n            } else if(x == \")\") {\n                if(!stack.peek().equals(\"\
    (\")) {\n                    result += \"No\"\n                } else {\n    \
    \                if(!stack.peek().equals(\"(\")) {\n                        result\
    \ += \"Yes\"\n                    }\n                }\n                stack.pop()\n\
    \            }\n        })\n        result.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5c8y28_k.scala:24:26 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e[0m(!stack.peek().equals(\e\
    [31m\"(\"\e[0m)) {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue peek is not a member of scala.collection.mutable.Stack[String]\
    \ - did you mean stack.head?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5c8y28_k.scala:27:30\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    \e[33mif\e\
    [0m(!stack.peek().equals(\e[31m\"(\"\e[0m)) {\n\e[31m\e[31m   |\e[0m         \
    \               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue peek is not a member of\
    \ scala.collection.mutable.Stack[String] - did you mean stack.head?\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stackWithParen = mutable.Stack[Boolean]()\n\
    \n        def addParen(s: String) : Unit = {\n            if (s.contains(\"(\"\
    ) || s.contains(\")\")) stackWithParen.push(true)\n            else stackWithParen.push(false)\n\
    \            stack += s\n        }\n\n        lst.foreach { s =>\n           \
    \ if (s.contains(\"(\")) {\n                addParen(s)\n            }\n     \
    \       if (s.contains(\")\")) {\n                if (stack.size == 1 && stackWithParen.head)\
    \ {\n                    return \"Yes\"\n                } else {\n          \
    \          return \"No\"\n                }\n            }\n        }\n      \
    \  return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg_24b678.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpg_24b678.scala:19:29 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mstackWithParen\e[0m = mutable.Stack[\e\
    [35mBoolean\e[0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: mutable\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        //Write\
    \ your code here\n        if(lst.size < 2) \n            return \"No\"\n     \
    \   else\n           var open = 1\n           var close = 0\n           var str\
    \ = \"\"\n           var curStr = lst(0)\n           var result = \"No\"\n   \
    \        while(curStr != \"\") {\n                if(curStr == \"(\") \n     \
    \               open += 1\n                else if(curStr == \")\")\n        \
    \            close += 1\n                else\n                    return \"No\"\
    \n\n                if(open > close)\n                    result = \"Yes\"\n \
    \               curStr = lst(open)\n                open -= 1\n              \
    \  close += 1\n           }\n           return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprr5nc9g6.scala:44)\n\tat Problem.main(tmprr5nc9g6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980043
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if(lst.isEmpty)\
    \ \n            \"No\" \n        else if(lst.head == lst.last.head) {\n      \
    \      val s = lst.tail\n            (lst.head == s.head) match {\n          \
    \      case true => matchParens(s.tail)\n                case _ => \"No\"\n  \
    \          }\n        } else {\n            val s = lst.tail\n            matchParens(s.tail)\
    \ match {\n                case true => \"Yes\"\n                case _ => matchParens(s.tail)\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp3mcs8i4v.scala:20:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m(lst.head == lst.last.head)\
    \ {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Values of types String and Char cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3mcs8i4v.scala:29:21\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                \e[33mcase\e\
    [0m \e[31mtrue\e[0m => \e[31m\"Yes\"\e[0m\n\e[31m\e[31m   |\e[0m             \
    \        ^^^^\e[0m\n\e[31m   |\e[0m                     Found:    (\e[31mtrue\e\
    [0m : Boolean)\n\e[31m   |\e[0m                     Required: String\n\e[31m \
    \  |\e[0m                     pattern type is incompatible with expected type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980043
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var\
    \ flag = 1\n        var res : String = \"\"\n        for (x <- lst) {\n      \
    \      val s = x.replaceAll(\"\\\\(\", \"\").replaceAll(\"\\\\)\", \"\")\n   \
    \         val l = s.length\n            var cur = 0\n            var sum = 0\n\
    \            var flag = 0\n            for(i <- 0 until s.length){\n         \
    \       if(s.charAt(i) == '('){\n                    sum += 1\n              \
    \  } else if(s.charAt(i) == ')'){\n                    if(sum > 0){\n        \
    \                sum -= 1\n                    } else {\n                    \
    \    flag = 1\n                    }\n                }\n                cur +=\
    \ 1\n            }\n            if(flag == 0){\n                res = \"No\"\n\
    \                break\n            }\n            res = res + \"(\" + s.substring(cur,\
    \ cur + l) + \")\"\n        }\n        if (res.equals(\"\")) {\n            res\
    \ = \"Yes\"\n        }\n        return res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqb9nj7r4.scala:40:16 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      require(!lst.isEmpty)\n\
    \      var stack = Stack(lst.head)\n      var result = true\n      for (a <- lst.tail)\
    \ {\n        if (stack.hasLeft) {\n          stack.peek.right\n          stack.pop()\n\
    \        } else {\n          if (stack.hasRight) {\n            stack.peek.left\n\
    \            stack.pop()\n          } else {\n            stack.pop()\n      \
    \    }\n          stack.pop()\n        }\n      }\n      if (stack.hasLeft) {\n\
    \        result = \"No\"\n      } else if (stack.hasRight) {\n        result =\
    \ \"Yes\"\n      }\n      result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg4fajul7.scala:22:18 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (stack.hasLeft) {\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue hasLeft is not\
    \ a member of scala.collection.mutable.Stack[String] - did you mean scala.collection.mutable.Stack[String].scanLeft?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg4fajul7.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m          stack.peek.right\n\e[31m\e[31m   |\e[0m   \
    \       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue peek is not a member of scala.collection.mutable.Stack[String]\
    \ - did you mean scala.collection.mutable.Stack[String].head?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpg4fajul7.scala:26:20 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m          \e[33mif\e[0m (stack.hasRight) {\n\e[31m\e\
    [31m   |\e[0m              ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue hasRight\
    \ is not a member of scala.collection.mutable.Stack[String] - did you mean scala.collection.mutable.Stack[String].scanRight?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg4fajul7.scala:27:18 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            stack.peek.left\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue peek is not a member of scala.collection.mutable.Stack[String]\
    \ - did you mean scala.collection.mutable.Stack[String].head?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpg4fajul7.scala:35:16 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m      \e[33mif\e[0m (stack.hasLeft) {\n\e[31m\e[31m \
    \  |\e[0m          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue hasLeft is not a member\
    \ of scala.collection.mutable.Stack[String] - did you mean scala.collection.mutable.Stack[String].scanLeft?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg4fajul7.scala:36:17 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        result = \e[31m\"No\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                 ^^^^\e[0m\n\e[31m   |\e[0m                 Found:    (\e[32m\"\
    No\"\e[0m : String)\n\e[31m   |\e[0m                 Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation avail"
  stdout: ''
  timestamp: 1659980044
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ p = lst.foldLeft(List[List[String]]()) {\n            (acc, x) =>\n        \
    \        if (acc.isEmpty) x :: acc.head\n                else if (x.charAt(0)\
    \ == '(' && acc.last.last.charAt(0) == ')') acc.last.last + x else acc :+ x\n\
    \        }\n        p.filter(_.length == 2).foldLeft(List[String]()) {\n     \
    \       (acc, x) =>\n                if (x.charAt(0) == '(' && acc.last.last.charAt(0)\
    \ == ')') acc.last.last + x\n                else if (acc.isEmpty) x :: acc.head\n\
    \                else {\n                    if (acc.last.last != x.charAt(0))\
    \ acc :+ x else acc :+ acc.last.last + x\n                }\n        }.head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp06mx41g0.scala:20:33\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                \e[33mif\e[0m\
    \ (acc.isEmpty) x :: acc.head\n\e[31m\e[31m   |\e[0m                         \
    \        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 Found:\
    \    List[String]\n\e[31m   |\e[0m                                 Required: List[\e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mString\e[1m\e[32m]\e[0m]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp06mx41g0.scala:21:79 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (x.charAt(\e\
    [31m0\e[0m) == \e[31m'('\e[0m && acc.last.last.charAt(\e[31m0\e[0m) == \e[31m')'\e\
    [0m) acc.last.last + x \e[33melse\e[0m acc :+ x\n\e[31m\e[31m   |\e[0m       \
    \                                                                        ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Found:    String\n\
    \e[31m   |\e[0m                                            Required: List[List[String]]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp06mx41g0.scala:21:109\
    \ -------------------\e[0m\e[0m\n\e[31m21 |\e[0m                \e[33melse\e[0m\
    \ \e[33mif\e[0m (x.charAt(\e[31m0\e[0m) == \e[31m'('\e[0m && acc.last.last.charAt(\e\
    [31m0\e[0m) == \e[31m')'\e[0m) acc.last.last + x \e[33melse\e[0m acc :+ x\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                                                   ^\e[0m\n\e[31m   |\e[0m  \
    \                                                Found:    (x : String)\n\e[31m\
    \   |\e[0m                                                  Required: List[String]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp06mx41g0.scala:25:22\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                \e[33mif\e\
    [0m (x.charAt(\e[31m0\e[0m) == \e[31m'('\e[0m && acc.last.last.charAt(\e[31m0"
  stdout: ''
  timestamp: 1659980044
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ lst1 = lst.map( x => x.split(\"(\").size)\n        val lst2 = lst.map( x =>\
    \ x.split(\")\").size)\n        val len = lst1.zipWithIndex.max( x => x._2 - x._1)\n\
    \        val l1 = lst1.filter( x => x._2 < len)\n        val l2 = lst2.filter(\
    \ x => x._2 < len)\n        val l3 = lst1.filter( x => x._2 > len && x._2 < len)\n\
    \        val l4 = lst2.filter( x => x._2 > len && x._2 < len)\n        val s1\
    \ = l1.map( x => x._2).mkString(\"\")\n        val s2 = l2.map( x => x._2).mkString(\"\
    \")\n        val s3 = l3.map( x => x._2).mkString(\"\")\n        val s4 = l4.map(\
    \ x => x._2).mkString(\"\")\n        val n = l1.size + l2.size + l3.size + l4.size\
    \ + 1\n        if (s1.isEmpty) {\n            if (s2.isEmpty) {\n            \
    \    if (s3.isEmpty) {\n                    if (s4.isEmpty) {\n              \
    \          \"Yes\"\n                    } else {\n                        \"No\"\
    \n                    }\n                } else {\n                    \"No\"\n\
    \                }\n            } else {\n                \"No\"\n           \
    \ }\n        } else {\n            \"No\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp4jtuhe3r.scala:20:43 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = lst1.zipWithIndex.max(\
    \ \e[36mx\e[0m => x._2 - x._1)\n\e[31m\e[31m   |\e[0m                        \
    \                 ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \            Wrong number of parameters, expected: 2\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp4jtuhe3r.scala:21:37 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mval\e[0m \e[36ml1\e[0m = lst1.filter( \e[36mx\e[0m\
    \ => x._2 < len)\n\e[31m\e[31m   |\e[0m                                   ^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value _2 is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4jtuhe3r.scala:22:37\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36ml2\e[0m = lst2.filter( \e[36mx\e[0m => x._2 < len)\n\e[31m\e[31m   |\e[0m\
    \                                   ^^^^\e[0m\n\e[31m   |\e[0m               \
    \                    value _2 is not a member of Int\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp4jtuhe3r.scala:23:37 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m        \e[33mval\e[0m \e[36ml3\e[0m = lst1.filter( \e[36mx\e[0m\
    \ => x._2 > len && x._2 < len)\n\e[31m\e[31m   |\e[0m                        \
    \           ^^^^\e[0m\n\e[31m   |\e[0m                                   value\
    \ _2 is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4jtuhe3r.scala:24:37\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36ml4\e[0m = lst2.filter( \e[36mx\e[0m => x._2 > len && x._2 < len)\n\e[31m\e\
    [31m   |\e[0m                                   ^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                value _2 is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp4jtuhe3r.scala:25:32 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36ms1\e[0m = l1.map( \e[36mx\e\
    [0m => x._2).mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \              ^^^^\e[0m\n\e[31m   |\e[0m                              value _2\
    \ is not a member of Int\n\e[31m\e[31m-- [E"
  stdout: ''
  timestamp: 1659980044
