name: HumanEval_93_encode
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that takes a message, and encodes in such a \n    // way\
  \ that it swaps case of all letters, replaces all vowels in \n    // the message\
  \ with the letter that appears 2 places ahead of that \n    // vowel in the english\
  \ alphabet. \n    // Assume only letters. \n    // Examples:\n    // >>> encode((\"\
  test\"))\n    // (\"TGST\")\n    // >>> encode((\"This is a message\"))\n    //\
  \ (\"tHKS KS C MGSSCGG\")\n    def encode(message : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
  )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n\
  \    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"This is\
  \ a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw\
  \ WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
completions: ["        val chars = mutable.ArrayBuffer.empty[Char]\n        for(i\
    \ <- 0 until message.length) chars += message(i)\n        chars.distinct\n   \
    \         .map((c: Char) => {\n            val newCase = \n                (c).toLowerCase\
    \ \n                    .replaceAll(\"aeiou\", \"qwrty\")\n                  \
    \  .replaceAll(\"AEIOU\", \"QWRTY\")\n                    .replaceAll(\"i\", \"\
    k\")\n                    .replaceAll(\"I\", \"K\")\n                    .replaceAll(\"\
    u\", \"h\")\n                    .replaceAll(\"U\", \"H\")\n                 \
    \   .replaceAll(\"o\", \"l\")\n                    .replaceAll(\"O\", \"L\")\n\
    \                    .replaceAll(\"a\", \"s\")\n                    .replaceAll(\"\
    A\", \"S\")\n                    .replaceAll(\"e\", \"x\")\n                 \
    \   .replaceAll(\"E\", \"X\")\n                    .replaceAll(\"b\", \"z\")\n\
    \                    .replaceAll(\"B\", \"Z\")\n                    .replaceAll(\"\
    h\", \"s\")\n                    .replaceAll(\"H\", \"S\")\n                 \
    \   .replaceAll(\"l\", \"r\")\n                    .replaceAll(\"L\", \"R\")\n\
    \                    .replaceAll(\"s\", \"t\")\n                    .replaceAll(\"\
    S\", \"T\")\n                    .replaceAll(\"q\", \"w\")\n                 \
    \   .replaceAll(\"Q\", \"W\")\n                    .replaceAll(\"e\", \"x\")\n\
    \                    .replaceAll(\"E\", \"X\")\n                    .replaceAll(\"\
    q\", \"z\")\n                    .replaceAll(\"Q\", \"Z\")\n                 \
    \   .replaceAll(\"r\", \"y\")\n                    .replaceAll(\"R\", \"Y\")\n\
    \                    .replaceAll(\"l\", \"t\")\n                    .replaceAll(\"\
    L\", \"T\")\n                    .replaceAll(\"q\", \"y\")\n                 \
    \   .replaceAll(\"Q\", \"Y\")\n                    .replaceAll(\"t\", \"v\")\n\
    \                    .replaceAll(\"T\", \"V\")\n                    .replaceAll(\"\
    q\", \"z\")\n                    .replaceAll(\"Q\", \"Z\")\n                 \
    \   .replaceAll(\"y\", \"x\")\n                    .replaceAll(\"Y\", \"X\")\n\
    \                    .replaceAll(\"z\", \"y\")\n                    .replaceAll(\"\
    Z\", \"Y\")\n                    .replaceAll(\"h\", \"s\")\n                 \
    \   .replaceAll(\"H\", \"S\")\n                    .replaceAll(\"s\", \"r\")\n\
    \                    .replaceAll(\"S\", \"R\")\n                    .replaceAll(\"\
    s\", \"y\")\n                    .replaceAll(\"S\", \"Y\")\n                 \
    \   .replaceAll(\"r\", \"t\")\n                    .replaceAll(\"R\", \"T\")\n\
    \                    .replaceAll(\"r\", \"v\")\n                    .replaceAll(\"\
    R\", \"V\")\n                    .replaceAll(\"y\", \"x\")\n                 \
    \   .replaceAll(\"Y\", \"X\")\n                    .replaceAll(\"y\", \"z\")\n\
    \                    ", "        // Your code here\n        var newMessage = message\n\
    \        for(letter <- newMessage){\n            letter match {\n            \
    \    case 'a' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'b' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'c' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'd' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'e' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'f' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'g' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'h' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'i' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'j' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'k' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'l' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'm' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'n' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'o' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'p' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'q' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'r' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 's' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 't' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'u' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'v' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'w' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'x' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'y' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case 'z' => \n                    newMessage = newMessage.map(_.toUpperCase())\n\
    \                case _ => \n                    if(newMessage.indexOf(\"aeiou\"\
    ) > -1){\n                        newMessage = newMessage.map(_.toUpperCase())\n\
    \                    }else{\n                        newMessage = newMessage.map(_.toLowerCase())\n\
    \                    }\n            }\n        }\n        for(vowel <- \"aeiou\"\
    ){\n            var indexOfVowel = newMessage.indexOf(vowel)\n            if(indexOfV",
  "        val charArray = message.toCharArray.asInstanceOf[mutable.WrappedArray[Char]]\n\
    \        val vowelArray = Array('a','e','i','o','u')\n        val charMap = new\
    \ HashMap[Char, Char]\n        val charMap2 = new HashMap[Char, Char]\n\n    \
    \    for (i <- 0 to charArray.length-1) {\n          charMap(charArray(i)) = charMap2.get(charArray(i))\n\
    \          charMap2.update(charArray(i), charMap(charArray(i+1))) \n        }\n\
    \n        charMap2.toSeq.map(_.toString) mkString \"\"", "        val letters\
    \ = message.map(x => x.toUpperCase)\n        val vowels = \"AEIOUaeiou\".toCharArray\n\
    \        val vowelIndices = scala.collection.mutable.ArrayBuffer.empty[Int]\n\
    \        val currentLetter = 0\n        for (letter <- letters) {\n          \
    \  val indexOfVowel = vowels.indexOf(letter)\n            vowelIndices += indexOfVowel\n\
    \            if (indexOfVowel == currentLetter) {\n                currentLetter\
    \ += 1\n            }\n        }\n        val encodedMessage = message.map(letter\
    \ => vowels(vowelIndices(currentLetter - 1)))\n        encodedMessage.toString\
    \ + message.map(letter => vowels(vowelIndices(currentLetter + 1)))", "       \
    \ val alphabet = scala.collection.mutable.List(\"a\",\"b\",\"c\",\"d\",\"e\",\"\
    f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"\
    s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\")\n        val vowels = scala.collection.mutable.List(\"\
    a\",\"e\",\"i\",\"o\",\"u\")\n        val result = new StringBuilder()\n     \
    \   for( x <- message.toCharArray()) {\n           if(alphabet(x) != x) alphabet(x)\
    \ := vowels(x)\n           else alphabet(x) := alphabet(x - 2)\n        }\n  \
    \      for( x <- vowels) {\n            if(result.indexOf(x.toString()) == -1)\
    \ result +:= x.toString()\n        }\n        result.toString()", "        def\
    \ swapCase(s:String) : String = {\n            var newS = \"\"\n            for(i\
    \ <- 0 until s.length){\n                var c1 = s.charAt(i)\n              \
    \  var c2 = s.charAt(i+1)\n                newS = newS + c2.toUpperCase + c1.toLowerCase\
    \ \n            }\n            return newS\n        }\n        val newMessage\
    \ = swapCase(message)\n        val vowels = Set(\"A\", \"E\", \"I\", \"O\", \"\
    U\")\n        val vowelsPlusOne = vowels ++ Set(\"A\",\"E\",\"I\",\"O\",\"U\"\
    )\n        val vowelsPlusTwo = vowelsPlusOne ++ Set(\"A\",\"E\",\"I\",\"O\",\"\
    U\")\n        val vowelsPlusThree = vowelsPlusTwo ++ Set(\"A\",\"E\",\"I\",\"\
    O\",\"U\")\n        val vowelsPlusFour = vowelsPlusThree ++ Set(\"A\",\"E\",\"\
    I\",\"O\",\"U\")\n        val vowelsPlusFive = vowelsPlusFour ++ Set(\"A\",\"\
    E\",\"I\",\"O\",\"U\")\n        val vowelsPlusSix = vowelsPlusFive ++ Set(\"A\"\
    ,\"E\",\"I\",\"O\",\"U\")\n        val vowelsPlusSeven = vowelsPlusSix ++ Set(\"\
    A\",\"E\",\"I\",\"O\",\"U\")\n        val vowelsPlusEight = vowelsPlusSeven ++\
    \ Set(\"A\",\"E\",\"I\",\"O\",\"U\")\n        val vowelsPlusNine = vowelsPlusEight\
    \ ++ Set(\"A\",\"E\",\"I\",\"O\",\"U\")\n        val vowelsPlusTen = vowelsPlusNine\
    \ ++ Set(\"A\",\"E\",\"I\",\"O\",\"U\")\n        val vowelsPlusEleven = vowelsPlusTen\
    \ ++ Set(\"A\",\"E\",\"I\",\"O\",\"U\")\n        val vowelsPlusTwelve = vowelsPlusEleven\
    \ ++ Set(\"A\",\"E\",\"I\",\"O\",\"U\")\n        val vowelsPlusThirteen = vowelsPlusTwelve\
    \ ++ Set(\"A\",\"E\",\"I\",\"O\",\"U\")\n        val vowelsPlusFourteen = vowelsPlusThirteen\
    \ ++ Set(\"A\",\"E\",\"I\",\"O\",\"U\")\n        val vowelsPlusFifteen = vowelsPlusFourteen\
    \ ++ Set(\"A\",\"E\",\"I\",\"O\",\"U\")\n        val vowelsPlusSixteen = vowelsPlusFifteen\
    \ ++ Set(\"A\",\"E\",\"", "        var result = \"\"\n        var currentLetter\
    \ = 0\n        var i = 0\n        while (i < message.length) {\n            currentLetter\
    \ = message.charAt(i).toInt\n            if ((currentLetter == 0) || (currentLetter\
    \ == 1))\n                result += currentLetter\n            else if (currentLetter\
    \ == 2) {\n                result += message.charAt(i + 1)\n                i\
    \ = i + 2\n            }\n            else\n                result += message.charAt(i)\n\
    \            i = i + 1\n        }\n        return result", "        // Create\
    \ an empty string and go through the message\n        // and replace all letters\
    \ 2 places ahead of the vowel\n        // with a lower case letter of the English\
    \ alphabet\n        val encMessage : String = \"\"\n        for(i <- message)\
    \ {\n            if (i == 'a') encMessage += \"g\"\n            else if (i ==\
    \ 'e') encMessage += \"q\"\n            else if (i == 'i') encMessage += \"k\"\
    \n            else if (i == 'o') encMessage += \"e\"\n            else if (i ==\
    \ 'u') encMessage += \"j\"\n            else if (i == 'A') encMessage += \"G\"\
    \n            else if (i == 'E') encMessage += \"Q\"\n            else if (i ==\
    \ 'I') encMessage += \"K\"\n            else if (i == 'O') encMessage += \"E\"\
    \n            else if (i == 'U') encMessage += \"J\"\n            else if (i ==\
    \ 'B') encMessage += \"G\"\n            else if (i == 'F') encMessage += \"Q\"\
    \n            else if (i == 'K') encMessage += \"K\"\n            else if (i ==\
    \ 'M') encMessage += \"M\"\n            else if (i == 'P') encMessage += \"P\"\
    \n            else if (i == 'T') encMessage += \"T\"\n            else if (i ==\
    \ 'X') encMessage += \"X\"\n            else if (i == 'Z') encMessage += \"Z\"\
    \n            else if (i == 'c') encMessage += \"l\"\n            else if (i ==\
    \ 'd') encMessage += \"m\"\n            else if (i == 's') encMessage += \"s\"\
    \n            else if (i == 'f') encMessage += \"v\"\n            else if (i ==\
    \ 'g') encMessage += \"x\"\n            else encMessage += i\n        }\n    \
    \    encMessage", "        val upperCaseMessage = message.toUpperCase\n      \
    \  val newMessage = mutable.StringBuilder.newBuilder\n\n        for(c <- upperCaseMessage)\
    \ {\n            val index = ((upperCaseMessage.indexOf(c))+2)\n            val\
    \ replacement = englishLetter.charAt(index)\n            newMessage.append(replacement).append(c)\n\
    \        }\n\n        newMessage.toString()", "        val message = message.toLowerCase\n\
    \        val alphabet = Array('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = Array('a','e','i','o','u')\n        val vowelPosition =\
    \ vowels.map(_.toString.length)\n        val letterPosition = Array(0,2,4,6,8)\n\
    \        val result = message.zip(alphabet)\n        val map1 = message.zip(letterPosition)\n\
    \        val map2 = message.zip(vowelPosition)\n        result.map{case (ch, pos)\
    \ => (\n            if(pos < vowelPosition(ch)) ch\n            else vowels(alphabet(map1(ch))\
    \ - vowels(alphabet(map2(ch))) + pos) })\n                .mkString(\"\")", " \
    \       var newMessage = message\n        val vowels = \"aeiou\"\n        val\
    \ letters = \"bcdfghjklmnpqrstvwxyz\"\n        var i = 0\n        while(i < newMessage.length){\n\
    \            if(letters.indexOf(newMessage(i, 1))!=0){\n                newMessage\
    \ = \n                newMessage.substring(0,i)+\n                    letters.indexOf(newMessage(i,\
    \ 1))+\n                    newMessage.substring(i+1)\n            }\n       \
    \     i += 1\n        }\n        newMessage", "        val newMessage = message\
    \ filter { ch =>\n            ch match {\n                case c if c.toUpper\
    \ == c => c.toUpper\n                case c if c.toLower == c => c.toLower\n \
    \               case _ => c.toUpperCase\n            }\n        }\n        val\
    \ letterMap = Map(\"a\" -> \"@\", \"b\" -> \"!\", \"c\" -> \"#\", \"d\" -> \"\
    $\", \"e\" -> \"%\", \"f\" -> \"&\", \"g\" -> \"*\", \"h\" -> \"(\", \"i\" ->\
    \ \")\", \"j\" -> \"=\", \"k\" -> \"[\", \"l\" -> \"]\", \"m\" -> \"\\\\\", \"\
    n\" -> \"<\", \"o\" -> \">\", \"p\" -> \"|\", \"q\" -> \"\\\\\", \"r\" -> \"(\"\
    , \"r\" -> \")\", \"s\" -> \"~\", \"t\" -> \"1\", \"u\" -> \"2\", \"v\" -> \"\
    3\", \"w\" -> \"4\", \"x\" -> \"5\", \"y\" -> \"6\", \"z\" -> \"7\").withDefaultValue(\"\
    \")\n        val vowelMap = Map(\"a\" -> \"A\", \"b\" -> \"B\", \"c\" -> \"C\"\
    , \"d\" -> \"D\", \"e\" -> \"E\", \"f\" -> \"F\", \"g\" -> \"G\", \"h\" -> \"\
    H\", \"i\" -> \"I\", \"j\" -> \"J\", \"k\" -> \"K\", \"l\" -> \"L\", \"m\" ->\
    \ \"M\", \"n\" -> \"N\", \"o\" -> \"O\", \"p\" -> \"P\", \"q\" -> \"Q\", \"r\"\
    \ -> \"R\", \"s\" -> \"S\", \"t\" -> \"T\", \"u\" -> \"U\", \"v\" -> \"V\", \"\
    w\" -> \"W\", \"x\" -> \"X\", \"y\" -> \"Y\", \"z\" -> \"Z\").withDefaultValue(\"\
    \")\n        val newMessage1 = newMessage map { ch =>\n            ch match {\n\
    \                case ch if vowelMap.contains(ch) => vowelMap(ch)\n          \
    \      case ch if letterMap.contains(ch) => letterMap(ch)\n                case\
    \ _ => ch\n            }\n        }\n        newMessage1 mkString \"\"", "   \
    \     val alphabet = Map('a'->'A','b'->'B','c'->'C','d'->'D','e'->'E','f'->'F','g'->'G','h'->'H','i'->'I','j'->'J','k'->'K','l'->'L','m'->'M','n'->'N','o'->'O','p'->'P','q'->'Q','r'->'R','s'->'S','t'->'T','u'->'U','v'->'V','w'->'W','x'->'X','y'->'Y','z'->'Z')\n\
    \        val replaced_letters = mutable.HashSet[String]()\n        for (letter\
    \ <- message)\n        {\n            if(replaced_letters.contains(letter)) \n\
    \            {\n                val index = alphabet.find(_ == letter).getOrElse(throw\
    \ new Exception(\"letter not found in alphabet: \" + letter))\n              \
    \  replaced_letters += alphabet.apply(index + 2)\n                replaced_letters\
    \ += alphabet.apply(index + 2)\n            } else replaced_letters += letter\n\
    \        }\n        val message_replaced_letters = replaced_letters.toSeq.sortBy(_).mkString(\"\
    \")\n        val replaced_vowels = mutable.HashSet[String]()\n        for (letter\
    \ <- message_replaced_letters)\n        {\n            if(replaced_vowels.contains(letter))\
    \ \n            {\n                val index = alphabet.find(_ == letter).getOrElse(throw\
    \ new Exception(\"letter not found in alphabet: \" + letter))\n              \
    \  replaced_vowels += alphabet.apply(index + 2)\n            } else replaced_vowels\
    \ += letter\n        }\n        val message_replaced_vowels = replaced_vowels.toSeq.sortBy(_).mkString(\"\
    \")\n        val replaced_letters_vowels = message_replaced_letters + message_replaced_vowels\n\
    \        val message_replaced_letters_vowels_replaced_vowels_replaced_letters\
    \ = replaced_letters_vowels.replaceAllIn(message_replaced_vowels_replaced_letters,\
    \ \"V\")\n        message_replaced_letters_vowels_replaced_vowels_replaced_letters.replace(\"\
    a\", \"A\").replace(\"b\", \"B\").replace(\"c\", \"C\").replace(\"d\", \"D\").replace(\"\
    e\", \"E\").replace(\"f\", \"F\").replace(\"g\", \"G\").replace(\"h\", \"H\").replace(\"\
    i\", \"I\").replace(\"j\", \"J\").replace(\"k\", \"K\").replace(\"l\", \"L\").replace(\"\
    m\", \"M\").replace(\"n\", \"N\").replace(\"o\", \"O\").replace(\"p\", \"P", " \
    \       var message = message\n        // We need to iterate through all the letters\
    \ in the message\n        for(i <- 0 until message.length()) {\n            var\
    \ currVowel = message(i)\n            var newVowel = currVowel\n            if(i\
    \ + 1 < message.length) {\n                // Now we check which letter appears\
    \ 2 letters ahead\n                // of our current letter\n                val\
    \ nextVowel = message(i + 1)\n                if((nextVowel == \"a\" || nextVowel\
    \ == \"e\" || nextVowel == \"i\" || nextVowel == \"o\" || nextVowel == \"u\")\
    \ && (currVowel == \"a\" || currVowel == \"e\" || currVowel == \"i\" || currVowel\
    \ == \"o\" || currVowel == \"u\")) {\n                    newVowel = nextVowel\n\
    \                }\n            }\n            message = message.replaceAll(currVowel,\
    \ newVowel)\n        }\n        message", "        var enc = new StringBuilder(message.length)\n\
    \        for (i<- message.length-1) {\n            var newEnc = \"\"\n       \
    \     var currentLetter = message.charAt(i)\n            var prevLetter = message.charAt(i-1)\n\
    \            if (isVowel(currentLetter)) {\n                enc += (currentLetter.toUpperCase)\n\
    \            } else {\n                enc += (currentLetter)\n            }\n\
    \            for (j <- 1 until prevLetter) {\n                if (currentLetter\
    \ != prevLetter) {\n                    newEnc += ((message.charAt(i-2) + message.charAt(i-1)).toUpperCase)\n\
    \                } else {\n                    newEnc += ((message.charAt(i-2)\
    \ + message.charAt(i-1))) \n                }\n            }\n            enc\
    \ += newEnc\n        }\n        return enc.toString()", "        // TODO: write\
    \ code here\n        val res = new StringBuilder(message)\n        for(c <- message)\
    \ {\n            val index = alphabet(c) - 'a'\n            if (index > -1) res.append(letters(index))\n\
    \        }\n        return res.toString", "        var vowels = \"aeiou\"\n  \
    \      var message : String = \"\"\n        var j = 0\n        for (i<- 0 until\
    \ message.length ) {\n            val chi = message.charAt(i)\n            if\
    \ (chi isLetter) {\n                val vowel = vowels.find(_ == chi).toList\n\
    \                val newVowel = vowel match {\n                    case Some(v)\
    \ => vowels(v)\n                    case None => chi\n                }\n    \
    \            val newMessage = message.substring(0, j) + newVowel + message.substring(j\
    \ + 1)\n                j += 1\n                message = newMessage\n       \
    \     }\n        }\n        return message", '        // TODO: Your code here',
  '        // TODO: Fill in your code here', "        val encodedMessage = \"\"\n\
    \        for(a <- message) {\n            if(a == \"a\") {\n                encodedMessage\
    \ = encodedMessage + \"g\"\n            } else if(a == \"e\") {\n            \
    \    encodedMessage = encodedMessage + \"k\"\n            } else if(a == \"i\"\
    ) {\n                encodedMessage = encodedMessage + \"g\"\n            } else\
    \ if(a == \"o\") {\n                encodedMessage = encodedMessage + \"k\"\n\
    \            } else if(a == \"u\") {\n                encodedMessage = encodedMessage\
    \ + \"s\"\n            } else if(a == \"c\") {\n                encodedMessage\
    \ = encodedMessage + \"g\"\n            } else if(a == \"d\") {\n            \
    \    encodedMessage = encodedMessage + \"k\"\n            } else if(a == \"g\"\
    ) {\n                encodedMessage = encodedMessage + \"g\"\n            } else\
    \ if(a == \"h\") {\n                encodedMessage = encodedMessage + \"h\"\n\
    \            } else if(a == \"k\") {\n                encodedMessage = encodedMessage\
    \ + \"k\"\n            } else if(a == \"l\") {\n                encodedMessage\
    \ = encodedMessage + \"g\"\n            } else if(a == \"m\") {\n            \
    \    encodedMessage = encodedMessage + \"m\"\n            } else if(a == \"n\"\
    ) {\n                encodedMessage = encodedMessage + \"n\"\n            } else\
    \ if(a == \"s\") {\n                encodedMessage = encodedMessage + \"s\"\n\
    \            } else if(a == \"t\") {\n                encodedMessage = encodedMessage\
    \ + \"t\"\n            } else if(a == \"x\") {\n                encodedMessage\
    \ = encodedMessage + \"x\"\n            } else if(a == \"y\") {\n            \
    \    encodedMessage = encodedMessage + \"y\"\n            } else if(a == \"z\"\
    ) {\n                encodedMessage = encodedMessage + \"z\"\n            } else\
    \ if(a == \"A\") {\n                encodedMessage = encodedMessage + \"A\"\n\
    \            } else if(a == \"B\") {\n                encodedMessage = encodedMessage\
    \ + \"B\"\n            } else if(a == \"C\") {\n                encodedMessage\
    \ = encodedMessage + \"C\"\n            } else if(a == \"D\") {\n            \
    \    encodedMessage = encodedMessage + \"D\"\n            } else if(a == \"E\"\
    ) {\n                encodedMessage = encodedMessage + \"E\"\n            } else\
    \ if(a == \"F\") {\n                encodedMessage = encodedMessage + \"F\"\n\
    \            } else if(a == \"G\") {\n                encodedMessage = encodedMessage\
    \ + \"G\"\n            } else if(a == \"H\") {\n                encodedMessage\
    \ = encodedMessage + \"H\"\n            } else if(a == \"I\") {\n            \
    \    encodedMessage = encodedMessage + \"I\"\n            } else if(a == \"J\"\
    ) {\n                encodedMessage = encodedMessage + \"J\"\n            } else\
    \ if(a == \"K\") {", "        // Write your code here.\n        val englishMap\
    \ = scala.collection.mutable.Map[Char, Char]()\n        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        for (letter <- message) {\n            englishMap\
    \ += (letter, englishMap.getOrElse(letter, vowels(messages.indexOf(letter) + 2)))\n\
    \        }\n        val result = message.mkString\n        for(vowel <- vowels)\
    \ {\n            result += englishMap.get(vowel)\n        }\n        result",
  "      val vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n      val message =\
    \ message.toUpperCase\n      var buffer = \"\"\n      message foreach {\n    \
    \    c => {\n          buffer += (c == c.toLowerCase ? c.toUpperCase : c.toLowerCase)\n\
    \        }\n      }\n      buffer.toUpperCase\n      vowels.foreach {\n      \
    \  vowel => {\n          buffer = buffer.replaceAll(vowel, vowel + 2)\n      \
    \  }\n      }\n      buffer", "        val messageList = message.split(\" \").toList\n\
    \        val newMessageList = mutable.ArrayBuffer.empty[String]\n        val finalList\
    \ = mutable.ArrayBuffer.empty[String]\n        messageList.foreach { elem =>\n\
    \            val firstLetter = elem.head\n            val secondLetter = elem.last\n\
    \            val secondLetterIndex = messageList.indexOf(secondLetter)\n     \
    \       var firstLetterIndex = messageList.indexOf(firstLetter)\n            if\
    \ (firstLetterIndex > secondLetterIndex) {\n                val temp = secondLetter\n\
    \                secondLetter = firstLetter\n                firstLetter = temp\n\
    \            }\n            val indexToSwapWith = secondLetterIndex + 2\n    \
    \        var tempString = \"\"\n            for (i <- firstLetterIndex to indexToSwapWith)\
    \ {\n                val firstChar = messageList(i)\n                val secondChar\
    \ = messageList(indexToSwapWith)\n                if (firstChar.equalsIgnoreCase(secondChar))\
    \ {\n                    tempString += secondChar\n                } else {\n\
    \                    tempString += firstChar\n                }\n            }\n\
    \            newMessageList += tempString\n        }\n        for (i <- newMessageList.indices){\n\
    \            finalList += newMessageList(i)\n        }\n        finalList.toString",
  "        val vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\");\n        var\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n        var output = \"\";\n   \
    \     for (c <- message.toCharArray) {\n            var c = c\n            val\
    \ position = alphabet.indexOf(c);\n            if (position > -1) {\n        \
    \        alphabet.updated(position, position + 1);\n                alphabet.updated(position\
    \ + 1, position);\n            }\n        }\n        for (a <- alphabet.toSet)\
    \ {\n            for (b <- alphabet.toSet) {\n                if (vowels.contains(a)\
    \ && vowels.contains(b)) {\n                    output = output + a\n        \
    \        } else {\n                    output = output + b\n                }\n\
    \            }\n        }\n        output", "        val enc = message.toCharArray.map\
    \ { x =>\n            val y = x.toUpperCase(Locale.ROOT)\n            y match\
    \ {\n                case c if c >= 'a' && c <= 'z' => (c + 2).toChar\n      \
    \          case c if c >= 'A' && c <= 'Z' => (c + 2).toChar\n                case\
    \ c => c\n            }\n        }\n        val charArray = Array(0 until enc.length).map(i\
    \ => enc(i))\n        val array = new Array[String](charArray.length)\n      \
    \  charArray.zipWithIndex.foreach { case (c, i) =>\n            array(i) = c.toString\n\
    \        }\n        array.mkString(\"\")", "    val map = Map(\n      \"A\" ->\
    \ \"A\", \"B\" -> \"B\", \"C\" -> \"C\", \"D\" -> \"D\", \"E\" -> \"E\",\n   \
    \   \"F\" -> \"F\", \"G\" -> \"G\", \"H\" -> \"H\", \"I\" -> \"I\", \"J\" -> \"\
    J\",\n      \"K\" -> \"K\", \"L\" -> \"L\", \"M\" -> \"M\", \"N\" -> \"N\", \"\
    O\" -> \"O\",\n      \"P\" -> \"P\", \"Q\" -> \"Q\", \"R\" -> \"R\", \"S\" ->\
    \ \"S\", \"T\" -> \"T\",\n      \"U\" -> \"U\", \"V\" -> \"V\", \"W\" -> \"W\"\
    , \"X\" -> \"X\", \"Y\" -> \"Y\",\n      \"Z\" -> \"Z\", \"a\" -> \"A\", \"b\"\
    \ -> \"B\", \"c\" -> \"C\", \"d\" -> \"D\", \"e\" -> \"E\",\n      \"f\" -> \"\
    F\", \"g\" -> \"G\", \"h\" -> \"H\", \"i\" -> \"I\", \"j\" -> \"J\",\n      \"\
    k\" -> \"K\", \"l\" -> \"L\", \"m\" -> \"M\", \"n\" -> \"N\", \"o\" -> \"O\",\n\
    \      \"p\" -> \"P\", \"q\" -> \"Q\", \"r\" -> \"R\", \"s\" -> \"S\", \"t\" ->\
    \ \"T\",\n      \"u\" -> \"U\", \"v\" -> \"V\", \"w\" -> \"W\", \"x\" -> \"X\"\
    , \"y\" -> \"Y\",\n      \"z\" -> \"Z\", \"?\" -> \"?\")\n\n    message.map {\
    \ ch =>\n      ch.toUpperCase\n    }.map { ch => \n      map get ch\n    }.map\
    \ { ch =>\n      if (map.contains(ch)) {\n        map get ch\n      } else {\n\
    \        ch\n      }\n    }.mkString\n  }\n}\n</code>\n<|/ a |>\n<| c |>\nPlease\
    \ add an explanation to your answer. Code dumps aren't very helpful.\n<|/ c |>\n\
    <| c |>\nThe code works, but it gives me this output when I run it `tHKS KS C\
    \ MGSSCGG`\n<|/ c |>\n<| a tags=functional-programming,scala dscore=2 |>\nAnother\
    \ solution:\n<code>\nval a = \"This is a message\"\nval b = a.toUpperCase\nval\
    \ c = b.map(c => Map(\"?\" -> \"?\", \"a\" -> \"A\", \"", "        val alphabet\
    \ = List('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\
    \ 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',\
    \ 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\
    \ 'U', 'V', 'W', 'X', 'Y', 'Z')\n        var result = \"\"\n        for (i <-\
    \ 0 to message.length - 1) {\n            result += alphabet(alphabet.indexOf(message(i))\
    \ + (message(i) + 1).hashCode) % 26\n        }\n        return result", "    \
    \    val arr = message.chars.toList\n        arr.sortBy { _ - 97 }\n        val\
    \ alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".toList\n        val map = mutable.Map[Char,\
    \ Int]()\n        arr.zipWithIndex.foreach { case (v, i) =>\n            map(i\
    \ + 97) = (alphabet.indexOf(v.toString) + 2)\n        }\n        arr.zipWithIndex.map\
    \ { case (v, i) =>\n            alphabet(i + 97) + v.toString.substring(0,1)\n\
    \        }", "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        var\
    \ newMessage = \"\"\n        for (letter <- message) {\n            val index\
    \ = alphabet.indexOf(letter)\n            if (index != 0) {\n                val\
    \ second = alphabet.charAt(index - 1)\n                val replacement = alphabet.charAt(index\
    \ + 1)\n                newMessage += (letter + (replacement + second))\n    \
    \        }\n            else {\n                newMessage += letter\n       \
    \     }\n        }\n        return newMessage", "        val englishLower = Array('a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n        val vowelLower = Array('A',\
    \ 'a', 'E', 'e', 'I', 'i', 'O', 'o', 'U', 'u')\n\n        // use mutable data\
    \ structures for faster lookups and to update \n        // the message in-place\n\
    \        val envowLower = mutable.ArrayBuffer.empty[String]\n        val vowel\
    \ = mutable.ArrayBuffer.empty[String]\n        val vowelEnvow = mutable.ArrayBuffer.empty[String]\n\
    \n        // get the english lower case letters and vowels into a mutable \n \
    \       // data structure so that we can perform lookups quickly and \n      \
    \  // update the message in-place\n        val english = message.split(\" \").map(englishLower.indexOf(_)).filter(_\
    \ > -1)\n        val vowels = message.split(\" \").map(vowelLower.indexOf(_)).filter(_\
    \ > -1)\n        val vowelEnvow = message.split(\" \").map(vowel +=_).filter(_\
    \ > -1)\n\n        // iterate over the english and vowel arrays to get \n    \
    \    // the positions in the english and vowel data structures \n        // that\
    \ correspond to the english letters and vowels\n        for (i <- 0 until english.length)\
    \ {\n            val envow = vowelEnvow.indexOf(i)\n            val vowel = vowels.indexOf(i)\n\
    \n            // if the position matches the position of the English \n      \
    \      // letter then add it to the envow array\n            if (envow != -1)\n\
    \                envowLower += english(envow)\n            // else if the position\
    \ matches the position of the \n            // vowel then add it to the vowel\
    \ array\n            else if (vowel != -1)\n                vowelLower += vowel(vowel)\n\
    \        }\n\n        // join the english letters and vowels arrays together \n\
    \        // to form the encoded string\n        val envow = envowLower.mkString(\"\
    \").trim.toUpperCase\n        val vowel = vowelLower.mkString(\"\").trim.toUpperCase\n\
    \n        // get the position of the next vowel in the english alphabet\n    \
    \    // and return the result with the vowel replaced\n        val vowelIndex\
    \ = (english.indexOf(\"a\") + english.indexOf(\"e\") + \n                english.indexOf(\"\
    i\") + english.indexOf(\"o\") + \n                english.indexOf(\"u\") + english.indexOf(\"\
    y\")) mod 26\n        val encodedString = envow.replaceAll(vowel, vowels(vowelIndex))\n\
    \        return encodedString", "        var letters = message match {\n     \
    \       case s: String => s.toUpperCase.split(\"\")\n            case _ => Nil\n\
    \        }\n        \n        var vowels = \"aeiou\"\n        var vowelPositions\
    \ = letters.zipWithIndex\n        \n        var result = \"\"\n        letters.foreach\
    \ { letter =>\n            vowelPositions.foreach { \n                case (vowelPosition,\
    \ letterPosition) =>\n                    if (letterPosition == vowelPosition)\
    \ {\n                        vowel = vowel.take(vowelPosition)\n             \
    \       }\n            }\n        }", "        val vowels = \"AEIOUaeiou\".toCharArray\n\
    \        val replacement = \"BbCcDdFfGgHhJjKkLlMmNnPpRrSsTtVvWwXxYyZz\".toCharArray\n\
    \        val letters = message.map(_.toLower)\n        val messageWithVowels =\
    \ new StringBuilder\n        val messageWithLetters = new StringBuilder\n    \
    \    for(letter <- letters){\n            if(vowels.contains(letter)) {\n    \
    \            val index = vowels.indexOf(letter)\n                messageWithVowels.append(vowels(index\
    \ - 1))\n                messageWithVowels.append(vowels(index + 1))\n       \
    \     } else {\n                messageWithLetters.append(letter)\n          \
    \  }\n        }\n        letters.foreach{letter =>\n            if(vowels.contains(letter))\
    \ {\n                val index = vowels.indexOf(letter)\n                messageWithLetters.append(vowels(index\
    \ - 1))\n                messageWithLetters.append(vowels(index + 1))\n      \
    \      } else {\n                messageWithVowels.append(replacement(0))\n  \
    \          }\n        }\n        messageWithLetters.toString()", "        var\
    \ newMessage = message\n        for (letter <- message) {\n            val letterValue\
    \ = letter.toUpper\n            if (letterValue == 'A' || letterValue == 'E' ||\
    \ letterValue == 'I' || letterValue == 'O' || letterValue == 'U') {\n        \
    \        newMessage = newMessage.substring(0, newMessage.length-1)\n         \
    \       newMessage = newMessage + letterValue\n                newMessage = newMessage\
    \ + letterValue.charAt(1)\n            } else {\n                newMessage =\
    \ newMessage + letterValue\n            }\n        }\n        for (vowel <- newMessage)\
    \ {\n            val vowelValue = vowel.toUpper\n            if (vowelValue ==\
    \ 'A' || vowelValue == 'E' || vowelValue == 'I' || vowelValue == 'O' || vowelValue\
    \ == 'U') {\n                newMessage = newMessage.substring(0, newMessage.length-1)\n\
    \                newMessage = newMessage + vowelValue\n                newMessage\
    \ = newMessage + vowelValue.charAt(1)\n            }\n        }\n        return\
    \ newMessage", "        var str = \"\"\n        for (x <- message) {\n       \
    \     str = str + x.toUpperCase(Locale.ROOT)\n        }\n        var vowels =\
    \ \"AEIOUaeiou\"\n        str = str.replaceAll(vowels, \"\")\n        str = str.replaceAll(\"\
    [aeiouAEIOU]\", \"\").reverse\n        var result = \"\"\n        var placeHolder\
    \ = \"\"\n        for (x <- str) {\n            val y = x.toUpperCase(Locale.ROOT)\n\
    \            if (vowels.contains(y)) {\n                placeHolder = y\n    \
    \        }\n            if (placeHolder != \"\") {\n                result +=\
    \ placeHolder\n                placeHolder = \"\"\n            }\n        }\n\
    \        if (placeHolder != \"\") {\n            result += placeHolder\n     \
    \   }\n        return result", "        val letters = message.map(x=>x.toUpperCase).mkString\n\
    \        val vowels = \"AEIOU\"\n        val encoded = letters.foldLeft(\"\")(\
    \ (result, letter) => result + letter +  vowels(vowels.indexOf(letter.toLowerCase.toLowerCase)+1)\
    \  )\n        encoded", "        var result = new StringBuilder\n        message\
    \ foreach { x =>\n            val l = x.toLowerCase // or x.charAt(0)\n      \
    \      if (l == 'a') result.append(l)\n            else if (!(l == 'e' || l ==\
    \ 'i' || l == 'o' || l == 'u'))\n                result.append(l.toUpperCase)\n\
    \            else\n                result.append(x.toUpperCase.charAt(2))\n  \
    \      }\n        return result.toString", "        var newString = \"\"\n   \
    \     var newVowel = \"\"\n        var newVowel2 = \"\"\n        var newVowel3\
    \ = \"\"\n        var countVowels = 0\n        for(char <- message){\n       \
    \     if(('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z')){\n    \
    \            newString = newString + char\n            }else{\n              \
    \  if((('a' <= char && char <= 'z') && (newVowel == \"\"))){\n               \
    \     newVowel = char\n                    countVowels = countVowels + 1\n   \
    \             }else if((('A' <= char && char <= 'Z') && (newVowel2 ==\"\"))){\n\
    \                    newVowel2 = char\n                    countVowels = countVowels\
    \ + 1\n                }else if((('a' <= char && char <= 'z') && (newVowel3 ==\"\
    \"))){\n                    newVowel3 = char\n                    countVowels\
    \ = countVowels + 1\n                }\n            }\n        }\n        for(letter\
    \ <- newString){\n            if(('A' <= letter && letter <= 'Z')){\n        \
    \        letter = letter + newVowel\n            }else if(('a' <= letter && letter\
    \ <= 'z')){\n                letter = letter + newVowel2\n            }else if(('a'\
    \ <= letter && letter <= 'z')){\n                letter = letter + newVowel3\n\
    \            }\n        }\n        return newString", "        val m = message.trim\n\
    \        val r = new StringBuilder\n        m.toLowerCase.filter(i => i >= 'a'\
    \ && i <= 'z').toIterator.foreach(i => r.append(i).append(i.toChar))\n       \
    \ m.toLowerCase.filter(i => i >= 'a' && i <= 'z').toIterator.filter(i => !(i ==\
    \ 'a' || i == 'e' || i == 'i' || i == 'o' || i == 'u' || i == 'y')).foreach(i\
    \ => r.append(i).append(\"A\"))\n        m.toLowerCase.filter(i => i >= 'a' &&\
    \ i <= 'z').toIterator.filter(i => i == 'a' || i == 'e' || i == 'i' || i == 'o'\
    \ || i == 'u' || i == 'y').foreach(i => r.append(i).append(\"B\"))\n        m.toLowerCase.filter(i\
    \ => i >= 'a' && i <= 'z').toIterator.filter(i => i == 'a' || i == 'e' || i ==\
    \ 'i' || i == 'o' || i == 'u' || i == 'y' || i == 'i').foreach(i => r.append(i).append(\"\
    C\"))\n        m.toLowerCase.filter(i => i >= 'a' && i <= 'z').toIterator.filter(i\
    \ => i == 'a' || i == 'e' || i == 'i' || i == 'o' || i == 'u' || i == 'y' || i\
    \ == 'i').foreach(i => r.append(i).append(\"D\"))\n        m.toLowerCase.filter(i\
    \ => i >= 'a' && i <= 'z').toIterator.filter(i => i == 'a' || i == 'e' || i ==\
    \ 'i' || i == 'o' || i == 'u' || i == 'y' || i == 'i').foreach(i => r.append(i).append(\"\
    E\"))\n        m.toLowerCase.filter(i => i >= 'a' && i <= 'z').toIterator.filter(i\
    \ => i == 'a' || i == 'e' || i == 'i' || i == 'o' || i == 'u' || i == 'y' || i\
    \ == 'i').foreach(i => r.append(i).append(\"F\"))\n        m.toLowerCase.filter(i\
    \ => i >= 'a' && i <= 'z').toIterator.filter(i => i == 'a' || i == 'e' || i ==\
    \ 'i' || i == 'o' || i == 'u' || i == 'y' || i == 'i').foreach(i => r.append(i).append(\"\
    G\"))\n        m.toLowerCase.filter(i => i >= 'a' && i <= 'z').toIterator.filter(i\
    \ => i == 'a' || i == 'e' || i == 'i' || i == 'o' || i == 'u' || i == 'y' || i\
    \ == 'i').foreach(i => r.append(i", "        val message = message.trim\n    \
    \    val newMessage = message + message.substring(2,message.length)\n        val\
    \ vowels = \"aeiou\"\n        val vowelsMap = vowels.toCharArray map (_.toUpperCase())\n\
    \        val vowelsMap2 = vowelsMap.toList.reverse.zipWithIndex.filter(_._2 ==\
    \ 0).map(_._1)\n        val vowelsMap3 = vowelsMap2.toList.reverse.zipWithIndex.filter(_._2\
    \ == 1).map(_._1)\n        newMessage.map(c => {\n            if(c in vowels)\
    \ c\n            else if((c-1) in vowelsMap2) c+(\"2\")\n            else if((c+1)\
    \ in vowelsMap3) c+(\"3\")\n            else c\n        })", "        var result\
    \ : String = \"\"\n        for(i <- 0 to message.length-1) {\n            if(message.charAt(i)\
    \ == 'a') {\n                result += (message.charAt(i) + message.charAt(i+1))\n\
    \            } else {\n                result += message.charAt(i)\n         \
    \   }\n        }\n        return result", "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .toArray\n        val vowels = \"aeiou\".toArray\n        val twoVowel = \"AEIOU\"\
    .toArray\n\n        var result = \"\"\n        var index = 0\n        var i =\
    \ 0\n        while (i < message.length) {\n            val charVal = message.charAt(i)\n\
    \            if (charVal >= 'a' && charVal <= 'z') {\n                result +=\
    \ alphabet(charVal - 'a' + 1)\n            }\n            else if (charVal >=\
    \ 'A' && charVal <= 'Z') {\n                result += alphabet(charVal - 'A' +\
    \ 1)\n            }\n            else if (charVal >= 'a' && charVal <= 'z' ||\
    \ charVal >= 'A' && charVal <= 'Z' || charVal >= '0' && charVal <= '9') {\n  \
    \              result += charVal\n            }\n            else {\n        \
    \        result += vowels(index)\n                index += 2\n            }\n\
    \            i += 1\n        }\n        return result", "        val newMessage\
    \ = message.map(_.toUpperCase)\n        val vowels = ('A':'Z','a':'z')\n     \
    \   var i = 0\n        var j = 0\n        var output = new String\n        for\
    \ (word <- newMessage) {\n            for(vowel <- vowels) {\n               \
    \ if(word.contains(vowel)) {\n                    output.append((word.substring(j,j+2)).zip(vowel.zip(word.substring(j,j+2))).map(_._1).mkString)\n\
    \                    j += 2\n                }\n            }\n            j =\
    \ i\n            i += 1\n        }\n        output", "        val vowels = List('a','e','i','o','u')\n\
    \        val consonants = List('b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x',\n\
    \        'y','z')\n        val letter = message.toLowerCase //case insensitive\n\
    \        val letterWithVowels = letter zip vowels //zip letters\n        val letterWithConsonants\
    \ = letter zip consonants //zip letters\n        val swappedLettersWithVowels\
    \ = letterWithVowels.map{case (letter, vowel) => letter.toUpperCase() }\n    \
    \    val swappedLettersWithConsonants = letterWithConsonants.map{case (letter,\
    \ consonant) => consonant.toUpperCase }\n        val swapped = swapped ++ swappedLettersWithVowels\
    \ ++ swappedLettersWithConsonants\n        swapped.mkString //join letters", " \
    \       val newMessage = message.toUpperCase +: \n                       (for\
    \ (letter <- message.toLowerCase ; \n                            a <- ('a' to\
    \ 'z') ; \n                            b <- ('A' to 'Z') \n                  \
    \        ) yield {\n                             val index = (letter + a).toInt\n\
    \                             if (index != index)\n                          \
    \       (letter + b.charAt(index - a)).asInstanceOf[String]\n                \
    \            else\n                               letter \n                  \
    \       }) \n        newMessage.reverse ++ \n        (for (i <- 0 until message.length)\
    \ yield \n          {\n            val vowels = \"aeiou\"\n            if (vowels.indexOf(message.charAt(i))\
    \ > -1)\n               message.charAt(i) + message.charAt(i + 1)\n          \
    \  else\n               message.charAt(i) \n          })", "        val alphabet\
    \ = \n            \"abcdefghijklmnopqrstuvwxyz\".toList \n            ++ \n  \
    \          \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".toList\n            ++ \n          \
    \  \"\xC4\xC5\xC7\xC9\xD1\xD6\xDC\".toList \n            ++ \n            \"\xDC\
    \xC4\xDC\xC7\xC9\xC4\xC5\".toList\n            ++ \n            \"\xD6\xD1\xDC\
    \xDC\xDC\xC4\xC4\".toList\n\n        def chars(message : String) : Seq[String]\
    \ = {\n            var charSeq = Seq[String]()\n            for (letter <- message)\
    \ {\n                charSeq = charSeq :+ alphabet.find(letter => letter != letter.toUpperCase)\n\
    \            }\n            charSeq\n        }\n        def swap(charSeq : Seq[String],\
    \ i : Int, j : Int) : Seq[String] = {\n            charSeq match {\n         \
    \       case Seq() => Seq()\n                case Seq(last, first) => \n     \
    \               last +: (first swap i + 2, j swap i + 2)\n                case\
    \ other =>\n                    other\n            }\n        }\n        def replace(message\
    \ : String, i : Int, j : Int, letter : String, \n                    swapFunc\
    \ : ((Seq[String], Int, Int) => (Seq[String], Int, Int)) \n                  \
    \  ) : Seq[String] = {\n            val newSeq = swapFunc(chars(message), i, j)\n\
    \            newSeq match {\n                case Seq() => Seq()\n           \
    \     case Seq(first, second) =>\n                    first :+ letter\n      \
    \              replace(message, second, i, letter, swapFunc)\n               \
    \ case other => other\n            }\n        }\n        replace(message, 0, 0,\
    \ message.charAt(0), swap)", "        val chars = message.toCharArray\n      \
    \  val letters = message.chars.toList\n        val newChars = mutable.Buffer.empty[Char]\n\
    \        for (i <- 0 until chars.length) {\n            if (letters.contains(chars(i)))\
    \ {\n                val firstLetter = chars(i).toUpper\n                val secondLetter\
    \ = chars(i + 1).toUpper\n                if (chars.contains(firstLetter) && chars.contains(secondLetter))\
    \ {\n                    newChars += firstLetter //swap the letters\n        \
    \            newChars += secondLetter\n                }\n                newChars\
    \ += chars(i)\n                newChars += chars(i + 1)\n            } else {\n\
    \                newChars += chars(i)\n            }\n        }\n        newChars.toString.toUpperCase",
  "        var newString = \"\"\n        var vowels = \"aeiouAEIOU\"\n        for\
    \ ( i <- 0 until message.length ) {\n            val letter = message.charAt(i)\n\
    \            if ( vowels.contains(letter) ) {\n                val beforeVowel\
    \ = message.charAt(i - 1)\n                newString += if ( vowels.contains(beforeVowel)\
    \ ) {\n                    message.charAt(i - 1) + beforeVowel\n             \
    \   } else letter\n            } else newString += letter\n        }\n       \
    \ return newString", "        val vowels = scala.collection.mutable.List(\"a\"\
    , \"e\", \"i\", \"o\", \"u\")\n        val replaced = message.foldLeft(\"\") {\
    \ (result, char) =>\n            val index = vowels.indexOf(char.toLowerCase)\n\
    \            if (index != -1) {\n                val a = vowels(index - 1)\n \
    \               val b = vowels(index)\n                val c = vowels(index +\
    \ 1)\n                result + (if (char == a) b else c) + char\n            }\
    \ else {\n                result + char\n            }\n        }\n        replaced.toLowerCase",
  "      val result = new StringBuilder()\n      var i = 0\n      while (i < message.length)\
    \ {\n        var c = message.charAt(i)\n        if (c.isUpperCase || c.isLowerCase\
    \ || c.isDigit) {\n          result = result.append(c)\n        } else {\n   \
    \       val r = c.toUpperCase\n          val l = c.toLowerCase\n          var\
    \ j = 0\n          var prev = i + 1\n          while (j < l.length) {\n      \
    \      var next = prev + 1\n            while (next < l.length) {\n          \
    \    val x = l.charAt(next)\n              if (x == 'A' || x == 'E' || x == 'I'\
    \ || x == 'O' || x == 'U') {\n                next = next+1\n                break\n\
    \              }\n              next = next+1\n            }\n            val\
    \ y = l.charAt(next)\n            if (prev > 0) {\n              val x = l.charAt(prev-1)\n\
    \              if (x == 'A' || x == 'E' || x == 'I' || x == 'O' || x == 'U') {\n\
    \                result.append((r + y).swapcase)\n                break\n    \
    \          }\n            }\n            if (prev < message.length-1) {\n    \
    \          val x = l.charAt(prev+1)\n              if (x == 'A' || x == 'E' ||\
    \ x == 'I' || x == 'O' || x == 'U') {\n                result.append((r + y).swapcase)\n\
    \                break\n              }\n            }\n            prev = prev+1\n\
    \          }\n        }\n        i = i+1\n      }\n      result.toString", " \
    \       val vowelSet = mutable.HashSet[Char]('a', 'e', 'i', 'o', 'u')\n      \
    \  var newMessage = message\n        var currentVowel = 'a'\n        for(i <-\
    \ 0 until message.length) {\n            val char = message.charAt(i)\n      \
    \      if(vowelSet.contains(char)) {\n                newMessage = newMessage.replace(char.toUpperCase,\
    \ vowelSet.apply(currentVowel))\n                currentVowel = char.toUpperCase\n\
    \            }\n        }\n        newMessage", "        val newMessage = message.map(x=>{\n\
    \            if(x.toLowerCase.contains(\"a\")){\n                x.toLowerCase.swapCase\n\
    \            }else{\n                x\n            }\n        }).map(x=>{\n \
    \           val vowels = \"aeiou\"\n            var count = 0\n            var\
    \ result = \"\"\n            for(i <- 0 to x.toCharArray.length -1){\n       \
    \         if(vowels.contains(x.toCharArray(i))){\n                    result +=\
    \ x.toCharArray(i).swapCase\n                    count += 1\n                }\n\
    \            }\n            if(count >= 2){\n                x.toCharArray(i).swapCase\n\
    \            }else{\n                x\n            }\n        })\n        newMessage.toString",
  "        val result = message.foldLeft(\"\"){ (result,c) => \n            if(c.toUpper\
    \ == c.toLowerCase) result += c.toUpper\n            else if((c.toUpper == 'a'\
    \ || c.toUpper == 'e' || c.toUpper == 'i' || c.toUpper == 'o' || c.toUpper ==\
    \ 'u')) {\n                val pos = getVowelPosition(c) \n                result\
    \ += c.substring(0, pos)\n                result += c.substring(pos,c.getLength)\n\
    \            }\n            else result += c\n        }\n        result", "  \
    \      var newMessage = \"\"\n        for (letter1 <- message) {\n           \
    \ for (letter2 <- message) {\n                if (letter1 != letter2) {\n    \
    \                newMessage += letter2.toLowerCase().charAt(letter2.indexOf((letter1.toLowerCase()))).\n\
    \                        toString().toUpperCase()\n                }\n       \
    \     }\n        }\n        return newMessage", "        def charToNum(c: Char):\
    \ Int = {\n            c.toUpper - 'A'.toUpper\n        }\n        val messageAsArray\
    \ = message.toCharArray.asInstanceOf[Array[Char]]\n        val n = messageAsArray.length\n\
    \        val vowelsMap = new mutable.HashMap[Char, Int]()\n        for (i <- 0\
    \ until n) {\n            if (messageAsArray(i) == 'A') {\n                vowelsMap\
    \ += ('A' -> 0)\n            } else if (messageAsArray(i) == 'E') {\n        \
    \        vowelsMap += ('E' -> 1)\n            } else if (messageAsArray(i) ==\
    \ 'I') {\n                vowelsMap += ('I' -> 2)\n            } else if (messageAsArray(i)\
    \ == 'O') {\n                vowelsMap += ('O' -> 3)\n            } else if (messageAsArray(i)\
    \ == 'U') {\n                vowelsMap += ('U' -> 4)\n            } else if (messageAsArray(i)\
    \ == 'Y') {\n                vowelsMap += ('Y' -> 5)\n            } else if (messageAsArray(i)\
    \ == 'a') {\n                vowelsMap += ('a' -> 6)\n            } else if (messageAsArray(i)\
    \ == 'e') {\n                vowelsMap += ('e' -> 7)\n            } else if (messageAsArray(i)\
    \ == 'i') {\n                vowelsMap += ('i' -> 8)\n            } else if (messageAsArray(i)\
    \ == 'o') {\n                vowelsMap += ('o' -> 9)\n            } else if (messageAsArray(i)\
    \ == 'u') {\n                vowelsMap += ('u' -> 10)\n            } else if (messageAsArray(i)\
    \ == 'y') {\n                vowelsMap += ('y' -> 11)\n            }\n       \
    \ }\n        var result = \"\"\n        for (i <- 0 until n) {\n            if\
    \ (vowelsMap.contains(messageAsArray(i))) {\n                result += messageAsArray(i).swapCase\n\
    \            } else {\n                result += messageAsArray(i)\n         \
    \   }\n        }\n        return result", "        def vowel(a: String) : Int\
    \ = {\n            def b(a: String, i: Int) : Int = {\n                if (i >=\
    \ a.length) 0\n                else if (a.charAt(i) == a.charAt(i - 1)) 1\n  \
    \              else {\n                    b(a = a.substring(0,i), i + 1)\n  \
    \              }\n            }\n            b(a, 0)\n        }\n        def count(a\
    \ : String) : Int = {\n            def c(a: String): Int = {\n               \
    \ val b = a.length\n                var i = 0\n                while (i<b){\n\
    \                    if (a.charAt(i) == a.charAt(i + 1)) i + 1 else c(a = a.substring(0,i)\
    \ + a.substring(i + 1))\n                    i += 1\n                }\n     \
    \           i\n            }\n            c(message)\n        }\n        val r\
    \ = message.mkString\n        var i = 0\n        while (i<r.length){\n       \
    \     if (vowel(r.charAt(i))) r.charAt(i) match {\n                case a if a\
    \ == r.charAt(i) =>\n                    r = r.substring(0,i) + r.substring(i+1,i+2)\
    \ + \"A\"\n                case a if a == r.charAt(i) =>\n                   \
    \ r = r.substring(0,i) + r.substring(i+1,i+2) + \"B\"\n                case a\
    \ if a == r.charAt(i) =>\n                    r = r.substring(0,i) + r.substring(i+1,i+2)\
    \ + \"C\"\n                case a if a == r.charAt(i) =>\n                   \
    \ r = r.substring(0,i) + r.substring(i+1,i+2) + \"D\"\n                case a\
    \ if a == r.charAt(i) =>\n                    r = r.substring(0,i) + r.substring(i+1,i+2)\
    \ + \"E\"\n                case a if a == r.charAt(i) =>\n                   \
    \ r = r.substring(0,i) + r.substring(i+1,i+2) + \"F\"\n                case a\
    \ if a == r.charAt(i) =>\n                    r = r.substring(0,i) + r.substring(i+1,i+2)\
    \ + \"G\"\n                case a if a == r.charAt(i) =>\n                   \
    \ r = r.substring(0,i) + r.substring(i+1,i+2) + \"H\"\n                case a\
    \ if a == r.charAt(i) =>\n                    r = r.substring(0,i) + r.substring(i+1,i+2)\
    \ + \"I\"\n                case a if a == r.charAt(i) =>\n                   \
    \ r = r.substring(0,i) + r.substring(i+1,i+2) + \"J\"\n                case a\
    \ if a == r.charAt(i) =>\n                    r = r.substring(0,i) + r.substring(i+1,i+2)\
    \ + \"K\"\n                case a if a == r.charAt(i) =>\n                   \
    \ r = r.substring(0,i) + r.substring(i+1,i+2) + \"L\"\n                case a\
    \ if a == r.charAt(i) =>\n                    r = r.substring(0,i) + r.substring(i+1,i+2)\
    \ + \"M\"\n                case a if a == r.charAt(i) =>", "        val replaceVowels\
    \ = new mutable.StringBuilder\n        var i = 0\n        for(letter <- message)\
    \ {\n            if (letter == ' ') {\n                replaceVowels.append(\"\
    \")\n                i++\n            } else {\n                val firstLetter\
    \ =\n                    if (i == 0) 'z' \n                    else if (letter\
    \ == message.charAt(i - 1)) 'z'\n                    else letter\n\n         \
    \       val secondLetter =\n                    if (i == 1) 'z' \n           \
    \         else if (letter == message.charAt(i - 2)) 'z'\n                    else\
    \ letter\n\n                val thirdLetter =\n                    if (i == 2)\
    \ 'z' \n                    else if (letter == message.charAt(i - 3)) 'z'\n  \
    \                  else letter\n\n                val fourthLetter =\n       \
    \             if (i == 3) 'z' \n                    else if (letter == message.charAt(i\
    \ - 4)) 'z'\n                    else letter\n\n                val fithLetter\
    \ =\n                    if (i == 4) 'z' \n                    else if (letter\
    \ == message.charAt(i - 5)) 'z'\n                    else letter\n\n         \
    \       val sixthLetter =\n                    if (i == 6) 'z' \n            \
    \        else if (letter == message.charAt(i - 6)) 'z'\n                    else\
    \ letter\n\n                val seventhLetter =\n                    if (i ==\
    \ 7) 'z' \n                    else if (letter == message.charAt(i - 7)) 'z'\n\
    \                    else letter\n\n                val eighthLetter =\n     \
    \               if (i == 8) 'z' \n                    else if (letter == message.charAt(i\
    \ - 8)) 'z'\n                    else letter\n\n                val ninthLetter\
    \ =\n                    if (i == 9) 'z' \n                    else if (letter\
    \ == message.charAt(i - 9)) 'z'\n                    else letter\n\n         \
    \       val tenthLetter =\n                    if (i == 10) 'z' \n           \
    \         else if (letter == message.charAt(i - 10)) 'z'\n                   \
    \ else letter\n\n                val firstLetter2PlaceAhead =\n              \
    \      if (i == 1) 'A' \n                    else if (letter == message.charAt(i\
    \ - 1)\n                    && letter != message.charAt(i - 2)) 'A'\n        \
    \            else letter\n\n                val secondLetter2PlaceAhead =\n  \
    \                  if (i == 2) 'A' \n                    else if (letter == message.charAt(i\
    \ - 2)\n                    && letter != message.charAt(i - 3)) 'A'\n        \
    \            else letter\n\n                val thirdLetter2PlaceAhead =\n   \
    \                 if (i == 3) 'A' \n                    else if (letter == message.charAt(i\
    \ - 3)\n                    && letter != message.charAt(i - 4)) 'A'\n        \
    \            else letter\n\n                val fourthLetter2PlaceAhead =\n  \
    \                  if (i == 4) '", "        val vowels = \"aeiou\"\n        val\
    \ lettersOnly = message.replaceAll(\"[^a-zA-Z]\", \"\")\n\n        val firstLetters\
    \ = lettersOnly.substring(0,lettersOnly.indexOf(\"a\"))\n        val secondLetters\
    \ = lettersOnly.substring(lettersOnly.indexOf(\"a\"),lettersOnly.indexOf(\"e\"\
    ))\n        val thirdLetters = lettersOnly.substring(lettersOnly.indexOf(\"e\"\
    ),lettersOnly.indexOf(\"i\"))\n        val fourthLetters = lettersOnly.substring(lettersOnly.indexOf(\"\
    i\"),lettersOnly.indexOf(\"o\"))\n        val fifthLetters = lettersOnly.substring(lettersOnly.indexOf(\"\
    o\"),lettersOnly.indexOf(\"u\"))\n\n        val firstVowels = firstLetters.replaceAll(vowels,\"\
    a\")\n        val secondVowels = secondLetters.replaceAll(vowels,\"a\")\n    \
    \    val thirdVowels = thirdLetters.replaceAll(vowels,\"a\")\n        val fourthVowels\
    \ = fourthLetters.replaceAll(vowels,\"a\")\n        val fifthVowels = fifthLetters.replaceAll(vowels,\"\
    a\")\n\n        val firstLettersOnTheLeft = firstVowels.replaceAll(\"a\",firstLetters)\n\
    \        val secondLettersOnTheLeft = secondVowels.replaceAll(\"a\",secondLetters)\n\
    \        val thirdLettersOnTheLeft = thirdVowels.replaceAll(\"a\",thirdLetters)\n\
    \        val fourthLettersOnTheLeft = fourthVowels.replaceAll(\"a\",fourthLetters)\n\
    \        val fifthLettersOnTheLeft = fifthVowels.replaceAll(\"a\",fifthLetters)\n\
    \n        val firstLettersOnTheRight = firstLettersOnTheLeft.replaceAll(\"e\"\
    ,secondLetters)\n        val secondLettersOnTheRight = secondLettersOnTheLeft.replaceAll(\"\
    e\",secondLetters)\n        val thirdLettersOnTheRight = thirdLettersOnTheLeft.replaceAll(\"\
    e\",secondLetters)\n        val fourthLettersOnTheRight = fourthLettersOnTheLeft.replaceAll(\"\
    e\",secondLetters)\n        val fifthLettersOnTheRight = fifthLettersOnTheLeft.replaceAll(\"\
    e\",secondLetters)\n\n        val firstLettersOnTheLeftAndRight = firstLettersOnTheLeft\
    \ + secondLettersOnTheRight + thirdLettersOnTheRight + fourthLetters", '        //
    TODO: write your code here', "      val alphabet = \n        List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z').toList\n\
    \      val vowels = List('e','i','o','u','y').toList\n      val message = message.map(c\
    \ => \n          if (alphabet.contains(c.toLowerCase)) c else \n            if\
    \ (vowels.contains(c)) c.toUpperCase.charAt(0) + c.toUpperCase.charAt(1) else\
    \ \n              (c))\n      val encodedString = message.reduceLeft(_ + _)\n\
    \      encodedString.reverse", "         \n         val vowels = \"aeiouAEIOU\"\
    \n         val lettersOnly = message.replaceAll(\"[^A-Z]\", \"\")\n         val\
    \ vowelIndices = lettersOnly.map(_.toChar).filter(c => vowels.indexOf(c) >= 0).zipWithIndex.toMap\n\
    \         val replacedLetters = lettersOnly.map(letter =>\n         {\n      \
    \       if(vowelIndices.contains(letter)) \n                 vowelIndices(letter)\n\
    \             else \n                 letter\n         })\n         val twoAheadIndices\
    \ = lettersOnly.zipWithIndex.filter(\n             i => vowelIndices.getOrElse(i._2,\
    \ letters.size) === letters.size).map(_._2)\n         val newLetters = replacedLetters.map(letter\
    \ => vowelIndices(letter))\n         twoAheadIndices.foreach(i => newLetters(i)\
    \ = newLetters(i)+\"a\")\n         newLetters.mkString", "        val messageAsList\
    \ = message.toLowerCase.split(\" \").map(_.toLowerCase)\n        val messageAsMap\
    \ = (for (letter <- messageAsList) yield letter -> letter)\n        val vowels\
    \ = List(\"a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"i\", \"o\", \"a\")\n    \
    \    val swappedLetters = messageAsList.map(letter => {\n            val replacement\
    \ = vowels.foldLeft(letter)((a, e) => \n                    if (a.charAt(0) ==\
    \ e.charAt(0)) a else e.charAt(0) + a)\n            val twoAheadLetter = vowels(vowels.indexOf(letter)\
    \ + 1)\n            (replacement -> twoAheadLetter)\n        })\n        val replacedLetters\
    \ = vowels.flatMap(vowel => \n                messageAsList.map(letter => \n \
    \                   letter -> \n                    swappedLetters.find(_._1 ==\
    \ vowel)._2.toString).flatten)\n        replacedLetters.foldLeft(messageAsList)((a,\
    \ letter) => a + letter)", "        val chars = message.chars.toList\n       \
    \ val vowels = \"aeiou\".toList\n        val output = new StringBuilder\n\n  \
    \      for (i <- 0 until chars.size) {\n            val currentChar = chars(i)\n\
    \n            if (vowels.contains(currentChar)) {\n                for (j <- i\
    \ + 1 until chars.size) {\n                    val currentChar2 = chars(j)\n \
    \                   if (vowels.contains(currentChar2)) {\n                   \
    \     val replacementChar = vowels.zip(vowels.tail).find(_._1 == currentChar2)._2\n\
    \                        output.append(replacementChar)\n                    }\n\
    \                    else {\n                        output.append(currentChar2)\n\
    \                    }\n                }\n            }\n            else {\n\
    \                output.append(currentChar)\n            }\n        }\n\n    \
    \    output.toString", "        var messageLetters = message.toCharArray\n   \
    \     var vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var newMessage\
    \ = message //start with original message\n        for(i <- 0 to messageLetters.length-1){\n\
    \            if(vowels(messageLetters(i))){\n                for(j <- i+1 to messageLetters.length-1){\n\
    \                    if(!vowels(messageLetters(j))){\n                       \
    \ var index = messageLetters.indexOf(messageLetters(i));\n                   \
    \     messageLetters = messageLetters.updated(index, messageLetters(j))\n    \
    \                }\n                }\n                newMessage = newMessage.replaceAll(messageLetters(i),\
    \ messageLetters(i+1))\n            }\n        }\n        newMessage = newMessage.replaceAll(\"\
    \\\\W\", \"\")\n        return newMessage", "        val input = message.split(\"\
    \")\n        val output = new StringBuilder\n        var vowels = \"aeiouAEIOU\"\
    .toList\n        for ((index, element) <- input.zipWithIndex) {\n            if(vowels.contains(element))\
    \ {\n                var first = vowels.head\n                var second = vowels.last\n\
    \                val secondPlace = vowels.indexWhere(vowels.contains(element))\n\
    \                for (i <- index+1 to index+2) {\n                    if(vowels.contains(element))\
    \ {\n                        second = vowels(secondPlace+1)\n                \
    \    }\n                    output.append(vowels(first).toLowerCase)\n       \
    \             output.append(vowels(second).toLowerCase)\n                    output.append(element)\n\
    \                }\n            } else {\n                output.append(element)\n\
    \            }\n        }\n        output.toString", '        val enc = message.map(c
    => (if (c.isLetter) c.toUpperCase else c)).map(c => (if (c.isLetter) c.toUpperCase
    else c)).map(c => (if (c.isLetter) c.toUpperCase else c)).map(c => (if (c.isLetter)
    c.toUpperCase else c)).map(c => (if (c.isLetter) c.toUpperCase else c)).map(c
    => (if (c.isLetter) c.toUpperCase else c)).map(c => (if (c.isLetter) c.toUpperCase
    else c)).map(c => (if (c.isLetter) c.toUpperCase else c)).map(c => (if (c.isLetter)
    c.toUpperCase else c)).map(c => (if (c.isLetter) c.toUpperCase else c)).map(c
    => (if (c.isLetter) c.toUpperCase else c)).map(c => (if (c.isLetter) c.toUpperCase
    else c)).map(c => (if (c.isLetter) c.toUpperCase else c)).map(c => (if (c.isLetter)
    c.toUpperCase else c)).map(c => (if (c.isLetter) c.toUpperCase else c)).map(c
    => (if (c.isLetter) c.toUpperCase else c)).map(c => (if (c.isLetter) c.toUpperCase
    else c)).map(c => (if (c.isLetter) c.toUpperCase else c)).map(c => (if (c.isLetter)
    c.toUpperCase else c)).map(c => (if (c.isLetter) c.toUpperCase else c)).map(c
    => (if (c.isLetter) c.toUpperCase else c)).map(c => (if (c.isLetter) c.toUpperCase
    else c)).map(c => (if (c.isLetter) c.toUpperCase else c)).map(c => (if (c.isLetter)
    c.toUpperCase else c)).map(c => (if (c.isLetter) c.toUpperCase else c)).map(c
    => (if (c.isLetter) c.toUpperCase else c)).map(c => (if (c.isLetter) c.toUpperCase
    else c)).map(c => (if (c.isLetter) c.toUpperCase else c)).map(c => (if (c.isLetter)
    c.toUpperCase else c)).map(c => (if (c.isLetter) c.toUpperCase else c)).map(c
    => (if (c.isLetter) c.toUpperCase else c)).map(c => (if (c.isLetter) c.toUpperCase
    else c)).map(c => (if (c.isLetter) c.toUpperCase else c)).map(c => (if (c.isLetter)
    c.toUpperCase ', "        var newMessage : String = message \n        var charCounts\
    \ : mutable.Map[Char, Int] = mutable.Map[Char, Int]()\n        var newCharCounts\
    \ : mutable.Map[Char, Int] = mutable.Map[Char, Int]()\n        for (c <- message)\
    \ { \n            charCounts(c) += 1\n            newCharCounts(c) = charCounts(c)\
    \ + 1\n        }\n\n        // Swap case of each character in the message and\
    \ replace vowels\n        for (c <- message) {\n            if (charCounts(c)\
    \ > 1) {\n                val newChar = newCharCounts(c) - 2\n               \
    \ val newChar = newChar.toChar\n                val newCharCounts = charCounts\
    \ - 2\n                newCharCounts(c) = newCharCounts(c).toChar\n          \
    \      charCounts(c) = newChar\n                newCharCounts(newChar) = newCharCounts\n\
    \            }\n        }\n        return newMessage", "        var vowels = \"\
    AEIOU\"\n        var alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        var result\
    \ = \"\"\n        for ((index, letter) <- message.zipWithIndex) {\n          \
    \  if ((index % 2) == 0) {\n                for (i <- 0 until vowels.length) result\
    \ += alphabet.charAt(vowels.charAt(i) + alphabet.indexOf(letter.charAt(i)) + 1)\n\
    \                result += \"G\"\n            } else {\n                result\
    \ += \"S\"\n            }\n        }\n        return result", "        var result\
    \ = \"\"\n        for(char <- message) {\n            val swap = char.swapCase\n\
    \            val vowels = Set.of('A','E','I','O','U')\n            val replacement\
    \ = vowels.indexOf(char.charAt(1)) % 26\n            result += (swap + replacement)\n\
    \        }\n        result", "        val s = message.mkString\n        val m\
    \ = s.toUpperCase\n        val v = \"AEIOU\"\n        val m = m.replaceAllIn(m,\
    \ m => v contains m.toUpperCase)\n        val l = m.length\n        var i = 0\n\
    \        val s = new StringBuilder\n        while (i < l) {\n            if (m.charAt(i)\
    \ == m.charAt(i+1)) {\n                s.append(v)\n            } else {\n   \
    \             s.append(m.charAt(i))\n            }\n            i += 1\n     \
    \   }\n        s.append(m)", "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .toList\n        val vowels = \"aeiou\".toList\n        val enc = new mutable.StringBuilder\n\
    \        message.foreach{ x =>\n            if(x == ' ') {\n                enc.append('\
    \ ')\n            }\n            else {\n                x match {\n         \
    \           case 'a' -> enc.append('z')\n                    case 'e' -> enc.append('z')\n\
    \                    case 'i' -> enc.append('z')\n                    case 'o'\
    \ -> enc.append('z')\n                    case 'u' -> enc.append('z')\n      \
    \              case 'A' -> enc.append('Z')\n                    case 'E' -> enc.append('Z')\n\
    \                    case 'I' -> enc.append('Z')\n                    case 'O'\
    \ -> enc.append('Z')\n                    case 'U' -> enc.append('Z')\n      \
    \              case c =>\n                        x match {\n                \
    \            case vowels(0) if (x == 'a') =>\n                               \
    \ enc.append('z')\n                            case vowels(0) if (x == 'e') =>\n\
    \                                enc.append('z')\n                           \
    \ case vowels(0) if (x == 'i') =>\n                                enc.append('z')\n\
    \                            case vowels(0) if (x == 'o') =>\n               \
    \                 enc.append('z')\n                            case vowels(0)\
    \ if (x == 'u') =>\n                                enc.append('z')\n        \
    \                    case x => enc.append(alphabet(alphabet.indexOf(x))+1)\n \
    \                       }\n                }\n            }\n        }\n     \
    \   enc.toString", "      val buffer = new mutable.Buffer[Char]\n      val vowels\
    \ = \"aeiouAEIOU\"\n      message match {\n        case letter if letter == 'a'\
    \ =>\n          buffer.append(letter)\n          letter\n        case letter if\
    \ letter == 'e' =>\n          buffer.append(letter)\n          letter\n      \
    \  case letter if letter == 'i' =>\n          buffer.append(letter)\n        \
    \  letter\n        case letter if letter == 'o' =>\n          buffer.append(letter)\n\
    \          letter\n        case letter if letter == 'u' =>\n          buffer.append(letter)\n\
    \          letter\n        case letter => letter\n      }\n      buffer.toString.replaceAll(vowels.toSeq.tail.mkString,\
    \ \"$1\")", "        val result = new mutable.ArrayBuffer[String]\n        val\
    \ alphabet = new mutable.ArrayBuffer[Char]('A'\n            ++ ('a' - 'A') ++\
    \ (('A' - 'a') to 'z') ++ (('a' - 'A') to 'z'\n                ++ ('A' - 'a')\
    \ to 'z') ++ (('A' - 'A') to 'z') ++ (\n                    ('a' - 'A') to 'z')\
    \ ++ (('A' - 'a') to 'z'))\n        val vowels = \"aeiou\"\n        val map =\
    \ new mutable.Map[Char, Int]()\n        for(c <- message) if(alphabet.contains(c))\
    \ map.put(c.toUpperCase, map.getOrElse(c.toUpperCase, 0) + 1)\n        for (a\
    \ <- alphabet) if(map.contains(a)) map.put(a -> map.getOrElse(a -> 1, 0) + 1)\n\
    \        for ((a, b) <- map) \n            a -> b\n        .foreach { case (k,\
    \ v) => result += ((k)(v) -> ((k)((v) - 1) + (alphabet.get((v) + 1))) :: result)\
    \ }\n        result += ((k)(v) -> ((k)((v) - 1) + (alphabet.get((v) + 1))) ::\
    \ result)\n        result mkString \"\"", "        val result = new StringBuilder\n\
    \        for(i <- 0 until message.length){\n            if(message.charAt(i) ==\
    \ 'a') {\n                result.append(message.charAt(i)).append('A')\n     \
    \       }\n            else if(message.charAt(i) == 'e') {\n                result.append(message.charAt(i)).append('E')\n\
    \            }\n            else if(message.charAt(i) == 'i') {\n            \
    \    result.append(message.charAt(i)).append('I')\n            }\n           \
    \ else if(message.charAt(i) == 'o') {\n                result.append(message.charAt(i)).append('O')\n\
    \            }\n            else if(message.charAt(i) == 'u') {\n            \
    \    result.append(message.charAt(i)).append('U')\n            }\n           \
    \ else if(message.charAt(i) == 'A') {\n                result.append(message.charAt(i)).append('A')\n\
    \            }\n            else if(message.charAt(i) == 'E') {\n            \
    \    result.append(message.charAt(i)).append('E')\n            }\n           \
    \ else if(message.charAt(i) == 'I') {\n                result.append(message.charAt(i)).append('I')\n\
    \            }\n            else if(message.charAt(i) == 'O') {\n            \
    \    result.append(message.charAt(i)).append('O')\n            }\n           \
    \ else if(message.charAt(i) == 'U') {\n                result.append(message.charAt(i)).append('U')\n\
    \            }\n            else if(message.charAt(i) == 'a') {\n            \
    \    result.append(message.charAt(i)).append('A')\n            }\n           \
    \ else if(message.charAt(i) == 'e') {\n                result.append(message.charAt(i)).append('E')\n\
    \            }\n            else if(message.charAt(i) == 'i') {\n            \
    \    result.append(message.charAt(i)).append('I')\n            }\n           \
    \ else if(message.charAt(i) == 'o') {\n                result.append(message.charAt(i)).append('O')\n\
    \            }\n            else if(message.charAt(i) == 'u') {\n            \
    \    result.append(message.charAt(i)).append('U')\n            }\n        }\n\
    \        return result.toString()", '        // Write your code here', "     \
    \   var result = new StringBuilder\n        var currentVowel = 0\n        var\
    \ letterIndex = 0\n        var vowels = List( 'a', 'e', 'i', 'o', 'u' )\n    \
    \    val characters = message.toCharArray\n        val characterSet = Set(characters.toSeq:\
    \ _*)\n        for (c <- characters) {\n            val currentChar = c.toUpperCase\n\
    \            if (currentChar in characterSet) {\n                val currentCharPosition\
    \ = characterSet.toList.indexOf(currentChar)\n                if (vowels.contains(currentChar))\
    \ {\n                    result.append((c -> vowels(currentCharPosition)))\n \
    \                   vowels(currentCharPosition) = currentChar\n              \
    \  } else {\n                    vowels(currentCharPosition) = currentChar\n \
    \               }\n            } else {\n                result.append((c -> letterIndex))\n\
    \                letterIndex = letterIndex + 1\n            }\n        }\n   \
    \     return result.toString", "        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val vowels = \"aeiou\"\n        var new_message = \"\"\n\n        //\
    \ Write code here!\n        for (letter <- message) {\n            val x = alphabet.indexOf(letter)\n\
    \            val y = alphabet.indexOf((alphabet.charAt(x+1) + alphabet.charAt(x)))\n\
    \            val z = alphabet.indexOf((alphabet.charAt(x-1) + alphabet.charAt(y)))\n\
    \            val c = alphabet.charAt(z)\n            val temp = alphabet.charAt(x)\n\
    \            alphabet.charAt(x) = alphabet.charAt(y)\n            alphabet.charAt(y)\
    \ = alphabet.charAt(z)\n            alphabet.charAt(z) = c\n            alphabet.charAt(x)\
    \ = temp\n            new_message += alphabet\n        }\n        new_message",
  "        val vowels = Array('a', 'e', 'i', 'o', 'u')\n        val letters = Array('a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n        val newMessage = message.map(x\
    \ => (x match {\n            case 'a' => \"t\"\n            case 'b' => \"g\"\n\
    \            case 'c' => \"k\"\n            case 'd' => \"h\"\n            case\
    \ 'e' => \"j\"\n            case 'f' => \"g\"\n            case 'g' => \"g\"\n\
    \            case 'h' => \"h\"\n            case 'i' => \"k\"\n            case\
    \ 'j' => \"k\"\n            case 'k' => \"k\"\n            case 'l' => \"m\"\n\
    \            case 'm' => \"m\"\n            case 'n' => \"n\"\n            case\
    \ 'o' => \"p\"\n            case 'p' => \"p\"\n            case 'q' => \"q\"\n\
    \            case 'r' => \"q\"\n            case 's' => \"s\"\n            case\
    \ 't' => \"s\"\n            case 'u' => \"v\"\n            case 'v' => \"v\"\n\
    \            case 'w' => \"w\"\n            case 'x' => \"x\"\n            case\
    \ 'y' => \"y\"\n            case 'z' => \"z\"\n            case _ => x\n     \
    \   })).mkString\n        val newMessageWithLetter2 = newMessage match {\n   \
    \         case x if vowels.contains(x) => (x match {\n                case 'a'\
    \ => \"t\"\n                case 'e' => \"j\"\n                case 'i' => \"\
    k\"\n                case 'o' => \"p\"\n                case 'u' => \"v\"\n  \
    \              case _ => x\n            })\n            case x if letters.contains(x)\
    \ => (x match {\n                case 'a' => \"h\"\n                case 'b' =>\
    \ \"g\"\n                case 'c' => \"k\"\n                case 'd' => \"j\"\n\
    \                case 'e' => \"g\"\n                case 'f' => \"g\"\n      \
    \          case 'g' => \"g\"\n                case 'h' => \"h\"\n            \
    \    case 'i' => \"k\"\n                case 'j' => \"k\"\n                case\
    \ 'k' => \"k\"\n                case 'l' => \"m\"\n                case 'm' =>\
    \ \"m\"\n                case 'n' => \"n\"\n                case 'o' => \"p\"\n\
    \                case 'p' => \"p\"\n                case 'q' => \"q\"\n      \
    \          case 'r' => \"q\"\n                case 's' => \"s\"\n            \
    \    case 't' => \"s\"\n                case 'u' => \"v\"\n                case\
    \ 'v' => \"v\"\n                case 'w' => \"w\"\n                case 'x' =>\
    \ \"x\"\n                case 'y' => \"y\"\n                case 'z' => \"z\"\n\
    \                case _ => x\n            })\n            case x if letters.contains(x) ",
  "        var message : String = \"\"\n        var vowel = \"AEIOUaeiou\"\n     \
    \   var lower = \"abcdefghijklmnopqrstuvwxyz\"\n        var upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        for( letters <- message) {\n            message += letter match {\n\
    \                case letter if letter in vowel => letter match {\n          \
    \          case letter if letter in vowel => lower match {\n                 \
    \       case letter if lower ( index <- lower.indexOf(lower)) => lower(index)\
    \ + lower(index + 1) + letter\n                        case letter if lower index\
    \ > lower.indexOf(letter) => lower(index - 1) + letter\n                     \
    \   case letter => lower(index)\n                    }\n                    case\
    \ letter if lower index > lower.indexOf(letter) => lower match {\n           \
    \             case letter if lower ( index <- lower.indexOf(lower)) => lower(index)\
    \ + lower(index + 1) + letter\n                        case letter if lower index\
    \ > lower.indexOf(letter) => lower(index - 1) + letter\n                     \
    \   case letter => lower match {\n                            case letter if lower\
    \ ( index <- lower.indexOf(lower)) => lower + lower + letter\n               \
    \             case letter if lower index > lower.indexOf(letter) => lower + lower(index\
    \ - 1) + letter\n                            case letter => lower (index)\n  \
    \                      }\n                    }\n                    case letter\
    \ if lower index > lower.indexOf(letter) => lower match {\n                  \
    \      case letter if lower ( index <- lower.indexOf(lower)) => lower + lower\
    \ + letter\n                        case letter if lower index > lower.indexOf(letter)\
    \ => lower + lower(index - 1) + letter\n                        case letter =>\
    \ lower (index)\n                    }\n                }\n                case\
    \ letter if lower index > lower.indexOf(letter) => lower match {\n           \
    \         case letter if lower ( index <- lower.indexOf(lower)) => lower + lower\
    \ + letter\n                    case letter if lower index > lower.indexOf(letter)\
    \ => lower + lower(index - 1) + letter\n                    case letter => lower\
    \ (index)\n                }\n            }\n        }\n        message", "  \
    \      // Write your code here\n        val vowels = \"aeiou\"\n        val eng_vowels\
    \ = \"AEIOU\"\n        var messageWithEncVowels = message\n        var message\
    \ = messageWithEncVowels.toUpperCase\n\n        val newMessage = for (charA <-\
    \ message) yield {\n            if (charA.isLower) charA\n            else charA.toLowerCase\n\
    \        }\n        val newMessageWithEncVowels = for (charA <- newMessage) yield\
    \ {\n            if (vowels.contains(charA)) charA\n            else eng_vowels.indexOf(charA)\
    \ + 2\n        }\n        messageWithEncVowels = newMessageWithEncVowels.toUpperCase\n\
    \n        messageWithEncVowels", "        def replaceVowel(index : Int) : String\
    \ = {\n            val currentChar = message(i)\n            val nextChar = message(i\
    \ + 1)\n            if (currentChar == 'a') 'b'\n            else if (currentChar\
    \ == 'e') 'f'\n            else if (currentChar == 'i') 'g'\n            else\
    \ if (currentChar == 'o') 'h'\n            else if (currentChar == 'u') 'j'\n\
    \            else nextChar\n        }\n\n        def replaceLetter(index : Int)\
    \ : String = {\n            val currentChar = message(i)\n            val nextChar\
    \ = message(i + 1)\n            if (currentChar == 'a') 'b'\n            else\
    \ if (currentChar == 'e') 'f'\n            else if (currentChar == 'i') 'g'\n\
    \            else if (currentChar == 'o') 'h'\n            else if (currentChar\
    \ == 'u') 'j'\n            else nextChar\n        }\n\n        val alphabet =\
    \ \"abcdefghijklmnopqrstuvwxyz\"\n        val vowels = \"aeiou\"\n        val\
    \ newMessage = message.map(replaceLetter).map(replaceVowel)\n        val newAlphabet\
    \ = alphabet.map(replaceLetter).map(replaceVowel)\n        newMessage.zip(newAlphabet).map\
    \ {\n            case (newString, newLetter) => newLetter + newString\n      \
    \  }.toList", "        val alphabet = scala.collection.mutable.List('a' to 'z')\n\
    \        val vowels = \"aeiouAEIOU\"\n        val letterMap = scala.collection.mutable.Map[String,String]()\n\
    \        message.foreach {\n            letter =>\n            val index = alphabet.indexOf(letter)\n\
    \            letterMap(letter) = alphabet(index+1)\n            alphabet.updated(index+1,letter)\n\
    \        }\n        val newMessage = message.map(letter => letterMap(letter))\n\
    \        val result = newMessage.toString.replaceAllIn(vowels, letterMap(\"a\"\
    ))\n        result", "        val letters = message.filter(_ > 'A' && _ < 'Z').toList\n\
    \        val vowels = Array('a', 'e', 'i', 'o', 'u')\n        val alphabet = letters\
    \ zip vowels\n        message.map(l => alphabet(alphabet.indexOf(l)+1))", "  \
    \      var result = new StringBuilder(message)\n        for(i <- 0 until result.length())\
    \ {\n            val letter = result.charAt(i)\n            val vowelIndex = i\n\
    \            val vowel = vowels.indexOf(letter)\n            if(vowel != -1) {\n\
    \                val aLetter = vowel + 2\n                val aLetter = chars.indexOf(aLetter)\n\
    \                val replacement = chars(aLetter)\n                result.setCharAt(i,\
    \ replacement)\n            }\n        }\n        return result.toString()", " \
    \       val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('e','i','o','u')\n        val res = message\n     \
    \   // We first replace all vowels in the message with the letter that appears\
    \ 2 places ahead of them in the alphabet\n        res = res.replaceAllIn(vowels,alphabet(alphabet.indexOf(vowels(alphabet.indexOf(vowels.indexOf(\"\
    e\"))+1))+2))\n        val letters = message.split(\"\")\n        val res = letters.foldLeft(List[String]())((list,c)\
    \ => {\n            var l = list\n            if(c matches vowels)\n         \
    \   l = c match {\n                case 'e' -> alphabet(alphabet.indexOf(\"e\"\
    )+1)\n                case 'i' -> alphabet(alphabet.indexOf(\"i\")+1)\n      \
    \          case 'o' -> alphabet(alphabet.indexOf(\"o\")+1)\n                case\
    \ 'u' -> alphabet(alphabet.indexOf(\"u\")+1)\n                case _ -> c\n  \
    \          }\n            if(l.length==2)\n            l :+ alphabet(alphabet.indexOf(l.last)+2)\n\
    \            else\n            list\n        })\n        res = res.reverse.foldRight[String](res)(_.concat(_))\n\
    \        res", "        val vowels = \"aeiouAEIOU\".toList\n        val consonants\
    \ = \"bcdfghjklmnpqrstvwxyz\".toList\n        val replacements = consonants zip\
    \ vowels\n        message.zipWithIndex.map { case(letter, i) => if (letter !=\
    \ ' ') letter else replacements(i)(letter - 2) }.mkString", "        val englishAlphabet\
    \ = List('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\
    \ 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z');\n        val englishVowels\
    \ = List('a', 'e', 'i', 'o', 'u')\n        val initialMessage = message filter\
    \ { x => x.toUpper == x } map { x => x.toUpper } mkString \"\"\n        val initialMessageLength\
    \ = initialMessage.length\n        var i = 0;\n        while (i < initialMessageLength)\
    \ {\n            val initialChar = initialMessage.charAt(i);\n            if (englishAlphabet.contains(initialChar))\
    \ {\n                val position = englishAlphabet.indexOf(initialChar);\n  \
    \              if (position != 0) {\n                    val after = initialMessage.charAt(position\
    \ + 1);\n                    val afterChar = after.toUpper\n                 \
    \   if (englishVowels.contains(afterChar)) {\n                        val replace\
    \ = englishAlphabet(position);\n                        initialMessage = initialMessage\
    \ replace initialChar replace\n                    } else {\n                \
    \        initialMessage = initialMessage replace initialChar initialChar\n   \
    \                 }\n                }\n            }\n            i += 1\n  \
    \      }\n        initialMessage", "        var result: String = \"\";\n     \
    \   for(i <- 0 until message.length){\n            if((message.charAt(i)).equals(\"\
    a\")) result += message.charAt(i).toUpper;\n            if((message.charAt(i)).equals(\"\
    e\")) result += message.charAt(i).toUpper;\n            if((message.charAt(i)).equals(\"\
    i\")) result += message.charAt(i).toUpper;\n            if((message.charAt(i)).equals(\"\
    o\")) result += message.charAt(i).toUpper;\n            if((message.charAt(i)).equals(\"\
    u\")) result += message.charAt(i).toUpper;\n            if((message.charAt(i)).equals(\"\
    A\")) result += message.charAt(i).toUpper;\n            if((message.charAt(i)).equals(\"\
    E\")) result += message.charAt(i).toUpper;\n            if((message.charAt(i)).equals(\"\
    I\")) result += message.charAt(i).toUpper;\n            if((message.charAt(i)).equals(\"\
    O\")) result += message.charAt(i).toUpper;\n            if((message.charAt(i)).equals(\"\
    U\")) result += message.charAt(i).toUpper;\n            result += message.charAt(i);\n\
    \            result += message.charAt(i).toUpper;\n            result += message.charAt(i).toUpper;\n\
    \            result += message.charAt(i).toUpper;\n            result += message.charAt(i).toUpper;\n\
    \            result += message.charAt(i).toUpper;\n            result += message.charAt(i).toUpper;\n\
    \            result += message.charAt(i).toUpper;\n            result += message.charAt(i).toUpper;\n\
    \        }\n        return result;", "        val result: List[String] = message\
    \ map {letter =>\n            if (letter == 't') letter.toUpperCase \n       \
    \     else letter match{\n                case 'a' => letter.toUpperCase + letter.toLowerCase\
    \ \n                case 'e' => letter.toUpperCase + letter.toLowerCase \n   \
    \             case 'i' => letter.toUpperCase + letter.toLowerCase \n         \
    \       case 'o' => letter.toUpperCase + letter.toLowerCase \n               \
    \ case 'u' => letter.toUpperCase + letter.toLowerCase \n                case _\
    \ => letter\n            }\n        }\n        result.mkString(\"\")", "     \
    \   val vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n        val vowelMap:\
    \ mutable.Map[Char, Char] = mutable.Map(a -> 'b', e -> 'f', i -> 'g', o -> 'h',\
    \ u -> 'j')\n        message\n            .map(l => vowelMap.get(l))\n       \
    \     .map(v => v.head + (v.tail * 2))\n            .map(cs => cs.mkString)\n\
    \            .map(cs => cs.map(c => vowels(c)).mkString())\n            .mkString",
  "      // The solution to this is quite simple. We iterate over the string and \n\
    \      // for each letter we keep track of the position it appears \n      //\
    \ in the english alphabet (in a Map). Each time we see a letter, we \n      //\
    \ can swap the letter to the position 2 places ahead of that letter in \n    \
    \  // the alphabet (we know that this is 2 letters because of the fact that\n\
    \      // the letter we are replacing is the next letter of the alphabet). \n\
    \      // After we have iterated over the string and have swapped the letters,\
    \ we \n      // simply rebuild the string from the Map and return the result \n\
    \      (message +: message.dropWhile(_ == '.').map { c => \n        (english.get(c.toLowerCase())\
    \ - (english.get(c.toLowerCase()) + 2).toString) \n        + \" \" \n        +\
    \ (english.get(c.toLowerCase()) + 2).toString\n      }).mkString", "      val\
    \ newMessage = message.foldLeft(\"\"){ (acc, letter) => \n        val indexedLetter\
    \ = letter.toString.toUpperCase.indexOf\n        val firstLetter = indexedLetter\
    \ % 26\n        val secondLetter = indexedLetter / 26\n        val firstVowelIndex\
    \ = firstLetter % 5\n        val secondVowelIndex = firstLetter / 5\n        acc\
    \ + (if (firstVowelIndex == 0 && secondVowelIndex > 1) secondLetter else \n  \
    \      ((if (firstVowelIndex > 0) firstLetter else \n        ((if (secondVowelIndex\
    \ > 0) secondLetter else firstLetter) + 1))))\n      }\n      newMessage", " \
    \       val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = \"a\",\"e\",\"i\",\"o\",\"u\",\"y\"\n        val messageArr\
    \ = message.toList\n        val outputString = \"\"\n\n        for(i<-0 until\
    \ messageArr.size){\n            val curr = messageArr(i)\n            val newCase\
    \ = alphabet(alphabet.indexOf(curr))\n            outputString += newCase\n  \
    \          outputString += alphabet(alphabet.indexOf(messageArr(i + 1)) + 2)\n\
    \        }\n        outputString", "        val vowels = \"aeiou\"\n        val\
    \ vowelIndex = List(1,2,3,4,5,6,7,8,9,0).zipWithIndex.filter{ case (s,i) => vowels.contains(s)\
    \ }.map(_._2)\n        val newMessage = message\n            .toCharArray\n  \
    \          .map { c =>\n                c match {\n                    case vowels(1)\
    \ =>\n                        vowels(0)\n                    case vowels(2) =>\n\
    \                        vowels(1)\n                    case vowels(3) =>\n  \
    \                      vowels(2)\n                    case vowels(4) =>\n    \
    \                    vowels(3)\n                    case vowels(5) =>\n      \
    \                  vowels(4)\n                    case vowels(6) =>\n        \
    \                vowels(5)\n                    case vowels(7) =>\n          \
    \              vowels(6)\n                    case vowels(8) =>\n            \
    \            vowels(7)\n                    case vowels(9) =>\n              \
    \          vowels(8)\n                    case vowels(0) =>\n                \
    \        vowels(9).head\n                }\n            }\n            .toString\n\
    \        newMessage", "        val alphaSet = scala.collection.mutable.Set(\"\
    A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"\
    N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\")\n\
    \        val vowelSet = scala.collection.mutable.Set(\"a\",\"e\",\"i\",\"o\",\"\
    u\")\n        val messageArray = message.toCharArray.map(_.toUpperCase)\n    \
    \    val swapped = messageArray.zip(messageArray.reverse)\n        val encoded\
    \ = swapped.map(c => {\n            if(alphaSet.contains(c))\n               \
    \ c\n            else if(vowelSet.contains(c))\n                alphaSet(messageArray.indexOf(c)\
    \ + 1)\n            else\n                c\n        })\n        encoded.mkString(\"\
    \")", "        val alphabet = ('A' -> 'A', 'T' -> 'T', 'G' -> 'G', 'C' -> 'C'\
    \ ,'M' ->'M', 'R' -> 'R')\n        var res = \"\"\n        for (i <- message.indices)\
    \ {\n            res = res + alphabet(message.charAt(i)) + alphabet(message.charAt(i-1))\
    \ \n        }\n        return res", "        val vowels =  List(\"a\",\"e\",\"\
    i\",\"o\",\"u\")\n        val caps = List(\"A\",\"E\",\"I\",\"O\",\"U\")\n   \
    \     val swaps = vowels zip caps\n        val swapped = message flatMap { charToNum(c)\
    \ => swaps.find(_._1 == charToNum(c))._2 }\n        swapped map numToChar", " \
    \       val res = message.map(letter => {\n            val index = letter.indexOf\n\
    \            (\n                if (index > -1 && index == 0 || index == 2 ||\
    \ index == 4) letter.charAt(index) \n                else if (letter.indexOf(\"\
    aeiou\") > -1) letter.charAt(letter.length)\n                else letter\n   \
    \         )\n        })\n        \"\"+res.mkString(\"\")", "        // Write your\
    \ code here\n        val vowelSet = scala.collection.mutable.HashSet[Char]()\n\
    \        val vowels = \"aeiouAEIOU\"\n        for(x <- message) vowelSet.add(x)\
    \ \n        for(x <- vowels) { \n            val vowels2 =  vowels.indexOf(x)\
    \ + 2\n            val vowels2 = vowels2 % vowels.length\n            val charToBeReplaced\
    \ = message.charAt(vowels2)\n            val result = charToBeReplaced \n    \
    \        for(i <- 1 to vowels2) result += message.charAt(i)\n            val resultSet\
    \ = scala.collection.mutable.Set[Char]()\n            resultSet.add(result)\n\
    \            vowelSet.remove(x)\n            vowelSet.add(result)\n        }\n\
    \        resultSet.mkString.toUpperCase", "        val charArray = message.split(\"\
    \")\n        var newMessage : String = \"\"\n        val vowelSet = scala.collection.mutable.Set(\"\
    A\", \"E\", \"I\", \"O\", \"U\")\n        val consonantSet = scala.collection.mutable.Set(\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\")\n\n      \
    \  for (c <- charArray) {\n            val charArrayIndexOfVowel = vowelSet.indexOf(c)\n\
    \            val charArrayIndexOfConsonant = consonantSet.indexOf(c)\n       \
    \     if (charArrayIndexOfVowel > -1 && charArrayIndexOfConsonant > -1) {\n  \
    \              val swappedCharArrayIndexOfVowel = charArrayIndexOfVowel + 2\n\
    \                val swappedCharArrayIndexOfConsonant = charArrayIndexOfConsonant\
    \ + 2\n                if (swappedCharArrayIndexOfVowel > vowelSet.size || swappedCharArrayIndexOfConsonant\
    \ > consonantSet.size) {\n                    throw new IllegalArgumentException\n\
    \                }\n                if (charArrayIndexOfVowel < charArrayIndexOfConsonant)\
    \ {\n                    newMessage += vowelSet(swappedCharArrayIndexOfVowel)\n\
    \                } else {\n                    newMessage += consonantSet(swappedCharArrayIndexOfConsonant)\n\
    \                }\n            }\n        }\n        newMessage", "        val\
    \ l = message.length\n        var i = 0\n        var k = 0\n        var result\
    \ = \"\"\n        for (x <- message) {\n            if (x < 'a' || x > 'z') {\n\
    \                result += x.toString\n            } else {\n                if\
    \ (i < (l - 1)) {\n                    if (message(chars(i)) >= 'a' && message(chars(i))\
    \ <= 'z') {\n                        result += message(chars(i)) + message(chars(i\
    \ + 1))\n                        i += 2\n                    } else {\n      \
    \                  result += message(chars(i))\n                        i += 1\n\
    \                    }\n                } else {\n                    result +=\
    \ message(chars(i))\n                    i += 1\n                }\n         \
    \   }\n        }\n        result", "        val messageLowerCase = message.toLowerCase()\n\
    \        val encodedString = new mutable.StringBuilder\n        var index = 0\n\
    \        while (index < messageLowerCase.length){\n            var isVowel = false\n\
    \            var isUpper = false\n            var currentLetter = messageLowerCase(index)\n\
    \            var currentVowel = currentLetter match {\n                case c:\
    \ \"a\" | \"e\" | \"i\" | \"o\" | \"u\" => c\n                case _ => \"a\"\n\
    \            }\n            index += 1\n            while (index < messageLowerCase.length){\n\
    \                val nextLetter = messageLowerCase(index)\n                nextLetter\
    \ match {\n                    case \"a\" => \"b\"\n                    case \"\
    b\" => \"a\"\n                    case \"c\" => \"d\"\n                    case\
    \ \"d\" => \"c\"\n                    case \"e\" => \"f\"\n                  \
    \  case \"f\" => \"e\"\n                    case \"g\" => \"h\"\n            \
    \        case \"h\" => \"g\"\n                    case \"i\" => \"j\"\n      \
    \              case \"j\" => \"i\"\n                    case \"k\" => \"l\"\n\
    \                    case \"l\" => \"k\"\n                    case \"m\" => \"\
    n\"\n                    case \"n\" => \"m\"\n                    case \"o\" =>\
    \ \"p\"\n                    case \"p\" => \"o\"\n                    case \"\
    q\" => \"r\"\n                    case \"r\" => \"q\"\n                    case\
    \ \"s\" => \"t\"\n                    case \"t\" => \"s\"\n                  \
    \  case \"u\" => \"v\"\n                    case \"v\" => \"u\"\n            \
    \        case \"w\" => \"x\"\n                    case \"x\" => \"w\"\n      \
    \              case \"y\" => \"z\"\n                    case \"z\" => \"y\"\n\
    \                    case \"A\" => \"B\"\n                    case \"B\" => \"\
    A\"\n                    case \"C\" => \"D\"\n                    case \"D\" =>\
    \ \"C\"\n                    case \"E\" => \"F\"\n                    case \"\
    F\" => \"E\"\n                    case \"G\" => \"H\"\n                    case\
    \ \"H\" => \"G\"\n                    case \"I\" => \"J\"\n                  \
    \  case \"J\" => \"I\"\n                    case \"K\" => \"L\"\n            \
    \        case \"L\" => \"K\"\n                    case \"M\" => \"N\"\n      \
    \              case \"N\" => \"M\"\n                    case \"O\" => \"P\"\n\
    \                    case \"P\" => \"O\"\n                    case \"Q\" => \"\
    R\"\n                    case \"R\" => \"Q\"\n                    case \"S\" =>\
    \ \"T\"\n                    case \"T\" => \"S\"\n                    case \"\
    U\" => \"V\"\n                    case \"V\" => \"U\"\n                    case\
    \ \"W\" => \"X\"\n                    case \"X\" => \"W\"\n                  \
    \  case \"Y\" => \"Z\"\n                    ", "        val result = \"\"\n  \
    \      for(i <- 0 to message.length-1){\n            val char1 = message.charAt(i)\n\
    \            if(char1 != 'a' && char1 != 'e' && char1 != 'i' && char1 != 'o' &&\
    \ char1 != 'u')\n                result += char1\n        }\n        val arr =\
    \ result.split(\"\")\n        for(i <- 0 to arr.length-1){\n            val arr\
    \ = result.split(\"\")\n            val index = arr.indexWhere(_ == arr(i))\n\
    \            if(arr.length <= 2)\n                result += arr(i)\n         \
    \   else\n                result += arr(i).swapCase.charAt(index)\n        }\n\
    \        return result", "        val letters = message.split('')\n        val\
    \ vowels = \"aeiou\"\n        val map = Map('a'->\"A\", 'e'->\"E\", 'i'->\"I\"\
    , 'o'->\"O\", 'u'->\"U\")\n        val map2 = Map('e'->\"E\", 'i'->\"I\", 'o'->\"\
    O\", 'u'->\"U\", 'a'->\"A\", 'i'->\"I\", 'o'->\"O\", 'u'->\"U\", 'A'->\"A\", 'i'->\"\
    I\", 'o'->\"O\", 'u'->\"U\")\n        var res = new Array[Char](letters.length)\n\
    \        for (i <- 0 to letters.length-1){\n            if(letters(i) == vowels(0)){\n\
    \                for(j <- 0 to i-1){\n                    if(vowels(j) == letters(j)){\n\
    \                        letters(j) = map2(vowels(j))\n                    }\n\
    \                }\n                letters(i) = map(vowels(i))\n            }\n\
    \            for(j <- 0 to i-1){\n                letters(j) = map2(letters(j))\n\
    \            }\n            res = res :+ letters(i)\n        }\n        val ans\
    \ = new String(res)\n        return res", "        val newmessage = message.toLowerCase\n\
    \        var newmessage = message.toLowerCase\n        var index = 0\n       \
    \ while(index != newmessage.length){\n            if(newmessage(index) == \"a\"\
    ){\n                newmessage = newmessage.replaceAll(\"a\",\"A\")\n        \
    \    }\n            if(newmessage(index) == \"e\"){\n                newmessage\
    \ = newmessage.replaceAll(\"e\",\"E\")\n            }\n            if(newmessage(index)\
    \ == \"i\"){\n                newmessage = newmessage.replaceAll(\"i\",\"I\")\n\
    \            }\n            if(newmessage(index) == \"o\"){\n                newmessage\
    \ = newmessage.replaceAll(\"o\",\"O\")\n            }\n            if(newmessage(index)\
    \ == \"u\"){\n                newmessage = newmessage.replaceAll(\"u\",\"U\")\n\
    \            }\n            if(newmessage(index) == \"A\"){\n                newmessage\
    \ = newmessage.replaceAll(\"A\",\"a\")\n            }\n            if(newmessage(index)\
    \ == \"E\"){\n                newmessage = newmessage.replaceAll(\"E\",\"e\")\n\
    \            }\n            if(newmessage(index) == \"I\"){\n                newmessage\
    \ = newmessage.replaceAll(\"I\",\"i\")\n            }\n            if(newmessage(index)\
    \ == \"O\"){\n                newmessage = newmessage.replaceAll(\"O\",\"o\")\n\
    \            }\n            if(newmessage(index) == \"U\"){\n                newmessage\
    \ = newmessage.replaceAll(\"U\",\"u\")\n            }\n            index += 1\n\
    \        }\n        newmessage", "        val englishLetters = Array('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z')\n\
    \        val vowels = Array('a','e','i','o','u')\n        val encoded = message\n\
    \            .foldLeft(\"\")( (acc,letter) => \n                acc + (if (englishLetters.contains(letter))\
    \ letter else \n                        vowels.contains(acc) match { case true\
    \ => letter + englishLetters.indexOf(vowels.indexOf(acc)) else letter }) )\n \
    \       encoded", "      var output = \"\"\n      for (i <- 0 until message.length)\n\
    \      {\n          output += message.charAt(i).swapCase.charAt(0).toUpperCase\n\
    \          output += message.charAt(i).swapCase.charAt(1).toUpperCase\n      }\n\
    \      output", "        val vowels = Array(\"a\", \"e\", \"i\", \"o\", \"u\"\
    )\n        val letters = message.map(_.toUpperCase)\n        val letterCounts\
    \ = letters.map(letter => letter -> letter.count(letter => vowels.contains(letter)))\n\
    \        var res = \"\"\n        for(letter <- letters) {\n            val index\
    \ = letterCounts.findIndex(letterCounts => (letterCounts._1 == letter))\n    \
    \        if(index != -1) res += letterCounts(letter)\n            else res +=\
    \ letter\n        }\n        return res", "        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var finalString = \"\"\n        for ( word <- message){\n           \
    \ finalString += word.toUpperCase.takeWhile(c => alphabet.contains(c)).mkString(\"\
    \") +\n            word.takeWhile(c => alphabet.contains(c)).mkString(\"\") +\
    \ \n            word.dropWhile(c => alphabet.contains(c)).mkString(\"\") + \n\
    \            word.drop(word.lastIndexOf(word.toUpperCase.takeWhile(c => alphabet.contains(c)))).mkString(\"\
    \") + \n            word.drop(word.lastIndexOf(word.toUpperCase.takeWhile(c =>\
    \ alphabet.contains(c))))\n        }\n        finalString", "        val messageList\
    \ = message.toLowerCase.split(\" \").filter(_.length() > 0)\n        var result\
    \ = \"\"\n        var index = 0\n        for(i <- 0 until messageList.length){\n\
    \            if(messageList(i).length() > 1){\n                result += messageList(i).toChar.swapCase().toString.replaceAll(\"\
    [^A-Z]\", messageList(i).toChar)\n                index++\n            }else{\n\
    \                result += messageList(i).toChar\n                index++\n  \
    \          }\n        }\n        result", "      // Add your code here\n     \
    \ return message;", "        var result = \"\"\n        for(char <- message) {\n\
    \            if(char.matches(\"[a-zA-Z]\"))\n                result += char.toUpperCase().replace('a','A').replace('e','E')\n\
    \            else\n                result += char\n        }\n        result",
  "        var i = 0\n        var messageToEncode : String = \"\"\n        for (c\
    \ <- message) {\n            if(i>0) messageToEncode += (c.toUpperCase)\n    \
    \        else {\n                val vowels = \"AEIOUaeiou\"\n               \
    \ var counter = 0\n                for (v <- vowels) {\n                    if(v\
    \ == c) {\n                        counter += 2\n                    }\n     \
    \           }\n                if(counter>0) messageToEncode += (v.charAt(counter))\n\
    \            }\n            i += 1\n        }\n        \n        // Now apply\
    \ the algorithm to the message\n        val alphabet : Array[Char] = Array('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var messageDecoded : String = \"\"\n        var j = 0\n        for (c\
    \ <- messageToEncode) {\n            val a = alphabet(j)\n            var b =\
    \ 0\n            for (v <- vowels) {\n                if(v == c) {\n         \
    \           b += 1\n                }\n            }\n            if(j==0) {\n\
    \                messageDecoded += a\n                j = 1\n            } else\
    \ if(j==1) {\n                if(b==0) {\n                    messageDecoded +=\
    \ a\n                    j = 2\n                } else {\n                   \
    \ messageDecoded += a.charAt(b-1)\n                    j = 2\n               \
    \ }\n            } else {\n                if(b==0) {\n                    messageDecoded\
    \ += a\n                    j = 0\n                } else {\n                \
    \    messageDecoded += a.charAt(b-1)\n                    j = 0\n            \
    \    }\n            }\n        }\n        \n        // Return the encoded message\n\
    \        return messageDecoded", "        val list = message.map { \n        \
    \    case x => (x.toUpperCase + x.toLowerCase) \n        }.toList\n        val\
    \ map = list.groupBy(x => (x.charAt(0)/2))\n        val result = map.map { case\
    \ (c,list) => \n            val index = list.indexOf(c._1)\n            if (index\
    \ > 0) {\n                val prev = list[index-1]\n                val next =\
    \ list[index+1]\n                val replaced = c._2.map(x => (x._1 + prev.toUpperCase\
    \ + x._2.toLowerCase)).mkString\n                next + replaced + prev\n    \
    \        } else {\n                c._2.map(x => (x._1 + x._2.toLowerCase)).mkString\n\
    \            }\n        }.mkString\n        return result", "        var newMessage\
    \ = message\n        var position = 1\n        // If there are less than 2 positions\
    \ \n        // ahead of the current letter, \n        // then that letter is swapped\
    \ with the \n        // 2 position ahead letter.\n        if(newMessage.count(_\
    \ == 'A') - 1 == 2)\n            newMessage =\n                newMessage.map((x\
    \ => {\n                    if(x.toLower.equals('a'))\n                      \
    \  return x.toUpper\n                    else\n                        return\
    \ x.toLower\n                }))\n        // Otherwise, we need to swap the vowels\
    \ in the message.\n        else if(newMessage.count(_ == 'A') - 1 > 2)\n     \
    \       newMessage =\n                newMessage.map((x => {\n               \
    \     if(x.toLower.equals('a'))\n                        return x.toLower\n  \
    \                  else\n                        return x.toUpper\n          \
    \      }))\n        // If the current letter is A, then we need to \n        //\
    \ find two adjacent letters in the english alphabet \n        // that share the\
    \ same vowel. \n        else if(newMessage.count(_ == 'A') - 1 == 1)\n       \
    \     newMessage =\n                newMessage.map((x => {\n                 \
    \   if(x.toLower.equals('a'))\n                        return x.toUpper\n    \
    \                else {\n                        val positionAround = position\
    \ + 1\n                        position += 2\n                        val positionAround2\
    \ = positionAround + 1\n                        position += 2\n              \
    \          if(positionAround == newMessage.count(_ == 'A'))\n                \
    \            return x.toUpper\n                        else if(positionAround2\
    \ == newMessage.count(_ == 'A'))\n                            return x.toLower\n\
    \                        else\n                            return x.toUpper\n\
    \                    }\n                }))\n        newMessage", "        var\
    \ s = message \n        val vowels = \"AEIOUaeiou\".toCharArray\n        val indexes\
    \ = new mutable.ListBuffer[Int]()\n        for (i <- 0 to s.length-1) {\n    \
    \        if (vowels(i)==' ') {\n                indexes += i\n            }\n\
    \        }\n        for (i1 <- 0 to indexes.length-1) {\n            val index\
    \ = indexes(i1)\n            val letter = s(index)\n            s = s.replaceAll(letter,\
    \ s(index+2))\n        }\n        return s", "        val alphabet = \"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYz\"\
    \n        val encoded = message.toLowerCase.zip(alphabet).foldLeft(\"\") {\n \
    \           case (acc, (c,a)) => acc + (a(c.toUpperCase) match {\n           \
    \     case \"a\" => \"t\"\n                case \"b\" => \"h\"\n             \
    \   case \"c\" => \"k\"\n                case \"d\" => \"s\"\n               \
    \ case \"e\" => \"g\"\n                case \"f\" => \"h\"\n                case\
    \ \"g\" => \"h\"\n                case \"h\" => \"s\"\n                case \"\
    i\" => \"j\"\n                case \"j\" => \"j\"\n                case \"k\"\
    \ => \"l\"\n                case \"l\" => \"l\"\n                case \"m\" =>\
    \ \"n\"\n                case \"n\" => \"n\"\n                case \"o\" => \"\
    p\"\n                case \"p\" => \"p\"\n                case \"q\" => \"q\"\n\
    \                case \"r\" => \"r\"\n                case \"s\" => \"s\"\n  \
    \              case \"t\" => \"t\"\n                case \"u\" => \"v\"\n    \
    \            case \"v\" => \"v\"\n                case \"w\" => \"x\"\n      \
    \          case \"x\" => \"x\"\n                case \"y\" => \"y\"\n        \
    \        case \"z\" => \"z\"\n                case _ => c)\n            }).toUpperCase\
    \ + acc\n        }\n        encoded", "        var output = message.toCharArray.mkString\n\
    \        val vowels = \"aeiouAEIOU\".toCharArray\n        for (x<-1 to message.length-1)\
    \ {\n            if (vowels(x) == message(x)) {\n                output = output.substring(0,\
    \ x) + output.substring(x+1, x+2).toUpperCase()\n            }\n        }\n  \
    \      return output", "        val s = message.foldLeft(\"\")(_ + _)\n      \
    \  val vowels = \"aeiouAEIOU\".toList\n        val messageList = message.split(\"\
    \")\n        val vowelIndex = messageList.foldLeft(0)((c, _) => c + 1)\n     \
    \   val vowelIndex = messageList.foldLeft(0)((c, _) => c + 1)\n        val newList\
    \ = messageList.map(x => x.toUpperCase)\n        val upperCaseIndexed = newList.zipWithIndex.filter(x\
    \ => x % 2 == 0)\n        val firstVowelIndex = upperCaseIndexed.foldLeft(0)((c,\
    \ _) => c + 1)\n        val firstVowelIndex = upperCaseIndexed.foldLeft(0)((c,\
    \ _) => c + 1)\n        val newUpperCaseIndexed = upperCaseIndexed.map(x => x._1\
    \ + x._2)\n        val newUpperIndexed = newUpperCaseIndexed.zipWithIndex.filter(x\
    \ => x % 2 == 0)\n        val newList2 = newUpperIndexed.map(x => x._1 + x._2)\n\
    \        val newString2 = newList2.zipWithIndex.filter(x => x % 2 == 0)\n    \
    \    val first2Indexed = newString2.foldLeft(0)((c, _) => c + 1)\n        val\
    \ first2Indexed = newString2.foldLeft(0)((c, _) => c + 1)\n        val newString3\
    \ = newString2.map(x => x._1 + x._2)\n        val newString4 = newString3.zipWithIndex.filter(x\
    \ => x % 2 == 0)\n        val first3Indexed = newString4.foldLeft(0)((c, _) =>\
    \ c + 1)\n        val first3Indexed = newString4.foldLeft(0)((c, _) => c + 1)\n\
    \        val newString5 = newString4.map(x => x._1 + x._2)\n        val first4Indexed\
    \ = newString5.foldLeft(0)((c, _) => c + 1)\n        val first4Indexed = newString5.foldLeft(0)((c,\
    \ _) => c + 1)\n        val newString6 = newString5.map(x => x._1 + x._2)\n  \
    \      val first5Indexed = newString6.foldLeft(0)((c, _) => c + 1)\n        val\
    \ first5Indexed = newString6.foldLeft(0)((c, _) => c + 1)\n        val newString7\
    \ = newString6.map(x => x._1 + x._2)\n        val first6Indexed = newString7.foldLeft(0)((c,\
    \ _", '        // write your code here', "        var index = 0\n        var result\
    \ = \"\"\n        while (index < message.length){\n            val vowels = \"\
    AEIOU\"\n            val characterIndex  = vowels.indexOf(message.charAt(index))\n\
    \            val characterIndex2 = vowels.indexOf(message.charAt(index))\n   \
    \         if (characterIndex != characterIndex2){\n                result += message.charAt(index)\
    \ \n            } else {\n                val swapCase = message.substring(index\
    \ + 1, message.length)\n                result += swapCase.toUpperCase()\n   \
    \             index += 2\n            }\n            index += 1\n        }\n \
    \       result", "        var output = message\n        val vowels = \"aeiou\"\
    \n        val indexMap = new mutable.HashMap[String,Int]()\n        for (i <-\
    \ 0 until output.length) {\n            val c = output(i).toChar\n           \
    \ val lowerCaseC = c\n            if (vowels.contains(lowerCaseC)) {\n       \
    \         indexMap.setValue(lowerCaseC,indexMap.getOrElse(lowerCaseC,0)+1)\n \
    \           }\n        }\n        val orderedVowels = vowels.toList.sortWith(_.compareTo(_)\
    \ <= 0)\n        for (i <- 0 until orderedVowels.length) {\n            val vowelIndex\
    \ = orderedVowels(i)\n            val vowelValue = indexMap.getOrElse(vowelIndex,0)\n\
    \            val newVowelIndex = vowelValue + 2\n            val replacement =\
    \ vowels.charAt(newVowelIndex)\n            output = output.replaceFirst(vowels.charAt(i),\
    \ replacement)\n        }\n        output", "        def swapped(letter : String)\
    \ : String = {\n            def nextLetter(letter : String) : String = {\n   \
    \             if (letter.length != 1) letter\n                else letter.toLowerCase()\
    \ + letter.substring(0,1)\n            }\n            val firstVowel = letter.toLowerCase()\
    \ + letter.substring(1)\n            val nextVowel = nextLetter(firstVowel)\n\
    \            val letterToSwap = if (letter == firstVowel) firstVowel\n       \
    \     else nextVowel\n            (letterToSwap + nextVowel)\n        }\n    \
    \    def repaired(string : String) : String = {\n            string.map { letter\
    \ =>\n                swapped(letter)\n            }.mkString(\"\")\n        }\n\
    \        repaired(message)", "        var message = message.toLowerCase\n    \
    \    var messageArray = message.split(\"\")\n        messageArray = messageArray.map(char\
    \ => {\n            val index = char.charAt(0).toInt\n            if (char.charAt(0)\
    \ == 'a') return \"g\"\n            if (char.charAt(0) == 'e') return \"f\"\n\
    \            if (char.charAt(0) == 'i') return \"j\"\n            if (char.charAt(0)\
    \ == 'o') return \"m\"\n            if (char.charAt(0) == 'u') return \"h\"\n\
    \            if (char.charAt(0) == 'y') return \"k\"\n            if (char.charAt(0)\
    \ == 'i') return \"l\"\n            if (char.charAt(0) == 'A') return \"G\"\n\
    \            if (char.charAt(0) == 'E') return \"F\"\n            if (char.charAt(0)\
    \ == 'I') return \"J\"\n            if (char.charAt(0) == 'O') return \"M\"\n\
    \            if (char.charAt(0) == 'U') return \"H\"\n            if (char.charAt(0)\
    \ == 'Y') return \"K\"\n            if (char.charAt(0) == 'I') return \"L\"\n\
    \            return char.charAt(0)\n        })\n        var swappedArray = messageArray.zipWithIndex.filter(_._2\
    \ % 2 != 0).map {\n        case (word, index) => word.swapCase\n        }\n  \
    \      var newArray = swappedArray.zip(messageArray).filter(_._1 != _._2).map\
    \ {\n        case (word, index) => word.replaceAll(\"[aeiouAEIOUY]\", (_: String)\
    \ => {\n            val index = index.toInt + 1\n            val charToInsert\
    \ = messageArray.get(index - 1).charAt(0)\n            val charToRemove = messageArray.get(index).charAt(0)\n\
    \            charToRemove\n        }) \n        }\n        newArray.toList.mkString(\"\
    \")", "        var message =  message.toLowerCase\n        val alphabet = List('a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n        for(letter <- alphabet)\
    \ {\n            val index = alphabet.indexOf(letter)\n            if(message.contains(letter))\
    \ {\n                message = message.replaceAll(letter, alphabet(index+1))\n\
    \            }\n        }\n        val vowels = List('a', 'e', 'i', 'o', 'u')\n\
    \        for(vowel <- vowels) {\n            val index = vowels.indexOf(vowel)\n\
    \            if(message.contains(vowel)) {\n                message = message.replaceAll(vowel,\
    \ alphabet(index+2))\n            }\n        }\n        message", "        var\
    \ messageList = message.toLowerCase.split(\"\")\n        var charCounts = messageList.map(char\
    \ => char.toChar)\n        val vowels = \"aeiouAEIOU\".toCharArray\n        charCounts.foldLeft(Map[Char,Int]()){\n\
    \            case (accumulator,charCount) =>\n                val currentVowel\
    \ = vowels(charCount % vowels.length)\n                if(accumulator.contains(currentVowel)){\n\
    \                    accumulator + (currentVowel -> (accumulator(currentVowel)-1))\n\
    \                } else {\n                    accumulator + (currentVowel ->\
    \ (vowels.length-1))\n                }\n        }\n        .map{ case (k,v) =>\n\
    \            val currentVowel = vowels(v % vowels.length)\n            val newVowel\
    \ = vowels(v + 2)\n            val newCount = v + 2\n            currentVowel\
    \ -> newVowel\n        }.foldLeft((\"\")){\n            case (accumulator,(k,v))\
    \ =>\n                accumulator + k + v\n        }", "        var result = \"\
    \"\n        var vowels = \"AEIOUaeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        for (letter <- message){\n            result += letter.swapCase()\n\
    \            for (i <- 1 to vowels.length){\n                result += alphabet(vowels.charAt(i)\
    \ + alphabet.indexOf((vowels.charAt(i) + vowels.charAt(i - 1)) % 26))\n      \
    \      }\n        }\n        result", "        var result: String = message \n\
    \        for (i <- 0 to message.length - 2) {\n            if (message(i) >= 'a'\
    \ && message(i) <= 'z') {\n                result += ((message(i) + message(i\
    \ + 1)).toUpperCase)\n            } else {\n                result += message(i)\n\
    \            }\n        }\n        return result", "        // Your code here\n\
    \        var newMessage = message\n        var vowels = \"aeiouAEIOU\"\n     \
    \   var letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val countLetters = message.count(x\
    \ => letters.contains(x))\n        val countVowels = message.count(x => vowels.contains(x))\n\
    \        val countVowelsAhead = message.count(x => vowels.indexOf(x.charAt(2))\
    \ == 2)\n        println(newMessage)\n        newMessage.replace(vowels, letter\
    \ => {\n            val idx = letters.indexOf(letter)\n            val idx2 =\
    \ vowels.indexOf(vowels(idx))\n            val idx3 = vowels.indexOf(vowels(idx2))\n\
    \            if (idx3 == -1) {\n                if (idx == 2) {\n            \
    \        val idx4 = letters.indexOf(letters.substring(idx + 2, idx))\n       \
    \             val idx5 = letters.indexOf(letters.substring(idx2 + 1, idx2))\n\
    \                    val idx6 = letters.indexOf(letters.substring(idx5 + 1, idx4))\n\
    \                    val idx7 = letters.indexOf(letters.substring(idx6 + 1, idx5))\n\
    \                    val idx8 = letters.indexOf(letters.substring(idx7 + 1, idx6))\n\
    \                    if (idx8 != -1) {\n                        idx8\n       \
    \             } else {\n                        idx5\n                    } \n\
    \                } else if (idx == 2) {\n                    idx\n           \
    \     } else {\n                    idx\n                }\n            } else\
    \ {\n                idx2\n            }\n        })", "        val lowercase\
    \ = message.map {x => x.toLowerCase()}\n        val vowels = mutable.List(\"a\"\
    , \"e\", \"i\", \"o\", \"u\", \"y\")\n        val encodedString = mutable.ListBuffer.empty[String]\n\
    \        for (letter <- lowercase) {\n            val letterCount = vowels.count(_\
    \ == letter)\n            if(letterCount == 0)\n                encodedString\
    \ += letter\n            else if(letterCount > 2)\n                encodedString\
    \ += vowels(letterCount - 1)\n            else {\n                val position\
    \ = (vowels.indexOf(letter) + 1) % vowels.size\n                encodedString\
    \ += vowels(position)\n            }\n        }\n        encodedString.toList",
  "      val letters = new mutable.StringBuilder\n      for (x <- message) {\n   \
    \     val pos = x.indexOf(\"a\")\n        if (pos < 0) { letters += x }\n    \
    \    else {\n          val l = if (pos == 1) \"z\" else \"a\"\n          val p\
    \ = x.indexOf(\"a\")\n          if (p > -1 && (p + 1 == x.length)) letters +=\
    \ l\n          else letters += l + x.charAt(p + 1)\n        }\n      }\n     \
    \ letters.toString", '        // Code here ', "        // your code here\n   \
    \     val vowels: mutable.Set[String] = new mutable.HashSet(\"a\", \"e\", \"i\"\
    , \"o\", \"u\", \"y\"); \n        val alphabet: mutable.Set[String] = new mutable.HashSet(\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"\
    l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"); \n        val newMessage = mutable.StringBuilder(message);\
    \ \n        for (i <- 0 until message.size){\n            val currentChar = message(i)\n\
    \            val position = alphabet.indexOf(currentChar)\n            if (position\
    \ != -1) {\n                if (vowels.contains(currentChar)) {\n            \
    \        newMessage.setCharAt(i, \"a\" * position + \"e\" * (position + 1)) \n\
    \                }\n                else {\n                    newMessage.setCharAt(i,\
    \ \"a\" * position + \"e\" * (position + 1)) \n                }\n           \
    \ }\n        }\n        newMessage.toString", "        val replaceMap = new mutable.HashMap[String,String]()\n\
    \        replaceMap += \"a\" -> \"A\"\n        replaceMap += \"b\" -> \"B\"\n\
    \        replaceMap += \"c\" -> \"C\"\n        replaceMap += \"d\" -> \"D\"\n\
    \        replaceMap += \"e\" -> \"E\"\n        replaceMap += \"f\" -> \"F\"\n\
    \        replaceMap += \"g\" -> \"G\"\n        replaceMap += \"h\" -> \"H\"\n\
    \        replaceMap += \"i\" -> \"I\"\n        replaceMap += \"j\" -> \"J\"\n\
    \        replaceMap += \"k\" -> \"K\"\n        replaceMap += \"l\" -> \"L\"\n\
    \        replaceMap += \"m\" -> \"M\"\n        replaceMap += \"n\" -> \"N\"\n\
    \        replaceMap += \"o\" -> \"O\"\n        replaceMap += \"p\" -> \"P\"\n\
    \        replaceMap += \"q\" -> \"Q\"\n        replaceMap += \"r\" -> \"R\"\n\
    \        replaceMap += \"s\" -> \"S\"\n        replaceMap += \"t\" -> \"T\"\n\
    \        replaceMap += \"u\" -> \"U\"\n        replaceMap += \"v\" -> \"V\"\n\
    \        replaceMap += \"w\" -> \"W\"\n        replaceMap += \"x\" -> \"X\"\n\
    \        replaceMap += \"y\" -> \"Y\"\n        replaceMap += \"z\" -> \"Z\"\n\
    \        replaceMap += \"A\" -> \"a\"\n        replaceMap += \"B\" -> \"b\"\n\
    \        replaceMap += \"C\" -> \"c\"\n        replaceMap += \"D\" -> \"d\"\n\
    \        replaceMap += \"E\" -> \"e\"\n        replaceMap += \"F\" -> \"f\"\n\
    \        replaceMap += \"G\" -> \"g\"\n        replaceMap += \"H\" -> \"h\"\n\
    \        replaceMap += \"I\" -> \"i\"\n        replaceMap += \"J\" -> \"j\"\n\
    \        replaceMap += \"K\" -> \"k\"\n        replaceMap += \"L\" -> \"l\"\n\
    \        replaceMap += \"M\" -> \"m\"\n        replaceMap += \"N\" -> \"n\"\n\
    \        replaceMap += \"O\" -> \"o\"\n        replaceMap += \"P\" -> \"p\"\n\
    \        replaceMap += \"Q\" -> \"q\"\n        replaceMap += \"R\" -> \"r\"\n\
    \        replaceMap += \"S\" -> \"s\"\n        replaceMap += \"T\" -> \"t\"\n\
    \        replace", "        val lowercase = message.toLowerCase\n        val vowels\
    \ = mutable.Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n        val translated = mutable.Set[String]()\n\
    \        for(letter <- lowercase){\n            if(vowels.contains(letter)){\n\
    \                translated += translateLetter((letter + vowels.size - 1) % vowels.size)\n\
    \            }\n            else {\n                translated += translateLetter(letter)\n\
    \            }\n        }\n        translated.toString.toUpperCase", "      val\
    \ lowercase = message.toLowerCase\n      val vowels = mutable.Set(\"a\", \"e\"\
    , \"i\", \"o\", \"u\", \"y\")\n      val alphabet = mutable.List(\"a\", \"b\"\
    , \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\")\n      val alphabetLetters: Array[String] = alphabet.toArray\n\
    \      val alphabetIndex: Array[Int] = alphabet.toArray.zipWithIndex.toArray\n\
    \      val vowelIndex: Array[Int] = vowels.toArray.zipWithIndex.toArray\n    \
    \  var messageIndex : Int = 0\n      var newMessageIndex : Int = 0\n      \n \
    \     lowercase.foldLeft(\"\"){ \n        case(\"\", messageIndex) => (messageIndex\
    \ % 26).toChar + alphabetLetters((messageIndex / 26) - 1) \n      }\n      \n\
    \      val alphabetLettersLength: Int = alphabetLetters.length\n      val vowelsLength:\
    \ Int = vowels.length\n      \n      lowercase.foldLeft(\"\"){ \n        case(\"\
    \", messageIndex) => (messageIndex % 26).toChar + alphabetLetters((messageIndex\
    \ / 26) - 1) \n      }\n      \n      for(i <- 0 until message.length){\n    \
    \    newMessageIndex = \n          if(vowels(messageIndex) ne \"y\") \n      \
    \    vowelIndex(alphabetIndex(messageIndex)) else\n          vowelIndex(alphabetIndex(messageIndex\
    \ + 1))\n          \n        if(messageIndex == 0){\n          newMessageIndex\
    \ = 26\n          messageIndex = newMessageIndex\n          messageIndex % = 1\n\
    \          messageIndex = messageIndex.abs % 26\n        } else {\n          messageIndex\
    \ = newMessageIndex\n          messageIndex % = 1\n        }\n        \n     \
    \   newMessageIndex = \n          if(vowels(messageIndex) ne \"y\") \n       \
    \   vowelIndex(alphabetIndex(messageIndex)) else\n          vowelIndex(alphabetIndex(messageIndex\
    \ - 1))\n          \n        if(messageIndex == 0){\n          newMessageIndex\
    \ = 26\n          messageIndex = newMessageIndex\n          messageIndex % = 1\n\
    \          messageIndex = messageIndex.abs % 26\n        } else {\n          messageIndex\
    \ = newMessageIndex\n          messageIndex % = 1\n        }\n      }", "    \
    \    // TODO: Write your implementation here. \n        \"\"", "        var result\
    \ = \"\"\n        for (i <- 0 until message.length)\n            result += swapCase(message(i))\
    \ + swapCase(message.charAt(i + 1)) + \n                swapCase(message.charAt(i\
    \ + 2)) + swapCase(message.charAt(i + 3))\n        result", "         val vowel\
    \ = \"AEIOUaeiou\"\n         val alphabet = message.toCharArray\n         val\
    \ messageLength = alphabet.length\n         var index = messageLength\n      \
    \   var outputMessage = message\n\n         while(index >= 0) {\n            var\
    \ newPosition = index\n            var newOutput = outputMessage\n           \
    \ while(newPosition >= 0) {\n               val ch = alphabet(newPosition)\n \
    \              val upperCase = if (ch >= 'A' && ch <= 'Z') ch - ('A' - 'a') else\
    \ ch\n               val lowerCase = if (ch >= 'a' && ch <= 'z') ch - ('a' - 'A')\
    \ else ch\n               val newChar = if (upperCase == lowerCase) upperCase\
    \ else lowerCase\n               newOutput = newOutput.replaceAll(vowel, newChar)\n\
    \               newPosition -= 1\n            }\n            outputMessage = newOutput\n\
    \            index -= 1\n         }\n         outputMessage\n      }\n   }\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=scala |>\nHere's a solution using your initial solution\
    \ with a slight twist - it uses the fact that all characters in the English alphabet\
    \ have an offset of 0, and that every vowel has an offset of 1.\n<code>\ndef convert(message:\
    \ String): String = {\n  val vowel = \"AEIOUaeiou\".toCharArray\n  val alphabet\
    \ = message.toCharArray\n  val messageLength = alphabet.length\n  var index =\
    \ messageLength\n  var outputMessage = message\n\n  while (index >= 0) {\n   \
    \ val newPosition = index\n    val newOutput = outputMessage\n    while (newPosition\
    \ >= 0) {\n      val ch = alphabet(newPosition)\n      val upperCase = if (ch\
    \ >= 'A' && ch <= 'Z') ch - ('a' - 'A') else ch\n      val lowerCase = if (ch\
    \ >= 'a' && ch <= 'z') ch - ('a' - 'A') else ch\n      val newChar = if (upperCase\
    \ == lowerCase) upperCase else lowerCase\n      newOutput = newOutput.replaceAll(vowel,\
    \ newChar)\n      newPosition -= 1", '        // Your code here', "        val\
    \ enc = new mutable.ListBuffer[String]()\n        var index = 0\n        for (char1\
    \ <- message) {\n            if (char1.isUpper) {\n                val replacement\
    \ = math.ceil(index/26)\n                enc.append(alphabet(replacement))\n \
    \               index %= 26\n            }\n            enc.append(char1)\n  \
    \      }\n        enc.toString()", "        var result : String = \"\"\n     \
    \   // Create all possible mappings\n        // TODO: write function for all mappings\
    \ \n        // and add them into result with String.format \n        // as done\
    \ in encodeLetter\n        val mappings = (0 to 26).map( x => x -> x % 26 )\n\
    \        val allMappings : mutable.Map[String, String] = mutable.Map(\n      \
    \      \"A\"->\"B\",\n            \"B\"->\"C\",\n            \"C\"->\"D\",\n \
    \           \"D\"->\"E\",\n            \"E\"->\"F\",\n            \"F\"->\"G\"\
    ,\n            \"G\"->\"H\",\n            \"H\"->\"I\",\n            \"I\"->\"\
    J\",\n            \"J\"->\"K\",\n            \"K\"->\"L\",\n            \"L\"\
    ->\"M\",\n            \"M\"->\"N\",\n            \"N\"->\"O\",\n            \"\
    O\"->\"P\",\n            \"P\"->\"Q\",\n            \"Q\"->\"R\",\n          \
    \  \"R\"->\"S\",\n            \"S\"->\"T\",\n            \"T\"->\"U\",\n     \
    \       \"U\"->\"V\",\n            \"V\"->\"W\",\n            \"W\"->\"X\",\n\
    \            \"X\"->\"Y\",\n            \"Y\"->\"Z\",\n            \"Z\"->\"0\"\
    \n        )\n        // Iterate all mappings, swap case and replace all vowels\
    \ with \n        // the letter that appears 2 places ahead of the vowel \n   \
    \     mappings.foreach( ( (key, value) ) => {\n            val newValue = allMappings(key)\n\
    \            val newCase = key.toUpperCase\n            val newString = (newCase\
    \ + newValue).replaceAll(findVowel(newValue), value)\n            result += newString\n\
    \        })\n        result", "        // write code here\n        val newMessage\
    \ = message.toLowerCase\n        val vowels = \"aeiouAEIOU\"\n        val charArray\
    \ = Array(vowels, newMessage)\n        val pairs = charArray.toSet\n        val\
    \ pairArray = pairs.toArray\n        val pairSet = mutable.HashSet[Pair[String,\
    \ String]]()\n        pairArray.foreach{pair => pairSet += pair}\n        val\
    \ vowelSet = mutable.HashSet[String]()\n        pairSet.foreach{pair => vowelSet\
    \ += pair.left}\n        val newMessageToEncode = newMessage.toUpperCase\n   \
    \     val newMessageWithVowelsSwapped = newMessageToEncode.replaceAll(vowels,\
    \ \"\")\n        val pairArray = Array(vowelSet, newMessageWithVowelsSwapped)\n\
    \        val pairSet = mutable.HashSet[Pair[String, String]]()\n        pairArray.foreach{pair\
    \ => pairSet += pair}\n        val pairSetArray = pairSet.toArray\n        val\
    \ pairArray = pairSetArray.toSet\n        val pairArray = pairArray.toSet\n  \
    \      val pairSet = mutable.HashSet[Pair[String, String]]()\n        pairArray.foreach{pair\
    \ => pairSet += pair}\n        val pairSetArray = pairSet.toArray\n        val\
    \ pairArray = pairSetArray.toSet\n        val pairArray = pairArray.toSet\n  \
    \      val pairArray = pairArray.toSet\n        val pairArray = pairArray.toSet\n\
    \        val pairArray = pairArray.toSet\n        val pairArray = pairArray.toSet\n\
    \        val pairArray = pairArray.toSet\n        val pairArray = pairArray.toSet\n\
    \        val pairArray = pairArray.toSet\n        val pairArray = pairArray.toSet\n\
    \        val pairArray = pairArray.toSet\n        val pairArray = pairArray.toSet\n\
    \        val pairArray = pairArray.toSet\n        val pairArray = pairArray.toSet\n\
    \        val pairArray = pairArray.toSet\n        val pairArray = pairArray.toSet\n\
    \        val pairArray = pairArray.toSet\n        val pairArray = pairArray.toSet\n\
    \        val pairArray = pairArray.toSet\n        val pairArray = pairArray.toSet\n\
    \        val pairArray = pairArray.toSet\n        val pairArray = pairArray.toSet\n\
    \        val pairArray = pairArray.toSet\n        val pairArray = pairArray.toSet\n\
    \        val pair", "        val alphabet = List(\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n \
    \       var result = \"\"\n        for (c <- message) {\n            val index\
    \ = alphabet.indexOf(c)\n            if (index != -1)\n                result\
    \ = result + alphabet(index - 2)\n        }\n        \n        val vowels = \"\
    aeiou\"\n        for (c <- message.split(\"\")) {\n            val index = vowels.indexOf(c)\n\
    \            if (index != -1)\n                result = result + alphabet(index)\n\
    \        }\n        \n        result", "        val result = new StringBuilder\n\
    \        var vowels = \"\"\n        for (c <- message) {\n            if (c.toUpper\
    \ == 'A')\n                vowels = c\n            else \n                if (vowels.length\
    \ <= 1)\n                    result.append(vowels)\n                else\n   \
    \                 result.append(vowels.charAt(2))\n                vowels = \"\
    \"\n            result.append(c.toUpper)\n        }\n        result", '        //your
    code goes here', "        var message : String = \"\"\n        var index = 0\n\
    \        while (index <= message.length) {\n            var letter = message.charAt(index)\n\
    \            var vowelCount = message.count(letter)\n            if (vowelCount\
    \ > 1) {\n                var currentVowel = letter // keep this in case you want\
    \ to use later\n                message += currentVowel\n                message\
    \ += letter // add the first vowel to the message\n                for (i <- 1\
    \ to vowelCount) {\n                    // now look for the 2nd vowel before this\
    \ one in the alphabet\n                    currentVowel = message.charAt(index\
    \ + i)\n                    // if it exists, replace it with the letter that appears\
    \ 2 places before\n                    // this vowel\n                    if (currentVowel\
    \ == 'e' || currentVowel == 'i' || currentVowel == 'o' || currentVowel == 'u')\
    \ {\n                        message += alphabet(currentVowel)\n             \
    \       } else {\n                        message += currentVowel\n          \
    \          }\n                }\n            } else {\n                message\
    \ += letter\n            }\n            index += 1\n        }\n        message",
  "        val chars = message.map(c => (c.toUpperCase))\n        val vowels = mutable.List(\"\
    A\", \"E\", \"I\", \"O\", \"U\")\n        val vowelChars = mutable.List(\"A\"\
    , \"E\", \"I\", \"O\", \"U\")\n        val resultList = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until message.length) {\n            val subMessage = message.substring(0,\
    \ i)\n            val subChars = subMessage.map(c => (c.toUpperCase))\n      \
    \      for(j <- 0 until vowels.length) {\n                val vowel = vowels(j)\n\
    \                val vowelChar = vowelChars(j)\n                if(vowel.isDefined)\
    \ {\n                    if(subChars.contains(vowel)) {\n                    \
    \    resultList += subChars.take(vowel.asInstanceOf[Int]).mkString(vowelChar)\n\
    \                    }\n                }\n            }\n            resultList\
    \ += subMessage.substring(i, i+1)\n        }\n        resultList.mkString", '        //
    TODO: Write code here!', "        val swap = (x: Char) => if(x == 'a') 'b' else\
    \ 'a'\n        val replaceVowel = (x: Char) => if(x == 'a') 'z' else 'a'\n   \
    \     val mapVowels = (x : Char) => {\n            val y = x.toUpperCase()\n \
    \           if(y == \"AEIOU\") \"V\"\n            else y\n        }\n        val\
    \ mapLetters = (x : Char) => {\n            val y = x.toUpperCase()\n        \
    \    if(y == \"QWERTYUIO\") \"L\"\n            else y\n        }\n        val\
    \ mapVowelsAndLetters = (x : Char) => {\n            val y = x.toUpperCase()\n\
    \            if(y == \"AEIOU\") \"Z\"\n            else y\n        }\n       \
    \ val mapLettersAndVowels = (x : Char) => {\n            val y = x.toUpperCase()\n\
    \            if(y == \"QWERTYUIO\") \"L\"\n            else y\n        }\n   \
    \     val vowels = message.map(_).toSet\n        val letters = message.map(_).toSet\n\
    \        var result = \"\"\n        for(x <- message) {\n            result +=\
    \ (if(x != 'a') x else swap(x))\n        }\n        for(x <- letters) {\n    \
    \        result += (if(vowels.contains(x)) mapVowels(x) \n            else mapLetters(x))\n\
    \        }\n        for(x <- vowels) {\n            result += (if(vowels.contains(x))\
    \ mapVowelsAndLetters(x) \n            else mapLettersAndVowels(x))\n        }\n\
    \        return result", "        val messages = message.split(\"\\\\s+\") //\
    \ split into individual words\n        val result = new StringBuilder(messages.length\
    \ * 3 + \"T\")\n\n        for(i <- 0 until messages.length)\n            result.append(message(i)).append(i)\n\
    \        for(i <- 0 until messages.length)\n            result.append(message(i)).append(i\
    \ - 1)\n        return result.toString()", "        message.foldLeft(\"\")((accum,\
    \ char) =>\n            char.map {\n                case c if (c.isUpper) => (c\
    \ + (alphabet.indexOf((alphabet.indexOf(c) + 2).asInstanceOf[Char]))).asInstanceOf[Char]\n\
    \                case c if (c.isUpper) => alphabet.indexOf((alphabet.indexOf(c)\
    \ + 1).asInstanceOf[Char])\n                case c if !c.isUpper => c\n      \
    \      }.foldLeft(accum.concat(char))((accum, char) => accum ++ char))", "   \
    \     val list = message.toList\n        val swapped = list.map(x => (if (x.toUpper\
    \ == \"A\") \"Z\" else \"A\") + x).map(x => x.drop(1)).map(x => x.take(1) + x.drop(1))\n\
    \        val vowels = scala.collection.mutable.Set(\"A\", \"E\", \"I\", \"O\"\
    , \"U\", \"a\", \"e\", \"i\", \"o\", \"u\", \"y\")\n        swapped ++ vowels.map(x\
    \ => swapped.indexWhere(_ == x))", "        val alphabet = scala.collection.mutable.Set(\"\
    a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"\
    n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\")\n\
    \        val vowels = scala.collection.mutable.Set(\"a\",\"e\",\"i\",\"o\",\"\
    u\")\n        val message = message.toLowerCase\n        val result = new StringBuilder()\n\
    \        var counter = 0\n        while (counter < message.length)\n        {\n\
    \            val c = message.charAt(counter)\n            if (alphabet.contains(c))\n\
    \            {\n                alphabet.remove(c)\n                result.append(alphabet)\n\
    \                counter += 1\n            }\n            else if (vowels.contains(c))\n\
    \            {\n                val pos = alphabet.indexOf(c) + 1\n          \
    \      result.append(alphabet.substring(pos, pos))\n                counter +=\
    \ 1\n            }\n            else\n            {\n                result.append(c)\n\
    \                counter += 1\n            }\n        }\n        return result.toString",
  "        var msgChars = mutable.ArrayBuffer(message.toLowerCase.map(_.toChar))\n\
    \        var encoded = \"\"\n        var vowels = \"aeiou\"\n        for(i <-\
    \ 1 to message.length-1){\n            val firstVowel = msgChars.head.indexOfAt(vowels,\
    \ 0)\n            val secondVowel = msgChars.head.indexOfAt(vowels, 1)\n     \
    \       val firstLetter = msgChars.head.charAt(firstVowel)\n            val secondLetter\
    \ = msgChars.head.charAt(secondVowel)\n            msgChars = msgChars.tail.take(2).flatMap(x\
    \ => ArrayBuffer(x.charAt(0), x.charAt(1))).distinct\n            encoded += firstLetter\
    \ + secondLetter\n        }\n        encoded", "        val replaced = message.toLowerCase\
    \ \n        val chars = mutable.ListBuffer.empty[Char]\n        var currentIndex\
    \ = 0\n        var currentLetter = replaced.charAt(currentIndex)\n        while\
    \ (currentIndex < replaced.length) {\n            val nextLetter = replaced.charAt(currentIndex\
    \ + 1)\n            if (currentLetter == 'A' || currentLetter == 'E' || \n   \
    \             currentLetter == 'I' || currentLetter == 'O' || \n             \
    \   currentLetter == 'U' || currentLetter == 'a'){\n                if (nextLetter\
    \ == 'A' || nextLetter == 'E' || \n                    nextLetter == 'I' || nextLetter\
    \ == 'O' || \n                    nextLetter == 'U' || nextLetter == 'a'){\n \
    \                   chars.append(nextLetter)\n                } else {\n     \
    \               chars.append(currentLetter)\n                }\n             \
    \   currentIndex += 1\n                currentLetter = replaced.charAt(currentIndex)\n\
    \            } else if (currentLetter == 'B' || currentLetter == 'C' || \n   \
    \             currentLetter == 'D' || currentLetter == 'F' || \n             \
    \   currentLetter == 'G' || currentLetter == 'h' || \n                currentLetter\
    \ == 'j' || currentLetter == 'k' || \n                currentLetter == 'l' ||\
    \ currentLetter == 'm' || \n                currentLetter == 'n' || currentLetter\
    \ == 'p' || \n                currentLetter == 'q' || currentLetter == 'r' ||\
    \ \n                currentLetter == 's' || currentLetter == 't' || \n       \
    \         currentLetter == 'v' || currentLetter == 'w' || \n                currentLetter\
    \ == 'y') {\n                if (nextLetter == 'B' || nextLetter == 'C' || \n\
    \                    nextLetter == 'D' || nextLetter == 'F' || \n            \
    \        nextLetter == 'G' || nextLetter == 'h' || \n                    nextLetter\
    \ == 'j' || nextLetter == 'k' || \n                    nextLetter == 'l' || nextLetter\
    \ == 'm' || \n                    nextLetter == 'n' || nextLetter == 'p' || \n\
    \                    nextLetter == 'q' || nextLetter == 'r' || \n            \
    \        nextLetter == 's' || nextLetter == 't' || \n                    nextLetter\
    \ == 'v' || nextLetter == 'w' || \n                    nextLetter == 'y'){\n \
    \                   chars.append(nextLetter)\n                } else {\n     \
    \               chars.append(currentLetter)\n                }\n             \
    \   currentIndex += 1\n                currentLetter = replaced.charAt(currentIndex)\n\
    \            } else if (currentLetter == 'C' || currentLetter == 'D' || \n   \
    \             currentLetter == 'F' || currentLetter == 'G' || \n             \
    \   currentLetter == 'h' || currentLetter == 'j' || \n                currentLetter\
    \ == 'k' || currentLetter == 'l' || \n                currentLetter == 'm' ||\
    \ currentLetter == 'n' || \n                currentLetter == 'p' || currentLetter\
    \ == 'q' || \n                currentLetter == 'r' || currentLetter == 's' ||\
    \ \n                currentLetter", "        var buffer = new mutable.StringBuilder()\n\
    \        var pos = 1\n        for(char <- message.toCharArray) {\n           \
    \ if(Character.isLetter(char)) {\n                while(pos < message.length &&\
    \ Character.isLetter(message.charAt(pos))) {\n                    pos = pos +\
    \ 1\n                }\n                buffer.append(message.substring(0,pos)\
    \ + \n                               (if(message.charAt(pos) == 'A') 'B' \n  \
    \                                  else if(message.charAt(pos) == 'E') 'F' \n\
    \                                    else if(message.charAt(pos) == 'I') 'J' \n\
    \                                    else if(message.charAt(pos) == 'O') 'P' \n\
    \                                    else if(message.charAt(pos) == 'U') 'T' \n\
    \                                    else 'A'))\n                buffer.append(message.substring(pos,pos\
    \ + 1))\n                pos = pos + 1\n            }\n        }\n        if(buffer.length()\
    \ > 0)\n            buffer.append(message.substring(0,pos))\n        buffer.toString",
  "        val s = mutable.StringBuilder(message) \n        for(i <- 0 until s.length)\
    \ { \n            val c = s.charAt(i) \n            if( c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c ==\
    \ 'O' || c == 'U' ) {\n                s.insert(i, c.toUpperCase) \n         \
    \   }\n            if( c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ ) {\n                s.insert(i, c.toLowerCase) \n            }\n        }\n\
    \        s.toString()", "        //Define a list that has the english alphabet\
    \ and all vowels\n        var list = List(\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"\
    ,\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\"\
    ,\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"\
    ,\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\"\
    ,\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\")\n        //Define a list that contains\
    \ the vowels in the message\n        var vowels = List(\"a\",\"e\",\"i\",\"o\"\
    ,\"u\")\n        var res = \"\"\n        //Loop through each character in the\
    \ message\n        for (i <- 0 until message.length) {\n            //If the character\
    \ is a vowel\n            if (vowels.contains(message.charAt(i))) {\n        \
    \        //Set the result to an empty string\n                res = \"\"\n   \
    \             //Loop through each character in the english alphabet\n        \
    \        for (j <- 0 until list.length) {\n                    //If the character\
    \ is equal or greater by 2 with the vowel\n                    if (message.charAt(i)\
    \ == list(j)) {\n                        //Add the character at the location j\
    \ + 1 in the result\n                        res += list(j + 1)\n            \
    \        //If the character is equal or less by 2 with the vowel\n           \
    \         } else if (message.charAt(i) < list(j)) {\n                        //Add\
    \ the character at the location j - 2 in the result\n                        res\
    \ += list(j - 2)\n                    }\n                }\n                //Append\
    \ the result to the result\n                res += \" \"\n            } else {\n\
    \                //Append the character to the result\n                res +=\
    \ message.charAt(i)\n            }\n        }\n        //Return the result\n \
    \       res", "        val m = message.toLowerCase().filter(x => x.isLetter)\n\
    \        val a = m.filter(_ == 'a')\n        val b = m.filter(_ == 'b')\n    \
    \    val c = m.filter(_ == 'c')\n        val d = m.filter(_ == 'd')\n        val\
    \ e = m.filter(_ == 'e')\n        val f = m.filter(_ == 'f')\n        val g =\
    \ m.filter(_ == 'g')\n        val h = m.filter(_ == 'h')\n        val i = m.filter(_\
    \ == 'i')\n        val j = m.filter(_ == 'j')\n        val k = m.filter(_ == 'k')\n\
    \        val l = m.filter(_ == 'l')\n        val m = m.filter(_ == 'm')\n    \
    \    val n = m.filter(_ == 'n')\n        val o = m.filter(_ == 'o')\n        val\
    \ p = m.filter(_ == 'p')\n        val q = m.filter(_ == 'q')\n        val r =\
    \ m.filter(_ == 'r')\n        val s = m.filter(_ == 's')\n        val t = m.filter(_\
    \ == 't')\n        val u = m.filter(_ == 'u')\n        val v = m.filter(_ == 'v')\n\
    \        val w = m.filter(_ == 'w')\n        val x = m.filter(_ == 'x')\n    \
    \    val y = m.filter(_ == 'y')\n        val z = m.filter(_ == 'z')\n        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\".toCharArray\n        var c = 0\n \
    \       var i = 2\n        var l = m.size\n        while(i < l) {\n          \
    \  c += m(i).toString.length\n            i += 1\n        }\n        var res =\
    \ \"\"\n        while(c > 0) {\n            if(c % 2 != 0) {\n               \
    \ res += alphabet[c(0) - 1]\n            }\n            c -= 1\n        }\n  \
    \      while(c > 0) {\n            if(c % 2 == 0) {\n                res += alphabet[c(0)\
    \ - 1]\n            }\n            c -= 1\n        }\n        res = res.reverse\n\
    \        res = m.filter(x => !x.isLetter).mkString(\"\") + res\n        res.reverse.mkString(\"\
    \")", "      val messageChars = message.toList\n      val vowels = \"aeiouAEIOU\"\
    .toList\n      val vowelsIndexes = vowels.zipWithIndex.toMap\n      val vowelsAhead\
    \ = \"aeiou\".zipWithIndex.filter(x => x._2 > 0).map(_._1).reverse.map(vowelsIndexes.get).flatten.filter(x\
    \ => x != -1).map(vowelsIndexes.get).flatten.map(x => x + (x-1))\n      val replacementMap\
    \ = vowelsAhead.zip(vowelsIndexes.map(_._2)).groupBy(x => x).mapValues(x => x(0))\n\
    \      messageChars.map( c => replacementMap.get(c).map(_ => c).reduceLeft((x,y)\
    \ => x.toChar + y.toChar) ).mkString", "        val vowels = \"aeiouAEIOU\".toList\n\
    \        val consonants = \"bcdfghjklmnpqrstvwxyz\".toList\n        val vowelsAndConsonants\
    \ = vowels.map(_ -> consonants)\n        val vowelsAndConsonantsMap = vowelsAndConsonants.toMap\n\
    \        val consonantsAndVowels = consonants.map(_ -> vowels)\n        val consonantsAndVowelsMap\
    \ = consonantsAndVowels.toMap\n        val translatedMessage = message.flatMap(chars\
    \ => chars.map(c => (c, consonantsAndVowelsMap(c)))).groupBy(_._2).mapValues(_.map(_._1)).mapValues(_.map(_._2))\n\
    \        val translatedMessageMap = translatedMessage.toMap\n        translatedMessage.map(_.map\
    \ { \n            case \"a\" -> vowelsAndConsonantsMap(\"a\"); \n            case\
    \ \"e\" -> vowelsAndConsonantsMap(\"e\"); \n            case \"i\" -> vowelsAndConsonantsMap(\"\
    i\");\n            case \"o\" -> vowelsAndConsonantsMap(\"o\");\n            case\
    \ \"u\" -> vowelsAndConsonantsMap(\"u\");\n            case \"A\" -> vowelsAndConsonantsMap(\"\
    A\");\n            case \"E\" -> vowelsAndConsonantsMap(\"E\");\n            case\
    \ \"I\" -> vowelsAndConsonantsMap(\"I\");\n            case \"O\" -> vowelsAndConsonantsMap(\"\
    O\");\n            case \"U\" -> vowelsAndConsonantsMap(\"U\");\n            case\
    \ _ -> consonantsAndVowelsMap(_)\n        }).mkString(\"\")", "        val m =\
    \ message\n        val newmessage = m.map(x => x.toLowerCase)\n        val newmessage\
    \ = newmessage.map(x => x.replaceAll(\"a\", \"@\"))\n        val newmessage =\
    \ newmessage.map(x => x.replaceAll(\"A\", \"a\"))\n        val newmessage = newmessage.map(x\
    \ => x.replaceAll(\"b\", \"@\"))\n        val newmessage = newmessage.map(x =>\
    \ x.replaceAll(\"B\", \"b\"))\n        val newmessage = newmessage.map(x => x.replaceAll(\"\
    c\", \"@\"))\n        val newmessage = newmessage.map(x => x.replaceAll(\"C\"\
    , \"c\"))\n        val newmessage = newmessage.map(x => x.replaceAll(\"d\", \"\
    @\"))\n        val newmessage = newmessage.map(x => x.replaceAll(\"D\", \"d\"\
    ))\n        val newmessage = newmessage.map(x => x.replaceAll(\"e\", \"@\"))\n\
    \        val newmessage = newmessage.map(x => x.replaceAll(\"E\", \"e\"))\n  \
    \      val newmessage = newmessage.map(x => x.replaceAll(\"f\", \"@\"))\n    \
    \    val newmessage = newmessage.map(x => x.replaceAll(\"F\", \"f\"))\n      \
    \  val newmessage = newmessage.map(x => x.replaceAll(\"g\", \"@\"))\n        val\
    \ newmessage = newmessage.map(x => x.replaceAll(\"G\", \"g\"))\n        val newmessage\
    \ = newmessage.map(x => x.replaceAll(\"h\", \"@\"))\n        val newmessage =\
    \ newmessage.map(x => x.replaceAll(\"H\", \"h\"))\n        val newmessage = newmessage.map(x\
    \ => x.replaceAll(\"i\", \"@\"))\n        val newmessage = newmessage.map(x =>\
    \ x.replaceAll(\"I\", \"i\"))\n        val newmessage = newmessage.map(x => x.replaceAll(\"\
    j\", \"@\"))\n        val newmessage = newmessage.map(x => x.replaceAll(\"J\"\
    , \"j\"))\n        val newmessage = newmessage.map(x => x.replaceAll(\"k\", \"\
    @\"))\n        val newmessage = newmessage.map(x => x.replaceAll(\"K\", \"k\"\
    ))\n        val newmessage = newmessage.map(x => x.replaceAll(\"l\", \"@\"))\n\
    \        val newmessage = newmessage.map(x => x.replaceAll(\"L\", \"l\"))\n  \
    \      val newmessage = newmessage.map(x => x.replaceAll(\"m\", \"@\"))\n    \
    \    val newmessage = newmessage.map(x => x.replaceAll(\"M\", \"m\"))\n      \
    \  val newmessage = newmessage.map(x => x.replaceAll(\"n\", \"@\"))\n        val\
    \ newmessage = newmessage.map(x => x.replaceAll(\"N", "        if (message.length\
    \ <= 1) message\n        else message(0) match {\n            case 'a' => encode(message.tail.map(_.toLowerCase).getOrElse(\"\
    a\"))\n            case 'e' => encode(message.tail.map(_.toUpperCase).getOrElse(\"\
    e\"))\n            case 'i' => encode(message.tail.map(_.toUpperCase).getOrElse(\"\
    i\"))\n            case 'o' => encode(message.tail.map(_.toLowerCase).getOrElse(\"\
    o\"))\n            case 'u' => encode(message.tail.map(_.toUpperCase).getOrElse(\"\
    u\"))\n            case 'A' => encode(message.tail.map(_.toLowerCase).getOrElse(\"\
    A\"))\n            case 'E' => encode(message.tail.map(_.toUpperCase).getOrElse(\"\
    E\"))\n            case 'I' => encode(message.tail.map(_.toUpperCase).getOrElse(\"\
    I\"))\n            case 'O' => encode(message.tail.map(_.toLowerCase).getOrElse(\"\
    O\"))\n            case 'U' => encode(message.tail.map(_.toUpperCase).getOrElse(\"\
    U\"))\n            case '!' => encode(message.tail.map(_.toLowerCase).getOrElse(\"\
    !\"))\n            case _ => \n                message.zipWithIndex.map { \n \
    \                   case (c, i) => \n                        if(i % 2 != 0) c.toLowerCase\n\
    \                        else c.toUpperCase\n                }.mkString(\"\")\
    \ \n        }", "        val messageWords = message.split(\" \").map(_.toLowerCase).toList\n\
    \        val codeWords = messageWords.map(word => {\n            val codeWord\
    \ = word.map(letter => {\n                val position = letter.toInt - 1\n  \
    \              val codeIndex = math.max(0, position)\n                val codeWord\
    \ = if (codeIndex == 0) letter else codeWord(codeIndex - 1) + letter\n       \
    \         codeWord\n            })\n            codeWord.mkString(\"\")\n    \
    \    })\n        codeWords.mkString(\" \")", "        // Split the message into\
    \ characters\n        val letters = message.chars\n        // Iterate through\
    \ each character and swap case\n        for (c <- letters) {\n            val\
    \ char1 = c.toUpper\n            val char2 = c.toLower\n            val newChar\
    \ = char1.toChar + (2 * char2.toChar)\n            letters = letters.updated(c,\
    \ newChar)\n        }\n        // Combine with vowel\n        letters + \"V\"",
  "        val map = mutable.HashMap.empty[Char, String]\n        for (ch <- message)\
    \ {\n            val mappedChar = ch.toUpperCase\n            val firstLetter\
    \ = mappedChar.charAt(0)\n            val secondLetter = mappedChar.charAt(1)\n\
    \            if (map.contains(firstLetter)) {\n                map += firstLetter\
    \ -> map.get(firstLetter) + secondLetter\n            } else {\n             \
    \   map += firstLetter -> mappedChar\n            }\n        }\n        val result\
    \ = new StringBuilder\n        for (entry <- map.toIterable.sorted) {\n      \
    \      result.append(entry._2)\n            result.append(entry._1)\n        }\n\
    \        return result.toString", "        var result = \"\"\n        for (letter\
    \ <- message) {\n            result += (letter.toString.toLowerCase().replace(vowels,\
    \ \"X\")\n                     + vowels.zip(vowels.tail).map(x => x._1 + \"X\"\
    \ + x._2).mkString(\"\") + letter)\n        }\n        return result", "     \
    \   val newMessage = message.replaceAll(\"\\\\p{L}\", \"\") //remove all letters\
    \ from message\n        newMessage.replaceAll(\"a|e|i|o|u|y\", \"$0\") //replace\
    \ vowels with nothing\n        val alphabet = List(\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    )\n        val newMessageArray = newMessage.split(\"\").toArray\n        val letterCounts\
    \ = mutable.Map[Char,Int]()\n        for (letter <- newMessageArray) {\n     \
    \       if (alphabet.contains(letter)) { //letter exists in alphabet\n       \
    \         if (letterCounts.getOrElse(letter, 0) == 0) letterCounts += (letter\
    \ -> (letterCounts.getOrElse(letter, 0) + 1)) //add first occurrence of this letter\n\
    \                else if (letterCounts.getOrElse(letter, 0) == 2) letterCounts\
    \ += (letter -> (letterCounts.getOrElse(letter, 1) - 1)) //remove second occurrence\
    \ of this letter\n                else {\n                    letterCounts +=\
    \ (letter -> (letterCounts.getOrElse(letter, 0) + 1)) //add second occurrence\
    \ of this letter\n                }\n            }\n        }\n        var res\
    \ = \"\"\n        for (letter <- letterCounts.keys) {\n            res += alphabet.take(letterCounts(letter))(letterCounts(letter))\
    \ + letter\n        }\n        res", "       var result = message\n       val\
    \ vowels = \"aeiouAEIOU\"\n       val aIndex = vowels.indexOf(\"a\")\n       val\
    \ oIndex = vowels.indexOf(\"o\")\n       val uIndex = vowels.indexOf(\"u\")\n\
    \       val resultList = message.split(\"\").map(_.toUpperCase)\n       var count\
    \ = 1\n       val vowelCount = message.split(\"\").count(x => vowels.contains(x))\n\
    \       val vowelIndex = (message.split(\"\").count(x => vowels.contains(x)) to\
    \ vowelCount)\n       val firstVowel = vowelIndex.take(vowelIndex.size +1)\n \
    \      firstVowel.foreach{x =>\n          val firstLetter = message.substring(vowelIndex.indexOf(x)\
    \ + vowelIndex.indexOf(x) + 1,aIndex)\n          val secondLetter = message.substring(vowelIndex.indexOf(x)\
    \ + vowelIndex.indexOf(x) + 1,oIndex)\n          val thirdLetter = message.substring(vowelIndex.indexOf(x)\
    \ + vowelIndex.indexOf(x) + 1,uIndex)\n          result = result.replaceAll(vowels,firstLetter)\n\
    \          result = result.replaceAll(vowels,secondLetter)\n          result =\
    \ result.replaceAll(vowels,thirdLetter)\n          count += 1\n        }\n   \
    \     result = result.replace(\" \",\"\")\n        result = result.toUpperCase\n\
    \        return result + \" \" + count + \" \" + vowelCount + \" \" + vowelIndex.length",
  "        val vowels = \"AEIOU\"\n        val lower = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val vowelIndexes = lower\n            .map(v => (v, vowels.indexOf(v)))\n\
    \            .toMap\n        val message = message.toLowerCase\n        var output\
    \ = new StringBuilder\n        var vowelIndex = 0\n        for (i <- 0 until message.length){\n\
    \            val char = message.charAt(i)\n            // Swap the case of all\
    \ letters in the message\n            var c = char.toLowerCase\n            var\
    \ pos = 0\n            var newChar = char\n            for (j <- 0 until vowelIndexes.length){\n\
    \                val v = vowelIndexes.getOrElse(j,-1)\n                if (v ==\
    \ pos && newChar.equals(vowels)){\n                    newChar = vowels.charAt(v)\n\
    \                }\n                pos = v\n            }\n            output\
    \ += newChar\n            vowelIndex += 1\n        }\n        return output.toString",
  "        val alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        val vowels = \"\
    AEIOU\"\n\n        var newMessage = \"\"\n\n        for (letter <- message) {\n\
    \            val index = alphabet.indexOf(letter)\n            if (index != -1)\
    \ {\n                val letter1 = alphabet(index - 2)\n                val letter2\
    \ = alphabet(index - 1)\n                newMessage += (letter1 + \"2\" + letter2)\n\
    \            } else {\n                newMessage += letter\n            }\n \
    \       }\n        for (v <- vowels) {\n            newMessage = newMessage.replaceAll(v,\
    \ \"a\")\n        }\n        return newMessage", "        var encodedMessage :\
    \ String = \"\"\n        message foreach {\n           letter =>\n           \
    \ if (letter ==='A' || letter ==='a') encodedMessage += \"T\"\n            if\
    \ (letter ==='B' || letter ==='b') encodedMessage += \"K\"\n            if (letter\
    \ ==='C' || letter ==='c') encodedMessage += \"S\"\n            if (letter ==='D'\
    \ || letter ==='d') encodedMessage += \"H\"\n            if (letter ==='E' ||\
    \ letter ==='e') encodedMessage += \"A\"\n            if (letter ==='F' || letter\
    \ ==='f') encodedMessage += \"B\"\n            if (letter ==='G' || letter ==='g')\
    \ encodedMessage += \"V\"\n            if (letter ==='H' || letter ==='h') encodedMessage\
    \ += \"D\"\n            if (letter ==='I' || letter ==='i') encodedMessage +=\
    \ \"E\"\n            if (letter ==='J' || letter ==='j') encodedMessage += \"\
    G\"\n            if (letter ==='K' || letter ==='k') encodedMessage += \"C\"\n\
    \            if (letter ==='L' || letter ==='l') encodedMessage += \"I\"\n   \
    \         if (letter ==='M' || letter ==='m') encodedMessage += \"F\"\n      \
    \      if (letter ==='N' || letter ==='n') encodedMessage += \"J\"\n         \
    \   if (letter ==='O' || letter ==='o') encodedMessage += \"H\"\n            if\
    \ (letter ==='P' || letter ==='p') encodedMessage += \"N\"\n            if (letter\
    \ ==='Q' || letter ==='q') encodedMessage += \"O\"\n            if (letter ==='R'\
    \ || letter ==='r') encodedMessage += \"P\"\n            if (letter ==='S' ||\
    \ letter ==='s') encodedMessage += \"B\"\n            if (letter ==='T' || letter\
    \ ==='t') encodedMessage += \"A\"\n            if (letter ==='U' || letter ==='u')\
    \ encodedMessage += \"H\"\n            if (letter ==='V' || letter ==='v') encodedMessage\
    \ += \"G\"\n            if (letter ==='W' || letter ==='w') encodedMessage +=\
    \ \"V\"\n            if (letter ==='X' || letter ==='x') encodedMessage += \"\
    N\"\n            if (letter ==='Y' || letter ==='y') encodedMessage += \"T\"\n\
    \            if (letter ==='Z' || letter ==='z') encodedMessage += \"K\"\n   \
    \     }\n        encodedMessage", "        val vowel = \"AEIOUaeiou\"\n      \
    \  val replacements = List(\"A\" -> \"E\", \"E\" -> \"A\", \"I\" -> \"O\", \"\
    O\" -> \"I\")\n        val newMessage = for (letter <- message) yield letter match\
    \ {\n            case c if vowel.contains(c) => replacements.getOrElse(c, c)\n\
    \            case c => c\n        }\n        return newMessage", "        val\
    \ messageLength = message.length\n        if (messageLength == 0) {\n        \
    \    \"\"\n        } else {\n            def vowelMap : mutable.Map[String, String]\
    \ = mutable.HashMap(\"a\" -> \"B\", \"e\" -> \"E\", \"i\" -> \"I\", \"o\" -> \"\
    O\", \"u\" -> \"U\", \"y\" -> \"Y\")\n            val mapVowels = message.zip(vowelMap)\n\
    \            def swapChars(s : String) : String = {\n                s.toList.foldLeft(\"\
    \") { (c, c2) =>\n                    if (c != c2._1) {\n                    \
    \    c + \"-\" + c2._2\n                    } else {\n                       \
    \ c\n                    }\n                }\n            }\n            val\
    \ vowelMap2 = mapVowels.toList.zip(mapVowels.toList).map(t => t._1 + t._2).map(swapChars)\n\
    \            val alphabet = Map(1 -> \"A\", 2 -> \"B\", 3 -> \"C\", 4 -> \"D\"\
    , 5 -> \"E\", 6 -> \"F\", 7 -> \"G\", 8 -> \"H\", 9 -> \"I\", 10 -> \"J\", 11\
    \ -> \"K\", 12 -> \"L\", 13 -> \"M\", 14 -> \"N\", 15 -> \"O\", 16 -> \"P\", 17\
    \ -> \"Q\", 18 -> \"R\", 19 -> \"S\", 20 -> \"T\", 21 -> \"U\", 22 -> \"V\", 23\
    \ -> \"W\", 24 -> \"X\", 25 -> \"Y\", 26 -> \"Z\")\n            val alphabet2\
    \ = Map(1 -> \"a\", 2 -> \"b\", 3 -> \"c\", 4 -> \"d\", 5 -> \"e\", 6 -> \"f\"\
    , 7 -> \"g\", 8 -> \"h\", 9 -> \"i\", 10 -> \"j\", 11 -> \"k\", 12 -> \"l\", 13\
    \ -> \"m\", 14 -> \"n\", 15 -> \"o\", 16 -> \"p\", 17 -> \"q\", 18 -> \"r\", 19\
    \ -> \"s\", 20 -> \"t\", 21 -> \"u\", 22 -> \"v\", 23 -> \"w\", 24 -> \"x\", 25\
    \ -> \"y\", 26 -> \"z\")\n            def decode(s2 : String) : String = {\n \
    \               s2.toList.foldLeft(\"\") { (c, c2) => {\n                    if\
    \ (c == \"-\") {\n                        c\n                    } else {\n  \
    \                      val index = c2.toInt - 1\n                        if (alphabet2.containsKey(index))\
    \ {\n                            c + alphabet2(index)\n                      \
    \  } else {\n                            c\n                        }\n      \
    \              }\n                }}\n            }\n            val ", '        //
    Code here', "       message.map(x => x.toUpperCase)\n          .replaceAll(\"\
    [AEIOUaeiou]\",\"\")\n          .replaceAll(\"[aeiou]\",x => x.charAt(0) + x.charAt(1))\n\
    \          .replaceAll(\"[aeiouAEIOU]\",\"\")\n          .toUpperCase", "    \
    \    // Initialize a list to hold the new letters\n        var newLetters : List[String]\
    \ = Nil\n        // Iterate over the message\n        for (i <- 0 until message.length)\
    \ {\n            // If the character is a letter\n            if (Character.isLetter(message.charAt(i)))\
    \ {\n                // Initialize a mutable set to hold the vowels so far\n \
    \               var vowels : mutable.Set[Char] = mutable.Set('a', 'e', 'i', 'o',\
    \ 'u')\n                // Iterate over the vowels, checking each against the\
    \ character\n                for (j <- 0 until vowels.size) {\n              \
    \      // If the vowel is the same as the current character\n                \
    \    if (vowels(j) == message.charAt(i)) {\n                        // Add it\
    \ back to the vowels set\n                        vowels += message.charAt(i +\
    \ 1)\n                    }\n                }\n                // Append the\
    \ vowels to the list\n                newLetters = newLetters :+ vowels.mkString\n\
    \            }\n        }\n        // Return the new letters list\n        newLetters.mkString(\"\
    \")", "        val alphabet = List('a' to 'z', 'A' to 'Z')\n        val vowels\
    \ = List('a', 'e', 'i', 'o', 'u')\n        val replacement = List('b', 'c', 'd',\
    \ 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x',\
    \ 'z')\n        val swapped = message map (ch => \n            if (ch in vowels)\
    \ ch \n            else (if (ch in alphabet) replacement\n                else\
    \ (if (ch == 'a') 'b' \n                    else if (ch == 'e') 'c' \n       \
    \             else if (ch == 'i') 'd' \n                    else if (ch == 'o')\
    \ 'f' \n                    else if (ch == 'u') 'g' \n                    else\
    \ if (ch == 'A') 'B' \n                    else if (ch == 'E') 'C' \n        \
    \            else if (ch == 'I') 'D' \n                    else if (ch == 'O')\
    \ 'F' \n                    else if (ch == 'U') 'G' \n                    else\
    \ (if (ch == 'a') 'h' \n                    else if (ch == 'e') 'j' \n       \
    \             else if (ch == 'i') 'k' \n                    else if (ch == 'o')\
    \ 'l' \n                    else if (ch == 'u') 'm' \n                    else\
    \ if (ch == 'A') 'H' \n                    else if (ch == 'E') 'J' \n        \
    \            else if (ch == 'I') 'K' \n                    else if (ch == 'O')\
    \ 'L' \n                    else if (ch == 'U') 'M' \n                    else\
    \ (if (ch == 'a') 'n' \n                    else if (ch == 'e') 'p' \n       \
    \             else if (ch == 'i') 'q' \n                    else if (ch == 'o')\
    \ 'r' \n                    else if (ch == 'u') 's' \n                    else\
    \ if (ch == 'A') 'N' \n                    else if (ch == 'E') 'P' \n        \
    \            else if (ch == 'I') 'Q' \n                    else if (ch == 'O')\
    \ 'R' \n                    else if (ch == 'U') 'S' \n                    else\
    \ ch)))\n\n        swapped mkString \"\"", "        val vowels = \"AEIOUaeiou\"\
    \n        var msg = \"\"\n        for(i <- 0 until message.length){\n        \
    \    msg += (message(i))\n        }\n        val result = msg.foldLeft(\"\")((a,\
    \ b) => a + b.toLowerCase())\n        val swapped = result.foldLeft((\"\", \"\"\
    ))((a, b) => b + a.replace(vowels, b.toLowerCase))\n        val alphabet = swapped._1\n\
    \        val vowel = swapped._2\n        var currentVowel = \"\"\n        var\
    \ currentLetter = \"\"\n        for(i <- 0 until result.length){\n           \
    \ currentLetter = alphabet(i)\n            if((i + 1) < result.length){\n    \
    \            currentVowel = vowel(i+1)\n            }\n            if(currentVowel\
    \ == \"\"){\n                result += currentLetter\n            }\n        \
    \    if(currentLetter == \"\"){\n                result += currentVowel\n    \
    \        }\n            else{\n                result += currentLetter + vowel(currentVowel.length)\n\
    \            }\n        }\n        result", "        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('e','i','o','u')\n        val messageList = message.split('')\n\
    \        val encoded = new StringBuilder(messageList.length)\n        messageList.foreach(x\
    \ => encoded.append(alphabet.indexOf(x) + vowels.indexOf(x)).asInstanceOf[String])\n\
    \        encoded.toString()", "        val result = new StringBuilder()\n    \
    \    val vowels = \"aeiou\"\n        for (i <- 0 to message.length - 1){\n   \
    \         val currentChar = message.charAt(i)\n            if (vowels.contains(currentChar))\
    \ {\n                val nextChar = message.charAt(i+1)\n                val replacement\
    \ = nextChar + Character.toUpperCase(currentChar) - Character.toUpperCase(nextChar)\n\
    \                result.append(replacement)\n                i = i + 2\n     \
    \       }\n            result.append(currentChar)\n        }\n        return result.toString()",
  "        val alphabet = message.map(c => c.toUpperCase()).map(c => c.toLowerCase\
    \ + (if (c =:= \"a\") \"n\" else \"A\"))\n        val vowels = \"AEIOU\"\n   \
    \     val encodedMessage = mutable.ArrayBuffer.empty[Char]\n        for (i <-\
    \ 0 until message.length)\n        {\n            val letter = message(i)\n  \
    \          for (j <- 0 until vowels.length)\n            {\n                if\
    \ (vowels(j) == letter)\n                {\n                    encodedMessage\
    \ += alphabet(j)\n                }\n            }\n            encodedMessage\
    \ += letter\n        }\n        encodedMessage.toString.toLowerCase()", "    \
    \    val alphabet = new mutable.LinkedHashSet[Char](\"abcdefghijklmnopqrstuvwxyz\"\
    .toCharArray)\n        val vowels = new mutable.LinkedHashSet[Char](\"aeiou\"\
    .toCharArray)\n        val twoLetters = new mutable.LinkedHashSet[Char](\"bcdfghjklmnpqrstvwxyz\"\
    .toCharArray)\n        val swap = new mutable.LinkedHashSet[Char]()\n        val\
    \ newMessage = new mutable.LinkedHashSet[Char]()\n        val messageLength =\
    \ message.length\n        for(i <- 0 until messageLength){\n            val letter\
    \ = message.charAt(i)\n            val index = alphabet.indexOf(letter)\n    \
    \        if(index != -1){\n                swap.add(index)\n            }else{\n\
    \                val vowel = vowels.indexOf(letter)\n                if(vowel\
    \ != -1){\n                    swap.add(vowel)\n                }else{\n     \
    \               val twoLetter = twoLetters.indexOf(letter)\n                 \
    \   if(twoLetter != -1){\n                        swap.add(twoLetter)\n      \
    \              }else{\n                        newMessage.add(letter)\n      \
    \              }\n                }\n            }\n        }\n        swap.foreach(letter\
    \ => alphabet.add(letter))\n        swap.clear()\n        for(letter <- alphabet){\n\
    \            val index = newMessage.indexOf(letter)\n            if(index != -1){\n\
    \                swap.add(index)\n            }else{\n                newMessage.add(letter)\n\
    \            }\n        }\n        swap.foreach(letter => alphabet.add(letter))\n\
    \        swap.clear()\n        for(letter <- alphabet){\n            val index\
    \ = newMessage.indexOf(letter)\n            if(index != -1){\n               \
    \ swap.add(index)\n            }else{\n                newMessage.add(letter)\n\
    \            }\n        }\n        swap.foreach(letter => alphabet.add(letter))\n\
    \        swap.clear()\n        for(letter <- alphabet){\n            val index\
    \ = newMessage.indexOf(letter)\n            if(index != -1){\n               \
    \ swap.add(index)\n            }else{\n                newMessage.add(letter)\n\
    \            }\n        }\n        swap.foreach(letter => alphabet.add(letter))\n\
    \        swap.clear()\n        for(letter <- alphabet){\n            val index\
    \ = newMessage.indexOf(letter)\n            if(index != -1){\n               \
    \ swap.add(index)\n            }else{\n                newMessage.add(letter)\n\
    \            }\n        }\n        swap.foreach(letter => alphabet.add(letter))\n\
    \        swap.clear()\n        for(letter <- alphabet){\n            val index\
    \ = newMessage.indexOf(letter)\n            if(index != -1){\n               \
    \ swap.add(index)\n            }else{\n                newMessage.add(letter)\n",
  "        // Your code goes here\n        val list = message.split(\" \").toList\n\
    \        var i = 0\n        var newMessage = message\n\n        val vowels = List('a',\
    \ 'e', 'i', 'o', 'u')\n        val result = mutable.ListBuffer.empty[String]\n\
    \        while(i < list.size) {\n            var nextVowel = vowels(i % 6)\n \
    \           if (i + 1 < list.size) {\n                if (vowels(i + (list.size\
    \ - 1)) == nextVowel)\n                    nextVowel = vowels(i + (list.size -\
    \ 2))\n            }\n            val letter = list(i).toChar\n            if\
    \ (vowels.contains(letter))\n                newMessage = newMessage.substring(0,\
    \ i) + nextVowel + newMessage.substring(i + 1).toLowerCase\n            i += 1\n\
    \        }\n        result foreach { x => newMessage = newMessage + x }\n    \
    \    newMessage", "        val l = message.length\n        var i = 0\n       \
    \ var j = 0\n        var k = 0\n        var a = 0\n        var str = \"\"\n  \
    \      while (i < l) {\n            str += message.charAt(i)\n            i +=\
    \ 1\n        }\n        str = str.toUpperCase\n        str = str.replaceAll((\"\
    a\", \"A\"), (\"A\"))\n        str = str.replaceAll((\"e\", \"E\"), (\"E\"))\n\
    \        str = str.replaceAll((\"i\", \"I\"), (\"I\"))\n        str = str.replaceAll((\"\
    o\", \"O\"), (\"O\"))\n        str = str.replaceAll((\"u\", \"U\"), (\"U\"))\n\
    \        str = str.replaceAll((\"y\", \"T\"), (\"T\"))\n        str = str.replaceAll((\"\
    a\", \"A\"), (\"A\"))\n        str = str.replaceAll((\"e\", \"E\"), (\"E\"))\n\
    \        str = str.replaceAll((\"i\", \"I\"), (\"I\"))\n        str = str.replaceAll((\"\
    o\", \"O\"), (\"O\"))\n        str = str.replaceAll((\"u\", \"U\"), (\"U\"))\n\
    \        str = str.replaceAll((\"y\", \"T\"), (\"T\"))\n        str = str.replaceAll((\"\
    1\", \"!\"), (\"!\"))\n        str = str.replaceAll((\"2\", \"!\"), (\"!\"))\n\
    \        str = str.replaceAll((\"3\", \"!\"), (\"!\"))\n        str = str.replaceAll((\"\
    4\", \"!\"), (\"!\"))\n        str = str.replaceAll((\"5\", \"!\"), (\"!\"))\n\
    \        str = str.replaceAll((\"6\", \"!\"), (\"!\"))\n        str = str.replaceAll((\"\
    7\", \"!\"), (\"!\"))\n        str = str.replaceAll((\"8\", \"!\"), (\"!\"))\n\
    \        str = str.replaceAll((\"9\", \"!\"), (\"!\"))\n        str = str.replaceAll((\"\
    0\", \"!\"), (\"!\"))\n        var j = 0\n        var k = 0\n        var a = 0\n\
    \        while (j < l) {\n            a += 1\n            k = str.indexOf(\"A\"\
    , j)\n            while (k > -1) {\n                val tempStr = str.substring(k,\
    \ k + 2)\n                str = str.substring(0, k) + tempStr + str.substring(k\
    \ + 2)\n                k += 1\n            }\n            j = k\n        }\n\
    \        str += str\n        str", "        def charAtered(c : String) : Int =\
    \ {\n            c match {\n                case letter if letter.isLetter =>\
    \ \n                    c.toInt.toChar\n                case _ => 0\n        \
    \    }\n        }\n        val newMessage = message.toList\n        val newMessageToSwap\
    \ = newMessage.map(c => charAtered(c) - charAtered(c.charAt(0)))\n        val\
    \ vowels = List('a', 'e', 'i', 'o', 'u')\n        val newMessageToChange = newMessageToSwap.map(c\
    \ => vowels.indexOf(c))\n        newMessageToChange.zip(vowels).map(c => (c().toInt\
    \ - c().toInt.toChar))\n        newMessageToChange.zipWithIndex.map { case (c,\
    \ index) => \n            index match {\n                case 0 => c.toChar\n\
    \                case 1 => c.toChar\n                case 2 => c.toChar\n    \
    \            case 3 => c.toChar\n                case 4 => c.toChar\n        \
    \        case 5 => c.toChar\n                case 6 => c.toChar\n            \
    \    case 7 => c.toChar\n                case _ => c.toChar\n            }\n \
    \       }.mkString(\"\")", "        val vowels = \"aeiouAEIOU\".toList.map(_.toLowerCase())\n\
    \        val vowelMap: mutable.Map[String, String] = mutable.HashMap.empty[String,\
    \ String]\n        vowels.foreach(vowelMap add _)\n        message.foldLeft(\"\
    \") { (result, x) => \n            val before = result.head\n            val beforeVowel\
    \ = before.toLowerCase \n            val afterVowel = vowelMap.get(beforeVowel)\
    \ \n            val after = afterVowel match {\n                case Some(afterVowel)\
    \ => after.head\n                case None => x\n            }\n            result\
    \ += after\n        }", "         // Write your code here\n         val vowels\
    \ = List('a','e','i','o','u')\n         val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \         val lowerMessage = message.toLowerCase()\n         val newMessage =\
    \ lowerMessage.foldLeft(\"\")( (res, letter) => res + letter.charAt(1) + alphabet.indexOf(letter.charAt(2))\
    \ + alphabet.indexOf(letter.charAt(3)) + alphabet.indexOf(letter.charAt(4)) +\
    \ alphabet.indexOf(letter.charAt(5)) + alphabet.indexOf(letter.charAt(6))) \n\
    \         newMessage\n         }\n}\n</code>\nI solved this problem in a very\
    \ convoluted manner, first I thought the problem was coming from my logic in the\
    \ fold, which I did not understand. But I realized that the problem was coming\
    \ from my code in the foldLeft, as I was not using the accumulator correctly.\n\
    Here is what my code does:\n<code>\nval lowerMessage = message.toLowerCase()\n\
    </code>\nThis line takes the string message, and makes it lower case, so that\
    \ we can use it to check the characters in the english alphabet. We will do this\
    \ later in the function.\n<code>\nval newMessage = lowerMessage.foldLeft(\"\"\
    )( (res, letter) => res + letter.charAt(1) + alphabet.indexOf(letter.charAt(2))\
    \ + alphabet.indexOf(letter.charAt(3)) + alphabet.indexOf(letter.charAt(4)) +\
    \ alphabet.indexOf(letter.charAt(5)) + alphabet.indexOf(letter.charAt(6))) \n\
    </code>\nfoldLeft is used to go through the string, starting with a blank (\"\"\
    ). \nThe first argument is the initial value of the accumulator variable, (the\
    \ blank). \nThe second argument is the function that will run to update the accumulator\
    \ value for each character in the string in the foldLeft. The first argument is\
    \ a character in the string, and the second is the current accumulator. \nThe\
    \ function will take the letter as a parameter and concatenate it to the accumulator\
    \ variable with the position of the corresponding character in the english alphabet.\
    \ \nI understand how foldLeft works. But how does the second argument work? When\
    \ we call foldLeft, the second argument is (acc, letter) => res + letter.charAt(1)\
    \ + alphabet.indexOf(letter.charAt(2)) + alphabet.indexOf(letter.charAt(3)) +\
    \ alphabet.indexOf(letter.charAt(4)) + alphabet.indexOf(letter.charAt(5)) + alphabet.indexOf(letter.charAt(6))\n\
    acc is the initial value of the accumulator variable. Lets take a look at the\
    \ first character in the string. \nLets say that the current character ", "  \
    \      val newMessage = message.replace(\" \", \"\")\n        val vowels = Array(\"\
    a\", \"e\", \"i\", \"o\", \"u\")\n        val chars = newMessage.toCharArray\n\
    \        chars.foreach {\n            char =>\n            val pos = chars.indexOf(char)\
    \ + 1\n            chars.updated(pos, chars.apply(pos))\n        }\n        chars.toList.map\
    \ {\n            char => vowels.indexOf(char) + vowels.indexOf(char) + 1\n   \
    \     }.toList.zipWithIndex.map {\n            pair =>\n            val i = pair._2\n\
    \            val firstChar = chars(i)\n            val secondChar = chars(i +\
    \ 1)\n            firstChar + secondChar\n        }.mkString", "        val alphabet\
    \ = Array(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"\
    l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"\
    y\",\"z\")\n        val vowels = Array(\"a\",\"e\",\"i\",\"o\",\"u\",\"y\",\"\
    A\",\"E\",\"I\",\"O\",\"U\",\"Y\")\n        val swapped = message.map { x =>\n\
    \            if (x == x.toUpperCase())\n                x.toUpperCase\n      \
    \      else if (x == x.toLowerCase())\n                x.toLowerCase\n       \
    \     else \n                x.toUpperCase\n        }\n        val result = swapped\
    \ flatMap { x =>\n            x.toCharArray.toList map (x => (x -> alphabet.indexOf(x.toLowerCase)\
    \ - vowels.indexOf(x.toLowerCase).toInt)).toMap\n        }.map { x => alphabet(x._1)\
    \ + x._2 }.mkString(\"\")", "        val charSet = scala.collection.mutable.HashSet[String](\n\
    \            \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\",\n \
    \           \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"\
    D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\",\n        \
    \    \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"\
    X\", \"Y\", \"Z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\",\n            \"6\"\
    , \"7\", \"8\", \"9\"\n        )\n\n        for (c <- message) {\n           \
    \ if (charSet.contains(c)) {\n                charSet += c\n            }\n  \
    \      }\n\n        val vowels = scala.collection.mutable.HashSet[String](\n \
    \           \"a\", \"e\", \"i\", \"o\", \"u\"\n        )\n\n        val messageToEncode\
    \ = message.toString.replaceAll(\"[^a-zA-Z]\", \"\")\n\n        // Now replace\
    \ vowels with letters 2 places ahead of them in the alphabet\n        for (v <-\
    \ vowels) {\n            messageToEncode = messageToEncode.replaceAll(v, v.substring(0,\
    \ 2))\n        }\n\n        charSet.toString + messageToEncode", "        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val encodedString = message.map(letter\
    \ => \n            val index = alphabet.indexOf(letter)\n            if (index\
    \ > 0) \n                alphabet(index - 1)\n            else letter\n      \
    \  ).mkString\n        encodedString", "        var message = message\n      \
    \  var result = \"\"\n        for (i <- 0 until message.length){\n           \
    \ var pos = message.indexOf(i)\n            if (pos !=0){\n                result\
    \ += message.charAt(pos-1)\n                if (message.charAt(pos)==\"a\"){\n\
    \                    result += message.charAt(pos + 1)\n                }\n  \
    \              result += message.charAt(pos)\n            }\n        }\n     \
    \   result", '        // Your code goes here', "        var ret = \"\"\n     \
    \   for (i <- 0 until message.length) {\n            val currentChar = message.charAt(i)\n\
    \            // if all letters then return\n            if (currentChar <= 'z'\
    \ && currentChar >= 'a') return message\n            // if vowel\n           \
    \ val vowels = \"aeiou\"\n            val index = vowels.indexOf(currentChar)\n\
    \            if (index >= 0) ret += message.charAt(i) \n            else {\n \
    \               // count number of vowels 2 places after\n                val\
    \ c = message.charAt(i) + message.charAt(i + 1)\n                if (c >= 'a'\
    \ && c <= 'z') ret += c\n                else ret += currentChar\n           \
    \ }\n        }\n        ret", "        val letters = message map (_.toUpperCase)\
    \ toList\n        val vowels = letters.filter(letter => letter.toString.toLowerCase.contains(\"\
    aeiou\"))\n        val reordered = letters.map{letter =>\n          val position\
    \ = vowels.indexOf(letter) + 1\n          val replacement = if (position < 3)\
    \ \"T\" else if (position < 3 and position >= 2) \"G\" else \"C\"\n          letter.replace(letter,\
    \ replacement)\n        }\n        reordered.mkString(\"\")", "        val messageArray\
    \ = message.split(\"\")\n        val encoded = messageArray.foldLeft(List[String]())\
    \ { (list, letter) => \n            val newList = list.toList\n            newList(0)\
    \ = if (newList(0).toChar == 'A')\n                    ('A' + letter).toChar\n\
    \                else if (newList(0).toChar == 'E')\n                    ('E'\
    \ + letter).toChar\n                else if (newList(0).toChar == 'I')\n     \
    \               ('I' + letter).toChar\n                else if (newList(0).toChar\
    \ == 'O')\n                    ('O' + letter).toChar\n                else if\
    \ (newList(0).toChar == 'U')\n                    ('U' + letter).toChar\n    \
    \            else\n                    letter\n            list :+ newList.mkString\n\
    \        }\n        encoded.reverse", "        var index = 0;\n        var result\
    \ = '';\n        for(i <- 0 until message.length){\n            if(message.charAt(i)\
    \ == ' ') {\n                result += ' ';\n                index = i+1;\n  \
    \          } else {\n                result += message.charAt(i).toUpper;\n  \
    \              result += message.charAt(i + 1).toUpper;\n            }\n     \
    \   }\n        index = 0;\n        for(i <- 0 until result.length){\n        \
    \    if(result.charAt(i) == 'A') {\n                result += message.charAt(index).toUpper;\n\
    \                index += 1\n            } else if(result.charAt(i) == 'E') {\n\
    \                result += message.charAt(index).toUpper;\n                index\
    \ += 1\n            } else if(result.charAt(i) == 'I') {\n                result\
    \ += message.charAt(index).toUpper;\n                index += 1\n            }\
    \ else if(result.charAt(i) == 'O') {\n                result += message.charAt(index).toUpper;\n\
    \                index += 1\n            } else if(result.charAt(i) == 'U') {\n\
    \                result += message.charAt(index).toUpper;\n                index\
    \ += 1\n            } else if(result.charAt(i) == 'Y') {\n                result\
    \ += message.charAt(index).toUpper;\n                index += 1\n            }\
    \ else if(result.charAt(i) == 'a') {\n                result += message.charAt(index).toUpper;\n\
    \                index += 1\n            } else if(result.charAt(i) == 'e') {\n\
    \                result += message.charAt(index).toUpper;\n                index\
    \ += 1\n            } else if(result.charAt(i) == 'i') {\n                result\
    \ += message.charAt(index).toUpper;\n                index += 1\n            }\
    \ else if(result.charAt(i) == 'o') {\n                result += message.charAt(index).toUpper;\n\
    \                index += 1\n            } else if(result.charAt(i) == 'u') {\n\
    \                result += message.charAt(index).toUpper;\n                index\
    \ += 1\n            } else if(result.charAt(i) == 'y') {\n                result\
    \ += message.charAt(index).toUpper;\n                index += 1\n            }\
    \ else {\n                result += message.charAt(i)\n            }\n       \
    \ }\n        return result", "        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val messageCopy = message\n\
    \        val messageLengthCopy = messageCopy.length\n        val encoded = mutable.ListBuffer[String]()\n\
    \        var i = 0\n        while (i < messageLengthCopy) {\n            val firstLetter\
    \ = messageCopy(i).toLowerCase()\n            val secondLetter = messageCopy(i+1).toLowerCase()\n\
    \            val encodedLetter = if (alphabet.contains(firstLetter) && alphabet.contains(secondLetter))\
    \ {\n                val pos = alphabet.indexOf(firstLetter)\n               \
    \ alphabet(pos) \n            }\n            else {\n                val pos =\
    \ alphabet.indexOf(firstLetter)\n                alphabet(pos) \n            }\n\
    \            val encodedLetter2 = if (alphabet.contains(firstLetter) && alphabet.contains(secondLetter))\
    \ {\n                val pos2 = alphabet.indexOf(secondLetter)\n             \
    \   alphabet(pos2)\n            }\n            else {\n                val pos2\
    \ = alphabet.indexOf(secondLetter)\n                alphabet(pos2)\n         \
    \   }\n            encoded.append(encodedLetter+secondLetter)\n            i +=\
    \ 2\n        }\n        encoded.toString.replace(\"[\", \"\").replace(\"]\", \"\
    \").replace(\",\", \"\").replace(\"'\", \"\").replace(\"{\", \"\").replace(\"\
    }\", \"\")", "      val vowels = \"AEIOUaeiou\"\n      val newMessage = message.toLowerCase\n\
    \      val newChars = new mutable.ListBuffer[Char]()\n      val numVowels = newMessage.count(vowels)\n\
    \      val vowelIndex = 0\n      val vowelIndexToEncode = numVowels - 1\n    \
    \  val swaps = newMessage.count(c => vowels.indexOf(c) >= 0)\n      val vowelToSwap\
    \ = newMessage.charAt(vowelIndexToEncode)\n      val vowelIndexToSwap = vowelIndexToEncode\
    \ + 1\n\n      for(i <- 0 until newMessage.length)\n        if(vowels.indexOf(newMessage.charAt(i))\
    \ >= 0) {\n          newChars += newMessage.charAt(i)\n          newChars += vowelToSwap\n\
    \          newChars += newMessage.charAt(i)\n          vowelIndex += 1\n     \
    \   } else if(vowels.indexOf(newMessage.charAt(i)) < 0) {\n          newChars\
    \ += newMessage.charAt(i)\n          if(vowelIndex != vowelIndexToSwap) {\n  \
    \          newChars += vowelToSwap\n          }\n          newChars += newMessage.charAt(i)\n\
    \        }\n\n      newChars.mkString"]
stop_tokens:
- "\n    }\n"
