name: HumanEval_68_pluck
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // \"Given a list representing a branch of a tree that has non-negative integer\
  \ nodes\n    // your task is to pluck one of the nodes and return it.\n    // The\
  \ plucked node should be the node with the smallest even value.\n    // If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n    // The plucked node should be returned in a list, [ smalest_value,\
  \ its index ],\n    // If there are no even values or the given list is empty, return\
  \ [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n\
  \    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n\
  \    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n  \
  \  // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
  \ 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0\
  \ is the smallest value, but  there are two zeros,\n    // so we will choose the\
  \ first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <=\
  \ nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long])\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
  \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
  \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
  \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
  \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
  \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
  \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
  \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
  \    }\n\n}\n"
completions: ["        if (arr.isEmpty) List() \n        else {\n            var min\
    \ = arr.head\n            var index = arr.indexOf(min)\n            var minIndex\
    \ = 0\n            while (min % 2 == 0 && index != -1) {\n                min\
    \ += 1\n                index = arr.indexOf(min, index)\n                minIndex\
    \ += 1\n            }\n            return arr.drop(index).toList ++ List(min)\n\
    \        }", "      val m = arr.toMap\n      val ev = m.filter {\n        case\
    \ (v,k) => v % 2 == 0\n      }\n      val min = ev.minBy { case (_,v) => v }.key\n\
    \      ev.filter { case (_,v) => v == min }.keys.toList", "        if(arr.isEmpty)\
    \ List();\n        else {\n            val evens : (Long, Long) = (arr.filter(_%2==0).toList.min,\
    \ arr.minIndex)\n            arr.takeWhile(_%2==0).filter(_%2==0).takeWhile(_\
    \ < evens._1).take(evens._1 - arr.minIndex).sortWith(_ < evens._1).take(1).map(_\
    \ + evens._1)\n        }", "        var res = mutable.ArrayBuffer[Long]()\n  \
    \      var index = 0\n        var minIndex = 0\n        var smallestValue = 0\n\
    \n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0) {\n\
    \                if (smallestValue == 0) {\n                    smallestValue\
    \ = arr(i)\n                    minIndex = i\n                }\n            }\
    \ else if (smallestValue != 0) {\n                if (smallestValue > arr(i))\
    \ {\n                    minIndex = index\n                    smallestValue =\
    \ arr(i)\n                }\n            }\n            index += 1\n        }\n\
    \n        if (smallestValue == 0) {\n            return arr\n        }\n\n   \
    \     res += smallestValue\n        res += minIndex\n        return res.toList",
  "        val map = mutable.Map.empty[Long, Long]\n        for (i <- 0 until arr.length)\
    \ {\n            val currentValue = arr(i)\n            val currentIndex = i\n\
    \            if (map.contains(currentValue)) {\n                val prevIndex\
    \ = map(currentValue)\n                if (prevIndex < currentIndex) {\n     \
    \               map.put(currentValue, currentIndex)\n                }\n     \
    \       }\n            else {\n                map.put(currentValue, currentIndex)\n\
    \            }\n        }\n        val keys = map.keys\n        if (keys.length\
    \ == 0) {\n            return []\n        }\n        if (keys.length == 1) {\n\
    \            return (keys.head, map.getOrElse(keys.head))\n        }\n       \
    \ val minValue = keys.min\n        val minIndex = 0\n        var minEvenIndex\
    \ = false\n        val currentKey = minValue\n        for (i <- 0 until keys.length)\
    \ {\n            if (key(i) == currentKey) {\n                if (i % 2 == 0)\
    \ {\n                    if (minEvenIndex == false) {\n                      \
    \  minEvenIndex = i\n                    }\n                    minEvenIndex =\
    \ true\n                }\n                else {\n                    if (minEvenIndex\
    \ == true && minEvenIndex < i) {\n                        minEvenIndex = i\n \
    \                   }\n                }\n            }\n            else {\n\
    \                if (minEvenIndex == true && minEvenIndex < i) {\n           \
    \         minEvenIndex = i\n                }\n            }\n        }\n    \
    \    (keys.find(_ == minValue).getOrElse(List[Long]()), map(minValue), minEvenIndex)",
  "      if (arr.isEmpty)\n        List[]\n      else if (arr.size < 2)\n        List(arr(0))\n\
    \      else {\n        val (smallest, idx) = arr.minBy(_.toLong) % arr.size\n\
    \        val rem = arr.take(idx)\n        val rem = rem.sortBy(_.toLong).take(2).map\
    \ { case (x, _) => x }\n        rem match {\n          case Nil => Nil\n     \
    \     case x :: xs => List(smallest, idx) :: pluck(xs)\n        }\n      }", " \
    \       val res = new mutable.LinkedList[Long]()\n        val m = arr.size\n \
    \       var min = arr(0)\n        var index = -1\n        for(i <- 0 until m)\
    \ {\n            if(arr(i).toLong % 2 == 0){\n                if(arr(i) > min){\n\
    \                    min = arr(i)\n                    index = i\n           \
    \     }\n            }\n        }\n        if(index < 0){\n            res ++=\
    \ arr\n        }else{\n            res += min\n            res += index\n    \
    \    }\n        res.toList", "        val s = arr.groupBy(x => (x % 2).toInt).mapValues(x\
    \ => x.min.toLong)\n        s.map(x => arr(x._1))", "        var smalest_value\
    \ : Long = -1\n        var smalest_index : Int = -1\n        var index = 0\n \
    \       arr.zipWithIndex.foreach { case (item, index) =>\n            if (item\
    \ > 0 && item % 2 == 0) {\n                if (smalest_value < 0 || smalest_value\
    \ < item) {\n                    smalest_value = item\n                    smalest_index\
    \ = index\n                }\n            }\n        }\n        arr.zipWithIndex.foreach\
    \ { case (item, index) =>\n            if (item > 0 && item % 2 == 0) {\n    \
    \            if (smalest_value < 0 || smalest_value < item) {\n              \
    \      smalest_value = item\n                    smalest_index = index\n     \
    \           }\n            }\n        }\n        if (smalest_value == -1 || arr.isEmpty)\
    \ {\n            return Nil\n        } else {\n            val smalest_node :\
    \ Long = arr[smalest_index]\n            arr.zipWithIndex.foreach { case (item,\
    \ index) =>\n                if (item > 0 && item % 2 == 0) {\n              \
    \      if (smalest_value < 0 || smalest_value < item) {\n                    \
    \    smalest_value = item\n                        smalest_index = index\n   \
    \                 }\n                }\n            }\n            val smalest_node_in_list\
    \ : Long = arr[smalest_index]\n            val smalest_node_in_list_index : Int\
    \ = arr.lastIndexWhere(item => item == smalest_node_in_list)\n            val\
    \ smalest_node_in_list_value : Long = arr[smalest_node_in_list_index]\n      \
    \      return List(smalest_value, smalest_index, smalest_node_in_list_index, smalest_node_in_list_value)\n\
    \        }", "        val arr1 = arr.map(_.toLong)\n        val res = arr1.groupBy(x\
    \ => x % 2)\n        val smallestEvenValue = res.minBy(x => x._1)._1\n       \
    \ val indexes = res.filter(x => x._1 == smallestEvenValue).map(x => x._2)\n  \
    \      val minValue = res.minBy(x => x._1)._2\n        val arr2 = arr1.filter(x\
    \ => x != minValue)\n        if (arr2.isEmpty) {\n            Nil\n        }\n\
    \        else {\n            (smallestEvenValue, indexes)\n        }", "     \
    \   if(arr.isEmpty) {\n            return List.empty\n        }\n        var smallest\
    \ = 0\n        var smallestIndex = 0\n        for(i <- 0 until arr.length) {\n\
    \            if((arr(i) % 2) != 0) {\n                if(smallest != arr(i)) {\n\
    \                    smallest = arr(i)\n                    smallestIndex = i\n\
    \                }\n            }\n        }\n        smallestIndex", "      \
    \  val m = arr.map(_ % 2).toSet\n        val l = arr.size\n        if(l == 0)\
    \ List() else arr.zip(m).foldLeft((0,List())){\n            case ((s, m), i) =>\
    \ if(m) (i.toLong, m) else (s, i+1)\n        }._2.toList", "        val nums =\
    \ arr.map{v =>\n            if(v%2 == 0) v else -1\n        }.toList\n       \
    \ val min_odd = nums.min\n        if(min_odd < 0)\n            return List[]\n\
    \        if(nums.contains(min_odd))\n            return List(min_odd, nums.index(min_odd))\n\
    \        val indexes = nums.zip(nums.drop(1)).filter(x => x._1 % 2 == 0).map{x\
    \ =>\n            if(x._2 > min_odd) x._2 else -1\n        }\n        return List(min_odd,\
    \ indexes.find(x => x >= 0)).getOrElse(List())", "        val result = mutable.ListBuffer.empty[Long]\n\
    \        arr.foreach{node =>\n            arr.foreach{ currNode =>\n         \
    \       if (node % 2 == 0) {\n                    result.add((currNode, currNode\
    \ % 2))\n                }\n            }\n        }\n        if (result.isEmpty)\
    \ {\n            arr.toList\n        } else {\n            val sortedList = new\
    \ Array[Long](result.size)\n            result.toArray.foreach(x => sortedList(x._1)\
    \ = x._2)\n            sortedList\n        }", "        val ans = arr.foldLeft[List[Long]](Nil)((list,e)\
    \ => {\n          val index = list.indexOf(e)\n          index match {\n     \
    \       case -1 => list :+ e\n            case _ =>\n              val minIndex\
    \ = (list.indexOf((e % 2 ==0)) * 2 + 1) max 0\n              list :+ ((e % 2 ==\
    \ 0) ? e : list.take(minIndex).max)\n          }\n        })\n        ans.filter(x\
    \ => x % 2 == 0).map(x => x / 2)", "        var smallest_value : Long = arr(0)\n\
    \        var smallest_index : Int = 0\n        var index : Int = 0\n        var\
    \ i = 0\n        var j = 0\n        var temp_array : List[Long] = arr\n      \
    \  while (i < temp_array.length) {\n            var val : Long = temp_array(i)\n\
    \            if(i+1 < temp_array.length) {\n                val next_val : Long\
    \ = temp_array(i+1)\n                if((val % 2) == 0) {\n                  \
    \  smallest_value = val if (smallest_value < val) else smallest_value\n      \
    \              smallest_index = i+1 if (smallest_value < val) else smallest_index\n\
    \                    val temp = j\n                    for (j <- i+1 until temp_array.length)\
    \ {\n                        temp_array(i) = temp_array(j)\n                 \
    \       temp_array(j) = smallest_value\n                        val temp_val :\
    \ Long = temp_array(j)\n                        if (temp_val < smallest_value)\
    \ {\n                            smallest_value = temp_val\n                 \
    \           smallest_index = temp\n                        }\n               \
    \     }\n                }\n                i+=2;\n            }\n           \
    \ else {\n                smallest_value = val if (smallest_value < val) else\
    \ smallest_value\n                smallest_index = i+1 if (smallest_value < val)\
    \ else smallest_index\n                val temp = j\n                for (j <-\
    \ i+1 until temp_array.length) {\n                    temp_array(i) = temp_array(j)\n\
    \                    temp_array(j) = smallest_value\n                    val temp_val\
    \ : Long = temp_array(j)\n                    if (temp_val < smallest_value) {\n\
    \                        smallest_value = temp_val\n                        smallest_index\
    \ = temp\n                    }\n                }\n            }\n          \
    \  i += 1\n        }\n        val result: List[Long] = temp_array\n        smallest_value\
    \ = temp_array(0)\n        smallest_index = temp_array.indexOf(0)\n        result",
  "        require(arr.nonEmpty, \"arr is empty\")\n        val newArr: List[Long]\
    \ = new mutable.LinkedList[Long]()\n        var index : Int = 0\n        var sum\
    \ : Long = 0\n        for(i <- 0 until arr.length){\n            sum += arr(i)\n\
    \            if (sum % 2 == 0 && sum > 0) {\n                newArr += arr(i)\n\
    \                index += 1\n            }\n        }\n        if (newArr.isEmpty)\
    \ {\n            return []\n        } else {\n            require(index > 0, \"\
    index is zero\")\n            require(index == newArr(0), \"index is zero\")\n\
    \            return newArr\n        }", "        val res = new mutable.ListBuffer[Long]()\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i).isEven) {\n \
    \               res += arr(i)\n                arr.updated(i, arr.delete(i))\n\
    \            }\n        }\n        res.toList", "        val minEven = arr.min(_%2\
    \ == 0).getOrElse(0)\n        val index = arr.indexOf(minEven)\n        val value\
    \ = arr(index)\n        arr.take(index) ++ List(value -> index).filter(identity).map\
    \ {\n            x => (x.get._1, x.get._2)\n        }", "        def checkEven(x\
    \ : Long) : Boolean = {\n            x % 2 == 0\n        }\n        val evens\
    \ = arr.filter(checkEven)\n        var result = (0 until arr.size).foldLeft((arr.size,\
    \ arr.head.asInstanceOf[Long])) { case ((size, i), x) => (x, i) }\n        result\
    \ match {\n            case (_, 0) => List()\n            case (_, 0) => List()\n\
    \            case (size, x) => {\n                if (evens.exists(checkEven))\
    \ {\n                    evens.foldLeft((size, x)) { case ((size, i), x) => {\n\
    \                        if (i % 2 == 0) {\n                            (i, x)\n\
    \                        } else {\n                            (size, x)\n   \
    \                     }\n                    }}\n                } else if (size\
    \ == arr.size) {\n                    (size, x)\n                } else {\n  \
    \                  List()\n                }\n            }\n        }", "   \
    \     var minValue : Long = arr(0).toLong;\n        var minIndex : Int = -1;\n\
    \        var index : Int = -1;\n        var smallestEven : Long = arr(0).toLong\n\
    \        var minIndex : int = -1;\n        for (i <- 0 until arr.length) {\n \
    \           if (arr(i) % 2l == smallestEven) {\n                if (minIndex ==\
    \ -1) {\n                    minIndex = i\n                }\n               \
    \ if (arr(i) < minValue) {\n                    minValue = arr(i)\n          \
    \          minIndex = i\n                }\n            }\n        }\n       \
    \ if (minIndex == -1) {\n            List[Long]()\n        } else {\n        \
    \    List(minValue, minIndex)\n        }", "        val sorted_arr = arr.sorted\n\
    \        val smalest_value = sorted_arr(0)\n        val smallest_index = arr.indexOf(\
    \ smalest_value)\n        if(smallest_index == -1) List()\n        else List(\
    \ smalest_value, smallest_index)", "        var result: List[Long] = Nil\n   \
    \     var maxV = 0\n        var nodeMaxV = 0\n        var maxI = 0\n        var\
    \ nodeMaxI = 0\n        for (i <- 0 until arr.length){\n            val v = arr(i)\n\
    \            if (v > maxV){ maxV = v; maxI = i}\n            if (v >= nodeMaxV){\n\
    \                if (v > nodeMaxV){nodeMaxV = v; nodeMaxI = i}\n            }\n\
    \        }\n        result = (nodeMaxI until arr.length)\n        result.map((x)\
    \ => if (x == maxI) maxV else x).toList", "        def checkNodes(nodes : List[Long],\
    \ index : List[Long]) : List[Long] = {\n            val smalest_value = if (nodes.size\
    \ > 0) nodes.head else 0\n            val smalest_index = if (nodes.size > 0)\
    \ index else 0\n            if (smalest_value == 0l) {\n                List[Long]()\n\
    \            } else if (smalest_value % 2 == 0) {\n                checkNodes(nodes.tail,\
    \ smalest_index::smalest_value)\n            } else {\n                checkNodes(nodes.tail,\
    \ smalest_index)\n            }\n        }\n        checkNodes(arr, 0)", "   \
    \     if (arr.isEmpty) List(-1).toList\n        var smallest_value = arr(0l)\n\
    \        var smallest_index = -1\n        var smallest_index = 0\n        var\
    \ even_value = 0l\n        var i = 0\n        for (i <- arr.indices) {\n     \
    \       if (arr(i).toLong % 2 == 0) {\n                even_value = arr(i)\n \
    \           }\n            if (arr(i) < smallest_value) {\n                smallest_value\
    \ = arr(i)\n                smallest_index = i\n            } else if (arr(i)\
    \ < smallest_value && arr(i).toLong % 2 == 0) {\n                smallest_index\
    \ = i\n            }\n        }\n        if (smallest_index == -1) {\n       \
    \     smallest_index = -1\n        }\n        even_value = even_value.toLong\n\
    \        List(smallest_value, smallest_index).toList", "        val result: List[Long]\
    \ = new mutable.ListBuffer[Long]()\n        arr.foreach{\n          x =>\n   \
    \       if(x % 2 == 0 && x != 0){\n            result += x\n          }\n    \
    \    }\n        arr.size\n        if(result.isEmpty){\n          result.add(0)\n\
    \        }\n        result", "        if (arr.isEmpty) {\n            return List()\n\
    \        }\n        val m = 0l\n        val result = new Array[Long](arr.length)\n\
    \        var i = 0\n        while (i < arr.length) {\n            if (arr(i).mod(2)\
    \ == 0) {\n                m = arr(i)\n                break\n            }\n\
    \            i += 1\n        }\n        var j = 0\n        while (j < arr.length)\
    \ {\n            if (arr(j).mod(2) == 0) {\n                if (m == arr(j)) {\n\
    \                    result(i) = arr(j)\n                } else {\n          \
    \          val temp = m\n                    m = arr(j)\n                    result(i)\
    \ = temp\n                }\n                break\n            }\n          \
    \  j += 1\n        }\n        result", "        val arr = arr.toList.sorted\n\
    \        val even = arr.dropWhile(x => x % 2 == 0).toList\n        if (even.isEmpty)\
    \ arr.toList\n        else even.head", "      val sorted = arr.sorted\n      val\
    \ even = sorted.filter(_ % 2 == 0)\n      val odd  = sorted.filter(_ % 2 != 0)\n\
    \      if (even.isEmpty) odd else even.headOption", "        var evenNum = arr.head\n\
    \        var evenIndex = 0\n        var evenValue = 0\n        var smalest = 0\n\
    \        var smalest_value = 0\n        var smalest_index = 0\n        var i =\
    \ 0\n        var j = 0\n        \n        for(i <- arr.length) {\n           \
    \ if(arr(i) % 2 == 0) {\n                evenNum = arr(i)\n                evenIndex\
    \ = i\n                evenValue = arr(i).asInstanceOf[Long]\n               \
    \ for(j <- i + 1) {\n                    if(arr(j) % 2 == 0) {\n             \
    \           if(evenValue < arr(j).asInstanceOf[Long]) {\n                    \
    \        evenValue = arr(j).asInstanceOf[Long]\n                            evenIndex\
    \ = j\n                        }\n                    }\n                }\n \
    \               if(evenValue < smalest_value) {\n                    smalest_value\
    \ = evenValue\n                    smalest_index = evenIndex\n               \
    \     smalest = evenNum\n                }\n            }\n        }\n       \
    \ return smalest.asInstanceOf[List[Long]] :: smalest_index.asInstanceOf[List[Long]]",
  "        val minIndex = arr.zipWithIndex.minBy(_._1)._1\n        val smalest = arr.filter(_._1\
    \ == minIndex)\n        if (smalest.length == 0) arr.toList\n        else smalest.head._2.map(i\
    \ => arr(i)).toList", "        arr.foldLeft((Int.MinValue, 0l)) { (a, v) => v\
    \ match {\n            case 0 => (a._1, a._2)\n            case i if (i < a._1)\
    \ => (i, v)\n            case _ => (a._1, v)\n        }}._2", "        var even\
    \ = 0\n        var idx = 0\n        arr.sortWith(_ < _)\n        arr.zipWithIndex.foreach\
    \ { case (value, index) =>\n            if (value % 2 == 0) {\n              \
    \  even = value\n                idx = index\n            }\n        }\n     \
    \   if (even != 0)\n            arr.take(idx).reverse\n        else\n        \
    \    arr.toList", "        val n = arr.length\n        val result = new Array[Long](n)\n\
    \        for(i <- 0 until n) {\n            val k = arr(i)\n            val index\
    \ = if (k % 2 == 0) (n - i - 1) else i\n            if (k % 2 == 0 && index <\
    \ result(0)) result(0) = k\n            else if (k % 2 == 0 && index > result(0))\
    \ result(index) = k\n        }\n        result", "        require(arr.length ==\
    \ 100)\n        var result = new mutable.ArrayBuffer[Long]()\n        var index\
    \ = 0\n        var smallestEven = arr.head\n        var smallestIndex = 0\n  \
    \      var index = 0\n        while (smallestEven.isDefined && (index < arr.length))\
    \ {\n            if (arr(index) %% 2 == 0) {\n                if (smallestEven.get()\
    \ <= arr(index)) {\n                    smallestEven.set(arr(index))\n       \
    \             smallestIndex = 0\n                } else {\n                  \
    \  if (smallestIndex < index) {\n                        smallestIndex = index\n\
    \                    }\n                }\n            }\n            index +=\
    \ 1\n        }\n        val tempIndex = smallestIndex\n        val tempEven =\
    \ smallestEven.get\n        smallestEven.set(arr(tempIndex))\n        smallestIndex\
    \ += 1\n        if (tempEven != 0) {\n            result += (tempEven.toLong,\
    \ tempIndex.toLong)\n        }\n        result", "        var smallest_even :\
    \ Long = -1\n        var smallest_even : Long = -1\n        var smallest_index\
    \ : Long = -1\n        var index = 0\n        var even_index = 0\n        var\
    \ new_arr = new ArrayBuffer[Long]()\n        for(i <- 0 until arr.length) {\n\
    \            if(arr(i) % 2 == 0) {\n                even_index += 1\n        \
    \        if(even_index == smallest_even) {\n                    smallest_even\
    \ = even_index\n                    smallest_index = index\n                }\n\
    \            }\n            else {\n                index += 1\n             \
    \   new_arr += arr(i)\n            }\n        }\n        if(smallest_even != -1)\
    \ {\n            return new_arr ++ List(smallest_even, smallest_index)\n     \
    \   }\n        return List()", "      val n = arr.size\n      if (n == 0) List()\n\
    \      else if (n % 2 == 1) arr.minBy(_.toInt) match {\n        case Some(x) =>\
    \ List(x.toLong, arr.indexOf(x))\n        case None => List()\n      }\n     \
    \ else arr.minBy(_.toInt) match {\n        case Some(x) => List(x.toLong, arr.indexOf(x))\n\
    \        case None => pluck(arr.drop(arr.indexOf(0).toInt))\n      }", "     \
    \   def pluck_helper(arr : List[Long]) : List[Long] = {\n            if (arr.isEmpty)\n\
    \                Nil\n            else {\n                var next_node : Long\
    \ = arr.head\n                var head : Long = arr.head\n                for\
    \ (i <- 1 to arr.size) {\n                    if (arr(i) %2 == 0) {\n        \
    \                if (next_node < arr(i)) {\n                            next_node\
    \ = arr(i)\n                            head = i\n                        }\n\
    \                    }\n                }\n                (next_node, head)\n\
    \            }\n        }\n        pluck_helper(arr)", "        // write your\
    \ code here\n        ", "        val nodes : Map[Long, List[Long]] = arr.foldLeft(Map[Long,\
    \ List[Long]]()) {\n            case (acc, val) => {\n                val node\
    \ = acc\n                val idx = val\n                if (node == null || node.isEmpty)\
    \ {\n                    acc + (val -> (List[Long]()))\n                } else\
    \ if (val % 2 == 0) {\n                    val val = node.minBy(x => x._1)\n \
    \                   if (node.contains(val._1)) {\n                        if (val._1\
    \ < idx) node.remove(val._1) else node(val._1) = List(idx)\n                 \
    \   } else {\n                        node(val._1) = List(idx)\n             \
    \       }\n                } else {\n                    node + (val -> List(0))\n\
    \                }\n            }\n        }\n        nodes.keys.toList.sortBy(x\
    \ => nodes.getOrElse(x, List[Long]()).minBy(y => y._1)).toList", "        var\
    \ min_even: Long = arr(0)\n        var min_index: Long = 0\n        var even_values:\
    \ List[Long] = Nil\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0 && (min_even < arr(i) || min_even < arr(i)))\n                even_values\
    \ ::= arr(i)\n            if (arr(i) % 2 == 0 && min_even < arr(i)) {\n      \
    \          min_even = arr(i)\n                min_index = i\n            }\n \
    \       }\n        if (even_values.isEmpty) {\n            Nil\n        } else\
    \ {\n            var even_value: Long = even_values(0)\n            var even_index_list:\
    \ List[Long] = Nil\n            for (i <- 0 until even_values.length)\n      \
    \          if (even_values(i) == even_value) {\n                    even_index_list\
    \ ::= even_values(i)\n                }\n            (min_even, min_index, even_index_list)\n\
    \        }", "        arr.sortWith((a, b) => a.toLong > b.toLong)\n        var\
    \ index = 0\n        var smalest_value = arr(0) // start with the smallest value\n\
    \        while (index < arr.length) {\n            var value = arr(index).toLong\n\
    \            if (value % 2 == 0) {\n                if (value < smalest_value)\
    \ smalest_value = value\n            } else {\n                smalest_value =\
    \ value // no even number found, so we do not need to check the following nodes\n\
    \            }\n            index += 1\n        }\n        val answer = arr(arr.length\
    \ - 1).toLong - smalest_value\n        if (answer < 0) answer.toLong // we did\
    \ not find a value that even, so return -1\n        else answer.toLong :: 0 //\
    \ return [ smalest_value, its index ]", "        val arr = arr.sortWith(_ < _)\n\
    \        val evens = arr.filter(_ % 2 == 0).sortWith(_ < _)\n        val vals\
    \ = evens.reverse.takeWhile(_ < arr.head)\n        if(evens.isEmpty) arr.toList\n\
    \        else vals.reverse.takeWhile(_ < arr.head).toList :+ arr.head", "    \
    \    var min = arr(0)\n        var min_idx = -1\n        var min_index = -1;\n\
    \        var even_value = false;\n        var min_even_value = -1l\n        for\
    \ (i <- arr.indices) {\n            if (arr(i) % 2 == 0) {\n                if\
    \ (arr(i) < min_even_value) {\n                    min_even_value = arr(i)\n \
    \                   min_idx = i\n                } else if (arr(i) == min_even_value)\
    \ {\n                    min_index = i\n                }\n            }\n   \
    \         if (arr(i) < min) {\n                even_value = true;\n          \
    \      min = arr(i)\n                min_idx = i\n            }\n        }\n \
    \       if (even_value) {\n            arr.updated(min_idx, arr(min_idx))\n  \
    \      }\n        if (arr.length == 0) arr.updated(min_idx, arr(min_idx))\n  \
    \      if (arr.length == 1) arr", "        val evens : List[Long] = arr.filter(_%2\
    \ == 0).toList\n        val smalest_value = (evens.min).getOrElse(0l)\n      \
    \  val smallest_index =\n            evens.indexOf((smallest_value, smallest_even_value)\
    \ => smallest_value == smallest_even_value)\n        if (smallest_index == -1)\
    \ return List()\n        evens.take(smallest_index + 1)", "        var minEvenValue\
    \ : Long = -1\n        var minEvenIndex = 0\n        var i : Int = 0\n       \
    \ for (node <- arr) {\n            if (node % 2 == 0) {\n                if (minEvenValue\
    \ == -1 || node < minEvenValue) {\n                    minEvenValue = node\n \
    \                   minEvenIndex = i\n                }\n            }\n     \
    \       i += 1\n        }\n        minEvenIndex == 0 ? arr.empty : arr(minEvenIndex,1)",
  "        if (arr.isEmpty) List()\n        else arr.sortWith(_.value < _.value)\n\
    \            .map(i => if (i.value % 2 == 0) i.value else i.value % 2)\n     \
    \       .find(_._2 == 0)\n            .map(_._1)", "        val evenValues = arr.filter(_%2\
    \ == 0)\n        if (evenValues.isEmpty) return List()\n        val evenValueList\
    \ = evenValues.toList.sortWith(_.value < _.value)\n        if (evenValueList.size\
    \ < 2) return List()\n        evenValueList.head._2", "        val n = arr.size\n\
    \        val evens = arr.filter( x => x % 2 == 0 ).toList\n        val evensSet\
    \ = evens.toSet\n        val smallestIndex = arr.indexWhere( x => x % 2 == 0 ).min\n\
    \        val smallestValues = evens.filter(x => x % 2 == 0)\n        val indexOfSmallest\
    \ = arr.indexWhere( x => x % 2 == 0 ).min\n        if(smallestIndex == indexOfSmallest)\
    \ {\n            return List( smallestValue, smallestIndex )\n        }\n    \
    \    if(evensSet.size == 1) {\n            return List( smallestValue, smallestIndex\
    \ )\n        }\n        val index = Array.fill(n)(evens.indexOf( x => x % 2 ==\
    \ 0 )).min\n        return List( smallestValues(index), smallestIndex )", "  \
    \      def partition(arr : List[Long], v : Long) : List[Long] = {\n          \
    \  val index = if (arr.isEmpty) 0 else arr.head\n            val value = arr.head\n\
    \            arr.tail.foldLeft((index, value)) { case ((index, v), v) => if (v\
    \ % 2 == 0) (v + 1, v) else if (v < v) (v + 1, index) else if (v > v) (v + 1,\
    \ index) }\n        }\n        val min = partition(arr, arr.head)\n        if\
    \ (min.head == min.tail)\n            min.head :: Nil\n        else\n        \
    \    min.head :: min.tail", "        // Write your code here.\n        val arr2\
    \ = arr.toSet\n        var minIndex = 0\n        var maxValue = 0\n        var\
    \ min = Long.MaxValue\n        for(i <- 0 until arr.length){\n            val\
    \ value = arr(i)\n            if(value % 2 == 0) {\n                minIndex =\
    \ i\n                maxValue = value\n                min = Long.MaxValue\n \
    \           }\n            else if(value < maxValue){\n                minIndex\
    \ = i\n                maxValue = value\n                min = Long.MaxValue\n\
    \            }\n            else if(value == maxValue){\n                if(value\
    \ < min){ min = value }\n                else{\n                    if(value >\
    \ max){\n                        maxIndex = i\n                        maxValue\
    \ = value\n                        max = Long.MaxValue\n                    }\n\
    \                    else{\n                        if(max == Long.MaxValue){\n\
    \                            minIndex = i\n                            maxValue\
    \ = value\n                            min = Long.MaxValue\n                 \
    \       }\n                    }\n                }\n            }\n        }\n\
    \        if(arr.length == 0) {return Nil}\n        if(arr.length == 1){return\
    \ List(arr(0))}\n        val minValues = arr.toArray.filter(v => v % 2 == 0).sortBy(v\
    \ => v).toList\n        val minIndexes = minValues.indices.filter(_ => minValues(_)\
    \ < min).sortBy(_ => minValues(_)).toList\n        val index = minIndexes.head\n\
    \        val value = minValues(index)\n        if(value < minValues.last){\n \
    \           val newArr = ArrayBuffer.empty[Long]\n            var lastElement\
    \ = arr(arr.length - 1)\n            newArr ++= arr2.toList.filter(v => v != lastElement)\n\
    \            newArr ++= minIndexes.map(i => arr(i))\n            return newArr\n\
    \        }\n        else{\n            val newArr = ArrayBuffer.empty[Long]\n\
    \            for(i <- 0 until arr.length-1){\n                if(arr(i) != value\
    \ && arr(i) != arr2(arr(i))) {\n                    val newArr = ArrayBuffer.empty[Long]\n\
    \                    var lastElement = arr(arr.length - 1)\n                 \
    \   newArr ++= arr2.toList.filter(v => v != lastElement)\n                   \
    \ newArr ++= minIndexes.map(i => arr(i))\n                    return newArr\n\
    \                }\n            }\n            return Nil\n        }", '        //
    write your code in Scala', "        var result = arr.toVector\n        if (arr.isEmpty\
    \ || arr.toVector.min % 2 != 0) {\n            result = List()\n        }\n  \
    \      else {\n            var index = 0\n            for (i <- arr.indices) {\n\
    \                if (arr(i) % 2 == 0) {\n                    index += 1\n    \
    \            }\n            }\n            var smallest_value = arr(arr.length)\n\
    \            for (i <- arr.indices) {\n                if (arr(i) % 2 == 0) {\n\
    \                    if (smallest_value < arr(i)) {\n                        smallest_value\
    \ = arr(i)\n                        index = i\n                    }\n       \
    \         }\n            }\n            result = List()\n            for (i <-\
    \ 0 until arr.size) {\n                if (arr(i) == smallest_value) {\n     \
    \               result = result :+ smallest_value.toLong\n                }\n\
    \            }\n        }\n        result.toList", "        var picked = 0\n \
    \       var pickedNode = 0\n        var pickedIndex = 0\n        var evenValue\
    \ = 0\n        var evenIndex = 0\n        for(i <- 0 until arr.length){\n    \
    \        if(arr(i) %2 == 0 && arr(i) > evenValue){\n                evenValue\
    \ = arr(i)\n                evenIndex = i\n            }\n            if(arr(i)\
    \ == evenValue && i < arr.length){\n                picked = i + 1\n         \
    \       pickedNode = evenIndex\n                pickedIndex = evenIndex\n    \
    \        }\n        }\n        if(arr.length > 0){\n            pickedNode = pickedNode\
    \ + 1\n            pickedIndex = pickedIndex + 1\n        }\n        if(picked\
    \ == 0){\n            return List()\n        }\n        else{\n            pickedIndex\
    \ -= 1\n        }\n        return List(pickedValue, pickedIndex)", "       def\
    \ minEvenIndex(a : Long, b : Long) : Int = {\n           val m = (a + b) / 2;\n\
    \           if (m % 2 == 0) a else b\n       }\n\n       val evens = new mutable.HashSet[Long]()\n\
    \       var index = 0\n       arr.filter(_ % 2 == 0).foreach { e => evens.add(e)\
    \ }\n       val list = arr.filter(_ % 2 == 0).map(_ => e).toList\n       val evenSet\
    \ = new mutable.HashSet[Long](evens)\n       val result  = list.sorted.takeWhile(_\
    \ % 2 == 0).takeWhile(_ < evenSet.min).zipWithIndex.filter(_._2 % 2 == 0).map(_._1).headOption\n\
    \       if(result != None) result.map(_+1).toList\n       else Nil", "       \
    \ val len = arr.length\n        val evens = arr.filter(x => x.toString.contains(\"\
    even\"))\n        val min = evens.minBy(_.toString).head\n        val evensIndex\
    \ = evens.map(x => x.indexOf(min)).toArray\n        val evensArray = evensIndex.toArray\n\
    \        evensArray.maxBy(x => x).headOption", "        if (arr.isEmpty) List[Long]()\n\
    \        var min : Long = arr.head\n        var i : Int = 0\n        var odds\
    \ : List[Long] = Nil\n        var evens : List[Long] = Nil\n        var evensIndex\
    \ : List[Long] = Nil\n        var oddsIndex : List[Long] = Nil\n        var minIndex\
    \ : Int = arr.length\n\n        while (i < arr.length) {\n            if (arr(i)\
    \ % 2 == 0) {\n                evens = evens ::: List(i)\n                evensIndex\
    \ = evensIndex ::: List(i)\n            } else {\n                odds = odds\
    \ ::: List(i)\n                oddsIndex = oddsIndex ::: List(i)\n           \
    \ }\n            i += 2\n        }\n        if (evens.isEmpty) odds\n        else\
    \ {\n            val smalest_value = (evens.min) match {\n                case\
    \ i: Int => arr(i)\n                case j: Long => arr(j)\n            }\n  \
    \          if (evensIndex.contains(smalest_value)) {\n                oddsIndex.find(_.toLong\
    \ == smalest_value) match {\n                    case Some(smalest_index) => smalest_index\n\
    \                    case None => 0\n                }\n            } else {\n\
    \                minIndex\n            }\n        }", "        var min_even_value\
    \ : Long = -1\n        var min_value : Long = Long.MaxValue\n        var min_node\
    \ : Long = 0\n        var index : Long = -1\n        var i = 0\n        while(i\
    \ < arr.length) {\n            if(arr(i) % 2 == 0) {\n                if(min_even_value\
    \ < 0 || arr(i) < min_value) {\n                    min_even_value = arr(i)\n\
    \                    min_value = arr(i)\n                    min_node = i\n  \
    \                  index = i\n                }\n                i += 1\n    \
    \        } else {\n                i += 1\n            }\n        }\n        if(min_even_value\
    \ < 0) return Array[Long]()\n        if(min_node == arr.length - 1) return Array(min_even_value,\
    \ index)\n        if(min_node == 0) return Array(min_even_value, index)\n    \
    \    val new_arr = Array[Long](min_even_value, index)\n        for(i <- 0 until\
    \ arr.length - 1) {\n            if(arr(i) % 2 == 0) {\n                if(arr(i)\
    \ > min_value) {\n                    min_value = arr(i)\n                   \
    \ index = i\n                }\n            }\n        }\n        for(i <- 0 until\
    \ arr.length - 1) {\n            if(arr(i) % 2 == 0) {\n                if(arr(i)\
    \ > min_value) {\n                    new_arr += arr(i)\n                }\n \
    \           }\n        }\n        new_arr", "        var retVal = new Array[Long](arr.length);\n\
    \        var index = 0;\n        var minVal = Long.MaxValue;\n        var minIndex\
    \ = 0;\n        for (elem <- arr) {\n            if (elem.toInt % 2 == 0 && elem.toInt\
    \ < minVal) {\n                minVal = elem.toInt\n                minIndex =\
    \ index\n            } else if (elem.toInt % 2 == 0 && elem.toInt == minVal) {\n\
    \                retVal(index) = elem.toInt\n            }\n            index+=1\n\
    \        }\n        retVal(minIndex)", "        var maxEvenIndex = 0\n       \
    \ var maxEvenValue = arr(0)\n        var maxIndex = 0\n        var tempArr = arr\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0) {\n\
    \                if (maxEvenValue > arr(i)) {\n                    maxEvenValue\
    \ = arr(i)\n                    maxEvenIndex = i\n                }\n        \
    \        else {\n                    maxEvenValue = arr(i)\n                 \
    \   maxEvenIndex = i\n                }\n            }\n        }\n        tempArr\
    \ = tempArr filter { x =>\n            if (x % 2 == 0) {\n                if (x\
    \ == maxEvenValue) {\n                    tempArr.indexOf(maxEvenIndex) < tempArr.lastIndexOf(maxEvenIndex)\n\
    \                }\n                else {\n                    x == maxEvenValue\n\
    \                }\n            }\n            else {\n                x == maxEvenValue\n\
    \            }\n        }\n        tempArr", "        val indexMap = arr.groupBy(x\
    \ => x % 2l.toLong).map(x => (x._1.head, x._2.head)).toMap\n        arr.sortWith(_.toLong\
    \ % 2l.toLong < 0).headOption.getOrElse(arr :+ 0l.toLong)", "        val newArr:\
    \ List[Long] = new scala.collection.mutable.ArrayList[Long]()\n        newArr\
    \ ++= arr.map(i => (i, i))\n        val evenArray = arr.filter(i => (i % 2) ==\
    \ 0)\n        evenArray.sortWith(_.compare(_.toLong) < 0)\n        if(evenArray.size\
    \ == 0) newArr else evenArray(0)", "        val evenList = arr.filter(_ % 2 ==\
    \ 0).toList\n        if (evenList.size > 0) {\n            val minIndex : Int\
    \ = (evenList.filter(_ % 2 == 1).min)\n            val smalestValue : Long = (evenList.toSet\
    \ + minIndex).min\n            val pickedNode : List[Long] = arr.filter(_ == smalestValue).toList\n\
    \            pickedNode\n        } else {\n            Nil\n        }", "    \
    \    if(arr.isEmpty) return arr\n        var min_value = math.min(arr)\n     \
    \   for(i <- 0 until arr.size) {\n            if(arr(i) % 2 == 0) arr(i) = min_value\n\
    \            if(arr(i) == min_value) min_value += 1\n        }\n        if(min_value\
    \ == 1) arr.remove(0)\n        else arr", "        var arrs = arr.toSet\n    \
    \    while(arrs.nonEmpty){\n            var minVal = arrs.min\n            arrs\
    \ = arrs - minVal\n            arrs.map( _ + minVal )\n        }", "        //\
    \ write your code here\n        val result = new mutable.ListBuffer[Long]\n  \
    \      arr.foreach { n =>\n            if (n % 2 == 0) {\n                result.append(n)\n\
    \            }\n        }\n        if (result.isEmpty || result.size < 2) {\n\
    \            ListBuffer.empty\n        } else {\n            result.sortWith((x,\
    \ y) => x % 2 == y % 2)\n            result.toList\n        }", "        def findSmallest(arr\
    \ : List[Long], pick : Long) : List[Long] = {\n            if (arr.isEmpty) {\n\
    \                if (pick == 0) List(pick)\n                else {\n         \
    \           pick\n                }\n            } else {\n                arr.zipWithIndex.map(l\
    \ => (l._2 + l._1, l._1))\n                    .sortWith((x, y) => x._1 < y._1)\n\
    \                    .map(x => (x._2 % 2 != 0) ? x._1 : x._2)\n              \
    \      .headOption\n                    .map(l => findSmallest(arr.filter(x =>\
    \ x % 2 != 0), l))\n            }\n        }\n        findSmallest(arr, 0).toList",
  "        val indexSet = arr groupBy {_.toInt} mapValues { _.toList }\n        var\
    \ index = 0\n        var index = indexSet.values.toArray.sortWith(compare(_, 0))(index)\
    \ match {\n            case a if a.size < a.length =>\n                val index\
    \ = a.indexWhere(_ => a.contains(0))\n                val value = a(0)\n     \
    \           if (indexSet.contains(value))\n                    a\n           \
    \     else\n                    List[Long](value, index)\n            case _ =>\n\
    \                List[Long]()\n        }\n        var value = 0\n        index\
    \ = indexSet.values.toArray.sortWith(compare(_, 0))(index) match {\n         \
    \   case a if a.size < a.length =>\n                value = a(0)\n           \
    \ case _ =>\n                List[Long]()\n        }\n        if (indexSet.contains(value))\
    \ {\n            val list = indexSet.get(value).map(v => List(v)).toList\n   \
    \         indexSet.remove(value)\n            List(list.toVector)\n        }\n\
    \        else\n            List()", "        var flag : Boolean = true\n     \
    \   var index : Int = 0\n        var flag1 = true\n        var index1 = 1\n  \
    \      var arr1 = arr\n        while (arr1.nonEmpty) {\n            var smallest_value\
    \ : Long = arr1.min\n            var smallest_index : Int = arr1.indexOf(min)\n\
    \            smallest_value = smallest_value % 2\n            if (flag1 && flag)\
    \ {\n                flag1 = false\n                index = index1\n         \
    \   }\n            if (smallest_value == 0 && smallest_index != -1) {\n      \
    \          flag = false\n                index = index1\n            } else if\
    \ (smallest_value == 0 && smallest_index == -1) {\n                flag = true\n\
    \                index1 = index\n            } else if (smallest_value % 2 ==\
    \ 0) {\n                arr1 = arr1.removeAt(smallest_index)\n               \
    \ arr1 = arr1.removeAt(smallest_index)\n                arr1 = arr1.removeAt(smallest_index)\n\
    \                arr1 = arr1.removeAt(smallest_index)\n                arr1 =\
    \ arr1.removeAt(smallest_index)\n                arr1 = arr1.removeAt(smallest_index)\n\
    \            } else {\n                arr1 = arr1.removeAt(smallest_index)\n\
    \                arr1 = arr1.removeAt(smallest_index)\n                arr1 =\
    \ arr1.removeAt(smallest_index)\n                arr1 = arr1.removeAt(smallest_index)\n\
    \                arr1 = arr1.removeAt(smallest_index)\n                arr1 =\
    \ arr1.removeAt(smallest_index)\n            }\n        }\n        arr.toList",
  "        var min_even_count = 0\n        var min_even_index = -1\n        arr.foldLeft((0,-1)){\n\
    \            case ((even_count, even_index), node) =>\n                if (even_count\
    \ == min_even_count) {\n                    if (even_index < min_even_index)\n\
    \                        min_even_index = even_index\n                }\n    \
    \            else {\n                    if (even_count > min_even_count)\n  \
    \                      (min_even_count, min_even_index) = (even_count, even_index)\n\
    \                }\n                (node)\n        }\n        if (min_even_count\
    \ == min_even_count)\n            List()\n        else\n            (arr.take(min_even_index),\
    \ min_even_index)", "        if (arr.isEmpty) List(Long.MaxValue)\n        if\
    \ (arr.isEmpty && arr(0) == Long.MaxValue) List()\n        var arr1 = arr filter\
    \ (_ % 2 == 0)\n        arr1 foreach (n => { val temp = arr1.filter(_ != n)\n\
    \                          if (temp.length < arr1.length) {\n                \
    \              arr1 = temp :: arr1\n                          } else arr1 = temp})\n\
    \        arr1(0)", "        val evens = arr.filter(_.toLong % 2 == 0).sortBy(_.toLong).reverse\n\
    \        evens.head.asInstanceOf[Long] % 2 == 0 ? evens.toList :\n           \
    \ evens.takeWhile(x => x.asInstanceOf[Long] % 2 == 0).sortBy(_.toLong).reverse.take(1).asInstanceOf[List[Long]]",
  "        val indexMap = arr.zipWithIndex.toMap\n        val smalest_vals = arr.filter(_\
    \ % 2 == 0)\n        if (smalest_vals.isEmpty) {\n            return Array[Long]()\n\
    \        }\n        val smalest_val = smalest_vals.sortBy(-_).head\n        val\
    \ index = (smalest_vals, indexMap.get(smalest_val)).last\n        return index\
    \ match {\n            case (v, i) => Array[Long](smalest_val, i)\n          \
    \  case _ => Array[Long]()\n        }", "        val result: List[Long] = new\
    \ ArrayList[Long]\n        val min_value: List[Long] = arr\n        .sortWith((x,\
    \ y) => x < y)\n        .map((x) => if (x % 2 == 0) x else -1)\n        .takeWhile(_\
    \ >= 0)\n        .filter(_ % 2 == 0)\n        .sortWith(_ < _)\n        .map((_\
    \ + 1l))\n        .takeWhile(_ < arr.length)\n        .map((_ + 1l))\n       \
    \ .takeWhile(x => x < arr.length)\n        .filter(_ < arr.length)\n        .map((_\
    \ + 1l))\n        .takeWhile(x => x < arr.length)\n        .filter(_ < arr.length)\n\
    \        .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n        .filter(_\
    \ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n\
    \        .filter(_ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x\
    \ => x < arr.length)\n        .filter(_ < arr.length)\n        .map((_ + 1l))\n\
    \        .takeWhile(x => x < arr.length)\n        .filter(_ < arr.length)\n  \
    \      .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n        .filter(_\
    \ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n\
    \        .filter(_ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x\
    \ => x < arr.length)\n        .filter(_ < arr.length)\n        .map((_ + 1l))\n\
    \        .takeWhile(x => x < arr.length)\n        .filter(_ < arr.length)\n  \
    \      .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n        .filter(_\
    \ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n\
    \        .filter(_ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x\
    \ => x < arr.length)\n        .filter(_ < arr.length)\n        .map((_ + 1l))\n\
    \        .takeWhile(x => x < arr.length)\n        .filter(_ < arr.length)\n  \
    \      .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n        .filter(_\
    \ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n\
    \        .filter(_ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x\
    \ => x < arr.length)\n        .filter(_ < arr.length)\n        .map((_ + 1", " \
    \       val m = arr.foldLeft(Option(Long.MaxValue))((v, el) => if (v.get < el)\
    \ Some(el) else None);\n        if(m.isEmpty)\n            List()\n        else\n\
    \            m.get.map((el, i) => if (i % 2 == 0)\n                el\n      \
    \      else\n                el.toLong)", "        var cur = arr(0)\n        var\
    \ i = 0\n        var res : List[Long] = Nil\n\n        while (i < arr.length)\
    \ {\n            if (cur % 2 == 0) {\n                if (i != arr.length && arr(i+1)\
    \ == cur) {\n                    i += 1\n                } else if (i == arr.length)\
    \ {\n                    res.append(cur)\n                    i += 1\n       \
    \         } else {\n                    res.append(cur)\n                    i\
    \ += 1\n                    cur = arr(i)\n                }\n            } else\
    \ {\n                i += 1\n            }\n        }\n        if (i == arr.length)\
    \ {\n            res.append(cur)\n        }\n        return res", "        val\
    \ even_values = arr.filter(x => x % 2 == 0).sortBy(x => x).toArray\n        val\
    \ first_value : Long = even_values(0)\n        val max_value_index : Int = arr.indexWhere(x\
    \ => x == first_value)\n        val value = even_values(max_value_index)\n   \
    \     val index: List[Long] = List(first_value, max_value_index)\n        if (even_values.size\
    \ == 1) {\n            return index\n        } else {\n            val even_values_with_index\
    \ = even_values.map(_ -> arr.indexOf(_)).toMap\n            val first_value_with_index\
    \ = even_values_with_index(1)\n            val max_value_index_with_index = even_values_with_index(max_value_index)\n\
    \            return List(first_value_with_index, max_value_index_with_index)\n\
    \        }", '        arr.foldRight(List[Long]())((x, y) => if (x%2==0) y else
    x)', "        val len = arr.length\n        var smallest = arr(0)\n        var\
    \ smallest_index = -1\n        var next_node = 0\n        var i = 1 // counter\n\
    \        while (i < len) {\n            val item = arr(i)\n            if (item\
    \ % 2 == 0) {\n                smallest = item\n                smallest_index\
    \ = i\n                next_node = i + 1\n            }\n            i += 1\n\
    \        }\n        if (smallest_index != -1) smallest_index\n        else arr.toList",
  "        val list = arr.sorted\n        var res = new List[Long]()\n        var\
    \ index = 0\n        var picked = 0\n        var even = list.reduceLeft{ (a, e)\
    \ =>\n            if (even) {\n                picked = 0\n                even\
    \ = false\n                index = 0\n                a = e\n                e\n\
    \            } else {\n                if (a < e) {\n                    picked\
    \ = e\n                    even = true\n                    index = index + 1\n\
    \                    e\n                } else if (a == e) {\n               \
    \     picked = e\n                    even = true\n                    index =\
    \ index + 1\n                    e\n                } else {\n               \
    \     picked = e\n                    even = true\n                    index =\
    \ index + 1\n                    e\n                }\n            }\n       \
    \ }\n        res ::= picked\n        res", "        val (val, idx) = arr.foldLeft((-1L,\
    \ -1)) { case ((val, idx), nextVal) =>\n            val (nextVal, nextIdx) = nextVal.zipWithIndex.max\n\
    \            val (nextVal, nextIdx) = nextVal match {\n                case (_,\
    \ -1) => nextVal, 0\n                case (_, 0) => (nextVal, nextIdx)\n     \
    \           case (v, i) => (v, i + 1)\n            }\n            (nextVal, nextIdx)\n\
    \        }\n        arr match {\n            case Nil => Nil\n            case\
    \ head :: tail => head :: tail.filter(i => i % 2 == 0).sortWith(_ < _).reverse.takeWhile(i\
    \ => i < idx).reverse.toList\n        }", "        arr.sortBy(x => x.toInt)\n\
    \        arr.zipWithIndex.filter(_._2 % 2 == 1).map(_._1).headOption.getOrElse(arr.headOption)",
  "        var index = 0\n        var pluck_val = arr(0) // start with the first node\
    \ to compare\n        var pluck_val_index = 0 // this is used for the first node\
    \ in the list\n        for (i <- 1 until arr.length){\n            if(arr(i) %\
    \ 2 == 0) \n            { // if we have an even value\n                if(pluck_val\
    \ > arr(i)){ // if we are still getting the highest value\n                  \
    \  pluck_val = arr(i)\n                    pluck_val_index = i\n             \
    \   }\n            }\n            else\n            { // if we have an odd value\n\
    \                if(pluck_val < arr(i)){ // if we are still getting the lowest\
    \ value\n                    pluck_val = arr(i)\n                    pluck_val_index\
    \ = i\n                }\n            }\n        }\n        var pluck_val_return\
    \ = List.empty[Long]\n        if(pluck_val != 0) // if we found a value\n    \
    \    {\n            pluck_val_return = List(pluck_val, pluck_val_index)\n    \
    \    }\n        return pluck_val_return", "        require(arr.length > 0)\n \
    \       var index = 0\n        var largest = 0\n        var result = []\n    \
    \    for (i<- 0 until arr.length) {\n            if (arr(i) % 2 != 0) {\n    \
    \            if (arr(i) > largest) {\n                    largest = arr(i)\n \
    \                   index = i\n                } else if (arr(i) == largest) {\n\
    \                    if (index < i) index = i\n                }\n           \
    \ }\n        }\n        if (index >= 0) result.add(largest)\n        result.add(index)\n\
    \        return result", "        // base case\n        if(arr.isEmpty) return\
    \ List()\n        // get smallest even value\n        val even = arr.filter(_\
    \ % 2 == 0).toList.min\n        // get smallest even index\n        val index\
    \ = arr.indexOf(0)\n        // get new array by removing odd value\n        arr.filter(_\
    \ % 2 != 0).zipWithIndex.filter(_._1 == even).map(_._2)", "        val set = arr.map(n\
    \ => (n % 2, n)).distinct\n\n        if (set.size == 0) return Nil\n        else\
    \ if (set.size == 1) return set._1\n        else if (set.size == 2) return if\
    \ (set._1 <= set._2) set._1 else {\n            val i = arr.lastIndexWhere(x =>\
    \ set._1 == (x % 2 ==0l))\n            if (i != -1) set._2 else set._1\n     \
    \   }\n        else {\n            val i = arr.lastIndexWhere(x => set._1 == (x\
    \ % 2 ==0l))\n            if (i != -1) set._1 else set.last\n        }", "   \
    \     var min = arr(0).toLong\n        var minIndex = 0\n        var maxIndex\
    \ = 0\n        for(i <- 0 until arr.length) {\n            if(arr(i).toLong ==\
    \ min) {\n                minIndex = i\n                max = arr(i)\n       \
    \     }else if(arr(i).toLong == max) {\n                maxIndex = i\n       \
    \     }\n        }\n        if(minIndex == maxIndex) {\n            List();\n\
    \        }else if(minIndex < maxIndex) {\n            List (arr[minIndex], arr[minIndex+1])\n\
    \        }else{\n            List (arr[maxIndex], arr[maxIndex-1])\n        }",
  "        var nodeMap = mutable.Map[Long, List[Long]]()\n        var nodeList = new\
    \ ListBuffer[Long]()\n        for(i <- arr.iterator){\n            val node =\
    \ i\n            if(!nodeMap.contains(node)){\n                nodeMap.put(node,\
    \ new ListBuffer[Long])\n            }\n            nodeMap.get(node) += i\n \
    \       }\n        for(node <- nodeMap.keys){\n            val buffer = nodeMap.get(node)\n\
    \            val smallestValue = buffer.min\n            if(smallestValue == 0){\n\
    \                nodeList += smallestValue\n            }else{\n             \
    \   buffer.remove(0)\n                if(buffer.isEmpty){\n                  \
    \  nodeList += smallestValue\n                }else{\n                    val\
    \ smallestIndex = buffer.indexOf(0)\n                    nodeList += smallestValue\n\
    \                    nodeList += smallestIndex.toLong\n                }\n   \
    \         }\n        }\n        if(nodeList.isEmpty){\n            nodeList +=\
    \ 0\n        }\n        nodeList.toList", "        val evenNodes = arr.filter(x\
    \ => x.toInt % 2 == 0)\n        val smallest = evenNodes.minBy(x => x.toInt)\n\
    \        val largest = evenNodes.maxBy(x => x.toInt)\n        val indices = evenNodes.zipWithIndex.filter\
    \ { case (v, i) => v % 2 == 0 && v < smallest }.map(x => x._2).sortBy(x => x).reverse\n\
    \        if(indices.size > 0) {\n            List((largest, indices.get(0)))\n\
    \        } else {\n            List[Long]()\n        }", "        if (arr.isEmpty)\
    \ return arr\n        var max_index = 0\n        var max_value = 0\n        for(i\
    \ <- 0 until arr.length) {\n            val cur_value = arr(i)\n            if(cur_value\
    \ % 2 == 0 && cur_value <= max_value) {\n                max_index = i\n     \
    \           max_value = cur_value\n            }\n        }\n        val out_arr\
    \ = arr.filter(_ % 2 == 0).sortWith(_ < _).map(i => arr(i))\n        out_arr(max_index)",
  "        val map = new mutable.HashMap[(Long, Int), Long]\n        arr.foreach(x\
    \ => map += ((x, map.getOrElse((x, -1), 0) + 1))\n        )\n        val max =\
    \ map.maxBy(_._2._2)\n        if (max._2._2 != 0) map.get((max._1, max._2))\n\
    \        else map.get(max._1)", "        val evenValues = arr.filter(i => i %\
    \ 2 == 0)\n        if(evenValues.isEmpty) return Nil\n        evenValues.minBy(i\
    \ => i)", "        val s = arr.sortWith((a, b) => math.abs(a - b))\n        s.takeWhile((x,\
    \ i) => i % 2 == 0) // the second arg is index", "        if (arr.isEmpty) List[Long]()\n\
    \        else if (arr.isEmpty) List[Long]()\n        else arr.sortWith(_ < _)",
  "        var ans = List[Long]()\n        var smallestValue = arr(0)\n        var\
    \ smallestIndex = 0\n\n        for (i <- arr.indices) {\n            if(smallestValue\
    \ < arr(i)) {\n                smallestValue = arr(i)\n                smallestIndex\
    \ = i\n            }\n        }\n\n        if (smallestValue == 0) ans = List(0)\n\
    \        else ans = List(smallestValue, smallestIndex)", "        val arr = arr.toSet\n\
    \        val len = arr.size\n        var minIndex = 0\n        var minValue =\
    \ arr(0).toLong\n        var minArray = arr.toList\n        while (len > 0) {\n\
    \            val curValue = arr(len - 1).toLong\n            var index = len -\
    \ 1\n            while (index >= 0 && arr(index).toLong > curValue) {\n      \
    \          minArray = arr.drop(index).toList\n                index -= 1\n   \
    \         }\n            if (index < 0) {\n                minArray = arr.toList\n\
    \            }\n            if (arr(index).toLong < minValue || (arr(index).toLong\
    \ == minValue && index < minIndex)) {\n                minIndex = index\n    \
    \            minValue = arr(index).toLong\n            }\n            len -= 1\n\
    \        }\n        minArray", "      var min = Long.MaxValue\n      var index\
    \ = 0\n      for(i <- 0 until arr.length){\n        val curr = arr(i)\n      \
    \  if(curr.toInt % 2 == 0){\n          min = Math.min(min, curr)\n          index\
    \ = i\n        }\n      }\n      List(min, index)", "        arr.sortWith(_ <\
    \ _)\n        val evenIndex = arr.indexOf(_ % 2 == 0)\n        if(evenIndex <\
    \ arr.length) arr.lift(evenIndex) else List().reverse", '        arr.toList.sortBy(_.toLong).map(arr(_).toLong).distinct().toList.groupBy(_.toLong).map(_.min).flatMap(_.find(_.toLong
    % 2 == 0)).map(x => List(x.toLong,arr.indexOf(x)).filterNot(_ == 0).map(x => (x.toLong,
    x)))', "        if (arr.isEmpty) {\n            return []\n        }\n       \
    \ var smalest_value : Long = -1L\n        var index : Long = -1L\n        var\
    \ ans : List[Long] = Nil\n        var tmp : List[Long] = Nil\n        var index\
    \ = 0\n        var value : Long = 0L\n        for (i <- 0 until arr.length) {\n\
    \            value = arr(i)\n            if (value < smalest_value) {\n      \
    \          smalest_value = value\n                index = i\n            }\n \
    \           if (value == smalest_value) {\n                tmp = arr.slice(i +\
    \ 1)\n                if (index < tmp.length) {\n                    index = tmp.length\n\
    \                }\n                if (tmp(index) % 2 == 0) {\n             \
    \       ans = tmp.slice(1, index).toList\n                }\n            }\n \
    \       }\n        return ans", "        val smalest_value : Long  = arr.min\n\
    \        val index_of_smalest_value = arr.indexOf( smalest_value)\n        val\
    \ smalest_value_with_index = smalest_value + index_of_smalest_value\n        arr.filter(_\
    \ % 2 == 0).filter(_ < smalest_value_with_index).map(_ + index_of_smalest_value)",
  "        val result = mutable.ListBuffer.empty[Long]\n        arr.sortWith( (a,b)\
    \ => a > b)\n        for ( (n, i) in arr.zipWithIndex.toList ) if (n % 2 == 0)\
    \ result.+= n\n        if (result.isEmpty) result else result.sortWith( (a,b)\
    \ => a < b)", "        var minVal = arr(0)\n        var minIndex = 0\n       \
    \ var minIndexInner = 1\n\n        var index = 0\n        var evenArray = arr.filter(_\
    \ % 2 == 0)\n\n        evenArray.foreach{\n            if(minVal > _){\n     \
    \           minVal = _\n                minIndex = index\n                minIndexInner\
    \ = minIndexInner+1\n            }\n        }\n\n        arr.filter(!evenArray.contains(_)).sortBy(_\
    \ % 2 == 0).take(minIndexInner).toList", "        def getSmallestIndex(nodes:\
    \ List[Long], index : Int) : List[Long] = {\n            if (nodes == null) null\n\
    \            else {\n                val smallestNode = nodes.head\n         \
    \       if (smallestNode % 2 == 0) smallestNode :: smallestIndex\n           \
    \     else smallestNode :: getSmallestIndex(nodes.tail, smallestIndex + 1)\n \
    \           }\n        }\n        val smallestIndex = -1\n        val smallestNode\
    \ = arr(0)\n        val res = (0 until arr.size).map { i => getSmallestIndex(arr,\
    \ i + 1) }\n        if (res.nonEmpty) {\n            val minIndex = res.minBy(_.size)\n\
    \            val pluckedValue = arr(minIndex.size)\n            res(minIndex)\
    \ match {\n                case null => null\n                case _ => (pluckedValue,\
    \ minIndex.size)\n            }\n        }\n        else {\n            null\n\
    \        }", "        def pickEvenIndex(i: Int): Int = if (arr(i) %2 == 0) i else\
    \ i + 2\n        val evenList = arr.filter(i => i % 2 == 0).sortWith(_ < _)\n\
    \        evenList.toList.map(pickEvenIndex)", "       val res = arr.groupBy(x\
    \ => (x%2 ==0)).mapValues(_.sortBy(x => x)).toList\n       res.sortBy(x=>x._2)",
  "        val evens = arr.filter(x => x % 2 == 0).sorted\n        if (evens.isEmpty)\
    \ return emptyList[Long]\n        evens.headOption.map { x => arr.indexOf(x.toLong,\
    \ arr.indexOf(x.toLong) + 1) }.getOrElse(arr.indexOf(evens.head.toLong))", " \
    \       var index = 0;\n        var smallest = arr(0) match {\n            case\
    \ _ if arr(0) % 2 == 0 => 1\n            case _ if arr(0) % 2 == 1 => 2\n    \
    \        case _ => 0\n        }\n        var result: mutable.List[Long] = mutable.List();\n\
    \        var index = arr(0)\n        for (x <- arr) {\n            if (x % 2 ==\
    \ 0) {\n                if (smallest == 0) {\n                    smallest = 1;\n\
    \                }\n                if (x < smallest) {\n                    smallest\
    \ = x;\n                    index = 0;\n                }\n            }\n   \
    \         if (x % 2 == 1) {\n                if (smallest == 1) {\n          \
    \          smallest = 2;\n                }\n                if (x < smallest)\
    \ {\n                    smallest = x;\n                    index = 1;\n     \
    \           }\n            }\n        }\n        if (smallest == 0) {\n      \
    \      result = mutable.List();\n        } else {\n            result = mutable.List(smallest,\
    \ index);\n        }\n        return result", "        val ans = mutable.Buffer[Long]()\n\
    \        val index = 0\n\n        for(x <- arr) {\n            if(x.toInt % 2\
    \ == 0) {\n                ans += x\n            }\n        }\n        ans.toList",
  "        val even = arr.filter(i => i % 2 == 0).sortWith(_ < _)\n        val zero\
    \ = arr.filter(i => i % 2 == 0).sortWith(_ < _).head\n        even.find(i => i\
    \ % 2 == 0).map(i => (i, even.indexWhere(_ == i))).toList match {\n          \
    \  case Nil => zero\n            case List(i @ _, _) => i\n        }", "     \
    \   var ans = List[Long]()\n        var node = 0\n        var minVal = arr(0)\n\
    \        var minIndex = 0\n        for (i<- 0 until arr.length) {\n          \
    \  if (arr(i) % 2 == 0) {\n                if (arr(i) < minVal) {\n          \
    \          minVal = arr(i)\n                    minIndex = i\n               \
    \ }\n            }\n        }\n        ans += minVal\n        ans += minIndex\n\
    \        return ans", "        val m = arr.takeWhile(_ % 2 == 0).sortBy(_ % 2).head\n\
    \        if (m.isEven) {\n            arr.map { n => n }.takeWhile(_ > m).takeWhile(n\
    \ => n % 2 == 0).sortBy(_ % 2).head\n        } else {\n            arr.map { n\
    \ => n }.takeWhile(_ >= m).takeWhile(n => n % 2 == 0).sortBy(_ % 2).head\n   \
    \     }", "        var nodes : List[Long] = Nil\n        var minIndex : Long =\
    \ 0\n        var minVal : Long = 0l\n        var minEven : Boolean = false\n \
    \       for(i <- 0 until arr.length) {\n            if(arr(i) %2 == 0) {\n   \
    \             if(minEven) {\n                    minVal = arr(i)\n           \
    \         minIndex = i\n                    minEven = false\n                }\n\
    \                else {\n                    minEven = true\n                }\n\
    \            }\n            else {\n                if(minEven) {\n          \
    \          minVal = arr(i)\n                    minIndex = i\n               \
    \     minEven = false\n                }\n                else {\n           \
    \         minEven = true\n                }\n            }\n        }\n      \
    \  if(minEven) {\n            nodes = arr.toList\n        }\n        else {\n\
    \            nodes = arr.sortWith(_.compareTo(_) < 0).toList\n        }\n    \
    \    nodes.head", "        if (arr.length == 0){\n            return []\n    \
    \    }\n        var min_value : Long = arr.head\n        var min_index : int =\
    \ 1\n        var index_set = List[Int]()\n        for (i <- 0 until arr.length){\n\
    \            if (arr(i) % 2 == 0){\n                if (arr(i) < min_value){\n\
    \                    min_value = arr(i)\n                    min_index = i\n \
    \                   index_set = []\n                }\n            }\n       \
    \     index_set ::= i\n        }\n        var new_list = []\n        for (i <-\
    \ 0 until index_set.length){\n            new_list ::= (min_value, min_index +\
    \ i - 1)\n        }\n        if (index_set.length == 0){\n            new_list\
    \ = []\n        }\n        new_list", "        val n = arr.length\n        if\
    \ (n == 0) List()\n        if (n % 2 == 1) arr(n)\n        else {\n          \
    \  var min = arr(n/2).toLong\n            var min_index = 0\n            for (i\
    \ <- n / 2 + 1 until n) {\n                if (arr(i) %2 == 0) {\n           \
    \         if (min > arr(i))\n                        min = arr(i)\n          \
    \          min_index = i\n                }\n            }\n            List((min.toLong,\
    \ min_index))\n        }", "        // Write your code here\n        def swap(a\
    \ : Long, b : Long) : Unit = {\n            val t = a\n            a = b\n   \
    \         b = t\n        }\n        val min_val = arr(0)\n        val min_idx\
    \ = 1\n        for( i <- 0 until arr.length ) {\n            if(arr(i) % 2 ==\
    \ 0) {\n                swap(arr(i), min_val)\n                swap(min_idx, i)\n\
    \            }\n        }\n        List(min_val, min_idx)", "        var m = arr.sortBy(-_)\n\
    \        val l = (m.length >>> 1).toInt\n        val k = (m.length / l).toInt\n\
    \        m.take(l).zipWithIndex.foldLeft(List[Long]()) { (acc, el) =>\n      \
    \      if (el._2 % 2 == 0) {\n                acc.reverse.push(el._1)\n      \
    \      } else {\n                acc.reverse.push(el._1)\n                acc.reverse.push(el._2)\n\
    \            }\n        }.map(_.toLong)", "        val evenValues = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smallestIndex = arr.indexOfMax( x => x %\
    \ 2 == 0)\n        val smalestValue = evenValues.min\n        val newArr: List[Long]\
    \ = arr.filterNot(x => x % 2 == 0).filter(x => x % 2 == 0)\n        newArr", " \
    \       val arr = arr.sorted\n        val evens = arr.filter(_%2 == 0).sortBy(-_)\n\
    \        if(evens.length == 0 || arr.length == 0)\n            List()\n      \
    \  else\n            evens.head", "        val map = mutable.TreeMap[Long, Int]()\n\
    \        var index = 0\n        var smallest = 0L\n        arr.foreach(l => {\n\
    \            if(map.contains(l)) {\n                smallest = map.get(l).getOrElse(0L)\n\
    \            } else {\n                map.put(l, index+1)\n            }\n  \
    \          index += 1\n        })\n        if(map.isEmpty) return List()\n   \
    \     val keys = map.keys.sorted\n        if(keys.isEmpty) List()\n        else\
    \ {\n            val indexMap = keys.zipWithIndex\n            val smalest = keys.get(keys.indexOf((smallest+1).toInt)).getOrElse(smallest+1).toInt\n\
    \            val smalestValue = keys.get(keys.indexOf(smalest)).getOrElse(smalest).toLong\n\
    \            return List(smalestValue.toLong, indexMap.get(smalest).getOrElse(0).toInt)\n\
    \        }", "        if (arr.isEmpty) List()\n        val map = arr.toSet.toList\n\
    \        val sorted = arr.sortWith((a, b) => a.toLong > b.toLong)\n        val\
    \ even = sorted.filter(_%2 == 0).takeWhile(_ <= sorted.last.toLong).toList\n \
    \       val idx = sorted.toList.zipWithIndex.find(t => t._2 == even(0)).getOrElse(sorted.last)\n\
    \        List(sorted.last, idx)", "        var minValue = arr.sortWith(_ < _).head\n\
    \        var minIndex = 0\n        var evenIndex = 0\n        var evenMax = 0\n\
    \        var minIndex = 0\n        for (i <- 0 until arr.length) {\n         \
    \   if (arr(i) % 2 == 0){\n                if (evenIndex < evenMax) {\n      \
    \              minValue = arr(i)\n                    minIndex = i\n         \
    \           evenIndex = 0\n                    evenMax = 0\n                }\n\
    \                else {\n                    evenIndex += 1\n                \
    \    evenMax = evenIndex\n                }\n            }\n        }\n      \
    \  if (evenIndex == 0){\n            return Nil\n        }\n        else {\n \
    \           return List(minValue, minIndex)\n        }", "        var even_values\
    \ = mutable.ArrayBuffer.empty[Long]\n        var even_index = mutable.ArrayBuffer.empty[Long]\n\
    \        var lowest_index = mutable.ArrayBuffer.empty[Long]\n\n        var i =\
    \ 0\n        for(i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0)\
    \ {\n                even_values += arr(i)\n                even_index += i\n\
    \            } else if (even_values.nonEmpty && even_values.last == arr(i)) {\n\
    \                lowest_index += (even_index.last + 1)\n            } else if\
    \ (even_values.nonEmpty && even_values.last != arr(i)) {\n                lowest_index\
    \ += (even_index.last + 1)\n                even_index += (even_index.last + 1)\n\
    \                even_values += arr(i)\n            } else {\n               \
    \ even_values += arr(i)\n                even_index += i\n            }\n    \
    \    }\n        even_values.toList.sortWith(_ < _)\n        even_index.toList.sortWith(_\
    \ < _)\n        if (even_values.nonEmpty) {\n            even_values.last\n  \
    \      } else {\n            0\n        }", "        def minIndex( node : Long\
    \ ): Int = {\n            // find the smallest even number and its index from\
    \ arr\n            val minValue = min(arr(0 until arr.length).filter(x => x %\
    \ 2 ==  0 ))\n            val index = arr.indexOf(minValue)\n            if( index\
    \ == arr.length - 1 )\n                -1\n            else\n                index\n\
    \        }\n\n        arr.head :: minIndex(arr.head) ++ arr.tail.filter(x => x\
    \ % 2 ==  0 )", "        if(arr.isEmpty || arr.size <= 0) {\n            return\
    \ arr\n        }\n        // Sort list\n        val sortedArr = arr.toArray.sortWith((x,y)\
    \ => x.toLong == y.toLong)\n        // Get minimum even value\n        var minEven\
    \ = sortedArr(0)\n        // If there are multiple values, then get the smallest\
    \ index\n        var minIndex = -1\n        var i = 0\n        while(i < sortedArr.length)\
    \ {\n            if(sortedArr(i) % 2 == 0) {\n                if(minEven.compareToDouble(sortedArr(i))\
    \ < 0.0) {\n                    minEven = sortedArr(i)\n                    minIndex\
    \ = i\n                }\n                i += 1\n            } else {\n     \
    \           i += 1\n            }\n        }\n        // Create result list\n\
    \        val resultArr: List[Long] = Array(minEven.toLong, minIndex)\n       \
    \ // Return result\n        return resultArr", "        val smalest_value = 0\n\
    \        val smalest_index = 0\n        for (i <- 0 until arr.size) {\n      \
    \      if (arr(i) % 2 == 0) {\n                if (smalest_value < arr(i)) {\n\
    \                    smalest_value = arr(i)\n                    smalest_index\
    \ = i\n                }\n            }\n        }\n        if (smalest_value\
    \ == 0) {\n            return Nil\n        }\n        smalest_index match {\n\
    \            case 0 => List(smalest_value)\n            case _ => List(smalest_value,\
    \ smalest_index)\n        }", "        def pickEven(arr : List[Long], pick : List[Long])\
    \ : List[Long] = {\n            if(arr.isEmpty) {\n                return pick\n\
    \            }\n            var curr : Long = 0\n            val indexes = mutable.ListBuffer.empty[Int]\n\
    \            for(i <- 0 until arr.length) {\n                if(arr(i) % 2 ==\
    \ 0) {\n                    curr = arr(i)\n                    indexes.add(i)\n\
    \                }\n            }\n            if(indexes.isEmpty) {\n       \
    \         return pickEven(arr, pick)\n            }\n            val min = indexes(0)\n\
    \            val minIndex = indexes(0)\n            var i = 0\n            for(i\
    \ <- 0 until arr.length) {\n                if(arr(i) == min) {\n            \
    \        if(i < minIndex) {\n                        minIndex = i\n          \
    \          }\n                }\n            }\n            val picked = pickEven(arr.drop(minIndex),\
    \ pick)\n            if(minIndex == picked.length) {\n                return picked\n\
    \            }\n            picked ++ pickEven(arr.take(minIndex), pick)\n   \
    \     }\n        pickEven(arr, List.empty[Long])", "        // Write your code\
    \ here\n        if(arr.isEmpty || arr.length < 1){\n            return arr.toList\n\
    \        }\n        var index = 0\n        var min_even = 0\n        var min_index\
    \ = 0\n        for(a <- arr){\n            if(a%2 == 0){\n                min_even\
    \ = a\n                min_index = a\n            }\n        }\n        for(a\
    \ <- arr){\n            if(a%2 != 0 && a < min_even){\n                min_even\
    \ = a\n                min_index = a\n            }\n        }\n        return\
    \ Array[Long](min_even.toLong, min_index).toList", "      var list = new mutable.MutableList[Long]()\n\
    \      var index = 0\n      var smalest_value = arr(0).toLong\n      var new_array\
    \ = new List[Long]()\n      for(i <- 0 until arr.length) {\n        val value\
    \ = arr(i)\n        if(value.toLong == smalest_value) {\n          index += 1\n\
    \          if(index == arr.length) {\n            list.+= new_array\n        \
    \    break\n          }\n        } else {\n          index = 0\n          smalest_value\
    \ = value.toLong\n          new_array += arr(i)\n        }\n      }\n      if(arr.isEmpty)\
    \ {\n        list.+=(new_array)\n      }\n      list", "        var minIndex =\
    \ 0\n        var maxIndex = 0\n        var minVal = arr(0)\n        var maxVal\
    \ = arr(0)\n        var evenCount = 1\n        var index = 0\n        for ((i,\
    \ _, _) <- arr.zipWithIndex) {\n            if (i % 2 != 0) {\n              \
    \  if (minVal > arr(i)) {\n                    minVal = arr(i)\n             \
    \       minIndex = i\n                }\n            }\n            else if (i\
    \ % 2 == 0) {\n                if (minVal > arr(i)) {\n                    minVal\
    \ = arr(i)\n                    minIndex = i\n                }\n            \
    \    else {\n                    if (maxVal < arr(i)) {\n                    \
    \    maxVal = arr(i)\n                        maxIndex = i\n                 \
    \   }\n                }\n                evenCount += 1\n            }\n    \
    \    }\n        if (evenCount == 0) {\n            List[Long]()\n        }\n \
    \       else if (evenCount == arr.length) {\n            List[Long](maxVal, maxIndex)\n\
    \        }\n        else {\n            List[Long](minVal, minIndex)\n       \
    \ }", "        val even = arr.filter(v => v % 2 == 0).toList\n        val min\
    \ = even.min(implicitly[Ordering[Long]]).asInstanceOf[Long]\n        even.filter(\
    \ v => v == min)", "        val evensMap = arr.groupBy(_ % 2 == 0).mapValues(_.length).toMap\n\
    \        val smallestIndexValue = arr.minBy(_ % 2 == 0)._2\n        val index\
    \ = arr.indexOf(smallestIndexValue)\n        val evensValues = evensMap.values\n\
    \        if(index < evensValues.size)\n            evensMap.get(smallestIndexValue)\n\
    \        else\n            evensValues.take(index).reverse", "        // Your\
    \ code here\n        if(arr.isEmpty) {\n            throw new IllegalArgumentException(\"\
    Not found\")\n        }\n        var min = 0L\n        var max = 0L\n        var\
    \ index = 0\n        var indexMin = 0\n        var indexMax = 0\n        var i\
    \ = 0\n        var flag = false\n        while(i < arr.length) {\n           \
    \ index = arr(i)\n            if(flag) {\n                max = 0L\n         \
    \       min = index\n                indexMax = 0\n                indexMin =\
    \ 0\n                flag = false\n            }\n            if(index < min)\
    \ {\n                min = index\n            }\n            if(index > max) {\n\
    \                max = index\n            }\n            i += 1\n        }\n \
    \       if(min == max) {\n            return List()\n        }\n        var tempArr\
    \ = [min.toLong, min.toInt]\n        while(i < arr.length) {\n            index\
    \ = arr(i)\n            if(index < min) {\n                tempArr += index.toLong\n\
    \                index += index.toInt\n                flag = true\n         \
    \   }\n            i += 1\n        }\n        while(i < arr.length) {\n      \
    \      index = arr(i)\n            if(index > max) {\n                tempArr\
    \ += index.toLong\n                index += index.toInt\n                flag\
    \ = true\n            }\n            i += 1\n        }\n        return tempArr",
  "        val sorted = arr.toList.sortBy(_.toLong).reverse\n        sorted.foldLeft[List[Long]](List[Long]()){\
    \ (acc, x) => \n            var index = 0\n            while (index < acc.length\
    \ && x % 2 == 0) index += 2\n            val v = acc.toList.take(index)\n    \
    \        val result = if (acc.length == 0 || v.length < v(0).toLong) v else v(0)\n\
    \            (acc.length -> result)\n        }", "        arr.sortWith((x, y)\
    \ => x % 2 == y % 2)\n        arr.filter(_ % 2 == 0).takeWhile(_ < arr.head).toList",
  "        var ans = scala.collection.mutable.ListBuffer.empty[Long]\n        var\
    \ ans_idx = scala.collection.mutable.ListBuffer.empty[Int]\n        var evens\
    \ : Set[Long] = scala.collection.mutable.Set[Long]()\n        arr.foreach(x =>\
    \ {\n            val i = arr.indexOf(x)\n            if (i % 2 == 0) evens.add(x)\n\
    \            ans += x\n            ans_idx += i\n        })\n        if (ans.isEmpty)\
    \ ans\n        else {\n            val smallers = evens.toList\n            val\
    \ small = smallers.head\n            smallers.foreach(x => ans.remove(x))\n  \
    \          ans += small\n            ans_idx.push(evens.index(small))\n      \
    \  }\n        ans :: ans_idx", "        arr.foldLeft((List[Long](0l, -1l), 0l))\
    \ {\n          case ((acc, index), value) =>\n            if (value % 2 == 0)\n\
    \              (List(value, index), acc + 1)\n            else\n             \
    \ (acc, index)\n        }._1.filter(_ > 0)", "        // Write your code here\n\
    \        if(arr.isEmpty) {\n            return Array[Long]()\n        }\n\n  \
    \      val odd = arr.filter(_%2 == 0).toList\n        val smallestEven = odd.sortWith(_\
    \ < _) match {\n            case Nil => smallestEven\n            case head ::\
    \ tail => head\n        }\n\n        if(smallestEven.isEmpty) {\n            return\
    \ Array[Long]()\n        }\n        val index = smallestEven.indexOf(0)\n    \
    \    if(index < smallestEven.size){\n            return Array(smallestEven(0).toLong,\
    \ index.toLong)\n        }else{\n            return Array[Long]()\n        }",
  "        if (arr.isEmpty) List();\n        else {\n            var smallest_even_value\
    \ = 0;\n            var smallest_index = 0;\n            for (val n <- arr) {\n\
    \                if (n.toInt%2==0) {\n                    if (smallest_even_value==0)\
    \ smallest_even_value = n; else smallest_index = n;\n                }\n     \
    \       }\n            if (smallest_even_value==0) List();\n            else List(smallest_even_value,\
    \ smallest_index);\n        }", "        var minVal : Long = arr(0)\n        var\
    \ minIndex : Long = 0\n        var i : Long = 1\n        var list : List[Long]\
    \ = Nil\n\n        // Find the smallest even value in the array\n        while\
    \ (i < arr.length && arr(i) rem 2 != 0) {\n            val currentVal = arr(i)\n\
    \            if (currentVal < minVal) {\n                minIndex = i\n      \
    \          minVal = currentVal\n            }\n            i += 1\n        }\n\
    \n        // If there are more values smaller than the smallest even value, pick\
    \ the smallest index value\n        if (minVal != 0) {\n            if (arr.length\
    \ == i) {\n                list = List(minVal)\n            } else {\n       \
    \         list = List(minVal, minIndex)\n            }\n        } else {\n   \
    \         list = Nil\n        }\n        list", "        // your code goes here\n\
    \        if(arr.isEmpty || arr.head == 0l) {\n            return []\n        }\n\
    \        val smalest_value = arr.head \n        val index_arr = arr.toList.map(i\
    \ => (i, i)).toList\n        val smalest_index_arr = index_arr.filter(x => x._1.toLong\
    \ %2 == 0).sortBy(x => x._1)\n        if(smalest_index_arr.length == 1) {\n  \
    \          smalest_index_arr.get._1 \n        } else if(smalest_index_arr.length\
    \ > 1) {\n            smalest_index_arr.toList.head._1\n        }", "        if\
    \ (arr.isEmpty) return List()\n        var smallest_value = 0\n        var smallest_index\
    \ = 0\n        var index = 0\n        var even_value_count = arr.filter(_%2 ==\
    \ 0).length\n        var smalest_value = arr.min\n        while (smallest_value\
    \ == smalest_value && index <  arr.length) {\n            smallest_value += 2\n\
    \            smallest_index  += index\n            index += 1\n        }\n   \
    \     while(even_value_count > 0 && smallest_value == smalest_value && index <\
    \  arr.length) {\n            even_value_count-=arr.filter(_%2 == 0).length\n\
    \            smallest_value += 2\n            smallest_index  += index\n     \
    \       index += 1\n        }\n        if(even_value_count == 0){\n          \
    \  if (smallest_value == smalest_value) return List()\n            else\n    \
    \        List(smalest_value, smallest_index)\n        }\n        else{\n     \
    \       smallest_value += 2\n            smallest_index  += index\n          \
    \  while(smallest_value < smalest_value) {\n                smallest_value +=\
    \ 2\n                smallest_index  += index\n                index += 1\n  \
    \          }\n            List(smalest_value, smallest_index)\n        }", " \
    \       require(arr.length < 10000)\n        val minEvenValueIndex =\n       \
    \     arr.groupBy(x => x % 2).toSeq\n                .map(x => (x._2, x._1.indexOfMin))\n\
    \                .toList\n                .map(x => (x._1, x._2)).minBy(x => x._1)\n\
    \                .getOrElse(List(1L, 0L))\n        val minEvenValue =\n      \
    \      arr.indexOf(minEvenValueIndex.getOrElse(List(1L, 0L)))\n              \
    \  .toLong\n        minEvenValueIndex.getOrElse(List(1L, 0L))", "        arr.foldLeft((0l,\
    \ 0l)) { (a,b) =>\n            val nodeValue = a._1\n            if (nodeValue\
    \ % 2 == 0) {\n                if (b._1 < nodeValue) {\n                    (a,\
    \ b)\n                } else {\n                    (b, nodeValue)\n         \
    \       }\n            } else {\n                (a, b)\n            }\n     \
    \   }._1", "        var result = ListBuffer[Long]()\n        var index_of_smallest_value\
    \ = -1\n\n        // Find the smallest value among all even values, then pluck\
    \ it out\n        for (value <- arr.filter(_ % 2 == 0).toSorted) {\n         \
    \   index_of_smallest_value = arr.indexOf(value)\n            if ((index_of_smallest_value\
    \ < 0) && (index_of_smallest_value < result.length)) {\n                result\
    \ = result ++ List(value)\n            }\n        }\n        return result.toList",
  "      if(arr.isEmpty) List[]\n      else if(arr.head % 2 == 0) arr.takeRight(arr.size\
    \ - 2).minBy(_.toInt).toList\n      else arr.sortBy(_ % 2).takeWhile(_ > 0).reverse.map(_.toInt).minBy(_\
    \ % 2).toList", "        val nodes = (arr.map(_.toLong).sorted).distinct.toList\n\
    \        var pickedNode = null\n        var pickedIndex = 0\n        for (i <-\
    \ 0 until nodes.length) {\n            if (pickedIndex == 0) {\n             \
    \   if (node(i) % 2 == 0) {\n                    pickedNode = i\n            \
    \        pickedIndex = i\n                }\n            } else if (pickedIndex\
    \ != i) {\n                if (node(i) == pickedNode) {\n                    pickedIndex\
    \ = i\n                } else {\n                    pickedNode = pickedIndex\n\
    \                    pickedIndex = i\n                }\n            }\n     \
    \   }\n        pickedNode match {\n            case 0 => List() //if there are\
    \ no even numbers\n            case i => List(pickedNode, pickedIndex)\n     \
    \   }", "        val minIndexMap = arr.zipWithIndex.minBy(_._1) // nodes with\
    \ smallest value\n        arr.filter(node => node.toLong % 2 == 0L).map(node =>\
    \ minIndexMap.getOrElse(node, node))", "        var minEvenValue : Long = 0\n\
    \        var minIndex = 0\n        var evenCount = 0\n        var i = 0\n    \
    \    while (i < arr.length) {\n            if (arr(i) % 2 == 0) {\n          \
    \      evenCount += 1\n                if (minEvenValue < arr(i)) {\n        \
    \            minEvenValue = arr(i)\n                    minIndex = i\n       \
    \         }\n                i += 1\n            }\n            else {\n     \
    \           i += 1\n            }\n        }\n        if (evenCount == 0) {\n\
    \            return List()\n        }\n        else {\n            var evenIndex\
    \ = 0\n            var evenMinValue = 0\n            var evenCount2 = 0\n    \
    \        var evenMinIndex = 0\n            i = 0\n            while (i < arr.length)\
    \ {\n                if (arr(i) % 2 == 0) {\n                    evenCount2 +=\
    \ 1\n                    if (evenMinValue < arr(i)) {\n                      \
    \  evenMinValue = arr(i)\n                        evenMinIndex = i\n         \
    \           }\n                }\n                else {\n                   \
    \ i += 1\n                }\n            }\n            var evenMinIndex = -1\n\
    \            var evenMinValue = -1\n            if (evenCount2 == 1) {\n     \
    \           evenIndex = evenMinIndex\n                evenMinValue = evenMinValue\n\
    \            }\n            else if (evenCount == evenCount2) {\n            \
    \    while (evenIndex < arr.length) {\n                    if (evenIndex == evenMinIndex)\
    \ {\n                        if (evenMinValue < arr(evenIndex)) {\n          \
    \                  evenMinValue = arr(evenIndex)\n                           \
    \ evenMinIndex = evenIndex\n                        }\n                    }\n\
    \                    evenIndex += 1\n                }\n            }\n      \
    \      else if (evenCount == evenCount2 - 1) {\n                while (evenIndex\
    \ < arr.length) {\n                    if (evenIndex == evenMinIndex) {\n    \
    \                    if (evenMinValue < arr(evenIndex)) {\n                  \
    \          evenMinValue = arr(evenIndex)\n                            evenMinIndex\
    \ = evenIndex\n                        }\n                    }\n            \
    \        evenIndex += 1\n                }\n                while (evenIndex <\
    \ arr.length) {\n                    if (evenIndex == evenMinIndex) {\n      \
    \                  if (evenMinValue < arr(evenIndex)) {\n                    \
    \        evenMinValue = arr(evenIndex)\n                            evenMinIndex\
    \ = evenIndex\n                        }\n                    }\n            \
    \        evenIndex += 1\n                }\n            }\n            else if\
    \ (evenCount == evenCount2 - 2) {\n                while (evenIndex < arr.length)\
    \ {\n                    if (evenIndex == evenMinIndex) {\n                  \
    \      if (evenMinValue < arr(evenIndex)) {\n                            evenMinValue\
    \ = arr(evenIndex)\n                            evenMinIndex = evenIndex\n   \
    \                     }\n                    }\n                    evenIndex\
    \ += 1\n                }\n                while (evenIndex < arr.length) {\n\
    \                    if (evenIndex == evenMinIndex) {\n                      \
    \  if (evenMinValue < arr(evenIndex)) {\n                            evenMinValue\
    \ = arr(evenIndex)\n                            evenMinIndex = evenIndex\n   \
    \                     }\n                    }\n                    evenIndex\
    \ += 1\n                }\n                while (evenIndex < ", "        arr.sorted\n\
    \            .map(i => (i , arr indexOf(i)))\n            .filter(_._2.isDefined)\n\
    \            .map { case (index , value) => (value , index) }\n            .head\n\
    \            .getOrElse(List[Long]())", "        // Write your code here\n   \
    \     val smallest = arr.minBy { x => x % 2 }.head\n        val count = arr.count(_\
    \ % 2 == smallest % 2)\n        if (count <= 1) {\n            List(smallest)\n\
    \        } else {\n            arr.filter(x => x % 2 == smallest % 2).minBy {\
    \ x => x }\n        }", "        val len = arr.size\n        if (len == 0) List()\
    \ else {\n            val mVal = arr.min\n            val mIdx = arr.indexWhere(_\
    \ == mVal)\n            val odd = arr.takeWhile(x => x % 2 == 0).toSet\n     \
    \       val smalest = arr.filter(x => x % 2 == 0).min\n            if (odd.isEmpty)\
    \ {\n                if (mIdx >= 0) List(mVal, mIdx) else List()\n           \
    \ } else List(smalest, mIdx)\n        }", "        val evens = arr.filter(_%2\
    \ == 0L)\n        if(evens.isEmpty) List(arr.head)\n        else evens.minBy(x\
    \ => x)._2", "        // write your code here\n        var resultSet = TreeSet[Long]()\n\
    \        var smallest = arr(0) // the value at the lowest index\n        var smallestIndex\
    \ = -1\n        for( i <- 0 until arr.length) {\n            if(arr(i) % 2 ==\
    \ 0){ // if the index is even\n                if(resultSet.contains(smallest))\
    \ { // if we've already found a smallest index for this value\n              \
    \      // return the smallest value with that index\n                    smallestIndex\
    \ = i\n                } else {\n                    resultSet += smallest\n \
    \               }\n            }\n            smallest += arr(i) // add the new\
    \ value to the smallest number\n        }\n        // if we found a smallest index\
    \ for this value, return it\n        if(smallestIndex != -1) {\n            resultSet.contains(smallest)\n\
    \        } else {\n            // otherwise, if we didn't find an even index return\
    \ empty list\n            resultSet.toList == List(false)\n        }", "     \
    \   val evenValues = arr.filter(num => num.toInt % 2 == 0).toSet\n        if(evenValues.isEmpty)\
    \ {\n            List[Long]()\n        }\n        else {\n            val smallestIndex\
    \ = evenValues.min\n            val smallestValue = evenValues(smallestIndex)\n\
    \            List(smallestValue, smallestIndex)\n        }", '        arr.zipWithIndex.sortBy(_._1).takeWhile(n
    => n._2 % 2 == 0).map(_._1).reverse', "      val n = arr.size\n      val minEven\
    \ = arr.minBy { n => n % 2 == 0 }\n      val minEvenIndex = arr.indexWhere(_.toLong\
    \ == minEven)\n      val (smalest_val, smalest_idx) = if (minEvenIndex == -1)\
    \ (minEven, 0) else (minEven, minEvenIndex)\n      (arr.filter(_.toLong == smalest_val).map(_.toLong),\
    \ minEvenIndex)", "        // Your code here\n        val res = mutable.ArrayBuffer.empty[Long]\n\
    \        val size = arr.size\n        arr.zipWithIndex.foreach {\n           \
    \ case (el, index) => {\n                if (el % 2 == 0) {\n                \
    \    res.+=el\n                }\n            }\n        }\n        res.sortWith(_\
    \ < _)\n        res.headOption", "        var index = -1\n        var value =\
    \ arr.head\n        var temp = []\n        arr.foreach(x => {\n            if\
    \ (x % 2 == 0) {\n                if (index == -1) {\n                    index\
    \ = x\n                } else {\n                    if (value < arr[index]) {\n\
    \                        value = arr[index]\n                        index = x\n\
    \                    }\n                }\n            }\n        })\n       \
    \ if (arr.isEmpty) return temp\n        else if (value == arr.head) {\n      \
    \      temp.add(index)\n            return temp\n        } else {\n          \
    \  val result = Array(value, index + 1)\n            temp.add(index)\n       \
    \     return result\n        }", "        var min = arr.min\n        var index\
    \ = arr.indexOf(min)\n        var even_values = arr.filter(_%2 == 0)\n       \
    \ if (arr.isEmpty) {\n            return List().asInstanceOf[List[Long]]\n   \
    \     }\n        while (even_values.nonEmpty) {\n            var even_value =\
    \ even_values.min()\n            if (even_values.contains(even_value)) {\n   \
    \             val current_index = even_values.indexOf(even_value)\n          \
    \      if (current_index < index) {\n                    index = current_index\n\
    \                }\n            }\n            even_values = even_values.filter(_%2\
    \ == 0)\n        }\n        List((min.toLong, index)).asInstanceOf[List[Long]]",
  "        val odd = arr.filter(_%2 == 0).toList\n        val even = arr.filter(_%2\
    \ == 1).toList\n        val smallest = odd.sortWith(_ < _).toList\n        val\
    \ smallest_idx = even.indexOf(smallest(0))\n        List(smallest(0), smallest_idx)",
  "        def getSmallestEvenValue(arr : List[Long]) : List[Long] = {\n         \
    \   val smalest_value = arr(0)\n            var index = 0\n            arr.foreach{\n\
    \                if (it.even) {\n                    val value_to_be_compare =\
    \ it\n                    if (value_to_be_compare < smalest_value) {\n       \
    \                 smalest_value = value_to_be_compare\n                      \
    \  index = arr.indexOf(value_to_be_compare)\n                    }\n         \
    \       }\n            }\n            List(smalest_value, index)\n        }\n\
    \        val smalest_value, smalest_value_and_index = getSmallestEvenValue(arr)\n\
    \        if (arr.isEmpty) {\n            List()\n        } else {\n          \
    \  arr.indexWhere(i => i.even == smalest_value) match {\n                case\
    \ Some(index) => List(smalest_value, smalest_value_and_index, index.toLong)\n\
    \                case None => List()\n            }\n        }", "        var\
    \ index = 0\n        var smallest_even_value = -1\n        var result: List[Long]\
    \ = Nil\n\n        arr.foreach( n => if (n % 2 == 0 && smallest_even_value ==\
    \ -1 || n < smallest_even_value) {\n                if (smallest_even_value ==\
    \ -1) {\n                    smallest_even_value = n\n                    index\
    \ = n\n                } else if (smallest_even_value != -1) {\n             \
    \       smallest_even_value = n\n                    index = smallest_even_value\n\
    \                }\n                else {\n                    smallest_even_value\
    \ = n\n                    index = n\n                }\n            })\n    \
    \    if (smallest_even_value == -1) {\n            return Nil\n        } else\
    \ if (smallest_even_value != -1) {\n            result.append((smallest_even_value,\
    \ index))\n        } else {\n            result.append((smallest_even_value, index))\n\
    \        }\n        return result", "        val indexMap = mutable.Map[Long,\
    \ Long]()\n        val indexMap = mutable.Map[Long, Long]()\n        var evenArr\
    \ : List[Long] = null\n        for(i <- 0 until arr.length) {\n            val\
    \ n = arr(i)\n            if(i == arr.length - 1 || (n % 2 != 0)) {\n        \
    \        evenArr :+ n\n                indexMap.put(arr(i), i)\n            }\
    \ else if((n % 2 == 0) && evenArr == null) {\n                evenArr :+ n\n \
    \               indexMap.put(arr(i), i)\n            }\n        }\n        if(evenArr.isEmpty\
    \ && indexMap.isEmpty) {\n            return List[Long]()\n        } else {\n\
    \            return evenArr.toList.sortBy(x => x).zipWithIndex.toList.filter(x\
    \ => x._2 < x._1).map(x => x._2)\n        }", "        val minValue = arr.min\n\
    \        val maxValue = arr.max\n        val evenNodes = arr.filter(_ % 2 == 0).distinct\n\
    \        val smalestEvenNode = evenNodes.min\n\n        // return an empty list\
    \ if the input array is empty\n        if(arr.isEmpty)\n            return (List[Long]())\n\
    \n        // return the node with the smallest even value if it exists\n     \
    \   if(evenNodes.contains(smalestEvenNode))\n            return (smalestEvenNode,\
    \ arr.indexOf(smalestEvenNode))\n\n        // return an empty list if there is\
    \ no even value in this list\n        if(evenNodes.isEmpty)\n            return\
    \ (List[Long]())\n\n        // find the smallest even value in the remaining nodes\
    \ in the array\n        val indexOfSmallestEven = evenNodes.indexOf(smalestEvenNode)\n\
    \        val smallestValueAtIndex = arr.take(indexOfSmallestEven).min\n\n    \
    \    // return the node at the index\n        return (smallestValueAtIndex, arr.indexOf(smallestValueAtIndex))",
  "        if (arr.length == 0) {\n            return []\n        }\n        var minVal\
    \ : Long = arr(0).toLong\n        var minIndex = 0\n        var index = 0\n  \
    \      for (i <- arr.indices) {\n            var val : Long = arr(i).toLong\n\
    \            if (val < minVal) {\n                minVal = val\n             \
    \   minIndex = i\n            } else if (val == minVal) {\n                if\
    \ (index == minIndex) {\n                    return Array[Long](minVal, minIndex)\n\
    \                }\n                index++\n            }\n        }\n      \
    \  return Array[Long](minVal, minIndex)", "        var smalest_value : Long =\
    \ arr(0)\n        var smalest_index : int = 0\n        var index = 0\n       \
    \ for(elem <- arr) {\n            if(elem.toLong % 2 == 0) {\n               \
    \ if(elem < smalest_value) {\n                    smalest_value = elem\n     \
    \               smalest_index = index\n                }\n                index\
    \ += 1\n            }\n        }\n        if(arr.isEmpty) List(smalest_value,\
    \ smalest_index)\n        else Array(smalest_value, smalest_index)", "       \
    \ val min = arr.min\n        val even = arr.filter(_%2 == 0).sortBy(-_).head\n\
    \        arr.filter(_ != even).filter(i => i % 2 == 0).sortBy(-_).head match {\n\
    \            case i if i % 2 == 0 => List(even, arr.indexOf(i))\n            case\
    \ i if i == min => List(even, arr.indexOf(i))\n            case _ => List()\n\
    \        }", "        val sorted_arr = arr.sortWith( (a,b) => a < b)\n       \
    \ if(sorted_arr.isEmpty) {\n            return List[]\n        }\n        val\
    \ smallest_even_val = sorted_arr(0)\n        val smallest_even_node_index = arr.indexWhere(elem\
    \ => elem == smallest_even_val)\n        val even_node_index = smallest_even_node_index\
    \ + 1\n        if(smallest_even_val % 2 == 0) {\n            // If the smallest\
    \ even value can be divided by 2, then we found a node.\n            // Therefore\
    \ we should pick this node as our result.\n            return List(sorted_arr(even_node_index))\n\
    \        } else {\n            // If the smallest even value is not divided by\
    \ 2, then we need to search\n            // the list again. We pick the smallest\
    \ even value that divided by 2 and add it.\n            // As a result, we'll\
    \ pick the node which has the smallest even value divided by 2.\n            val\
    \ sorted_arr_2 = arr.sortWith( (a,b) => a < b)\n            val smallest_even_val_2\
    \ = sorted_arr_2(0)\n            val smallest_even_node_index_2 = arr.indexWhere(elem\
    \ => elem == smallest_even_val_2)\n            val even_node_index_2 = smallest_even_node_index_2\
    \ + 1\n            val smallest_even_val_2_by_2 = smallest_even_val_2 / 2\n  \
    \          val even_node_index_2_by_2 = even_node_index_2 + 1\n            val\
    \ smallest_even_val_2_by_2_even_node_index = arr.indexWhere(elem => elem == smallest_even_val_2_by_2)\n\
    \            val even_node_index_2_by_2_even_node_index = smallest_even_val_2_by_2_even_node_index\
    \ + 1\n            val even_node_index_2_by_2_even_val = arr[even_node_index_2_by_2_even_node_index]\n\
    \            val smallest_even_val_2_by_2_even_node_index = arr.indexWhere(elem\
    \ => elem == smallest_even_val_2_by_2_even_val)\n            val even_node_index_2_by_2_even_node_index_by_2\
    \ = arr[smallest_even_val_2_by_2_even_node_index_by_2]\n            return List(sorted_arr(even_node_index),\
    \ sorted_arr(even_node_index_by_2), sorted_arr(even_node_index_2_by_2), sorted_arr(even_node_index_2_by_2_even_node_index),\
    \ sorted_arr(even_node_index_2_by_2_even_node_index_by_2))\n        }", "    \
    \    var flag = 0\n        var temp = 0\n        var min = 0\n        var nodes:\
    \ List[Long] = Nil\n        var index: List[Long] = Nil\n        for(i <- 0 to\
    \ arr.length - 1 ){\n            if(arr(i) % 2 == 0){\n                if(arr(i)\
    \ < min || i == 0){\n                    min = arr(i)\n                    index\
    \ = List(i)\n                    temp = 0\n                }else if(arr(i) > min){\n\
    \                    min = arr(i)\n                    index = List(i)\n     \
    \               temp = 1\n                }\n            }\n        }\n      \
    \  nodes = index :: nodes\n        if(arr.length == 0){\n            nodes = Nil\n\
    \        }else if(temp == 0){\n            nodes = Nil\n        }else{\n     \
    \       nodes.sortWith(_ < _)\n        }\n        return nodes", "        var\
    \ smallestOdd : Long = 0\n        var smallestIndex : Int = 0\n        var evenSmallestValue\
    \ : Boolean = false\n        var evenSmallestIndex : Int = 0\n        var oddSmallestValue\
    \ : Boolean = false\n        var oddSmallestIndex : Int = 0\n        var index\
    \ : Int = 0\n        arr.zipWithIndex.foreach { case (node, index) => {\n    \
    \        if (node.toLong % 2l.toLong == 0l.toLong) {\n                if (evenSmallestValue\
    \ == false)\n                    evenSmallestValue = true\n                evenSmallestIndex\
    \ = index\n            }\n            else {\n                if (oddSmallestValue\
    \ == false)\n                    oddSmallestValue = true\n                oddSmallestIndex\
    \ = index\n            }\n        }}\n        if (evenSmallestValue)\n       \
    \     smallestOdd = evenSmallestIndex\n        if (oddSmallestValue)\n       \
    \     smallestOdd = oddSmallestIndex\n        smallestIndex = 0\n        arr.zipWithIndex.foreach\
    \ { case (node, index) => {\n            if (node.toLong % 2l.toLong == 0l.toLong)\
    \ {\n                if (smallestOdd != 0l.toLong && smallestOdd < node.toLong)\n\
    \                    smallestOdd = node.toLong\n                smallestIndex\
    \ = index\n            }\n        }}\n        if (smallestOdd != 0l.toLong)\n\
    \            arr.take(smallestIndex).toList\n        else\n            List()",
  "        def evenOdd(i : Long) : List[Long] = {\n            if (i % 2 == 0) {\n\
    \                List(i.toLong, i.toLong.toInt)\n            }\n            else\
    \ {\n                List(i.toLong, i.toLong.toInt)\n            }\n        }\n\
    \        val arr = arr.toList\n        var smallestValue = arr.head\n        var\
    \ smallestIndex = 0\n        var evenValue = 0\n        var evenIndex = 0\n  \
    \      for(i <- arr.indices) {\n            val listEvenOdd = evenOdd(arr(i))\n\
    \            if (listEvenOdd.head == smallestValue) {\n                evenValue\
    \ = listEvenOdd.head\n                evenIndex = i\n            }\n         \
    \   else {\n                if (evenValue == smallestValue) {\n              \
    \      smallestValue = listEvenOdd.head\n                    smallestIndex = i\n\
    \                }\n            }\n        }\n        List(smallestValue, evenIndex,\
    \ smallestIndex.toLong)", "        val res = mutable.LinkedList[Long]()\n    \
    \    var lowest = arr.min\n        var index = 0\n        var counter = 0\n  \
    \      var curr = 0\n        for (i <- 0 until arr.length) {\n            counter\
    \ += 1\n            if (arr(i).toLong % 2 == 0) {\n                curr = arr(i)\n\
    \                if (lowest < curr) {\n                    lowest = curr\n   \
    \                 index = i\n                }\n            }\n        }\n   \
    \     res += lowest\n        res += index\n        res", "        var index =\
    \ 0\n        var smallestEven = -1\n        var largestEven = -1\n        for(i\
    \ <- 0 until arr.length) {\n            if(arr(i) % 2 == 0) {\n              \
    \  if(smallestEven == -1) {\n                    smallestEven = i\n          \
    \      } else {\n                    if(smallestEven == i)\n                 \
    \       smallestEven = i\n                    else if(smallestEven == 0)\n   \
    \                     smallestEven = -1\n                }\n            } else\
    \ {\n                if(largestEven == -1) {\n                    largestEven\
    \ = i\n                } else {\n                    if(largestEven == i)\n  \
    \                      largestEven = i\n                    else if(largestEven\
    \ == 0)\n                        largestEven = -1\n                }\n       \
    \     }\n        }\n        val ret = List[Long](smallestEven, index).toList\n\
    \        if(ret.isEmpty) {\n            ret.empty\n        } else {\n        \
    \    if(ret(0) != 0 && ret(1) != 0) {\n                val temp = ret(0)\n   \
    \             ret(0) = ret(1)\n                ret(1) = temp\n            }\n\
    \            ret.asInstanceOf[List[Long]]\n        }", "        var evenVal :\
    \ Long = 0\n        var evenIndex : Long = 0\n        var smalest_value : Long\
    \ = 0\n        var smalest_index : Long = 0\n        var minVal : Long = arr(0)\n\
    \        var minIndex : Long = 0\n        for ( val value : Long <- arr ) {\n\
    \            if( value % 2 == 0) {\n                if(evenVal == 0) {\n     \
    \               evenVal = value\n                    evenIndex = minIndex\n  \
    \              } else {\n                    if( value < evenVal ) {\n       \
    \                 evenVal = value\n                        evenIndex = minIndex\n\
    \                    }\n                }\n            } else {\n            \
    \    if(evenVal != 0) {\n                    if( value < evenVal ) {\n       \
    \                 smalest_value = evenVal\n                        smalest_index\
    \ = evenIndex\n                    }\n                    evenVal = 0\n      \
    \              evenIndex = 0\n                }\n            }\n            minVal\
    \ = value \n            if( minVal < minIndex) {\n                minIndex = minVal\n\
    \            }\n        }\n        if( evenVal != 0) {\n            if( evenVal\
    \ < minVal ) {\n                smalest_value = evenVal\n                smalest_index\
    \ = evenIndex\n            }\n            evenVal = 0\n            evenIndex =\
    \ 0\n        }\n        if( minIndex < arr.length) {\n            if( arr.isEmpty\
    \ ) {\n                return []\n            }\n            arr.take(minIndex).foreach(\
    \ elem => arr(minIndex) = elem )\n            arr.drop(minIndex+1)\n        }\n\
    \        arr", "        val evensMap = arr.zipWithIndex.filter{ _._2.toLong %\
    \ 2 == 0 }.map{case (item, index) => (index, _)}.toMap\n        val evensMapKeys\
    \ = evensMap.keys.toList.sortBy(_._1)\n        val smallestIndex = evensMapKeys.head\n\
    \        val smalest_value = evensMap(smallestIndex)._2.toLong\n        if(arr.isEmpty)\
    \ List(smalest_value.toLong)\n        else {\n            val remainingList =\
    \ arr.filterNot(evensMapKeys.contains(_))\n            if(remainingList.isEmpty)\
    \ List(smalest_value.toLong)\n            else {\n                val smallestIndexAndSmalest_value\
    \ = evensMap(remainingList.head).toList\n                smallestIndexAndSmalest_value.sortBy(_._1).take(1).reverse\
    \ :+ smalest_value.toLong\n            }\n        }", "        var evenVals: List[Long]\
    \ = arr.filter(f => (f % 2) == 0).sortBy(f => f).toList\n        var index = arr.indexOf(0)\n\
    \        var temp = 0\n        var res = [0, index]\n        while (evenVals.nonEmpty\
    \ && (evenVals.head % 2) == 0) {\n            temp = evenVals.head\n         \
    \   evenVals = evenVals.tail\n            index = index + 1\n            res =\
    \ [temp, index]\n        }\n        if (evenVals.isEmpty) res\n        else res",
  "        var smallest_even_value : Long = 0\n        var smallest_even_index : Long\
    \ = 0\n        for (i <- arr.indices) {\n            if (arr(i) %2 == 0) {\n \
    \               if(smallest_even_index < i) smallest_even_index = i\n        \
    \        smallest_even_value += arr(i)\n            }\n        }\n        if (smallest_even_value\
    \ == 0) return List()\n        return List(smallest_even_value, smallest_even_index)",
  "      val map = new mutable.HashMap[Long, Long]()\n      for (i <- 0 until arr.length)\n\
    \        map += (arr(i) -> i)\n      val result = arr.toList.sortBy(-_).filter(_\
    \ % 2 == 0).takeWhile(_ % 2 == 0)\n      val index = result.indexOf(0)\n     \
    \ if(index == -1)\n        []\n      else\n        (result - index).map(_ - index).toList",
  "        val nm = arr.zipWithIndex.toMap\n        var smallest = arr.head\n    \
    \    var smallestIdx = 0\n\n        for (idx <- 0 until arr.length) {\n      \
    \      if (nm.get((arr(idx) >> 1) & 1).toOption.isDefined) {\n               \
    \ if (smallest > arr(idx)) {\n                    smallest = arr(idx)\n      \
    \              smallestIdx = idx\n                }\n            }\n        }\n\
    \        List(smallest, smallestIdx)", "        if (arr.isEmpty)\n           \
    \ return []\n        // sort the list to find the smallest even\n        var minVal\
    \ : Long = arr.head\n        var minIndex : Int = 0\n        for (i <- 0 until\
    \ arr.length)\n            if (arr(i) % 2 == 0 && arr(i) < minVal)\n         \
    \       minVal = arr(i)\n                minIndex = i\n\n        // then find\
    \ the node with smallest even value\n        var result : List[Long] = List(minVal)\n\
    \        if (minIndex > 0) {\n            // use the index\n            result\
    \ = result :+ arr(minIndex).toLong\n        } else {\n            // the smallest\
    \ even number in the array is 0\n            result = result :+ 0l.toLong\n  \
    \      }\n        result", "        def even(l: Long) = l%2 == 0\n        val\
    \ lsmalest = arr.filter(even).sortBy(x => x).head\n        arr.filter(even).indexOf(lsmalest)",
  "        val arr = arr.toList\n        if(arr.isEmpty) Nil\n        else if(arr.head.isMultipleOf(2))\
    \ arr filter { _%2==0 }\n        else {\n            val result = Nil\n      \
    \      val minValue = arr.head\n            val minIndex = 0\n            val\
    \ minEvenValue = 0\n            for(i <- 0 until arr.length) {\n             \
    \   if(arr(i).isMultipleOf(2)) minEvenValue = arr(i)\n                if(arr(i)\
    \ < minValue) minValue = arr(i)\n                if((arr(i) & 1) == 0) minIndex\
    \ = i\n            }\n            if(minEvenValue != 0){\n                result\
    \ += (minValue -> minIndex)\n            }\n            result\n        }", " \
    \       val evens = arr.filter(x => x % 2 == 0)\n        val smalest_val = evens.min\n\
    \        val smalest_idx = evens.indexOf(smalest_val)\n        if (smalest_idx\
    \ == 0) evens.toList\n        else if (smalest_idx == evens.length) evens.take(evens.length-1)\n\
    \        else evens.take(smalest_idx).drop(smalest_idx).map(x => (x, smalest_idx)).toList",
  "        val result = arr.zipWithIndex.filter(_._2 % 2 == 0).map(_._1).sortWith((a,\
    \ b) => math.signum(a) - math.signum(b))\n        if (result.length > 0) {\n \
    \           result.headOption\n        } else {\n            Array[Long]()\n \
    \       }", "      val smalest_even = arr.filter(e => e % 2 == 0).min\n      val\
    \ smalest_index = (arr(arr.indexWhere(e => e % 2 == 0)) - smalest_even).toInt\n\
    \      smalest_even :: smalest_index :: arr.filterNot(e => e % 2 == 0).map(e =>\
    \ e - smalest_even).toList", "        val ans = mutable.ArrayBuffer.empty[Long]\n\
    \        val evens = arr.filter(_ % 2 == 0).zipWithIndex.sortBy(-_._1).takeWhile(_._1\
    \ <= arr.length).map(_._1)\n        if(evens.nonEmpty) {\n            ans += evens.head\n\
    \            ans += evens.takeWhile(_._1 < arr.length).map(arr(_))\n        }\n\
    \        ans", "        // Your code here\n        val result = new mutable.LinkedList[Long]\n\
    \        arr.foreach(i => {\n            if(i % 2 == 0 && i % 2 != 0) {\n    \
    \            result.add(i)\n            }\n        })\n        result.toList",
  "        val evens = arr.filter(x => (x % 2) == 0)\n        val smalest_value =\
    \ evens.min\n        var i = 0\n        var out: List[Long] = null\n        var\
    \ index = -1\n        while(i < evens.length) {\n            val elm = evens(i)\n\
    \            if(elm == smalest_value) {\n                if(out == null) {\n \
    \                   out = arr.filter(_ != smalest_value)\n                   \
    \ index = i\n                } else if(out.length == 0) {\n                  \
    \  out = arr.filter(_ != smalest_value)\n                    index = i\n     \
    \           } else if(elm < out.min) {\n                    out = arr.filter(_\
    \ != smalest_value)\n                    index = i\n                } else if(elm\
    \ < out(index)) {\n                    index = i\n                } else {\n \
    \                   index -= 1\n                }\n            } else if(elm <\
    \ smalest_value) {\n                out = arr.filter(_ != smalest_value)\n   \
    \             index = i\n            } else if(elm < out(index)) {\n         \
    \       index = i\n            } else {\n                index -= 1\n        \
    \    }\n            i += 1\n        }\n        if(out == null) out = new List\n\
    \        out", "        var idx = 0\n        var even_value = 0\n        val result\
    \ = arr.zipWithIndex.filter { case (x, y) => if (x.toInt%2 == 0) x.toInt >= x.toInt/2\
    \ else false }\n        var smallest_value = min(arr)\n        val smalest_value\
    \ = arr(arr.indexOf(smallest_value)).toLong\n        smallest_value = arr(arr.indexOf(smallest_value)).toInt\n\
    \        val idx = arr.indexOf(smallest_value)\n        while (idx<arr.length\
    \ && arr(idx).toInt%2==0) {\n            idx+=1\n        }\n        val even_value_idx\
    \ = arr.indexOf(smallest_value)\n        if (even_value_idx>=even_value){\n  \
    \          val even_value_idx = arr.indexOf(smallest_value)\n            val even_value_idx\
    \ = arr.indexOf(smallest_value)\n            even_value = arr(even_value_idx).toLong\n\
    \        }\n        if (arr.isEmpty){\n            return List();\n        }\n\
    \        if (even_value==0){\n            if (idx<arr.length){\n             \
    \   val even_value_idx = arr.indexOf(smallest_value)\n                even_value\
    \ = arr(even_value_idx).toLong\n            }\n            if (smallest_value\
    \ >= arr.indexOf(arr.max)){\n                val even_value_idx = arr.indexOf(smallest_value)\n\
    \                even_value = arr(even_value_idx).toLong\n            }\n    \
    \    }\n        if (even_value<arr.length){\n            even_value = arr(even_value_idx).toLong\n\
    \        }\n        if (even_value<arr.length){\n            even_value = arr(even_value_idx).toLong\n\
    \        }\n        if (arr.length>0){\n            if (even_value>=0){\n    \
    \            if (even_value<arr.length){\n                    even_value = arr(even_value_idx).toLong\n\
    \                }\n            }\n            if (even_value<arr.length){\n \
    \               even_value = arr(even_value_idx).toLong\n            }\n     \
    \       if (even_value>=0){\n                if (even_value<arr.length){\n   \
    \                 even_value = arr(even_value_idx).toLong\n                }\n\
    \            }\n        }\n        if (arr.length>0){\n            if (even_value>=0){\n\
    \                if (even_value<arr.length){\n                    even_value =\
    \ arr(even_value_idx).toLong\n                }\n            }\n            if\
    \ (even_value<arr.length){\n                even_value = arr(even_value_idx).toLong\n\
    \            }\n            if (even_value>=0){\n                if (even_value<arr.length){\n\
    \                    even_value = arr(even_value_idx).toLong\n               \
    \ }\n            }\n        }\n        result(even_value).toLong", "        //\
    \ Your code here\n        if(arr.isEmpty) List();\n        val result = arr.foldLeft(List[Long]())((res,\
    \ node) => {\n            val index = res.indexOf(node);\n            if(index\
    \ >= 0 && node.toInt % 2 == 0) res :+ node;\n            else res\n        });\n\
    \        if(result.isEmpty) List()\n        else result.sortBy(l => l).toList\
    \ // get the smallest even value and index", "        var minEvenVal = 0\n   \
    \     var minIndex = 0\n        var oddValFound = false\n        var evenValFound\
    \ = false\n        var foundVal = Long.MinValue\n        arr.foreach(elem => if\
    \ (!evenValFound && elem % 2 == 0) {\n            evenValFound = true\n      \
    \      foundVal = elem\n        }\n        else if (!oddValFound && elem % 2 !=\
    \ 0) {\n            oddValFound = true\n            foundVal = elem\n        }\n\
    \        else if (evenValFound && oddValFound && (elem < minEvenVal)) {\n    \
    \        minEvenVal = elem\n            minIndex = arr.indexOf(foundVal)\n   \
    \     }\n        else if (evenValFound && (elem < minEvenVal)) {\n           \
    \ minEvenVal = elem\n            minIndex = arr.indexOf(foundVal)\n        }\n\
    \        else if (oddValFound && (elem < minEvenVal)) {\n            minEvenVal\
    \ = elem\n            minIndex = arr.indexOf(foundVal)\n        }\n        else\
    \ {\n            minEvenVal = 0\n            minIndex = 0\n        }\n       \
    \ return arr.drop(minIndex)", "        require(arr.size <= 10000)\n        require(arr.forall(_\
    \ >= 0))\n        require(arr.forall(_ % 2 == 0))\n\n        var minEl = -1\n\
    \        var minIndex = -1\n        var evenIndex = -1\n        for((elm, index)\
    \ <- arr.zip(0 until arr.length)){\n            if(elm % 2 == 0){\n          \
    \      if(minEl < 0 || elm > minEl)\n                    minEl = elm\n       \
    \         minIndex = index\n            }else{\n                if(minIndex <\
    \ 0 || elm < minEl)\n                    minIndex = index\n            }\n   \
    \     }\n        val res = List(minEl, minIndex)\n        arr filter (_ != minEl)\
    \ filter (_ != minIndex)", "        var smalest_value = arr.head\n        var\
    \ smallest_index = 0\n        var smallest_value = arr.head\n        var index_of_smallest_value\
    \ = 0\n\n        for(i <- 0 until arr.length - 1) {\n            if(arr.apply(i)\
    \ % 2 == 0) {\n                if(smallest_value > arr.apply(i)) {\n         \
    \           index_of_smallest_value = i\n                    smallest_value =\
    \ arr.apply(i)\n                }\n            }\n        }\n        smalest_value\
    \ = smallest_value\n        smallest_index = index_of_smallest_value\n       \
    \ arr.drop(smallest_index)\n\n        return arr.take(smallest_index)", "    \
    \    val minIndex : mutable.Map[Long, Long] = mutable.Map[Long, Long]()\n    \
    \    val minIndexVal : Long = Long.MaxValue\n        arr.foreach(e => minIndex(e)\
    \ match {\n            case 0 => minIndexVal = 0\n            case v => minIndexVal\
    \ > v match {\n                case true => minIndexVal += 1\n               \
    \ case false => minIndexVal = v\n            }\n        })\n\n        val evenValues\
    \ : mutable.Set[Long] = mutable.Set()\n        arr.foreach(e => evenValues(e)\
    \ match {\n            case true => evenValues += e\n            case false =>\
    \ evenValues += 0\n        })\n        if (evenValues.size == 0) Nil\n       \
    \ else {\n            evenValues.find(ev => ev % 2 == 0)\n        }", "      \
    \  var max_index = 0;\n        var max_value = arr(0);\n        var result: List[Long]\
    \ = Nil\n        for(i <- arr.indices) {\n            val curr = arr(i)\n    \
    \        if(i % 2 == 0) {\n                if (curr < max_value) {\n         \
    \           max_value = curr\n                    max_index = i\n            \
    \    }\n            } else {\n                if (curr == max_value) {\n     \
    \               max_index = i\n                }\n            }\n        }\n \
    \       if(arr.isEmpty || max_index == 0) {\n            result = []\n       \
    \ } else {\n            result = arr.take(max_index + 1)\n        }\n        result",
  "        def getSmallestEven(arr: List[Long], index: Int): Option[Long] = {\n  \
    \          var smallestEven = None\n            for(i <- 0 until arr.length) if(arr(i)\
    \ % 2 == 0) smallestEven = Some(arr(i))\n            if(smallestEven.isDefined)\
    \ Some(smallestEven.get)\n            else getSmallestEven(arr.tail, index+1)\n\
    \        }\n        getSmallestEven(arr.takeWhile(_ != 0), 0)", "        val ans\
    \ = arr.groupBy(x => (x % 2 == 0)).maxBy(x => x._2)\n        ans.headOption.toList.sortBy(x\
    \ => x._2)", "        if (arr.isEmpty) List[Long]()\n        val ans = arr.sortBy(_\
    \ % 2)\n        ans.head % 2 == 0 match {\n            case true  => ans.reverse.drop(1).reverse\n\
    \            case false => ans\n        }", "        var index = 0\n        var\
    \ index_max = 0\n        var smalest_value = 0\n        var smalest_value_count\
    \ = 0\n        var smalest_value_count_index = 0\n        for (i <- arr.indices)\
    \ {\n            if (arr(i) % 2 == 0) {\n                smalest_value = arr(i)\n\
    \                smalest_value_count = smalest_value_count + 1\n             \
    \   if (smalest_value_count > smalest_value_count_index) {\n                 \
    \   index = i\n                    smalest_value_count_index = smalest_value_count\n\
    \                }\n            }\n        }\n        if (smalest_value_count\
    \ == 0) {\n            return Nil\n        }\n        var smalest_value_index\
    \ = index\n        var smalest_value_index_count = 0\n        for (i <- arr.indices)\
    \ {\n            if (arr(i) % 2 == 0) {\n                if (smalest_value_count\
    \ == smalest_value_index_count) {\n                    if (arr(i) == smalest_value)\
    \ {\n                        return arr(index..i)\n                    }\n   \
    \             }\n                smalest_value_index = i\n                smalest_value_index_count\
    \ = smalest_value_index_count + 1\n            }\n        }\n        return Nil"]
stop_tokens:
- "\n    }\n"
