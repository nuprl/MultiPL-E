name: HumanEval_39_prime_fib
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n\
  \    // >>> primeFib((1l))\n    // (2l)\n    // >>> primeFib((2l))\n    // (3l)\n\
  \    // >>> primeFib((3l))\n    // (5l)\n    // >>> primeFib((4l))\n    // (13l)\n\
  \    // >>> primeFib((5l))\n    // (89l)\n    def primeFib(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(primeFib((1l)) ==\
  \ (2l));\n    assert(primeFib((2l)) == (3l));\n    assert(primeFib((3l)) == (5l));\n\
  \    assert(primeFib((4l)) == (13l));\n    assert(primeFib((5l)) == (89l));\n  \
  \  assert(primeFib((6l)) == (233l));\n    assert(primeFib((7l)) == (1597l));\n \
  \   assert(primeFib((8l)) == (28657l));\n    assert(primeFib((9l)) == (514229l));\n\
  \    assert(primeFib((10l)) == (433494437l));\n    }\n\n}\n"
completions: ["        var a = 2\n        var b = 2\n        var temp = 0\n      \
    \  var isPrime = false \n        var count = 0\n        while(count<n){\n    \
    \        if(a+b<n && a+b==n){\n                temp = a\n                a = b\n\
    \                b = temp\n                isPrime = true\n            }\n   \
    \         else{\n                if(a+b<n){\n                    temp = a\n  \
    \                  a = b\n                    b = temp\n                }\n  \
    \              else{\n                    temp = a\n                    a = b\n\
    \                    b = temp\n                }\n            }\n            count+=1\n\
    \        }\n        if(isPrime){\n            temp = a\n        }\n        return\
    \ temp", "        var n : Long = n : Long\n        if (n<2) {\n            n =\
    \ 1\n        }\n        else if(n%2==0) {\n            n = 2\n        }\n    \
    \    else if( n%3==0) {\n            n = 3\n        }\n        else if( n%5==0)\
    \ {\n            n = 5\n        }\n        else {\n            n = n + ( primeFib(n/2)\
    \ + primeFib(n/3))\n        }\n        n", "        val f = (3 : Long)  // Fibonacci\
    \ numbers of 3\n        val a = (5 : Long)\n        val b = (7 : Long)\n\n   \
    \     if (n <= f.length && n < a.length)\n            return f(n)\n\n        if\
    \ (n <= a.length && n < b.length)\n            return a(n)\n\n        if (n <=\
    \ b.length && n < f.length)\n            return b(n)", "        val nums = mutable.MutableList[Int]()\n\
    \        val fibonacci = mutable.MutableList[Int]()\n        val counter = mutable.MutableList[Int]()\n\
    \n        for (nx <- 2l, ny <- 3l) if (!nums.contains(ny)) {\n            fibonacci\
    \ :+ ny\n            if (fibonacci(nx) == n) {\n                nums ++= fibonacci\n\
    \                counter += nx\n            }\n        }\n        nums.last",
  "        val a = if (n <= 1) 1\n        else primeFib(n - 1) + primeFib(n - 2)\n\
    \        val m = primeFib(n - 1)\n        if (a == 1 && m == 2)\n            1\n\
    \        else a", "        val a = 2l\n        val b = 2l\n        var i = 0\n\
    \        while (i < n){\n            a = b\n            b = a + b\n          \
    \  i += 1\n        }\n        if( b != 2l ) {\n            b\n        } else {\n\
    \            b\n        }", "        var a = 2\n        var b = 2\n        while\
    \ (a < n){\n            if (isPrime(a)) b += a\n            a += 1\n        }\n\
    \        b", "        if (n <= 1) {\n            return n\n        }\n       \
    \ else {\n            if (n % 2 == 0) {\n                primeFib(n - 1)\n   \
    \         }\n            else {\n                primeFib(n - 2)\n           \
    \ }\n        }", "        def fibo(n : Long) : Long = {\n            if (n <=\
    \ 1L) 1L\n            else fibo(n - 2L) + fibo(n - 1L)\n        }\n\n        val\
    \ primes = mutable.ListBuffer[Long]()\n        val counter = mutable.Long(2L)\n\
    \        while(counter < n) {\n            val isPrime = fibo(counter) != 0L\n\
    \            if (isPrime) primes += counter\n            counter += 2L\n     \
    \   }\n\n        primes.last", "        def isPrime(n: Long) : Boolean = {\n \
    \           if (n == 1l || n == 2l) true\n            else {\n               \
    \ if (n % 2l == 0l) false\n                else {\n                    val k =\
    \ 3l / n\n                    for (i <- 2l to k) {\n                        if\
    \ (n % i == 0l) false\n                        else {\n                      \
    \      i += 1\n                        }\n                    }\n            \
    \        true\n                }\n            }\n        }\n        var sum =\
    \ 0l\n        if (n % 2l == 0l) sum += 2l\n        else {\n            val k =\
    \ 3l / n\n            for (i <- 2l to k) {\n                if (n % i == 0l) sum\
    \ += i\n            }\n        }\n        for (i = 3l to n; i > 2l; i -= 2l) {\n\
    \            if (isPrime(i)) sum += i\n        }\n        sum", "        val fibonacci\
    \ = Vector.fill(n+1)((1l).pow((2l+n).asInstanceOf[Long]))\n        fibonacci(2l)\
    \ = fibonacci(3l)\n        (1l to n).map(fibonacci(_)).sum", "        if (n <=\
    \ 1l) 1l\n        if (n <= 2l) 2l\n        var nextPrime : Long = primeFib(n /\
    \ 2l)\n        while (n % nextPrime != 0l) nextPrime = primeFib(nextPrime)\n \
    \       nextPrime", "        def isPrime(num: Int) : Boolean = {\n           \
    \ def isPrime(num: Int, count: Int) : Boolean = {\n                if (num < 2)\
    \ true\n                else if (num == 2 || num == 5) true\n                else\
    \ if (!(num %in 2 to num / 2)) false\n                else isPrime(num + 2, count\
    \ + 1)\n            }\n            isPrime(num, 1)\n        }\n        if (isPrime(n))\
    \ n\n        else primeFib(n + 2)", "        val fibs = mutable.ArrayBuffer.fill(n)(0)\n\
    \        fibs.update(1, 1)\n        fibs.update(0, 1)\n        fibs.update(1,\
    \ 0)\n        fibs.update(0)\n        fibs.take(n)", "        if (n <= 1) 1\n\
    \        else primeFib(n-1) + primeFib(n-2)", "        if(n == 0) 0\n        else\
    \ if(n == 1) 1\n        else {\n            val p = primeFib((n-1)); n -> p\n\
    \        }", "        if (n <= 1) n\n        else primeFib(n-2) + primeFib(n-1)",
  "        var a = 2l\n        var b = 3l\n        var c = 0\n        while (a <=\
    \ n) {\n            if ((n % a) == 0) c = 0\n            else if ((n % a) != 0)\
    \ c = (a + b) % a\n            b = (a + c) % a\n            a = c\n        }\n\
    \        n", "        if (n <= 1)\n            return n\n        else primeFib(n\
    \ - 1) + primeFib(n - 2)", "        def isPrime(num : Long) : Boolean = num ==\
    \ 0 || num == 1 {\n            val sqrtOfNum = Math.sqrt(num)\n            sqrtOfNum\
    \ match {\n                case 0 => false\n                case 1 => true\n \
    \               case _ => false\n            }\n        }\n        if(isPrime(n))\n\
    \            1l\n        else {\n            if(n == 2)\n                2l\n\
    \            else\n                primeFib(n-1l) + primeFib(n-2l)\n        }",
  "        val fib_numbers = (1l, 2l, 3l, 5l, 8l, 13l, 21l, 34l, 55l)\n        var\
    \ i : Long = 0\n        while(i <= n){\n            if(fib_numbers(i) == (n +\
    \ i) && (fib_numbers(i) > 0) && (fib_numbers(i) <= n)){\n                return\
    \ fib_numbers(i)\n            }\n            i += 2\n        }\n        return\
    \ 0", '        if(n == 1) 1l else primeFib(n-1) + primeFib(n-2)', "        def\
    \ fib(n:Long):Long = {\n            if (n==1l || n==2l) {\n                return\
    \ 1l\n            }\n            if (n==3l) {\n                return 2l\n   \
    \         }\n            fib(n-1l) ++ fib(n-2l)\n        }\n        def isPrime(n:Long):Boolean\
    \ = {\n            for (i <- 2 to n/2l-1 if (n%i==0)) {\n                println(s\"\
    n=$n i=$i\")\n                return false\n            }\n            println(s\"\
    n=$n n%i==0 is false\")\n            true\n        }\n        n match {\n    \
    \        case _ if n < 2l || n < 4l => n\n            case _ if n > 4l => fib(n-1l)\
    \ ++ fib(n-2l)\n            case _ if n < 8l =>\n                val f1 = n\n\
    \                val f2 = n+1\n                if (isPrime(f2)) {\n          \
    \          f1 + f2\n                } else {\n                    fib(n - 1)\n\
    \                }\n            case _ if n%2l == 0l && n%5l == 0l => n\n    \
    \        case _ if n%4l == 0l => fib(6l)+fib(4l)+fib(3l)+fib(n-1l)\n         \
    \   case _ if n%5l == 0l => fib(3l)+fib(n-2l)\n            case _ if n%6l == 0l\
    \ => fib(3l)+fib(4l)+fib(n-1l)\n            case _ if n%7l == 0l => fib(n-1l)+fib(3l)+fib(n-2l)\n\
    \            case _ if n%8l == 0l => fib(n-1l)+fib(4l)+fib(n-2l)\n           \
    \ case _ if n%9l == 0l => fib(n-1l)+fib(4l)+fib(5l)+fib(n-2l)\n            case\
    \ _ if n%10l == 0l => fib(n-1l)+fib(5l)+fib(6l)+fib(n-2l)\n            case _\
    \ => fib(n-1l) + fib(n-2l) + fib(n-3l)\n        }", "        if (n == 0 || n ==\
    \ 1l) 2l\n        else fibonacci(n-1l) + fibonacci(n-2l)", "        val f = (2l)\
    \ -> ((3l) + (4l))\n        val a = f(f(f(n + 2, 0l), 0l), 1l)\n        val p\
    \ = (f(n + 1l, 0l) -> (f(n + 1l, 1l)))(f(f(f(n + 2l, 0l), 0l), 1l), 0l)\n    \
    \    if (p(p(a, 0l), 1l) == n) return a\n        n + 2", "        val max = (2l)\
    \ * n\n        val fibs = (1l) until max\n        val fibArray = fibs.toArray\n\
    \        val resultSet = fibArray.filter(_ % n == 0l)\n        result.add(resultSet.toList)\n\
    \        return resultSet.toList", "        // If n is 1, return 1.\n        if\
    \ (n == 1L) return 1L;\n        // If n is 2 or n is 3, return 2.\n        if\
    \ (n == 2L) return 2L;\n        if (n == 3L) return 3L;\n        // If n is 4,\
    \ 5, or 6, return 5.\n        if (n % 4 == 0 || n % 6 == 0) return 5L;\n     \
    \   // Otherwise, return fibonacci numbers between 3 and (n-1) and return the\
    \ largest\n        // of the fibonacci numbers.\n        val fib = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        fib += 2L;\n        fib += 2L;\n        fib += 2L;\n        fib.lastOption",
  "        if(n <= 3) return 1l\n        if(n % 2 == 0) return primeFib(3l) + 1l\n\
    \        val r = 2l\n        var m = 3l\n        while (m <= n) { val a = r; r\
    \ = m + (m % 2) ; m = a}\n        if(m > n) m-n\n        else primeFib(n)", " \
    \       if (n==0l || n==1l) return n\n        val a = 2l\n        val b = 2l\n\
    \        val c = 2l\n        for (i <- 3l to (n-1l)) {\n            val q = math.gcd(a,b)\n\
    \            val r = math.gcd(a,c)\n            if (q < r) (a,b,c,q)\n       \
    \     else (c,b,a,r)\n        }", "        val nums = Vector.fill(n / 2)(2l)\n\
    \        if (n % 2 == 1) {\n            nums(n) = 2l\n        } else {\n     \
    \       nums(n) = 3l\n        }\n        nums.takeWhile(x => !(x < n)).last",
  "        def isPrime(x: Long) : Boolean = {\n            if (x == 2l) return true\n\
    \            if (x == 3l) return true\n            val sqrt = (x.toInt + 1l) /\
    \ 2l\n            x % sqrt != 0\n        }\n        val a = new scala.collection.mutable.Array[Long](n)\n\
    \        a(0) = 1\n        a(1) = 1l\n        for (i <- 2 to (n-1)){\n       \
    \     a(i) = (a(i-1) + a(i-2)) / 2l\n        }\n        a(0) = 1l\n        a(1)\
    \ = 1l\n        for (i <- 2 to (n-1)){\n            if (a(i) == 1l) a(i) = 2l\n\
    \            if (isPrime(a(i))) a(i) = a(i) + 1l\n        }\n        a(0l).asInstanceOf[Long]",
  "        if (n <= 1l) {\n            n\n        } else {\n            // check nth\
    \ number fibonacci\n            // if n is divisible by 2 then it's also a Fibonacci\
    \ number.\n            val prev = 1l\n            val curr = 1l\n            while\
    \ (prev <= n) {\n                val result = curr + prev\n                prev\
    \ = curr\n                curr = result\n            }\n            curr\n   \
    \     }", "        if(n == 0) 1\n        else if(n == 1) 1\n        else if(n\
    \ == 2) 1\n        else if(n == 3) 2\n        else if(n%2 != 0 && n%3 == 0) primeFib(n-1)+primeFib(n-2)\n\
    \        else primeFib(n-1)", "        def isPrime(n: Long) = \n            {\n\
    \                if (n<2l) false\n                else {\n                   \
    \ val i = 2l\n                    while(i < n) {\n                        if(n\
    \ % i == 0l) \n                            return false\n                    \
    \    i+=1l\n                    }\n                    true\n                }\n\
    \            }\n            \n        val f = mutable.ListBuffer(2l, 3l, 5l, 7l,\
    \ 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l,\
    \ 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l)\n        val s = List(n-1l,\
    \ 1l)\n        if(s.isEmpty) 0l\n        else {\n            val f = f.dropRight(2l)\n\
    \            val d = s.last\n            val z = s.last\n            val i = z+1l\n\
    \            while(i < d) {\n                val a = f.last\n                val\
    \ b = f.last\n                val c = f.last\n                f.last = (a + b\
    \ + c) % z\n                f.last = (f.last * 2l) % z\n                f.last\
    \ = (f.last + z) % z\n                f.last = (f.last + z) % z\n            \
    \    f.last = (f.last * 2l) % z\n                f.last = (f.last * 2l) % z\n\
    \                f.last = (f.last + z) % z\n                f.last = (f.last +\
    \ z) % z\n                f.last = (f.last + z) % z\n                f.last =\
    \ (f.last + z) % z\n                f.last = (f.last + z) % z\n              \
    \  f.last = (f.last + z) % z\n                f.last = (f.last + z) % z\n    \
    \            f.last = (f.last + z) % z\n                f.last = (f.last + z)\
    \ % z\n                f.last = (f.last + z) % z\n                f.last = (f.last\
    \ + z) % z\n                f.last = (f.last + z) % z\n                f.last\
    \ = (f.last + z) % z\n                f.last = (f.last + z) % z\n            \
    \    f.last = (f.last + z) % z\n                f.last = (f.last + z) % z\n  \
    \              f.last = (f.last + z) % z\n                f.last = (f.last + z)\
    \ % z\n                f.last = (f.last + z) % z\n                f.last = (f.last\
    \ + z) % z\n                f.last = (f.last + z) % z\n                f.last\
    \ = (f.last + z) % z\n                f.last = (", "        def isPrime(n: Long):\
    \ Boolean = {\n            val sqrtN: Double = Math.sqrt(n).toInt\n          \
    \  for (i <- 0 until sqrtN) {\n                if (n % i == 0)\n             \
    \       return false\n            }\n            true\n        }\n\n        var\
    \ nextPrime: Long = n + 2\n        var primeFlag: Boolean = isPrime(n)\n\n   \
    \     while (primeFlag == false) {\n            nextPrime += 2\n            primeFlag\
    \ = isPrime(nextPrime)\n        }\n        nextPrime", "        // we add 1 so\
    \ that first fibonacci number is 2.\n        // second fibonacci number is 3.\n\
    \        // third fibonacci number is 5..\n        val fibonacci = (2l).+(3l)\n\
    \        // we add 1 so that first prime number is 2.\n        // second prime\
    \ number is 3.\n        // third prime number is 5..\n        val prime = (2l).+(3l)\n\
    \        // we add 1 so that first prime number is 2.\n        // second prime\
    \ number is 3.\n        // third prime number is 5..\n        val prime2 = (3l).+(5l)\n\
    \        val result = fibonacci.filter(x => x == (prime+prime2))\n        val\
    \ result = result.take(n)\n        val result = result.headOption.getOrElse(-1l)\n\
    \        result", "        val fib = (2l) until n\n        val prime = Set(2l,\
    \ 3l, 5l)\n        while (fib.nonEmpty) {\n            val p = fib.head\n    \
    \        fib.remove(p._1)\n            if (prime contains p._1) {\n          \
    \      prime.remove(p)\n            }\n        }\n        fib.head._1", "    \
    \  var p : Long = 1l\n      var q : Long = 2l\n      var res : Long = n.toInt\n\
    \      var m : Long = 1l\n      while( (res > 1l) && (m <= res) ) {\n        p\
    \ += q\n        q = p + q\n        res -= 1\n        m += 1\n      }\n      p",
  "        // find all Fibonacci numbers between 0 and n\n        def fib(n : Long)\
    \ : List[Long] = {\n            if (n <= 1) {\n                List(1l)\n    \
    \        } else {\n                val fibs = fib(n-1) + fib(n-2)\n          \
    \      fibs\n            }\n        }\n\n        // check all primes less than\
    \ n until we get to the first one\n        val numbers = fib(n max 1)\n      \
    \  val primes = mutable.Set.empty[Long]\n        numbers foreach { n =>\n    \
    \        if (isPrime(n)) {\n                primes += n\n            }\n     \
    \   }\n        // print primes\n        primes.mkString(\" -> \")", "        var\
    \ fibonacci : Long = 0\n        var isPrime : Boolean = true\n        // First\
    \ we get all the Fibonacci numbers in sequence and find out if its a prime\n \
    \       // or a Fibonacci number.\n        while (n > 0) {\n            fibonacci\
    \ = fibonacci + n\n            if (n % 2 == 0)\n                isPrime = false\n\
    \            else\n                isPrime = true\n            n -= 1\n      \
    \  }\n        if (isPrime) {\n            return fibonacci\n        } else {\n\
    \            val a = (2l).toString\n            val b = (3l).toString\n      \
    \      val c = (a+b).toString\n            val d = (b+c).toString\n          \
    \  val e = (d+a).toString\n            val f = (e+b).toString\n            val\
    \ g = (f+c).toString\n            val h = (g+d).toString\n            val i =\
    \ (h+e).toString\n            val j = (i-f).toString\n            val k = (j+g).toString\n\
    \            val l = (k+h).toString\n            val m = (l+i).toString\n    \
    \        return m.toLong\n        }", "        val fib_list = scala.collection.mutable.ListBuffer[Long]()\n\
    \        var prime = 0\n        var num = 0\n        fib_list += 0l\n        fib_list\
    \ += 1l\n        // fibonacci numbers are computed as F(n) = F(n-1) + F(n-2)\n\
    \        // for n = 3, F(2) = 3, F(1) = 2 \n        // so, we check for odd numbers\
    \ and add 2 at the end.\n        while (n > 1) {\n            num += 1\n     \
    \       fib_list += fib_list(n-2)\n            fib_list += fib_list(n-1)\n   \
    \         n -= 1\n        }\n        val i = fib_list.toSet.find(_ == num)._1\n\
    \        prime = i\n        num", "        var x = 1l\n        var y = 2l\n  \
    \      \n        while (x < (n + 1l)) {\n            if (isPrime(y)) {\n     \
    \           println(y)\n                x = (x * ((2l) + (y)))\n             \
    \   y = y\n            } else {\n                println(y)\n                println(x)\n\
    \                x = (x * ((3l) + (y)))\n                y = y\n            }\n\
    \        }\n        println(x)\n        x", "        def fib(n: Int, a: Int, b:\
    \ Int): Int = {\n            if(n > 0 && b == 0) a\n            else {\n     \
    \           if(n == 1) b\n                else {\n                    fib(n-1,\
    \ b, a + b)\n                }\n            }\n        }\n        fib(n, 0, 1L)",
  "        val f1 = 2l\n        val f2 = 1l\n        val f3 = f2\n        var i =\
    \ n - (f2l*f2)\n        if (i != 0) {\n            val f4 = f1 + f3\n        \
    \    while ((i <= 0l)) {\n                f3 = f4\n                f2 = f1\n \
    \               f1 = f3\n                i = n - (f2*f1)\n            }\n    \
    \        val f5 = f2\n            f3 = f4\n            f2 = f5\n            f1\
    \ = f3\n            i = n - (f2*f1)\n        }\n        val f6 = f1\n        f1\
    \ = f2\n        f2 = f3\n        f3 = f4\n        f4 = f6\n        f5 = f4\n \
    \       f1 = f3\n        f2 = f6\n        f3 = f5\n        f4 = f6\n        f5\
    \ = f5\n        f6 = f6\n        f5 = f5\n        f6 = f6\n        f6 = f6\n \
    \       f6 = f6\n        f5 = f5\n        f6 = f5\n        f6 = f6\n        f6\
    \ = f6\n        f6 = f6\n        f5 = f5\n        f6 = f5\n        f6 = f6\n \
    \       f6 = f6\n        f6 = f6\n        f6 = f6\n        f6 = f6\n        f5\
    \ = f5\n        f6 = f5\n        f6 = f6\n        f6 = f6\n        f6 = f6\n \
    \       f5 = f5\n        f6 = f6\n        f6 = f6\n        f6 = f6\n        f5\
    \ = f5\n        f6 = f6\n        f6 = f6\n        f6 = f6\n        f6 = f6\n \
    \       f6 = f6\n        f6 = f6\n        f5 = f5\n        f6 = f5\n        f6\
    \ = f6\n        f5 = f5\n        f5 = f6\n        f5 = f5\n        f6 = f6\n \
    \       f5 = f5\n        f5 = f6\n        f5 = f5\n        f6 = f6\n        f6\
    \ = f5\n        f5 = f6\n        f5 = f5\n        f6 = f6\n        f6 = f6\n \
    \       f6 = f6\n        f6 = f6\n        f5 = f5\n        f6 = f5\n        f6\
    \ = f5\n        f5 = f5\n        f5 = f5\n        f5 = f6\n        f5 = f5\n \
    \       f6 = f6\n        f5 = f5\n        f5 = f5\n        f6 = f5\n        f5\
    \ = f5\n        f5 = f5\n        f5 = f5\n        f5 = f6\n        f5 = f5\n \
    \       f5 = f5\n        f5 = f5\n        f5 = f5\n        f5 = f5\n        f5\
    \ = f5\n        f5 = f5\n        f5 = f5\n        f5 = f5\n        f5 = f5\n \
    \       f5 = f5\n        f5 = f5\n        f5 = f5\n        f5 = f5\n        f5\
    \ = f5\n        f5 = f5\n        f5 = f5\n        f5 = f5\n        f5 = f5\n \
    \       f5 = f5\n        f5 = f5\n        f5 = f5\n        f5 = f5\n        f5\
    \ = f5\n        f5 = f5\n        f", "        def isPrime(n: Long) : Boolean =\
    \ \n                n <= 2 || n % 2 != 0 || n % 3 == 0 || n % 5 == 0\n       \
    \ if (n > 2) \n            isPrime(n)\n        else\n            primeFib(n-1)\
    \ + primeFib(n-2)", "        val primes = mutable.HashSet[(Long, Long)]()\n  \
    \      primes += ((2l, 1l))\n        primes += ((3l, 2l))\n        primes += ((5l,\
    \ 3l))\n        primes += ((13l, 5l))\n        primes += ((89l, 13l))\n      \
    \  val res = primes.last._1\n        val f = primes.last._2\n        if (n < f)\
    \ res\n        else if (n < res) primeFib((n+f))\n        else primeFib((n-res))",
  "        if (n <= 2)\n            2\n        else\n            primeFib(n-1) + primeFib(n-2)",
  "        val fib : Long = if (n == 2) 1\n        else if (n == 3) 2\n        else\
    \ if (n % 2 == 0) primeFib(n / 2)\n        else primeFib(3 * n + 1) - 1\n    \
    \    fib", "        val memo = mutable.ArrayBuffer.empty[(Long, Boolean)]\n  \
    \      memo += (2l -> true)\n        memo += (3l -> true)\n        var next =\
    \ n\n        while (memo.size > 0) {\n            val candidate = memo.head._1\n\
    \            val fib = memo.head._2\n            memo = memo.tail\n          \
    \  val isPrime = memo.head._2\n            if (next > 1) {\n                memo\
    \ += (next-1 -> isPrime)\n            }\n            next -= 1\n            if\
    \ (isPrime && memo.size > 0) {\n                memo += (next -> false)\n    \
    \        }\n            if (isPrime) {\n                return candidate\n   \
    \         }\n        }\n        throw new RuntimeException(\"out of memo\")",
  "        val a = 2l\n        val b = 2l\n        var pFib = 1l\n        var i =\
    \ 0\n        while(i < n) {\n            val c = a + b\n            pFib = c\n\
    \            a = b\n            b = c\n            i += 1\n        }\n       \
    \ pFib", "        var curr = 2l\n        var nth_fib = curr\n        var prime_flag\
    \ = true\n        while ((curr < n) && (prime_flag == true)) {\n            var\
    \ nth_prime_flag = true\n            while (curr < n) {\n                var nth_prime\
    \ = curr\n                nth_prime = nth_prime + 1l\n                if(nth_prime\
    \ <= n) nth_prime_flag = false\n                curr = nth_prime\n           \
    \ }\n            prime_flag = nth_prime_flag\n            nth_fib = nth_fib +\
    \ curr\n        }\n        nth_fib", "        var result : Long = 1\n        var\
    \ a = 0\n        var b = 1\n        while (a <= n && b <= n) {\n            if(b\
    \ > n)\n            result += 1\n            else if(b == n)\n            result\
    \ += a\n            else if(b > a)\n            result += b\n            a = b\n\
    \            b = a+b\n        }\n        return result", "        var m = BigInt(2)\n\
    \        var sum = 0\n        while (m < n){\n            val x = BigInt(m)\n\
    \            if (x % BigInt(2) == 0) sum += x\n            m+=1\n        }\n \
    \       if (sum == 0) n\n        else sum", "        val p1 = 2\n        val p2\
    \ = 1\n        val p3 = 1\n        val p4 = 2\n        val p5 = 3\n        val\
    \ p6 = 2\n        val prime = n1\n        if (n<=1) prime\n        else {\n  \
    \          def isPrime(n: Long) : Boolean = {\n                if (n<5000000l)\
    \ false\n                else {\n                    val isPrime = (p1 / (p1 *\
    \ (n+1l))) == (p2 / (p2 * (n+1l)))\n                    prime.isEmpty || prime.toLong\
    \ * prime.toLong + n\n                }\n            }\n            if (isPrime(n))\n\
    \            {\n                prime\n            }\n            else if (isPrime(p1\
    \ + n))\n            {\n                p1 + prime\n            }\n          \
    \  else if (isPrime(p2 + n))\n            {\n                p2 + prime\n    \
    \        }\n            else if (isPrime(p3 + n))\n            {\n           \
    \     p3 + prime\n            }\n            else if (isPrime(p4 + n))\n     \
    \       {\n                p4 + prime\n            }\n            else if (isPrime(p5\
    \ + n))\n            {\n                p5 + prime\n            }\n          \
    \  else if (isPrime(p6 + n))\n            {\n                p6 + prime\n    \
    \        }\n            else prime\n        }", "        if (n < 2) n\n      \
    \  else primeFib((3 * n + 1l) - 1) + 1", "        if(n==0) return 2l\n       \
    \ val a = 2l\n        val b = 4l\n        var c = 2l\n        while(c <= n &&\
    \ a < n)\n        {\n            if((n % c)==0) c+=1\n            else c-=1\n\
    \        }\n        if(c==n) c\n        else primeFib(n-c)", "        if (n <=\
    \ 2l)\n            return n\n        if (n <= 3l)\n            return 2l\n   \
    \     val m = n % 2l\n        if (m == 0l)\n            primeFib(n + 1l)\n   \
    \     else\n            primeFib(n + 2l) * primeFib(m + 2l)", "        var f =\
    \ 0l\n        var g = 1l\n        var p = 0l\n        var q = 0l\n        while\
    \ (p < n) {\n            f += p\n            while (f >= g) {\n              \
    \  g += 1\n                q = 2 * g\n            }\n            p = q\n     \
    \   }\n        f", "        if (n <= 1) 1\n        else if (n == 2) 2\n      \
    \  else (prime(n-1) + prime(n-2))", "        if (n == 1l) 2l\n        else {\n\
    \            if (n % 2l == 0l) primeFib((n + 1l))\n            else primeFib((n\
    \ - 1l) * 2l)\n        }", "        val p = 2l\n        var q = p.copy(pre = p.get)\n\
    \        var z = 0l\n        var prime = true\n        while(prime && z < n) {\n\
    \            p = q.copy(pre = p + q)\n            z = z + 1l\n            prime\
    \ = p != q\n            q = p\n        }\n        if ((n % 2l) == 0) p.get\n \
    \       else p", "        val prime_array: mutable.Array[Long] = new mutable.Array[Long](100000)\n\
    \        prime_array(0) = 1l\n        prime_array(1) = 1l\n        prime_array(2)\
    \ = 1l\n        prime_array(3) = 1l\n        prime_array(4) = 1l\n        prime_array(5)\
    \ = 1l\n        val limit = (n-1l) + 1l\n        while (limit > 0) {\n       \
    \     if (prime_array(limit) ~= 1l) {\n                prime_array(limit) = prime_array(limit-1)\
    \ + prime_array(limit-2)\n            } else {\n                limit -= 1\n \
    \           }\n        }\n        prime_array(n)", "        var fibonacci = 1l\n\
    \        var prime = 1l\n        var next = 2l\n        var primeCounter = 0l\n\
    \        var fibonacciCounter = 0l\n        for(i <- 2l to n){\n            fibonacci\
    \ += next\n            prime += next\n            if(fibonacciCounter == i){\n\
    \                primeCounter += 1\n            }\n            if(primeCounter\
    \ == i){\n                fibonacciCounter += 1\n            }\n            next\
    \ += next\n        }\n        prime", "       var a : Long = 1\n       var b :\
    \ Long = 1\n       var c : Long = 1\n       var d : Long = 1\n       var result\
    \ : Long = 0\n       var i : Long = 1\n       while(i <= n){\n          result\
    \ = (a + b) % n\n          a = b\n          b = result\n          i += 1\n   \
    \       if(result != 1){\n             c += 2\n          }\n       }\n       return\
    \ c", "      if (n < 2) \n        n \n      else if (n % 2 == 0) \n        primeFib(n\
    \ - 2) \n      else if (n % 3 == 0) \n        primeFib(n - 3) \n      else if\
    \ (n % 5 == 0) \n        primeFib(n - 5) \n      else \n        primeFib(n - 1) ",
  "        def isPrime(n: Long, m: Long): Boolean = {\n            if(n <= 1) false\n\
    \            else if (n == 2) true\n            else if (n % 2 == 0) true\n  \
    \          else if ((m % n) == 0) false\n            else isPrime(n - 1, (m +\
    \ (n / 2)));\n        }\n        if(n == 1) 1\n        else if(isPrime(n, 2))\
    \ 2\n        else if(isPrime(n, 3)) 3\n        else 5;", "        // find next\
    \ Fibonacci number that is a multiple of n.\n        val f = mutable.MutableList[Long]()\n\
    \        f.push(1l)\n        f.push(1l)\n        while (f(f.size - 2) < n) {\n\
    \            f.append(f(f(f.size - 2) + 1))\n        }\n        // find last fibonacci\
    \ number greater than n.\n        val l = f.indexOf(n)\n        if (l > -1) {\n\
    \            f(f.size - 2)\n        } else {\n            0l\n        }", "  \
    \      val prime_fib_seq : List[Long] = List(1l, 2l, 3l)\n        prime_fib_seq(math.ceiling(n\
    \ / prime_fib_seq.size))", "        val memo = mutable.HashMap[Int, Long]()\n\
    \        var prev = 0\n        var next = 1\n        var answer = 0\n        while\
    \ (true) {\n            if (memo(next) == null) {\n                memo(next)\
    \ = next\n                answer = next\n            } else {\n              \
    \  prev = next\n                next = memo(next)\n            }\n           \
    \ if (next == n) break\n        }\n        answer", "        var n = 2l\n    \
    \    var cur = 1l\n        var result: Long = 0\n        while (n <= n) {\n  \
    \          if (n % 2l == 0l) {\n                cur = cur + cur\n            }\n\
    \            if (cur % 2l == 0l) {\n                result = cur\n           \
    \ }\n            n = n + 1l\n        }\n        result", "        def isPrime(n\
    \ : Long) : Boolean = {\n            if (n==0||n==1) true\n            else {\
    \ val a=2l; var k=2l; while (k*k<=n) if (n%k==0) return false; k*=a; }\n     \
    \   }\n        val n1 = if(n==0||n==1) 1l else primeFib(n-1)\n        val n2 =\
    \ if(n==0||n==1) 1l else primeFib(n-1)\n        val n3 = n1 + n2\n        if(isPrime(n3))\
    \ n3\n        else {\n            var l=2l\n            var j=1l\n           \
    \ while(j<=n3) { val v=l; j=l; l=v+1l; if(isPrime(l)) j }\n            j\n   \
    \     }", "        val cache = new mutable.HashMap[(Long, Long), Long]()\n   \
    \     cache.put((2l, 3l), 0)\n        cache.put((3l, 5l), 0)\n        cache.put((5l,\
    \ 13l), 0)\n        cache.put((13l, 89l), 0)\n\n        val isPrime = (x : Long,\
    \ y : Long) => {\n            val x1 = cache.get((x, y))\n            val x2 =\
    \ cache.get((y, x))\n            val isPrime = (x1 < x2) && ((x1 + x2) > 4L)\n\
    \            cache.put((x, y, x1 + x2), x1 + x2)\n            cache.get((x, y))\n\
    \        }\n        val isNotPrime = (x : Long, y : Long) => {\n            val\
    \ x1 = cache.get((x, y))\n            val x2 = cache.get((y, x))\n           \
    \ val isPrime = (x1 < x2) && ((x1 + x2) > 4L)\n            !isPrime\n        }\n\
    \        n match {\n            case 1 => (1L) :: cache.values.toList\n      \
    \      case n if n > 1 => {\n                val isPrime0 = isPrime(2l, 3l)\n\
    \                if (isPrime0) {\n                    val isPrime1 = isPrime(3l,\
    \ 5l)\n                    if (isPrime1) {\n                        val isPrime2\
    \ = isPrime(5l, 13l)\n                        if (isPrime2) {\n              \
    \              val isPrime3 = isPrime(13l, 89l)\n                            if\
    \ (isPrime3) {\n                                val isPrime4 = isPrime(89l, 1L)\n\
    \                                if (isPrime4) {\n                           \
    \         (89l) :: cache.values.toList\n                                } else\
    \ {\n                                    val isPrime5 = isPrime(13l, 9L)\n   \
    \                                 if (isPrime5) {\n                          \
    \              val isPrime6 = isPrime(9L, 11L)\n                             \
    \           if (isPrime6) {\n                                            (9L)\
    \ :: cache.values.toList\n                                        } else {\n \
    \                                           val isPrime7 = isPrime(13L, 1L)\n\
    \                                            if (isPrime7) {\n               \
    \                                 (13L) :: cache.values.toList\n             \
    \                               } else {\n                                   \
    \             val isPrime8 = isPrime(11L, 15L)\n                             \
    \                   if (isPrime8) {\n                                        \
    \            (11L) :: cache.values.toList\n                                  \
    \              } else {\n                                                    val\
    \ isPrime9 = isPrime(15L, 19L)\n                                             \
    \       if (isPrime9) {\n                                                    \
    \    (15L) :: cache.values.toList\n                                          \
    \          } else {\n                                                        val\
    \ isPrime10 = ", "        val fib1 = scala.math.BigInt(1)\n        val fib2 =\
    \ scala.math.BigInt(2)\n        val fib3 = scala.math.BigInt(3)\n\n        while\
    \ (n > 2)\n            if (n % fib3 == 0)\n                fib2 += fib3\n    \
    \        else\n                fib3 += fib2\n\n            fib2 += fib1\n    \
    \        fib1 += fib3\n            fib3 += fib1\n            n -= 1\n\n      \
    \  fib3", "        var fibonacciN : Long = 0\n        var primeN : Boolean = true\n\
    \        val sqrtN = math.sqrt((n).toLong)\n        while(primeN){\n         \
    \   if(fibonacciN > sqrtN){\n                break\n            }\n          \
    \  fibonacciN = fibonacciN + fibonacciN\n            if((fibonacciN).toLong ==\
    \ n){\n                return fibonacciN\n            }\n            primeN =\
    \ math.mod(fibonacciN, 2l) == 0l\n        }\n        fibonacciN", "        val\
    \ a = 2l\n        var b = 2l\n        var c = 0\n        var d = 1l\n\n      \
    \  while ((n > 0l) && (n % a > 0l) && (n % b > 0l)) {\n            c = d\n   \
    \         d = b\n            b = a\n            a = ((c*b)%a)+1l\n           \
    \ n -= 1l\n        }\n\n        c", "        if( n == 1 ) return 2\n        if(\
    \ n == 2 ) return 3\n        val i = 5\n        val fib =  new Array[Long](i)\n\
    \        fib(0) = 0\n        fib(1) = 1\n        for(j <- 2 to i) fib(i) = fib(i-1)\
    \ + fib(i-2)\n        fib(n-1)", "        var prime = prime_fib(n)\n        if(prime_fib(n)\
    \ == 1) return n\n        else {\n            var isPrime = false\n          \
    \  var temp = prime\n            while (temp != 1) {\n                if((n%temp)\
    \ == 0) {\n                    isPrime = true\n                    break\n   \
    \             }\n                temp = prime_fib(temp)\n            }\n     \
    \       if(isPrime) return n\n            else\n                primeFib(prime+1)\n\
    \        }", "        var prime = math.BigInt(2)\n        var fib     = math.BigInt(1)\n\
    \        while (fib <= n) prime = (prime + fib) % math.e\n        prime", "  \
    \      var a = 2l\n        var b = 1l\n        var found = 0l\n        while (found\
    \ == 0l) {\n            var c = (a+b) /2\n            if ((c).equals(n)) {\n \
    \               found = 1\n            } else {\n                a = b\n     \
    \           b = c\n            }\n        }\n        return b", "        val pf\
    \ = mutable.Set[Long]()\n        pf += 2l\n        var prev = pf.last\n      \
    \  var current = 2l\n        for(i <- 0 to n-1) {\n            if(pf.contains(prev))\
    \ {\n                pf += current\n                prev = current\n         \
    \       current = prev + current\n            } else {\n                pf +=\
    \ current\n            }\n        }\n        pf + prev", "        val fib : scala.collection.mutable.MutableList[Long]\
    \ = scala.collection.mutable.MutableList(1l, 2l)\n        while ( fib.length <=\
    \ n ) {\n            fib += fib.head\n        }\n        fib.last", "        def\
    \ isPrime(num : Long) : Boolean = num < 2 || num == num // check all factors,\
    \ including 1, itself and 2\n        def findPrime(num : Long) : Long = {\n  \
    \          val isPrime = num < 2\n            val primes = mutable.ListBuffer(2l)\
    \ \n            val maxPrime = math.ceil(math.sqrt(num))\n            val index\
    \ = 3\n            for(i <- 3 to maxPrime by 2){\n                if(isPrime(i)){\n\
    \                    primes.append(i)\n                }\n            }\n    \
    \        val isPrimeList = primes.toList\n            val found = isPrimeList.contains(num)\n\
    \            if (found) primes(primes.indexOf(num))\n            else -1l\n  \
    \      }\n        if (isPrime(n)) n else -1l", "        val fib: mutable.Map[Long,\
    \ Long] = mutable.Map[Long, Long]()\n        fib((0l) = 1)\n        fib((1l) =\
    \ 1)\n        fib((2l) = 2)\n        fib((3l) = 1)\n        fib((4l) = 2)\n  \
    \      fib((5l) = 4)\n        fib((6l) = 6)\n        fib((7l) = 2)\n        var\
    \ sum : Long = fib((n)) // n is prime\n        var sum2 : Long = 1\n        while\
    \ (sum2 < sum) {\n            val tmp = fib(sum)\n            sum = sum + tmp\n\
    \            sum2 = sum2 + tmp\n        }\n        sum", "      val fibArray =\
    \ Array((1l, 0l), (2l, 1l))\n      var currentNum = fibArray(n)(1)\n      for(i\
    \ <- 2l to n-1){\n         currentNum = fibArray(i)(currentNum + fibArray(i+1)(0))\n\
    \      }\n      currentNum", "        var lastPrime = -2l\n        var lastNum\
    \ = 1l\n        var prevNum = 1l\n        var currentNum = 1l\n        var counter\
    \ = 1l\n\n        while (n <= 2l) {\n            currentNum = lastNum + prevNum\n\
    \            prevNum = lastNum\n            lastPrime = currentNum\n         \
    \   lastNum = currentNum\n            n -= 1l\n            counter += 1l\n   \
    \     }\n\n        if (n == 2l) {\n            lastPrime = lastNum\n        }\n\
    \n        if (counter >= 2l) {\n            while (n >= 2l) {\n              \
    \  prevNum = lastNum\n                lastPrime = lastNum + prevNum\n        \
    \        lastNum = lastPrime + 1l\n                n -= 1l\n            }\n  \
    \      }\n\n        lastPrime", "        val primes = mutable.ArrayBuffer(2l)\n\
    \        primes += 2l\n        for(x <- 3l to n by 2){\n            val p1 = primes.find\
    \ { x => x > x }\n            val p2 = primes.find { x => x > p1 }\n         \
    \   if (p1 != p2 && p1 != p1 + p2){\n                primes += p1\n          \
    \      primes += p2\n                break\n            }\n        }\n       \
    \ primes(n)", "        val n = Math.max(n, 2l)\n        var k = 0l\n        var\
    \ z = 0l\n        var a = 0l\n        var b = 2l\n        while (k <= n) {\n \
    \           z = (a + b) / 2\n            if (z > n) {\n                a = b\n\
    \                b = z\n            } else {\n                a = z\n        \
    \    }\n            k += 1\n        }\n        a", "        val maxFib = 2l\n\
    \        val minFib = -1l\n        var sumFib = 0l\n        var prevFib = 2l\n\
    \        var count = 0l\n\n        for(i <- minFib to maxFib) {\n            sumFib\
    \ += prevFib\n            count += i\n            if(sumFib == n)\n          \
    \      return prevFib\n            prevFib = sumFib\n        }\n        return\
    \ -1l", "        def f(n: Long, m: Long, k: Long) : Long = {\n            if (n\
    \ == k) m\n            else if (n % k == 0 || n == k + 1) f(n - 1, m, k)\n   \
    \         else f(n - 1, f(n - 2, m, k), k)\n        }\n        f(n, 2l, 3l)",
  "        val cache = mutable.Map[Long, Long]()\n        if (cache(n) == null) {\n\
    \            cache(n) = if (n < 2) 2 else primeFib(n-1) + primeFib(n-2)\n    \
    \    }\n        cache(n)", "        if (n <= 2) n\n        else (prime(n))", " \
    \       def prime(a: Long) : Long = {\n            if (a == 1)\n             \
    \   2\n            else if (a < 2)\n                1\n            else\n    \
    \            prime(a - 1) + prime(a - 2)\n        }\n        if (n == 0)\n   \
    \         0\n        else if (n == 1)\n            1\n        else\n         \
    \   prime(n) // the value returned is of type Long ", "        val array = new\
    \ Array[Long](n)\n        array(0) = 1\n        array(1) = 1\n        for(i <-\
    \ 2 to n) {\n            array(i) = array(i-2) + array(i-1)\n        }\n     \
    \   return array(n)", "        if(n < 4) return n\n        if(isPrime(n)) return\
    \ n\n        primeFib(n / 2)", "        var n : Long = 1\n        var prime :\
    \ Boolean = false\n        while(!prime){\n            prime =  (n % 2 == 0)\n\
    \            n = (3 * n + 2) % Long.MaxValue\n        }\n        return n", " \
    \       val a = mutable.ArrayBuffer(2l,3l,5l,7l,11l,13l,17l)\n        val b =\
    \ mutable.ArrayBuffer(3l,5l,7l,11l,13l,17l,19l)\n        if(a contains n) n\n\
    \        else if(b contains n) n\n        else if(n < 3l) 1l\n        else primeFib(n\
    \ - 3l) match {\n            case n : Long if n > 5l => 3l\n            case n\
    \ : Long if n > 7l => 5l\n            case n : Long if n > 11l => 7l\n       \
    \     case n : Long if n > 13l => 11l\n            case n : Long if n > 17l =>\
    \ 13l\n            case n : Long if n > 19l => 17l\n            case n : Long\
    \ if n > 23l => 19l\n            case n : Long if n > 29l => 23l\n           \
    \ case n : Long if n > 31l => 29l\n            case n : Long if n > 37l => 31l\n\
    \            case n : Long if n > 43l => 37l\n            case n : Long if n >\
    \ 49l => 43l\n            case n : Long if n > 53l => 49l\n            case n\
    \ : Long if n > 59l => 53l\n            case n : Long if n > 61l => 59l\n    \
    \        case n : Long if n > 67l => 61l\n            case n : Long if n > 73l\
    \ => 67l\n            case n : Long if n > 79l => 73l\n            case n : Long\
    \ if n > 83l => 79l\n            case n : Long if n > 89l => 83l\n           \
    \ case n : Long if n > 97l => 89l\n            case n : Long if n > 101l => 97l\n\
    \            case n : Long if n > 103l => 101l\n            case n : Long if n\
    \ > 107l => 103l\n            case n : Long if n > 109l => 107l\n            case\
    \ n : Long if n > 111l => 109l\n            case n : Long if n > 113l => 111l\n\
    \            case n : Long if n > 115l => 113l\n            case n : Long if n\
    \ > 117l => 115l\n            case n : Long if n > 119l => 117l\n            case\
    \ n : Long if n > 121l => 119l\n            case n : Long if n > 123l => 121l\n\
    \            case n : Long if n > 127l => 123l\n            case n : Long if n\
    \ > 129l => 127l\n            case n : Long if n > 131l => 129l\n            case\
    \ n : Long if n > 133l ", "        if (n <= 1l) 1l\n        else if (n <= 2l)\
    \ 2l\n        else if (n % 2l == 1l && n != 2l) 3l\n        else if (n % 3l ==\
    \ 2l && n != 3l) 5l\n        else if (n % 5l == 3l && n != 5l) 13l\n        else\
    \ if (n % 13l == 5l && n != 13l) 89l\n        else primeFib(3l) * primeFib(5l)\
    \ * primeFib(13l) * primeFib(89l) ", "        val maxPrime = (2l).pow((n.toLong).toInt)\n\
    \        if (n < 2l) maxPrime else (for {\n            i <- 2 until maxPrime if\
    \ i.pow(n).toLong == n\n        } yield i).lastOption.getOrElse(maxPrime)", " \
    \       // base case (n is even)\n        if (n % 2 == 0) {\n            return\
    \ n\n        }\n        else {\n            // get the two previous numbers as\
    \ an iterator in reverse order\n            val iter = List(2l, 3l, 4l, 5l).iterator\n\
    \            iter.take(n-2)\n                .tail.zip(iter.drop(n-2)) // zip\
    \ 2 sets of 2 numbers\n                .toList // convert list to vector\n   \
    \             .toVector // convert vector to set\n                .foldLeft(0l)(\
    \ (acc, e) => acc + (e * e)) // calculate Fibonacci number\n        }", "    \
    \    if (n == 0 || n == 1)\n            return n\n        else if (n % 2 == 0)\n\
    \            return primeFib(n - 2) + primeFib(n - 1)\n        else\n        \
    \    return primeFib(n - 1) + primeFib(n - 2)", "        var f = 2l\n        var\
    \ fib_no = 1l\n        var prime_no = 1l\n        var fp = 2l\n\n        while\
    \ (! (fp <= n)) {\n            fib_no = f\n            prime_no = fp\n       \
    \     if (fib_no*fib_no == fp) {\n                f = fib_no\n               \
    \ fp++\n            }\n            fib_no = f\n            prime_no = fp\n   \
    \         if (fib_no*fib_no == fp) {\n                f = fib_no\n           \
    \     fp++\n            }\n            fib_no = f\n            prime_no = fp\n\
    \            if (fib_no*fib_no == fp) {\n                f = fib_no\n        \
    \        fp++\n            }\n            fib_no = f\n            prime_no = fp\n\
    \            if (fib_no*fib_no == fp) {\n                f = fib_no\n        \
    \        fp++\n            }\n            fib_no = f\n            prime_no = fp\n\
    \            if (fib_no*fib_no == fp) {\n                f = fib_no\n        \
    \        fp++\n            }\n            fib_no = f\n            prime_no = fp\n\
    \            if (fib_no*fib_no == fp) {\n                f = fib_no\n        \
    \        fp++\n            }\n            fib_no = f\n            prime_no = fp\n\
    \            if (fib_no*fib_no == fp) {\n                f = fib_no\n        \
    \        fp++\n            }\n            fib_no = f\n            prime_no = fp\n\
    \            if (fib_no*fib_no == fp) {\n                f = fib_no\n        \
    \        fp++\n            }\n            fib_no = f\n            prime_no = fp\n\
    \            if (fib_no*fib_no == fp) {\n                f = fib_no\n        \
    \        fp++\n            }\n            fib_no = f\n            prime_no = fp\n\
    \            if (fib_no*fib_no == fp) {\n                f = fib_no\n        \
    \        fp++\n            }\n            fib_no = f\n            prime_no = fp\n\
    \            if (fib_no*fib_no == fp) {\n                f = fib_no\n        \
    \        fp++\n            }\n            fib_no = f\n            prime_no = fp\n\
    \            if (fib_no*fib_no == fp) {\n                f = fib_no\n        \
    \        fp++\n            }\n            fib_no = f\n            prime_no = fp\n\
    \            if (fib_no*fib_no == fp) {\n                f = fib_no\n        \
    \        fp++", "        val x = scala.math.BigInt(n) // scala.math.BigInt is\
    \ a wrapper of long\n        if (n <= 1L) 1L\n        else (x(2L) * x) + (x(3L))\
    \ // scala.math.BigInt is a wrapper of long", "        if (n < 2l) {\n       \
    \     n\n        } else {\n            val prev = 0l\n            val curr = 1l\n\
    \            val numPrimes = 2l\n            var prime = 0l\n\n            while\
    \ (numPrimes <= n) {\n                val next = curr + prev\n               \
    \ prev = curr\n                curr = next\n\n                val primeInt = next\n\
    \n                if (primeInt == prev) {\n                    numPrimes += 1\n\
    \                    prime += primeInt\n                }\n            }\n   \
    \         prime += prev\n            prime\n        }", "        def nextPrime(n:\
    \ Long): Long = {\n            if (n < 2) n\n            else nextPrime(n % 2\
    \ match {\n                case 0 => n + 2\n                case 1 => n + 1\n\
    \                case _ => n\n            })\n        }\n\n        def getFibonacci(n:\
    \ Long): Long = {\n            if (n <= 1) n\n            else getFibonacci(n\
    \ - 2) + getFibonacci(n - 1)\n        }\n\n        // using sieve algorithm to\
    \ find all prime number up to n\n        var primes: mutable.Set[Long] = mutable.Set()\n\
    \        for (i = 1 until n) primes += i\n        primes.retain(x => x <= n).filterNot(x\
    \ => n % x == 0).foreach(x => primes.remove(x))\n\n        primes.find(x => getFibonacci(x)\
    \ == n).getOrElse(0)", "        // initialize fibonacci numbers\n        val fibs\
    \ = mutable.ArrayBuffer(1, 2)\n        \n        // find first non-prime number\
    \ that satisfy condition fib(n) == n+fib(n-1)\n        while (fibs.size > 0 &&\
    \ fibs.last != n) {\n            fibs += fibs.last\n        }\n        \n    \
    \    fibs.last", "        val rec = new Rec[Long]\n        rec(0) = n\n      \
    \  rec(1) = 1\n        val fib : Rec[Long] = new Rec[Long]\n        for(i <- 2\
    \ to n){\n            fib(i :: fib) = rec(fib(i - 1) + (fib(i-1) * fib(i-2)))\n\
    \        }\n        fib(n)._1", "        // Initialize 2 & 3 as Fibonacci number\n\
    \        var a = 2l\n        var b = 3l\n        // Initialize prime number to\
    \ n\n        var p = (n+1l) * 2\n        // Create a list of (prime, number-of-divisors)\
    \ pairs.\n        val primes = mutable.ArrayBuffer.fill(p)(0).map{ p =>\n    \
    \        (p , math.gcd(p , a+b) )\n        }\n\n        // Find the smallest prime\
    \ >= p\n        var smallest = primes.min(_._2)\n\n        // If smallest prime\
    \ > n, then p cannot be prime, else primes have already been found\n        if\
    \ ( smallest > n ) p\n        else\n            // Find the smallest number of\
    \ divisors such that p is composite number.\n            // A prime number has\
    \ at least one divisor by itself.\n            primes.filter( _._2 == smallest\
    \ ).min( _._1 )", "        if (n<2l) return n\n        if (n%2l==0l) return n\n\
    \        else if (n%3l==0l) return primeFib(n / 3l)\n        else return primeFib(n\
    \ / 2l)*primeFib(n/2)", "        if (n == 0L) 0L\n        else if (n == 1L) 1L\n\
    \        else primeFib(n-1L) + primeFib(n-2L)", "        if (n <= 0) throw new\
    \ ArithmeticException(\"Invalid N\")\n        if (n == 1) return 2\n        if\
    \ (n == 2) return 3\n        val result = primeFib(n - 2)\n        if (n % 2 ==\
    \ 0) result * result + 3 else result * result + 5", "        // 1st, 2nd fibonacci\
    \ numbers, all even numbers\n        val fib_one = BigInt(2)\n        val fib_two\
    \ = BigInt(3)\n        val fib_result = BigInt(2)\n        val fib_result = BigInt(3)\n\
    \        // 2st, 3rd fibonacci numbers, all odd numbers\n        val fib_three\
    \ = BigInt(2)\n        val fib_four = BigInt(3)\n        val fib_result = BigInt(2)\n\
    \        val fib_result = BigInt(3)\n        while(n >= 2l) {\n            if((n%2l)\
    \ == 0) {\n                fib_result = fib_result + fib_one\n               \
    \ fib_one = fib_two\n                fib_two = fib_result\n                fib_result\
    \ = BigInt(2)\n            } else {\n                fib_result = fib_result +\
    \ fib_two\n                fib_two = fib_four\n                fib_four = fib_result\n\
    \                fib_result = BigInt(2)\n            }\n            n = n - 1l\n\
    \        }\n        return fib_result + fib_four", "        def f(n: Long): Long\
    \ = {\n            if (n <= 1l)\n                1l\n            else if (n ==\
    \ 2l)\n                2l\n            else if (n == 3l)\n                3l\n\
    \            else if (n == 5l)\n                5l\n            else\n       \
    \         n * (f(n-1l) + f(n-2l))\n        }\n        val res = (2l).asInstanceOf[Int]\
    \ * f(n)\n        res", "        // First test to see if n is prime\n        var\
    \ i : Long = n - 1\n        while (i >= 1) {\n            if (n % i == 0) {\n\
    \                i -= 1\n            } else {\n                break\n       \
    \     }\n        }\n        if (i == 1) {\n            return n\n        }\n \
    \       // then test to see if n is a Fibonacci number\n        i += 1\n     \
    \   val fib1 : Long = primeFib(i)\n        val fib2 : Long = primeFib(i)\n   \
    \     while (fib2 != fib1) {\n            fib1 = fib2\n            fib2 = primeFib(i\
    \ + fib1)\n            i += fib1\n        }\n        fib1", "        def nextPrime(n:Long):Long\
    \ = {\n            var nprime = 2 * n + 1\n            while ( (nprime < n) &&\
    \  (! (nprime % n)) ) {\n                nprime += 1\n            }\n        \
    \    nprime\n        }\n        val n = n - 1\n        if ( n == 0 ) 2\n     \
    \   else if ( n < 2l) n\n        else nextPrime(n) // if n is odd it returns n+1th\
    \ Fibonacci number", "        val fib_nums = Vector.fill(100)(0l).scanLeft(1l)(_\
    \ + _) // Fibonacci numbers sequence\n        if(fib_nums.contains(n))\n     \
    \       n\n        else if(fib_nums.takeWhile(_ < n).isEmpty) 0\n        else\
    \ fib_nums.takeWhile(_ < n).last", "        var x = 1l\n        var y = 2l\n \
    \       while (x<= n) {\n            if ((n % x) == 0)\n                return\
    \ x\n            else\n                x = x + y\n            y = y + x\n    \
    \    }\n        n", "        def isPrime(p: Long) : Boolean = {\n            for\
    \ (i <- 2 to (p / 2)) {\n                if (p % i == 0) {\n                 \
    \   return false\n                }\n            }\n            true\n       \
    \ }\n        val f = BigInt(n.toInt + 1)\n        for {\n            x <- if (isPrime(f))\
    \ 1l else 2l\n        } yield f", "        def isPrime(r : Long) : Boolean = {\n\
    \            val numPrime = (3l to r)\n            for(remR <- numPrime) {\n \
    \               if(numPrime.filter(remR % _ == 0).isEmpty) {\n               \
    \     return true\n                }\n            }\n            false\n     \
    \   }\n        if(n < 2l) 1l\n        else {\n            val fib = (n - (2l))\
    \ + (3l to (n-1l))\n            val prime = fib.filter(_ % 2 != 0)\n         \
    \   if(isPrime((fib.size - 1l) * fib.head))\n                primeFib(fib.size)\n\
    \            else\n                primeFib(fib.head * 2l)\n        }", "    \
    \    var a = 2l\n        var b = 2l\n        var s = a\n        var i = 2l\n \
    \       var j = 0l\n        var prime: Boolean = true\n        var temp: Long\
    \ = 0l\n        \n        while (s < n) {\n            if (n % a == 0) {\n   \
    \             i = i + 1l\n                s = s + 1l\n            }\n        \
    \    \n            if (n % b == 0) {\n                j = j + 1l\n           \
    \     s = s + 1l\n            }\n            \n            if ((j % 2l) == 0)\
    \ {\n                prime = false\n            } else {\n                prime\
    \ = true\n            }\n            \n            if (prime == true) {\n    \
    \            temp = s\n                s = s + 2l\n            }\n           \
    \ \n            i = i + 1l\n            b = s + 2l\n            a = temp + 2l\n\
    \        }\n        \n        return (s)", "        if (n<2)\n            return\
    \ n\n        val m = 2\n        while (m <= n)\n            {\n            if\
    \ (m*m == n) return m\n            m += 1\n            }\n        m\n        }\n\
    \    \n    // primes_less_than returns list of primes less than n.\n    // >>>\
    \ primes_less_than(100l)\n    // (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71)\n    def primes_less_than(n : Long) : List[Long]\
    \ = {\n        val p = scala.util.Random.shuffle(scala.util.Prime.primes).toList\n\
    \        val m = 2\n        val q = scala.util.Random.shuffle(p.tail).toList\n\
    \        if (n<2)\n            return p\n        while (q contains n+1 )\n   \
    \         {\n            m += 1\n            q = scala.util.Random.shuffle(p.tail).toList\n\
    \            }\n        (p+q+p.takeWhile(_<=n)).filter(_ % n == 0).takeWhile(_<n)\n\
    \        }\n    \n    // primes_less_than_prime_fib returns list of primes less\
    \ than the n-th Fibonacci number.\n    // >>> primes_less_than_prime_fib(100l)\n\
    \    // (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71)\n    def primes_less_than_prime_fib(n : Long) : List[Long] = {\n       \
    \ val p = scala.util.Random.shuffle(scala.util.Prime.primes).toList\n        val\
    \ m = 2\n        val q = scala.util.Random.shuffle(p.tail).toList\n        if\
    \ (n<2)\n            return p\n        while (q contains n+1 )\n            {\n\
    \            m += 1\n            q = scala.util.Random.shuffle(p.tail).toList\n\
    \            }\n        (p+q+p.takeWhile(_<=n)).filter(_ % n == 0).takeWhile(_<n).filter(_\
    \ <= n)\n        }\n    \n    // primes_less_than_prime_fib_prime_fib returns\
    \ list of primes less than the n-th Fibonacci number.\n    // >>> primes_less_than_prime_fib_prime_fib(100l)\n\
    \    // (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71)\n    def primes_less_than_prime_fib_prime_fib(n : Long) : List[Long] = {\n\
    \        val p = scala.util.Random.shuffle(scala.util.Prime.primes).toList\n \
    \       val m = 2", "        // initialize fib\n        var fib : Long = 1l\n\
    \        var fprime : Long = 1l\n\n        // while prime is false and fib is\
    \ less than n\n        while (!isPrime(fib, fprime, n) && fib <= n){\n       \
    \     // update fib\n            fib = fib + fprime;\n            // update fprime\n\
    \            fprime = fib;\n        }\n        // return fib\n        return fib;",
  "        var x = 1l\n        var y = 2l\n        var ans = 0l\n        while (n\
    \ > 0) {\n            ans = ans + x\n            x = y\n            y = ans +\
    \ y\n            n = n - 1\n        }\n        ans", "        val fibs : mutable.Set[Long]\
    \ = mutable.Set()\n        fibs += 2\n        fibs += 3\n        fibs += 5\n \
    \       while (fibs.contains(n)) {\n            fibs += fibs\n        }\n    \
    \    fibs.last", "        var a = 2l\n        var b = 1l\n        var c = 2l\n\
    \        val res = []\n        for (i = 3l; i < n+1l; i += 1l) {\n           \
    \ c = (a+b)\n            a = b\n            b = c\n            c += 1l\n     \
    \       if (c > n) res.append(c-1l)\n        }\n        if (n <= 5l) res(n-1l)\n\
    \        else res", "        val arr : mutable.MutableList[Int] = mutable.MutableList.empty\n\
    \        arr += 0\n        arr += 1\n        var temp : Int = 0\n        var count\
    \ = 0\n        while ((n < arr(0)) && (count < arr.size)) {\n            temp\
    \ = arr(n) + arr(n-1)\n            arr += temp\n            count += 1\n     \
    \       n += temp\n        }\n        temp", "        val primeList = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        primeList += 2\n        primeList += 3\n        while ((n > 0l) && (primeList.contains(n)))\n\
    \            primeList += 5\n        while ((n > 0l) && (primeList.contains(n)))\n\
    \            primeList += 7\n        while ((n > 0l) && (primeList.contains(n)))\n\
    \            primeList += 11\n        while ((n > 0l) && (primeList.contains(n)))\n\
    \            primeList += 13\n        while ((n > 0l) && (primeList.contains(n)))\n\
    \            primeList += 17\n        while ((n > 0l) && (primeList.contains(n)))\n\
    \            primeList += 19\n        while ((n > 0l) && (primeList.contains(n)))\n\
    \            primeList += 23\n        primeList.last", "        if (n < 3l) {\n\
    \            return n\n        }\n        else {\n            val nextFib = (n\
    \ + 1l).fibonacci()\n            if (nextFib > n + 1l) {\n                nextFib\n\
    \            }\n            else {\n                primeFib(nextFib)\n      \
    \      }\n        }", "        var fib_1 =  1L\n        var fib_2 = 2L\n     \
    \   var fib_3 =  1L\n        var num_prime = 1L\n        var i = n\n\n       \
    \ while (i != 1L)\n        {\n            var temp = fib_1\n            fib_1\
    \ = fib_2\n            fib_2 = temp\n            var temp = fib_2\n          \
    \  fib_3 = fib_3 + fib_2\n            num_prime += 1\n\n            i += 1\n \
    \       }\n\n        fib_3", "        val primes = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        var current = 2l\n        while (primes.size < n)\n        {\n      \
    \      primes += current\n            current += 1l\n        }\n        primes.take(n)",
  "        var p : Long = n.toInt\n        var q : Long = 1\n        var r : Long\
    \ = 0\n        while (p < q) {\n            r = p + q\n            if (r > n)\n\
    \                q = r\n            else {\n                p += q\n         \
    \       p += r\n            }\n        }\n        return p", "        val r =\
    \ BigInt(2)\n        val d = BigInt(5)\n        while (n >= d) {\n           \
    \ val t = r.multiply(r)\n            val u = d\n            val v = d\n      \
    \      val m = (v + u) / 2\n            if ((n % m) == 0) {\n                r\
    \ = u\n                d = v\n            } else {\n                r = v\n  \
    \              d = m\n            }\n        }\n        r", "        if ( n <\
    \ 2l ) {\n            if ( n == 2l ) {\n                return 1l\n          \
    \  }\n            return n\n        }\n        val cache = new mutable.HashMap[Long,\
    \ Long]()\n        def primeF(n, acc: Long): Long = {\n            if ( cache.containsKey(n)\
    \ ) {\n                return cache.get(n)\n            }\n            if ( n\
    \ % 2l == 0l ) {\n                val nextN = primeF(n / 2l, acc)\n          \
    \      if ( n % 4l == 0l ) {\n                    val nextNextN = primeF(n / 4l,\
    \ nextN)\n                    cache.set(n, nextNextN)\n                } else\
    \ {\n                    cache.set(n, nextN)\n                }\n            \
    \    return nextN\n            }\n            val nextN = primeF(n / 2l, acc)\n\
    \            cache.set(n, nextN)\n            return nextN\n        }\n      \
    \  primeF(n, 1l)", "        var p = 2l\n        var q = 2l\n        var r : Long\
    \ = p + (q * p)\n        while(r > n){\n            q = (q * p)%n\n          \
    \  p = q\n            q = p + (q * p)\n            r = p + (q * p)\n        }\n\
    \        return r", "        val cache = mutable.ArrayBuffer.empty[Int]\n    \
    \    def loop(i: Int, a: Int, b: Int) : Long = {\n            if (i == 0) a\n\
    \            else loop(i-1, a + b, cache(i-1) + cache(i-2))\n        }\n     \
    \   loop(n, 2, n)", "      val fibs = mutable.ListBuffer[Long](1l, 2l)\n     \
    \ val limit = (1l) until (n).dropRight(1)\n\n      for {\n        i <- limit\n\
    \        j <- fibs.lastOption\n      } yield {\n        if (j+i == n) return j\n\
    \        fibs += i+j\n        j\n      }\n      fibs.last", "        var fib =\
    \ scala.collection.mutable.ListBuffer[(Long, Boolean)]()\n        var a = 2l\n\
    \        var b = 3l\n        for(i <- 0 to n) {\n            if((b == a)) {\n\
    \                fib.add((a,true))\n                a = b\n                b +=\
    \ 2l\n            }\n            else {\n                fib.add((a,false))\n\
    \                a = b\n                b += 2l\n            }\n        }\n  \
    \      fib.last._1._1", "        // Initialize first two fibonacci numbers. Because\
    \ Fibonacci numbers are less than or equal to\n        // the given number and\
    \ the given number is not prime or even Fibonacci number, the first\n        //\
    \ two fibonacci numbers are less than or equal to the given number.\n        var\
    \ fibonacciFirst = (1l) // 1\n        var fibonacciSecond = (2l) // 1\n      \
    \  for(i <- 2 to n){\n            // If the given number is not a prime or even\
    \ fibonacci number, increment second fibonacci\n            // number by adding\
    \ the first two fibonacci numbers.\n            if(fibonacciSecond.isPrime ||\
    \ fibonacciSecond == fibonacciFirst){\n                fibonacciSecond += fibonacciFirst\n\
    \            } else {\n                // If n is not a prime or even fibonacci\
    \ number, then return the given number as the\n                // result.\n  \
    \              break\n            }\n        }\n        return fibonacciSecond",
  "        var a = 1l\n        var b = 2l\n        var count = 0l\n        while(\
    \ (count < n) && ( (a <= b) && ( b <= math.sqrt((a * a))) ) ) {\n            count\
    \ = count + 1l\n            a = a + b\n            b = b - a\n        }\n    \
    \    if( count == n ) {\n            return a\n        } else {\n            return\
    \ -1l\n        }", "        if(n == 0 || n == 1) return n\n        val f: List[Long]\
    \ = List(2l, 3l, 5l, 8l, 13l, 21l, 34l, 55l, 89l)\n        f.indexOf(n)", "  \
    \      val i = 2\n        var a = 2\n        var b = 1\n        var c = 2\n  \
    \      val p = 3\n        var n = n\n        var p = p\n        var i = i\n  \
    \      val prime = 0\n        while ((p <= n) && (prime == 0)) {\n           \
    \ for (i in 0 until i) {\n                val temp = a\n                a = b\n\
    \                b = temp\n            }\n            for (i in 0 until i) {\n\
    \                val temp = c\n                c = p\n                p = temp\n\
    \            }\n            var m = 2\n            for (i in 0 until m) {\n  \
    \              val temp = p\n                p = m\n                m = temp\n\
    \            }\n            i = i + 1\n            if (b == a) {\n           \
    \     prime = 1\n            }\n        }\n        if (prime == 1) {\n       \
    \     return a\n        } else {\n            return b\n        }", "        def\
    \ isPrime(n : Long) : Boolean = {\n            val i = 2\n            while (i\
    \ <= n / i) {\n                if (n % i == 0)\n                    return false\n\
    \                i += 2\n            }\n            true\n        }\n        val\
    \ fib = n -2 // n - 2 because 0 is also prime.\n        if (fib == 0 || fib ==\
    \ 1)\n            return fib\n        val max = (2l to fib).find {\n         \
    \   n => isPrime(n.toLong)\n        }.filter(_ % 2 == 0)\n        if (max.isEmpty)\n\
    \            fib\n        else\n            max.get", "        // base cases\n\
    \        if(n < 3) return n\n        if(n < 5) return 5l\n\n        // finding\
    \ out whether n is divisible by 4 or not\n        var divisors = 2l\n        var\
    \ current = 2l\n        while(divisors.compareTo(n) > 0){\n            divisors\
    \ += current\n            current += 2l\n        }\n        // if current is greater\
    \ than n\n        if(current.compareTo(n) > 0){\n            return n\n      \
    \  } else {\n            val remainder = n % current\n            return primeFib(divisors)\
    \ + remainder\n        }", "      if(n < 4) return n\n      if(n % 2 == 0) primeFib(n\
    \ / 2)\n      else primeFib(3 * n + 2)", "        def isPrime(n: Int) : Boolean\
    \ = {\n            if (n <= 2) false\n            else if (n % 2 == 0 || n % 3\
    \ == 0) false\n            else true\n        }\n        def sum(a: Int, b: Int)\
    \ : Int = {\n            val sum = a+b\n            sum\n        }\n        var\
    \ sum : Int = 0\n        var n2 : int = n\n        while (n2 >= 2) {\n       \
    \     if (isPrime(n2)) {\n                sum = sum(sum, n2)\n               \
    \ n2 = n2 - 1\n            }\n            else {\n                n2 = n2 - 2\n\
    \            }\n        }\n        sum", "        val primes = scala.collection.mutable.HashSet[Long]()\n\
    \        var a = 2\n        var b = 1\n        while(a < n){\n            if(primes.contains(a)){\n\
    \                a += 1\n            }else{\n                primes.add(a)\n \
    \               b = a + b\n                a += 1\n            }\n        }\n\
    \        b", "        var fib = 2L\n        while (fib < n) {\n            fib\
    \ = fib + fib\n        }\n        fib", "        def isPrime(n : Long) : Boolean\
    \ = \n            {\n                if (n == 1l || n == 2l) true\n          \
    \      else {\n                    val isPrime = (n % 2l) == 0l\n            \
    \        if (!isPrime) isPrime\n                    else { val isPrime = (n %\
    \ 3l) == 0l; !isPrime }\n                }\n            }\n        // n is odd\
    \ so n-1 is prime and n-2 not so return n-2 as the answer\n        if (isPrime(n-1l))\
    \ { n-2l }\n        // n is even so n-1 is not prime and n-2 is, so return n-2\
    \ as the answer\n        else { n-2l }", "        // n is less than or equal to\
    \ 10\n        if (n <= 10) {\n            return n\n        }\n        val isPrime\
    \ = (2l) until (n).forall {\n            case x if x % _ == 0 => false\n     \
    \       case x => true\n        }\n        if (isPrime)\n            return n\n\
    \        else\n            return primeFib(n + 2l) ", "        def iterate(i :\
    \ Long, memo : mutable.HashSet[Long]) : Long = {\n            if (i <= 1) {\n\
    \                memo(i)\n            } else {\n                val next = i +\
    \ 2\n                iterate(next, memo)\n            }\n        }\n\n       \
    \ var i : Long = 0\n        var memo : mutable.HashSet[Long] = mutable.HashSet()\n\
    \        iterate(i, memo)\n        memo(n).asInstanceOf[Long]", "        // Check\
    \ if n is prime.\n        if(n.toInt==1) return n\n        if(isPrime(n)) \n \
    \           // If n is a prime, return its Fibonacci number.\n            return\
    \ fib(n.toInt)\n        else\n            // If n is not a prime, find the Fibonacci\
    \ number which is not prime.\n            val fib_not_prime = fib(n.toInt)\n \
    \           while(!isPrime(fib_not_prime)) fib_not_prime = fib(n.toInt)\n    \
    \        fib_not_prime", "        val primesArray = Array.fill(n + 1) {\n    \
    \        if (Math.sqrt(i + 1) == 1) {\n                println(\"i\" + i + \"\
    's square root is \" + Math.sqrt(i) + \"; it's a whole number!\");\n         \
    \       1\n            } else {\n                if (i % 2 == 0) {\n         \
    \           println(\"i\" + i + \"'s square root is \" + Math.sqrt(i) + \"; it's\
    \ even.\");\n                    2\n                } else {\n               \
    \     println(\"i\" + i + \"'s square root is \" + Math.sqrt(i) + \"; it's odd.\"\
    );\n                    3\n                }\n            }\n        }\n     \
    \   val primes = primesArray\n        val fibonacciArray = Array.fill(n + 1) {\n\
    \            if (primes(n - 2) == 2) {\n                println(\"i\" + i + \"\
    's Fibonacci number is \" + i * (n - 2) + \"; it's a whole number!\");\n     \
    \           n - 2\n            } else {\n                if (primes(n - 2) ==\
    \ 3) {\n                    println(\"i\" + i + \"'s Fibonacci number is \" +\
    \ i * (n - 2) + \"; it's even.\");\n                    n - 2\n              \
    \  } else {\n                    println(\"i\" + i + \"'s Fibonacci number is\
    \ \" + i * (n - 2) + \"; it's odd.\");\n                    n - 3\n          \
    \      }\n            }\n        }\n        val fibonacci = fibonacciArray\n \
    \       primes(n), fibonacci(n)", "        if (n == 1l) 2l\n        else if (n\
    \ == 2l) 3l\n        else if (n == 3l) 5l\n        else { \n            val sqrt\
    \ = (long) Math.sqrt(n);\n            val fib = n-long(sqrt);\n            val\
    \ newfib = (fib % 2l) + 1l;\n            if (newfib == long(sqrt)) newfib\n  \
    \          else primeFib(newfib) \n        }", "        val memo = mutable.HashMap[Long,\
    \ Long]()\n        def prime(n: Long): Long = n match {\n            case 0 |\
    \ 1 => n\n            case n if n % 2 == 0 => prime(n * 2)\n            case n\
    \ if n % 2 == 1 => prime(n * 3 + 1)\n            case n => memo.get(n) match {\n\
    \                case None => {\n                    val q = prime(n * 3 + 1)\n\
    \                    memo(n) = (q * q * n) / n\n                    q\n      \
    \          }\n                case Some(ans) => ans\n            }\n        }\n\
    \        memo.get(n) match {\n            case None => prime(n + 2)\n        \
    \    case Some(ans) => ans\n        }", "        var a : Long = 1\n        var\
    \ b : Long = 2\n        var i : Long = 1\n        while (i < n) {\n          \
    \  val temp = a\n            a = b\n            b = temp + b\n            i +=\
    \ 1\n        }\n        a", "        val fibs = Vector(2l, 3l, 5l)\n        fibs.drop(n).takeWhile(fibs(_)\
    \ < n).head", "        var a = 0l\n        var b = 1l\n        var sum = 0l\n\
    \        while(true){\n            if(n % a == 0){\n                b = b - a\n\
    \                sum = b + sum\n            }\n            else\n            \
    \    a = a + b\n            if(b == 0)\n                break\n            n+=1\n\
    \        }\n        return sum", "        var i : Long = 0\n        var j : Long\
    \ = 1\n        var n : Long = 1\n        var sum : Long = 0\n        while (i\
    \ != 0) {\n            if (n % i == 0) {\n                if (i % 2 == 0) {\n\
    \                    n = n / 2\n                } else {\n                   \
    \ n = n * 3 + 1\n                }\n                i = i + 1\n            } else\
    \ {\n                i = i + 1\n            }\n        }\n        return sum",
  "        var a = 0L\n        var b = 1L\n        for(i <- 1 to n){\n           \
    \ if(a != 1L && b != 1L) {\n                val c = a + b\n                a =\
    \ b\n                b = c\n            }\n            else {\n              \
    \  a = b\n                b = 2L\n            }\n        }\n        if(b == 1L)\n\
    \            b\n        else\n            -1L", "        def isPrime(n : Long)\
    \ : Boolean = {\n            var i : Long = 1\n            var count : Long =\
    \ 1\n            while (i <= n){\n                if (i % i == 0)\n          \
    \      { count += 1; i = 0}\n                else {i += 1}\n            }\n  \
    \          count == n\n        }\n        var fibo : Long = 1\n        while(fibo\
    \ < n)\n        { fibo += 1 }\n        if (n == 0)\n        { return 1 }\n   \
    \     else if (n % 2 == 0)\n        { return 2 }\n        else { //if n is odd,\
    \ check from 3 to sqrt(n) \n            if (isPrime((Math.sqrt(n) + 1l)))\n  \
    \          { \n                while(fibo < n)\n                { fibo += 1 }\n\
    \                return fibo\n            }\n            else {\n            \
    \    while(fibo < n) //if n is not prime, check from 1 to sqrt(n)\n          \
    \      { fibo += 1 }\n                return primeFib((Math.sqrt(n) + 1l))\n \
    \           }\n        }", "        var fib : Long = 0\n        var nextFib :\
    \ Long = 1\n        while (fib < n){\n            fib = nextFib\n            nextFib\
    \ = fib + fib\n        }\n        fib", "        val arr = mutable.ArrayBuffer.empty[Long]\n\
    \        var prev = 0\n        var curr = 1\n        while (arr.length < n){\n\
    \            arr += curr\n            curr += prev\n            prev = curr\n\
    \        }\n        arr(n)", "        var fib_list : mutable.List[Long] = mutable.ListBuffer()\n\
    \        var i : Long = 1\n        while(i <= n){\n            fib_list += i\n\
    \            i = i + 2\n        }\n        if(fib_list.contains(n)) n\n      \
    \  else primeFib(n+1)", "        val fibNums = new mutable.ListBuffer[Long]()\n\
    \        fibNums += 2\n        fibNums += 3\n\n        var j = 1\n        while\
    \ (fibNums.size < n)\n        {\n            if (fibNums.contains(j))\n      \
    \      {\n                j += 2\n            }\n            else\n          \
    \  {\n                fibNums += j\n                j = 1\n            }\n   \
    \     }\n        fibNums(n)", "        var fibonacci = scala.math.BigInt(1)\n\
    \        var prime = 1\n        while(fibonacci < n) {\n            fibonacci\
    \ = fibonacci + scala.math.BigInt(2)\n            prime = prime + 1\n        }\n\
    \        return fibonacci - scala.math.BigInt(1) + prime", "        if ((n <=\
    \ 0l) || (n == 2l)) {\n            return n\n        }\n        else if (n ==\
    \ 1l) {\n            return 2l\n        }\n        else if (n == 2l) {\n     \
    \       return 3l\n        }\n        else {\n            var a : Long = n - 2l\n\
    \            var b : Long = 3l + 0l\n            while (b < a) {\n           \
    \     var c = a + b\n                if (n % c == 0l) {\n                    a\
    \ = c\n                } else {\n                    b = c\n                }\n\
    \            }\n            return b\n        }", "      val num = (2l*n+1l*(n+1)+1)\n\
    \      val sq = num.pow(2l*n)\n      if(sq.equals(num)) sq else {\n        val\
    \ num2 = (2l*(n+1)-1l*(n+1)+1)\n        val sq2 = num2.pow(2l*(n+1))\n       \
    \ if(sq2.equals(num2)) sq2 else {\n          val num3 = (2l*(n+1)-2l*(n+1)+1)\n\
    \          val sq3 = num3.pow(2l*(n+1))\n          if(sq3.equals(num3)) sq3 else\
    \ {\n            val num4 = (2l*(n+1)-3l*(n+1)+1)\n            val sq4 = num4.pow(2l*(n+1))\n\
    \            if(sq4.equals(num4)) sq4 else {\n              val num5 = (2l*(n+1)-4l*(n+1)+1)\n\
    \              val sq5 = num5.pow(2l*(n+1))\n              if(sq5.equals(num5))\
    \ sq5 else {\n                val num6 = (2l*(n+1)-5l*(n+1)+1)\n             \
    \   val sq6 = num6.pow(2l*(n+1))\n                if(sq6.equals(num6)) sq6 else\
    \ {\n                  val num7 = (2l*(n+1)-6l*(n+1)+1)\n                  val\
    \ sq7 = num7.pow(2l*(n+1))\n                  if(sq7.equals(num7)) sq7 else {\n\
    \                    val num8 = (2l*(n+1)-7l*(n+1)+1)\n                    val\
    \ sq8 = num8.pow(2l*(n+1))\n                    if(sq8.equals(num8)) sq8 else\
    \ {\n                      val num9 = (2l*(n+1)-8l*(n+1)+1)\n                \
    \      val sq9 = num9.pow(2l*(n+1))\n                      if(sq9.equals(num9))\
    \ sq9 else {\n                        val num10 = (2l*(n+1)-9l*(n+1)+1)\n    \
    \                    val sq10 = num10.pow(2l*(n+1))\n                        if(sq10.equals(num10))\
    \ sq10 else {\n                          val num11 = (2l*(n+1)-10l*(n+1)+1)\n\
    \                          val sq11 = num11.pow(2l*(n+1))\n                  \
    \        if(sq11.equals(num11)) sq11 else {\n                            val num12\
    \ = (2l*(n+1)-11l*(n+1)+1)\n                            val sq12 = num12.pow(2l*(n+1))\n\
    \                            if(sq12.equals(num12)) sq12 else {\n            \
    \                  val num13 = (2", "        val fibArray = Array(2, 3); \n  \
    \      for(x <- 1 to n){\n            fibArray += fibArray(0)\n        }\n   \
    \     fibArray.last ", "        var a = 2l\n        var b = 3l\n        \n   \
    \     while (true) {\n            \n            val c = b\n            b = a +\
    \ (b - a)\n            a = c\n            if (b > n) \n                break\n\
    \        }\n        \n        return b", "        val fibs = Vector.fill(10)(2)\n\
    \        val current = 2\n        // For each n, we calculate it's n-th Fibonacci\
    \ number and its prime.\n        // We store them in Vector and calculate the\
    \ sum of them at the end.\n        for(i <- 1 to n){\n            val result =\
    \ fibs(current)\n            current += 1\n            fibs(current) = fibs(current\
    \ - 1) + fibs(current - 2)\n        }\n        // We calculate the sum of them.\n\
    \        fibs(current).sum", "        def fibs(n : Long, n1 : Long, n2 : Long):\
    \ Long = {\n            if (n1 === n2) {\n                n\n            } else\
    \ if (n1 < n2) {\n                fibs(n1, n2 + n1, n2)\n            } else {\n\
    \                fibs(n2, n1 + n2, n1)\n            }\n        }\n        fibs(1,\
    \ 1, n)", "        var pf : Long = 1\n        var pf2 : Long = 2\n        var\
    \ pf3 : Long = 3\n        // pf is Fibonacci number and it's also prime\n    \
    \    // pf2 is Fibonacci number but it's not a prime\n        // pf3 is Fibonacci\
    \ number but it's not a prime\n        while(n > 0){\n            pf = pf2\n \
    \           pf2 = pf2\n            pf3 = pf + pf2\n            pf := pf2\n   \
    \         pf2 := pf + pf2\n            pf := pf2\n            n--\n        }\n\
    \        return pf", "        val primes : mutable.Set[Long] = mutable.Set(1)\n\
    \        val fibonacci : mutable.Set[Long] = mutable.Set(0)\n        for (i <-\
    \ 2 to n) {\n            if (fibonacci.contains(i)) {\n                primes.add(i)\n\
    \            } else {\n                fibonacci.add(i)\n            }\n     \
    \   }\n        return primes.last", "        // A small prime number is defined\
    \ as a composite number that is \n        // less than or equal to twice the square\
    \ root of a large prime number\n        // (https://en.wikipedia.org/wiki/Prime_number_theorem)\n\
    \        // A Fibonacci number is a large prime number that is divisible by two\n\
    \        // And this two together make the biggest Fibonacci number (and it is\
    \ also prime)\n        // We assume that all primes are less than 1000 and that\
    \ \n        // Fibonacci numbers are less than 1000000 \n        if(n == 2) 2l\n\
    \        else if(n == 3l) 3l\n        else if(n == 5l) 5l\n        else if(n ==\
    \ 10l) 10l\n        else if(n == 20l) 20l\n        else if(n == 50l) 50l\n   \
    \     else if(n == 100l) 100l\n        else if(n == 500l) 500l\n        else if(n\
    \ == 1000l) 1000l\n        else if(n == 10000l) 10000l\n        else if(n == 100000l)\
    \ 100000l\n        else if(n == 1000000l) 1000000l\n        else if(n == 1000000l)\
    \ 1000000l\n        else if(n == 1000000l) 1000000l\n        else if(n == 10000000l)\
    \ 10000000l\n        else if(n == 100000000l) 100000000l\n        else if(n ==\
    \ 1000000000l) 1000000000l\n        else if(n == 10000000000l) 10000000000l\n\
    \        else if(n == 100000000000l) 100000000000l\n        else if(n == 1000000000000l)\
    \ 1000000000000l\n        else if(n == 10000000000000l) 10000000000000l\n    \
    \    else if(n == 100000000000000l) 100000000000000l\n        else if(n == 1000000000000000l)\
    \ 1000000000000000l\n        else if(n == 10000000000000000l) 10000000000000000l\n\
    \        else if(n == 100000000000000000l) 100000000000000000l\n        else if(n\
    \ == 1000000000000000000l) 1000000000000000000l\n        else if(n == 10000000000000000000l)\
    \ 10000000000000000000l\n        else if(n == 100000000000000000000l) 100000000000000000000l\n\
    \        else if(n == 1000000000000000000000l) 1000000000000000000000l\n     \
    \   else if(n == 10000000000000000000000l) 10000000000000000000000l\n        else\
    \ if(n == 100000000000000000000000l) 100000000000000000000000l\n        else if(n\
    \ == 1000000000000000000000000l) 1000000000000000000000000l\n        else if(n\
    \ == 10000000000000000000000000l) 10000000000000000000000000l\n        else if(n\
    \ == 100000000000000000000000000l) 100000000000000000000000000l\n        else\
    \ if(n == 1000000000000000000000000000l) ", "        var lastFib :Long = 0\n \
    \       var nextFib :Long = 1\n        while (n > 0) {\n            nextFib =\
    \ lastFib + nextFib\n            lastFib = nextFib\n            nextFib++\n  \
    \          n -= 1\n        }\n        return lastFib", "        // use mutable.Buffer\
    \ collection to save all fibonacci numbers\n        var fib : mutable.Buffer[Long]\
    \ = mutable.Buffer()\n        var previous = 0\n        fib += 0\n        fib\
    \ += 1\n        // start from n-1 because the first number is 0\n        for (i\
    \ <- 1 to (n - 1)){\n            fib += (fib - previous)\n            previous\
    \ = fib\n        }\n        // remove the first two numbers, because they are\
    \ 0\n        fib.drop(2).toSeq", "        // base case\n        if (n == 0 ||\
    \ n == 1) {\n            return n\n        }\n        // recursive case\n    \
    \    if (n % 2 == 0) {\n            return primeFib(3 * n + 1)\n        }\n  \
    \      else {\n            return primeFib(3 * n - 1)\n        }", "        var\
    \ last = 0\n        var last1 = 1\n        var prime = 0\n        var prime1 =\
    \ 1\n        for(i <- 2 to n){\n            last += last1\n            last1 =\
    \ last\n            prime += prime1\n            prime1 = prime\n        }\n \
    \       prime", "        def isPrimeFib(x: Long) : Boolean = {\n            if((x%2l)\
    \ == 0) return false\n            if(x%3l==0) return false\n            if(x%5l==0)\
    \ return false\n            if(x%7l==0) return false\n            if(x%11l==0)\
    \ return false\n            if(x%13l==0) return false\n            if(x%17l==0)\
    \ return false\n            if(x%19l==0) return false\n            if(x%23l==0)\
    \ return false\n            if(x%29l==0) return false\n            if(x%31l==0)\
    \ return false\n            if(x%37l==0) return false\n            if(x%41l==0)\
    \ return false\n            if(x%47l==0) return false\n            if(x%53l==0)\
    \ return false\n            if(x%59l==0) return false\n            if(x%61l==0)\
    \ return false\n            if(x%67l==0) return false\n            if(x%73l==0)\
    \ return false\n            if(x%79l==0) return false\n            if(x%83l==0)\
    \ return false\n            if(x%89l==0) return false\n            if(x%97l==0)\
    \ return false\n            if(x%101l==0) return false\n            if(x%103l==0)\
    \ return false\n            if(x%107l==0) return false\n            if(x%109l==0)\
    \ return false\n            if(x%113l==0) return false\n            if(x%127l==0)\
    \ return false\n            if(x%131l==0) return false\n            if(x%137l==0)\
    \ return false\n            if(x%139l==0) return false\n            if(x%141l==0)\
    \ return false\n            if(x%143l==0) return false\n            if(x%147l==0)\
    \ return false\n            if(x%149l==0) return false\n            if(x%151l==0)\
    \ return false\n            if(x%157l==0) return false\n            if(x%163l==0)\
    \ return false\n            if(x%167l==0) return false\n            if(x%173l==0)\
    \ return false\n            if(x%179l==0) return false\n            if(x%181l==0)\
    \ return false\n            if(x%191l==0) return false\n            if(x%193l==0) ",
  "        val primeFreq = mutable.HashMap[Long,Long]();\n        primeFreq.put(1l,1l);\n\
    \        primeFreq.put(2l,2l);\n        primeFreq.put(3l,3l);\n        primeFreq.put(4l,5l);\n\
    \        primeFreq.put(5l,10l);\n        primeFreq.put(6l,15l);\n        primeFreq.put(7l,21l);\n\
    \        primeFreq.put(8l,28l);\n        primeFreq.put(9l,36l);\n        primeFreq.put(10l,45l);\n\
    \        primeFreq.put(11l,57l);\n        primeFreq.put(12l,66l);\n        primeFreq.put(13l,76l);\n\
    \        primeFreq.put(14l,86l);\n        primeFreq.put(15l,96l);\n        primeFreq.put(16l,106l);\n\
    \        primeFreq.put(17l,114l);\n        primeFreq.put(18l,120l);\n        primeFreq.put(19l,129l);\n\
    \        primeFreq.put(20l,138l);\n        primeFreq.put(21l,147l);\n        primeFreq.put(22l,156l);\n\
    \        primeFreq.put(23l,164l);\n        primeFreq.put(24l,172l);\n        primeFreq.put(25l,180l);\n\
    \        primeFreq.put(26l,188l);\n        primeFreq.put(27l,196l);\n        primeFreq.put(28l,204l);\n\
    \        primeFreq.put(29l,212l);\n        primeFreq.put(30l,220l);\n        primeFreq.put(31l,228l);\n\
    \        primeFreq.put(32l,236l);\n        primeFreq.put(33l,246l);\n        primeFreq.put(34l,254l);\n\
    \        primeFreq.put(35l,262l);\n        primeFreq.put(36l,270l);\n        primeFreq.put(37l,278l);\n\
    \        primeFreq.put(38l,286l);\n        primeFreq.put(39l,294l);\n        primeFreq.put(40l,302l);\n\
    \        primeFreq.put(41l,308l);\n        primeFreq.put(42l,316l);\n        primeFreq.put(43l,322l);\n\
    \        primeFreq.put(44l,330l);\n        primeFreq.put(45l,338l);\n        primeFreq.put(46l,346l);\n\
    \        primeFreq.put(47l,352l);\n        primeFreq.put(48l,360l);\n        primeFreq.put(49l,368l);\n\
    \        primeF", "        val primes = mutable.ArrayBuffer(2l) \n        var\
    \ next_prime = 2l\n        while (next_prime < n && !primes.contains(next_prime))\
    \ {\n            primes += next_prime \n            next_prime += 1l\n       \
    \ }\n        primes.last", "      if (n == 1l || n == 0l) {\n        if (n ==\
    \ 1l) {\n          1l\n        } else {\n          0l\n        }\n      } else\
    \ if (n % 2l == 0l) {\n        primeFib(n / 2l) + 1l\n      } else {\n       \
    \ primeFib(n / 2l) + 1l\n      }", "        if (n <= 2)\n            return n\n\
    \        val first = primeFib(n / 2l)\n        val second = primeFib(n / 2l)\n\
    \        if (second > first)\n            second\n        else\n            first",
  "        var a : Long = 0\n        var b : Long = 1\n        var i : Long = 1\n\
    \        while (i<n) {\n            if (b%i == 0) {\n                a = b\n \
    \           }\n            b = b+a\n            i += 1\n        }\n        return\
    \ a", "        var a = 2l\n        var b = 3l\n        var nextFib = 1l\n    \
    \    var count = 0l\n\n        // If n is even.\n        if (n.toLong % 2 == 0)\
    \ {\n            a = b\n            n = n.toLong / 2\n        }\n        // If\
    \ n is odd.\n        else {\n            b = nextFib\n            nextFib = a\
    \ + b\n            n = n.toLong / 2\n        }\n\n        // Loop to find and\
    \ return the prime number.\n        n match {\n            case 0l => a\n    \
    \        case 1l => b\n            case _  => nextFib\n        }", "        def\
    \ isPrime(n : Long) : Boolean = {\n            val sqrt: Long = Math.sqrt(n)\n\
    \            var i: Long = 1\n            while (i <= sqrt) {\n              \
    \  if (n % i == 0)\n                    return false\n                i += 1\n\
    \            }\n            return true\n        }\n        if (isPrime(n)) {\n\
    \            return n\n        }\n        var a: Long = 1\n        var b: Long\
    \ = 1\n        val m: Long = n - 1\n        while (m >= 1) {\n            val\
    \ n: Long = a + b\n            a = b\n            b = n\n            m -= 1\n\
    \        }\n        if (n > 1)\n            primeFib(n + 1)\n        else\n  \
    \          a", "        var x = 0l\n        var y = 0l\n        var z = 0l\n \
    \       var fib : Long = 1l\n        var isPrime : Boolean = false\n        while\
    \ (!isPrime) {\n            if (fib > n) {\n                isPrime = true\n \
    \           }\n            if (fib == n) {\n                return fib\n     \
    \       }\n            if (fib % 2 == 0) {\n                fib = fib * 3 + 1\n\
    \            } else if (fib % 3 == 0) {\n                fib = fib * 5 + 1\n \
    \           } else {\n                fib = fib * 3 + 1\n            }\n     \
    \       x += 1\n            y += 1\n            z += 1\n        }\n        fib",
  "        val fibs = Vector.fill(n)((0l))\n        fibs(0) += 1l\n        fibs(1)\
    \ += 2l\n        fibs(2) += 3l\n        fibs(3) += 5l\n        fibs(4) += 13l\n\
    \        fibs(5) += 89l\n        fibs.takeWhile(elem => elem != fibs.last).last",
  "        if (n < 2) n\n        else {\n            var a = 2\n            var b\
    \ = 2\n            while (b < n) {\n                val mid = (a+b)/2\n      \
    \          if (isPrime(mid)) {\n                    a = mid\n                }\
    \ else {\n                    b = mid\n                }\n            }\n    \
    \        b\n        }", "        val a = 2l\n        val b = 5l\n        val c\
    \ = 5l\n        val d = 6l\n        val r = 0l\n        var i = 0l\n        while(n>0l){\n\
    \            val tmp = a+b\n            a := b\n            b := tmp\n       \
    \     r := r + a\n            c := d + (r%b)\n            d := tmp\n         \
    \   n -= 1l\n            i += 1l\n        }\n        r", "        var a = 0\n\
    \        var b = 1\n        for(i <- 2 to n step 2){\n            if(b%i == 0){\n\
    \                a+=1\n            }\n        }\n        return b", "        var\
    \ a = 2l\n        var b = 3l\n        var c = 5l\n        var i = 1l\n       \
    \ while (i <= n && a < n)\n        {\n            val p = (a * b) % c\n      \
    \      if (p < a)\n            {\n                a = p\n            }\n     \
    \       else \n            {\n                b = p\n            }\n         \
    \   i += 1\n        }\n        if (n == a)\n        {\n            return a\n\
    \        }\n        if (n == b)\n        {\n            return b\n        }\n\
    \        var result = a + b\n        return result", "        val ln = scala.math.lcm.toInt\
    \ (n.toLong)\n        val fibonacciSeq = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        fibonacciSeq += n\n        fibonacciSeq += n-1\n        fibonacciSeq\
    \ += n+1\n        fibonacciSeq.toList.take(ln).toSeq.last", "        val fib :\
    \ Array[Long] = new Array[Long](n+1)\n        fib(0) = 0\n        fib(1) = 1\n\
    \        fib(2) = 1\n        for (i <- 3 until n) {\n            fib(i)=fib(i-1)+fib(i-2)\n\
    \        }\n        fib(n)", "        val p = scala.math.BigInt(n).toString\n\
    \        if (p.toString.indexOf(\"(\") >= 0)\n            (p.toString.substring(p.toString.indexOf(\"\
    (\") + 1, p.toString.indexOf(\")\")).toLong)\n        else\n            p", " \
    \       def find(n : Long) : Long = {\n            if (n == 0 || n == 1) {\n \
    \               return n\n            }\n            else {\n                return\
    \ find(n-1) + find(n-2) + n\n            }\n        }\n        if (n%2 == 0) {\n\
    \            return find(n+2)\n        }\n        else {\n            val l =\
    \ math.ceil(sqrt(n).toInt)\n            val k = n/l\n            val q = primeFib(k)\n\
    \            val r = primeFib(k+1)\n            return r*q + l\n        }", " \
    \       var x = 1\n        var y = 2\n        var count = 0\n        while (count\
    \ != n) {\n            if (x * y == n) count += 1\n            x += 1\n      \
    \      y += 1\n        }\n        x", "        def isPrime(n: Long) : Boolean\
    \ = \n            for( i <- 2 to n/2 if n%i == 0 ) yield false\n        val m\
    \ = 2l\n        for( i <- 2l to n ) if( isPrime(i) ) m += 1\n        m", "   \
    \     def isPrime(n: Long) : Boolean = {\n            if (n < 2l) false\n    \
    \        else {\n                if (n % 2 == 0) false\n                else if\
    \ (!(n % 3) == 0) false\n                else {\n                    for (i <-\
    \ 4l until (n-2l)) {\n                        if (n % i == 0) false\n        \
    \            }\n                    true\n                }\n            }\n \
    \       }\n        val fibs = Vector.fill(n)(0l)\n        var i = 0l\n       \
    \ while (fibs.last() < 2l) fibs(i) = fibs(i-1) + fibs(i-2)\n        fibs.last",
  "        if((n % 2l) == 0l) {\n            primeFib(n / 2l)\n        } else if((n\
    \ % 2l) != 0l){\n            primeFib(n / 2l) + 1l\n        } else primeFib(n\
    \ * 3l)", "        var a = 2\n        var b = 1\n        for(i <- 0 until n){\n\
    \            if(b == 1){\n                b = 2\n                a = a + b\n \
    \           }\n            else if(b == 2){\n                a = 3\n         \
    \       b = a + b\n            }\n            else{\n                a = a + b\n\
    \            }\n        }\n        return a"]
stop_tokens:
- "\n    }\n"
