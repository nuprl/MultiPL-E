name: HumanEval_70_strange_sort_list
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given list of integers, return list in strange order.\n    // Strange sorting,\
  \ is when you start with the minimum value,\n    // then maximum of the remaining\
  \ integers, then minimum and so on.\n    // Examples:\n    // >>> strangeSortList((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong)))\n    // (List[Long](1l.toLong, 4l.toLong, 2l.toLong,\
  \ 3l.toLong))\n    // >>> strangeSortList((List[Long](5l.toLong, 5l.toLong, 5l.toLong,\
  \ 5l.toLong)))\n    // (List[Long](5l.toLong, 5l.toLong, 5l.toLong, 5l.toLong))\n\
  \    // >>> strangeSortList((List[Long]()))\n    // (List[Long]())\n    def strangeSortList(lst\
  \ : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(strangeSortList((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 4l.toLong, 2l.toLong,\
  \ 3l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong, 9l.toLong))).equals((List[Long](5l.toLong, 9l.toLong, 6l.toLong, 8l.toLong,\
  \ 7l.toLong))));\n    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong, 5l.toLong))).equals((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 4l.toLong,\
  \ 3l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong, 9l.toLong, 1l.toLong))).equals((List[Long](1l.toLong, 9l.toLong, 5l.toLong,\
  \ 8l.toLong, 6l.toLong, 7l.toLong))));\n    assert(strangeSortList((List[Long](5l.toLong,\
  \ 5l.toLong, 5l.toLong, 5l.toLong))).equals((List[Long](5l.toLong, 5l.toLong, 5l.toLong,\
  \ 5l.toLong))));\n    assert(strangeSortList((List[Long]())).equals((List[Long]())));\n\
  \    assert(strangeSortList((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
  \ 5l.toLong, 6l.toLong, 7l.toLong, 8l.toLong))).equals((List[Long](1l.toLong, 8l.toLong,\
  \ 2l.toLong, 7l.toLong, 3l.toLong, 6l.toLong, 4l.toLong, 5l.toLong))));\n    assert(strangeSortList((List[Long](0l.toLong,\
  \ 2l.toLong, 2l.toLong, 2l.toLong, 5l.toLong, 5l.toLong, -5l.toLong, -5l.toLong))).equals((List[Long](-5l.toLong,\
  \ 5l.toLong, -5l.toLong, 5l.toLong, 0l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))));\n\
  \    assert(strangeSortList((List[Long](111111l.toLong))).equals((List[Long](111111l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        val list = mutable.ListBuffer.empty[Long]\n        list.add(lst(0))\n\
    \        list.add(lst(1))\n\n        for (i <- 2 to lst.length-1) {\n        \
    \    list.add(lst(i))\n            list.add(lst(i-1))\n        }\n        list.toList",
  "        val listOfPairs = lst.toList.grouped(2).toList\n        listOfPairs.map\
    \ { p =>\n            val first = p._1\n            val second = p._2\n      \
    \      List((first - second).toLong, (second - first).toLong)\n        }", " \
    \       var list = lst\n        var currentMin = lst(0)\n        var currentMax\
    \ = lst(lst.length-1)\n        var currentMinIndex = 0\n        var currentMaxIndex\
    \ = 0\n        while(currentMinIndex < list.length){\n            val currentMin\
    \ = currentMin\n            val currentMax = currentMax\n            currentMinIndex\
    \ = currentMinIndex + 1\n            currentMaxIndex = currentMaxIndex + 1\n \
    \           val currentMinIndex = currentMinIndex - 1\n            val currentMaxIndex\
    \ = currentMaxIndex - 1\n            while(currentMaxIndex >= 0 && currentMax(currentMaxIndex)\
    \ > currentMin){\n                list = list.remove(currentMaxIndex)\n      \
    \          list = list.insert(currentMaxIndex, currentMin)\n                currentMinIndex\
    \ = currentMinIndex + 1\n                currentMaxIndex = currentMaxIndex + 1\n\
    \                val currentMinIndex = currentMinIndex - 1\n                val\
    \ currentMaxIndex = currentMaxIndex - 1\n            }\n        }\n        list",
  "        val sortedList = lst.sortBy(_ -1)\n        val sortedList2 = sortedList.sortBy(_\
    \ -2)\n        val sortedList3 = sortedList2.sortBy(_ -3)\n        val sortedList4\
    \ = sortedList3.sortBy(_ -4)\n        sortedList4", "        val s = lst.sortWith((x:\
    \ Long, y: Long) => x < y)\n        val l3 = s.take(2)\n        val l2 = s.drop(2)\n\
    \        val l1 = s.take(1)\n        l1 ++ l3 ++ l2", "        def strangeSort(li\
    \ : List[Long]) : List[Long] = {\n            val m = li(0)\n            val r\
    \ = li.tail\n            val s = r.foldLeft[List[Long]](m)((list, e) => e < list\
    \ match {\n                case true => e\n                case false => list\n\
    \            })\n            s :: r\n        }\n        val sortedList = lst.foldLeft[List[Long]](List[Long]())((list,\
    \ e) => e < list match {\n            case true => list\n            case false\
    \ => e :: list\n        })\n        strangeSort(sortedList).reverse", "      \
    \  var tmp: List[Long] = Nil\n        for ( i <- 0 until lst.length ) {\n    \
    \        tmp = lst.tail\n            lst.tail = lst.take(i)\n            lst.head\
    \ = tmp\n        }\n        return lst", "        val result = new ListBuffer[Long]()\n\
    \        val tmpList = lst.sort\n        result.addAll(tmpList)\n        tmpList.clear()\n\
    \        result.addAll(tmpList)\n        result.toList", "        if (lst.isEmpty)\
    \ lst\n        else {\n            val (minVal, maxVal) = lst.minBy(_.toInt).toLong,\
    \ \n                              lst.maxBy(_.toInt).toLong\n            val newList\
    \ = mutable.ArrayBuffer.empty[Long]\n            for (i <- lst.indices) {\n  \
    \              if (i < (maxVal-minVal)) {\n                    newList += lst.apply(i)\
    \ + minVal\n                    newList += lst.apply(i+1)\n                  \
    \  newList += lst.apply(i+2)\n                } else {\n                    newList\
    \ += lst.apply(i)\n                    newList += lst.apply(i-1)\n           \
    \         newList += lst.apply(i-2) + maxVal\n                }\n            }\n\
    \            newList\n        }", "        lst.foldLeft( List(lst(0)) :+ lst(lst.size\
    \ - 1) ){\n            (acc: List[Long], elem: List[Long]) =>\n              \
    \  acc.reverse ::: List(elem) ::: acc\n        }", "        if (lst.isEmpty) lst\n\
    \        else {\n            val startInd = lst.min.asInstanceOf[Long]\n     \
    \       val endInd = lst.max.asInstanceOf[Long]\n            val newInd = 1\n\
    \            val curr = startInd\n            val list = mutable.ListBuffer.empty[Long]\n\
    \            while (curr < endInd) {\n                list += curr\n         \
    \       newInd += 1\n                curr += newInd\n            }\n         \
    \   list += endInd\n            list.toList.sortBy(_ - startInd).reverse\n   \
    \     }", "        val sortedList = lst.sortBy(x => x.toLong)\n        val reversedList\
    \ = sortedList.reverse\n        reversedList", "        val result = new ArrayList[Long]()\n\
    \        var current = new Long(lst(0))\n        for(i <- 1 until lst.size){\n\
    \            val val = lst(i)\n            if(val < current){\n              \
    \  result.add(current.toLong)\n                current = val\n            }\n\
    \            else {\n                result.add(val.toLong)\n                current\
    \ = val\n            }\n        }\n        result.add(current.toLong)\n      \
    \  return result", "        def strangeSort(lst : List[Long], index : Int) : List[Long]\
    \ = {\n            if (lst.isEmpty || index >= lst.length) lst\n            else\
    \ {\n                // Get the minimum between current index and remaining length\n\
    \                val (minL, minI) = lst.span(index)(_ < _)\n\n               \
    \ // Get the maximum between current index and remaining length\n            \
    \    val (maxL, maxI) = lst.span(index)(_ > _)\n\n                // Get the minimum\
    \ between current index and remaining length\n                val (minL, maxL)\
    \ = lst.span(index)(_ < _)\n\n                // Merge the minimum with maximum\n\
    \                val minLmax = minL ++ maxL\n\n                // Merge the minimum\
    \ and maximum into current index\n                val lst = minI.toLong ++ minLmax\
    \ ++ maxI.toLong\n\n                // Recursively call for the rest of the list\n\
    \                strangeSort(lst, index + 1)\n            }\n        }\n     \
    \   strangeSort(lst, 1)", "        val newlst = lst.map(x => (x to (x + 1)).toList)\n\
    \        newlst.sortWith(_ < _)", "        val res = new ListBuffer[Long]\n  \
    \      var nextMax = lst(0)\n        var nextMin = lst(0)\n        for(i <- 1\
    \ until lst.size){\n            val curMax = lst(i)\n            val curMin =\
    \ lst(i)\n            val newMax = if(curMax < nextMax) curMax else nextMax\n\
    \            val newMin = if(curMin > nextMin) curMin else nextMin\n         \
    \   res += newMax\n            nextMax = newMax\n            nextMin = newMin\n\
    \        }\n        return res", "        var max = lst.map(_.toLong).max\n  \
    \      var min = lst.map(_.toLong).min\n        while(max < min) {\n         \
    \   max = lst.map(_.toLong).max\n            min = lst.map(_.toLong).min\n   \
    \     }\n        val listOfInts = lst.map{i => i to (i - max)}\n        val listOfLongs\
    \ = listOfInts.map{i => i._1 to i._2}\n        val reversedList = listOfLongs.toList.reverse\n\
    \        val listOfReversedLongs = reversedList.map{i => i._2 to i._1}\n     \
    \   val listOfReversedInts = listOfReversedLongs.toList.reverse\n        val result\
    \ = listOfReversedInts.toList\n        result.map{i => i*2l.toLong}", "      \
    \  var lst1 = lst\n        lst1 = lst1.sortWith((a, b) => a.toDouble < b.toDouble)\n\
    \        lst1 = lst1.sortWith((a, b) => a.toDouble > b.toDouble)\n        lst1\
    \ = lst1.sortWith((a, b) => a.toLong < b.toLong)\n        lst1 = lst1.sortWith((a,\
    \ b) => a.toLong > b.toLong)\n        return lst1.toList", "        val result\
    \ = new collection.mutable.ListBuffer[Long]()\n        val current = lst(0)\n\
    \        result.append(current)\n        lst.drop(1).foreach {\n            item\
    \ => \n                if(item > current) {\n                    result.append(item)\n\
    \                } else {\n                    current = item\n              \
    \  }\n        }\n        result.toList", "        val n = lst.size\n        val\
    \ listOfInt = mutable.ArrayBuffer.empty[Long]\n        for (i <- 1 to n) {\n \
    \           listOfInt += lst(n - i)\n        }\n        listOfInt.sort", "   \
    \     var list : List[Long] = lst.take(lst.size/2-1).toList\n        var list\
    \ : List[Long] = lst.take(lst.size/2).toList\n        for(x<-list.takeWhile(list>x)){\n\
    \            list.update(x)\n        }\n        list", "        val map = lst.foldLeft(Map.empty[Long,Long])((m,n)\
    \ =>{\n            m + (n -> (m.getOrElse(n,0) + 1));\n        })\n        map.keySet.sortWith(\
    \ (a,b) => map.get(b) - map.get(a)).toList", "        val result = new mutable.ListBuffer[Long]()\n\
    \        val minValue = lst.min\n        val maxValue = lst.max\n        var minIndex\
    \ = -1\n        var maxIndex = -1\n\n        for (i <- 0 until lst.size) {\n \
    \           if (i > minIndex) {\n                result.insert(maxIndex, maxValue)\n\
    \                maxIndex = -1\n            }\n\n            if (i < maxIndex)\
    \ {\n                result.insert(minIndex, minValue)\n                minIndex\
    \ = -1\n            }\n\n            minIndex = i\n            minValue = lst(i)\n\
    \        }\n\n        if (minIndex != -1) {\n            result.insert(minIndex,\
    \ minValue)\n        }\n\n        return result.toList", "        val n = lst.size\n\
    \        val minLst = lst.minBy(_.toLong).toList\n        val maxLst = lst.maxBy(_.toLong).toList\n\
    \        // reverse maxLst and minLst\n        // then reverse maxLst and minLst\n\
    \        // then reverse maxLst and minLst\n        // then reverse maxLst and\
    \ minLst\n        // then reverse maxLst and minLst\n        // reverse maxLst\
    \ and minLst\n        // reverse maxLst and minLst\n        // then reverse maxLst\
    \ and minLst\n        val reversedLst = maxLst ++ minLst ++ maxLst ++ minLst ++\
    \ maxLst ++ minLst ++ maxLst ++ minLst ++ maxLst ++ minLst ++ maxLst ++ minLst\
    \ ++ maxLst ++ minLst ++ maxLst ++ minLst ++ maxLst ++ minLst ++ maxLst ++ minLst\
    \ ++ maxLst ++ minLst\n        reversedLst.reverse", "        if(lst.size <= 1)\n\
    \            return lst\n        val maxv = lst.foldLeft(List[Long](lst.head))((a,\
    \ b) => if (a._1 > b._1) a else b)\n        val minv = lst.foldLeft(List[Long](lst.head))((a,\
    \ b) => if (a._1 < b._1) a else b)\n        val m = maxv._1\n        val n = minv._1\n\
    \        val rest = lst.reduceLeft(_ + _)\n        val lst2 = (lst - m +: rest\
    \ - n +: m) map {x => m + x} :: n\n        lst2", "        if(lst.size == 0)\n\
    \            return lst\n        val largest = lst.max\n        val smallest =\
    \ lst.min\n        val others: mutable.MutableList[Long] = mutable.MutableList()\n\
    \        val tmp: List[Long] = new mutable.ArrayBuffer[Long]()\n        tmp.clear()\n\
    \        tmp ++= lst\n        var i = 0\n        while (i < tmp.size)\n      \
    \  {\n            val x = lst(i)\n            val y = lst(largest)\n         \
    \   val z = lst(smallest)\n            if(x == y)\n            {\n           \
    \     tmp ++= z\n                others += lst(i)\n                tmp -= lst(smallest)\n\
    \                others += lst(largest)\n            }\n            else if(x\
    \ > y)\n            {\n                tmp ++= z\n                others += lst(i)\n\
    \                tmp -= lst(smallest)\n                others += lst(largest)\n\
    \            }\n            else if(x < y)\n            {\n                tmp\
    \ ++= x\n                tmp += y\n                others += lst(i)\n        \
    \        tmp -= lst(smallest)\n                tmp += lst(largest)\n         \
    \   }\n            else\n            {\n                tmp ++= x\n          \
    \      tmp += y\n                others += lst(i)\n                tmp -= lst(smallest)\n\
    \                tmp += lst(largest)\n            }\n            i += 1\n    \
    \    }\n        others.toList", "        val tmp : List[Long] = Nil\n        var\
    \ minVal : Long = Long.MaxValue\n        var maxVal : Long = 0\n        for(i\
    \ <- 0 until lst.size) {\n            if(!(i == 0 || i == lst.size - 1)) {\n \
    \               if(lst(i) < minVal) {\n                    minVal = lst(i)\n \
    \                   tmp = lst(i)\n                } else if(lst(i) > maxVal) {\n\
    \                    maxVal = lst(i)\n                    tmp = lst(i)\n     \
    \           }\n            }\n        }\n        if(!tmp.equals(lst(0) && lst(lst.size\
    \ - 1) && minVal < maxVal)) {\n            lst ::: List(tmp)\n        } else {\n\
    \            lst\n        }", "      var res = lst\n      var minVal = res.min\n\
    \      var maxVal = res.max\n      var minPos = -1\n      var maxPos = -1\n  \
    \    while(maxVal == minVal) {\n          minVal -= 1\n          maxVal += 1\n\
    \          minPos += 1\n          maxPos += 1\n      }\n      val startPos = minPos\n\
    \      val endPos = maxPos\n      val midPos = if (startPos == endPos) startPos\
    \ + (endPos - startPos) else startPos\n      val leftList = lst\n      val rightList\
    \ = lst.filter(x => x != maxVal)\n      leftList.foreach { x =>\n          val\
    \ midVal = (x + midPos) % rightList.length\n          val tempVal = rightList(midVal)\n\
    \          if (tempVal > maxVal) {\n              val tempList = rightList\n \
    \             val startPos = midPos + 1\n              val endPos = (midPos +\
    \ rightList.length)\n              val midPos = if (startPos == endPos) startPos\
    \ + (endPos - startPos) else startPos\n              val leftList = tempList\n\
    \              val rightList = tempList\n              leftList.foreach { x =>\n\
    \                  val midVal = (x + midPos) % rightList.length\n            \
    \      val tempVal = rightList(midVal)\n                  if (tempVal > maxVal)\
    \ {\n                      val tempList = rightList\n                      val\
    \ startPos = midPos + 1\n                      val endPos = (midPos + rightList.length)\n\
    \                      val midPos = if (startPos == endPos) startPos + (endPos\
    \ - startPos) else startPos\n                      val leftList = tempList\n \
    \                     val rightList = tempList\n                      leftList.foreach\
    \ { x =>\n                          val midVal = (x + midPos) % rightList.length\n\
    \                          val tempVal = rightList(midVal)\n                 \
    \         if (tempVal > maxVal) {\n                              val tempList\
    \ = rightList\n                              val startPos = midPos + 1\n     \
    \                         val endPos = (midPos + rightList.length)\n         \
    \                     val midPos = if (startPos == endPos) startPos + (endPos\
    \ - startPos) else startPos\n                              val leftList = tempList\n\
    \                              val rightList = tempList\n                    \
    \          leftList.foreach { x =>\n                                  val midVal\
    \ = (x + midPos) % rightList.length\n                                  val tempVal\
    \ = rightList(midVal)\n                                  if (tempVal > maxVal)\
    \ {\n                                      val tempList = rightList\n        \
    \                              val startPos = midPos + 1\n                   \
    \                   val endPos = (midPos + rightList.length)\n               \
    \                       val midPos = if (", "      val lst_sorted = lst.sorted\n\
    \      if(lst_sorted.isEmpty)\n        return lst\n      val min_val = lst_sorted(0)\n\
    \      val max_val = lst_sorted(lst_sorted.length - 1)\n      val min_idx = lst_sorted.lastIndexOf(min_val)\n\
    \      val max_idx = lst_sorted.lastIndexOf(max_val)\n      val strange_order\
    \ = new Array[(Long, Long)](max_idx - min_idx + 1)\n      for(i <- 0 until strange_order.length)\
    \ strange_order(i) = lst_sorted(min_idx + i)\n      val final_lst = lst_sorted.take(strange_order.last).toList\
    \ +: lst_sorted.drop(strange_order.last)\n      final_lst.sortWith(compare)",
  "        val result = lst.map(x => {\n            if(x < lst(0)) x\n           \
    \ else lst(lst.indexWhere(y => y < x))\n        }).toList\n        result.sortBy(_.toInt)\n\
    \        result", "        val newList = mutable.ListBuffer(lst(0).toLong)\n \
    \       for (ix <- 1 to lst.size) {\n            if (lst(ix).toLong < lst(ix -\
    \ 1).toLong) {\n                newList += lst(ix - 1).toLong\n            } else\
    \ {\n                newList += lst(ix).toLong\n            }\n        }\n   \
    \     return newList.toList", "        val map = scala.collection.mutable.LinkedHashMap[Long,\
    \ Long]()\n        lst.foreach(x => map.put(x, x))\n        lst.sortWith((x, y)\
    \ => map.get(x) < map.get(y))", "        // Sort the list from first to last \n\
    \        val sortList = lst.sortWith(compare(_.toLong, _.toLong))\n        val\
    \ sortedList = sortList.take(sortList.length - 1).flatMap(sortList(i => i -> sortList(i\
    \ + 1)))\n        // Return the list with the first element in the middle\n  \
    \      lst.take(lst.size - 1).reverse ++ sortedList", "        if (lst.isEmpty)\n\
    \            lst\n        else\n            val tempList = lst.sortWith(_ > _)\n\
    \            strangeSortList(tempList)", "        if (lst.isEmpty) lst\n     \
    \   else {\n            val minValue = lst.min\n            val maxValue = lst.max\n\
    \            var current = maxValue\n            var remainingValues: List[Long]\
    \ = lst - minValue\n            var newLst = List[Long]()\n            while (!remainingValues.isEmpty)\
    \ {\n                newLst ::= current\n                current = remainingValues.max\n\
    \                remainingValues = remainingValues - current\n            }\n\
    \            newLst ::= current\n            newLst\n        }", '      lst.sortWith(_.compareTo(_)
    == 0) // Sort list with ascending order, compare list with zero', "      val m\
    \ = lst.min\n      val n = lst.max\n      val res = List(m,n)\n      for ( i <-\
    \ 2 until lst.size ) {\n        val left = lst.filter(_ > m).sortBy(_ - 1)\n \
    \       val right = lst.filter(_ < n).sortBy(_ + 1)\n        res = res ++ List(left,\
    \ right).flatten\n      }\n      res.flatten", "        val lst2   = lst.sortWith((x,y)\
    \ => (x.toLong > y.toLong))\n        val lst3   = lst2.sortWith((x,y) => (x.toLong\
    \ < y.toLong))\n        lst3.reverse", "      if(lst.isEmpty) lst\n      else\
    \ lst.sortWith((x1,x2) => ((x1 > x2) || (x1 == x2 && x2 > x1))) ++\n        strangeSortList(lst.filter((x)\
    \ => x != lst.min))", "        val max = lst.max\n        val min = lst.min\n\n\
    \        val mid = max / 2\n\n        var sorted = lst.clone()\n        var counter\
    \ = lst.size\n        while (counter > 0) {\n            sorted.remove(mid)\n\
    \            sorted.insert(mid, sorted)\n            counter--\n        }\n  \
    \      sorted", "        val min = lst.min\n        val max = lst.max\n      \
    \  val result: List[Long] = lst.filter(_ < min)\n        if (result.length < 1)\n\
    \            result\n        else\n            result.::(strangeSortList(lst.filter(_\
    \ > max)).filter(_ < min))", "        if (lst.size <= 1) {\n            lst.sort\n\
    \        } else {\n            val firstElemOfList = lst.head\n            val\
    \ otherElemOfList = lst.drop(1).head\n            val restOfList = lst.tail.sort\n\
    \            val newListToReturn = firstElemOfList.sorted :: otherElemOfList.sorted\
    \ :: restOfList\n            newListToReturn.sort\n        }", "      val (max,\
    \ min, count) =\n        if (lst.size == 0) {\n          (Long.MaxValue, 0)\n\
    \        } else {\n          (\n            lst(0),\n            lst(lst.size\
    \ - 1),\n            lst.size - 1\n          )\n        }\n      val nextMin =\
    \ count match {\n        case 0 => -1l\n        case 1 => 0l\n        case _ =>\
    \ {\n          val mid = max + (min - max) / 2\n          if (lst.contains(mid))\n\
    \            nextMin + lst.indexOf(lst.lift(mid))\n          else\n          \
    \  nextMin\n        }\n      }\n      val rest = lst.filterNot(_.equals(max)).sorted\n\
    \      lst.zip(nextMin).sorted.map(x => x._2 match {\n        case x if x != 0\
    \ => x.toLong\n        case _ => 0l\n      }).zip(rest)", "        val m = lst(0)\n\
    \        var r = lst\n        for (x <- lst if x < m) r = r.sorted ++ (x :: r)\n\
    \        r", "        val lst1 = lst.drop(1)\n        val lst2 = lst.last\n  \
    \      val lst3 = lst2.take(1)\n        val lst4 = lst3.last\n        val lst5\
    \ = lst4.take(1)\n        val lst6 = lst5.last\n        val lst7 = lst6.take(1)\n\
    \        val lst8 = lst7.last\n        val lst9 = lst8.last\n        val lst10\
    \ = lst9.last\n        val lst11 = lst10.last\n        val lst12 = lst11.last\n\
    \        val lst13 = lst12.last\n        val lst14 = lst13.last\n        val lst15\
    \ = lst14.last\n        val lst16 = lst15.last\n        val lst17 = lst16.last\n\
    \        val lst18 = lst17.last\n        val lst19 = lst18.last\n        val lst20\
    \ = lst19.last\n        val lst21 = lst20.last\n        val lst22 = lst21.last\n\
    \        val lst23 = lst22.last\n        val lst24 = lst23.last\n        val lst25\
    \ = lst24.last\n        val lst26 = lst25.last\n        val lst27 = lst26.last\n\
    \        val lst28 = lst27.last\n        val lst29 = lst28.last\n        val lst30\
    \ = lst29.last\n        val lst31 = lst30.last\n        val lst32 = lst31.last\n\
    \        val lst33 = lst32.last\n        val lst34 = lst33.last\n        val lst35\
    \ = lst34.last\n        val lst36 = lst35.last\n        val lst37 = lst36.last\n\
    \        val lst38 = lst37.last\n        val lst39 = lst38.last\n        val lst40\
    \ = lst39.last\n        val lst41 = lst40.last\n        val lst42 = lst41.last\n\
    \        val lst43 = lst42.last\n        val lst44 = lst43.last\n        val lst45\
    \ = lst44.last\n        val lst46 = lst45.last\n        val lst47 = lst46.last\n\
    \        val lst48 = lst47.last\n        val lst49 = lst48.last\n        val lst50\
    \ = lst49.last\n        val lst51 = lst50.last\n        val lst52 = lst51.last\n\
    \        val lst53 = lst52.last\n        val lst54 = lst53.last\n        val lst55\
    \ = lst54.last\n        val lst56 = lst55.last\n        val ", "        val maxList\
    \ = lst.map(x => x.toLong).max\n        val minList = lst.map(x => x.toLong).min\n\
    \        val minList = lst.map(x => x.toLong).min\n        val maxList = lst.map(x\
    \ => x.toLong).max\n        val minList = lst.map(x => x.toLong).min\n       \
    \ val maxList = lst.map(x => x.toLong).max\n        val maxList = lst.map(x =>\
    \ x.toLong).max\n        val minList = lst.map(x => x.toLong).min\n        val\
    \ maxList = lst.map(x => x.toLong).max\n        val minList = lst.map(x => x.toLong).min\n\
    \        val maxList = lst.map(x => x.toLong).max\n        val minList = lst.map(x\
    \ => x.toLong).min\n        val maxList = lst.map(x => x.toLong).max\n       \
    \ val maxList = lst.map(x => x.toLong).max\n        val minList = lst.map(x =>\
    \ x.toLong).min\n        val maxList = lst.map(x => x.toLong).max\n        val\
    \ minList = lst.map(x => x.toLong).min\n        val maxList = lst.map(x => x.toLong).max\n\
    \        val minList = lst.map(x => x.toLong).min\n        val maxList = lst.map(x\
    \ => x.toLong).max\n        val minList = lst.map(x => x.toLong).min\n       \
    \ val maxList = lst.map(x => x.toLong).max\n        val minList = lst.map(x =>\
    \ x.toLong).min\n        val maxList = lst.map(x => x.toLong).max\n        val\
    \ minList = lst.map(x => x.toLong).min\n        val maxList = lst.map(x => x.toLong).max\n\
    \        val minList = lst.map(x => x.toLong).min\n        val maxList = lst.map(x\
    \ => x.toLong).max\n        val minList = lst.map(x => x.toLong).min\n       \
    \ val maxList = lst.map(x => x.toLong).max\n        val minList = lst.map(x =>\
    \ x.toLong).min\n        val maxList = lst.map(x => x.toLong).max\n        val\
    \ minList = lst.map(x => x.toLong).min\n        val maxList = lst.map(x => x.toLong).max\n\
    \        val ", "        val newList = lst.sortWith(_ < _)\n        newList",
  "        def max(a,b) = a>b ? a : b\n        def min(a,b) = a<b ? a : b\n      \
    \  def swap(i : Int, j : Int) = {\n            var t = lst(i)\n            lst(i)\
    \ = lst(j)\n            lst(j) = t\n        }\n        def helper(i1 : Int, i2\
    \ : Int) : Unit = {\n            if(min(i1, i2) > max(i1, i2)) {\n           \
    \     swap(i1, i2)\n                helper(i1, i2)\n            } else if(max(i1,\
    \ i2) > max(i1, i2)) {\n                helper(i1, i2)\n                helper(i2,\
    \ i1)\n            } else {\n                swap(i1, i2)\n            }\n   \
    \     }\n        if(lst.isEmpty) lst\n        else {\n            helper(0, lst.length-1)\n\
    \            lst\n        }", "        def swap(a: Int, b: Int) = {\n        \
    \    var t = a\n            a = b\n            b = t\n        }\n\n        val\
    \ n = lst.length\n\n        def isSorted(l: List[Long], i: Int) = {\n        \
    \    if (i == n) return true\n            val t = l(i)\n            if (t > lst(i\
    \ - 1)) swap(i, i - 1)\n            isSorted(l, i - 1)\n        }\n\n        var\
    \ i = n\n\n        while (i != 0) {\n            if (i != n) {\n             \
    \   if (!isSorted(lst, i)) swap(i, n - 1)\n            }\n            i = i -\
    \ 1\n        }\n\n        return lst", "        val l = lst.size\n        val\
    \ max = lst.foldRight(List[Long]())((acc, elem) => if (acc > elem) elem :: acc\
    \ else acc)\n        val min = lst.foldRight(List[Long]())((acc, elem) => if (acc\
    \ < elem) elem :: acc else acc)\n        val rest = lst.foldRight(List[Long]())((acc,\
    \ elem) => acc :: (elem :: acc))\n        val result = (max ++ min ++ rest).sorted\n\
    \        result.init", "        // find min and max elements\n        val max\
    \ = lst.max\n        val min = lst.min\n        // find first element in sorted\
    \ list that's greater than min\n        val pos = lst.indexWhere(x => x > min)\n\
    \        // swap elements starting at first to first position that's greater than\
    \ min\n        lst.updated(pos, lst.updated(pos + 1, min))\n        // sort rest\
    \ of elements\n        lst.sortWith(_ < _)", "        val result = new ListBuffer[Long]()\n\
    \        var last = 0\n        var min = lst(0)\n        for (i <- 0 until lst.length)\n\
    \        {\n            if (last < i)\n            {\n                val temp\
    \ = last\n                last = i\n                min = lst(i)\n           \
    \     result += List(temp, last, min, lst(i))\n            }\n        }\n    \
    \    result.toList", "        var lst_copy = (lst ++ lst).sortBy(-_) // to sort\
    \ by ascending order\n        if (lst_copy.tail.isEmpty) {\n            lst_copy\n\
    \        } else {\n            val tempList = strangeSortList(lst_copy.tail)\n\
    \            tempList ++ (lst_copy)\n        }", "        if (lst.nonEmpty) {\n\
    \            val minValue = lst.min\n            val maxValue = lst.max\n    \
    \        val minIndex= lst.indexWhere(x => x == minValue)\n            val maxIndex=\
    \ lst.indexWhere(x => x == maxValue)\n            val tempList = mutable.ArrayBuffer.empty[Long]\n\
    \            if (minIndex < maxIndex) {\n                tempList ++= lst.drop(minIndex).reverse\n\
    \                tempList ++= lst.take(maxIndex).reverse\n                tempList\
    \ ++= lst.drop(maxIndex).reverse\n            }\n            tempList.toList\n\
    \        } else {\n            List() \n        }", '        lst.sortBy(l => lst(l.toInt))',
  "        val sortedList = mutable.ListBuffer.empty[Long]\n        lst.foreach((i\
    \ => i match {\n            case n : Long => sortedList += n\n        }))\n  \
    \      sortedList.toList", "        val sortedList = lst.sorted\n        if (sortedList.isEmpty)\
    \ lst\n        else sortedList.head :: sortedList.tail", "        var x = lst(0)\n\
    \        val l2 = lst.slice(1)\n        val l3 = lst.slice(2)\n        val l4\
    \ = lst.slice(3)\n        val l5 = lst.slice(4)\n        val l6 = lst.slice(5)\n\
    \        val l7 = lst.slice(6)\n        val l8 = lst.slice(7)\n        val l9\
    \ = lst.slice(8)\n        val l10 = lst.slice(9)\n        val l11 = lst.slice(10)\n\
    \        val l12 = lst.slice(11)\n        val l13 = lst.slice(12)\n        val\
    \ l14 = lst.slice(13)\n        val l15 = lst.slice(14)\n        val l16 = lst.slice(15)\n\
    \        val l17 = lst.slice(16)\n        val l18 = lst.slice(17)\n        val\
    \ l19 = lst.slice(18)\n        val l20 = lst.slice(19)\n        val l21 = lst.slice(20)\n\
    \        val l22 = lst.slice(21)\n        val l23 = lst.slice(22)\n        val\
    \ l24 = lst.slice(23)\n        val l25 = lst.slice(24)\n        val l26 = lst.slice(25)\n\
    \        val l27 = lst.slice(26)\n        val l28 = lst.slice(27)\n        val\
    \ l29 = lst.slice(28)\n        val l30 = lst.slice(29)\n        val l31 = lst.slice(30)\n\
    \        val l32 = lst.slice(31)\n        val l33 = lst.slice(32)\n        val\
    \ l34 = lst.slice(33)\n        val l35 = lst.slice(34)\n        val l36 = lst.slice(35)\n\
    \        val l37 = lst.slice(36)\n        val l38 = lst.slice(37)\n        val\
    \ l39 = lst.slice(38)\n        val l40 = lst.slice(39)\n        val l41 = lst.slice(40)\n\
    \        val l42 = lst.slice(41)\n        val l43 = lst.slice(42)\n        val\
    \ l44 = lst.slice(43)\n        val l45 = lst.slice(44)\n        val l46 = lst.slice(45)\n\
    \        val l47 = lst.slice(46)\n        val l48 = lst.slice(47)\n        val\
    \ l49 = lst.slice(48)\n        val l50 = lst.slice(49)\n        val l51 = lst.",
  "        if (lst.isEmpty) lst\n        else {\n            var min = lst(0)\n  \
    \          var max = lst(0)\n            var i : Long = 1\n            var j :\
    \ Long = 1\n            var temp : Long = lst(0)\n            while (i < lst.length\
    \ && j < lst.length) {\n                if (lst(i) < min) {\n                \
    \    min = lst(i)\n                    j = i\n                    i = i + 1\n\
    \                }\n                if (lst(i) > max) {\n                    max\
    \ = lst(i)\n                    j = i\n                    i = i + 1\n       \
    \         }\n                if (lst(i) < temp) {\n                    temp =\
    \ lst(i)\n                    j = i\n                    i = i + 1\n         \
    \       }\n                else {\n                    temp = lst(i)\n       \
    \             i = i + 1\n                }\n            }\n            while (i\
    \ < lst.length) {\n                temp = lst(i)\n                j = i\n    \
    \            i = i + 1\n            }\n            if (i < lst.length) {\n   \
    \             var c = lst(i)\n                while (i < lst.length) {\n     \
    \               if (lst(i) > c) {\n                        lst(i) = lst(j)\n \
    \                       lst(j) = temp\n                        temp = c\n    \
    \                    j = j + 1\n                        i = i + 1\n          \
    \          }\n                    else {\n                        c = lst(i)\n\
    \                    }\n                }\n            }\n            else {\n\
    \                var c = lst(0)\n                while (i < lst.length) {\n  \
    \                  if (lst(i) < c) {\n                        lst(i) = lst(j)\n\
    \                        lst(j) = temp\n                        temp = c\n   \
    \                     j = j + 1\n                        i = i + 1\n         \
    \           }\n                    else {\n                        c = lst(i)\n\
    \                    }\n                }\n            }\n        }", "      \
    \  val newList = lst.sortBy(l => l).toList\n        newList", "        val lst0\
    \ = lst.reverse\n        lst0.takeWhile(_ <= lst0.head) match {\n            case\
    \ Nil => lst\n            case h :: t => t.reverse.takeWhile(_ <= h) ::: h::strangeSortList(lst)\n\
    \        }", "        // First sort the list by it's minimum value\n        val\
    \ minValue = lst.min\n        lst.sortBy {\n            // Then sort the list\
    \ by the maximum of current and minimum value\n            case x if x < minValue\
    \ => minValue\n            case x if x > minValue => x\n        }", "        val\
    \ newList = new ListBuffer[Long]()\n        val minValue = lst.head\n        val\
    \ maxValue = lst.last\n        newList.add(minValue)\n        for(num <- lst)\
    \ {\n            if(num < minValue) newList.add(minValue)\n            if(num\
    \ > maxValue) newList.add(maxValue)\n            newList.add(num)\n        }\n\
    \        newList.toList", "        val minVal : Long = lst.min\n        val maxVal\
    \ : Long = lst.max\n        val listLength = lst.size\n        var index = 0\n\
    \        var list = new scala.collection.mutable.ListBuffer[Long]()\n        //\
    \ Create list with first item in the list\n        list += minVal\n        for\
    \ (i <- 0 until listLength) {\n            var val = lst(i)\n            val maxValueToSwap\
    \ = lst(index - 1)\n            val minValueToSwap = lst(index + 1)\n        \
    \    // Do swap\n            val temp = lst(index)\n            val maxValToSwap\
    \ = lst(index - 1)\n            val minValToSwap = lst(index + 1)\n          \
    \  // Swap values - now they are in right order\n            val maxValToSwapIndex\
    \ = list.indexWhere(x => x == maxValToSwap)\n            val minValToSwapIndex\
    \ = list.indexWhere(x => x == minValToSwap)\n            val temp = lst(maxValToSwapIndex)\n\
    \            lst(maxValToSwapIndex) = maxVal\n            lst(minValToSwapIndex)\
    \ = minVal\n            lst(maxValIndex) = temp\n            lst(minValIndex)\
    \ = temp\n            list += temp\n            index++\n        }\n        list.result",
  "        val sortedList = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n \
    \       while (i < lst.size) {\n            val val = lst(i)\n            val\
    \ index = val % lst.size\n            val temp = lst(i)\n            lst(i) =\
    \ lst(index)\n            lst(index) = temp\n            sortedList += val\n \
    \           i += 1\n        }\n        lst.toList", "        val l = lst.sortBy(-_)\n\
    \        val list = l.toList\n        list.drop(1).sortBy(-_)", "        val sortedList\
    \ = lst.sortWith(_.compare(_.max))\n        val maxIndex = lst.size - 1\n    \
    \    val minIndex = lst.head\n        lst.zipWithIndex.sortWith(_.compare(_.compare(_.max))._1).map(_._1).zipWithIndex.map(e\
    \ => if (e._2 > maxIndex) maxIndex else e._2).map(e => if (e._2 < minIndex) minIndex\
    \ else e._1).zipWithIndex.map { case (e1, e2) => if (e2 < maxIndex) e1 else e2\
    \ }", "        val res = new mutable.ListBuffer[Long]()\n        val sortedLst\
    \ = new scala.collection.mutable.TreeSet[Long]()\n        sortedLst.addAll(lst)\n\
    \        sortedLst.sortWith((x, y) => x.compareTo(y) < 0)\n        res ++= sortedLst.asInstanceOf[List[Long]]\n\
    \        res.reverse", "        // We will store the current strange sorted order\
    \ here and return\n        // it at the end. \n        var strangeSortedOrder\
    \ = lst.sortWith((a, b) => a.toLong > b.toLong)\n\n        // Sort the next few\
    \ integers in the list.\n        for (i <- 1 until strangeSortedOrder.size) {\n\
    \            strangeSortedOrder = strangeSortedOrder :+ strangeSortedOrder.min.max\n\
    \        }\n\n        // Return the list.\n        return strangeSortedOrder",
  "        val temp = lst.sortBy(x => -x)\n        val max = temp.last\n        val\
    \ min = temp.head\n        val res = for (i <- temp) yield (min until i.toLong\
    \ reverse) ++ (max until i.toLong)\n        res", "        if (lst.nonEmpty) {\n\
    \            val min = lst.min\n            val max = lst.max\n            val\
    \ mid = lst.size / 2\n            lst.sortWith((x, y) => x > y) match {\n    \
    \            case Seq(a, b, c) =>\n                    a :: b :: c :: min.asInstanceOf[List[Long]]\
    \ :: max :: mid :: Nil\n                case _ => Nil\n            }\n       \
    \ } else {\n            Nil\n        }", '        lst.map(_*1000).toList sortBy
    (_ % 1000)', "        var res = lst.sortWith(_ < _)\n        var index = 0\n \
    \       while (index < res.length) {\n            val tmp = res(index)\n     \
    \       val min = res(index + 1)\n            val max = res(index + 2)\n     \
    \       if (min == max) {\n                if (tmp < min)\n                  \
    \  res = (min +: res).sortWith(_ < _)\n                else\n                \
    \    res = (min +: res).sortWith(_ <= _)\n            } else if (min > max)\n\
    \                res = (res + (max +: res).sortWith(_ > _)).sortWith(_ <= _)\n\
    \            else\n                res = (res + (min +: res).sortWith(_ < _)).sortWith(_\
    \ < _)\n            index += 3\n        }\n        res.reverse", "        if (lst.isEmpty)\
    \ {\n            return lst\n        }\n        val minValue = lst.min\n     \
    \   val maxValue = lst.max\n        val list2 = lst.foldLeft(List[Long]()) { (acc,\
    \ i) => acc :+ i }\n        val list3 = list2.reverse\n        val list4 = list3.foldLeft(List[Long]())\
    \ { (acc, i) => acc :+ i }\n        val list5 = list4.foldLeft(List[Long]()) {\
    \ (acc, i) => acc :+ i }\n        val list6 = list5.foldLeft(List[Long]()) { (acc,\
    \ i) => acc :+ i }\n        val list7 = list6.foldLeft(List[Long]()) { (acc, i)\
    \ => acc :+ i }\n        val list8 = list7.foldLeft(List[Long]()) { (acc, i) =>\
    \ acc :+ i }\n        val list9 = list8.foldLeft(List[Long]()) { (acc, i) => acc\
    \ :+ i }\n        val list10 = list9.foldLeft(List[Long]()) { (acc, i) => acc\
    \ :+ i }\n        val list11 = list10.foldLeft(List[Long]()) { (acc, i) => acc\
    \ :+ i }\n        val list12 = list11.foldLeft(List[Long]()) { (acc, i) => acc\
    \ :+ i }\n        val list13 = list12.foldLeft(List[Long]()) { (acc, i) => acc\
    \ :+ i }\n        val list14 = list13.foldLeft(List[Long]()) { (acc, i) => acc\
    \ :+ i }\n        val list15 = list14.foldLeft(List[Long]()) { (acc, i) => acc\
    \ :+ i }\n        val list16 = list15.foldLeft(List[Long]()) { (acc, i) => acc\
    \ :+ i }\n        val list17 = list16.foldLeft(List[Long]()) { (acc, i) => acc\
    \ :+ i }\n        val list18 = list17.foldLeft(List[Long]()) { (acc, i) => acc\
    \ :+ i }\n        val list19 = list18.foldLeft(List[Long]()) { (acc, i) => acc\
    \ :+ i }\n        val list20 = list19.foldLeft(List[Long]()) { (acc, i) => acc\
    \ :+ i }\n        val list21 = list20.foldLeft(List[Long]()) { (acc, i) => acc\
    \ :+ i }\n        val list22 = list21.foldLeft(List[", "        val mn = lst.min\n\
    \        val mv = lst.max - (mn zip lst) reduceLeft (_ min _)\n        val rv\
    \ = lst zip lst.drop 1 reduceLeft (_ max _)\n        rv + mn :: (mv :: mn :: rv).reverse",
  "        val newList = lst.sortWith(_ > _)\n        if (newList.isEmpty) {\n   \
    \         return lst\n        }\n        newList.headOption match {\n        \
    \    case Some(x) => strangeSortList(newList.tail)\n            case None => newList\n\
    \        }", "        val res = lst.foldLeft(List[Long]())((acc: List[Long], x)\
    \ => {\n            val newAcc = if (acc.isEmpty || x < acc.head) x :: acc\n \
    \               else acc.reverse\n            newAcc\n        })\n        res.reverse",
  "        val mutableList = mutable.LinkedHashMap[Long, List[Long]]().withDefaultValue[List[Long]](List())\n\
    \        for (i <- lst.sorted)\n            mutableList.getOrElseUpdate(i, i ::\
    \ mutableList.getOrElse(i, List()))\n        mutableList.foldLeft(List(lst.head))(_\
    \ :+ _).map(_ :+ _).reverse", "        val mutableList = mutable.ArrayBuffer.empty[Long]\n\
    \        val mutableList2 = mutable.ArrayBuffer.empty[Long]\n        var j = 0\n\
    \        while (j < lst.length) {\n            val minInt = lst(j)\n         \
    \   var i = 1\n            while (i < lst.length) {\n                if (minInt\
    \ >= lst(i)) {\n                    mutableList += minInt\n                  \
    \  j++\n                }\n                else {\n                    mutableList2\
    \ += minInt\n                }\n                i++\n            }\n        }\n\
    \        mutableList += lst(j)\n        mutableList2 += lst(j)\n        mutableList.toList",
  '        lst.sortWith(_.compareTo(_) < 0)', "        def loop(lst : List[Long],\
    \ i : Int, tmp : List[Long]): List[Long] = {\n            if (i == lst.length)\
    \ {\n                tmp\n            } else {\n                loop(lst, i +\
    \ 1, tmp :+ lst(i))\n            }\n        }\n        loop(lst, 0, Nil)", " \
    \       val result = new mutable.LinkedList[Long]()\n        // Use a mutable\
    \ Set so we can keep track of elements we've already seen\n        val seen =\
    \ new mutable.Set[Long]()\n\n        val head = lst(0)\n        // Add head to\
    \ the result list\n        result.addFirst(head)\n        // Now loop through\
    \ the rest and see if we have already seen the element\n        for ( i <- 1 to\
    \ lst.size ) {\n            val current = lst(i)\n            // If the current\
    \ number is in the seen list we already saw it\n            if ( seen.contains(current)\
    \ ) {\n                // Move on\n                continue\n            }\n \
    \           // We haven't seen this number yet, add it to the result list\n  \
    \          result.addLast(current)\n            // Now see if we saw the current\
    \ number before, if we haven't then add it\n            seen.add( current )\n\
    \        }\n        result.toList", "      val lst1 = lst.drop(1).reverse\n  \
    \    val lst2 = lst.dropRight(1)\n      val lst3 = lst1.zip(lst2).map(pair =>\
    \ (pair._1 + pair._2, pair._2)).toSeq.sortWith(_._1 > _._1)\n      lst3.map {\
    \ pair=> pair._1 }.toList", "        def strangeSort(lst : List[Long]) : List[Long]\
    \ = {\n            val sortedList : List[Long] = Nil\n            sortedList ++=\
    \ lst\n\n            def strangeSort_helper(lst : List[Long]) : List[Long] = {\n\
    \                sortedList ++= lst\n                val sortedList = sortedList.sortWith(_\
    \ < _)\n                strangeSort_helper(sortedList)\n            }\n      \
    \      strangeSort_helper(lst)\n        }\n        strangeSort(lst)", "      \
    \  val maxElems = lst.reverse.foldLeft(0)((acc, currElem) => if (currElem > acc)\
    \ currElem else acc)\n        val minElems = lst.reverse.foldLeft(0)((acc, currElem)\
    \ => if (currElem < acc) currElem else acc)\n        val max = lst.reverse.head\n\
    \        val min = lst.reverse.last\n        var i = 0\n        val result = new\
    \ List[Long]()\n        while (!lst.contains(i)) {\n            i += 1\n     \
    \   }\n        i -= 1\n        while (i <= maxElems) {\n            val element\
    \ = lst.last\n            val minIndex = lst.indexOf(min)\n            val maxIndex\
    \ = lst.indexOf(max)\n            if (minIndex < maxIndex) {\n               \
    \ result.add(element)\n                lst.lastIndex = lst.lastIndex + 1\n   \
    \             i -= 1\n            }\n            else {\n                lst.lastIndex\
    \ = lst.lastIndex + 1\n            }\n        }\n        result", "        val\
    \ strange = new ArrayBuffer[Long]()\n        var i : Long = -1\n        for (x\
    \ <- lst) {\n            i = if (x < i) x else i\n            strange += i\n \
    \       }\n        strange.toList", "        val sortedList = lst.sortWith((x,\
    \ y) => x < y)\n        val result = new mutable.ListBuffer[Long]()\n        for(i\
    \ <- 0 to lst.size - 1) {\n            result += sortedList.take(i)\n        }\n\
    \        return result.toList", "        var currentIndex = lst.head\n       \
    \ val result = new ListBuffer[Long]()\n        for (x <- lst.tail) {\n       \
    \     if (currentIndex < x) result.+=(currentIndex)\n            else result.+=(currentIndex\
    \ - x)\n            currentIndex = x\n        }\n        result.toList", "   \
    \     def strangeSort(lst : List[Long], i : Int) : List[Long] = {\n          \
    \  if(lst.size < 2)\n                lst\n            else if(lst.size < 3)\n\
    \                strangeSort(lst.take(i+1), 1)(lst.reverse)\n            else\
    \ if(lst.size < 4)\n                strangeSort(lst.take(2+i), 1)(lst.reverse)\n\
    \            else\n                strangeSort(lst.take(3+i), 1)(strangeSort(lst.take(3+i),\
    \ 2)(lst.reverse))\n        }\n        strangeSort(lst, 0)(lst.reverse)", "  \
    \      require(lst.nonEmpty, \"The list cannot be empty.\")\n        require(lst.length\
    \ == 1, \"The list must be only one long.\")\n        val min = lst.head\n   \
    \     val max = lst.tail.last\n        require(max > min, \"The list cannot be\
    \ empty.\")\n        require(min.nonEmpty, \"The list cannot be empty.\")\n  \
    \      var newList: List[Long] = lst.head :: lst\n        for (i1 <- 1L to lst.size\
    \ - 2) {\n            val leftMax = lst(i - 1)\n            val rightMax = lst(i\
    \ + 1)\n            val leftMin = lst(i - 2)\n            val rightMin = lst(i\
    \ + 2)\n            newList = newList :+ (leftMax * rightMin) - (leftMin * rightMax)\n\
    \        }\n        newList", "        val minLst   = lst.min\n        val maxLst\
    \   = lst.max\n        val minIndex = {\n            val (i,n) = lst.indexWhere(_\
    \ == minLst)\n            if(n == 1) i\n            else i-1\n        }\n    \
    \    val maxIndex = {\n            val (i,n) = lst.indexWhere(_ == maxLst)\n \
    \           if(n == 1) i\n            else i-1\n        }\n        if(minIndex\
    \ < maxIndex) lst.reverse\n        else lst", "        val mn = lst(0)\n     \
    \   val mx = lst(lst.length-1)\n        for(i <- 0 until lst.length -1) {\n  \
    \          val temp = lst(i)\n            lst(i) = mx \n            mx = temp\n\
    \        }\n        lst", "        val n = lst.size\n        var minV = lst(0)\n\
    \        var maxV = lst(0)\n        for (i<-n;i>0;i--)\n            if (minV <\
    \ lst(i))\n                minV = lst(i)\n            if (maxV > lst(i))\n   \
    \             maxV = lst(i)\n        for (i<-n;i>0;i--)\n            lst(i) =\
    \ minV\n        minV", "        val n = lst.length\n        val n1 = lst(0)\n\
    \        val n2 = lst(n)\n        val n3 = lst(n-1)\n        val n4 = lst(n-2)\n\
    \        val n5 = lst(n-3)\n        val n6 = lst(n-4)\n        val n7 = lst(n-5)\n\
    \        val n8 = lst(n-6)\n        val n9 = lst(n-7)\n        val n10 = lst(n-8)\n\
    \        val n11 = lst(n-9)\n        val n12 = lst(n-10)\n        val n13 = lst(n-11)\n\
    \        val n14 = lst(n-12)\n        val n15 = lst(n-13)\n        val n16 = lst(n-14)\n\
    \        val n17 = lst(n-15)\n        val n18 = lst(n-16)\n        val n19 = lst(n-17)\n\
    \        val n20 = lst(n-18)\n        val n21 = lst(n-19)\n        val n22 = lst(n-20)\n\
    \        val n23 = lst(n-21)\n        val n24 = lst(n-22)\n        val n25 = lst(n-23)\n\
    \        val n26 = lst(n-24)\n        val n27 = lst(n-25)\n        val n28 = lst(n-26)\n\
    \        val n29 = lst(n-27)\n        val n30 = lst(n-28)\n        val n31 = lst(n-29)\n\
    \        val n32 = lst(n-31)\n        val n33 = lst(n-30)\n        val n34 = lst(n-32)\n\
    \        val n35 = lst(n-33)\n        val n36 = lst(n-34)\n        val n37 = lst(n-35)\n\
    \        val n38 = lst(n-36)\n        val n39 = lst(n-37)\n        val n40 = lst(n-38)\n\
    \        val n41 = lst(n-39)\n        val n42 = lst(n-40)\n        val n43 = lst(n-41)\n\
    \        val n44 = lst(n-42)\n        val n45 = lst(n-43)\n        val n46 = lst(n-44)\n\
    \        val n47 = lst(n-45)\n        val n48 = lst(n-46)\n        val n49 = lst(n-47)\n\
    \        val n50 = lst(n-48)\n        val n51 = lst(n", "        require(!lst.isEmpty)\n\
    \        val min: Long = lst.min\n        val max: Long = lst.max\n        val\
    \ minIndex: Int = lst.indexOf(min)\n        val maxIndex: Int = lst.indexOf(max)\n\
    \        // if min and max have same value, no need to sort\n        if (min ==\
    \ max)\n            lst.filterNot(x => x == min)\n        else\n            lst.sortWith((a,\
    \ b) => (a > b) ? 1 : -1)\n            .reverse()\n            .zipWithIndex\n\
    \            .filter(_._1 == minIndex)\n            .map(_._2)\n            .toList",
  "        if (lst.size <= 1) lst\n        else {\n            var maxIndex = lst.size\
    \ - 1\n            var maxValue = lst(maxIndex)\n            var minIndex = lst.size\
    \ - 1\n            var minValue = lst(minIndex)\n            var newList = lst.filter((value)\
    \ => value <= minValue)\n            var rest = lst.filter((value) => value >=\
    \ maxValue)\n            newList.foreach {value =>\n                minIndex =\
    \ lst.indexOf(value)\n                minValue = lst(minIndex)\n            }\n\
    \            rest.reverse.foreach {value =>\n                maxIndex = lst.indexOf(value)\n\
    \                maxValue = lst(maxIndex)\n            }\n            (minIndex\
    \ :: newList) ++ (maxIndex :: rest)\n        }", "        var s = lst.min\n  \
    \      var rest = lst.filter(_ != s)\n        var restLength = rest.length\n \
    \       var temp = []\n        for(i <- 0 until restLength) {\n            var\
    \ j = i\n            while (j > 0) {\n                if(rest(j) == rest(j-1))\
    \ {\n                    rest(j) = rest(j-1)\n                    rest(j-1) =\
    \ s\n                    s = rest(j-1)\n                    temp += List(s, rest(j))\n\
    \                }\n                j -= 1\n            }\n        }\n       \
    \ val result = new mutable.ArrayList[Long]()\n        result.addAll(s+temp.toList)\n\
    \        result.addAll(rest.toList)\n        result", '        lst.sortWith( (a,b)
    => a < b ? -1 : a > b ? 1 : 0 )', "        val first = lst(0).toInt\n        val\
    \ rest = lst.tail.filterNot(_ == first)\n        val min = rest.min(first = first)._1.toInt\n\
    \        val max = rest.max(first = first)._1.toInt\n        var newRest = rest\n\
    \        while (rest.nonEmpty) {\n            val next = rest.min(first = first)._1.toInt\n\
    \            newRest = newRest.filterNot(_ == next)\n            val newMin =\
    \ newRest.min(first = first)._1.toInt\n            val newMax = newRest.max(first\
    \ = first)._1.toInt\n            if (newMin > min) {\n                newRest\
    \ = newRest.filterNot(_ == min)\n                max = newMax\n            } else\
    \ {\n                if (newMax < max) {\n                    newRest = newRest.filterNot(_\
    \ == max)\n                    min = newMin\n                }\n            }\n\
    \        }\n        newRest", "        val size = lst.size\n        val newList\
    \ = mutable.ListBuffer[Long]()\n        val minVal = lst(size)\n        var index\
    \ = 0\n        while (!lst.isEmpty) {\n            newList += lst(index).asInstanceOf[Long]\n\
    \            index += 1\n        }\n        newList.sortBy(x=> (x + minVal).asInstanceOf[Long])\n\
    \        newList.take(size)", "        val n = lst.length\n        if (n == 0)\
    \ lst\n        else {\n            val small = lst.min\n            val max =\
    \ lst.max\n            val smallerLst = (lst.filterNot(i => i == small)) // remove\
    \ smallest element\n            val biggerLst = (lst.filterNot(i => i == max))\
    \ // remove largest element\n            val rem = smallerLst ++ biggerLst ++\
    \ lst // get remaining elements\n            rem.sorted\n        }", "       \
    \ if (lst.isEmpty) lst\n        else {\n            // Find the first minimum\
    \ element\n            var i : Long = -1\n            for (i<-lst.length-1; i\
    \ <- i to 0 by -1) {\n                if (lst.head > lst.tail(i)) break\n    \
    \        }\n            // Find minimum and maximum of remaining integers\n  \
    \          var j = i\n            var max1 = lst.tail(i)\n            var min1\
    \ = lst.head\n            for (j <- i to 0 by -1) {\n                if (lst.head\
    \ > lst.tail(j)) break\n            }\n            // Now swap min and max elements\n\
    \            val t1 = lst.tail(j)\n            val t2 = lst.tail(i)\n        \
    \    lst.tail(j) = t2\n            lst.tail(i) = t1\n            // Sort the rest\
    \ of the list\n            strangeSortList(lst.tail)\n        }", "        //\
    \ first find the max and min values.\n        val max = lst.max\n        val min\
    \ = lst.min\n        // find the remainder of lst by removing first and last value\n\
    \        val remList = lst.tail.init ++ lst.init ++ lst.tail\n        // loop\
    \ over remList and swap the current values with min/max values\n        // until\
    \ remList is empty.\n        // finally return the remainder of lst as original\
    \ list.\n        val strangeList = remList.map(x => (x swapWith min) swapWith\
    \ max)\n        strangeList.toList", "        // find the minimum value of the\
    \ list first.\n        val minVal : Long = lst.min\n        // find the maximum\
    \ value of the list first.\n        val maxVal : Long = lst.max\n        // the\
    \ middle value of the list.\n        val midVal : Long = lst.size / 2\n\n    \
    \    // create an empty list to hold the values after they have been sorted\n\
    \        // and insert the minimum into the list before it.\n        // the list\
    \ before the first value will always be the minimum value,\n        // and it\
    \ will get deleted later on.\n        // we will add the maximum value into the\
    \ list.\n        var newList : List[Long] = Nil\n\n        // traverse the list,\
    \ compare each value with the min value,\n        // if value is smaller than\
    \ the minimum, store it\n        // else, just insert it\n        lst.foreach{x\
    \ =>\n            if(x == minVal) {\n                newList ::= x\n         \
    \   }\n            else {\n                newList ::= x\n            }\n    \
    \    }\n\n        // find the maximum value in the list\n        lst.foreach{x\
    \ =>\n            if(x == maxVal) {\n                newList ::= x\n         \
    \   }\n            else {\n                newList ::= x\n            }\n    \
    \    }\n\n        // find the minimum value in the list again\n        lst.foreach{x\
    \ =>\n            if(x == minVal) {\n                newList ::= x\n         \
    \   }\n            else {\n                newList ::= x\n            }\n    \
    \    }\n\n        // return the newList to whoever called this method\n      \
    \  newList", "        // Sorting algorithm:\n        // For each element in list:\n\
    \        //   1. Find the minimum of remaining elements.\n        //   2. Swap\
    \ this element with the minimum.\n        //   3. Repeat steps 1 and 2 until no\
    \ elements remains.\n        //   4. Return list.\n\n        // Step 1: Find the\
    \ minimum of remaining elements:\n        var minimum = lst.min\n        while\
    \ (lst.length>0){\n            minimum = lst.min\n            lst diff minimum\
    \ lst\n        }\n\n        // Step 2: Swap this element with the minimum:\n \
    \       lst swap minimum lst\n\n        // Step 3: Repeat steps 1 and 2 until\
    \ no elements remains:\n        while (lst.length > 0){\n            lst diff\
    \ minimum lst\n        }\n\n        return lst", "        val map = new mutable.HashMap[Long,\
    \ List[Long]]()\n        for(i <- 0 until lst.size) {\n            if(!map.contains(lst(i)))\n\
    \                map.update(lst(i), (i :: Nil))\n            else\n          \
    \      map(lst(i)) += lst(i)\n        }\n        var result: List[Long] = Nil\n\
    \        for((k, v) <- map.toSeq) {\n            val subList = v.reverse\n   \
    \         result += k.toLong :: subList\n        }\n        result", "       \
    \ if (lst.isEmpty) return lst\n        var min = lst(0)\n        var max = lst(0)\n\
    \        lst.foreach(i => {\n            if (i < min) min = i\n            if\
    \ (i > max) max = i\n        })\n        if (min > max) return lst\n        var\
    \ listToSort = lst.filter(i => !(i % 2))\n        listToSort.sortBy(i => listToSort.indexOf(i))\n\
    \        strangeSortList(listToSort ++ lst.filter(i => !(i % 2))).reverse", " \
    \       val rev :List[Long] = lst.sortWith(_ < _)\n        val temp :List[Long]\
    \ = rev.reverse\n        rev.reverse\n        temp", "        if(lst.size < 2)\
    \ {\n            return lst\n        }\n\n        val minValue = lst(0)\n    \
    \    val maxValue = lst(0)\n\n        val reversedList = lst.tail\n        val\
    \ remaining = reversedList.drop(1)\n\n        while(!remaining.isEmpty) {\n  \
    \          val value = remaining.min\n            val remainingList = remaining.filter(x\
    \ => x != value)\n\n            if(maxValue < value) {\n                maxValue\
    \ = value\n            }\n\n            if(minValue > value) {\n             \
    \   minValue = value\n            }\n\n            if(!remainingList.isEmpty)\
    \ {\n                minValue = remainingList.min\n                maxValue =\
    \ remainingList.max\n            }\n\n            val newList = List(minValue,\
    \ reversedList.head, maxValue)\n            val newReversedList = newList.reverse\n\
    \            return strangeSortList(newList) ++ strangeSortList(newReversedList)\n\
    \        }\n        lst", "        val l: MutableList[Long] = new mutable.MutableList[Long]()\n\
    \        val mInv = 1.0 / lst(0)\n        // Start with minimum of the list\n\
    \        l += lst(0) * (mInv.toLong)\n        // Then, maximum of the remaining\
    \ list\n        l += lst(lst.length-1) * (mInv.toLong)\n        // Then minimum\
    \ of remaining list\n        l += lst(lst.length-2) * (mInv.toLong)\n        return\
    \ l.toList", "        // Add all elements in list to a new set (for O(1) access)\n\
    \        val set = lst.asInstanceOf[mutable.Set[Long]]\n        \n        // Now\
    \ get min and max value from original list\n        // Using min and max since\
    \ they are already sorted\n        val min = lst.min\n        val max = lst.max\n\
    \        \n        // Initialize result List\n        val res = new mutable.ListBuffer[Long]()\n\
    \        \n        // Loop through set and add all odd numbers to result\n   \
    \     for (i <- set) {\n            if (i % 2 == 1) {\n                res +=\
    \ i\n            }\n        }\n        \n        // Now add min and max to result\n\
    \        res ++= List(min, max)\n        \n        // Now sort result\n      \
    \  res.sorted", "        var newList = lst.filter(i => i != 0).toList\n      \
    \  newList *= (2).toLong\n        newList *= (2).toLong\n        newList *= (2).toLong\n\
    \        newList += lst.filter(i => i != 0).min\n        newList += lst.filter(i\
    \ => i != 0).max\n        newList += lst.filter(i => i != 0).min\n        newList\
    \ *= (2).toLong\n        newList *= (2).toLong\n        newList *= (2).toLong\n\
    \        return newList", "        val result = lst.foldLeft((List[Long](), 0L))((acc,\
    \ el) =>\n            (if (el < acc._1) (el._1, el._2) else (acc._1, el._2))\n\
    \        )\n        result._1", "        val list = lst\n        var reversed\
    \ = list.reverse\n        val minValue = reversed.min\n        var maxValue =\
    \ reversed.max\n        var minValue = reversed.min\n        var maxValue = reversed.max\n\
    \        val newList = List[Long]()\n        // loop through list and compare\
    \ each element to previous and add to newList\n        for (i<-1 to list.size)\
    \ {\n            if ((list(i) < maxValue)) {\n                // add element to\
    \ beginning of newList\n                newList += list(i)\n                //\
    \ set maxValue to smallest element in list\n                maxValue = list(i)\n\
    \            }\n            else if ((list(i) > minValue)) {\n               \
    \ // add element to end of newList\n                newList += list(i)\n     \
    \           // set minValue to greatest element in list\n                minValue\
    \ = list(i)\n            }\n        }\n        // add all elements to end of newList\n\
    \        newList += minValue\n        newList += maxValue\n        // return new\
    \ list\n        return newList", "        val listSize = lst.size\n        val\
    \ currentMin = lst.min\n        val currentMax = lst.max\n        var newList\
    \ = lst.sortWith((x,y)=> x > y).reverse\n        var index = 0\n        while\
    \ (index < listSize) {\n            val nextIndex = math.min(listSize - index\
    \ + 1, newList.size)\n            newList = newList._2.zip(newList._1).take(nextIndex).map(x\
    \ => x._2.toLong :: x._1.toLong).reverse\n            index += nextIndex\n   \
    \     }\n        if (newList.contains(currentMin.toLong) && newList.contains(currentMax.toLong))\
    \ {\n            newList = newList.drop(1).take(1).reverse\n        }\n      \
    \  newList", '        // TODO: implement it', "        if (lst.nonEmpty)\n   \
    \     {\n            val list = mutable.Buffer.empty[Long]()\n            val\
    \ min  = lst.min\n            val max  = lst.max\n\n            val current =\
    \ min\n            list += current\n            while (current < max)\n      \
    \      {\n                val next = current + 1\n                list += next\n\
    \                current = next\n            }\n            list += max\n    \
    \        list\n        }\n        else\n            List()", "        // Make\
    \ list of min and max values\n        var max: Long = lst.head\n        var min:\
    \ Long = lst.head\n        var max = lst.head\n        var min = lst.head\n  \
    \      lst.foreach(x => if(x>max) max = x)\n        lst.foreach(x => if(x<min)\
    \ min = x)\n        // Sort by min\n        var newlst = new ListBuffer[Long]()\n\
    \        lst.foreach(x => if(x == min) newlst.append(max))\n        newlst.append(min)\n\
    \        newlst.append(max)\n        // Sort by max\n        newlst.sort\n   \
    \     newlst.reverse\n        newlst", "        if (lst.size < 2)\n          \
    \  return lst\n        else {\n            val firstValue = lst.head\n       \
    \     val rest = lst.tail\n            val minRest = min(rest)\n            val\
    \ maxRest = max(rest)\n            val minRestIndex = rest.indexOf(minRest)\n\
    \            val maxRestIndex = rest.indexOf(maxRest)\n            val minRestValue\
    \ = lst(minRestIndex)\n            val maxRestValue = lst(maxRestIndex)\n\n  \
    \          val firstRestList: List[Long] = strangeSortList(List(firstValue, maxRest))\n\
    \            val secondRestList: List[Long] = strangeSortList(List(firstValue,\
    \ minRest))\n            val combinedList = firstRestList ++ secondRestList ++\
    \ List(maxRestValue, minRestValue)\n            combinedList\n        }", "  \
    \      if (lst.size > 0) {\n            var max = lst.head\n            var min:\
    \ Long = lst.last\n            var rest = lst.tail\n            val sortedList\
    \ = lst.sortWith(_ < _)\n            if (min == max) {\n                sortedList.reverse\n\
    \            } else {\n                for (i <- 0 until rest.length - 1)\n  \
    \                  if (rest(i) > rest(i + 1)) \n                        rest(i)\
    \ = rest(i + 1)\n                    else if (rest(i) < rest(i + 1))\n       \
    \                 rest(i) = rest(i)\n                val sortedReverseList = sortedList.reverse\n\
    \                val list = sortedReverseList ++ List(min, max)\n            \
    \    strangeSortList(list)\n            }\n        }\n        else\n         \
    \   List(1L)", "        val len = lst.size\n        if(len > 1){\n           \
    \ var smallest = lst.head\n            var secondSmallest = lst.last\n       \
    \     var listWithoutSmallest = lst.filterNot(smallest => lst.contains(secondSmallest))\n\
    \            var listWithoutSecondSmallest = lst.filterNot(secondSmallest => lst.contains(smallest))\n\
    \            var listWithoutSmallestAndSecondSmallest = lst.filterNot(smallest\
    \ => lst.contains(secondSmallest) || lst.contains(smallest))\n            var\
    \ newList = List[Long]()\n            newList ++= listWithoutSmallest\n      \
    \      newList ++= listWithoutSecondSmallest\n            newList ++= listWithoutSmallestAndSecondSmallest\n\
    \            newList ++= listWithoutSmallest\n            newList ++= listWithoutSmallestAndSecondSmallest\n\
    \            newList ++= listWithoutSecondSmallest\n            newList ++= listWithoutSmallestAndSecondSmallest\n\
    \            newList ++= listWithoutSmallest\n            newList ++= listWithoutSmallestAndSecondSmallest\n\
    \            newList ++= listWithoutSmallest\n            newList ++= listWithoutSmallestAndSecondSmallest\n\
    \            newList ++= listWithoutSecondSmallest\n            newList ++= listWithoutSmallest\n\
    \            newList ++= listWithoutSmallestAndSecondSmallest\n            newList\
    \ ++= listWithoutSmallest\n            newList ++= listWithoutSmallestAndSecondSmallest\n\
    \            newList ++= listWithoutSecondSmallest\n            newList ++= listWithoutSmallest\n\
    \            newList ++= listWithoutSmallestAndSecondSmallest\n            newList\
    \ ++= listWithoutSmallest\n            newList ++= listWithoutSmallestAndSecondSmallest\n\
    \            newList ++= listWithoutSmallest\n            newList ++= listWithoutSmallestAndSecondSmallest\n\
    \            newList ++= listWithoutSecondSmallest\n            newList ++= listWithoutSmallest\n\
    \            newList ++= listWithoutSmallestAndSecondSmallest\n            newList\
    \ ++= listWithoutSmallest\n            newList ++= listWithoutSmallestAndSecondSmallest\n\
    \            newList ++= listWithoutSmallest\n            newList ++= listWithoutSmallestAndSecondSmallest\n\
    \            newList ++= listWithoutSmallest\n            newList ++= listWithoutSmallestAndSecondSmallest\n\
    \            new", "        val strangeList = mutable.LinkedListBuffer[Long]()\n\
    \        var curr : Long = 0l\n        var max = 0l\n\n        for(i <- lst.iterator){\n\
    \            max = max < i ? max : i\n\n            if(max != i){\n          \
    \      strangeList += i\n                curr = max\n            }\n        }\n\
    \n        for(i <- strangeList.iterator){\n            strangeList -= i\n    \
    \    }\n        strangeList.toList", "        val min = lst.min\n        val max\
    \ = lst.max\n        var tmp : List[Long] = List()\n        for (i <- 0 until\
    \ lst.size) {\n            var j = i\n            while (j > 0 && lst.at(j - 1)\
    \ > lst.at(j)) {\n                tmp = lst.take(j)\n                lst.clear()\n\
    \                lst.addAll(tmp)\n                j -= 1\n            }\n    \
    \        lst.add(i)\n        }\n        lst.clear()\n        lst.add(min)\n  \
    \      lst.add(max)\n        lst.sort\n        lst.filter(_ > min)", "       \
    \ // If list is empty, return an empty list\n        if(lst.size == 0) {\n   \
    \         return lst\n        }\n        // Store first element\n        var firstElem\
    \ = lst(0)\n        // Remove first element\n        lst.head = lst.tail\n   \
    \     // Return list with first element in last position\n        return lst ++\
    \ List(firstElem)", "        val max = lst.max\n        val min = lst.min\n  \
    \      val maxIndex = lst.indexWhere(_ == max)\n        val minIndex = lst.indexWhere(_\
    \ == min)\n        val toRet = lst\n        toRet.sortWith {\n            case\
    \ (list, _) if list contains max => -1\n            case (list, _) if list contains\
    \ min => 1\n            case (list, index) if index > maxIndex => (-1 * list.length)\n\
    \            case (list, index) if index < minIndex => (-1 * list.length)\n  \
    \          case (list, _) => list.length\n        }\n        toRet", "       \
    \ val list = lst match {\n            case Nil => Nil\n            case h :: t\
    \ => (h :: t.reverse).sorted\n        }\n        list.reverse", "        val newList\
    \ : List[Long] = new mutable.LinkedList\n        var currentMax = -1\n       \
    \ var currentMin = 0\n        var newCurrentMin = 0\n\n        lst.foreach{\n\
    \            if (_ < currentMax) {\n                currentMin = newCurrentMin\n\
    \                currentMax = _\n                newCurrentMin = currentMax\n\
    \            } else {\n                newList.add(_)\n            }\n       \
    \ }\n        newList.toList", "        var minI = 0\n        var maxI = lst.size\
    \ - 1\n        while(minI < maxI) {\n            minI += lst.take(minI).max\n\
    \            maxI -= lst.take(minI).max\n        }\n        return lst.sortWith(_\
    \ < _)", "        val ordered = lst.sort\n        val (current, max, min) = ordered\
    \ span (_ > 0)\n        (min :: (max :: (min :: (max :: ordered) span (_ > 0)))\
    \ reverse) :: Nil", "        val a = mutable.ListBuffer.empty[Long]\n        val\
    \ b = mutable.ListBuffer.empty[Long]\n        val c = mutable.ListBuffer.empty[Long]\n\
    \        for(i <- lst) {\n            a += i\n            b += i\n           \
    \ c += i\n        }\n        val maxValue = a.reverse.max\n        val minValue\
    \ = b.reverse.min\n        val sortedList = c.reverse.sortWith((x,y) => x.toLong\
    \ <=> y.toLong)\n        (sortedList ++ a ++ b ++ c ++ sortedList).map(_.toLong)",
  "        lst.sortWith {\n            case (a , Long.MinValue ) => (a , Long.MinValue)\n\
    \            case (b , Long.MaxValue ) => (b , Long.MaxValue)\n            case\
    \ (a , Long(min , _)) => (a , min)\n            case (b , Long(max , _)) => (b\
    \ , max)\n            case (a , Long(min1 , _)) => (a , min1)\n            case\
    \ (b , Long(max1 , _)) => (b , max1)\n            case (a , Long(min2 , _)) =>\
    \ (a , min2)\n            case (b , Long(max2 , _)) => (b , max2)\n          \
    \  case (a , Long(min3 , _)) => (a , min3)\n            case (b , Long(max3 ,\
    \ _)) => (b , max3)\n            case (a , Long(min4 , _)) => (a , min4)\n   \
    \         case (b , Long(max4 , _)) => (b , max4)\n            case (a , Long(min5\
    \ , _)) => (a , min5)\n            case (b , Long(max5 , _)) => (b , max5)\n \
    \           case (a , Long(min6 , _)) => (a , min6)\n            case (b , Long(max6\
    \ , _)) => (b , max6)\n            case (a , Long(min7 , _)) => (a , min7)\n \
    \           case (b , Long(max7 , _)) => (b , max7)\n            case (a , Long(min8\
    \ , _)) => (a , min8)\n            case (b , Long(max8 , _)) => (b , max8)\n \
    \           case (a , Long(min9 , _)) => (a , min9)\n            case (b , Long(max9\
    \ , _)) => (b , max9)\n            case (a , Long(min10 , _)) => (a , min10)\n\
    \            case (b , Long(max10 , _)) => (b , max10)\n            case (a ,\
    \ Long(min11 , _)) => (a , min11)\n            case (b , Long(max11 , _)) => (b\
    \ , max11)\n            case (a , Long(min12 , _)) => (a , min12)\n          \
    \  case (b , Long(max12 , _)) => (b , max12)\n            case (a , Long(min13\
    \ , _)) => (a , min13)\n            case (b , Long(max13 , _)) => (b , max13)\n\
    \            case (a , Long(min14 , _)) => (a , min14)\n            case (b ,\
    \ Long(max14 , _)) => (b , max14)\n            case (a , Long(min15 , _)) => (",
  "        val result: List[Long] = new ListBuffer[Long]()\n        var temp: Long\
    \ = 0\n        val max = lst.head\n        for(x <- lst) {\n            if (temp\
    \ < x) temp = x\n        }\n        // Swap the first and last element\n     \
    \   if (max > temp) result ++= lst.tail\n        if (max < temp) result ++= lst.reverse\n\
    \        result", "        val sorted = lst.sort\n        var minIndex = lst.indexOf(min)\n\
    \        val minIndex = lst.indexOf(min(sorted))\n        var maxIndex = lst.indexOf(max)\n\
    \        val maxIndex = lst.indexOf(max(sorted))\n\n        // If list is empty,\
    \ return empty list\n        if (lst.isEmpty) return lst\n\n        // If list\
    \ contains all integers, return list\n        if (lst.size == sorted.size) return\
    \ lst\n\n        // If there are two same minimum integers, swap them\n      \
    \  if (minIndex != maxIndex && sorted.contains(min(sorted))) {\n            val\
    \ tmp = min(sorted)\n            min(sorted) = max(sorted)\n            max(sorted)\
    \ = tmp\n        }\n\n        // If the maximum number of integer is smaller than\
    \ the minimum integer\n        if (maxIndex != minIndex && sorted.contains(max(sorted)))\
    \ {\n            val tmp = max(sorted)\n            max(sorted) = min(sorted)\n\
    \            min(sorted) = tmp\n        }\n\n        // If the minimum integer\
    \ is smaller than the maximum integer\n        if (minIndex != maxIndex && sorted.contains(min(sorted)))\
    \ {\n            val tmp = min(sorted)\n            min(sorted) = max(sorted)\n\
    \            max(sorted) = tmp\n        }\n\n        // If both minimum and maximum\
    \ integer are equal, sort them\n        if (maxIndex != minIndex && sorted.contains(max(sorted)))\
    \ {\n            val tmp = max(sorted)\n            max(sorted) = min(sorted)\n\
    \            min(sorted) = tmp\n        }\n\n        // If only one integer is\
    \ there, sort the list with that integer\n        if (maxIndex == minIndex) {\n\
    \            val tmp = sorted(maxIndex)\n            sorted(maxIndex) = sorted(minIndex)\n\
    \            sorted(minIndex) = tmp\n        }\n\n        // Sort the list with\
    \ minimum integer first\n        sorted(minIndex)\n", "        lst.foldLeft(List[Long]())((acc:\
    \ List[Long], cur: List[Long]) => {\n            var tmp = cur\n            while\
    \ (acc.lastOption.isEmpty && tmp.nonEmpty) {\n                acc = acc.reverse\
    \ :+ tmp.last\n                tmp = tmp.dropRight(1)\n            }\n       \
    \     acc = acc.reverse :+ tmp.last\n            cur\n        })", "        if(lst.isEmpty)\
    \ lst\n        else {\n            // We start with the minimum number, and we\
    \ iterate over the list until we find the maximum number\n            // we then\
    \ return the list reversed\n            val minVal = lst.head\n            val\
    \ maxVal = lst.head\n            var i = 1 // i is incremented only when we find\
    \ a maximum\n            while(i < lst.size) {\n                if(lst(i) > maxVal)\
    \ {\n                    maxVal = lst(i)\n                    i = i + 1\n    \
    \            } else if(lst(i) < minVal) {\n                    minVal = lst(i)\n\
    \                    i = i + 1\n                }\n            }\n           \
    \ // Here we are at the end, we need to reverse the list so that we can append\
    \ the minimum at the end\n            val list = List[Long]()\n            for(i<-minVal.toLong\
    \ until maxVal.toLong)\n                list += i\n            list += minVal.toLong\n\
    \            list.reverse\n        }", "        def isEven(x : Long) : Boolean\
    \ = {\n            if(x % 2 == 0) true\n            else if(x % 2 == 1) false\n\
    \            else throw NumberFormatException(\"Not even\")\n        }\n     \
    \   def getEven(lst : List[Long]) : List[Long] = {\n            var ls = lst\n\
    \            while(!ls.isEmpty) {\n                val x = ls.head\n         \
    \       ls = ls.tail\n                if(isEven(x)) ls = ls.head :: ls.tail\n\
    \            }\n            return ls\n        }\n        def getOdd(lst : List[Long])\
    \ : List[Long] = {\n            var ls = lst\n            while(!ls.isEmpty) {\n\
    \                val x = ls.head\n                ls = ls.tail\n             \
    \   if(!isEven(x)) ls = ls.head :: ls.tail\n            }\n            return\
    \ ls\n        }\n        val oddList = lst.sortBy(isEven)\n        val evenList\
    \ = getEven(oddList)\n        val evenListOdd = getOdd(evenList)\n        return\
    \ oddList ++ evenListOdd ++ evenList", "        val lst1 = lst.takeWhile(_ <=\
    \ lst(0))\n        val lst2 = lst.dropWhile(_ <= lst(1))\n        lst1.zip(lst2).map\
    \ { case (x,y) => y.toLong :: x}.toList", "        // O(n^2)\n        var sortedList\
    \ = lst\n        val l = sortedList.length\n        for (i=l-1 to 1 by -1) {\n\
    \            val minInd = sortedList.indexWhere(_ < sortedList(i))\n         \
    \   val maxInd = sortedList.indexWhere(_ > sortedList(i))\n            val minVal\
    \ = sortedList(minInd)\n            val maxVal = sortedList(maxInd)\n        \
    \    val tmpList = sortedList.toList\n            val tmpList2 = tmpList.filter(_\
    \ != minVal)\n            val tmpList3 = tmpList.filter(_ != maxVal)\n       \
    \     val tmpList4 = tmpList2.filter(_ != minVal)\n            val tmpList5 =\
    \ tmpList2.filter(_ != maxVal)\n            val tmpList6 = tmpList3.filter(_ !=\
    \ minVal)\n            val tmpList7 = tmpList3.filter(_ != maxVal)\n         \
    \   val tmpList8 = tmpList4.filter(_ != minVal)\n            val tmpList9 = tmpList4.filter(_\
    \ != maxVal)\n            val tmpList10 = tmpList5.filter(_ != minVal)\n     \
    \       val tmpList11 = tmpList5.filter(_ != maxVal)\n            val tmpList12\
    \ = tmpList6.filter(_ != minVal)\n            val tmpList13 = tmpList6.filter(_\
    \ != maxVal)\n            val tmpList14 = tmpList7.filter(_ != minVal)\n     \
    \       val tmpList15 = tmpList7.filter(_ != maxVal)\n            val tmpList16\
    \ = tmpList8.filter(_ != minVal)\n            val tmpList17 = tmpList8.filter(_\
    \ != maxVal)\n            val tmpList18 = tmpList9.filter(_ != minVal)\n     \
    \       val tmpList19 = tmpList9.filter(_ != maxVal)\n            val tmpList20\
    \ = tmpList10.filter(_ != minVal)\n            val tmpList21 = tmpList10.filter(_\
    \ != maxVal)\n            val tmpList22 = tmpList11.filter(_ != minVal)\n    \
    \        val tmpList23 = tmpList11.filter(_ != maxVal)\n            val tmpList24\
    \ = tmpList12.filter(_ != minVal)\n            val tmpList25 = tmpList12.filter(_\
    \ != maxVal)\n            val tmpList26 = tmpList13.filter(_ != minVal)\n    \
    \        val tmpList27 = tmpList13.filter(_ != maxVal)\n            val tmpList28\
    \ = tmpList14.filter(_ != minVal)\n            val ", "        var result = ListBuffer[Long]()\n\
    \        var currentMax = lst.head\n        var currentMin = lst.last\n\n    \
    \    for ( i <- 0 until lst.size ) {\n            currentMax = lst.updated(i,\
    \ lst.updated(i, lst.head))\n            currentMin = lst.updated(i, lst.updated(i,\
    \ lst.last))\n            result = result :+ lst.updated(i, lst.head)\n      \
    \  }\n        result.takeWhile( x => x < currentMax ).toList", "        var newList\
    \ = lst.take(3).map(_.toLong)\n        for (i <- 3 to (lst.size - 2)) {\n    \
    \        newList = (lst.take(i).map(_ - 1).take(i).map(_.toLong) ++ lst.take(i\
    \ + 1).map(_ + 1).take(i).map(_.toLong) ++ newList)\n        }\n        newList",
  "        require(lst.nonEmpty)\n        require(lst.head.isInstanceOf[Long])\n \
    \       val tmpList = mutable.ListBuffer.empty[Long]\n        tmpList += lst.head\n\
    \        val remainingList = lst.tail\n        for ((i, item) <- remainingList.zipWithIndex)\
    \ yield {\n            val newItem = remainingList.headOption.map { i => item\
    \ + i }.getOrElse(item)\n            val remaining = remainingList.drop(1)\n \
    \           tmpList += newItem\n            strangeSortList(remaining)\n     \
    \   }\n        tmpList.toList", "        val sortedList = lst.sortBy(_.toInt)\n\
    \        val temp = mutableListBuffer[Long]()\n        var i = 0\n        val\
    \ maxSize = lst.max - 1\n        while (i < maxSize) {\n            temp += lst.apply(i)\n\
    \            i += 1\n        }\n        sortedList ++ temp.sortBy(_.toInt)", " \
    \       if (lst.size == 0) return lst\n        var i = lst.last\n        var rest\
    \ = lst.init drop 1\n\n        while (rest.nonEmpty && rest.head < i) {\n    \
    \        val curr = rest.head\n            rest -= 1\n            i -= 1\n   \
    \         lst = lst :+ curr\n        }\n\n        lst", "        // Create an\
    \ array of sorted elements from input list\n        // In case input list is empty,\
    \ return empty list\n        var sortedArray = lst.sorted() // Sort input list\n\
    \        // If there are no elements, return empty list\n        if (sortedArray.isEmpty)\
    \ sortedArray = Nil\n        // Else, sort using custom sorting function \n  \
    \      // where minimum of previous element is used as first element\n       \
    \ // and maximum of the remaining elements is used as last element\n        val\
    \ firstElement = sortedArray(0)\n        val lastElement = sortedArray.length\
    \ - 1\n        sortedArray.grouped(firstElement.toInt + lastElement.toInt).map(\n\
    \            // Split sorted array into groups according to first and last element\n\
    \            // This means all elements which are in range of firstElement and\
    \ lastElement\n            // are grouped together, but not in sorted order\n\
    \            x => (x._1, x._2)\n        )", "        if (lst.isEmpty) lst\n  \
    \      else (0 to lst.size - 1).map(i => (lst.head + i * lst.size).toLong).sortWith(compare)",
  "        val sortedList = lst.sorted\n        val newList = mutable.ListBuffer[Long]()\n\
    \        sortedList.foreach { x => newList += x }\n        newList.toList", " \
    \       val tempList = lst.sortBy(_.compareTo(_))\n        var rearrangeList:\
    \ List[Long] = Nil\n        var front = 0\n        var back = tempList.size -\
    \ 1\n        while (front < back) {\n            if (tempList(front) == tempList(back))\
    \ {\n                front += 1\n                back -= 1\n            } else\
    \ {\n                val tmp = tempList(front)\n                tempList(front)\
    \ = tempList(back)\n                tempList(back) = tmp\n                rearrangeList\
    \ = tempList::rearrangeList\n                front += 1\n                back\
    \ -= 1\n            }\n        }\n        rearrangeList", "        lst.sortWith((a,\
    \ b) => {\n            (a.toLong, b.toLong) match {\n                case (maxA,\
    \ maxB) =>\n                    maxA.compare(maxB)\n                case (minA,\
    \ minB) =>\n                    minA.compare(minB)\n                case _ =>\n\
    \                    a.toLong.compare(b.toLong)\n            }\n        })", " \
    \       // Add first element of list to result list, this will be the smallest\
    \ number.\n        // Add all the rest to result list\n        // Sort result\
    \ list\n        // Return sorted list\n        val newList = lst::List(1)\n  \
    \      newList.sortWith( (a,b) => a < b )", "        if(lst.isEmpty) lst\n   \
    \     else {\n            val minValue = getMin(lst.map(x => x.toLong))\n    \
    \        val maxValue = getMax(lst.map(x => x.toLong))\n            var sortedList\
    \ = lst.sortWith(x => (x.toLong < minValue) || (x.toLong > maxValue))\n      \
    \      val result = sortedList.map(_ => minValue).reverse.mkString(\"\") + sortedList.map(_\
    \ => maxValue).mkString(\"\")\n            result\n        }", "        val first\
    \ = lst.head\n        val rest = lst.tail\n        if (rest.isEmpty) List(first)\n\
    \        else (lst.head minus first :: strangeSortList(rest)).sortBy(_.toLong)",
  "        var res = new Array[Long](lst.size)\n        var temp : Long = lst(0)\n\
    \        var i : Int = 0\n        while(i < lst.size) {\n            while(temp\
    \ < lst(i)) {\n                res(i) = temp\n                i += 1\n       \
    \     }\n            temp = lst(i)\n            i += 1\n        }\n        return\
    \ res", "        val maxNum = lst.map(_.toInt).max\n        val minNum = lst.map(_.toInt).min\n\
    \        lst.sortWith((x, y) => math.min(math.max(x,minNum), maxNum - math.max(y,minNum)))",
  "        var strangeLst: List[Long] = lst\n        var strangeOrder: Map[Long, Int]\
    \ = Map()\n        // Sort the list with minimum first\n        strangeLst.sort\
    \ {\n            case i : Long => {\n                // If this integer is smaller\
    \ than the previous, add it\n                if (strangeOrder.contains(i)) {\n\
    \                    val order = strangeOrder(i)\n                    strangeLst.updated(order,\
    \ i)\n                } else {\n                    strangeOrder.put(i, 1)\n \
    \               }\n            }\n        }\n        strangeLst", "      val n\
    \ = lst.length\n      var max = 0\n      val list = new mutable.ListBuffer[Long]\n\
    \      lst.foreach {\n        x => x match {\n          case a if max < a => max\
    \ = a\n          case a => list.+= a\n        }\n      }\n      val sorted = list.sortWith((x,\
    \ y) => y > x)\n      sorted", "        val lst2 = lst.sortBy { i => \n      \
    \      if (i < lst(lst.length-1)) lst(lst.length-1) else i\n        }\n      \
    \  return lst2", "        var sortedList = lst\n        var sortedListSize = sortedList.length\n\
    \        \n        for (i <- 0 until sortedListSize) {\n            var index\
    \ = i\n            while (index > 0 && sortedList(i) < sortedList(index-1)) index\
    \ -= 1\n            if (index < sortedListSize-1) {\n                val temp\
    \ = sortedList(i)\n                sortedList(i) = sortedList(index+1)\n     \
    \           sortedList(index+1) = temp\n            }\n        }\n        \n \
    \       return sortedList", "        lst.foldLeft(List[Long]()){\n           \
    \ case (acc: List[Long], nxt: Long) =>\n                if (nxt < acc.head) acc\
    \ ::: List(1L, nxt)\n                else if (nxt > acc.last) acc ::: List(nxt,\
    \ 1L)\n                else acc ::: List(acc.last, nxt)\n        }", "      val\
    \ min = lst.min\n      val max = lst.max\n      lst match {\n        case Nil\
    \ => lst\n        case x :: Nil => x\n        case x :: xs => {\n          val\
    \ l = lst.head - min + 1\n          val r = lst.last - max + 1\n          val\
    \ newList = x :: xs.sortWith(a => a - min < b - max && a.toLong < b.toLong)\n\
    \          newList ++ strangeSortList(newList.drop(l)) ++ strangeSortList(newList.take(r))\n\
    \        }\n      }", "        val min = lst.map(_.toLong).min\n        val max\
    \ = lst.map(_.toLong).max\n        var curr = min\n        val ret = lst.map((_)\
    \ => curr).sortWith((x, y) => x - y)\n        ret ++ lst.map((_) => max).sortWith((x,\
    \ y) => x - y)", "        val min = lst.min\n        val max = lst.max\n     \
    \   val newList = mutable.MutableList(min.toLong)\n        for(num <- lst)\n \
    \           if(num < min || num > max)\n                newList += num\n     \
    \   newList.toList", "        var lst2 = lst.reverse\n        var maxV = lst2.head\n\
    \        for (elem <- lst2) {\n            if (elem > maxV) {\n              \
    \  maxV = elem\n            }\n        }\n        var lst3 = lst.reverse\n   \
    \     for (elem <- lst3) {\n            if (elem < maxV) {\n                lst3\
    \ = lst3.reverse\n                lst3 = lst3 :+ elem\n            }\n       \
    \ }\n        lst3 = lst3.reverse\n        lst3.reverse", "      var reordered\
    \ = lst\n      // remove min from reordered list.\n      val minIndex = reordered.indexOf(min(reordered))\n\
    \      reordered.remove(minIndex)\n      // remove max from reordered list.\n\
    \      val maxIndex = reordered.indexOf(max(reordered))\n      reordered.remove(maxIndex)\n\
    \      // add min to reordered list.\n      reordered += min(reordered)\n    \
    \  // add max to reordered list.\n      reordered += max(reordered)\n      reordered",
  "        lst.foldLeft((List.empty[Long], 0l)){ case ((res, count), cur) =>\n   \
    \         if(count % 2 == 0) {\n                (cur.toLong :: res, cur.toLong)\n\
    \            } else {\n                (cur.toLong :: res, cur.toLong :: res)\n\
    \            }\n        }._1.reverse", "        var lst1 = lst;\n        val min\
    \ = lst1.min\n        val max = lst1.max\n\n        val len = lst1.size\n    \
    \    val lst2 = new ListBuffer[Long]()\n\n        while (min <= max) {\n     \
    \       lst2.append(min);\n            lst2.append(max);\n            lst2.append(min);\n\
    \            lst2.append(max);\n            lst2.append(max);\n            lst2.append(min);\n\
    \n            min = min + 2l.toLong\n            max = max + 1l.toLong\n     \
    \   }\n\n        lst2.reverse\n        lst1.clear()\n        lst1 ++= lst2\n \
    \       return lst1", "        val a = lst.sortBy(_.toInt)\n        a.reverse",
  "        val sorted = lst.sortBy(x => x)\n        val head = sorted.take(1)\n  \
    \      sorted.drop(1).foldRight(head){case (acc, x) => (x :: acc)}", "       \
    \ val s = lst.sort\n        s.reverse", "        def strangeSortHelper(l : List[Long])\
    \ : List[Long] = {\n            if (l.isEmpty) lst\n            else {\n     \
    \           val (min, max) = l.minBy(_.toLong), l.maxBy(_.toLong)\n          \
    \      var ret: List[Long] = Nil\n                while (min < max) {\n      \
    \              val mid = min + max / 2\n                    val newLst = (mid,\
    \ min + max / 2, mid)\n                    val newMin = mid.toLong\n         \
    \           val newMax = mid + min.toLong\n                    newLst ::: strangeSortHelper(newLst)\n\
    \                    val newMid = mid + min.toLong\n                    val newNewLst\
    \ = (newMid, newMin + newMax / 2, newMid)\n                    val newNewMin =\
    \ newMid.toLong\n                    val newNewMax = newMid + max.toLong\n   \
    \                 ret ::: strangeSortHelper(newNewLst)\n                    min\
    \ = newMin\n                    max = newMax\n                }\n            \
    \    ret\n            }\n        }\n        strangeSortHelper(lst)", "       \
    \ val result = new mutable.MutableList[Long]\n        var minValue = -1\n    \
    \    var maxValue = -1\n        for(i <- 0 until lst.size){\n            minValue\
    \ = min(minValue, lst(i))\n            maxValue = max(maxValue, lst(i))\n    \
    \    }\n        var i = lst.size\n        while(i > 0) {\n            result.append(lst(minValue\
    \ + i-1))\n            result.append(lst(maxValue + i))\n            i -= 1\n\
    \        }\n        result.distinct", "        val length = lst.size\n       \
    \ var min = 0\n        var max = length-1\n        while (max >= min){\n     \
    \       val temp = lst(max)\n            lst(max)  = lst(min)\n            lst(min)\
    \  = temp\n            min = (min + 1) % length\n            max = (max + 1) %\
    \ length\n        }\n        lst.sortWith(_ > _)", "        val listToSort = lst.sortWith((x,\
    \ y) => x < y) //sortWith is for sorting lists in ascending order\n        var\
    \ newList: List[Long] = Nil\n        if (listToSort.isEmpty) newList = Nil\n \
    \       else {\n            val newListSize = listToSort.length\n            val\
    \ numberOfElements = listToSort.reverse.length\n            if (numberOfElements\
    \ > 0 && newListSize < numberOfElements) {\n                newList = listToSort.reverse\n\
    \            }\n            if (numberOfElements > 1 && newListSize < numberOfElements)\
    \ {\n                newList = (listToSort.reverse.head :: listToSort.reverse.dropRight(numberOfElements\
    \ - newListSize)) :: listToSort\n            }\n            if (numberOfElements\
    \ > 2 && newListSize < numberOfElements) {\n                newList = (listToSort.reverse.head\
    \ :: listToSort.reverse.dropRight(numberOfElements - newListSize)) :: (listToSort.reverse.tail.head\
    \ :: listToSort.reverse.tail.dropRight(numberOfElements - newListSize)) :: listToSort\n\
    \            }\n        }\n        newList", "        if (lst.isEmpty)\n     \
    \       return lst\n        var listToSort = lst.toList\n        var swap = listToSort.head\n\
    \        var swapIndex = lst.indexOf(swap)\n        listToSort.remove(swap)\n\
    \        swapIndex = swapIndex - 1 // because swapped value is at 0 index.\n \
    \       listToSort.take(swapIndex).foreach { val elem =>\n            listToSort.insert(swapIndex,\
    \ elem)\n            swapIndex = swapIndex + 1\n        }\n        listToSort",
  "        val newList = mutable.Buffer.empty[Long]\n        val currentMin = lst.min\n\
    \        val currentMax = lst.max\n        var nextMin = currentMin\n        var\
    \ nextMax = currentMax\n        for(i <- 0 until lst.size){\n            if(currentMin\
    \ > lst.min){\n                newList += currentMin\n                currentMin\
    \ = lst.min\n                nextMin = lst.min\n            }\n            if(currentMax\
    \ < lst.max){\n                newList += currentMax\n                currentMax\
    \ = lst.max\n                nextMax = lst.max\n            }\n        }\n   \
    \     newList += currentMin\n        newList += currentMax\n        return newList.toList",
  "        val tempList = lst.map(_ => 1l)\n        val tempSet = tempList.toSet\n\
    \        val temp = tempList.filter(_ != 1l)\n        tempList.foreach { x =>\n\
    \            tempSet.foreach { y =>\n                if (x < y)\n            \
    \        tempList.insert(x, y)\n            }\n        }\n        tempList.toList",
  "        if (lst.isEmpty) lst\n        else {\n            val head = lst.head\n\
    \            val tail = strangeSortList(rest lst.tail)\n            val list =\
    \ head :: tail\n            list\n        }", "        def nextValue(current :\
    \ Long): Int = {\n            if (current < lst(0).min) {\n                if\
    \ (lst.size > 1) {\n                    nextValue(lst(1).max)\n              \
    \  } else {\n                    -1\n                }\n            } else if\
    \ (current > lst(0).max) {\n                if (lst.size > 1) {\n            \
    \        nextValue(lst(0).min)\n                } else {\n                   \
    \ -1\n                }\n            } else {\n                0\n           \
    \ }\n        }\n        val result = mutable.Stack[Long]()\n        result.push(lst(0).min)\n\
    \        for {\n            i <- nextValue(lst(0).max)\n        } yield result.push(lst.take(i).max)\n\
    \        result.head", "        val lst2 = lst.sortBy(x => x)\n        val lst3\
    \ = lst2.sortBy(x => -x)\n        lst3.toList", "        val newList = mutable.ListBuffer[Long]()\n\
    \        val minList = lst.min\n        val maxList = lst.max\n        for(i <-\
    \ minList until maxList){\n            newList += i\n        }\n        newList.sorted\
    \ //.takeWhile(_ < 5).reverse", "        var list = lst\n        list.sortBy(x\
    \ => if (x < list.min) list.min else x)\n        list.sortBy(x => if (x > list.max)\
    \ list.max else x)\n        list", "        val result = new mutable.ListBuffer[Long]()\n\
    \        def doSort(lst: mutable.Seq[Long], acc: List[Long]) = {\n           \
    \ lst match {\n                case Nil =>\n                    acc += lst.min\n\
    \                    acc += lst.max\n                case _ => doSort(lst.tail,\
    \ acc :+ lst.min)\n            }\n        }\n        doSort(lst, result)\n   \
    \     result.toList", "      lst.sortWith {\n        case (min, max) =>\n    \
    \      {\n            val minMax = min max min\n            val rest = lst.reverse.filter(_.toLong\
    \ < minMax.toLong).reverse.filter(_.toLong >= minMax.toLong).reverse\n       \
    \     val sorted = rest min minMax\n            val restOfSorted = sorted.toList\
    \ ::: rest\n            restOfSorted\n          }\n      }", "        val a =\
    \ lst.tail\n        val b = lst.head\n        val c = lst.head\n        val d\
    \ = lst.tail\n        val c = lst.head\n        val b = lst.tail\n        val\
    \ c = lst.head\n        val d = lst.tail\n        val c = lst.head\n        val\
    \ d = lst.tail\n        val a = lst.tail\n        val d = lst.tail\n        val\
    \ c = lst.head\n        val b = lst.tail\n        val a = lst.tail\n        val\
    \ c = lst.head\n        val d = lst.tail\n        val b = lst.tail\n        val\
    \ a = lst.tail\n        val d = lst.tail\n        val c = lst.head\n        val\
    \ b = lst.tail\n        val a = lst.tail\n        val d = lst.tail\n        val\
    \ c = lst.head\n        val b = lst.tail\n        val a = lst.tail\n        val\
    \ d = lst.tail\n        val c = lst.head\n        val b = lst.tail\n        val\
    \ a = lst.tail\n        val d = lst.tail\n        val c = lst.head\n        val\
    \ b = lst.tail\n        val a = lst.tail\n        val d = lst.tail\n        val\
    \ c = lst.head\n        val b = lst.tail\n        val a = lst.tail\n        val\
    \ d = lst.tail\n        val c = lst.head\n        val b = lst.tail\n        val\
    \ a = lst.tail\n        val d = lst.tail\n        val c = lst.head\n        val\
    \ b = lst.tail\n        val a = lst.tail\n        val d = lst.tail\n        val\
    \ c = lst.head\n        val b = lst.tail\n        val a = lst.tail\n        val\
    \ d = lst.tail\n        val c = lst.head\n        val b = lst.tail\n        val\
    \ a = lst.tail\n        val d = lst.tail\n        val c = lst.head\n        val\
    \ b = lst.tail\n        val a = lst.tail\n        val d = lst.tail\n        val\
    \ c = lst.head\n        val b = lst.tail\n        val a = lst.tail\n        val\
    \ d = lst.tail\n        val c = lst.head\n        val b = lst.tail\n        val\
    \ a = lst.tail\n        val d = lst.tail\n        val c = lst.head\n        val\
    \ b = lst.tail\n        val a = lst.tail\n        val d = lst.tail\n        val\
    \ c = lst.head\n        ", "        val sortedList = lst.sortBy(_)\n        val\
    \ strangeList = sortedList.zipWithIndex.sortBy(_._1)\n        strangeList.toList",
  "        lst.foldLeft((List[Long](), List[Long]()))( (acc, x) => {\n           \
    \ val minLst  = acc.getOrElse(Long.MinValue, List[Long]())\n            val maxLst\
    \  = acc.getOrElse(Long.MaxValue, List[Long]())\n            val newLst = minLst\
    \ :+ x :+ maxLst\n            (newLst, maxLst)\n        })._1.reverse", "    \
    \    if(lst.isEmpty) lst\n        else {\n            val list = lst.head\n  \
    \          var result = lst.tail\n            for(i <- 0 until list) result =\
    \ swapIfLarger(result, list)\n            result\n        }", "        val minVal\
    \ = lst.min\n        val maxVal = lst.max\n        val tmpVal = minVal\n     \
    \   val resultList = mutable.Buffer.empty[Long]\n        // First value is the\
    \ min value minus one\n        resultList.append(tmpVal-1)\n\n        while (tmpVal\
    \ <= maxVal) {\n            // Now tmpVal, minVal and maxVal are all equal\n \
    \           if (tmpVal == minVal) {\n                // Append new value to the\
    \ beginning\n                resultList.append(tmpVal)\n                // Next\
    \ value is max value + 1\n                resultList.append(maxVal+1)\n      \
    \      } else {\n                // Append new value to the middle\n         \
    \       resultList.append(tmpVal)\n                // Next value is min value\
    \ - 1\n                resultList.append(minVal-1)\n            }\n          \
    \  tmpVal = minVal + (tmpVal - minVal)\n        }\n        // Add last value to\
    \ the end\n        resultList.append(tmpVal)\n        resultList.flatten", " \
    \       val nums = lst.sorted\n        val len   = nums.length\n        val res\
    \   = new mutable.ListBuffer[Long]()\n        for (i <- 0 until len) {\n     \
    \       var index = i\n            var j = i + 1;\n            while (j < len)\
    \ {\n                if (nums(i).equals(nums(j)) && index < j) j++\n         \
    \       else if (nums(i).equals(nums(j)) && index > j) index--\n             \
    \   else {\n                    res += nums(index)\n                    index\
    \ = j\n                }\n            }\n        }\n        res.toList", "   \
    \     var sortedList = lst\n        val length = sortedList.length\n        val\
    \ newList = new List[Long](length)\n        for (i<- 0 until length-1) {\n   \
    \         newList(length-i-1) = sortedList(i)\n        }\n        for (i<- 0 until\
    \ length-1) {\n            for (j <- i until length-1) {\n                if (newList(j)\
    \ > newList(i)) {\n                    val temp = newList(i)\n               \
    \     newList(i) = newList(j)\n                    newList(j) = temp\n       \
    \         }\n            }\n        }\n        return newList", "        // sort\
    \ the list in increasing order\n        val increasingOrderList = lst.sortBy(_.toLong)\n\
    \n        // sort the list in descending order\n        val decreasingOrderList\
    \ = lst.sortBy(_.toLong.reverse)\n\n        // return list of increasing and descending\
    \ order\n        increasingOrderList ++ decreasingOrderList", "        val minValue=\
    \ lst.head\n        val maxValue= lst.last\n        var newLst = List[Long]()\n\
    \        for (i <- 0 until lst.size) {\n            var maxPos = maxValue\n  \
    \          var currPos = minValue\n            var numSwaps = 0 // to count swaps\n\
    \            while (currPos != maxPos) {\n                maxPos -= 1\n      \
    \          currPos += 1\n                numSwaps += 1\n            }\n      \
    \      newLst += lst.take(maxPos).take(currPos)\n        }\n        return newLst",
  "        if (lst.size < 2) return lst\n        val mid = lst.size / 2\n        val\
    \ l = strangeSortList(lst.filter(_ < mid))\n        val r = strangeSortList(lst.filter(_\
    \ > mid))\n        l.sortWith(_ < _) ::: r.sortWith(_ > _) ::: l.sortWith(_ <\
    \ _) ::: r.sortWith(_ > _)", "      var maxVal = Long.MinValue\n      var minVal\
    \ = Long.MaxValue\n      lst.foreach(l => {\n        if (l > maxVal) maxVal =\
    \ l\n        if (l < minVal) minVal = l\n      })\n      var result: List[Long]\
    \ = List()\n      if (lst.size == 0) result\n      else {\n        var next =\
    \ minVal\n        lst.foreach(l => {\n          if (next > maxVal) next = maxVal\n\
    \          if (l < next) next = l\n        })\n        result = lst.sortWith(_\
    \ < _)\n        result += strangeSortList(lst.filter(_ < next))\n        result\
    \ += strangeSortList(lst.filter(_ > next))\n      }\n      result", "        if\
    \ (lst.isEmpty)\n            return lst\n        var newList = lst\n        var\
    \ index = 0\n        // Find minimum number in list\n        var minElement =\
    \ lst.min\n        newList = lst.filter(x => x != minElement).sortBy(x => x).reverse\n\
    \        // Find maximum number in list\n        var maxElement = lst.max\n  \
    \      newList = newList.map(x => (index++, x)).sortBy(_._1).reverse\n       \
    \ // Find minimum number in list after reversing and sorting\n        minElement\
    \ = newList.min._1\n        // Find maximum number in list after reversing and\
    \ sorting\n        maxElement = newList.max._1\n        newList = newList.map(x\
    \ => (index++, x)).sortBy(_._1).reverse\n        //  Create new list\n       \
    \ newList = newList.zipWithIndex.map{ case (l, i) => newList(i) }.flatMap(x =>\
    \ x)\n        //  Concatenate min and max\n        newList = newList.::(minElement).::(maxElement).::(lst.min).::(lst.max).::(lst)\n\
    \        newList.toList", "        if (lst.isEmpty) lst\n        else {\n    \
    \        val sorted = lst.sortBy(-_)\n            val list = sorted diff sorted.reverse\n\
    \            strangeSortList(list)\n        }", "        val longs = lst.toList.map(_.toLong).toList\n\
    \        if (longs.isEmpty) lst.clear()\n        else longs.sortWith((a, b) =>\
    \ a - b).reverse", "        val tmpMap : mutable.Map[Long, Long] = mutable.Map.empty[Long,\
    \ Long]\n        lst.foreach(x => {\n            if (tmpMap.containsKey(x))\n\
    \                tmpMap += (x -> tmpMap(x))\n            else\n              \
    \  tmpMap += (x -> x)\n        })\n        val maxVal = tmpMap.maxBy(_._2)._1\n\
    \        tmpMap.toList\n            .sortBy(_._1)\n            .map(x => (x._1,\
    \ x._2))\n            .map(x => maxVal + x)", "        def strange(lst: List[Long],\
    \ cur:List[Long], k:Int) : List[Long] = {\n            if( lst.length <= 1 )\n\
    \                lst\n            else\n                if( cur.length <= 1 )\n\
    \                    strange(lst.tail, cur.tail, k)\n                else\n  \
    \                  strange(lst.tail, lst.head,k) ::: strange(cur, lst.tail,k)\n\
    \        }\n        lst match {\n            case Nil =>\n                lst\n\
    \            case _  => strange(lst, Nil, 0) \n        }", "        var tmp =\
    \ lst\n        var tmp2 = lst\n        var i : Int = 0\n        while (i < tmp.size)\
    \ {\n            // move all the values above to tmp2\n            for (j <- i\
    \ to tmp.size ) {\n                if (j < tmp.size) {\n                    tmp2\
    \ += tmp(j)\n                }\n            }\n            // move the smallest\
    \ element to the tail of the list\n            tmp2 += tmp(i)\n            tmp2\
    \ = tmp2.sorted\n            // move the smallest element from tmp2 to the tail\n\
    \            for (j <- tmp.size until i) {\n                tmp2 += tmp(j)\n \
    \           }\n            tmp = tmp2\n            i += 1\n        }\n       \
    \ tmp", "        if (lst.size <= 1) {\n            return lst\n        }\n   \
    \     val m = lst.head\n        val n = lst.last\n        val bigger = strangeSortList(lst.rest)\
    \ ++ List(n)(0)\n        val smaller = strangeSortList(lst.rest) ++ List(m)((lst.last\
    \ - m)+1)\n        bigger ++ smaller"]
stop_tokens:
- "\n    }\n"
