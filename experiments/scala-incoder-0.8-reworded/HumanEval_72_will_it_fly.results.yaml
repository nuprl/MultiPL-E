language: scala
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindromic[T](l : List[T]) : Boolean = l match {\n           \
    \ case head :: tail => {\n                if (head != tail.head) false\n     \
    \           else (isPalindromic(tail.tail))\n            }\n            case _\
    \ => true\n        }\n\n        def maxPossibleWeight(l: List[Long]) : Long =\
    \ l match {\n            case x :: xs => xs.reduceOption(_ + _).getOrElse(0L)\n\
    \            case _ => 0\n        }\n\n        val l = new ListBuffer[Long]\n\
    \        l += w.toLong\n        q foreach { x => l += x.toLong }\n        val\
    \ w = l.foldRight(-1L)(_ + _)\n        if (w > 0 && w <= maxPossibleWeight(q)\
    \ && isPalindromic(q)) {\n            true\n        }\n        else false\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E039] Reference Error: /tmp/tmpscg_mbng.scala:34:13 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        l += w.toLong\n\e[31m\e[31m   |\e[0m        \
    \     ^\e[0m\n\e[31m   |\e[0m             w is a forward reference extending over\
    \ the definition of w\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010556
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.isEmpty) false\n        val maxSum = q.reduce((a,b) => a + b)\n\
    \        val sumOfElements = q.reduce((a,b) => a + b)\n        val maximum = if\
    \ (sumOfElements > w) sumOfElements else if (sumOfElements < 0) -sumOfElements\
    \ else w\n        val balanced = sumOfElements <= maximum\n        val palindromic\
    \ = sumOfElements == maximum\n        q.reverse.forall(x => x % 10 == 0 && palindromic)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz1pkosso.scala:29)\n\tat Problem.main(tmpz1pkosso.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010563
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Implement here\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7fg8bjk1.scala:19:56\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mwillItFly\e\
    [0m(\e[36mq\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mw\e[0m : \e[35mLong\e\
    [0m) : \e[35mBoolean\e[0m = {\n\e[31m\e[31m   |\e[0m                         \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                                 Found:    Unit\n\e[31m   |\e[0m            \
    \                                           Required: Boolean\n\e[31m20 |\e[0m\
    \        \e[34m// Implement here\e[0m\n\e[31m21 |\e[0m    }\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q.length <= 2\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq_l82q9e.scala:23)\n\tat Problem.main(tmpq_l82q9e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var ans = false\n        q.reverse.foreach{ x =>\n            if (q.length\
    \ == 0) ans = true\n            if (x > w) ans = false\n            if (q.length\
    \ == 1 && q == List(x.toLong)) ans = true\n        }\n        ans\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpowumnjct.scala:29)\n\tat Problem.main(tmpowumnjct.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010562
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxW  = Math.pow(10, w).max(10)\n        var b       = 0\n      \
    \  var bWeight = 0\n        val w = w.toLong\n        val q = q.filter {\n   \
    \         x => b += 1\n            bWeight += x.toLong\n            bWeight >\
    \ maxW\n        }\n        val palin = q.reverse.equals(q)\n        if(palin)\
    \ b > w*2\n        else bWeight <= w\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsop9glje.scala:23:16 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mw\e[0m = w.toLong\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mw\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpsop9glje.scala:24:16 ---------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = q.filter {\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mq\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010555
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // TODO: Write your solution here\n        val result = q match {\n \
    \           case x if (x.isEmpty) => true\n            case x => if (x.last ==\
    \ x.head) { val r = x.reverse; r == x.reverse } else false\n        }\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv25djsa7.scala:31)\n\tat Problem.main(tmpv25djsa7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010563
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Hint: use 'zip' on Lists\n        q match {\n            case List()\
    \ => true\n            case x :: xs => {\n                // Hint: use 'foldLeft'\
    \ to loop through the list\n                xs.foldLeft(false) {\n           \
    \         // Hint: compare the sum of elements to the maximum possible weight\n\
    \                    case (true, sum) => (sum < w) || x == xs.last\n         \
    \           // Hint: if the sum is less than or equal to the maximum possible\
    \ weight, return true\n                    case (false, sum) => sum == w\n   \
    \             }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz8c_bly6.scala:35)\n\tat Problem.main(tmpz8c_bly6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010564
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (w.isEmpty) true\n        else q.isEmpty && \n        w.sum < q.head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyflb1472.scala:20:14 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (w.isEmpty) \e[31mtrue\e[0m\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ isEmpty is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyflb1472.scala:22:10\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        w.sum < q.head\n\e\
    [31m\e[31m   |\e[0m        ^^^^^\e[0m\n\e[31m   |\e[0m        value sum is not\
    \ a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660010562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val w0 = w.toLong\n        val n = q.length\n        if (n == 0) true\n\
    \        else if (n == 1) true\n        else {\n            val head = q(0).toLong\n\
    \            val tail = q.drop(1).toList\n            val maxWeight = w0 + tail.max\n\
    \            if (maxWeight < w0) false\n            else willItFly(tail, maxWeight)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps1ldbia4.scala:34)\n\tat Problem.main(tmps1ldbia4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010563
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if(q.isEmpty)\n            false\n        else if(q.length == 1)\n  \
    \          true\n        else\n            {\n                val totalWeight\
    \ = sum(q)\n                val maxWeight = math.pow(10, math.floor(math.log10(totalWeight)))\n\
    \                val paliList: List[Long] = q.reverse.takeWhile(_ < maxWeight)\n\
    \                val listRev = paliList.reverse\n                if(totalWeight\
    \ < maxWeight)\n                    listRev == paliList\n                else\n\
    \                    listRev.last == paliList.last\n            }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpieyx5o2m.scala:26:34 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mval\e[0m \e[36mtotalWeight\e[0m\
    \ = sum(q)\n\e[31m\e[31m   |\e[0m                                  ^^^\e[0m\n\e\
    [31m   |\e[0m                                  Not found: sum\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010555
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val balance = q.length <= w\n        val total = q.foldLeft(0.0l){(x,\
    \ y) => x + y}\n        balance && total <= w\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpsuh0ose1.scala:21:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mtotal\e[0m = q.foldLeft(0.0l){(\e\
    [36mx\e[0m, \e[36my\e[0m) => x + y}\n\e[31m\e[31m   |\e[0m                   \
    \            ^\e[0m\n\e[31m   |\e[0m                               Invalid literal\
    \ number\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsuh0ose1.scala:21:49\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mtotal\e[0m = q.foldLeft(0.0l){(\e[36mx\e[0m, \e[36my\e[0m) => x + y}\n\e[31m\e\
    [31m   |\e[0m                                               ^^^\e[0m\n\e[31m \
    \  |\e[0mvalue + is not a member of Null, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.set\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.set\
    \ asScala\n\e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\
    \e[31m   |\e[0m  import math.BigInt.javaBigInteger2bigInt\n\e[31m   |\e[0m  import\
    \ math.Numeric.BigDecimalAsIfIntegral.mkNumericOps\n\e[31m   |\e[0m  import math.Numeric.BigDecimalIsFractional.mkNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsuh0ose1.scala:22:25\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        balance && total\
    \ <= w\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ <= is not a member of Null, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\
    \e[31m   |\e"
  stdout: ''
  timestamp: 1660010563
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q.sliding(2).forall { case List(i, j) => abs(i + j - 2 * w) < w }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq69ovx8s.scala:23)\n\tat Problem.main(tmpq69ovx8s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010563
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        q match {\n          case x :: xs =>\
    \ x.toLong match {\n            case _ if xs.isEmpty   => true\n            case\
    \ _ if xs.head < 0 => false\n            case _ if xs.last >= maxWeight => true\n\
    \            case _ if xs.last == maxWeight =>\n              val sum = sum(xs)\n\
    \              (sum + x.toLong) match {\n                case _ if sum == 0 =>\
    \ true\n                case _ if sum < maxWeight => false\n                case\
    \ _ if sum >= maxWeight => true\n              }\n            case _ => false\n\
    \          }\n          case _ => true\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzcgkmbyc.scala:27:24 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m              \e[33mval\e[0m \e[36msum\e[0m = sum(xs)\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35msum\e[0m needs type\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010555
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length < 2) true\n        else {\n            // It's unbalanced,\
    \ do something.\n            val maxWeight = q.reduceRight(_+_)\n            val\
    \ sumWeight = q.sum\n            if (sumWeight <= maxWeight - w) true\n      \
    \      else false\n        }\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvwucctqb.scala:30)\n\tat Problem.main(tmpvwucctqb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010563
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxW = math.pow(w, q.length).toInt\n        val balanced = q.length\
    \ % 2 != 0\n        if (balanced) {\n            val reverse = ListBuffer(q.last)\n\
    \            reverse.reverse\n            for (i <- 0 until q.length) reverse\
    \ = q(i).plus(reverse)\n            val sumOfWights = reverse.foldLeft(0l) { (acc,\
    \ el) => acc + el }\n            sumOfWights <= maxW\n        } else {\n     \
    \       val sumOfWights = q.foldLeft(0l) { (acc, el) => acc + el }\n         \
    \   sumOfWights <= maxW\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw9jff20n.scala:25:55 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mfor\e[0m (i <- \e[31m0\e[0m until q.length)\
    \ reverse = q(i).plus(reverse)\n\e[31m\e[31m   |\e[0m                        \
    \                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                   value plus is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val s = q.sum\n        val l = q.size\n        if (s > w) false\n   \
    \     else l == 0 || (w / s) <= l / 2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5x7gk41r.scala:27)\n\tat Problem.main(tmp5x7gk41r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010562
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val ls : List[Long] = reverse(q)\n        ls.forall { x =>\n        \
    \    val y = ls.filterNot(_ == x)\n            val sum = sumList(y)\n        \
    \    (sum == w) && {\n                if(sum < w)\n                    sum < w\n\
    \                else\n                    true\n            }\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg_g3c6ub.scala:20:30 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mls\e[0m : \e[35mList\e[0m[\e\
    [35mLong\e[0m] = reverse(q)\n\e[31m\e[31m   |\e[0m                           \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found: reverse\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg_g3c6ub.scala:23:22\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m\
    \ \e[36msum\e[0m = sumList(y)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: sumList\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010554
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Psuedocode\n        // 1. Sort q in descending order of w\n      \
    \  // 2. Add last element of q to stack\n        // 3. Remove top element of stack\
    \ from stack\n        // 4. Add next element of q to stack\n        // 5. Repeat\
    \ until stack is empty\n        // 6. Check for balanced condition\n        //\
    \ 7. Returns false if the condition is not satisfied\n        // 8. Returns true\
    \ if condition is satisfied\n        // 9. Sort q in descending order of w\n\n\
    \        // Psuedocode\n        // 1. Check balanced condition\n        // 2.\
    \ Return false if condition is not satisfied\n        // 3. Else return true\n\
    \n        // Psuedocode\n        // 1. Sort q in descending order of w\n     \
    \   // 2. Add last element of q to stack\n        // 3. Remove top element of\
    \ stack from stack\n        // 4. Add next element of q to stack\n        // 5.\
    \ Repeat until stack is empty\n        // 6. Check for balanced condition\n  \
    \      // 7. Return true if condition is satisfied\n        // 8. Else return\
    \ false\n\n        // Psuedocode\n        // 1. Sort q in descending order of\
    \ w\n        // 2. Add last element of q to stack\n        // 3. Remove top element\
    \ of stack from stack\n        // 4. Add next element of q to stack\n        //\
    \ 5. Repeat until stack is empty\n        // 6. Check for balanced condition\n\
    \        // 7. Return true if condition is satisfied\n        // 8. Else return\
    \ false\n\n        // Psuedocode\n        // 1. Sort q in descending order of\
    \ w\n        // 2. Add last element of q to stack\n        // 3. Remove top element\
    \ of stack from stack\n        // 4. Add next element of q to stack\n        //\
    \ 5. Repeat until stack is empty\n        // 6. Check for balanced condition\n\
    \        // 7. Return true if condition is satisfied\n        // 8. Else return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmfk_igxh.scala:19:56\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mwillItFly\e\
    [0m(\e[36mq\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mw\e[0m : \e[35mLong\e\
    [0m) : \e[35mBoolean\e[0m = {\n\e[31m\e[31m   |\e[0m                         \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                                 Found:    Unit\n\e[31m   |\e[0m            \
    \                                           Required: Boolean\n\e[31m20 |\e[0m\
    \        \e[34m// Psuedocode\e[0m\n\e[31m21 |\e[0m        \e[34m// 1. Sort q in\
    \ descending order of w\e[0m\n\e[31m22 |\e[0m        \e[34m// 2. Add last element\
    \ of q to stack\e[0m\n\e[31m23 |\e[0m        \e[34m// 3. Remove top element of\
    \ stack from stack\e[0m\n\e[31m24 |\e[0m        \e[34m// 4. Add next element of\
    \ q to stack\e[0m\n\e[31m25 |\e[0m        \e[34m// 5. Repeat until stack is empty\e\
    [0m\n\e[31m26 |\e[0m        \e[34m// 6. Check for balanced condition\e[0m\n\e\
    [31m27 |\e[0m        \e[34m// 7. Returns false if the condition is not satisfied\e\
    [0m\n\e[31m28 |\e[0m        \e[34m// 8. Returns true if condition is satisfied\e\
    [0m\n\e[31m29 |\e[0m        \e[34m// 9. Sort q in descending order of w\e[0m\n\
    \e[31m30 |\e[0m        \e[34m// Psuedocode\e[0m\n\e[31m31 |\e[0m        \e[34m//\
    \ 1. Check balanced condition\e[0m\n\e[31m32 |\e[0m        \e[34m// 2. Return\
    \ false if condition is not satisfied\e[0m\n\e[31m33 |\e[0m        \e[34m// 3.\
    \ Else return true\e[0m\n\e[31m34 |\e[0m        \e[34m// Psuedocode\e[0m\n\e[31m35\
    \ |\e[0m        \e[34m// 1. Sort q in descending order of w\e[0m\n\e[31m36 |\e\
    [0m        \e[34m// 2. Add last element of q to stack\e[0m\n\e[31m37 |\e[0m  \
    \      \e[34m// 3. Remove top element of stack from stack\e[0m\n\e[31m38 |\e[0m\
    \        \e[34m// 4. Add next element of q to stack\e[0m\n\e[31m39 |\e[0m    \
    \    \e[34m// 5. Repeat until stack is empty\e[0m\n\e[31m40 |\e[0m        \e[34m//\
    \ 6. Check for balanced condition\e[0m\n\e[31m41 |\e[0m        \e[34m// 7. Return\
    \ true if condition is satisfied\e[0m\n\e[31m42 |\e[0m        \e[34m// 8. Else\
    \ return false\e[0m\n\e[31m43 |\e[0m        \e[34m// Psuedocode\e[0m\n\e[31m44\
    \ |\e[0m        "
  stdout: ''
  timestamp: 1660010560
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindromic(xs: List[Long]): Boolean = xs.foldLeft(true)( (acc,\
    \ x) => acc && x.equals(xs.reverse) ) == true\n        def sum(xs: List[Long]):\
    \ Long = xs.foldLeft(0L)( (acc, x) => acc + x )\n        def palindromic(xs: List[Long],\
    \ max : Long): Boolean = xs.foldLeft(true)( (acc, x) => acc && x == (x.toLong\
    \ % max) ) == true\n        val xs = q.toList\n        xs.size == xs.reverse.length\
    \ && sum(xs) <= w && isPalindromic(xs) && palindromic(xs, w)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfg3s6r9n.scala:27)\n\tat Problem.main(tmpfg3s6r9n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010563
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 1) {\n            if (q(0) == q(1)) {\n             \
    \   q.length == 1\n            } else {\n                q.length == 0\n     \
    \       }\n        } else {\n            if (q.length % 2 == 0) {\n          \
    \      val left = q.take(q.length/2).reverse.sorted\n                val right\
    \ = q.drop(q.length/2).reverse.sorted\n                val maxSum = q.length /\
    \ 2\n                if (left.sum < w) {\n                    false\n        \
    \        } else if (left.sum > w) {\n                    val left = left.reverse.sorted\n\
    \                    if (left.sum < w) {\n                        false\n    \
    \                } else {\n                        val right = right.reverse.sorted\n\
    \                        if (right.sum < w) {\n                            false\n\
    \                        } else {\n                            val maxSum = maxSum\
    \ - left.sum + right.sum\n                            maxSum == w\n          \
    \              }\n                    }\n                } else {\n          \
    \          val left = left.reverse.sorted\n                    if (left.sum <\
    \ w) {\n                        false\n                    } else {\n        \
    \                val right = right.reverse.sorted\n                        if\
    \ (right.sum < w) {\n                            false\n                     \
    \   } else {\n                            val maxSum = maxSum - left.sum + right.sum\n\
    \                            maxSum == w\n                        }\n        \
    \            }\n                }\n            } else {\n                val left\
    \ = q.take(q.length/2).reverse.sorted\n                val right = q.drop(q.length/2).reverse.sorted\n\
    \                val maxSum = q.length / 2\n                if (left.sum < w)\
    \ {\n                    false\n                } else if (left.sum > w) {\n \
    \                   val left = left.reverse.sorted\n                    if (left.sum\
    \ < w) {\n                        false\n                    } else {\n      \
    \                  val right = right.reverse.sorted\n                        if\
    \ (right.sum < w) {\n                            false\n                     \
    \   } else {\n                            val maxSum = maxSum - left.sum + right.sum\n\
    \                            maxSum == w\n                        }\n        \
    \            }\n                } else {\n                    val left = left.reverse.sorted\n\
    \                    if (left.sum < w) {\n                        false\n    \
    \                } else {\n                        val right = right.reverse.sorted\n\
    \                        if (right.sum < w) {\n                            false\n\
    \                        } else {\n                            val maxSum = maxSum\
    \ - left.sum + right.sum\n                            maxSum == w\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpy56a485q.scala:34:31 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                    \e[33mval\e[0m \e[36mleft\e[0m =\
    \ left.reverse.sorted\n\e[31m\e[31m   |\e[0m                               ^\e\
    [0m\n\e[31m   |\e[0m                               Recursive \e[33mvalue\e[0m\
    \ \e[35mleft\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpy56a485q.scala:38:36 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m                        \e[33mval\e[0m \e[36mright\e[0m = right.reverse.sorted\n\
    \e[31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m   |\e\
    [0m                                    Recursive \e[33mvalue\e[0m \e[35mright\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpy56a485q.scala:42:41\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                     \
    \       \e[33mval\e[0m \e[36mmaxSum\e[0m = maxSum - left.sum + right.sum\n\e[31m\e\
    [31m   |\e[0m                                         ^\e[0m\n\e[31m   |\e[0m\
    \                                       Recursive \e[33mvalue\e[0m \e[35mmaxSum\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpy56a485q.scala:47:31\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m                    \e\
    [33mval\e[0m \e[36mleft\e[0m = left.reverse.sorted\n\e[31m\e[31m   |\e[0m    \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \     Recursive \e[33mvalue\e[0m \e[35mleft\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpy56a485q.scala:51:36 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                        \e[33mval\e[0m \e[36mright\e\
    [0m = right.reverse.sorted\n\e[31m\e[31m   |\e[0m                            \
    \        ^\e[0m\n\e[31m   |\e[0m                                    Recursive\
    \ \e[33mvalue\e[0"
  stdout: ''
  timestamp: 1660010558
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val p = (q :+ q.reverse) match {\n            case Nil => true\n    \
    \        case head :: tail => palindrome(head :: tail) && (q.sum < w)\n      \
    \  }\n        p\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzj84vp33.scala:22:33 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e[0m head :: tail => palindrome(head\
    \ :: tail) && (q.sum < w)\n\e[31m\e[31m   |\e[0m                             \
    \    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 Not found:\
    \ palindrome\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010555
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val max = Long.MaxValue\n        q.length <= w && (q.length == 0 || (q.length\
    \ == 1 && q.head <= max))\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmhs8483r.scala:24)\n\tat Problem.main(tmpmhs8483r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sumOfWeights = q.map(x => x.toLong).sum\n        if (sumOfWeights\
    \ <= w) true\n        else false\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbf57nnae.scala:26)\n\tat Problem.main(tmpbf57nnae.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val list = q.toList\n        val maxWeight = w\n        val listSize\
    \ = list.length\n        val sumOfElements = list.sum\n        if (listSize ==\
    \ 0 || sumOfElements > maxWeight) {\n            return false\n        }\n   \
    \     val reverseList = reverse(list)\n        val reverseSum = reverseList.sum\n\
    \        if (reverseSum > maxWeight) {\n            return false\n        }\n\
    \        val diff = maxWeight - sumOfElements\n        if (diff > 0) {\n     \
    \       return true\n        }\n        val reverseDiff = reverseSum - maxWeight\n\
    \        if (reverseDiff > 0) {\n            return true\n        }\n        reverseList.forall(element\
    \ => element < maxWeight)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzvvk93_y.scala:27:26 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mreverseList\e[0m = reverse(list)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                         Not found: reverse\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010568
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var flag : Boolean = false\n        var i = 0\n        var l = 0\n  \
    \      while(i < q.size && !flag) {\n            l = i\n            val x = q(i)\n\
    \            for(j <- i until q.size) {\n                val y = q(j)\n      \
    \          if(y < x) l = j\n            }\n            if(l != i && q(i) == q(l))\
    \ {\n                flag = true\n                break\n            }\n     \
    \       i += 1\n        }\n        return flag\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpme_s4ov_.scala:32:16 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010568
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var sum = 0\n        var max = 0\n        val myList = (q: _*)\n    \
    \    myList.foreach { e => sum = sum + e }\n        if (sum < w) false\n     \
    \   else {\n            for (x <- myList) {\n                if (x == 0) return\
    \ false\n                if (sum + x < w) max = Math.max(sum + x, max)\n     \
    \       }\n            if (max > w) true\n            else willItFly(q, w)\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E031] Syntax Error: /tmp/tmp7cstiz1m.scala:22:25 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mmyList\e[0m = (q: \e[35m_*\e\
    [0m)\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m  \
    \                       * can be used only for last argument\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmp7cstiz1m.scala:22:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mmyList\e[0m = (q: \e[35m_*\e\
    [0m)\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0m            Cannot\
    \ return repeated parameter type Long*\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp7cstiz1m.scala:23:36 --------------------\e[0m\e[0m\n\e[31m23 |\e[0m\
    \        myList.foreach { \e[36me\e[0m => sum = sum + e }\n\e[31m\e[31m   |\e\
    [0m                                    ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                           Found:    Long\n\e[31m   |\e[0m                  \
    \                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp7cstiz1m.scala:28:48 --------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                \e[33mif\e[0m (sum + x < w) max = Math.max(sum + x, max)\n\
    \e[31m\e[31m   |\e[0m                                                ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                Found:   \
    \ Long\n\e[31m   |\e[0m                                                Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var maxSum = w.toLong\n        var sum = 0\n\n        for( i <- 0 until\
    \ q.size){\n            sum = sum + q(i)\n            if(sum > maxSum){\n    \
    \            maxSum = sum\n            }\n        }\n        if((sum == maxSum)\
    \ && (q.reverse.forall( x => q(0) == x))){\n            return true\n        }\n\
    \        return false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqn9cz3fw.scala:24:18\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            sum = sum + q(i)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \            Found:    Long\n\e[31m   |\e[0m                  Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Your code goes here\n        val maxW = (w.toDouble / 2.0).toLong\n\
    \        val sum = 0\n        val len = q.size\n        for(i <- 0 until len)\
    \ {\n          val x = q(i).toLong\n          val y = math.max(x * 2 - w, 0l).toLong\n\
    \          sum += y\n        }\n        len == (sum.toDouble <= maxW && sum ==\
    \ sum && q == q.reverse)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq9s05z7i.scala:27:14 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m          sum += y\n\e[31m\e[31m   |\e[0m          ^^^^^^\e\
    [0m\n\e[31m   |\e[0m          value += is not a member of Int - did you mean sum.!=?\n\
    \e[31m\e[31m-- Error: /tmp/tmpq9s05z7i.scala:29:8 ------------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        len == (sum.toDouble <= maxW && sum == sum &&\
    \ q == q.reverse)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Int and Boolean cannot be compared\
    \ with == or !=\n2 errors found\n"
  stdout: ''
  timestamp: 1660010575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var sum = 0\n        q.foreach {\n            x => sum += x\n       \
    \ }\n        sum < w && q.reverse.forall {\n            x => sum += x\n      \
    \  }\n        sum < w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4mp5k1hn.scala:22:21 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[36mx\e[0m => sum += x\n\e[31m\e[31m  \
    \ |\e[0m                 ^^^^^^\e[0m\n\e[31m   |\e[0m                 value +=\
    \ is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp4mp5k1hn.scala:25:21 ------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            \e[36mx\e[0m => sum += x\n\e[31m\e[31m   |\e[0m          \
    \       ^^^^^^\e[0m\n\e[31m   |\e[0m                 value += is not a member\
    \ of Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def lSum(l : List[Long]) : Long = {\n            val total = 0\n    \
    \        var i = 0\n            while (i < l.length) {\n                total\
    \ += l(i).toLong\n                i += 1\n            }\n            total\n \
    \       }\n        // Write your logic here\n        val maxW = l * w\n      \
    \  if (maxW.toDouble * maxW.toDouble < lSum(q) * q.toDouble && lSum(q) <= maxW.toDouble\
    \ * maxW.toDouble) {\n            (maxW.toDouble * maxW.toDouble <= lSum(q) *\
    \ q.toDouble && lSum(q) <= maxW.toDouble * maxW.toDouble)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4ca4p5zm.scala:24:22 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                total += l(i).toLong\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value +=\
    \ is not a member of Int - did you mean total.!=?\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmp4ca4p5zm.scala:30:19 ------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxW\e[0m = l * w\n\e[31m\e[31m   |\e[0m\
    \                   ^\e[0m\n\e[31m   |\e[0m                   Not found: l\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4ca4p5zm.scala:31:8\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mif\e[0m (maxW.toDouble\
    \ * maxW.toDouble < lSum(q) * q.toDouble && lSum(q) <= maxW.toDouble * maxW.toDouble)\
    \ {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\
    \e[31m   |\e[0m        Required: Boolean\n\e[31m   |\e[0m        Maybe you are\
    \ missing an else part for the conditional?\n\e[31m32 |\e[0m            (maxW.toDouble\
    \ * maxW.toDouble <= lSum(q) * q.toDouble && lSum(q) <= maxW.toDouble * maxW.toDouble)\n\
    \e[31m33 |\e[0m        }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q.size() == q.reverse.size() && q.sum <= w\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp7tam8r41.scala:20:10 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        q.size() == q.reverse.size() && q.sum <= w\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e\
    [0m \e[35msize\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // TODO:\n        // Implement this function using a fold.\n        q.reverse.foldLeft(false){(acc,\
    \ el) => if (acc) el + acc >= w else acc}\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpir7cetk1.scala:22:59 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        q.reverse.foldLeft(\e[31mfalse\e[0m){(\e[36macc\e\
    [0m, \e[36mel\e[0m) => \e[33mif\e[0m (acc) el + acc >= w \e[33melse\e[0m acc}\n\
    \e[31m\e[31m   |\e[0m                                                        ^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m+\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m\
    \   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0m\
    \ (x: String): String\n\e[31m   |\e[0mmatch arguments ((acc : Boolean))\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWays = q.length * w\n        val ways = q.toStream.foldLeft(0)(_\
    \ + _)\n        ways <= maxWays\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3iu4qzdm.scala:21:42\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mways\e\
    [0m = q.toStream.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        \
    \                                  ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                           Found:    Long\n\e[31m   |\e[0m                  \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010580
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val l = q.length\n        if (l == 1) true\n        else if (l == 2 ||\
    \ l == 3) true\n        else if (l == 4 && q.sum - w <= 0) true\n        else\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5hqro9h7.scala:28)\n\tat Problem.main(tmp5hqro9h7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced (xs: List[Long]) : Boolean = {\n            val l = xs.size\n\
    \            if (l == 0) true\n            else {\n                val max = (xs\
    \ zip xs.reverse).max\n                val min = (xs zip xs.reverse).min\n   \
    \             val (min1, max1) = min._1, max._1\n                val diff = (max1\
    \ - min1) + w\n                if (diff < 0)\n                    false\n    \
    \            else if (diff == 0)\n                    true\n                else\
    \ {\n                    if (diff < min1) false\n                    else if (diff\
    \ == min1) true\n                    else {\n                        val (x1,\
    \ x2) = xs.splitAt(l)\n                        val a = xs.filter(_ != x1)\n  \
    \                      val b = xs.filter(_ != x2)\n                        val\
    \ aIsBalanced = isBalanced(a)\n                        val bIsBalanced = isBalanced(b)\n\
    \                        val allAreBalanced = aIsBalanced && bIsBalanced\n   \
    \                     if (allAreBalanced) true\n                        else false\n\
    \                    }\n                }\n            }\n        }\n\n      \
    \  isBalanced(q)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpoardlo0e.scala:26:41 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mval\e[0m (min1, max1) = min._1,\
    \ max._1\n\e[31m\e[31m   |\e[0m                                         ^\e[0m\n\
    \e[31m   |\e[0m                                 end of statement expected but\
    \ ',' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoardlo0e.scala:27:33\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                \e[33mval\e\
    [0m \e[36mdiff\e[0m = (max1 - min1) + w\n\e[31m\e[31m   |\e[0m               \
    \             ^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of Any, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpoardlo0e.scala:37:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                        \e[33mval\e[0m \e[36ma\e[0m =\
    \ xs.filter(_ != x1)\n\e[31m\e[31m   |\e[0m                                  \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types Long and List[Long]\
    \ cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpoardlo0e.scala:38:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m38 |\e[0m       \
    \                 \e[33mval\e[0m \e[36mb\e[0m = xs.filter(_ != x2)\n\e[31m\e[31m\
    \   |\e[0m                                          ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m    Values of types Long and List[Long] cannot be compared with == or !=\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(l: Seq[Long]): Boolean = {\n            // The sum of\
    \ its elements is less than or equal the maximum possible weight w.\n        \
    \    val sum = l.toSet.sum\n            l == l.reverse\n        }\n        def\
    \ isPalindrome(l: List[Long]) = {\n            val l = l.toList\n            l.tail\
    \ == l.init &&\n            l.head == l.last &&\n            l.reverse.tail ==\
    \ l.reverse.init\n        }\n        val l = q.toList\n        // q fly, if balanced\
    \ and sum < w\n        isBalanced(q) && isPalindrome(l) && sumLessOrEqual(l, w)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9y_7w16q.scala:26:20 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = l.toList\n\e\
    [31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m               \
    \     Recursive \e[33mvalue\e[0m \e[35ml\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9y_7w16q.scala:33:19 --------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        isBalanced(q) && isPalindrome(l) && sumLessOrEqual(l,\
    \ w)\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m        \
    \           Found:    (q : List[Long])\n\e[31m   |\e[0m                   Required:\
    \ collection.mutable.Seq[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp9y_7w16q.scala:33:44 ------------------------\e[0m\e[0m\n\e[31m33 |\e\
    [0m        isBalanced(q) && isPalindrome(l) && sumLessOrEqual(l, w)\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                            Not found: sumLessOrEqual\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.size < 2) true\n        else {\n            val maximumWeight =\
    \ w - q.sum\n            q.reverse.tail.forall(l => l <= maximumWeight && !q.reverse.exists(_\
    \ == l))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyxaaosmw.scala:27)\n\tat Problem.main(tmpyxaaosmw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val totalWeight = q.sum\n        if (totalWeight <= w) return true\n\
    \        val reverse = q.reverse\n        val currentIndex = reverse.indexOf(0)\n\
    \        while (currentIndex >= 0 && !reverse.exists(x => x == currentIndex))\
    \ {\n            reverse = reverse.reverse\n            currentIndex = reverse.indexOf(0)\n\
    \        }\n        reverse == q || (!reverse.exists(x => x == currentIndex) &&\
    \ totalWeight <= w)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp6k1ea905.scala:25:20 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            reverse = reverse.reverse\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \   Reassignment to val reverse\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp6k1ea905.scala:26:25 -----------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            currentIndex = reverse.indexOf(\e[31m0\e[0m)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            Reassignment to val currentIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def addPalindrome(a: Long, b: Long, ac: Array[Long], bc : Array[Long],\
    \ x: Long) : Unit = {\n            if (a > b || b > x)\n                return\n\
    \            if (a == b){\n                ac(0) = x\n                bc(0) =\
    \ x\n                addPalindrome(a+1, b, ac, bc, x)\n            }\n       \
    \     else if (a == x && b == x){\n                ac(0) = x\n               \
    \ bc(0) = x\n                addPalindrome(a+1, b, ac, bc, x)\n              \
    \  addPalindrome(a+1, b+1, ac, bc, x)\n            }\n            else{\n    \
    \            ac(0) = x\n                bc(0) = x\n                addPalindrome(a+1,\
    \ b, ac, bc, x)\n                addPalindrome(a+1, b+1, ac, bc, x)\n        \
    \        addPalindrome(a+1, b+1, ac, bc, x)\n                addPalindrome(a+1,\
    \ b+1, ac, bc, x)\n                addPalindrome(a+1, b+1, ac, bc, x)\n      \
    \          addPalindrome(a+1, b+1, ac, bc, x)\n            }\n        }\n\n  \
    \      def isPalindrome(a: Long, b: Long, ac : Array[Long], bc : Array[Long],\
    \ x : Long) : Boolean = {\n            if (a > b || b > x)\n                return\
    \ false\n            if (ac(0) != x)\n                return false\n         \
    \   if (bc(0) != x)\n                return false\n            if (a == x && b\
    \ == x){\n                return true\n            }\n            else{\n    \
    \            return true\n            }\n        }\n\n        def balance(a: Long,\
    \ b: Long, ac: Array[Long], bc : Array[Long], x: Long) : Unit = {\n          \
    \  if (a > b || b > x)\n                return\n            if (a == b){\n   \
    \             ac(0) = x\n                bc(0) = x\n            }\n          \
    \  else if (a == x && b == x){\n                ac(0) = x\n                bc(0)\
    \ = x\n            }\n            else{\n                ac(0) = x\n         \
    \       bc(0) = x\n                addPalindrome(a+1, b, ac, bc, x)\n        \
    \        addPalindrome(a+1, b+1, ac, bc, x)\n            }\n        }\n\n    \
    \    var ac = new Array[Long](q.size)\n        var bc = new Array[Long](q.size)\n\
    \        var a = 0\n        var b = 0\n        var x = 0\n        var total =\
    \ 0\n        var maxWeight = 0\n\n        def maxWeight () : Long = {\n      \
    \      var maxWeight = 0\n            var i = 0\n            while (i < q.size)\
    \ {\n                var x = q(i)\n                if (\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfwkk6cza.scala:93:20 ---------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m                \e[33mif\e[0m (\n\e[31m\e[31m   |\e[0m\
    \                    ^\e[0m\n\e[31m   |\e[0m                    expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpfwkk6cza.scala:105:0 ---------------------------\e[0m\e[0m\n\e[31m105\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfwkk6cza.scala:104:1\
    \ --------------------\e[0m\e[0m\n\e[31m104 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e\
    [0m\n\e[31m    |\e[0m Found:    Unit\n\e[31m    |\e[0m Required: Long\n\e[31m\
    \    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpfwkk6cza.scala:95:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m95 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660010583
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val palindrome = q.reverse.forall(q.equals)\n        val maximum = q.sum\n\
    \        (palindrome && maximum >= w) && maximum == q.max\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0xd13vq8.scala:25)\n\tat Problem.main(tmp0xd13vq8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val reverse = List.reverse(q)\n        var sum = 0\n        var num =\
    \ 0\n        for( i <- 1 to reverse.length ){\n            sum = sum + reverse(i)\n\
    \            num = num + 1\n        }\n        if( (reverse.length == 0) || (sum\
    \ == 0) ){\n            return false\n        }\n        val x = reverse(0)\n\
    \        var y = reverse(0)\n        for( i <- 1 to reverse.length ){\n      \
    \      y = y + (reverse(i) / num) * (x/y)\n        }\n        val z = reverse(0)\n\
    \        if(z > w){\n            return true\n        }\n        return false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzp0zyj_2.scala:20:27 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mreverse\e[0m = List.reverse(q)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \ value reverse is not a member of object scala.collection.immutable.List\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val max = List(0l).zip(q.takeWhile(!_.isZero)).reduce(_ + _)\n      \
    \  if (q.forall(_.isZero) || q.forall(_.isEven) && max <= w) true else false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp54i64oue.scala:20:46 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = List(\e[31m0l\e\
    [0m).zip(q.takeWhile(!_.isZero)).reduce(_ + _)\n\e[31m\e[31m   |\e[0m        \
    \                                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                          value isZero is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp54i64oue.scala:20:64 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = List(\e[31m0l\e\
    [0m).zip(q.takeWhile(!_.isZero)).reduce(_ + _)\n\e[31m\e[31m   |\e[0m        \
    \                                                      ^^^\e[0m\n\e[31m   |\e\
    [0mvalue + is not a member of (Long, Long), but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp54i64oue.scala:21:23\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (q.forall(_.isZero)\
    \ || q.forall(_.isEven) && max <= w) \e[31mtrue\e[0m \e[33melse\e[0m \e[31mfalse\e\
    [0m\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                     value isZero is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp54i64oue.scala:21:45 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (q.forall(_.isZero) || q.forall(_.isEven)\
    \ && max <= w) \e[31mtrue\e[0m \e[33melse\e[0m \e[31mfalse\e[0m\n\e[31m\e[31m\
    \   |\e[0m                                           ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                    value isEven is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp54i64oue.scala:21:60 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (q.forall(_.isZero) || q.forall(_.isEven)\
    \ && max <= w) \e[31mtrue\e[0m \e[33melse\e"
  stdout: ''
  timestamp: 1660010585
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var maxW = 0\n        var q = q.asInstanceOf[List[Long]]\n        var\
    \ wSum : Long = 0\n        var isBalanced : Boolean = true\n        while (!q.isEmpty\
    \ && q.length != maxW) {\n            if (maxW == 0) maxW = q.length\n       \
    \     wSum += q(0)\n            q = q.tail\n        }\n        if (q.length ==\
    \ maxW && maxW == w) {\n            isBalanced = true\n        } else if (q.length\
    \ == maxW) {\n            isBalanced = false\n        } else if (wSum == 0 ||\
    \ wSum > maxW) {\n            isBalanced = false\n        } else {\n         \
    \   isBalanced = true\n        }\n        return isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp22h41ahu.scala:21:16 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mq\e[0m = q.asInstanceOf[\e\
    [35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\
    \e[31m   |\e[0m                Recursive \e[33mvariable\e[0m \e[35mq\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010577
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q.tail.isEmpty && (q.isEmpty || w<=q.head || w>q.last)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn9dd43pm.scala:23)\n\tat Problem.main(tmpn9dd43pm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010585
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val reverse = q.asInstanceOf[mutable.Stack[Long]].toList.reverse\n  \
    \      if(reverse.last.isDefined && w <= reverse.last.get) {\n            true\n\
    \        } else if(q.size == 1) {\n            true\n        } else if(q.size\
    \ > 1 && reverse.last.isDefined && reverse.last.get.asInstanceOf[Long] <= w) {\n\
    \            true\n        } else {\n            false\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsi3kvdyx.scala:20:37 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mreverse\e[0m = q.asInstanceOf[mutable.Stack[\e\
    [35mLong\e[0m]].toList.reverse\n\e[31m\e[31m   |\e[0m                        \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val reverse = q.reverse.map(x => x.toLong)\n        val sumOfElements\
    \ = reverse.foldLeft(0)(_ + _)\n        sumOfElements <= w\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpknuj53ku.scala:21:48\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = reverse.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m           \
    \                                     ^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                                    Found:    Long\n\e[31m   |\e[0m         \
    \                                       Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010588
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val n = q.length\n        val l = q.map(x => math.abs(x)).reduce(_ +\
    \ _)\n        if (l == 0) true\n        else if (math.abs(w) < l) false\n    \
    \    else willItFly(q.tail, w)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.reduceLeft\n\tat scala.collection.IterableOnceOps.reduceLeft(IterableOnce.scala:727)\n\
    \tat scala.collection.IterableOnceOps.reduceLeft$(IterableOnce.scala:724)\n\t\
    at scala.collection.AbstractIterable.reduceLeft(Iterable.scala:926)\n\tat scala.collection.IterableOnceOps.reduce(IterableOnce.scala:698)\n\
    \tat scala.collection.IterableOnceOps.reduce$(IterableOnce.scala:698)\n\tat scala.collection.AbstractIterable.reduce(Iterable.scala:926)\n\
    \tat Problem$.willItFly(tmp08ppsnp5.scala:21)\n\tat Problem$.main(tmp08ppsnp5.scala:27)\n\
    \tat Problem.main(tmp08ppsnp5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010593
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Check balance\n        val p = q.reverse\n        var bal = true\n\
    \        p foreach { n =>\n            if (n > w) bal = false\n        }\n   \
    \     (bal && p.length == q.length)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyl67yd9i.scala:30)\n\tat Problem.main(tmpyl67yd9i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010595
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        q.reverse.forall(_ <=w)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkm4cf73p.scala:25)\n\tat Problem.main(tmpkm4cf73p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010596
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxW : Long = w.toLong\n\n        q.isEmpty || {\n            val\
    \ p = q.reverse\n            val pS = p.sum\n            val maxP = p.max\n\n\
    \            maxP >= maxW && pS == p.reverse.sum\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvjkel4w9.scala:31)\n\tat Problem.main(tmpvjkel4w9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val sumQ = q.foldLeft(0)(_ + _)\n \
    \       sumQ <= maxWeight && isPalindrome(q)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzist9jm4.scala:21:33\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msumQ\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                                 Found:\
    \    Long\n\e[31m   |\e[0m                                 Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzist9jm4.scala:22:29 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        sumQ <= maxWeight && isPalindrome(q)\n\e[31m\e\
    [31m   |\e[0m                             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                            Not found: isPalindrome\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010595
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \      q.reverse.forall(x => x<w)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8xc0_7bx.scala:24)\n\tat Problem.main(tmp8xc0_7bx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010598
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Complete the function\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7cfu2zy7.scala:19:56\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mwillItFly\e\
    [0m(\e[36mq\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mw\e[0m : \e[35mLong\e\
    [0m) : \e[35mBoolean\e[0m = {\n\e[31m\e[31m   |\e[0m                         \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                                 Found:    Unit\n\e[31m   |\e[0m            \
    \                                           Required: Boolean\n\e[31m20 |\e[0m\
    \        \e[34m// Complete the function\e[0m\n\e[31m21 |\e[0m    }\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010595
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var maxWeight = w\n        var balanced = true\n        var listPalindromic\
    \ = q.reverse.equals(q) //to check if the list is palindromic or not\n       \
    \ var sum = 0\n        var wSum = 0\n\n        if (listPalindromic) {\n      \
    \      sum = 0\n            for (i <- 0 until q.size) {\n                sum =\
    \ sum + q(i)\n            }\n            if (sum < w) {\n                sum =\
    \ 0\n            } else {\n                sum -= w\n            }\n         \
    \   if (sum < 0) {\n                balanced = false\n            }\n        }\n\
    \n        if (!listPalindromic) {\n            listPalindromic = (q.head == q.last)\n\
    \        }\n\n        if ((!listPalindromic) && balanced) {\n            maxWeight\
    \ = w\n            sum = 0\n            wSum = 0\n            balanced = false\n\
    \            for (i <- 0 until q.size) {\n                sum = sum + q(i)\n \
    \               wSum = wSum + q(i)\n            }\n            if (sum < w) {\n\
    \                sum = 0\n            } else {\n                sum -= w\n   \
    \         }\n            if (sum < 0) {\n                balanced = false\n  \
    \          }\n        }\n\n        if (listPalindromic && balanced && sum < w)\
    \ {\n            balanced = false\n        }\n        if (listPalindromic && balanced\
    \ && sum > w) {\n            balanced = false\n        }\n\n        if (listPalindromic\
    \ && balanced && sum == w) {\n            balanced = false\n        }\n\n    \
    \    if (!listPalindromic && !balanced) {\n            maxWeight = w\n       \
    \     sum = 0\n            wSum = 0\n            for (i <- 0 until q.size) {\n\
    \                sum = sum + q(i)\n                wSum = wSum + q(i)\n      \
    \      }\n            if (sum < w) {\n                sum = 0\n            } else\
    \ {\n                sum -= w\n            }\n            if (sum < 0) {\n   \
    \             balanced = false\n            }\n        }\n\n        return balanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfjw58dnt.scala:29:22\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                sum = sum + q(i)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                    Found:    Long\n\e[31m   |\e[0m                      Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfjw58dnt.scala:34:20\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                sum -= w\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \    value -= is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpfjw58dnt.scala:51:22 --------------------\e[0m\e\
    [0m\n\e[31m51 |\e[0m                sum = sum + q(i)\n\e[31m\e[31m   |\e[0m  \
    \                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      Found:\
    \    Long\n\e[31m   |\e[0m                      Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfjw58dnt.scala:52:23 --------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m                wSum = wSum + q(i)\n\e[31m\e[31m   |\e\
    [0m                       ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \     Found:    Long\n\e[31m   |\e[0m                       Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfjw58dnt.scala:57:20\
    \ ------------------------\e[0m\e[0m\n\e[31m57 |\e[0m                sum -= w\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \    value -= is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpfjw58dnt.scala:80:22 --------------------\e[0m\e\
    [0m\n\e[31m80 |\e[0m                sum = sum + q(i)\n\e[31m\e[31m   |\e[0m  \
    \                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      Found:\
    \    Long\n\e[31m   |\e[0m                      Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation ava"
  stdout: ''
  timestamp: 1660010601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val result = true\n        var w1 = w\n        var w2 = w\n\n       \
    \ q.foreach { x =>\n            if (w1 < x)\n                result = false\n\
    \            w1 = x\n        }\n\n        // we already tested if the list is\
    \ balanced, so we know w2 = w1 - 1\n        val x = q.last\n        w2 = w1 -\
    \ 1\n\n        if (w2 == x)\n            result = true\n\n        result\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp6588gmb9.scala:26:23 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                result = \e[31mfalse\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Reassignment to val result\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp6588gmb9.scala:35:19 -----------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m            result = \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val result\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010590
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val totalSum : Long = q.reduceLeftOption( _ +  _ ).map(_.toLong).getOrElse(0l)\n\
    \        val totalWeight = totalSum * w\n        if(totalWeight <= 1L) {\n   \
    \         return false\n        }\n        val max = totalWeight % maxPossibleWeight\n\
    \        val min = 1L / maxPossibleWeight\n        if(totalSum > max) {\n    \
    \        return false\n        }\n        val factorizable = totalWeight % maxPossibleWeight\
    \ != 0\n        if(factorizable) {\n            val f = maxPossibleWeight / max\n\
    \            val remainder = totalWeight % f\n            val leftSide = q.head\n\
    \            val rightSide = q.reverse.head\n            val factor = isPalindrome(leftSide)\
    \ * isPalindrome(rightSide)\n            if(factor != factorizable) {\n      \
    \          return false\n            }\n        }\n        if(totalSum < min)\
    \ {\n            return false\n        }\n        true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv_dmyx83.scala:25:32 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = totalWeight %\
    \ maxPossibleWeight\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: maxPossibleWeight\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv_dmyx83.scala:26:23\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mmin\e[0m = \e[31m1L\e[0m / maxPossibleWeight\n\e[31m\e[31m   |\e[0m      \
    \                 ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \   Not found: maxPossibleWeight\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpv_dmyx83.scala:30:41 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mfactorizable\e[0m = totalWeight % maxPossibleWeight\
    \ != \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                                     \
    \    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \        Not found: maxPossibleWeight\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpv_dmyx83.scala:32:20 ------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mf\e[0m = maxPossibleWeight\
    \ / max\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: maxPossibleWeight\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpv_dmyx83.scala:36:25 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mfactor\e[0m = isPalindrome(leftSide)\
    \ * isPalindrome(rightSide)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: isPalindrome\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling w"
  stdout: ''
  timestamp: 1660010591
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.isEmpty || q.length <= 0 || w <= 0) {\n            false\n    \
    \    }\n        else {\n            if (q.length % 2 == 0) {\n               \
    \ // odd\n                var maxWeight = w\n                for (i <- 0 until\
    \ q.length / 2) {\n                    if (q(i) > maxWeight) {\n             \
    \           maxWeight = q(i)\n                    }\n                }\n     \
    \           val sum = maxWeight + q(q.length / 2)\n                if (sum < w)\
    \ {\n                    false\n                }\n                else {\n  \
    \                  if (sum == w) {\n                        true\n           \
    \         }\n                }\n            }\n            else {\n          \
    \      // even\n                var maxWeight = w\n                var sum = 0\n\
    \                for (i <- 0 until q.length) {\n                    sum += q(i)\n\
    \                    if (sum > maxWeight) {\n                        maxWeight\
    \ = sum\n                    }\n                }\n                if (maxWeight\
    \ <= w) {\n                    true\n                }\n                else {\n\
    \                    false\n                }\n            }\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsyv_9bj4.scala:37:20\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m                    \e[33mif\e\
    [0m (sum == w) {\n\e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e\
    [0m                 Found:    Unit\n\e[31m   |\e[0m                 Required:\
    \ Boolean\n\e[31m   |\e[0m                 Maybe you are missing an else part\
    \ for the conditional?\n\e[31m38 |\e[0m                        \e[31mtrue\e[0m\n\
    \e[31m39 |\e[0m                    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpsyv_9bj4.scala:47:24 ------------------------\e[0m\e\
    [0m\n\e[31m47 |\e[0m                    sum += q(i)\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^\e[0m\n\e[31m   |\e[0m                  value += is not\
    \ a member of Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010598
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Solution below\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyuybvzdw.scala:19:56\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mwillItFly\e\
    [0m(\e[36mq\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mw\e[0m : \e[35mLong\e\
    [0m) : \e[35mBoolean\e[0m = {\n\e[31m\e[31m   |\e[0m                         \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                                 Found:    Unit\n\e[31m   |\e[0m            \
    \                                           Required: Boolean\n\e[31m20 |\e[0m\
    \        \e[34m// Solution below\e[0m\n\e[31m21 |\e[0m    }\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010596
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val max = scala.math.max(w, q.sum.toLong)\n        val balance = q.toList.foldLeft(0)((x,\
    \ y) => (x + y) % max != 0)\n        if (balance) {\n            (q.toList ==\
    \ q.reverse.reverse)\n        } else {\n            (q.toList.length == (max -\
    \ q.sum))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1c_uh5jn.scala:21:53\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbalance\e\
    [0m = q.toList.foldLeft(\e[31m0\e[0m)((\e[36mx\e[0m, \e[36my\e[0m) => (x + y)\
    \ % max != \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                              \
    \                       ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                                        Found:    Boolean\n\e[31m   |\e[0m  \
    \                                                   Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1c_uh5jn.scala:22:12 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (balance) {\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (balance : Int)\n\
    \e[31m   |\e[0m            Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val fly = false\n        var q = List(q)\n        var i = 0\n       \
    \ var maxWeight = w\n        while(i < q.size) {\n            if(q(i + 1) > q(i))\
    \ {\n                maxWeight = q(i)\n            }\n            i += 1\n   \
    \     }\n        while(i < q.size) {\n            if(!q(i).equals(q(i + 1))) {\n\
    \                fly = true\n                break\n            }\n          \
    \  i += 1\n        }\n        if(fly) {\n            true\n        } else {\n\
    \            val sum = 0\n            for(i <- 0 until q.size) {\n           \
    \     sum += q(i)\n            }\n            sum <= maxWeight\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfecm0kae.scala:21:21 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mq\e[0m = List(q)\n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ Recursive \e[33mvariable\e[0m \e[35mq\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpfecm0kae.scala:25:24 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mif\e[0m(q(i + \e[31m1\e[0m) > q(i))\
    \ {\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \           value > is not a member of Nothing\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpfecm0kae.scala:32:20 -----------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m                fly = \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m         \
    \       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val fly\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfecm0kae.scala:33:16\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfecm0kae.scala:42:20\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                sum += q(i)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \    value += is not a member of Int - did you mean sum.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1660010600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(ls: List[Long]) : Boolean = ls.head == ls.last // check\
    \ whether it is a palindrome\n        def sumOfElements(ls: List[Long]) : Long\
    \ = ls map (_.toLong) reduceLeft (_ + _) // sum of all the elements\n        def\
    \ calculateMaxPossibleWeight(balancedLs: List[Long]) : Long = // max possible\
    \ weight\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7fzj7n7d.scala:22:71 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mdef\e[0m \e[36mcalculateMaxPossibleWeight\e\
    [0m(\e[36mbalancedLs\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mLong\e[0m\
    \ = \e[34m// max possible weight\e[0m\n\e[31m\e[31m   |\e[0m                 \
    \                                                      ^\e[0m\n\e[31m   |\e[0m\
    \                                       expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7fzj7n7d.scala:23:5\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.isEmpty) true\n        else {\n            var sum = 0L\n     \
    \       var maxWeight = 0L\n            val tempList = q.tail\n            var\
    \ maxSum = 0L\n            val maxSumIndex = 0\n            q.headOption match\
    \ {\n                case Some(x) => sum += x\n                case None => return\
    \ false\n            }\n            for (x <- tempList) {\n                sum\
    \ += x\n                if (sum > maxWeight) {\n                    maxSum = sum\n\
    \                    maxSumIndex = tempList.indexWhere(_ == x)\n             \
    \   }\n                if (sum >= w && maxSum < w) {\n                    return\
    \ true\n                }\n            }\n            false\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp7uvds29l.scala:35:32 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    maxSumIndex = tempList.indexWhere(_\
    \ == x)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Reassignment to val maxSumIndex\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010597
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        val maxSum = w.fold(math.Long.MinValue)((a,\
    \ b) => math.max(a, b))\n        val numElements = q.size\n        val numPairs\
    \ = q.size / 2\n        val maxWeight = w.max\n        val maxCount = (numElements\
    \ - numPairs) / 2\n\n        if (numPairs < 1 || numElements <= numPairs) {\n\
    \            false\n        }\n        else if (q.size % 2 == 0) {\n         \
    \   if (maxSum == 0) {\n                true\n            }\n            else\
    \ if (maxSum - q.tail.sum == 0l) {\n                true\n            }\n    \
    \        else {\n                false\n            }\n        }\n        else\
    \ {\n            if (maxCount != (q.size / 2)) {\n                false\n    \
    \        }\n            else if (maxWeight < w || maxSum == 0) {\n           \
    \     true\n            }\n            else if (maxSum - q.tail.sum == 0l) {\n\
    \                true\n            }\n            else {\n                false\n\
    \            }\n        }\n\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp57p4g3n3.scala:21:23 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e[0m = w.fold(math.Long.MinValue)((\e\
    [36ma\e[0m, \e[36mb\e[0m) => math.max(a, b))\n\e[31m\e[31m   |\e[0m          \
    \           ^^^^^^\e[0m\n\e[31m   |\e[0m                     value fold is not\
    \ a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp57p4g3n3.scala:21:33\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxSum\e[0m = w.fold(math.Long.MinValue)((\e[36ma\e[0m, \e[36mb\e[0m) => math.max(a,\
    \ b))\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            value Long is not a member of math\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp57p4g3n3.scala:45:31 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (maxWeight\
    \ < w || maxSum == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                    \
    \ ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of Long => Long, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010605
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maximumWeight = w + 1l\n        if (q.isEmpty) true\n        else\
    \ if(q.head <= maximumWeight && q.reverse.tail.isEmpty) true\n        else false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4dyk2t6m.scala:26)\n\tat Problem.main(tmp4dyk2t6m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010606
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxW = Math.max(w, q.sum)\n        if (maxW <= 0) false\n       \
    \ else {\n            val reversed = List(q.reversed)\n            val allEven\
    \ = reverse(List(reversed.takeWhile(!_ % 2).toList)).length == 1\n           \
    \ val allOdd = reverse(List(reversed.takeWhile(!_ % 2).toList)).length == 0\n\
    \            (reversed == List(q.reversed) && allEven && allOdd) || maxW < q.sum\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpkra2fxpo.scala:23:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mreversed\e[0m = List(q.reversed)\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m\e[33mmethod\e[0m \e[35mreversed\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m cannot be accessed as a member of (q : List[Long]) from module class Problem$.\n\
    \e[31m   |\e[0m Access to protected \e[33mmethod\e[0m \e[35mreversed\e[0m not\
    \ permitted because enclosing \e[33mobject\e[0m \e[35mProblem\e[0m\n\e[31m   |\e\
    [0m is not a subclass of \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.collection\e[0m where target is defined\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpkra2fxpo.scala:24:26 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mallEven\e[0m = reverse(List(reversed.takeWhile(!_\
    \ % \e[31m2\e[0m).toList)).length == \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m     \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not\
    \ found: reverse\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkra2fxpo.scala:24:58\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m\
    \ \e[36mallEven\e[0m = reverse(List(reversed.takeWhile(!_ % \e[31m2\e[0m).toList)).length\
    \ == \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                     \
    \                     ^^\e[0m\n\e[31m   |\e[0m                               \
    \ value unary_! is not a member of Nothing\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpkra2fxpo.scala:25:25 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m            \e[33mval\e[0m \e[36mallOdd\e[0m = reverse(List(reversed.takeWhile(!_\
    \ % \e[31m2\e[0m).toList)).length == \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m     \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not\
    \ found: reverse\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkra2fxpo.scala:25:57\
    \ ---------------------"
  stdout: ''
  timestamp: 1660010606
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q.reverse.foldLeft(false)((acc, x) => acc || (x == w.reverse) && (q.sum\
    \ < w))\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_6t5_37w.scala:20:61 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        q.reverse.foldLeft(\e[31mfalse\e[0m)((\e[36macc\e\
    [0m, \e[36mx\e[0m) => acc || (x == w.reverse) && (q.sum < w))\n\e[31m\e[31m  \
    \ |\e[0m                                                           ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value reverse is not a\
    \ member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010605
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def balanced(i : Int, j : Int) = {\n            val q = q.take(i)\n \
    \           val l = q.take(j)\n            q.take(j - i) sameElements l\n    \
    \    }\n        // Base case\n        if (q.isEmpty) false\n        else {\n \
    \           // We only care about the first element, no need to check each element\
    \ to see if it will fly.\n            val l = q.head\n            // If l's sum\
    \ isn't within limits, it's unbalanced and it won't fly.\n            if (!(l\
    \ < w) && !balanced(1, l.length)) false\n            else {\n                //\
    \ We need to check the rest of the list to see if it will fly.\n             \
    \   // If so, then return true\n                if (balanced(0, l.length)) true\n\
    \                else false\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpz7ubshmc.scala:21:20 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mq\e[0m = q.take(i)\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mq\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpz7ubshmc.scala:31:43 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mif\e[0m (!(l < w) && !balanced(\e[31m1\e\
    [0m, l.length)) \e[31mfalse\e[0m\n\e[31m\e[31m   |\e[0m                      \
    \                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \         value length is not a member of Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpz7ubshmc.scala:35:34 ------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                \e[33mif\e[0m (balanced(\e[31m0\e[0m, l.length)) \e[31mtrue\e\
    [0m\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                value length is not a member of Long\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010606
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Your code here\n        val maxW: Long = w.toLong\n        q.reverseIterator.forall(x\
    \ => x > maxW)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7ejwf0or.scala:25)\n\tat Problem.main(tmp7ejwf0or.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010609
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var q2 : List[Long] = q.reverse\n        var i = 0\n        var sum =\
    \ 0\n        val max = w\n        while(i < q.size && sum < max) {\n         \
    \   sum += q.apply(i)\n            i += 1\n        }\n        if(q.size == i)\
    \ {\n            (sum == max)\n        } else if(sum > max) {\n            false\n\
    \        } else {\n            willItFly(q2, max)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdyuqt_8i.scala:25:16 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            sum += q.apply(i)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010608
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q match {\n            case Nil => false\n            case l :: tail\
    \ => {\n                if (w < l.sum) false else if (q.isEmpty || q.isDefinedAt(q.length-1))\
    \ true else willItFly(tail, w)\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsg8p6fj_.scala:23:26 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mif\e[0m (w < l.sum) \e[31mfalse\e\
    [0m \e[33melse\e[0m \e[33mif\e[0m (q.isEmpty || q.isDefinedAt(q.length-\e[31m1\e\
    [0m)) \e[31mtrue\e[0m \e[33melse\e[0m willItFly(tail, w)\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        value\
    \ sum is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010610
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var maxWeight = w;\n        var maxCount = q.size;\n        val maxItem\
    \ = q(0);\n        if (maxCount == 0)\n            return true;\n        for (i\
    \ <- 1 to q.size)\n            maxCount += q(i) - maxItem;\n        if (maxCount\
    \ < maxWeight)\n            return false;\n        val q2 = q.map(x => x.toLong);\n\
    \        val rev = q2.reverse;\n        val palindromes = q2.filter(rev);\n  \
    \      val diff = math.min(maxWeight, palindromes.size);\n        var sum = 0L;\n\
    \        var count = 1;\n        for (item <- palindromes)\n            sum +=\
    \ item;\n        val diff = math.min(diff, sum);\n        var last = 0;\n    \
    \    for (i = q2.size - 1 to 0 by -1)\n            if (q2(i) == last && diff >\
    \ w)\n                return false;\n            if (q2(i) == last && diff ==\
    \ w)\n                return true;\n            else\n                last = q2(i);\n\
    \        return false;\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp5a15wsx.scala:39:15 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mfor\e[0m (i = q2.size - \e[31m1\e[0m to\
    \ \e[31m0\e[0m by -\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\
    \e[31m   |\e[0m               ')' expected, but '=' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpp5a15wsx.scala:40:0 ----------------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m            \e[33mif\e[0m (q2(i) == last && diff > w)\n\e\
    [31m\e[31m   |\e[0m^^\e[0m\n\e[31m   |\e[0m'<-' expected, but 'end of statement'\
    \ found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpp5a15wsx.scala:40:42 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mif\e[0m (q2(i) == last && diff > w)\n\
    \e[31m\e[31m   |\e[0m                                          ^\e[0m\n\e[31m\
    \   |\e[0m                                          pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpp5a15wsx.scala:42:43 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mif\e[0m (q2(i) == last && diff == w)\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0m                                           pattern expected\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E020] Syntax Error: /tmp/tmpp5a15wsx.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    \e[33myield\e[0m or \e[33mdo\e[0m expected\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpp5a15wsx.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mdiff\e[0m = math.min(diff,\
    \ sum);\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mdiff is already defined as \e[33mvalue\e[0m \e[35mdiff\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Fou"
  stdout: ''
  timestamp: 1660010613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val q = q.tail.reverse\n        val w = w.toInt\n        val maxW = Math.sqrt(w).toInt\n\
    \        val qS = q.sum\n        val maxW = maxW * maxW\n        var fly = true\n\
    \        q.foreach { x => \n            if (x <= maxW && qS <= w) fly = false\n\
    \            else if (qS == w) fly = true\n            else fly = false\n    \
    \    }\n        fly\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9_a_jhrt.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmaxW\e[0m = maxW * maxW\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxW\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxW\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9_a_jhrt.scala:20:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mq\e[0m = q.tail.reverse\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\
    \e[31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mq\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9_a_jhrt.scala:21:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mw\e[0m = w.toInt\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m\
    \   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mw\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010607
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val palindromic = q.reverse.forall(qe => qe < w)\n        if (palindromic)\
    \ {\n            val totalWeight = q.sum\n            totalWeight <= w\n     \
    \   } else {\n            false\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9_bok23t.scala:30)\n\tat Problem.main(tmp9_bok23t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010620
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Use mutable sets to store all the elements in the list that are less\
    \ than or equal to the maximum possible weight.\n        // This operation is\
    \ O(1).\n        // Keep a Set of all the elements that haven't reached the maximum\
    \ possible weight yet.\n        // This operation is O(n).\n        var elements\
    \ = scala.collection.mutable.Set.empty[Long]\n        for (x<-q) {\n         \
    \   if (x < w) {\n                elements += x\n            }\n        }\n\n\
    \        // Find the maximum possible weight of the set.\n        // This operation\
    \ is O(1).\n        var maxW = 0l\n        for (x<elements) {\n            if\
    \ (x > maxW) {\n                maxW = x\n            }\n        }\n\n       \
    \ // If the maximum possible weight is less than or equal the weight, return true.\n\
    \        return maxW <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp61zmp6fe.scala:34:25 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mfor\e[0m (x<elements) {\n\e[31m\e[31m \
    \  |\e[0m                         ^\e[0m\n\e[31m   |\e[0m                    \
    \     '<-' expected, but '{' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp61zmp6fe.scala:38:9\
    \ -------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        }\n\e[31m\e[31m\
    \   |\e[0m         ^\e[0m\n\e[31m   |\e[0mvalue withFilter is not a member of\
    \ Null, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.set\
    \ asScala\n\e[31m   |\e[0m\n\e[31m39 |\e[0m        \e[34m// If the maximum possible\
    \ weight is less than or equal the weight, return true.\e[0m\n\e[31m40 |\e[0m\
    \        \e[33mreturn\e[0m maxW <= w\n2 errors found\n"
  stdout: ''
  timestamp: 1660010618
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxPossibleWeight = w + q.sum\n        q.isEmpty || \n        q.toList\
    \ == q.reverse.tail &&\n        q.sum >= w &&\n        q.reduceLeft(_ + _) <=\
    \ maxPossibleWeight\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2j3r2op_.scala:27)\n\tat Problem.main(tmp2j3r2op_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010620
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \      val pw = List.reverse(q).map(_.toLong).sum\n      pw <= w && pw.toLong\
    \ == w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm7wjacn3.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m      \e[33mval\e[0m \e[36mpw\e[0m = List.reverse(q).map(_.toLong).sum\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value reverse\
    \ is not a member of object scala.collection.immutable.List\n1 error found\n"
  stdout: ''
  timestamp: 1660010616
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight : Long = w.toLong\n        q.length == 1 && maxWeight <=\
    \ 0\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptc7zcedc.scala:24)\n\tat Problem.main(tmptc7zcedc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010619
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val reverseList = List.reverse(q)\n        val balanced = checkBalance(reverseList,\
    \ w)\n        val sum = reverseList.sum\n        balanced && sum <= w\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq_8n1_g_.scala:20:31 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mreverseList\e[0m = List.reverse(q)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m value reverse is not a member of object scala.collection.immutable.List\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpq_8n1_g_.scala:21:23 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbalanced\e[0m = checkBalance(reverseList,\
    \ w)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                       Not found: checkBalance\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var x = List[Long]()\n        var y = List[Long]()\n        for(q <-\
    \ q.reverse) {\n            if(q.isEmpty) {\n                q.reverse()\n   \
    \             continue\n            }\n            x :+ q(0)\n            y :+\
    \ q(0)\n        }\n        if(x.size == 0 || y.size == 0 || w <= 0 || w > x.head\
    \ || w > y.head) {\n            return false\n        }\n        val a = x.last\n\
    \        val b = y.last\n        val m = (b - a).abs\n        if(m > w || x.head\
    \ % 2 == y.head % 2) {\n            return false\n        }\n        (x.tail,\
    \ y.tail).foldRight(true) {\n            (x: List[Long], y: List[Long]) => if\
    \ (x == y) false else if (x.size == 1 && y.size == 1 && m.toDouble == x.head /\
    \ y.head) true else willItFly(x, w)\n        }(false)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn5halm5z.scala:23:17 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m(q.isEmpty) {\n\e[31m\e[31m\
    \   |\e[0m               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m               value isEmpty\
    \ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn5halm5z.scala:24:18\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                q.reverse()\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \       value reverse is not a member of Long\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpn5halm5z.scala:25:16 ------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                continue\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Not found: continue\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E050] Type Error: /tmp/tmpn5halm5z.scala:27:17 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            x :+ q(\e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m                 ^\e[0m\n\e[31m   |\e[0m                 \e[33mparameter\e\
    [0m \e[35mq\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E050]\
    \ Type Error: /tmp/tmpn5halm5z.scala:28:17 -----------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            y :+ q(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \               ^\e[0m\n\e[31m   |\e[0m                 \e[33mparameter\e[0m \e\
    [35mq\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpn5halm5z.scala:39:25 ------------------------\e[0m\e[0m\n\e[31m39 |\e\
    [0m        (x.tail, y.tail).foldRight(\e[31mtrue\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value foldRight\
    \ is not a member of (List[Long], List[Long])\n6 errors found\n"
  stdout: ''
  timestamp: 1660010620
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sumList = q.foldLeft(0l) { (x,y) => (x + y) % w == 0 }\n        sumList\
    \ == 0 || sumList == w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt1i6wll0.scala:20:48\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36msumList\e\
    [0m = q.foldLeft(\e[31m0l\e[0m) { (\e[36mx\e[0m,\e[36my\e[0m) => (x + y) % w ==\
    \ \e[31m0\e[0m }\n\e[31m\e[31m   |\e[0m                                      \
    \          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \                    Found:    Boolean\n\e[31m   |\e[0m                      \
    \                          Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var max = 0L\n        var sum = 0L\n        var fly = false\n       \
    \ var i = q.size-1\n        // go through list\n        while (i >= 0) {\n   \
    \         // if the current weight is more than the maximum,\n            if (q(i)\
    \ > max)\n                // set max weight and reset sum to zero.\n         \
    \       max = q(i)\n                sum = 0L\n            // add the weight to\
    \ the sum\n            sum += q(i)\n            // if sum is equal to the weight,\
    \ it's balanced\n            if (sum == w) {\n                fly = true\n   \
    \             break\n            }\n            // if sum is greater than the\
    \ maximum, it's unbalanced\n            if (sum > max) {\n                fly\
    \ = false\n                break\n            }\n            // go back one and\
    \ decrement the sum\n            i -= 1\n        }\n        return fly\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp82tnpkqv.scala:36:16 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp82tnpkqv.scala:41:16 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var b : Boolean = true\n        val l = q.reverse\n        val l = l.takeWhile(_\
    \ < w)\n        if (l.length == 1) {\n            b = false\n        }\n     \
    \   if (l.length == q.size) {\n            val l = q.reverse\n            val\
    \ l = l.takeWhile(_ >= w)\n            if (l.length == 0) {\n                b\
    \ = false\n            }\n        }\n        b\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzpldl093.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = l.takeWhile(_ <\
    \ w)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzpldl093.scala:28:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e\
    [0m \e[36ml\e[0m = l.takeWhile(_ >= w)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1660010614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Code here\n        val list = q.sortWith((x, y) => x-y)\n        if\
    \ (list.length < 1) true\n        else {\n            var sum = 0L\n         \
    \   var maximum = 0L\n            list.foreach {\n                if (sum+_ >\
    \ maximum) maximum = sum+_\n                sum += _\n            }\n        \
    \    list.length == maximum && (sum <= w)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2l2j5up7.scala:21:40\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlist\e\
    [0m = q.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x-y)\n\e[31m\e[31m   |\e[0m \
    \                                       ^^^\e[0m\n\e[31m   |\e[0m            \
    \                            Found:    Long\n\e[31m   |\e[0m                 \
    \                       Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmp2l2j5up7.scala:27:24 -----------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m                \e[33mif\e[0m (sum+_ > maximum) maximum =\
    \ sum+_\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m\
    \   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 =>\
    \ sum + _$1 > maximum.\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp2l2j5up7.scala:27:51\
    \ -----------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                \e[33mif\e\
    [0m (sum+_ > maximum) maximum = sum+_\n\e[31m\e[31m   |\e[0m                 \
    \                                  ^\e[0m\n\e[31m   |\e[0m   Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => sum + _$2.\n3 errors found\n"
  stdout: ''
  timestamp: 1660010621
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Initialize maxWeight as the maximum possible weight.\n        var\
    \ maxWeight = w\n        for (i <- 0 until q.size) {\n            // Get the current\
    \ balance, and if it's more than maxWeight, set maxWeight to the current balance\
    \ (and break the loop).\n            val balance = q.iterator.scanLeft(0){case\
    \ (sum, e) => if (e > maxWeight) sum + e else sum}.sum\n            if (balance\
    \ > maxWeight) maxWeight = balance else false\n        }\n        // Return true\
    \ if the object q will fly, and false otherwise.\n        q.forall(e => e <= maxWeight)\
    \ && q.size == q.reverse.size && q.reverse.toSet == q.toSet\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_lwjxbaf.scala:24:85\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e\
    [36mbalance\e[0m = q.iterator.scanLeft(\e[31m0\e[0m){\e[33mcase\e[0m (sum, e)\
    \ => \e[33mif\e[0m (e > maxWeight) sum + e \e[33melse\e[0m sum}.sum\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                                Found:    Long\n\e[31m   |\e[0m             \
    \                                             Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010622
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val l = new ListBuffer[Long]()\n        val m = new mutable.ListBuffer[Long]()\n\
    \        q.foreach(x => l += x)\n        l.sorted.reverse.foreach(x => m += x)\n\
    \        m.sorted.toList == l.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn2tkb20p.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m               \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010617
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.isEmpty) return false\n        val wSum = w.toInt\n        val\
    \ pal = q.reverse\n        val sum = pal.sum\n        return sum >= wSum\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcv5a2lql.scala:27)\n\tat Problem.main(tmpcv5a2lql.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWght = if (w.isInstanceOf[Int]) w else 0\n        var balanced\
    \ = true\n        var sum = 0\n        q.foreach {x => sum = sum + x; balanced\
    \ = balance && sum >= maxWght}\n        balanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb4097d4u.scala:23:30\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        q.foreach {\e[36mx\e\
    [0m => sum = sum + x; balanced = balance && sum >= maxWght}\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \               Found:    Long\n\e[31m   |\e[0m                              Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb4097d4u.scala:23:50\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        q.foreach {\e[36mx\e\
    [0m => sum = sum + x; balanced = balance && sum >= maxWght}\n\e[31m\e[31m   |\e\
    [0m                                                  ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                                  Not found: balance\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        //TODO: implement\n        //TODO: compare the sum of the elements of\
    \ the list q to w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyxmt5nmq.scala:19:56\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mwillItFly\e\
    [0m(\e[36mq\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mw\e[0m : \e[35mLong\e\
    [0m) : \e[35mBoolean\e[0m = {\n\e[31m\e[31m   |\e[0m                         \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                                 Found:    Unit\n\e[31m   |\e[0m            \
    \                                           Required: Boolean\n\e[31m20 |\e[0m\
    \        \e[34m//TODO: implement\e[0m\n\e[31m21 |\e[0m        \e[34m//TODO: compare\
    \ the sum of the elements of the list q to w\e[0m\n\e[31m22 |\e[0m    }\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight : Long = w\n        val minWeight : Long = 0\n        var\
    \ i = 0\n        val qList = (q.toIterator.mkString)\n        while (qList.substring(i,\
    \ i + 1).size != 0) {\n            val j = i + 1\n            val k = 0\n    \
    \        while (qList.substring(j, j + 1).size != 0) {\n                val l\
    \ = j + 1\n                if (qList.substring(l, l + 1).size > 0) {\n       \
    \             if (minWeight > 0) minWeight = qList.substring(l, l + 1).sum\n \
    \               }\n                k += 1\n                l += 1\n          \
    \  }\n            i += 1\n        }\n        if (qList.substring(i, i + 1).size\
    \ == 0 && minWeight > 0 && maxWeight > 0) return true\n        else if (qList.substring(i,\
    \ i + 1).size > 0 && minWeight > 0 && maxWeight < minWeight) return true\n   \
    \     else if (qList.substring(i, i + 1).size < 0 && minWeight < 0 && maxWeight\
    \ < minWeight) return true\n        else return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpps8fzv9b.scala:30:49 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    \e[33mif\e[0m (minWeight > \e[31m0\e\
    [0m) minWeight = qList.substring(l, l + \e[31m1\e[0m).sum\n\e[31m\e[31m   |\e\
    [0m                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Reassignment to val\
    \ minWeight\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpps8fzv9b.scala:32:18\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m                k += \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m         \
    \       value += is not a member of Int - did you mean k.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpps8fzv9b.scala:33:18 ------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m                l += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m \
    \               ^^^^\e[0m\n\e[31m   |\e[0m                value += is not a member\
    \ of Int - did you mean l.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val palindromic = q\n        val sum = 0l\n        val weightSum = List(0.toLong,\
    \ w.toLong).sum\n\n        palindromic.reverse.foreach { x => sum = sum + x }\n\
    \n        (sum <= weightSum) && (palindromic.length <= weightSum)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpcb9zb_kh.scala:24:47 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        palindromic.reverse.foreach { \e[36mx\e[0m =>\
    \ sum = sum + x }\n\e[31m\e[31m   |\e[0m                                     \
    \      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \        Reassignment to val sum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010622
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // TODO: Write the function\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpad8fosn4.scala:19:56\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mwillItFly\e\
    [0m(\e[36mq\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mw\e[0m : \e[35mLong\e\
    [0m) : \e[35mBoolean\e[0m = {\n\e[31m\e[31m   |\e[0m                         \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                                 Found:    Unit\n\e[31m   |\e[0m            \
    \                                           Required: Boolean\n\e[31m20 |\e[0m\
    \        \e[34m// TODO: Write the function\e[0m\n\e[31m21 |\e[0m    }\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010626
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.isEmpty) false\n        else if (q.tail.isEmpty) false\n      \
    \  else {\n            val sumOfWeight = q.tail.foldLeft(0l) { (totalWeight, curWeight)\
    \ =>\n                totalWeight + curWeight\n            }\n            if (sumOfWeight\
    \ > w) true\n            else willItFly(q.tail, w)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd0wiaw3t.scala:31)\n\tat Problem.main(tmpd0wiaw3t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w\n        var sum = 0l\n        val palindromic = q.palindrome\n\
    \        palindromic.reverseIterator.foreach {\n            n => sum += n\n  \
    \      }\n        sum < maxSum && palindromic.isEmpty\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpby50l_1t.scala:22:28 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = q.palindrome\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value palindrome is not a member of List[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010628
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Your code goes here.\n        val maxSum : Long = w.toLong\n     \
    \   q.isEmpty || q.toString.reverse.tail.forall( l => l < w && l <= maxSum )\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp055bdnc7.scala:25)\n\tat Problem.main(tmp055bdnc7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010633
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // TODO - your code here\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa9tq8kce.scala:19:56\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mwillItFly\e\
    [0m(\e[36mq\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mw\e[0m : \e[35mLong\e\
    [0m) : \e[35mBoolean\e[0m = {\n\e[31m\e[31m   |\e[0m                         \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                                 Found:    Unit\n\e[31m   |\e[0m            \
    \                                           Required: Boolean\n\e[31m20 |\e[0m\
    \        \e[34m// TODO - your code here\e[0m\n\e[31m21 |\e[0m    }\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // TODO: Write a recursive function\n        def balance(li : List[Long])\
    \ : Boolean = {\n            val l = li.toSet\n            l.length == 1 && l(0)\
    \ == l(1)\n        }\n\n        val n = q.length\n        val max = BigInt(w).pow(n.toDouble)\n\
    \        for( i <- 0 until n ) {\n            if( q(i).toString != q(n-i).toString\
    \ && q(i).toDouble < max ) {\n                return false\n            }\n  \
    \      }\n\n        balance(q) && q.length < max\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvhlmlg40.scala:23:14 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            l.length == \e[31m1\e[0m && l(\e[31m0\e[0m)\
    \ == l(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m            value length is not a member of Set[Long]\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpvhlmlg40.scala:27:34 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = BigInt(w).pow(n.toDouble)\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                Found:    Double\n\e[31m   |\e[0m   \
    \                             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmpvhlmlg40.scala:29:66 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m( q(i).toString != q(n-i).toString\
    \ && q(i).toDouble < max ) {\n\e[31m\e[31m   |\e[0m                          \
    \                          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m<\e[0m in \e[33mclass\e[0m \e[35mDouble\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float):\
    \ Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\
    \e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m\
    \   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments ((max : BigInt))\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010636
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val palindromic = p.forall(q.size == q.size)\n        val elementSumLessOrEqualToWayWeight\
    \ = q.zip(q.tail).map { case (e, i) => e + i } <= w\n        val balanced = palindromic\
    \ && elementSumLessOrEqualToWayWeight\n        !balanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq626up77.scala:20:26 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = p.forall(q.size\
    \ == q.size)\n\e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m  \
    \ |\e[0m                          Not found: p\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpq626up77.scala:21:90 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36melementSumLessOrEqualToWayWeight\e\
    [0m = q.zip(q.tail).map { \e[33mcase\e[0m (e, i) => e + i } <= w\n\e[31m\e[31m\
    \   |\e[0m                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue <= is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e\
    [0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010635
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \      def sum(a : Long) : Long = a.reduceLeft(_ + _)\n      val l = q.length\n\
    \      if (l == 0) true\n      else if (l == 1) true\n      else {\n        val\
    \ maxWeight = w / (l / 2)\n        val maxSum = sum(q(0) + q(l)) - w\n       \
    \ val maxSumAbs = math.abs(maxSum)\n        val maxSumAbsDiff = math.abs(maxSumAbs\
    \ - maxWeight)\n        val maxSumAbsDiff <= maxWeight -> maxSumAbsDiff\n    \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptj83lwf7.scala:30:6 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m      }\n\e[31m\e[31m   |\e[0m      ^\e[0m\n\e[31m  \
    \ |\e[0m      '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmptj83lwf7.scala:20:35 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m      \e[33mdef\e[0m \e[36msum\e[0m(\e[36ma\e[0m : \e[35mLong\e[0m) : \e[35mLong\e\
    [0m = a.reduceLeft(_ + _)\n\e[31m\e[31m   |\e[0m                             \
    \    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                value reduceLeft\
    \ is not a member of Long\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptj83lwf7.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ maxSumAbsDiff <= maxWeight -> maxSumAbsDiff\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxSumAbsDiff is already defined as \e\
    [33mvalue\e[0m \e[35mmaxSumAbsDiff\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptj83lwf7.scala:29:29 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m maxSumAbsDiff <= maxWeight ->\
    \ maxSumAbsDiff\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeight is already defined as \e[33mvalue\e[0m \e[35mmaxWeight\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmptj83lwf7.scala:29:26 ------------------------\e[0m\e[0m\n\
    \e[31m29 |\e[0m        \e[33mval\e[0m maxSumAbsDiff <= maxWeight -> maxSumAbsDiff\n\
    \e[31m\e[31m   |\e[0m                          ^^\e[0m\n\e[31m   |\e[0m      \
    \                    Not found: <=\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E005] Naming Error:\
    \ /tmp/tmptj83lwf7.scala:29:42 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m maxSumAbsDiff <= maxWeight -> maxSumAbsDiff\n\e\
    [31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^\e[0"
  stdout: ''
  timestamp: 1660010638
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toString.toDouble.max // 5l\n        val wSum = q.reduce(_\
    \ + _) // 3+2+3\n        if (wSum == maxSum && q.isEmpty)\n            true\n\
    \        else\n            false\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpgn2_4ucu.scala:22:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (wSum == maxSum && q.isEmpty)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of\
    \ types Long and Double => Double cannot be compared with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1660010636
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val palindromic_q = checkPalindrome(q)\n        val sum_qw = q.sum\n\
    \        val max_weight = math.min(w,sum_qw)\n        (max_weight == sum_qw) &&\
    \ palindromic_q\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjunudfk5.scala:20:28 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mpalindromic_q\e[0m = checkPalindrome(q)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Not found: checkPalindrome\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sumList = q.toList.sum\n        val max = math.max(w, sumList)\n\
    \        (sumList <= max) && (q.isInstanceOf[List[Long]]) && (q.toList.isInstanceOf[ListBuffer[Long]])\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_sbj3z57.scala:25)\n\tat Problem.main(tmp_sbj3z57.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxW = w.toLong.toInt.abs\n        val maxQ = w.fold(0)(_ + _)\n\
    \        val maxQList = if (maxQ.signum == 1) List(maxQ) else List(-maxQ)\n  \
    \      val res = (maxQList.size == q.size) && maxQList.forall(q => q < maxW)\n\
    \        res\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp53122jn2.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxQ\e[0m = w.fold(\e[31m0\e\
    [0m)(_ + _)\n\e[31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                   value fold is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp53122jn2.scala:23:70 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = (maxQList.size ==\
    \ q.size) && maxQList.forall(\e[36mq\e[0m => q < maxW)\n\e[31m\e[31m   |\e[0m\
    \                                                                    ^^^\e[0m\n\
    \e[31m   |\e[0mvalue < is not a member of Nothing, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val reversedList = q.reversed\n        val sumList = reversedList.map(_.toLong).sum\n\
    \        val maxWeight = q.length * w.toLong\n        val isBalanced = sumList\
    \ <= maxWeight\n        isBalanced\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp86ynb5lj.scala:20:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mreversedList\e[0m = q.reversed\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m\e[33mmethod\e[0m \e[35mreversed\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m cannot be accessed as a member of (q : List[Long]) from module class Problem$.\n\
    \e[31m   |\e[0m Access to protected \e[33mmethod\e[0m \e[35mreversed\e[0m not\
    \ permitted because enclosing \e[33mobject\e[0m \e[35mProblem\e[0m\n\e[31m   |\e\
    [0m is not a subclass of \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.collection\e[0m where target is defined\n1 error found\n"
  stdout: ''
  timestamp: 1660010635
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val qSet = q.toSet\n        val qSetSize = qSet.size\n        val listSize\
    \ = q.size\n        val maxWeight = w / 2\n        qSet.isEmpty || qSet.forall(w\
    \ >= _) && qSet.size == listSize && listSize <= maxWeight && ((q.sum.toLong ==\
    \ listSize) || (listSize == maxWeight && (q.sum.toLong == w)))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6ywj7nn_.scala:27)\n\tat Problem.main(tmp6ywj7nn_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // write your solution here\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgc1fm1fq.scala:25)\n\tat Problem.main(tmpgc1fm1fq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010642
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(_.isReverse)\n\
    \        val sum = q.reduceLeft(_ + _)\n\n        if( palindromic && sum < maxWeight\
    \ )\n            true\n        else\n            false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3iiqtvhu.scala:21:45 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = q.reverse.forall(_.isReverse)\n\
    \e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 value isReverse is not a\
    \ member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010639
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val w = q.head\n        val q = q.tail\n        if(q.size == 0) true\n\
    \        else {\n            val max = w / q.head\n            val q = q.reverse\n\
    \            val sum = q.reduce(_ + _)\n            val f = sum < w\n        \
    \    println(s\"${sum} < ${w} : ${f} : ${max}\")\n            f\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdfo8o19g.scala:21:16 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = q.tail\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mq\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpdfo8o19g.scala:25:20 ---------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mq\e[0m = q.reverse\n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    Recursive\
    \ \e[33mvalue\e[0m \e[35mq\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010635
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val list = q.sorted\n        var sum : Long = 0\n        val maxSum =\
    \ 2 * w.toLong\n        for (i <- 0 until list.size) {\n            val left =\
    \ list(i).abs.toLong\n            val right = list(i + 1).abs.toLong\n       \
    \     val left = list(i).abs.toLong\n            val right = list(i + 1).abs.toLong\n\
    \            sum += right\n            if (left < maxSum) sum += left\n      \
    \  }\n        sum == maxSum\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_o44hjma.scala:26:16 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mleft\e[0m = list(i).abs.toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mleft is already defined as \e[33mvalue\e[0m \e[35mleft\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_o44hjma.scala:27:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e\
    [0m \e[36mright\e[0m = list(i + \e[31m1\e[0m).abs.toLong\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mright is\
    \ already defined as \e[33mvalue\e[0m \e[35mright\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1660010638
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def canGoThrough(q1 : List[Long]) : Boolean = {\n            if (q1.isEmpty)\
    \ {\n                true\n            } else {\n                val first = q1.head\n\
    \                if (first == q1.last) canGoThrough(q1.tail) else canGoThrough(q1.tail)\
    \ && q1.head.toLong <= w\n            }\n        }\n        canGoThrough(q) &&\
    \ q.isPalindromic && q.length <= w\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3zl03w4a.scala:28:29 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        canGoThrough(q) && q.isPalindromic && q.length\
    \ <= w\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       value isPalindromic is not a member of List[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010641
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var res : Boolean = true \n        // Write your code here\n        \n\
    \        return res\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprf3mpa6h.scala:27)\n\tat Problem.main(tmprf3mpa6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var l = q.head\n        var h = q.last\n        var l2 = l % 2\n    \
    \    for(i <- 0 until q.size) {\n            var w2 = i.toLong % 2\n         \
    \   if((h / 2) < w2 && l2 == (i.toLong % 2))\n                l = (l+q)(i)\n \
    \           else if((h / 2) < w2 && l2 == (i.toLong % 2) == !(i.toLong % 2))\n\
    \                h = h + q(i)\n            else if((h / 2) < w2 && l2 == (i.toLong\
    \ % 2) == !(i.toLong % 2))\n                h = (h+q(i)) - q(i)\n            else\
    \ if((h / 2) < w2 && l2 == (i.toLong % 2) == !(i.toLong % 2))\n              \
    \  h = h + q(i)\n        }\n        if(w < h && w == l.toLong % 2)\n         \
    \   false\n        else\n            true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpiru5_roo.scala:26:22 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                l = (l+q)(i)\n\e[31m\e[31m   |\e[0m \
    \                    ^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m+\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0m (x: String): String\n\e[31m   |\e[0mmatch arguments ((q : List[Long]))\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiru5_roo.scala:27:60 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m((h / \e[31m2\e\
    [0m) < w2 && l2 == (i.toLong % \e[31m2\e[0m) == !(i.toLong % \e[31m2\e[0m))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \  ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value unary_! is not a member of\
    \ Long - did you mean Long.unary_+?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiru5_roo.scala:29:60\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33melse\e\
    [0m \e[33mif\e[0m((h / \e[31m2\e[0m) < w2 && l2 == (i.toLong % \e[31m2\e[0m) ==\
    \ !(i.toLong % \e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m                         \
    \                                   ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \  value unary_! is not a member of Long - did you mean Long.unary_+?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpiru5_roo.scala:31:60 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m((h / \e[31m2\e\
    [0m) < w2 && l2 == (i.toLong % \e[31m2\e[0m) == !(i.toLong % \e[31m2\e[0m))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \  ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value unary_! is not a member of\
    \ Long - did you mean Long.unary_+?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010647
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sumOfElements = q reduce { (x,y) => x+y }\n        sumOfElements\
    \ <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpudvu8apk.scala:25)\n\tat Problem.main(tmpudvu8apk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010649
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def balanced(ls: List[Long]) : Boolean = {\n            ls.forall(x =>\
    \ x == ls.reverse.head)\n        }\n\n        val s = \"\" + q.toString ++ \"\
    +\"\n        val w = w.toLong\n        val maxW = Long.MaxValue\n        def check():\
    \ Boolean = {\n            val n = s.replaceFirst(\"[\\\\+]\", \"\").trim\n  \
    \          val w = n.split(\"\\\\+\").map(_.toLong).sum\n            w <= maxW\
    \ && balanced(n.split(\"\\\\+\").map(_.toLong))\n        }\n        if (check())\
    \ true\n        else false\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_kw2wm8p.scala:25:16 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mw\e[0m = w.toLong\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mw\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp_kw2wm8p.scala:30:34 --------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m            w <= maxW && balanced(n.split(\e[31m\"\\\\+\"\e\
    [0m).map(_.toLong))\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mArray\e\
    [0m[Long]\n\e[31m   |\e[0m                                  Required: \e[1m\e\
    [32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010649
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val ls = q.size\n        if (ls == 0) true\n        else if (ls == 1)\
    \ true\n        else ls == ls.reverse.tail.map(_.toLong).reverse &&\n        \
    \    q.sum.equalTo(ls.toLong * w)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc75juy64.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m ls == ls.reverse.tail.map(_.toLong).reverse\
    \ &&\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                   value reverse is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660010647
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q.reverse.map(x => x*x).sum <= w\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7037rdpe.scala:23)\n\tat Problem.main(tmp7037rdpe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010649
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // write your function here\n        true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3cwwa153.scala:25)\n\tat Problem.main(tmp3cwwa153.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010653
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) true\n        else if(q.length == 1) true\n      \
    \  else {\n            val newList = q.tail\n            val newSum = newList.foldLeft(0l)\
    \ { (s, x) => s + x }\n            if (newSum < w) willItFly(newList, w)\n   \
    \         else willItFly(newList.init, w)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpocm3hlqk.scala:31)\n\tat Problem.main(tmpocm3hlqk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Complete this function!\n        // If the object q is a palindrome\
    \ and if the sum of its elements is less than or equal to the maximum possible\
    \ weight w, then return true (it will\n        // fly).\n        // Otherwise,\
    \ return false.\n        // If the object q has a balance (it has an even number\
    \ of elements)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp91q1odqh.scala:19:56\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mwillItFly\e\
    [0m(\e[36mq\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mw\e[0m : \e[35mLong\e\
    [0m) : \e[35mBoolean\e[0m = {\n\e[31m\e[31m   |\e[0m                         \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                                 Found:    Unit\n\e[31m   |\e[0m            \
    \                                           Required: Boolean\n\e[31m20 |\e[0m\
    \        \e[34m// Complete this function!\e[0m\n\e[31m21 |\e[0m        \e[34m//\
    \ If the object q is a palindrome and if the sum of its elements is less than\
    \ or equal to the maximum possible weight w, then return true (it will\e[0m\n\e\
    [31m22 |\e[0m        \e[34m// fly).\e[0m\n\e[31m23 |\e[0m        \e[34m// Otherwise,\
    \ return false.\e[0m\n\e[31m24 |\e[0m        \e[34m// If the object q has a balance\
    \ (it has an even number of elements)\e[0m\n\e[31m25 |\e[0m    }\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your solution here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_nt9n0a8.scala:19:56\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mwillItFly\e\
    [0m(\e[36mq\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mw\e[0m : \e[35mLong\e\
    [0m) : \e[35mBoolean\e[0m = {\n\e[31m\e[31m   |\e[0m                         \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                                 Found:    Unit\n\e[31m   |\e[0m            \
    \                                           Required: Boolean\n\e[31m20 |\e[0m\
    \        \e[34m// Write your solution here\e[0m\n\e[31m21 |\e[0m    }\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = 0l\n        var j = 0\n        var i = q.size\n        while\
    \ ( i >= 0 && j < q.size ) {\n            sum += q(j)\n            i -= 1\n  \
    \          j += 1\n        }\n        if (sum >= w) return true\n        else\
    \ return false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpntfzle_7.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            sum += q(j)\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Long\
    \ - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if(q.isEmpty) true\n        else {\n            var sum = 0\n       \
    \     for(x <- q.reverse) {\n                sum += x\n            }\n       \
    \     if(sum < w) false\n            else willItFly(q.tail, w)\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7_ludw89.scala:24:20 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                sum += x\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not a member\
    \ of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w + 1l\n        // We need to consider all possibilities\
    \ to check\n        // that sum of weight and sum of elements is less or equal\n\
    \        val numLists : List[List[Long]] = q.reverse.foldLeft[List[List[Long]]]\
    \ (Nil) {\n            (x, y) =>\n                if (x.isEmpty && y.isEmpty ||\
    \ x.reverse == y.reverse) (y::x)\n                else if (x.isEmpty || y.reverse\
    \ == x.reverse) (y::x)\n                else (x::y)\n        }\n        var isBalanced\
    \ : Boolean = true\n        for (l <- numLists)\n            if (!l.contains(w.toLong))\
    \ {\n                val sumOfElements = l.foldLeft[Long](0l) { (acc, x) => acc\
    \ + x }\n                val sumOfWeight = l.sum\n                if (sumOfElements\
    \ > maxWeight) {\n                    isBalanced = false\n                   \
    \ break\n                }\n            }\n        isBalanced\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf875f7v_.scala:25:35 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mif\e[0m (x.isEmpty && y.isEmpty\
    \ || x.reverse == y.reverse) (y::x)\n\e[31m\e[31m   |\e[0m                   \
    \              ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \  value isEmpty is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpf875f7v_.scala:25:61 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m                \e[33mif\e[0m (x.isEmpty && y.isEmpty || x.reverse == y.reverse)\
    \ (y::x)\n\e[31m\e[31m   |\e[0m                                              \
    \             ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \   value reverse is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpf875f7v_.scala:25:71 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                \e[33mif\e[0m (x.isEmpty && y.isEmpty || x.reverse ==\
    \ y.reverse) (y::x)\n\e[31m\e[31m   |\e[0m                                   \
    \                                    ^\e[0m\n\e[31m   |\e[0m                 \
    \                                   Found:    (y : Long)\n\e[31m   |\e[0m    \
    \                                                Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf875f7v_.scala:26:40 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (x.isEmpty\
    \ || y.reverse == x.reverse) (y::x)\n\e[31m\e[31m   |\e[0m                   \
    \                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \         value reverse is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpf875f7v_.scala:26:63 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (x.isEmpty || y.reverse\
    \ == x.reverse) (y::x)\n\e[31m\e[31m   |\e[0m                                \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                              Found:    (y : Long)\n\e[31m   |\e[0m         \
    \                        "
  stdout: ''
  timestamp: 1660010657
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def balen(q : List[Long], w : Long) : Boolean = {\n            if (q.isEmpty)\
    \ {\n                return true\n            }\n            val maxW = math.max(w,\
    \ q.head)\n            if (q.head < maxW) {\n                return false\n  \
    \          }\n            val len = q.tail.length\n            if (len % 2 ==\
    \ 0) {\n                if (balen(q.tail.drop(1), w)) {\n                    balen(q.tail.takeRight(2),\
    \ w)\n                } else {\n                    balen(q.tail.drop(2), w)\n\
    \                }\n            } else {\n                if (balen(q.tail.dropRight(1),\
    \ w)) {\n                    balen(q.tail, w)\n                } else {\n    \
    \                balen(q.tail.take(2), w)\n                }\n            }\n\
    \        }\n        balen(q, w)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2y5mz7js.scala:46)\n\tat Problem.main(tmp2y5mz7js.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val palindromic = q.reverse == q\n        var sum = 0\n        // use\
    \ fold to get the sum using traversing the list\n        q.foldLeft(0) { case\
    \ (acc, x) => acc + x }\n        // if sum is not palindromic and sum of its elements\
    \ is less than or equal the max possible weight\n        if(palindromic && sum\
    \ < w) {\n            true\n        } else if(!palindromic && sum < w) {\n   \
    \         false\n        } else {\n            willItFly(q, w)\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgf3qo4o8.scala:23:41\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        q.foldLeft(\e[31m0\e\
    [0m) { \e[33mcase\e[0m (acc, x) => acc + x }\n\e[31m\e[31m   |\e[0m          \
    \                               ^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                         Found:    Long\n\e[31m   |\e[0m                    \
    \                     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxW = q.max\n        if (w.toDouble > maxW) return true\n      \
    \  else (q.reverse.toList diff q.sum).forall(w => w.toDouble <= maxW)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4_u9kaza.scala:22:36\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m (q.reverse.toList\
    \ diff q.sum).forall(w => w.toDouble <= maxW)\n\e[31m\e[31m   |\e[0m         \
    \                           ^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \              Found:    Long\n\e[31m   |\e[0m                               \
    \     Required: scala.collection.Seq[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010657
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val l = q.length\n        if (l == 0) true\n        else {\n        \
    \    val q2 = new mutable.MutableList[Long]()\n            val w2 = new mutable.MutableList[Long]()\n\
    \            val maxW = w\n            val maxL = Math.sqrt(w).toInt\n       \
    \     var sum = 0\n            for (i <- 0 until l)\n                sum = sum\
    \ + q(i)\n            if (sum < maxW && sum >= 1L) {\n                for (i <-\
    \ 0 until l)\n                    if (q(i) < maxL)\n                        q2.add(q(i))\n\
    \                    else\n                        w2.add(q(i))\n            \
    \    return willItFly(q2, maxW) || willItFly(w2, maxW)\n            }\n      \
    \      else if (sum < maxW && sum < 1L)\n                return false\n      \
    \      else if (sum >= maxW)\n                return true\n            else\n\
    \                return false\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphr8qz6kt.scala:23:25 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mq2\e[0m = \e[33mnew\e\
    [0m mutable.MutableList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphr8qz6kt.scala:24:25\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m\
    \ \e[36mw2\e[0m = \e[33mnew\e[0m mutable.MutableList[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphr8qz6kt.scala:29:22 --------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                sum = sum + q(i)\n\e[31m\e[31m   |\e[0m              \
    \        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      Found:    Long\n\
    \e[31m   |\e[0m                      Required: Int\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum : List[Long] = q.reverse.foldLeft(0l) { (sum: Long, x: Long)\
    \ =>\n            sum + x\n        }\n        if (sum < w) {\n            false\n\
    \        }\n        if (sum == w) {\n            (q.length == 1 && q(0) == w)\n\
    \        }\n        else {\n            true\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptj1yq3vw.scala:20:54\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36msum\e\
    [0m : \e[35mList\e[0m[\e[35mLong\e[0m] = q.reverse.foldLeft(\e[31m0l\e[0m) { (\e\
    [36msum\e[0m: \e[35mLong\e[0m, \e[36mx\e[0m: \e[35mLong\e[0m) =>\n\e[31m\e[31m\
    \   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m             \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \    Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e\
    [31m21 |\e[0m            sum + x\n\e[31m22 |\e[0m        }\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmptj1yq3vw.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mif\e[0m (sum < w) {\n\e[31m\e[31m   |\e\
    [0m            ^^^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- Error: /tmp/tmptj1yq3vw.scala:26:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (sum == w) {\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types List[Long] and\
    \ Long cannot be compared with == or !=\n\e[33m\e[33m-- [E129] Potential Issue\
    \ Warning: /tmp/tmptj1yq3vw.scala:24:12 ----------------\e[0m\e[0m\n\e[33m24 |\e\
    [0m            \e[31mfalse\e[0m\n\e[33m\e[33m   |\e[0m            ^^^^^\e[0m\n\
    \e[33m   |\e[0mA pure expression does nothing in statement position; you may be\
    \ omitting necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(l : List[Long], w : Long) : Boolean = {\n            val\
    \ maxLength : Long = l.map(_.toLong).max\n            if (maxLength <= w) true\n\
    \            else {\n                val diff : Long = l diff List(0, maxLength)\n\
    \                val rev : List[Long] = rev(diff)\n                val sum : Long\
    \ = rev.reduce(_ + _)\n                if (sum == w) true\n                else\
    \ {\n                    val balanced : Boolean = l diff List(0, maxLength) ==\
    \ rev\n                    if (balanced) isBalanced(rev, w)\n                \
    \    else false\n                }\n            }\n        }\n        isBalanced(q,\
    \ w)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvi2_s6ka.scala:24:34\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mval\e[0m\
    \ \e[36mdiff\e[0m : \e[35mLong\e[0m = l diff List(\e[31m0\e[0m, maxLength)\n\e\
    [31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mList\e\
    [0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                   \
    \               Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpvi2_s6ka.scala:25:43 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                \e[33mval\e[0m \e[36mrev\e[0m : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = rev(diff)\n\e[31m\e[31m   |\e[0m                                      \
    \     ^^^^\e[0m\n\e[31m   |\e[0m                                           Found:\
    \    (diff : Long)\n\e[31m   |\e[0m                                          \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvi2_s6ka.scala:29:52\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                    \e[33mval\e\
    [0m \e[36mbalanced\e[0m : \e[35mBoolean\e[0m = l diff List(\e[31m0\e[0m, maxLength)\
    \ == rev\n\e[31m\e[31m   |\e[0m                                              \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \             Found:    Boolean\n\e[31m   |\e[0m                             \
    \       Required: scala.collection.Seq[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w / 2\n        val maxListLength = w.toInt / 2\n       \
    \ val maxLength = w.toInt / 2\n        val lengths = mutable.ListBuffer.empty[Int]\n\
    \        val elements = mutable.ListBuffer.empty[Long]\n\n        for(i <- 0 until\
    \ q.size) {\n            if(q(i).equals(q(i).reverse.tail))\n                lengths\
    \ += 1\n            else {\n                elements += q(i)\n               \
    \ lengths += 1\n            }\n        }\n\n        if(elements.toList.size ==\
    \ maxListLength && maxSum < elements.toList.sum)\n            true\n        else\n\
    \            false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpseoncu00.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mlengths\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpseoncu00.scala:24:23 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36melements\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpseoncu00.scala:27:32 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mif\e[0m(q(i).equals(q(i).reverse.tail))\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           value reverse is not a member of Long\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val l = q.size\n        val max = math.pow(w, l/2) - 1l\n        val\
    \ isBalanced = l.filter(_ <= max).forall(_ == l.reverse)\n        val isPalindromic\
    \ = l.forall(x => x == l.reverse)\n        isPalindromic && isBalanced && q.reduceLeft(_\
    \ + _) <= max\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprsoz1ra5.scala:22:27 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36misBalanced\e[0m = l.filter(_\
    \ <= max).forall(_ == l.reverse)\n\e[31m\e[31m   |\e[0m                      \
    \   ^^^^^^^^\e[0m\n\e[31m   |\e[0m                         value filter is not\
    \ a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprsoz1ra5.scala:23:30\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36misPalindromic\e[0m = l.forall(\e[36mx\e[0m => x == l.reverse)\n\e[31m\e[31m\
    \   |\e[0m                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                   value forall is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q.isEmpty || w < 0 || w == 0\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgcf4hamr.scala:23)\n\tat Problem.main(tmpgcf4hamr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010665
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sumOfQ = q.sum\n        val maxWeight = w * 3\n        val maxWaysToGo\
    \ = sumOfQ / maxWeight\n        val minWaysToGo = (sumOfQ - maxWaysToGo * maxWeight)\
    \ / maxWeight\n        val canGo = (maxWaysToGo >= minWaysToGo)\n        val isPalNum\
    \ = (q.reverse.forall(x => x.toLong == q(0)))\n        (canGo && isPalNum)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7kez8b_v.scala:29)\n\tat Problem.main(tmp7kez8b_v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val max = w * Math.pow(10, q.length)\n        val sum = 0L\n        q.foreach(x\
    \ => sum = sum + x)\n        (sum < max) && {\n            q.reverse.drop(q.length).reverse\
    \ == q\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpzqgo0m18.scala:22:27 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        q.foreach(\e[36mx\e[0m => sum = sum + x)\n\e\
    [31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       Reassignment to val sum\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Base case: if the list is balanced, or if its sum is less than the\
    \ maximum possible weight.\n        if(q.isEmpty || q.sum < w)\n            return\
    \ true\n        // Recursion case: if the list is not balanced, or if the sum\
    \ exceeds the maximum possible weight.\n        val maximum = q.sum - w\n    \
    \    val middle = maximum / 2\n        val left  = q.take(middle)\n        val\
    \ right = q.drop(middle)\n        willItFly(left, w) || willItFly(right, w)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj82fhl7t.scala:26:27\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mleft\e\
    [0m  = q.take(middle)\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    (middle : Long)\n\e[31m\
    \   |\e[0m                           Required: Int\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpj82fhl7t.scala:27:27 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mright\e[0m = q.drop(middle)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                          Found:    (middle : Long)\n\e[31m   |\e[0m        \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toDouble * w.toDouble\n        val q = q.reverse\n   \
    \     val n = q.size\n        val a = q.last\n        var i = n - 1\n        val\
    \ sum = 0\n        while (i >= 0) {\n            sum = sum + q(i).toDouble\n \
    \           if (sum > maxSum) {\n                break\n            }\n      \
    \      i = i - 1\n        }\n        sum.toDouble <= maxSum && sum.toDouble >=\
    \ 0.0 && sum != a\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpz6xhdbti.scala:21:16 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mq\e[0m = q.reverse\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mq\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpz6xhdbti.scala:27:16 -----------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m            sum = sum + q(i).toDouble\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val sum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz6xhdbti.scala:29:16\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var maxWeight = w\n        var balanced = false\n        var maxSum =\
    \ 0\n        for (x <- q.reverse) {\n            val sum = x\n            val\
    \ maxSum = sum + maxWeight\n            if (maxSum <= maxWeight) {\n         \
    \       balanced = true\n            }\n            if (maxSum >= maxWeight) {\n\
    \                maxSum = sum\n                maxWeight = sum - maxWeight\n \
    \           }\n        }\n        balanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpvlquuqda.scala:30:23 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                maxSum = sum\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val maxSum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val l = q.size\n        val max = w.toLong\n        val sum = 0\n   \
    \     val left = 0\n        val right = l - 1\n        while (left <= right) {\n\
    \            val mid = (left + right) / 2\n            sum = sum + q(mid)\n  \
    \          if (sum < max)\n                left = mid + 1\n            else\n\
    \                right = mid\n        }\n        if (sum == max)\n           \
    \ true\n        else\n            false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoobyjh5s.scala:27:18\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            sum = sum + q(mid)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \              Found:    Long\n\e[31m   |\e[0m                  Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpoobyjh5s.scala:29:21 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                left = mid + \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Reassignment to val left\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpoobyjh5s.scala:31:22 -----------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m                right = mid\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val right\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010668
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q.groupBy(x => math.abs(x)).size == q.size && (\n            q.filter(x\
    \ => math.abs(x) <= w).size == q.length\n        )\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4dtrj8vy.scala:25)\n\tat Problem.main(tmp4dtrj8vy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var listSize : Int = 0\n        val list = q match {\n            case\
    \ Nil => List(w)\n            case x :: Nil => List(w)\n            case x ::\
    \ y => listSize = x + y\n        }\n        var sum : Long = 0\n        var maxSum\
    \ = listSize\n        for (i <- 0 until listSize) {\n            sum += list(i)\n\
    \            if (sum > maxSum) {\n                maxSum = sum\n            }\n\
    \        }\n        val isPalindromic = listSize == list.size && list.reverse.forall(x\
    \ => x == list(0))\n        return isPalindromic && sum <= w\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpan8b_oym.scala:24:40 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m x :: y => listSize = x +\
    \ y\n\e[31m\e[31m   |\e[0m                                      ^^^\e[0m\n\e[31m\
    \   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m+\e[0m\
    \ in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\
    \e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e\
    [0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0m (x: String):\
    \ String\n\e[31m   |\e[0mmatch arguments ((y : List[Long]))\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpan8b_oym.scala:29:16 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m            sum += list(i)\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Long\
    \ - did you mean Long.!=?\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpan8b_oym.scala:29:19\
    \ -----------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            sum += list(i)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^\e[0m\n\e[31m   |\e[0m           \
    \        \e[33mvalue\e[0m \e[35mlist\e[0m does not take parameters\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpan8b_oym.scala:31:25 --------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                maxSum = sum\n\e[31m\e[31m   |\e[0m \
    \                        ^^^\e[0m\n\e[31m   |\e[0m                         Found:\
    \    (sum : Long)\n\e[31m   |\e[0m                         Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpan8b_oym.scala:34:45 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = listSize\
    \ == list.size && list.reverse.forall(\e[36mx\e[0m => x == list(\e[31m0\e[0m))\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                 value size is not a member "
  stdout: ''
  timestamp: 1660010673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxList = q.reverse.tail\n        val\
    \ palindromic = List.isPalindromic(q)\n        val sumList = q.sum\n        if(palindromic\
    \ && sumList <= maxWeight) {\n            true\n        } else if (sumList > maxWeight)\
    \ {\n            false\n        } else {\n            // check the maxWeight\n\
    \            if(q.head == q.last)\n                true\n            else {\n\
    \                val maxListTail = maxList.tail\n                maxListTail.forall(x\
    \ => x > maxWeight)\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_3dea_xr.scala:22:31 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = List.isPalindromic(q)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue isPalindromic is not a member of object scala.collection.immutable.List\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val listSize = q.length\n        val reversedList = reverse(q)\n    \
    \    val sumOfElements = reversedList.toList.map(_.toLong).sum\n        val maximumWeight\
    \ = w.toLong\n\n        // if listSize is a palindrome, then sumOfElements is\
    \ equal to w\n        if(listSize == reversedList.toList && sumOfElements == w)\
    \ {\n            true\n        }\n        // if listSize is not a palindrome,\
    \ then sumOfElements is less than w\n        else {\n            // if listSize\
    \ equals 0, then sumOfElements is equal to w\n            if(listSize == 0) {\n\
    \                true\n            }\n            // if listSize is greater than\
    \ 0, then sumOfElements is less than w\n            else {\n                if(sumOfElements\
    \ < w) {\n                    false\n                } else {\n              \
    \      true\n                }\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptmhaj5bo.scala:21:27 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mreversedList\e[0m = reverse(q)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Not found: reverse\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010666
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here.\n        var ans : Boolean = true\n        if(q.isEmpty)\
    \ ans\n        else {\n            var maxSum = w\n            var maxIndex =\
    \ 0\n            val minMaxIndex = if (q.head < w) q.size else 0\n           \
    \ var minMaxSum = w\n            for(i <- 0 until minMaxIndex) minMaxSum += q.head\n\
    \            for(i <- 0 until q.size) maxSum += q.tail.sum\n            if(maxSum\
    \ <= maxIndex) ans = true\n            else if(minMaxSum < maxIndex) ans = false\n\
    \            else if (maxSum < minMaxSum) ans = true\n            else ans = willItFly(q.tail,\
    \ w)\n        }\n        return ans\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc75qjdsc.scala:39)\n\tat Problem.main(tmpc75qjdsc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWays = maxListLength(q)\n        if (maxWays > w)\n          \
    \  false\n        else\n            checkSum(q, maxWays, w)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp81rw23kr.scala:20:22 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxWays\e[0m = maxListLength(q)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      Not found: maxListLength\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp81rw23kr.scala:24:12 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            checkSum(q, maxWays, w)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            Not found: checkSum\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010666
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) true\n        else if (q.length == 1) (q.head == q(0))\
    \ && (q.head == w)\n        else if (q.length == 2) (q.head == q(0)) && (q.head\
    \ == w) && (q.tail.head == w)\n        else (q.head == q(0)) && (q.head == w)\
    \ && (q.tail.head == w) && (q.tail.tail.head == w) && (q.tail.tail.tail.head ==\
    \ w)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw4bjn1e8.scala:26)\n\tat Problem.main(tmpw4bjn1e8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // write your logic here\n        val left = new ArrayBuffer[Long](q.head)\n\
    \        val right = q.tail.reverse\n        val length = right.length\n     \
    \   val maxSum = length + w\n        val tempSum = left.sum + right.length * w\n\
    \        if (maxSum < tempSum) {\n            false\n        }\n        else if\
    \ (maxSum > tempSum) {\n            true\n        }\n        else {\n        \
    \    val index = left.lastIndex\n            val index = right.lastIndex\n   \
    \         if (index <= 0 || index > length) {\n                false\n       \
    \     }\n            else {\n                val i = left\n                val\
    \ j = right\n                val sum = i.toDouble + w.toDouble\n             \
    \   if (sum < j) {\n                    false\n                }\n           \
    \     else {\n                    willItFly(i.drop(index), w)\n              \
    \  }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp1idn0nn.scala:21:43\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mleft\e\
    [0m = \e[33mnew\e[0m \e[35mArrayBuffer\e[0m[\e[35mLong\e[0m](q.head)\n\e[31m\e\
    [31m   |\e[0m                                         ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                         Found:    Long\n\e[31m   |\e[0m  \
    \                                       Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpp1idn0nn.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mindex\e[0m = right.lastIndex\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mindex is already defined as \e[33mvalue\e[0m \e[35mindex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp1idn0nn.scala:33:29\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m\
    \ \e[36mindex\e[0m = left.lastIndex\n\e[31m\e[31m   |\e[0m                   \
    \     ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue lastIndex is not a member of scala.collection.mutable.ArrayBuffer[Long]\
    \ - did you mean left.lastIndexOf?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp1idn0nn.scala:41:28\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                \e[33mval\e\
    [0m \e[36msum\e[0m = i.toDouble + w.toDouble\n\e[31m\e[31m   |\e[0m          \
    \                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toDouble is not a member\
    \ of scala.collection.mutable.ArrayBuffer[Long], but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp1idn0nn.scala:46:"
  stdout: ''
  timestamp: 1660010678
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // The sum of weights of balanced palindromic lists is equal to the maximum\
    \ possible weight.\n        // The object q will fly if it's balanced (it is a\
    \ palindromic list) and the sum of its elements is less than or equal the maximum\
    \ possible weight w.\n        // To calculate the sum, we need to traverse the\
    \ list in reverse.\n        // The sum of first two elements is less than or equal\
    \ to the maximum possible weight w.\n        val sum = 0\n        val max = w\n\
    \        q.reverse.foreach(w => sum <- sum + w)\n        sum <- max\n        //\
    \ q will fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n        sum <- sum < max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph7v1fbb_.scala:26:35 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        q.reverse.foreach(\e[36mw\e[0m => sum <- sum\
    \ + w)\n\e[31m\e[31m   |\e[0m                                   ^^\e[0m\n\e[31m\
    \   |\e[0m                                   ')' expected, but '<-' found\n\e\
    [31m\e[31m-- Error: /tmp/tmph7v1fbb_.scala:27:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        sum <- max\n\e[31m\e[31m   |\e[0m           \
    \ ^^\e[0m\n\e[31m   |\e[0m            end of statement expected but '<-' found\n\
    \e[31m\e[31m-- Error: /tmp/tmph7v1fbb_.scala:29:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        sum <- sum < max\n\e[31m\e[31m   |\e[0m     \
    \       ^^\e[0m\n\e[31m   |\e[0m            end of statement expected but '<-'\
    \ found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph7v1fbb_.scala:29:8\
    \ ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m        sum <- sum < max\n\e\
    [31m\e[31m   |\e[0m        ^^^\e[0m\n\e[31m   |\e[0m        Found:    (sum : Int)\n\
    \e[31m   |\e[0m        Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- [E129]\
    \ Potential Issue Warning: /tmp/tmph7v1fbb_.scala:27:8 -----------------\e[0m\e\
    [0m\n\e[33m27 |\e[0m        sum <- max\n\e[33m\e[33m   |\e[0m        ^^^\e[0m\n\
    \e[33m   |\e[0mA pure expression does nothing in statement position; you may be\
    \ omitting necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1660010676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        val maxWight = w.toLong * 2 - 1\n  \
    \      val maxSum = w.toLong * 2 - 1\n        val minSum = w.toLong * 2 - 1\n\
    \        val palindromicQ = if(q.isEmpty) false else willItFly(q.reverse, w)\n\
    \        if(q.sum >= maxWight && palindromicQ) true\n        else if(q.sum >=\
    \ maxSum && !palindromicQ) false\n        else if(q.sum >= minSum && palindromicQ)\
    \ true\n        else false\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\
    \tat Problem$.willItFly(tmpoph7rd75.scala:24)\n\tat Problem$"
  stdout: ''
  timestamp: 1660010681
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def balancedList[T](ls: List[T], max: Long) : List[T] = {\n         \
    \   val n = ls.size\n            val maxn = ls.sum\n            var j = 0\n  \
    \          var isBalanced = true\n\n            for (i <- 0 until n if !ls(i).equals(ls(i+1)))\
    \ {\n                j++\n            }\n\n            val maxj = j\n        \
    \    j = 0\n            for (i <- 0 until n if !ls(i).equals(ls(i+1))) {\n   \
    \             j++\n            }\n\n            val maxj1 = j\n            var\
    \ j = 0\n            var i = n-1\n            while (i >= 0) {\n             \
    \   j++\n                if (ls(i).equals(ls(i+1))) {\n                    i--\n\
    \                }\n            }\n\n            val maxj2 = j\n            var\
    \ i = 0\n            var isBalanced2 = true\n            var j = 0\n\n       \
    \     for (i <- 0 until n) {\n                if (ls(i).equals(ls(i+1))) {\n \
    \                   isBalanced2 = false\n                }\n            }\n\n\
    \            if (isBalanced2 && maxj >= maxj1 && maxj1 <= maxj2) {\n         \
    \       isBalanced = true\n            }\n            isBalanced\n        }\n\n\
    \        val xs = q.distinct\n        val ys = w.distinct\n        val zs = xs.intersect(ys)\n\
    \n        if (zs.isEmpty) {\n            true\n        } else {\n            val\
    \ n = xs.size\n            val m = ys.size\n            if (n <= m && balancedList(xs,\
    \ w) && balancedList(ys, w)) {\n                false\n            } else {\n\
    \                true\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphyvgccak.scala:27:19 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphyvgccak.scala:33:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                j++\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E018] Syntax Error: /tmp/tmphyvgccak.scala:40:19 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphyvgccak.scala:37:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mvar\e\
    [0m \e[36mj\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mj is already defined as \e[33mvariable\e[0m \e[35mj\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphyvgccak.scala:47:16 ---------------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m            \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined as \e\
    [33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmphyvgccak.scala:49:16 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m            \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined\
    \ as \e[33mvariable\e["
  stdout: ''
  timestamp: 1660010680
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = q.map(x => math.pow(x, 2)).reduce(math.max)\n        val\
    \ isPalindromic = (q.reverse.forall(x => q.head == x) && q.forall(x => x == q.tail.head))\
    \ && q.size == q.length\n        val isBalanced = (q.map(x => math.pow(x, 2)).sum\
    \ > maxSum) && q.size == q.length\n        isPalindromic && isBalanced\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdp9v8geh.scala:26)\n\tat Problem.main(tmpdp9v8geh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010681
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val s = q.reverse.map(_.toInt).sum\n        s <= w\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplvczzsfe.scala:25)\n\tat Problem.main(tmplvczzsfe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010684
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val list = new collection.mutable.ListBuffer[Long]()\n        var wsum\
    \ = 0l\n        for(i <- q) {\n            list+=i\n            wsum += i\n  \
    \      }\n        if (list.isEmpty || list.size != q.length) false else (wsum\
    \ < w) && (wsum == wlist.last)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzcbbq6l0.scala:26:85 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (list.isEmpty || list.size != q.length)\
    \ \e[31mfalse\e[0m \e[33melse\e[0m (wsum < w) && (wsum == wlist.last)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                     ^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \                            Not found: wlist\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxW = w\n        val pList = q.reverse.mkString\n        if (pList\
    \ == q.toString) true\n        else { val p = pList.length\n            if (p\
    \ < maxW) false\n            else { val q = pList.reverse.mkString\n         \
    \       if (q < maxW) true else false\n            }\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsa3vjabb.scala:26:24\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                \e[33mif\e[0m\
    \ (q < maxW) \e[31mtrue\e[0m \e[33melse\e[0m \e[31mfalse\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                        ^^^^\e[0m\n\e[31m   |\e[0m                   \
    \     Found:    (maxW : Long)\n\e[31m   |\e[0m                        Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010681
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val balanced = q.reverse.forall(_ == q.reverse.get(_)) && w.toLong <=\
    \ q.sum\n        !(balanced && q.sum < w.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpf0exiupb.scala:20:40 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbalanced\e[0m = q.reverse.forall(_\
    \ == q.reverse.get(_)) && w.toLong <= q.sum\n\e[31m\e[31m   |\e[0m           \
    \                             ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                             Wrong number of parameters, expected: 1\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010678
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val newList = q.map(x => (x, w)).toList\n        val palin = reverse(newList).equals(newList)\n\
    \        if(!palin)\n            return false\n        newList.map(_._1).sum >=\
    \ w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpppnu6gfc.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mpalin\e[0m = reverse(newList).equals(newList)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: reverse\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Your code goes here.\n        val maxWeight = w\n        val balance\
    \ = balanceQ(q, w)\n        (balance == true) && (maxWeight <= q.sum)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9ukq91d5.scala:22:22 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mbalance\e[0m = balanceQ(q,\
    \ w)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      Not found: balanceQ\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010677
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val pList = q.map(x => x.toString()).reverse.map(_.toLong).reverse.map(BigDecimal(_))\n\
    \        val fly = pList.sum == w\n        val isBalanced = pList.forall(_ < w)\n\
    \        (fly && isBalanced)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptvtfeokg.scala:26)\n\tat Problem.main(tmptvtfeokg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010686
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val wq = q.sum\n        // wq < w means q doesn't fly.\n        wq <\
    \ w && q.forall(x => math.abs(x - wq) < w)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9frexguo.scala:26)\n\tat Problem.main(tmp9frexguo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.size <= 0) false\n        else if (q.head != q.reverse && w <=\
    \ 0) true\n        else willItFly(q.reverse, w-1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpu788nx3f.scala:21:17 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (q.head != q.reverse\
    \ && w <= \e[31m0\e[0m) \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m               \
    \  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types Long and List[Long]\
    \ cannot be compared with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1660010685
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \       val ls = ListBuffer[Long]()\n       var qs = q\n       while(true){\n\
    \         qs = qs.reverse\n         if(qs.isEmpty){\n           true\n       \
    \  }else{\n           ls.append(qs.head)\n           qs = qs.tail\n         }\n\
    \         val sum = ls.sum\n         if(sum < w){\n           return false\n \
    \        }else if(sum == w){\n           return true\n         }\n       }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0w37et8v.scala:22:7\
    \ ---------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \e[33mwhile\e[0m(\e[31mtrue\e\
    [0m){\n\e[31m\e[31m   |\e[0m       ^\e[0m\n\e[31m   |\e[0m       Found:    Unit\n\
    \e[31m   |\e[0m       Required: Boolean\n\e[31m23 |\e[0m         qs = qs.reverse\n\
    \e[31m24 |\e[0m         \e[33mif\e[0m(qs.isEmpty){\n\e[31m25 |\e[0m          \
    \ \e[31mtrue\e[0m\n\e[31m26 |\e[0m         }\e[33melse\e[0m{\n\e[31m27 |\e[0m\
    \           ls.append(qs.head)\n\e[31m28 |\e[0m           qs = qs.tail\n\e[31m29\
    \ |\e[0m         }\n\e[31m30 |\e[0m         \e[33mval\e[0m \e[36msum\e[0m = ls.sum\n\
    \e[31m31 |\e[0m         \e[33mif\e[0m(sum < w){\n\e[31m32 |\e[0m           \e\
    [33mreturn\e[0m \e[31mfalse\e[0m\n\e[31m33 |\e[0m         }\e[33melse\e[0m \e\
    [33mif\e[0m(sum == w){\n\e[31m34 |\e[0m           \e[33mreturn\e[0m \e[31mtrue\e\
    [0m\n\e[31m35 |\e[0m         }\n\e[31m36 |\e[0m       }\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010685
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        if (q.size != 1)\n            return false\n\
    \        val left = q(0)\n        val right = q(0)\n        for (i <- 0 until\
    \ q.size) {\n            if (q(i) != left + right + q(i))\n                return\
    \ false\n        }\n        // Now we know that the list will be balanced if the\
    \ sum of the list elements\n        // is less than or equal to  maxWeight\n \
    \       if (q(0).signum < 0 || q(0).abs > (maxWeight + 1))\n            return\
    \ false\n        // We also know that the list will not be balanced if the sum\
    \ of its elements is greater\n        // than the maximum possible weight\n  \
    \      if (q(0).abs > (maxWeight - 1))\n            return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7qdy40s4.scala:40)\n\tat Problem.main(tmp7qdy40s4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010691
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        q.reverse.forall(x => x <= maxWeight)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp48uhr7kc.scala:25)\n\tat Problem.main(tmp48uhr7kc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010689
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong - q.sum\n        q.reverse.forall(i => i + q.sum\
    \ < maxWeight)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmu1rsu4x.scala:24)\n\tat Problem.main(tmpmu1rsu4x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // TODO : Write your code here\n        val maxW : Long = 1000000000l\n\
    \        if(q.isEmpty) true\n        else {\n            val sum : Long = q.reduce(_\
    \ + _)\n            if(sum < 0) false\n            else if(sum > maxW) false\n\
    \            else {\n                val maxSum = sum / w\n                if(maxSum\
    \ < 0) false\n                else {\n                    val firstHalfSum = (sum\
    \ - maxSum * (w-1)) / (w/2)\n                    if(firstHalfSum < 0) false\n\
    \                    else {\n                        val lastHalfSum = (sum -\
    \ maxSum * (w-1)) / (w/2)\n                        if(lastHalfSum > maxSum) false\n\
    \                        else {\n                            val firstHalfSumOfList\
    \ = q.takeWhile(_ < firstHalfSum).toList\n                            val lastHalfSumOfList\
    \ = q.takeWhile(_ > lastHalfSum).toList\n                            if(firstHalfSumOfList.size\
    \ == 0 || lastHalfSumOfList.size == 0) false\n                            else\
    \ {\n                                val firstHalfSumOfListIsPalindrome = firstHalfSumOfList.forall(x\
    \ => x == x.reverse)\n                                val lastHalfSumOfListIsPalindrome\
    \ = lastHalfSumOfList.forall(x => x == x.reverse)\n                          \
    \      if(firstHalfSumOfListIsPalindrome && lastHalfSumOfListIsPalindrome) true\n\
    \                                else false\n                            }\n \
    \                       }\n                    }\n                }\n        \
    \    }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkdqal0f3.scala:41:107 -----------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                                \e[33mval\e[0m \e[36mfirstHalfSumOfListIsPalindrome\e\
    [0m = firstHalfSumOfList.forall(\e[36mx\e[0m => x == x.reverse)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                            value reverse is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpkdqal0f3.scala:42:105 -----------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                                \e[33mval\e[0m \e[36mlastHalfSumOfListIsPalindrome\e\
    [0m = lastHalfSumOfList.forall(\e[36mx\e[0m => x == x.reverse)\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \                                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                         value reverse is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660010691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val newMaxWeight = w-q.sum\n        val rev = ListBuffer(q.tail.reverse)\n\
    \        val newList = rev.reverse\n        val reverseList = rev.reverse\n  \
    \      if (q.head == 0) true\n        else if (newMaxWeight < 0l || reverseList.sum\
    \ > newMaxWeight) true\n        else willItFly(newList.reverse, newMaxWeight)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp5zgq4at2.scala:25:53 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (newMaxWeight <\
    \ \e[31m0l\e[0m || reverseList.sum > newMaxWeight) \e[31mtrue\e[0m\n\e[31m\e[31m\
    \   |\e[0m                                                     ^\e[0m\n\e[31m\
    \   |\e[0m            No implicit Ordering defined for B\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m            where:    B is a type variable with constraint >: List[Long]\n\
    \e[31m   |\e[0m            .\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5zgq4at2.scala:26:31\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33melse\e[0m willItFly(newList.reverse,\
    \ newMaxWeight)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    scala.collection.mutable.ListBuffer[List[Long]]\n\
    \e[31m   |\e[0m               Required: List[Long]\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if(q.length == 0) false else (w < q(0) * q(0)) && (w-sum(q) <= q.last\
    \ * q.last)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn7fozj44.scala:20:61 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m(q.length == \e[31m0\e[0m) \e[31mfalse\e\
    [0m \e[33melse\e[0m (w < q(\e[31m0\e[0m) * q(\e[31m0\e[0m)) && (w-sum(q) <= q.last\
    \ * q.last)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^\e[0m\n\e[31m   |\e[0m                                 \
    \                         Not found: sum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010685
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.reduceLeft(_ + _)\n        q.reverse match {\n       \
    \     case Nil => true\n            case y :: ys =>\n                if(y.toLong\
    \ == qs.init.tail.sum && y == qs.init.init.head) {\n                    if(y ==\
    \ qs.tail.init.head) {\n                        willItFly(ys, w)\n           \
    \         } else {\n                        maxSum <= w && willItFly(ys, w)\n\
    \                    }\n                } else {\n                    maxSum <=\
    \ w && willItFly(ys, w)\n                }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5imcsz6w.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e[0m = w.reduceLeft(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                     value reduceLeft is not a member of Long\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5imcsz6w.scala:24:31 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e[0m(y.toLong == qs.init.tail.sum\
    \ && y == qs.init.init.head) {\n\e[31m\e[31m   |\e[0m                        \
    \       ^^\e[0m\n\e[31m   |\e[0m                               Not found: qs\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5imcsz6w.scala:25:28\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                    \e[33mif\e\
    [0m(y == qs.tail.init.head) {\n\e[31m\e[31m   |\e[0m                         \
    \   ^^\e[0m\n\e[31m   |\e[0m                            Not found: qs\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // check balance\n        if (q.isEmpty) return true\n        var maxWeight\
    \ = w\n        var maxSum = w.toLong\n        for (i <- 0 until q.size) {\n  \
    \          val c = q(i)\n            maxWeight = c > maxWeight ? c : maxWeight\n\
    \            maxSum = c > maxSum ? c : maxSum\n        }\n        maxWeight <=\
    \ w && maxSum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsexswdo_.scala:26:44 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            maxWeight = c > maxWeight ? c : \e[35mmaxWeight\e\
    [0m\n\e[31m\e[31m   |\e[0m                                            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Not found: type\
    \ maxWeight\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsexswdo_.scala:26:38\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            maxWeight = c\
    \ > maxWeight ? c : \e[35mmaxWeight\e[0m\n\e[31m\e[31m   |\e[0m              \
    \              ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            value\
    \ ? is not a member of Long\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsexswdo_.scala:27:38\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            maxSum = c >\
    \ maxSum ? c : \e[35mmaxSum\e[0m\n\e[31m\e[31m   |\e[0m                      \
    \                ^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \      Not found: type maxSum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpsexswdo_.scala:27:32 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m            maxSum = c > maxSum ? c : \e[35mmaxSum\e[0m\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \      value ? is not a member of Long\n4 errors found\n"
  stdout: ''
  timestamp: 1660010696
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxW : Long = w\n        val sum : Long = q.sum\n        val pList\
    \ : List[Long] = q.reverse\n        var fly = true\n        var bal = 0\n    \
    \    val fly_list : List[Long] = q.reverse\n        val pList : List[Long] = q.reverse\n\
    \        var fly = true\n        for(i <- 0 until q.size) {\n            if (pList(i)\
    \ != pList(i+1)) {\n                if (sum > maxW) {\n                    fly\
    \ = false\n                    break\n                }\n                if (i\
    \ == q.size-1) {\n                    fly = true\n                } else {\n \
    \                   if (pList(i) == pList(i+1)) {\n                        fly\
    \ = false\n                        break\n                    } else {\n     \
    \                   fly = false\n                        break\n             \
    \       }\n                }\n            }\n            if (pList(i) == pList(i+1))\
    \ {\n                bal += 1\n            } else {\n                bal -= 1\n\
    \            }\n        }\n        return fly\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnz0wim9m.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mpList\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m] = q.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mpList is already defined as \e[33mvalue\e[0m \e[35mpList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnz0wim9m.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mvar\e[0m \e[36mfly\e[0m = \e[31mtrue\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mfly is already defined\
    \ as \e[33mvariable\e[0m \e[35mfly\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnz0wim9m.scala:32:20 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnz0wim9m.scala:39:24\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                        break\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpnz0wim9m.scala:42:24 ------------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m                        break\n\e[31m\e[31m   |\e[0m     \
    \                   ^^^^^\e[0m\n\e[31m   |\e[0m                        Not found:\
    \ break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def balanced(l: List[Long], maxW: Long): Boolean = l.zip(l.reverse).map(_._1\
    \ + _._2).sum < maxW\n        val maxW : Long = w.toLong\n        (q.reverse.tail\
    \ exists (l => balanced(l, maxW)) || balanced(q, maxW))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmposkxjyl8.scala:20:82 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mdef\e[0m \e[36mbalanced\e[0m(\e[36ml\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mmaxW\e[0m: \e[35mLong\e[0m): \e[35mBoolean\e\
    [0m = l.zip(l.reverse).map(_._1 + _._2).sum < maxW\n\e[31m\e[31m   |\e[0m    \
    \                                                                            ^^^^\e\
    [0m\n\e[31m   |\e[0m                                        value _1 is not a\
    \ member of Long\n\e[31m\e[31m-- Error: /tmp/tmposkxjyl8.scala:20:96 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mdef\e[0m \e[36mbalanced\e[0m(\e[36ml\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mmaxW\e[0m: \e[35mLong\e[0m): \e[35mBoolean\e\
    [0m = l.zip(l.reverse).map(_._1 + _._2).sum < maxW\n\e[31m\e[31m   |\e[0m    \
    \                                                                            \
    \                ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mIntIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e\
    [0m \e[35mByteIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type\
    \ Numeric[B] of parameter num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e\
    [0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmposkxjyl8.scala:22:56\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        (q.reverse.tail exists\
    \ (\e[36ml\e[0m => balanced(l, maxW)) || balanced(q, maxW))\n\e[31m\e[31m   |\e\
    [0m                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                       value || is not a member of List[Long] => Boolean\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010698
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var result = true\n        var l = q.head\n        var w = w - 1\n  \
    \      while(l<q.last){\n            if(q(l) != q(l-1)){\n                result\
    \ = false\n                break\n            }\n            l += 1\n        \
    \    w += 1\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpihottpol.scala:22:16 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mw\e[0m = w - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvariable\e[0m \e[35mw\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpihottpol.scala:24:17 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m(q(l) != q(l-\e[31m1\e[0m)){\n\
    \e[31m\e[31m   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                \
    \ Found:    (l : Long)\n\e[31m   |\e[0m                 Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpihottpol.scala:24:25 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m(q(l) != q(l-\e[31m1\e[0m)){\n\
    \e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\e[31m   |\e[0m      \
    \                   Found:    Long\n\e[31m   |\e[0m                         Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpihottpol.scala:26:16\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010698
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxW = w.toLong\n\n        q.tail.fold(true)({ acc =>\n         \
    \   val sum = acc.fold(0L)(_ + _)\n            if(sum < maxW && !(acc.reverse.sliding(2).forall(_.toLong\
    \ == acc.reverse.head) && acc.forall(_ != acc.reverse.head))) {\n            \
    \    acc match {\n                    case x :: xs => willItFly(xs, maxW)\n  \
    \                  case _ => acc\n                }\n            } else {\n  \
    \              acc\n            }\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp2hgh30qp.scala:22:32 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        q.tail.fold(\e[31mtrue\e[0m)({ \e[36macc\e[0m\
    \ =>\n\e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m\
    \                            Wrong number of parameters, expected: 2\n\e[31m23\
    \ |\e[0m            \e[33mval\e[0m \e[36msum\e[0m = acc.fold(\e[31m0L\e[0m)(_\
    \ + _)\n\e[31m24 |\e[0m            \e[33mif\e[0m(sum < maxW && !(acc.reverse.sliding(\e\
    [31m2\e[0m).forall(_.toLong == acc.reverse.head) && acc.forall(_ != acc.reverse.head)))\
    \ {\n\e[31m25 |\e[0m                acc \e[33mmatch\e[0m {\n\e[31m26 |\e[0m  \
    \                  \e[33mcase\e[0m x :: xs => willItFly(xs, maxW)\n\e[31m27 |\e\
    [0m                    \e[33mcase\e[0m _ => acc\n\e[31m28 |\e[0m             \
    \   }\n\e[31m29 |\e[0m            } \e[33melse\e[0m {\n\e[31m30 |\e[0m       \
    \         acc\n\e[31m31 |\e[0m            }\n1 error found\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // your code here\n        if (q.length == 1) {\n            if (q.isDefined)\
    \ {\n                true\n            } else {\n                false\n     \
    \       }\n        } else {\n            val maxSum = math.max(w, q.map(_.toLong).sum)\n\
    \            val fly = q.foldLeft(false)((acc, current) =>\n                if\
    \ (acc && current.toLong == q.reverse.head) {\n                    acc && current.toLong\
    \ == q.reverse.tail.head\n                } else {\n                    acc &&\
    \ current.toLong <= maxSum\n                }\n            )\n            fly.toBoolean\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf8fcu1cs.scala:22:18 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (q.isDefined) {\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined is\
    \ not a member of List[Long] - did you mean q.isDefinedAt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpf8fcu1cs.scala:36:16 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m            fly.toBoolean\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value toBoolean is not a member\
    \ of Boolean\n2 errors found\n"
  stdout: ''
  timestamp: 1660010699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w /2.0\n        val qSum = q.toList.reverse.foldLeft(0.0)\
    \ { (sum, elem) =>\n            if (sum < maxSum * elem) sum + elem else sum\n\
    \        }\n        val maxElem = (q, maxSum).unzip\n        qSum < maxElem\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmswnstwb.scala:24:34 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmaxElem\e[0m = (q, maxSum).unzip\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue unzip is not a member of (List[Long], Double) - did you mean (List[Long],\
    \ Double).zip?\n1 error found\n"
  stdout: ''
  timestamp: 1660010697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w / 2\n        q.reverse.foldLeft((false, 0)) { (acc,\
    \ elem) => elem match {\n            case 1 => acc match {\n                case\
    \ (true, _) => true\n                case (false, 1) => false\n              \
    \  case (true, _) => false\n                case (false, 0) => acc\n         \
    \   }\n            case 2 => acc match {\n                case (true, _) => true\n\
    \                case (false, 2) => false\n                case (true, _) => false\n\
    \                case (false, 0) => acc\n            }\n            case 3 =>\
    \ acc match {\n                case (true, _) => true\n                case (false,\
    \ 3) => false\n                case (true, _) => false\n                case (false,\
    \ 0) => acc\n            }\n            case 4 => acc match {\n              \
    \  case (true, _) => true\n                case (false, 4) => false\n        \
    \        case (true, _) => false\n                case (false, 0) => acc\n   \
    \         }\n            case 5 => acc match {\n                case (true, _)\
    \ => true\n                case (false, 5) => false\n                case (true,\
    \ _) => false\n                case (false, 0) => acc\n            }\n       \
    \     case 6 => acc match {\n                case (true, _) => true\n        \
    \        case (false, 6) => false\n                case (true, _) => false\n \
    \               case (false, 0) => acc\n            }\n            case 7 => acc\
    \ match {\n                case (true, _) => true\n                case (false,\
    \ 7) => false\n                case (true, _) => false\n                case (false,\
    \ 0) => acc\n            }\n            case 8 => acc match {\n              \
    \  case (true, _) => true\n                case (false, 8) => false\n        \
    \        case (true, _) => false\n                case (false, 0) => acc\n   \
    \         }\n            case 9 => acc match {\n                case (true, _)\
    \ => true\n                case (false, 9) => false\n                case (true,\
    \ _) => false\n                case (false, 0) => acc\n            }\n       \
    \     case 10 => acc match {\n                case (true, _) => true\n       \
    \         case (false, 10) => false\n                case (true, _) => false\n\
    \                case (false, 0) => acc\n            }\n            case x =>\
    \ acc match {\n                case (true, _) => true\n                case (false,\
    \ x) => false\n                case (true, _) => false\n                case (false,\
    \ 0) => acc\n            }\n        }}\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdif4jj8d.scala:23:34\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33mcase\e\
    [0m (\e[31mtrue\e[0m, _) => \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    (\e[31mtrue\e[0m : Boolean)\n\e[31m   |\e[0m               \
    \                   Required: (Boolean, Int)\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpdif4jj8d.scala:24:35 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mcase\e[0m (\e[31mfalse\e[0m, \e\
    [31m1\e[0m) => \e[31mfalse\e[0m\n\e[31m\e[31m   |\e[0m                       \
    \            ^^^^^\e[0m\n\e[31m   |\e[0m                                   Found:\
    \    (\e[31mfalse\e[0m : Boolean)\n\e[31m   |\e[0m                           \
    \        Required: (Boolean, Int)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpdif4jj8d.scala:25:34 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                \e[33mcase\e[0m (\e[31mtrue\e[0m, _) => \e[31mfalse\e\
    [0m\n\e[31m\e[31m   |\e[0m                                  ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                  Found:    (\e[31mfalse\e[0m : Boolean)\n\
    \e[31m   |\e[0m                                  Required: (Boolean, Int)\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdif4jj8d.scala:29:34\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                \e[33mcase\e\
    [0m (\e[31mtrue\e[0m, _) => \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    (\e[31mtrue\e[0m : Boolean)\n\e[31m   |\e[0m               \
    \                   Required: (Boolean, Int)\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpdif4jj8d.scala:30:35 --------------------\e\
    [0m\e[0m\n\e["
  stdout: ''
  timestamp: 1660010707
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if(q.isEmpty) return true\n        val qList = q.toList\n        if(qList.length\
    \ < 2) return true\n        val maxSum = qList.map(x => x + x).sum\n        if(maxSum\
    \ < w) false\n        else\n            qList.tail.reverse.map { x =>\n      \
    \          if(maxSum - x < 0) false\n                else if(maxSum - x == w)\
    \ true\n                else false\n            }.forall(x => x)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwcdx6pqo.scala:33)\n\tat Problem.main(tmpwcdx6pqo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Your code here.\n        // Your code here.\n        // Your code\
    \ here.\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphdvk13dc.scala:19:56\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mwillItFly\e\
    [0m(\e[36mq\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mw\e[0m : \e[35mLong\e\
    [0m) : \e[35mBoolean\e[0m = {\n\e[31m\e[31m   |\e[0m                         \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                                 Found:    Unit\n\e[31m   |\e[0m            \
    \                                           Required: Boolean\n\e[31m20 |\e[0m\
    \        \e[34m// Your code here.\e[0m\n\e[31m21 |\e[0m        \e[34m// Your code\
    \ here.\e[0m\n\e[31m22 |\e[0m        \e[34m// Your code here.\e[0m\n\e[31m23 |\e\
    [0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.isEmpty) {\n            return true\n        }\n\n        // This\
    \ code is very similar to the code you wrote above,\n        // but now we will\
    \ use that code to check whether q will fly.\n        // So here is an explanation\
    \ of the code we wrote:\n        // The idea is to check whether the list q is\
    \ balanced or not.\n        // If balanced, then we will fly.\n        // So first\
    \ we will check if q is a palindrome.\n        // if yes, then we will not fly.\n\
    \        // else we will check if q is balanced.\n        // if yes, then we will\
    \ not fly.\n        // else we will fly.\n        // The method will be called\
    \ by isPalindrome(q).\n        // But now we will use another method to check\
    \ whether q is balanced.\n        // It will check whether the sum of elements\
    \ in a list is less than or equal to w.\n        // If it is, it will return true.\n\
    \        // Otherwise, returns false.\n        // So we combine isPalindrome(q)\
    \ with this method, and we will get what we want.\n        val palindrome = q.isPalindrome\n\
    \        if (palindrome) {\n            return false\n        }\n        val balanced\
    \ = q.isBalanced\n        if (balanced) {\n            return false\n        }\n\
    \        return true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphilz4w4d.scala:40:27 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mpalindrome\e[0m = q.isPalindrome\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        value isPalindrome is not a member of List[Long]\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmphilz4w4d.scala:44:25 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mbalanced\e[0m = q.isBalanced\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       value isBalanced is not a member of List[Long]\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val l = q.foldLeft(List[Long]())((l, x) => if (x == l.last) l.last else\
    \ l.last :: x)\n        if (l.isEmpty && l == w) false\n        else willItFly(l,\
    \ w)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv64hdmqr.scala:20:70\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36ml\e\
    [0m = q.foldLeft(List[\e[35mLong\e[0m]())((\e[36ml\e[0m, \e[36mx\e[0m) => \e[33mif\e\
    [0m (x == l.last) l.last \e[33melse\e[0m l.last :: x)\n\e[31m\e[31m   |\e[0m \
    \                                                                   ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                    Found:    Long\n\
    \e[31m   |\e[0m                                                    Required: \e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpv64hdmqr.scala:20:87 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = q.foldLeft(List[\e\
    [35mLong\e[0m]())((\e[36ml\e[0m, \e[36mx\e[0m) => \e[33mif\e[0m (x == l.last)\
    \ l.last \e[33melse\e[0m l.last :: x)\n\e[31m\e[31m   |\e[0m                 \
    \                                                                      ^^^^\e\
    [0m\n\e[31m   |\e[0m                                        value :: is not a\
    \ member of Long\n\e[31m\e[31m-- Error: /tmp/tmpv64hdmqr.scala:21:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (l.isEmpty && l == w) \e[31mfalse\e\
    [0m\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \    Values of types List[Long] and Long cannot be compared with == or !=\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w;\n        val maxSum = w;\n        val maxWasBalanced\
    \ = true;\n        val sum = 0;\n        q.foreach{ x =>\n            if(sum >\
    \ maxSum) {\n                maxWasBalanced = false;\n                break;\n\
    \            }\n            sum += x;\n        }\n        if(maxWasBalanced) {\n\
    \            (q.reverse.sum < maxWeight && q.reverse.forall(x=>x==w))\n      \
    \  } else {\n            false\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpv3k904at.scala:26:31 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                maxWasBalanced = \e[31mfalse\e[0m;\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Reassignment to val maxWasBalanced\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpv3k904at.scala:27:16 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                break;\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv3k904at.scala:29:16 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            sum += x;\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int -\
    \ did you mean sum.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // TODO: Write your solution here\n        val w = w.toLong\n       \
    \ val maxWeight = w * w.toDouble\n        val max = List(1l, 2l, 3l, 4l, 5l, 6l,\
    \ 7l, 8l, 9l).max\n        val maxW = max.toLong\n        val numElements = q.size\n\
    \        if (maxW + q.sum < w) false else if (maxW - q.sum > w) true else {\n\
    \            if (numElements <= (maxW / w).toInt) true else if (numElements <=\
    \ (maxW / w).toInt) false else {\n                if (q.forall(_.toDouble.toLong\
    \ == maxW)) true else false\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvc4i_ls_.scala:21:16 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mw\e[0m = w.toLong\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mw\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.isEmpty)\n            q.palindrome\n        else {\n          \
    \  val maxW = math.max(q, w).toLong\n            val maxWeight = q.length.toLong\n\
    \            val reverseQ = q.tail.reverse\n            var sum = 0\n        \
    \    var i = 0\n            while (i < reverseQ.length) {\n                sum\
    \ += reverseQ(i)\n                i += 1\n            }\n            sum >= maxW\
    \ && sum < maxWeight && sum == reverseQ.sum\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5ap2fviz.scala:21:14 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            q.palindrome\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value palindrome is not\
    \ a member of List[Long]\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp5ap2fviz.scala:23:28\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxW\e[0m = math.max(q, w).toLong\n\e[31m\e[31m   |\e[0m           \
    \            ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((q : List[Long]),\
    \ (w : Long))\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5ap2fviz.scala:29:20\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                sum += reverseQ(i)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \    value += is not a member of Int - did you mean Int.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010708
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val balanced = q.reverse.forall(x => x == q.reverse.last)\n        val\
    \ sum = q.sum\n        val maxWeight = math.max(w, balanced)\n        sum < maxWeight\
    \ && balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp22t5i3h2.scala:22:29 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mmaxWeight\e[0m = math.max(w,\
    \ balanced)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e\
    [0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e\
    [31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\
    \e[31m   |\e[0mmatch arguments ((w : Long), (balanced : Boolean))\n1 error found\n"
  stdout: ''
  timestamp: 1660010704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val qw = q.zipWithIndex\n        qw.forall { case (q, index) => q ===\
    \ qw(index-1)._1 }\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpin0hrd13.scala:21:41 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        qw.forall { \e[33mcase\e[0m (q, index) => q ===\
    \ qw(index-\e[31m1\e[0m)._1 }\n\e[31m\e[31m   |\e[0m                         \
    \              ^^^^^\e[0m\n\e[31m   |\e[0m                  value === is not a\
    \ member of Long - did you mean q.==?\n1 error found\n"
  stdout: ''
  timestamp: 1660010708
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val reversed = q.map(_.asInstanceOf[Long]).reverse\n        reversed.toSet.subsetOf(w.asInstanceOf[Long].asInstanceOf[Long])\
    \ == true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpse20ylsl.scala:21:65\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        reversed.toSet.subsetOf(w.asInstanceOf[\e\
    [35mLong\e[0m].asInstanceOf[\e[35mLong\e[0m]) == \e[31mtrue\e[0m\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Found:    Long\n\e[31m   |\e\
    [0m                                Required: scala.collection.Set[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010710
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val max = scala.math.min(w, q.sum.toLong)\n        q.toList.sortWith(_\
    \ <= _) match {\n            case Nil => true\n            case x :: Nil => false\n\
    \            case y :: xs => willItFly(xs, max)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph8k_9vw3.scala:28)\n\tat Problem.main(tmph8k_9vw3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def fly(x : List[Long], q : List[Long], w: Long) : Boolean = {\n    \
    \        if (x == q)\n                return true\n            else if (x != null\
    \ && x.tail.isEmpty)\n                return false\n            else if (x.length\
    \ != q.length)\n                return false\n            else if (x.head != q.reverse)\n\
    \                return false\n            else if (x.head == 0 && q.length !=\
    \ 0 && w == q.length && x.tail.forall(x => x <= q))\n                return true\n\
    \            else\n                return fly(x.tail, q.tail, w - q.length)\n\
    \        }\n        return fly(q, q, w)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpag7foas5.scala:27:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (x.head !=\
    \ q.reverse)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpag7foas5.scala:29:91\
    \ -----------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33melse\e\
    [0m \e[33mif\e[0m (x.head == \e[31m0\e[0m && q.length != \e[31m0\e[0m && w ==\
    \ q.length && x.tail.forall(x => x <= q))\n\e[31m\e[31m   |\e[0m             \
    \                                                                            ^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m<=\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long):\
    \ Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\
    \e[31m   |\e[0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m\
    \   |\e[0mmatch arguments ((q : List[Long]))\n2 errors found\n"
  stdout: ''
  timestamp: 1660010712
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q.isEmpty\n            || (q.length == 1 && q(0)*q(0) == w)\n       \
    \     || (q.length == 1 && q(0)*q(0) > w)\n            || (q.length == 1 && q(0)*q(0)\
    \ <= w)\n            || (q.length == 1 && q(0)*q(0) >= w)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmput8dwrpk.scala:27)\n\tat Problem.main(tmput8dwrpk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010713
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def fly(l : List[Long], r : List[Long]) : Boolean = {\n            l\
    \ == r || fly(l.tail, r.reverse)\n        }\n        fly(q, q.reverse) && w.toLong\
    \ == w.toLong.toLong && w.toLong == w.toLong.toLong || !fly(q, q)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: tail of empty list\n\tat scala.collection.immutable.Nil$.tail(List.scala:664)\n\
    \tat scala.collection.immutable.Nil$.tail(List.scala:661)\n\tat Problem$.fly$1(tmppf69lmbn.scala:21)\n\
    \tat Problem$.willItFly(tmppf69lmbn.scala:23)\n\tat Problem$.main(tmppf69lmbn.scala:27)\n\
    \tat Problem.main(tmppf69lmbn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here.\n        val sum = 0\n        var maxSum = 0\n\
    \        val maxWeight = math.max(w, 1l.toLong)\n        q.reverse.foreach { x\
    \ =>\n            val sum = sum + x\n            if(sum > maxSum) {\n        \
    \        maxSum = sum\n            }\n        }\n        return sum == maxSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphnlwv7ki.scala:25:22 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36msum\e[0m = sum + x\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35msum\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010708
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def weight(n: Long): Long = n * 100l\n\n        def canBeBalanced(w:\
    \ List[Long]): Boolean = { val n = w.last; w match { case Nil => true ; case h\
    \ :: Nil => false; case h :: t => weight(h) <= weight(n) + weight(t) } }\n   \
    \     def isPalindromic(a: List[Long]): Boolean = a.reverse == a\n        val\
    \ maxW = weight + 2 * w // the sum of the last two elements\n        val sumW\
    \ = weight + sum(a) // the sum of the last two elements + the current one\n  \
    \      if (canBeBalanced(q) && sumW < maxW && isPalindromic(q)) true\n       \
    \ else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4vc_t0jl.scala:22:170\
    \ -------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mdef\e[0m \e[36mcanBeBalanced\e\
    [0m(\e[36mw\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m]): \e[35mBoolean\e[0m = { \e\
    [33mval\e[0m \e[36mn\e[0m = w.last; w \e[33mmatch\e[0m { \e[33mcase\e[0m Nil =>\
    \ \e[31mtrue\e[0m ; \e[33mcase\e[0m h :: Nil => \e[31mfalse\e[0m; \e[33mcase\e\
    [0m h :: t => weight(h) <= weight(n) + weight(t) } }\n\e[31m\e[31m   |\e[0m  \
    \                                                                            \
    \                                                                            \
    \                ^\e[0m\n\e[31m   |\e[0m                                     \
    \         Found:    (t : List[Long])\n\e[31m   |\e[0m                        \
    \                      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp4vc_t0jl.scala:24:26 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmaxW\e[0m = weight + \e[31m2\e\
    [0m * w \e[34m// the sum of the last two elements\e[0m\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of Long\
    \ => Long, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp4vc_t0jl.scala:25:26 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msumW\e[0m = weight + sum(a)\
    \ \e[34m// the sum of the last two elements + the current one\e[0m\n\e[31m\e[31m\
    \   |\e[0m                   ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of Long => Long, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m "
  stdout: ''
  timestamp: 1660010714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q.isEmpty || {\n            if (q.isEmpty) true\n            else {\n\
    \                val (l, r) = q.span(_ % 2 == 0)\n                val sum = l.sum\
    \ + r.sum\n                if (sum == w) {\n                    val b = q.reverse.span(_\
    \ % 2 == 0)\n                    if (b.forall(x => x.sum == w) && b.forall(x =>\
    \ x.sum < w)) {\n                        true\n                    } else {\n\
    \                        false\n                    }\n                } else\
    \ {\n                    false\n                }\n            }\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp0cav0h8.scala:27:26 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    \e[33mif\e[0m (b.forall(\e[36mx\e\
    [0m => x.sum == w) && b.forall(\e[36mx\e[0m => x.sum < w)) {\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ forall is not a member of (List[Long], List[Long])\n1 error found\n"
  stdout: ''
  timestamp: 1660010713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def balancedSum(x : List[Long]) : Double = {\n            def sum(z :\
    \ List[Long]) : Double = {\n                z.toStream.foldLeft(0d){ (a, i) =>\
    \ (a + i.toDouble)}\n            }\n            val len = x.length\n         \
    \   if(len == 0) 0d else sum(z) + sum(x.tail) < (w / len.toDouble)\n        }\n\
    \        if(!q.isEmpty) {\n            val len = q.length\n            if(len\
    \ == 0) false\n            else {\n                val sum = 0d\n            \
    \    for( a <- q.toStream) {\n                    sum += a\n                }\n\
    \                if(sum < w / len.toDouble) false\n                else balancedSum(q)\
    \ <= w\n            }\n        }\n        else true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm3l1tcl9.scala:25:37 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mif\e[0m(len == \e[31m0\e[0m) \e[31m0d\e\
    [0m \e[33melse\e[0m sum(z) + sum(x.tail) < (w / len.toDouble)\n\e[31m\e[31m  \
    \ |\e[0m                                     ^\e[0m\n\e[31m   |\e[0m         \
    \                            Not found: z\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpm3l1tcl9.scala:33:24 ------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m                    sum += a\n\e[31m\e[31m   |\e[0m      \
    \              ^^^^^^\e[0m\n\e[31m   |\e[0m               value += is not a member\
    \ of Double - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010714
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q.filter(_ <= w).forall(w => w.toString.reverse.equals(q.toString))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu8zbhdms.scala:23)\n\tat Problem.main(tmpu8zbhdms.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010715
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val newQ = q.filter(_ < w)\n        if(newQ.size == 0)\n            false\n\
    \        else if(newQ.size == 1)\n            true\n        else if(newQ.size\
    \ == 2)\n            newQ.head == newQ.last\n        else\n            newQ.head\
    \ == newQ.reverse.last\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp_ffcd7h.scala:35)\n\tat Problem.main(tmpp_ffcd7h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010715
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val len = q.length\n        val r = scala.collection.mutable.Stack[Int]()\n\
    \        var maxSum = w\n        for(i <- 0 until len) {\n            val currentSum\
    \ = q(i) + r.head\n            if(currentSum > maxSum) maxSum = currentSum\n \
    \           if(r.head > 0 && currentSum > w) r.clear()\n            r.push(i)\n\
    \        }\n        if(r.nonEmpty) r.lastOption.isEmpty else false\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0 is out of bounds (min 0, max -1)\n\
    \tat scala.collection.mutable.ArrayDeque.apply(ArrayDeque.scala:580)\n\tat scala.collection.IndexedSeqOps.head(IndexedSeq.scala:84)\n\
    \tat scala.collection.IndexedSeqOps.head$(IndexedSeq.scala:84)\n\tat scala.collection.mutable.ArrayDeque.head(ArrayDeque.scala:39)\n\
    \tat Problem$.willItFly$$anonfun$1(tmp1_y98u7q.scala:24)\n\tat Problem$.willItFly$$anonfun$adapted$1(tmp1_y98u7q.scala:28)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.willItFly(tmp1_y98u7q.scala:28)\n\
    \tat Problem$.main(tmp1_y98u7q.scala:32)\n\tat Problem.main(tmp1_y98u7q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(p: List[Long]) : Boolean = { p match {\n           \
    \ case Nil => true\n            case x :: Nil => x == 0\n            case xs =>\
    \ xs == x reverse xs\n        }}\n        val isBalanced = isPalindrome(q) &&\
    \ q.sum < w\n        isBalanced && q.forall(x => x < w)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9u7nard1.scala:23:29 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m xs => xs == x reverse xs\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         Not found: x\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.size\n        q.isEmpty || {\n            q.reverse.foldLeft(true)(\
    \ (a,i) => a && {\n                val sum = i.sum\n                if (sum <\
    \ maxSum)\n                    false\n                else\n                 \
    \   sum < w && sum % 2 == 0\n            })\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaua7oi2w.scala:23:28 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mval\e[0m \e[36msum\e[0m = i.sum\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                       value sum is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Base case\n        if (q.isEmpty)\n            return true\n     \
    \   // Check balance\n        else if (q.length == 1)\n            if (q(0) ==\
    \ q(0))\n                return true\n            else\n                return\
    \ false\n        // Compute sum of elements\n        else\n            if (sum(q)\
    \ <= w)\n                if (willItFly(q.tail, w))\n                    return\
    \ true\n                else\n                    return false\n            else\n\
    \                if (willItFly(q.tail, w))\n                    return true\n\
    \                else\n                    return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6bj6ltny.scala:31:16 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mif\e[0m (sum(q) <= w)\n\e[31m\e[31m\
    \   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m                Not found:\
    \ sum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.nonEmpty && w == 0)\n            false\n        else if (q.nonEmpty)\n\
    \            if (w.getOrElse(0) == 0)\n                true\n            else\n\
    \                willItFly(q.reverse, w.getOrElse(0))\n        else\n        \
    \    true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz_thxtgx.scala:23:18 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (w.getOrElse(\e[31m0\e[0m)\
    \ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                value getOrElse is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpz_thxtgx.scala:26:39 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                willItFly(q.reverse, w.getOrElse(\e[31m0\e\
    [0m))\n\e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 value getOrElse is not a\
    \ member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660010716
