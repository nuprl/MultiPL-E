name: HumanEval_72_will_it_fly
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that returns true if the object q will fly, and false otherwise.\n\
  \    // The object q will fly if it's balanced (it is a palindromic list) and the\
  \ sum of its elements is less than or equal the maximum possible weight w.\n   \
  \ // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\n\
  \    // (false)\n    // # 1+2 is less than the maximum possible weight, but it's\
  \ unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
  \ (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more than the maximum\
  \ possible weight.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
  \ (9l))\n    // (true)\n    // # 3+2+3 is less than the maximum possible weight,\
  \ and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)), (5l))\n    //\
  \ (true)\n    // # 3 is less than the maximum possible weight, and it's balanced.\n\
  \    def willItFly(q : List[Long], w : Long) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
  \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
  \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
  \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
  \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
  \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
  \    }\n\n}\n"
completions: ["        def isPalindromic[T](l : List[T]) : Boolean = l match {\n \
    \           case head :: tail => {\n                if (head != tail.head) false\n\
    \                else (isPalindromic(tail.tail))\n            }\n            case\
    \ _ => true\n        }\n\n        def maxPossibleWeight(l: List[Long]) : Long\
    \ = l match {\n            case x :: xs => xs.reduceOption(_ + _).getOrElse(0L)\n\
    \            case _ => 0\n        }\n\n        val l = new ListBuffer[Long]\n\
    \        l += w.toLong\n        q foreach { x => l += x.toLong }\n        val\
    \ w = l.foldRight(-1L)(_ + _)\n        if (w > 0 && w <= maxPossibleWeight(q)\
    \ && isPalindromic(q)) {\n            true\n        }\n        else false", " \
    \       if (q.isEmpty) false\n        val maxSum = q.reduce((a,b) => a + b)\n\
    \        val sumOfElements = q.reduce((a,b) => a + b)\n        val maximum = if\
    \ (sumOfElements > w) sumOfElements else if (sumOfElements < 0) -sumOfElements\
    \ else w\n        val balanced = sumOfElements <= maximum\n        val palindromic\
    \ = sumOfElements == maximum\n        q.reverse.forall(x => x % 10 == 0 && palindromic)",
  '        // Implement here', '        q.length <= 2', "        var ans = false\n\
    \        q.reverse.foreach{ x =>\n            if (q.length == 0) ans = true\n\
    \            if (x > w) ans = false\n            if (q.length == 1 && q == List(x.toLong))\
    \ ans = true\n        }\n        ans", "        val maxW  = Math.pow(10, w).max(10)\n\
    \        var b       = 0\n        var bWeight = 0\n        val w = w.toLong\n\
    \        val q = q.filter {\n            x => b += 1\n            bWeight += x.toLong\n\
    \            bWeight > maxW\n        }\n        val palin = q.reverse.equals(q)\n\
    \        if(palin) b > w*2\n        else bWeight <= w", "        // TODO: Write\
    \ your solution here\n        val result = q match {\n            case x if (x.isEmpty)\
    \ => true\n            case x => if (x.last == x.head) { val r = x.reverse; r\
    \ == x.reverse } else false\n        }\n        result", "        // Hint: use\
    \ 'zip' on Lists\n        q match {\n            case List() => true\n       \
    \     case x :: xs => {\n                // Hint: use 'foldLeft' to loop through\
    \ the list\n                xs.foldLeft(false) {\n                    // Hint:\
    \ compare the sum of elements to the maximum possible weight\n               \
    \     case (true, sum) => (sum < w) || x == xs.last\n                    // Hint:\
    \ if the sum is less than or equal to the maximum possible weight, return true\n\
    \                    case (false, sum) => sum == w\n                }\n      \
    \      }\n        }", "        if (w.isEmpty) true\n        else q.isEmpty &&\
    \ \n        w.sum < q.head", "        val w0 = w.toLong\n        val n = q.length\n\
    \        if (n == 0) true\n        else if (n == 1) true\n        else {\n   \
    \         val head = q(0).toLong\n            val tail = q.drop(1).toList\n  \
    \          val maxWeight = w0 + tail.max\n            if (maxWeight < w0) false\n\
    \            else willItFly(tail, maxWeight)\n        }", "        if(q.isEmpty)\n\
    \            false\n        else if(q.length == 1)\n            true\n       \
    \ else\n            {\n                val totalWeight = sum(q)\n            \
    \    val maxWeight = math.pow(10, math.floor(math.log10(totalWeight)))\n     \
    \           val paliList: List[Long] = q.reverse.takeWhile(_ < maxWeight)\n  \
    \              val listRev = paliList.reverse\n                if(totalWeight\
    \ < maxWeight)\n                    listRev == paliList\n                else\n\
    \                    listRev.last == paliList.last\n            }", "        val\
    \ balance = q.length <= w\n        val total = q.foldLeft(0.0l){(x, y) => x +\
    \ y}\n        balance && total <= w", '        q.sliding(2).forall { case List(i,
    j) => abs(i + j - 2 * w) < w }', "        val maxWeight = w.toLong\n        q\
    \ match {\n          case x :: xs => x.toLong match {\n            case _ if xs.isEmpty\
    \   => true\n            case _ if xs.head < 0 => false\n            case _ if\
    \ xs.last >= maxWeight => true\n            case _ if xs.last == maxWeight =>\n\
    \              val sum = sum(xs)\n              (sum + x.toLong) match {\n   \
    \             case _ if sum == 0 => true\n                case _ if sum < maxWeight\
    \ => false\n                case _ if sum >= maxWeight => true\n             \
    \ }\n            case _ => false\n          }\n          case _ => true\n    \
    \    }", "        if (q.length < 2) true\n        else {\n            // It's\
    \ unbalanced, do something.\n            val maxWeight = q.reduceRight(_+_)\n\
    \            val sumWeight = q.sum\n            if (sumWeight <= maxWeight - w)\
    \ true\n            else false\n        }", "        val maxW = math.pow(w, q.length).toInt\n\
    \        val balanced = q.length % 2 != 0\n        if (balanced) {\n         \
    \   val reverse = ListBuffer(q.last)\n            reverse.reverse\n          \
    \  for (i <- 0 until q.length) reverse = q(i).plus(reverse)\n            val sumOfWights\
    \ = reverse.foldLeft(0l) { (acc, el) => acc + el }\n            sumOfWights <=\
    \ maxW\n        } else {\n            val sumOfWights = q.foldLeft(0l) { (acc,\
    \ el) => acc + el }\n            sumOfWights <= maxW\n        }", "        val\
    \ s = q.sum\n        val l = q.size\n        if (s > w) false\n        else l\
    \ == 0 || (w / s) <= l / 2", "        val ls : List[Long] = reverse(q)\n     \
    \   ls.forall { x =>\n            val y = ls.filterNot(_ == x)\n            val\
    \ sum = sumList(y)\n            (sum == w) && {\n                if(sum < w)\n\
    \                    sum < w\n                else\n                    true\n\
    \            }\n        }", "        // Psuedocode\n        // 1. Sort q in descending\
    \ order of w\n        // 2. Add last element of q to stack\n        // 3. Remove\
    \ top element of stack from stack\n        // 4. Add next element of q to stack\n\
    \        // 5. Repeat until stack is empty\n        // 6. Check for balanced condition\n\
    \        // 7. Returns false if the condition is not satisfied\n        // 8.\
    \ Returns true if condition is satisfied\n        // 9. Sort q in descending order\
    \ of w\n\n        // Psuedocode\n        // 1. Check balanced condition\n    \
    \    // 2. Return false if condition is not satisfied\n        // 3. Else return\
    \ true\n\n        // Psuedocode\n        // 1. Sort q in descending order of w\n\
    \        // 2. Add last element of q to stack\n        // 3. Remove top element\
    \ of stack from stack\n        // 4. Add next element of q to stack\n        //\
    \ 5. Repeat until stack is empty\n        // 6. Check for balanced condition\n\
    \        // 7. Return true if condition is satisfied\n        // 8. Else return\
    \ false\n\n        // Psuedocode\n        // 1. Sort q in descending order of\
    \ w\n        // 2. Add last element of q to stack\n        // 3. Remove top element\
    \ of stack from stack\n        // 4. Add next element of q to stack\n        //\
    \ 5. Repeat until stack is empty\n        // 6. Check for balanced condition\n\
    \        // 7. Return true if condition is satisfied\n        // 8. Else return\
    \ false\n\n        // Psuedocode\n        // 1. Sort q in descending order of\
    \ w\n        // 2. Add last element of q to stack\n        // 3. Remove top element\
    \ of stack from stack\n        // 4. Add next element of q to stack\n        //\
    \ 5. Repeat until stack is empty\n        // 6. Check for balanced condition\n\
    \        // 7. Return true if condition is satisfied\n        // 8. Else return\
    \ false", "        def isPalindromic(xs: List[Long]): Boolean = xs.foldLeft(true)(\
    \ (acc, x) => acc && x.equals(xs.reverse) ) == true\n        def sum(xs: List[Long]):\
    \ Long = xs.foldLeft(0L)( (acc, x) => acc + x )\n        def palindromic(xs: List[Long],\
    \ max : Long): Boolean = xs.foldLeft(true)( (acc, x) => acc && x == (x.toLong\
    \ % max) ) == true\n        val xs = q.toList\n        xs.size == xs.reverse.length\
    \ && sum(xs) <= w && isPalindromic(xs) && palindromic(xs, w)", "        if (q.length\
    \ == 1) {\n            if (q(0) == q(1)) {\n                q.length == 1\n  \
    \          } else {\n                q.length == 0\n            }\n        } else\
    \ {\n            if (q.length % 2 == 0) {\n                val left = q.take(q.length/2).reverse.sorted\n\
    \                val right = q.drop(q.length/2).reverse.sorted\n             \
    \   val maxSum = q.length / 2\n                if (left.sum < w) {\n         \
    \           false\n                } else if (left.sum > w) {\n              \
    \      val left = left.reverse.sorted\n                    if (left.sum < w) {\n\
    \                        false\n                    } else {\n               \
    \         val right = right.reverse.sorted\n                        if (right.sum\
    \ < w) {\n                            false\n                        } else {\n\
    \                            val maxSum = maxSum - left.sum + right.sum\n    \
    \                        maxSum == w\n                        }\n            \
    \        }\n                } else {\n                    val left = left.reverse.sorted\n\
    \                    if (left.sum < w) {\n                        false\n    \
    \                } else {\n                        val right = right.reverse.sorted\n\
    \                        if (right.sum < w) {\n                            false\n\
    \                        } else {\n                            val maxSum = maxSum\
    \ - left.sum + right.sum\n                            maxSum == w\n          \
    \              }\n                    }\n                }\n            } else\
    \ {\n                val left = q.take(q.length/2).reverse.sorted\n          \
    \      val right = q.drop(q.length/2).reverse.sorted\n                val maxSum\
    \ = q.length / 2\n                if (left.sum < w) {\n                    false\n\
    \                } else if (left.sum > w) {\n                    val left = left.reverse.sorted\n\
    \                    if (left.sum < w) {\n                        false\n    \
    \                } else {\n                        val right = right.reverse.sorted\n\
    \                        if (right.sum < w) {\n                            false\n\
    \                        } else {\n                            val maxSum = maxSum\
    \ - left.sum + right.sum\n                            maxSum == w\n          \
    \              }\n                    }\n                } else {\n          \
    \          val left = left.reverse.sorted\n                    if (left.sum <\
    \ w) {\n                        false\n                    } else {\n        \
    \                val right = right.reverse.sorted\n                        if\
    \ (right.sum < w) {\n                            false\n                     \
    \   } else {\n                            val maxSum = maxSum - left.sum + right.sum\n\
    \                            maxSum == w\n                        }\n        \
    \            }\n                }\n            }\n        }", "        val p =\
    \ (q :+ q.reverse) match {\n            case Nil => true\n            case head\
    \ :: tail => palindrome(head :: tail) && (q.sum < w)\n        }\n        p", " \
    \       val max = Long.MaxValue\n        q.length <= w && (q.length == 0 || (q.length\
    \ == 1 && q.head <= max))", "        val sumOfWeights = q.map(x => x.toLong).sum\n\
    \        if (sumOfWeights <= w) true\n        else false", "        val list =\
    \ q.toList\n        val maxWeight = w\n        val listSize = list.length\n  \
    \      val sumOfElements = list.sum\n        if (listSize == 0 || sumOfElements\
    \ > maxWeight) {\n            return false\n        }\n        val reverseList\
    \ = reverse(list)\n        val reverseSum = reverseList.sum\n        if (reverseSum\
    \ > maxWeight) {\n            return false\n        }\n        val diff = maxWeight\
    \ - sumOfElements\n        if (diff > 0) {\n            return true\n        }\n\
    \        val reverseDiff = reverseSum - maxWeight\n        if (reverseDiff > 0)\
    \ {\n            return true\n        }\n        reverseList.forall(element =>\
    \ element < maxWeight)", "        var flag : Boolean = false\n        var i =\
    \ 0\n        var l = 0\n        while(i < q.size && !flag) {\n            l =\
    \ i\n            val x = q(i)\n            for(j <- i until q.size) {\n      \
    \          val y = q(j)\n                if(y < x) l = j\n            }\n    \
    \        if(l != i && q(i) == q(l)) {\n                flag = true\n         \
    \       break\n            }\n            i += 1\n        }\n        return flag",
  "        var sum = 0\n        var max = 0\n        val myList = (q: _*)\n      \
    \  myList.foreach { e => sum = sum + e }\n        if (sum < w) false\n       \
    \ else {\n            for (x <- myList) {\n                if (x == 0) return\
    \ false\n                if (sum + x < w) max = Math.max(sum + x, max)\n     \
    \       }\n            if (max > w) true\n            else willItFly(q, w)\n \
    \       }", "        var maxSum = w.toLong\n        var sum = 0\n\n        for(\
    \ i <- 0 until q.size){\n            sum = sum + q(i)\n            if(sum > maxSum){\n\
    \                maxSum = sum\n            }\n        }\n        if((sum == maxSum)\
    \ && (q.reverse.forall( x => q(0) == x))){\n            return true\n        }\n\
    \        return false", "        // Your code goes here\n        val maxW = (w.toDouble\
    \ / 2.0).toLong\n        val sum = 0\n        val len = q.size\n        for(i\
    \ <- 0 until len) {\n          val x = q(i).toLong\n          val y = math.max(x\
    \ * 2 - w, 0l).toLong\n          sum += y\n        }\n        len == (sum.toDouble\
    \ <= maxW && sum == sum && q == q.reverse)", "        var sum = 0\n        q.foreach\
    \ {\n            x => sum += x\n        }\n        sum < w && q.reverse.forall\
    \ {\n            x => sum += x\n        }\n        sum < w", "        def lSum(l\
    \ : List[Long]) : Long = {\n            val total = 0\n            var i = 0\n\
    \            while (i < l.length) {\n                total += l(i).toLong\n  \
    \              i += 1\n            }\n            total\n        }\n        //\
    \ Write your logic here\n        val maxW = l * w\n        if (maxW.toDouble *\
    \ maxW.toDouble < lSum(q) * q.toDouble && lSum(q) <= maxW.toDouble * maxW.toDouble)\
    \ {\n            (maxW.toDouble * maxW.toDouble <= lSum(q) * q.toDouble && lSum(q)\
    \ <= maxW.toDouble * maxW.toDouble)\n        }", '        q.size() == q.reverse.size()
    && q.sum <= w', "        // TODO:\n        // Implement this function using a\
    \ fold.\n        q.reverse.foldLeft(false){(acc, el) => if (acc) el + acc >= w\
    \ else acc}", "        val maxWays = q.length * w\n        val ways = q.toStream.foldLeft(0)(_\
    \ + _)\n        ways <= maxWays", "        val l = q.length\n        if (l ==\
    \ 1) true\n        else if (l == 2 || l == 3) true\n        else if (l == 4 &&\
    \ q.sum - w <= 0) true\n        else false", "        def isBalanced (xs: List[Long])\
    \ : Boolean = {\n            val l = xs.size\n            if (l == 0) true\n \
    \           else {\n                val max = (xs zip xs.reverse).max\n      \
    \          val min = (xs zip xs.reverse).min\n                val (min1, max1)\
    \ = min._1, max._1\n                val diff = (max1 - min1) + w\n           \
    \     if (diff < 0)\n                    false\n                else if (diff\
    \ == 0)\n                    true\n                else {\n                  \
    \  if (diff < min1) false\n                    else if (diff == min1) true\n \
    \                   else {\n                        val (x1, x2) = xs.splitAt(l)\n\
    \                        val a = xs.filter(_ != x1)\n                        val\
    \ b = xs.filter(_ != x2)\n                        val aIsBalanced = isBalanced(a)\n\
    \                        val bIsBalanced = isBalanced(b)\n                   \
    \     val allAreBalanced = aIsBalanced && bIsBalanced\n                      \
    \  if (allAreBalanced) true\n                        else false\n            \
    \        }\n                }\n            }\n        }\n\n        isBalanced(q)",
  "        def isBalanced(l: Seq[Long]): Boolean = {\n            // The sum of its\
    \ elements is less than or equal the maximum possible weight w.\n            val\
    \ sum = l.toSet.sum\n            l == l.reverse\n        }\n        def isPalindrome(l:\
    \ List[Long]) = {\n            val l = l.toList\n            l.tail == l.init\
    \ &&\n            l.head == l.last &&\n            l.reverse.tail == l.reverse.init\n\
    \        }\n        val l = q.toList\n        // q fly, if balanced and sum <\
    \ w\n        isBalanced(q) && isPalindrome(l) && sumLessOrEqual(l, w)", "    \
    \    if (q.size < 2) true\n        else {\n            val maximumWeight = w -\
    \ q.sum\n            q.reverse.tail.forall(l => l <= maximumWeight && !q.reverse.exists(_\
    \ == l))\n        }", "        val totalWeight = q.sum\n        if (totalWeight\
    \ <= w) return true\n        val reverse = q.reverse\n        val currentIndex\
    \ = reverse.indexOf(0)\n        while (currentIndex >= 0 && !reverse.exists(x\
    \ => x == currentIndex)) {\n            reverse = reverse.reverse\n          \
    \  currentIndex = reverse.indexOf(0)\n        }\n        reverse == q || (!reverse.exists(x\
    \ => x == currentIndex) && totalWeight <= w)", "        def addPalindrome(a: Long,\
    \ b: Long, ac: Array[Long], bc : Array[Long], x: Long) : Unit = {\n          \
    \  if (a > b || b > x)\n                return\n            if (a == b){\n   \
    \             ac(0) = x\n                bc(0) = x\n                addPalindrome(a+1,\
    \ b, ac, bc, x)\n            }\n            else if (a == x && b == x){\n    \
    \            ac(0) = x\n                bc(0) = x\n                addPalindrome(a+1,\
    \ b, ac, bc, x)\n                addPalindrome(a+1, b+1, ac, bc, x)\n        \
    \    }\n            else{\n                ac(0) = x\n                bc(0) =\
    \ x\n                addPalindrome(a+1, b, ac, bc, x)\n                addPalindrome(a+1,\
    \ b+1, ac, bc, x)\n                addPalindrome(a+1, b+1, ac, bc, x)\n      \
    \          addPalindrome(a+1, b+1, ac, bc, x)\n                addPalindrome(a+1,\
    \ b+1, ac, bc, x)\n                addPalindrome(a+1, b+1, ac, bc, x)\n      \
    \      }\n        }\n\n        def isPalindrome(a: Long, b: Long, ac : Array[Long],\
    \ bc : Array[Long], x : Long) : Boolean = {\n            if (a > b || b > x)\n\
    \                return false\n            if (ac(0) != x)\n                return\
    \ false\n            if (bc(0) != x)\n                return false\n         \
    \   if (a == x && b == x){\n                return true\n            }\n     \
    \       else{\n                return true\n            }\n        }\n\n     \
    \   def balance(a: Long, b: Long, ac: Array[Long], bc : Array[Long], x: Long)\
    \ : Unit = {\n            if (a > b || b > x)\n                return\n      \
    \      if (a == b){\n                ac(0) = x\n                bc(0) = x\n  \
    \          }\n            else if (a == x && b == x){\n                ac(0) =\
    \ x\n                bc(0) = x\n            }\n            else{\n           \
    \     ac(0) = x\n                bc(0) = x\n                addPalindrome(a+1,\
    \ b, ac, bc, x)\n                addPalindrome(a+1, b+1, ac, bc, x)\n        \
    \    }\n        }\n\n        var ac = new Array[Long](q.size)\n        var bc\
    \ = new Array[Long](q.size)\n        var a = 0\n        var b = 0\n        var\
    \ x = 0\n        var total = 0\n        var maxWeight = 0\n\n        def maxWeight\
    \ () : Long = {\n            var maxWeight = 0\n            var i = 0\n      \
    \      while (i < q.size) {\n                var x = q(i)\n                if\
    \ (", "        val palindrome = q.reverse.forall(q.equals)\n        val maximum\
    \ = q.sum\n        (palindrome && maximum >= w) && maximum == q.max", "      \
    \  val reverse = List.reverse(q)\n        var sum = 0\n        var num = 0\n \
    \       for( i <- 1 to reverse.length ){\n            sum = sum + reverse(i)\n\
    \            num = num + 1\n        }\n        if( (reverse.length == 0) || (sum\
    \ == 0) ){\n            return false\n        }\n        val x = reverse(0)\n\
    \        var y = reverse(0)\n        for( i <- 1 to reverse.length ){\n      \
    \      y = y + (reverse(i) / num) * (x/y)\n        }\n        val z = reverse(0)\n\
    \        if(z > w){\n            return true\n        }\n        return false",
  "        val max = List(0l).zip(q.takeWhile(!_.isZero)).reduce(_ + _)\n        if\
    \ (q.forall(_.isZero) || q.forall(_.isEven) && max <= w) true else false", " \
    \       var maxW = 0\n        var q = q.asInstanceOf[List[Long]]\n        var\
    \ wSum : Long = 0\n        var isBalanced : Boolean = true\n        while (!q.isEmpty\
    \ && q.length != maxW) {\n            if (maxW == 0) maxW = q.length\n       \
    \     wSum += q(0)\n            q = q.tail\n        }\n        if (q.length ==\
    \ maxW && maxW == w) {\n            isBalanced = true\n        } else if (q.length\
    \ == maxW) {\n            isBalanced = false\n        } else if (wSum == 0 ||\
    \ wSum > maxW) {\n            isBalanced = false\n        } else {\n         \
    \   isBalanced = true\n        }\n        return isBalanced", '        q.tail.isEmpty
    && (q.isEmpty || w<=q.head || w>q.last)', "        val reverse = q.asInstanceOf[mutable.Stack[Long]].toList.reverse\n\
    \        if(reverse.last.isDefined && w <= reverse.last.get) {\n            true\n\
    \        } else if(q.size == 1) {\n            true\n        } else if(q.size\
    \ > 1 && reverse.last.isDefined && reverse.last.get.asInstanceOf[Long] <= w) {\n\
    \            true\n        } else {\n            false\n        }", "        val\
    \ reverse = q.reverse.map(x => x.toLong)\n        val sumOfElements = reverse.foldLeft(0)(_\
    \ + _)\n        sumOfElements <= w", "        val n = q.length\n        val l\
    \ = q.map(x => math.abs(x)).reduce(_ + _)\n        if (l == 0) true\n        else\
    \ if (math.abs(w) < l) false\n        else willItFly(q.tail, w)", "        //\
    \ Check balance\n        val p = q.reverse\n        var bal = true\n        p\
    \ foreach { n =>\n            if (n > w) bal = false\n        }\n        (bal\
    \ && p.length == q.length)", "        // Write your code here\n        q.reverse.forall(_\
    \ <=w)", "        val maxW : Long = w.toLong\n\n        q.isEmpty || {\n     \
    \       val p = q.reverse\n            val pS = p.sum\n            val maxP =\
    \ p.max\n\n            maxP >= maxW && pS == p.reverse.sum\n        }", "    \
    \    val maxWeight = w.toLong\n        val sumQ = q.foldLeft(0)(_ + _)\n     \
    \   sumQ <= maxWeight && isPalindrome(q)", '      q.reverse.forall(x => x<w)',
  '        // Complete the function', "        var maxWeight = w\n        var balanced\
    \ = true\n        var listPalindromic = q.reverse.equals(q) //to check if the\
    \ list is palindromic or not\n        var sum = 0\n        var wSum = 0\n\n  \
    \      if (listPalindromic) {\n            sum = 0\n            for (i <- 0 until\
    \ q.size) {\n                sum = sum + q(i)\n            }\n            if (sum\
    \ < w) {\n                sum = 0\n            } else {\n                sum -=\
    \ w\n            }\n            if (sum < 0) {\n                balanced = false\n\
    \            }\n        }\n\n        if (!listPalindromic) {\n            listPalindromic\
    \ = (q.head == q.last)\n        }\n\n        if ((!listPalindromic) && balanced)\
    \ {\n            maxWeight = w\n            sum = 0\n            wSum = 0\n  \
    \          balanced = false\n            for (i <- 0 until q.size) {\n       \
    \         sum = sum + q(i)\n                wSum = wSum + q(i)\n            }\n\
    \            if (sum < w) {\n                sum = 0\n            } else {\n \
    \               sum -= w\n            }\n            if (sum < 0) {\n        \
    \        balanced = false\n            }\n        }\n\n        if (listPalindromic\
    \ && balanced && sum < w) {\n            balanced = false\n        }\n       \
    \ if (listPalindromic && balanced && sum > w) {\n            balanced = false\n\
    \        }\n\n        if (listPalindromic && balanced && sum == w) {\n       \
    \     balanced = false\n        }\n\n        if (!listPalindromic && !balanced)\
    \ {\n            maxWeight = w\n            sum = 0\n            wSum = 0\n  \
    \          for (i <- 0 until q.size) {\n                sum = sum + q(i)\n   \
    \             wSum = wSum + q(i)\n            }\n            if (sum < w) {\n\
    \                sum = 0\n            } else {\n                sum -= w\n   \
    \         }\n            if (sum < 0) {\n                balanced = false\n  \
    \          }\n        }\n\n        return balanced", "        val result = true\n\
    \        var w1 = w\n        var w2 = w\n\n        q.foreach { x =>\n        \
    \    if (w1 < x)\n                result = false\n            w1 = x\n       \
    \ }\n\n        // we already tested if the list is balanced, so we know w2 = w1\
    \ - 1\n        val x = q.last\n        w2 = w1 - 1\n\n        if (w2 == x)\n \
    \           result = true\n\n        result", "        val totalSum : Long = q.reduceLeftOption(\
    \ _ +  _ ).map(_.toLong).getOrElse(0l)\n        val totalWeight = totalSum * w\n\
    \        if(totalWeight <= 1L) {\n            return false\n        }\n      \
    \  val max = totalWeight % maxPossibleWeight\n        val min = 1L / maxPossibleWeight\n\
    \        if(totalSum > max) {\n            return false\n        }\n        val\
    \ factorizable = totalWeight % maxPossibleWeight != 0\n        if(factorizable)\
    \ {\n            val f = maxPossibleWeight / max\n            val remainder =\
    \ totalWeight % f\n            val leftSide = q.head\n            val rightSide\
    \ = q.reverse.head\n            val factor = isPalindrome(leftSide) * isPalindrome(rightSide)\n\
    \            if(factor != factorizable) {\n                return false\n    \
    \        }\n        }\n        if(totalSum < min) {\n            return false\n\
    \        }\n        true", "        if (q.isEmpty || q.length <= 0 || w <= 0)\
    \ {\n            false\n        }\n        else {\n            if (q.length %\
    \ 2 == 0) {\n                // odd\n                var maxWeight = w\n     \
    \           for (i <- 0 until q.length / 2) {\n                    if (q(i) >\
    \ maxWeight) {\n                        maxWeight = q(i)\n                   \
    \ }\n                }\n                val sum = maxWeight + q(q.length / 2)\n\
    \                if (sum < w) {\n                    false\n                }\n\
    \                else {\n                    if (sum == w) {\n               \
    \         true\n                    }\n                }\n            }\n    \
    \        else {\n                // even\n                var maxWeight = w\n\
    \                var sum = 0\n                for (i <- 0 until q.length) {\n\
    \                    sum += q(i)\n                    if (sum > maxWeight) {\n\
    \                        maxWeight = sum\n                    }\n            \
    \    }\n                if (maxWeight <= w) {\n                    true\n    \
    \            }\n                else {\n                    false\n          \
    \      }\n            }\n        }", '        // Solution below', "        val\
    \ max = scala.math.max(w, q.sum.toLong)\n        val balance = q.toList.foldLeft(0)((x,\
    \ y) => (x + y) % max != 0)\n        if (balance) {\n            (q.toList ==\
    \ q.reverse.reverse)\n        } else {\n            (q.toList.length == (max -\
    \ q.sum))\n        }", "        val fly = false\n        var q = List(q)\n   \
    \     var i = 0\n        var maxWeight = w\n        while(i < q.size) {\n    \
    \        if(q(i + 1) > q(i)) {\n                maxWeight = q(i)\n           \
    \ }\n            i += 1\n        }\n        while(i < q.size) {\n            if(!q(i).equals(q(i\
    \ + 1))) {\n                fly = true\n                break\n            }\n\
    \            i += 1\n        }\n        if(fly) {\n            true\n        }\
    \ else {\n            val sum = 0\n            for(i <- 0 until q.size) {\n  \
    \              sum += q(i)\n            }\n            sum <= maxWeight\n    \
    \    }", "        def isBalanced(ls: List[Long]) : Boolean = ls.head == ls.last\
    \ // check whether it is a palindrome\n        def sumOfElements(ls: List[Long])\
    \ : Long = ls map (_.toLong) reduceLeft (_ + _) // sum of all the elements\n \
    \       def calculateMaxPossibleWeight(balancedLs: List[Long]) : Long = // max\
    \ possible weight", "        if (q.isEmpty) true\n        else {\n           \
    \ var sum = 0L\n            var maxWeight = 0L\n            val tempList = q.tail\n\
    \            var maxSum = 0L\n            val maxSumIndex = 0\n            q.headOption\
    \ match {\n                case Some(x) => sum += x\n                case None\
    \ => return false\n            }\n            for (x <- tempList) {\n        \
    \        sum += x\n                if (sum > maxWeight) {\n                  \
    \  maxSum = sum\n                    maxSumIndex = tempList.indexWhere(_ == x)\n\
    \                }\n                if (sum >= w && maxSum < w) {\n          \
    \          return true\n                }\n            }\n            false\n\
    \        }", "        // Write your code here\n        val maxSum = w.fold(math.Long.MinValue)((a,\
    \ b) => math.max(a, b))\n        val numElements = q.size\n        val numPairs\
    \ = q.size / 2\n        val maxWeight = w.max\n        val maxCount = (numElements\
    \ - numPairs) / 2\n\n        if (numPairs < 1 || numElements <= numPairs) {\n\
    \            false\n        }\n        else if (q.size % 2 == 0) {\n         \
    \   if (maxSum == 0) {\n                true\n            }\n            else\
    \ if (maxSum - q.tail.sum == 0l) {\n                true\n            }\n    \
    \        else {\n                false\n            }\n        }\n        else\
    \ {\n            if (maxCount != (q.size / 2)) {\n                false\n    \
    \        }\n            else if (maxWeight < w || maxSum == 0) {\n           \
    \     true\n            }\n            else if (maxSum - q.tail.sum == 0l) {\n\
    \                true\n            }\n            else {\n                false\n\
    \            }\n        }\n", "        val maximumWeight = w + 1l\n        if\
    \ (q.isEmpty) true\n        else if(q.head <= maximumWeight && q.reverse.tail.isEmpty)\
    \ true\n        else false", "        val maxW = Math.max(w, q.sum)\n        if\
    \ (maxW <= 0) false\n        else {\n            val reversed = List(q.reversed)\n\
    \            val allEven = reverse(List(reversed.takeWhile(!_ % 2).toList)).length\
    \ == 1\n            val allOdd = reverse(List(reversed.takeWhile(!_ % 2).toList)).length\
    \ == 0\n            (reversed == List(q.reversed) && allEven && allOdd) || maxW\
    \ < q.sum\n        }", '        q.reverse.foldLeft(false)((acc, x) => acc || (x
    == w.reverse) && (q.sum < w))', "        def balanced(i : Int, j : Int) = {\n\
    \            val q = q.take(i)\n            val l = q.take(j)\n            q.take(j\
    \ - i) sameElements l\n        }\n        // Base case\n        if (q.isEmpty)\
    \ false\n        else {\n            // We only care about the first element,\
    \ no need to check each element to see if it will fly.\n            val l = q.head\n\
    \            // If l's sum isn't within limits, it's unbalanced and it won't fly.\n\
    \            if (!(l < w) && !balanced(1, l.length)) false\n            else {\n\
    \                // We need to check the rest of the list to see if it will fly.\n\
    \                // If so, then return true\n                if (balanced(0, l.length))\
    \ true\n                else false\n            }\n        }", "        // Your\
    \ code here\n        val maxW: Long = w.toLong\n        q.reverseIterator.forall(x\
    \ => x > maxW)", "        var q2 : List[Long] = q.reverse\n        var i = 0\n\
    \        var sum = 0\n        val max = w\n        while(i < q.size && sum < max)\
    \ {\n            sum += q.apply(i)\n            i += 1\n        }\n        if(q.size\
    \ == i) {\n            (sum == max)\n        } else if(sum > max) {\n        \
    \    false\n        } else {\n            willItFly(q2, max)\n        }", "  \
    \      q match {\n            case Nil => false\n            case l :: tail =>\
    \ {\n                if (w < l.sum) false else if (q.isEmpty || q.isDefinedAt(q.length-1))\
    \ true else willItFly(tail, w)\n            }\n        }", "        var maxWeight\
    \ = w;\n        var maxCount = q.size;\n        val maxItem = q(0);\n        if\
    \ (maxCount == 0)\n            return true;\n        for (i <- 1 to q.size)\n\
    \            maxCount += q(i) - maxItem;\n        if (maxCount < maxWeight)\n\
    \            return false;\n        val q2 = q.map(x => x.toLong);\n        val\
    \ rev = q2.reverse;\n        val palindromes = q2.filter(rev);\n        val diff\
    \ = math.min(maxWeight, palindromes.size);\n        var sum = 0L;\n        var\
    \ count = 1;\n        for (item <- palindromes)\n            sum += item;\n  \
    \      val diff = math.min(diff, sum);\n        var last = 0;\n        for (i\
    \ = q2.size - 1 to 0 by -1)\n            if (q2(i) == last && diff > w)\n    \
    \            return false;\n            if (q2(i) == last && diff == w)\n    \
    \            return true;\n            else\n                last = q2(i);\n \
    \       return false;", "        val q = q.tail.reverse\n        val w = w.toInt\n\
    \        val maxW = Math.sqrt(w).toInt\n        val qS = q.sum\n        val maxW\
    \ = maxW * maxW\n        var fly = true\n        q.foreach { x => \n         \
    \   if (x <= maxW && qS <= w) fly = false\n            else if (qS == w) fly =\
    \ true\n            else fly = false\n        }\n        fly", "        val palindromic\
    \ = q.reverse.forall(qe => qe < w)\n        if (palindromic) {\n            val\
    \ totalWeight = q.sum\n            totalWeight <= w\n        } else {\n      \
    \      false\n        }", "        // Use mutable sets to store all the elements\
    \ in the list that are less than or equal to the maximum possible weight.\n  \
    \      // This operation is O(1).\n        // Keep a Set of all the elements that\
    \ haven't reached the maximum possible weight yet.\n        // This operation\
    \ is O(n).\n        var elements = scala.collection.mutable.Set.empty[Long]\n\
    \        for (x<-q) {\n            if (x < w) {\n                elements += x\n\
    \            }\n        }\n\n        // Find the maximum possible weight of the\
    \ set.\n        // This operation is O(1).\n        var maxW = 0l\n        for\
    \ (x<elements) {\n            if (x > maxW) {\n                maxW = x\n    \
    \        }\n        }\n\n        // If the maximum possible weight is less than\
    \ or equal the weight, return true.\n        return maxW <= w", "        val maxPossibleWeight\
    \ = w + q.sum\n        q.isEmpty || \n        q.toList == q.reverse.tail &&\n\
    \        q.sum >= w &&\n        q.reduceLeft(_ + _) <= maxPossibleWeight", " \
    \     val pw = List.reverse(q).map(_.toLong).sum\n      pw <= w && pw.toLong ==\
    \ w", "        val maxWeight : Long = w.toLong\n        q.length == 1 && maxWeight\
    \ <= 0", "        val reverseList = List.reverse(q)\n        val balanced = checkBalance(reverseList,\
    \ w)\n        val sum = reverseList.sum\n        balanced && sum <= w", "    \
    \    var x = List[Long]()\n        var y = List[Long]()\n        for(q <- q.reverse)\
    \ {\n            if(q.isEmpty) {\n                q.reverse()\n              \
    \  continue\n            }\n            x :+ q(0)\n            y :+ q(0)\n   \
    \     }\n        if(x.size == 0 || y.size == 0 || w <= 0 || w > x.head || w >\
    \ y.head) {\n            return false\n        }\n        val a = x.last\n   \
    \     val b = y.last\n        val m = (b - a).abs\n        if(m > w || x.head\
    \ % 2 == y.head % 2) {\n            return false\n        }\n        (x.tail,\
    \ y.tail).foldRight(true) {\n            (x: List[Long], y: List[Long]) => if\
    \ (x == y) false else if (x.size == 1 && y.size == 1 && m.toDouble == x.head /\
    \ y.head) true else willItFly(x, w)\n        }(false)", "        val sumList =\
    \ q.foldLeft(0l) { (x,y) => (x + y) % w == 0 }\n        sumList == 0 || sumList\
    \ == w", "        var max = 0L\n        var sum = 0L\n        var fly = false\n\
    \        var i = q.size-1\n        // go through list\n        while (i >= 0)\
    \ {\n            // if the current weight is more than the maximum,\n        \
    \    if (q(i) > max)\n                // set max weight and reset sum to zero.\n\
    \                max = q(i)\n                sum = 0L\n            // add the\
    \ weight to the sum\n            sum += q(i)\n            // if sum is equal to\
    \ the weight, it's balanced\n            if (sum == w) {\n                fly\
    \ = true\n                break\n            }\n            // if sum is greater\
    \ than the maximum, it's unbalanced\n            if (sum > max) {\n          \
    \      fly = false\n                break\n            }\n            // go back\
    \ one and decrement the sum\n            i -= 1\n        }\n        return fly",
  "        var b : Boolean = true\n        val l = q.reverse\n        val l = l.takeWhile(_\
    \ < w)\n        if (l.length == 1) {\n            b = false\n        }\n     \
    \   if (l.length == q.size) {\n            val l = q.reverse\n            val\
    \ l = l.takeWhile(_ >= w)\n            if (l.length == 0) {\n                b\
    \ = false\n            }\n        }\n        b", "        // Code here\n     \
    \   val list = q.sortWith((x, y) => x-y)\n        if (list.length < 1) true\n\
    \        else {\n            var sum = 0L\n            var maximum = 0L\n    \
    \        list.foreach {\n                if (sum+_ > maximum) maximum = sum+_\n\
    \                sum += _\n            }\n            list.length == maximum &&\
    \ (sum <= w)\n        }", "        // Initialize maxWeight as the maximum possible\
    \ weight.\n        var maxWeight = w\n        for (i <- 0 until q.size) {\n  \
    \          // Get the current balance, and if it's more than maxWeight, set maxWeight\
    \ to the current balance (and break the loop).\n            val balance = q.iterator.scanLeft(0){case\
    \ (sum, e) => if (e > maxWeight) sum + e else sum}.sum\n            if (balance\
    \ > maxWeight) maxWeight = balance else false\n        }\n        // Return true\
    \ if the object q will fly, and false otherwise.\n        q.forall(e => e <= maxWeight)\
    \ && q.size == q.reverse.size && q.reverse.toSet == q.toSet", "        val l =\
    \ new ListBuffer[Long]()\n        val m = new mutable.ListBuffer[Long]()\n   \
    \     q.foreach(x => l += x)\n        l.sorted.reverse.foreach(x => m += x)\n\
    \        m.sorted.toList == l.reverse", "        if (q.isEmpty) return false\n\
    \        val wSum = w.toInt\n        val pal = q.reverse\n        val sum = pal.sum\n\
    \        return sum >= wSum", "        val maxWght = if (w.isInstanceOf[Int])\
    \ w else 0\n        var balanced = true\n        var sum = 0\n        q.foreach\
    \ {x => sum = sum + x; balanced = balance && sum >= maxWght}\n        balanced",
  "        //TODO: implement\n        //TODO: compare the sum of the elements of the\
    \ list q to w", "        val maxWeight : Long = w\n        val minWeight : Long\
    \ = 0\n        var i = 0\n        val qList = (q.toIterator.mkString)\n      \
    \  while (qList.substring(i, i + 1).size != 0) {\n            val j = i + 1\n\
    \            val k = 0\n            while (qList.substring(j, j + 1).size != 0)\
    \ {\n                val l = j + 1\n                if (qList.substring(l, l +\
    \ 1).size > 0) {\n                    if (minWeight > 0) minWeight = qList.substring(l,\
    \ l + 1).sum\n                }\n                k += 1\n                l +=\
    \ 1\n            }\n            i += 1\n        }\n        if (qList.substring(i,\
    \ i + 1).size == 0 && minWeight > 0 && maxWeight > 0) return true\n        else\
    \ if (qList.substring(i, i + 1).size > 0 && minWeight > 0 && maxWeight < minWeight)\
    \ return true\n        else if (qList.substring(i, i + 1).size < 0 && minWeight\
    \ < 0 && maxWeight < minWeight) return true\n        else return false", "   \
    \     val palindromic = q\n        val sum = 0l\n        val weightSum = List(0.toLong,\
    \ w.toLong).sum\n\n        palindromic.reverse.foreach { x => sum = sum + x }\n\
    \n        (sum <= weightSum) && (palindromic.length <= weightSum)", '        //
    TODO: Write the function', "        if (q.isEmpty) false\n        else if (q.tail.isEmpty)\
    \ false\n        else {\n            val sumOfWeight = q.tail.foldLeft(0l) { (totalWeight,\
    \ curWeight) =>\n                totalWeight + curWeight\n            }\n    \
    \        if (sumOfWeight > w) true\n            else willItFly(q.tail, w)\n  \
    \      }", "        val maxSum = w\n        var sum = 0l\n        val palindromic\
    \ = q.palindrome\n        palindromic.reverseIterator.foreach {\n            n\
    \ => sum += n\n        }\n        sum < maxSum && palindromic.isEmpty", "    \
    \    // Your code goes here.\n        val maxSum : Long = w.toLong\n        q.isEmpty\
    \ || q.toString.reverse.tail.forall( l => l < w && l <= maxSum )", '        //
    TODO - your code here', "        // TODO: Write a recursive function\n       \
    \ def balance(li : List[Long]) : Boolean = {\n            val l = li.toSet\n \
    \           l.length == 1 && l(0) == l(1)\n        }\n\n        val n = q.length\n\
    \        val max = BigInt(w).pow(n.toDouble)\n        for( i <- 0 until n ) {\n\
    \            if( q(i).toString != q(n-i).toString && q(i).toDouble < max ) {\n\
    \                return false\n            }\n        }\n\n        balance(q)\
    \ && q.length < max", "        val palindromic = p.forall(q.size == q.size)\n\
    \        val elementSumLessOrEqualToWayWeight = q.zip(q.tail).map { case (e, i)\
    \ => e + i } <= w\n        val balanced = palindromic && elementSumLessOrEqualToWayWeight\n\
    \        !balanced", "      def sum(a : Long) : Long = a.reduceLeft(_ + _)\n \
    \     val l = q.length\n      if (l == 0) true\n      else if (l == 1) true\n\
    \      else {\n        val maxWeight = w / (l / 2)\n        val maxSum = sum(q(0)\
    \ + q(l)) - w\n        val maxSumAbs = math.abs(maxSum)\n        val maxSumAbsDiff\
    \ = math.abs(maxSumAbs - maxWeight)\n        val maxSumAbsDiff <= maxWeight ->\
    \ maxSumAbsDiff\n      }", "        val maxSum = w.toString.toDouble.max // 5l\n\
    \        val wSum = q.reduce(_ + _) // 3+2+3\n        if (wSum == maxSum && q.isEmpty)\n\
    \            true\n        else\n            false", "        val palindromic_q\
    \ = checkPalindrome(q)\n        val sum_qw = q.sum\n        val max_weight = math.min(w,sum_qw)\n\
    \        (max_weight == sum_qw) && palindromic_q", "        val sumList = q.toList.sum\n\
    \        val max = math.max(w, sumList)\n        (sumList <= max) && (q.isInstanceOf[List[Long]])\
    \ && (q.toList.isInstanceOf[ListBuffer[Long]])", "        val maxW = w.toLong.toInt.abs\n\
    \        val maxQ = w.fold(0)(_ + _)\n        val maxQList = if (maxQ.signum ==\
    \ 1) List(maxQ) else List(-maxQ)\n        val res = (maxQList.size == q.size)\
    \ && maxQList.forall(q => q < maxW)\n        res", "        val reversedList =\
    \ q.reversed\n        val sumList = reversedList.map(_.toLong).sum\n        val\
    \ maxWeight = q.length * w.toLong\n        val isBalanced = sumList <= maxWeight\n\
    \        isBalanced", "        val qSet = q.toSet\n        val qSetSize = qSet.size\n\
    \        val listSize = q.size\n        val maxWeight = w / 2\n        qSet.isEmpty\
    \ || qSet.forall(w >= _) && qSet.size == listSize && listSize <= maxWeight &&\
    \ ((q.sum.toLong == listSize) || (listSize == maxWeight && (q.sum.toLong == w)))",
  "        // write your solution here\n        return true", "        val maxWeight\
    \ = w\n        val palindromic = q.reverse.forall(_.isReverse)\n        val sum\
    \ = q.reduceLeft(_ + _)\n\n        if( palindromic && sum < maxWeight )\n    \
    \        true\n        else\n            false", "        val w = q.head\n   \
    \     val q = q.tail\n        if(q.size == 0) true\n        else {\n         \
    \   val max = w / q.head\n            val q = q.reverse\n            val sum =\
    \ q.reduce(_ + _)\n            val f = sum < w\n            println(s\"${sum}\
    \ < ${w} : ${f} : ${max}\")\n            f\n        }", "        val list = q.sorted\n\
    \        var sum : Long = 0\n        val maxSum = 2 * w.toLong\n        for (i\
    \ <- 0 until list.size) {\n            val left = list(i).abs.toLong\n       \
    \     val right = list(i + 1).abs.toLong\n            val left = list(i).abs.toLong\n\
    \            val right = list(i + 1).abs.toLong\n            sum += right\n  \
    \          if (left < maxSum) sum += left\n        }\n        sum == maxSum",
  "        def canGoThrough(q1 : List[Long]) : Boolean = {\n            if (q1.isEmpty)\
    \ {\n                true\n            } else {\n                val first = q1.head\n\
    \                if (first == q1.last) canGoThrough(q1.tail) else canGoThrough(q1.tail)\
    \ && q1.head.toLong <= w\n            }\n        }\n        canGoThrough(q) &&\
    \ q.isPalindromic && q.length <= w", "        var res : Boolean = true \n    \
    \    // Write your code here\n        \n        return res", "        var l =\
    \ q.head\n        var h = q.last\n        var l2 = l % 2\n        for(i <- 0 until\
    \ q.size) {\n            var w2 = i.toLong % 2\n            if((h / 2) < w2 &&\
    \ l2 == (i.toLong % 2))\n                l = (l+q)(i)\n            else if((h\
    \ / 2) < w2 && l2 == (i.toLong % 2) == !(i.toLong % 2))\n                h = h\
    \ + q(i)\n            else if((h / 2) < w2 && l2 == (i.toLong % 2) == !(i.toLong\
    \ % 2))\n                h = (h+q(i)) - q(i)\n            else if((h / 2) < w2\
    \ && l2 == (i.toLong % 2) == !(i.toLong % 2))\n                h = h + q(i)\n\
    \        }\n        if(w < h && w == l.toLong % 2)\n            false\n      \
    \  else\n            true", "        val sumOfElements = q reduce { (x,y) => x+y\
    \ }\n        sumOfElements <= w", "        def balanced(ls: List[Long]) : Boolean\
    \ = {\n            ls.forall(x => x == ls.reverse.head)\n        }\n\n       \
    \ val s = \"\" + q.toString ++ \"+\"\n        val w = w.toLong\n        val maxW\
    \ = Long.MaxValue\n        def check(): Boolean = {\n            val n = s.replaceFirst(\"\
    [\\\\+]\", \"\").trim\n            val w = n.split(\"\\\\+\").map(_.toLong).sum\n\
    \            w <= maxW && balanced(n.split(\"\\\\+\").map(_.toLong))\n       \
    \ }\n        if (check()) true\n        else false", "        val ls = q.size\n\
    \        if (ls == 0) true\n        else if (ls == 1) true\n        else ls ==\
    \ ls.reverse.tail.map(_.toLong).reverse &&\n            q.sum.equalTo(ls.toLong\
    \ * w)", '        q.reverse.map(x => x*x).sum <= w', "        // write your function\
    \ here\n        true", "        if (q.length == 0) true\n        else if(q.length\
    \ == 1) true\n        else {\n            val newList = q.tail\n            val\
    \ newSum = newList.foldLeft(0l) { (s, x) => s + x }\n            if (newSum <\
    \ w) willItFly(newList, w)\n            else willItFly(newList.init, w)\n    \
    \    }", "        // Complete this function!\n        // If the object q is a\
    \ palindrome and if the sum of its elements is less than or equal to the maximum\
    \ possible weight w, then return true (it will\n        // fly).\n        // Otherwise,\
    \ return false.\n        // If the object q has a balance (it has an even number\
    \ of elements)", '        // Write your solution here', "        val sum = 0l\n\
    \        var j = 0\n        var i = q.size\n        while ( i >= 0 && j < q.size\
    \ ) {\n            sum += q(j)\n            i -= 1\n            j += 1\n     \
    \   }\n        if (sum >= w) return true\n        else return false", "      \
    \  if(q.isEmpty) true\n        else {\n            var sum = 0\n            for(x\
    \ <- q.reverse) {\n                sum += x\n            }\n            if(sum\
    \ < w) false\n            else willItFly(q.tail, w)\n        }", "        val\
    \ maxWeight = w + 1l\n        // We need to consider all possibilities to check\n\
    \        // that sum of weight and sum of elements is less or equal\n        val\
    \ numLists : List[List[Long]] = q.reverse.foldLeft[List[List[Long]]] (Nil) {\n\
    \            (x, y) =>\n                if (x.isEmpty && y.isEmpty || x.reverse\
    \ == y.reverse) (y::x)\n                else if (x.isEmpty || y.reverse == x.reverse)\
    \ (y::x)\n                else (x::y)\n        }\n        var isBalanced : Boolean\
    \ = true\n        for (l <- numLists)\n            if (!l.contains(w.toLong))\
    \ {\n                val sumOfElements = l.foldLeft[Long](0l) { (acc, x) => acc\
    \ + x }\n                val sumOfWeight = l.sum\n                if (sumOfElements\
    \ > maxWeight) {\n                    isBalanced = false\n                   \
    \ break\n                }\n            }\n        isBalanced", "        def balen(q\
    \ : List[Long], w : Long) : Boolean = {\n            if (q.isEmpty) {\n      \
    \          return true\n            }\n            val maxW = math.max(w, q.head)\n\
    \            if (q.head < maxW) {\n                return false\n            }\n\
    \            val len = q.tail.length\n            if (len % 2 == 0) {\n      \
    \          if (balen(q.tail.drop(1), w)) {\n                    balen(q.tail.takeRight(2),\
    \ w)\n                } else {\n                    balen(q.tail.drop(2), w)\n\
    \                }\n            } else {\n                if (balen(q.tail.dropRight(1),\
    \ w)) {\n                    balen(q.tail, w)\n                } else {\n    \
    \                balen(q.tail.take(2), w)\n                }\n            }\n\
    \        }\n        balen(q, w)", "        val palindromic = q.reverse == q\n\
    \        var sum = 0\n        // use fold to get the sum using traversing the\
    \ list\n        q.foldLeft(0) { case (acc, x) => acc + x }\n        // if sum\
    \ is not palindromic and sum of its elements is less than or equal the max possible\
    \ weight\n        if(palindromic && sum < w) {\n            true\n        } else\
    \ if(!palindromic && sum < w) {\n            false\n        } else {\n       \
    \     willItFly(q, w)\n        }", "        val maxW = q.max\n        if (w.toDouble\
    \ > maxW) return true\n        else (q.reverse.toList diff q.sum).forall(w =>\
    \ w.toDouble <= maxW)", "        val l = q.length\n        if (l == 0) true\n\
    \        else {\n            val q2 = new mutable.MutableList[Long]()\n      \
    \      val w2 = new mutable.MutableList[Long]()\n            val maxW = w\n  \
    \          val maxL = Math.sqrt(w).toInt\n            var sum = 0\n          \
    \  for (i <- 0 until l)\n                sum = sum + q(i)\n            if (sum\
    \ < maxW && sum >= 1L) {\n                for (i <- 0 until l)\n             \
    \       if (q(i) < maxL)\n                        q2.add(q(i))\n             \
    \       else\n                        w2.add(q(i))\n                return willItFly(q2,\
    \ maxW) || willItFly(w2, maxW)\n            }\n            else if (sum < maxW\
    \ && sum < 1L)\n                return false\n            else if (sum >= maxW)\n\
    \                return true\n            else\n                return false\n\
    \        }", "        val sum : List[Long] = q.reverse.foldLeft(0l) { (sum: Long,\
    \ x: Long) =>\n            sum + x\n        }\n        if (sum < w) {\n      \
    \      false\n        }\n        if (sum == w) {\n            (q.length == 1 &&\
    \ q(0) == w)\n        }\n        else {\n            true\n        }", "     \
    \   def isBalanced(l : List[Long], w : Long) : Boolean = {\n            val maxLength\
    \ : Long = l.map(_.toLong).max\n            if (maxLength <= w) true\n       \
    \     else {\n                val diff : Long = l diff List(0, maxLength)\n  \
    \              val rev : List[Long] = rev(diff)\n                val sum : Long\
    \ = rev.reduce(_ + _)\n                if (sum == w) true\n                else\
    \ {\n                    val balanced : Boolean = l diff List(0, maxLength) ==\
    \ rev\n                    if (balanced) isBalanced(rev, w)\n                \
    \    else false\n                }\n            }\n        }\n        isBalanced(q,\
    \ w)", "        val maxSum = w / 2\n        val maxListLength = w.toInt / 2\n\
    \        val maxLength = w.toInt / 2\n        val lengths = mutable.ListBuffer.empty[Int]\n\
    \        val elements = mutable.ListBuffer.empty[Long]\n\n        for(i <- 0 until\
    \ q.size) {\n            if(q(i).equals(q(i).reverse.tail))\n                lengths\
    \ += 1\n            else {\n                elements += q(i)\n               \
    \ lengths += 1\n            }\n        }\n\n        if(elements.toList.size ==\
    \ maxListLength && maxSum < elements.toList.sum)\n            true\n        else\n\
    \            false", "        val l = q.size\n        val max = math.pow(w, l/2)\
    \ - 1l\n        val isBalanced = l.filter(_ <= max).forall(_ == l.reverse)\n \
    \       val isPalindromic = l.forall(x => x == l.reverse)\n        isPalindromic\
    \ && isBalanced && q.reduceLeft(_ + _) <= max", '        q.isEmpty || w < 0 ||
    w == 0', "        val sumOfQ = q.sum\n        val maxWeight = w * 3\n        val\
    \ maxWaysToGo = sumOfQ / maxWeight\n        val minWaysToGo = (sumOfQ - maxWaysToGo\
    \ * maxWeight) / maxWeight\n        val canGo = (maxWaysToGo >= minWaysToGo)\n\
    \        val isPalNum = (q.reverse.forall(x => x.toLong == q(0)))\n        (canGo\
    \ && isPalNum)", "        val max = w * Math.pow(10, q.length)\n        val sum\
    \ = 0L\n        q.foreach(x => sum = sum + x)\n        (sum < max) && {\n    \
    \        q.reverse.drop(q.length).reverse == q\n        }", "        // Base case:\
    \ if the list is balanced, or if its sum is less than the maximum possible weight.\n\
    \        if(q.isEmpty || q.sum < w)\n            return true\n        // Recursion\
    \ case: if the list is not balanced, or if the sum exceeds the maximum possible\
    \ weight.\n        val maximum = q.sum - w\n        val middle = maximum / 2\n\
    \        val left  = q.take(middle)\n        val right = q.drop(middle)\n    \
    \    willItFly(left, w) || willItFly(right, w)", "        val maxSum = w.toDouble\
    \ * w.toDouble\n        val q = q.reverse\n        val n = q.size\n        val\
    \ a = q.last\n        var i = n - 1\n        val sum = 0\n        while (i >=\
    \ 0) {\n            sum = sum + q(i).toDouble\n            if (sum > maxSum) {\n\
    \                break\n            }\n            i = i - 1\n        }\n    \
    \    sum.toDouble <= maxSum && sum.toDouble >= 0.0 && sum != a", "        var\
    \ maxWeight = w\n        var balanced = false\n        var maxSum = 0\n      \
    \  for (x <- q.reverse) {\n            val sum = x\n            val maxSum = sum\
    \ + maxWeight\n            if (maxSum <= maxWeight) {\n                balanced\
    \ = true\n            }\n            if (maxSum >= maxWeight) {\n            \
    \    maxSum = sum\n                maxWeight = sum - maxWeight\n            }\n\
    \        }\n        balanced", "        val l = q.size\n        val max = w.toLong\n\
    \        val sum = 0\n        val left = 0\n        val right = l - 1\n      \
    \  while (left <= right) {\n            val mid = (left + right) / 2\n       \
    \     sum = sum + q(mid)\n            if (sum < max)\n                left = mid\
    \ + 1\n            else\n                right = mid\n        }\n        if (sum\
    \ == max)\n            true\n        else\n            false", "        q.groupBy(x\
    \ => math.abs(x)).size == q.size && (\n            q.filter(x => math.abs(x) <=\
    \ w).size == q.length\n        )", "        var listSize : Int = 0\n        val\
    \ list = q match {\n            case Nil => List(w)\n            case x :: Nil\
    \ => List(w)\n            case x :: y => listSize = x + y\n        }\n       \
    \ var sum : Long = 0\n        var maxSum = listSize\n        for (i <- 0 until\
    \ listSize) {\n            sum += list(i)\n            if (sum > maxSum) {\n \
    \               maxSum = sum\n            }\n        }\n        val isPalindromic\
    \ = listSize == list.size && list.reverse.forall(x => x == list(0))\n        return\
    \ isPalindromic && sum <= w", "        val maxWeight = w\n        val maxList\
    \ = q.reverse.tail\n        val palindromic = List.isPalindromic(q)\n        val\
    \ sumList = q.sum\n        if(palindromic && sumList <= maxWeight) {\n       \
    \     true\n        } else if (sumList > maxWeight) {\n            false\n   \
    \     } else {\n            // check the maxWeight\n            if(q.head == q.last)\n\
    \                true\n            else {\n                val maxListTail = maxList.tail\n\
    \                maxListTail.forall(x => x > maxWeight)\n            }\n     \
    \   }", "        val listSize = q.length\n        val reversedList = reverse(q)\n\
    \        val sumOfElements = reversedList.toList.map(_.toLong).sum\n        val\
    \ maximumWeight = w.toLong\n\n        // if listSize is a palindrome, then sumOfElements\
    \ is equal to w\n        if(listSize == reversedList.toList && sumOfElements ==\
    \ w) {\n            true\n        }\n        // if listSize is not a palindrome,\
    \ then sumOfElements is less than w\n        else {\n            // if listSize\
    \ equals 0, then sumOfElements is equal to w\n            if(listSize == 0) {\n\
    \                true\n            }\n            // if listSize is greater than\
    \ 0, then sumOfElements is less than w\n            else {\n                if(sumOfElements\
    \ < w) {\n                    false\n                } else {\n              \
    \      true\n                }\n            }\n        }", "        // Write your\
    \ code here.\n        var ans : Boolean = true\n        if(q.isEmpty) ans\n  \
    \      else {\n            var maxSum = w\n            var maxIndex = 0\n    \
    \        val minMaxIndex = if (q.head < w) q.size else 0\n            var minMaxSum\
    \ = w\n            for(i <- 0 until minMaxIndex) minMaxSum += q.head\n       \
    \     for(i <- 0 until q.size) maxSum += q.tail.sum\n            if(maxSum <=\
    \ maxIndex) ans = true\n            else if(minMaxSum < maxIndex) ans = false\n\
    \            else if (maxSum < minMaxSum) ans = true\n            else ans = willItFly(q.tail,\
    \ w)\n        }\n        return ans", "        val maxWays = maxListLength(q)\n\
    \        if (maxWays > w)\n            false\n        else\n            checkSum(q,\
    \ maxWays, w)", "        if (q.length == 0) true\n        else if (q.length ==\
    \ 1) (q.head == q(0)) && (q.head == w)\n        else if (q.length == 2) (q.head\
    \ == q(0)) && (q.head == w) && (q.tail.head == w)\n        else (q.head == q(0))\
    \ && (q.head == w) && (q.tail.head == w) && (q.tail.tail.head == w) && (q.tail.tail.tail.head\
    \ == w)", "        // write your logic here\n        val left = new ArrayBuffer[Long](q.head)\n\
    \        val right = q.tail.reverse\n        val length = right.length\n     \
    \   val maxSum = length + w\n        val tempSum = left.sum + right.length * w\n\
    \        if (maxSum < tempSum) {\n            false\n        }\n        else if\
    \ (maxSum > tempSum) {\n            true\n        }\n        else {\n        \
    \    val index = left.lastIndex\n            val index = right.lastIndex\n   \
    \         if (index <= 0 || index > length) {\n                false\n       \
    \     }\n            else {\n                val i = left\n                val\
    \ j = right\n                val sum = i.toDouble + w.toDouble\n             \
    \   if (sum < j) {\n                    false\n                }\n           \
    \     else {\n                    willItFly(i.drop(index), w)\n              \
    \  }\n            }\n        }", "        // The sum of weights of balanced palindromic\
    \ lists is equal to the maximum possible weight.\n        // The object q will\
    \ fly if it's balanced (it is a palindromic list) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n        // To calculate\
    \ the sum, we need to traverse the list in reverse.\n        // The sum of first\
    \ two elements is less than or equal to the maximum possible weight w.\n     \
    \   val sum = 0\n        val max = w\n        q.reverse.foreach(w => sum <- sum\
    \ + w)\n        sum <- max\n        // q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n        sum <- sum < max", "        // Write your code here\n   \
    \     val maxWight = w.toLong * 2 - 1\n        val maxSum = w.toLong * 2 - 1\n\
    \        val minSum = w.toLong * 2 - 1\n        val palindromicQ = if(q.isEmpty)\
    \ false else willItFly(q.reverse, w)\n        if(q.sum >= maxWight && palindromicQ)\
    \ true\n        else if(q.sum >= maxSum && !palindromicQ) false\n        else\
    \ if(q.sum >= minSum && palindromicQ) true\n        else false", "        def\
    \ balancedList[T](ls: List[T], max: Long) : List[T] = {\n            val n = ls.size\n\
    \            val maxn = ls.sum\n            var j = 0\n            var isBalanced\
    \ = true\n\n            for (i <- 0 until n if !ls(i).equals(ls(i+1))) {\n   \
    \             j++\n            }\n\n            val maxj = j\n            j =\
    \ 0\n            for (i <- 0 until n if !ls(i).equals(ls(i+1))) {\n          \
    \      j++\n            }\n\n            val maxj1 = j\n            var j = 0\n\
    \            var i = n-1\n            while (i >= 0) {\n                j++\n\
    \                if (ls(i).equals(ls(i+1))) {\n                    i--\n     \
    \           }\n            }\n\n            val maxj2 = j\n            var i =\
    \ 0\n            var isBalanced2 = true\n            var j = 0\n\n           \
    \ for (i <- 0 until n) {\n                if (ls(i).equals(ls(i+1))) {\n     \
    \               isBalanced2 = false\n                }\n            }\n\n    \
    \        if (isBalanced2 && maxj >= maxj1 && maxj1 <= maxj2) {\n             \
    \   isBalanced = true\n            }\n            isBalanced\n        }\n\n  \
    \      val xs = q.distinct\n        val ys = w.distinct\n        val zs = xs.intersect(ys)\n\
    \n        if (zs.isEmpty) {\n            true\n        } else {\n            val\
    \ n = xs.size\n            val m = ys.size\n            if (n <= m && balancedList(xs,\
    \ w) && balancedList(ys, w)) {\n                false\n            } else {\n\
    \                true\n            }\n        }", "        val maxSum = q.map(x\
    \ => math.pow(x, 2)).reduce(math.max)\n        val isPalindromic = (q.reverse.forall(x\
    \ => q.head == x) && q.forall(x => x == q.tail.head)) && q.size == q.length\n\
    \        val isBalanced = (q.map(x => math.pow(x, 2)).sum > maxSum) && q.size\
    \ == q.length\n        isPalindromic && isBalanced", "        val s = q.reverse.map(_.toInt).sum\n\
    \        s <= w", "        val list = new collection.mutable.ListBuffer[Long]()\n\
    \        var wsum = 0l\n        for(i <- q) {\n            list+=i\n         \
    \   wsum += i\n        }\n        if (list.isEmpty || list.size != q.length) false\
    \ else (wsum < w) && (wsum == wlist.last)", "        val maxW = w\n        val\
    \ pList = q.reverse.mkString\n        if (pList == q.toString) true\n        else\
    \ { val p = pList.length\n            if (p < maxW) false\n            else {\
    \ val q = pList.reverse.mkString\n                if (q < maxW) true else false\n\
    \            }\n        }", "        val balanced = q.reverse.forall(_ == q.reverse.get(_))\
    \ && w.toLong <= q.sum\n        !(balanced && q.sum < w.toLong)", "        val\
    \ newList = q.map(x => (x, w)).toList\n        val palin = reverse(newList).equals(newList)\n\
    \        if(!palin)\n            return false\n        newList.map(_._1).sum >=\
    \ w", "        // Your code goes here.\n        val maxWeight = w\n        val\
    \ balance = balanceQ(q, w)\n        (balance == true) && (maxWeight <= q.sum)",
  "        val pList = q.map(x => x.toString()).reverse.map(_.toLong).reverse.map(BigDecimal(_))\n\
    \        val fly = pList.sum == w\n        val isBalanced = pList.forall(_ < w)\n\
    \        (fly && isBalanced)", "        val wq = q.sum\n        // wq < w means\
    \ q doesn't fly.\n        wq < w && q.forall(x => math.abs(x - wq) < w)", "  \
    \      if (q.size <= 0) false\n        else if (q.head != q.reverse && w <= 0)\
    \ true\n        else willItFly(q.reverse, w-1)", "       val ls = ListBuffer[Long]()\n\
    \       var qs = q\n       while(true){\n         qs = qs.reverse\n         if(qs.isEmpty){\n\
    \           true\n         }else{\n           ls.append(qs.head)\n           qs\
    \ = qs.tail\n         }\n         val sum = ls.sum\n         if(sum < w){\n  \
    \         return false\n         }else if(sum == w){\n           return true\n\
    \         }\n       }", "        val maxWeight = w\n        if (q.size != 1)\n\
    \            return false\n        val left = q(0)\n        val right = q(0)\n\
    \        for (i <- 0 until q.size) {\n            if (q(i) != left + right + q(i))\n\
    \                return false\n        }\n        // Now we know that the list\
    \ will be balanced if the sum of the list elements\n        // is less than or\
    \ equal to  maxWeight\n        if (q(0).signum < 0 || q(0).abs > (maxWeight +\
    \ 1))\n            return false\n        // We also know that the list will not\
    \ be balanced if the sum of its elements is greater\n        // than the maximum\
    \ possible weight\n        if (q(0).abs > (maxWeight - 1))\n            return\
    \ true\n        return false", "        val maxWeight = w.toLong\n        q.reverse.forall(x\
    \ => x <= maxWeight)", "        val maxWeight = w.toLong - q.sum\n        q.reverse.forall(i\
    \ => i + q.sum < maxWeight)", "        // TODO : Write your code here\n      \
    \  val maxW : Long = 1000000000l\n        if(q.isEmpty) true\n        else {\n\
    \            val sum : Long = q.reduce(_ + _)\n            if(sum < 0) false\n\
    \            else if(sum > maxW) false\n            else {\n                val\
    \ maxSum = sum / w\n                if(maxSum < 0) false\n                else\
    \ {\n                    val firstHalfSum = (sum - maxSum * (w-1)) / (w/2)\n \
    \                   if(firstHalfSum < 0) false\n                    else {\n \
    \                       val lastHalfSum = (sum - maxSum * (w-1)) / (w/2)\n   \
    \                     if(lastHalfSum > maxSum) false\n                       \
    \ else {\n                            val firstHalfSumOfList = q.takeWhile(_ <\
    \ firstHalfSum).toList\n                            val lastHalfSumOfList = q.takeWhile(_\
    \ > lastHalfSum).toList\n                            if(firstHalfSumOfList.size\
    \ == 0 || lastHalfSumOfList.size == 0) false\n                            else\
    \ {\n                                val firstHalfSumOfListIsPalindrome = firstHalfSumOfList.forall(x\
    \ => x == x.reverse)\n                                val lastHalfSumOfListIsPalindrome\
    \ = lastHalfSumOfList.forall(x => x == x.reverse)\n                          \
    \      if(firstHalfSumOfListIsPalindrome && lastHalfSumOfListIsPalindrome) true\n\
    \                                else false\n                            }\n \
    \                       }\n                    }\n                }\n        \
    \    }\n        }", "        val newMaxWeight = w-q.sum\n        val rev = ListBuffer(q.tail.reverse)\n\
    \        val newList = rev.reverse\n        val reverseList = rev.reverse\n  \
    \      if (q.head == 0) true\n        else if (newMaxWeight < 0l || reverseList.sum\
    \ > newMaxWeight) true\n        else willItFly(newList.reverse, newMaxWeight)",
  '        if(q.length == 0) false else (w < q(0) * q(0)) && (w-sum(q) <= q.last *
    q.last)', "        val maxSum = w.reduceLeft(_ + _)\n        q.reverse match {\n\
    \            case Nil => true\n            case y :: ys =>\n                if(y.toLong\
    \ == qs.init.tail.sum && y == qs.init.init.head) {\n                    if(y ==\
    \ qs.tail.init.head) {\n                        willItFly(ys, w)\n           \
    \         } else {\n                        maxSum <= w && willItFly(ys, w)\n\
    \                    }\n                } else {\n                    maxSum <=\
    \ w && willItFly(ys, w)\n                }\n        }", "        // check balance\n\
    \        if (q.isEmpty) return true\n        var maxWeight = w\n        var maxSum\
    \ = w.toLong\n        for (i <- 0 until q.size) {\n            val c = q(i)\n\
    \            maxWeight = c > maxWeight ? c : maxWeight\n            maxSum = c\
    \ > maxSum ? c : maxSum\n        }\n        maxWeight <= w && maxSum <= w", " \
    \       val maxW : Long = w\n        val sum : Long = q.sum\n        val pList\
    \ : List[Long] = q.reverse\n        var fly = true\n        var bal = 0\n    \
    \    val fly_list : List[Long] = q.reverse\n        val pList : List[Long] = q.reverse\n\
    \        var fly = true\n        for(i <- 0 until q.size) {\n            if (pList(i)\
    \ != pList(i+1)) {\n                if (sum > maxW) {\n                    fly\
    \ = false\n                    break\n                }\n                if (i\
    \ == q.size-1) {\n                    fly = true\n                } else {\n \
    \                   if (pList(i) == pList(i+1)) {\n                        fly\
    \ = false\n                        break\n                    } else {\n     \
    \                   fly = false\n                        break\n             \
    \       }\n                }\n            }\n            if (pList(i) == pList(i+1))\
    \ {\n                bal += 1\n            } else {\n                bal -= 1\n\
    \            }\n        }\n        return fly", "        def balanced(l: List[Long],\
    \ maxW: Long): Boolean = l.zip(l.reverse).map(_._1 + _._2).sum < maxW\n      \
    \  val maxW : Long = w.toLong\n        (q.reverse.tail exists (l => balanced(l,\
    \ maxW)) || balanced(q, maxW))", "        var result = true\n        var l = q.head\n\
    \        var w = w - 1\n        while(l<q.last){\n            if(q(l) != q(l-1)){\n\
    \                result = false\n                break\n            }\n      \
    \      l += 1\n            w += 1\n        }\n        result", "        val maxW\
    \ = w.toLong\n\n        q.tail.fold(true)({ acc =>\n            val sum = acc.fold(0L)(_\
    \ + _)\n            if(sum < maxW && !(acc.reverse.sliding(2).forall(_.toLong\
    \ == acc.reverse.head) && acc.forall(_ != acc.reverse.head))) {\n            \
    \    acc match {\n                    case x :: xs => willItFly(xs, maxW)\n  \
    \                  case _ => acc\n                }\n            } else {\n  \
    \              acc\n            }\n        })", "        // your code here\n \
    \       if (q.length == 1) {\n            if (q.isDefined) {\n               \
    \ true\n            } else {\n                false\n            }\n        }\
    \ else {\n            val maxSum = math.max(w, q.map(_.toLong).sum)\n        \
    \    val fly = q.foldLeft(false)((acc, current) =>\n                if (acc &&\
    \ current.toLong == q.reverse.head) {\n                    acc && current.toLong\
    \ == q.reverse.tail.head\n                } else {\n                    acc &&\
    \ current.toLong <= maxSum\n                }\n            )\n            fly.toBoolean\n\
    \        }", "        val maxSum = w /2.0\n        val qSum = q.toList.reverse.foldLeft(0.0)\
    \ { (sum, elem) =>\n            if (sum < maxSum * elem) sum + elem else sum\n\
    \        }\n        val maxElem = (q, maxSum).unzip\n        qSum < maxElem",
  "        val maxWeight = w / 2\n        q.reverse.foldLeft((false, 0)) { (acc, elem)\
    \ => elem match {\n            case 1 => acc match {\n                case (true,\
    \ _) => true\n                case (false, 1) => false\n                case (true,\
    \ _) => false\n                case (false, 0) => acc\n            }\n       \
    \     case 2 => acc match {\n                case (true, _) => true\n        \
    \        case (false, 2) => false\n                case (true, _) => false\n \
    \               case (false, 0) => acc\n            }\n            case 3 => acc\
    \ match {\n                case (true, _) => true\n                case (false,\
    \ 3) => false\n                case (true, _) => false\n                case (false,\
    \ 0) => acc\n            }\n            case 4 => acc match {\n              \
    \  case (true, _) => true\n                case (false, 4) => false\n        \
    \        case (true, _) => false\n                case (false, 0) => acc\n   \
    \         }\n            case 5 => acc match {\n                case (true, _)\
    \ => true\n                case (false, 5) => false\n                case (true,\
    \ _) => false\n                case (false, 0) => acc\n            }\n       \
    \     case 6 => acc match {\n                case (true, _) => true\n        \
    \        case (false, 6) => false\n                case (true, _) => false\n \
    \               case (false, 0) => acc\n            }\n            case 7 => acc\
    \ match {\n                case (true, _) => true\n                case (false,\
    \ 7) => false\n                case (true, _) => false\n                case (false,\
    \ 0) => acc\n            }\n            case 8 => acc match {\n              \
    \  case (true, _) => true\n                case (false, 8) => false\n        \
    \        case (true, _) => false\n                case (false, 0) => acc\n   \
    \         }\n            case 9 => acc match {\n                case (true, _)\
    \ => true\n                case (false, 9) => false\n                case (true,\
    \ _) => false\n                case (false, 0) => acc\n            }\n       \
    \     case 10 => acc match {\n                case (true, _) => true\n       \
    \         case (false, 10) => false\n                case (true, _) => false\n\
    \                case (false, 0) => acc\n            }\n            case x =>\
    \ acc match {\n                case (true, _) => true\n                case (false,\
    \ x) => false\n                case (true, _) => false\n                case (false,\
    \ 0) => acc\n            }\n        }}", "        if(q.isEmpty) return true\n\
    \        val qList = q.toList\n        if(qList.length < 2) return true\n    \
    \    val maxSum = qList.map(x => x + x).sum\n        if(maxSum < w) false\n  \
    \      else\n            qList.tail.reverse.map { x =>\n                if(maxSum\
    \ - x < 0) false\n                else if(maxSum - x == w) true\n            \
    \    else false\n            }.forall(x => x)", "        // Your code here.\n\
    \        // Your code here.\n        // Your code here.", "        if (q.isEmpty)\
    \ {\n            return true\n        }\n\n        // This code is very similar\
    \ to the code you wrote above,\n        // but now we will use that code to check\
    \ whether q will fly.\n        // So here is an explanation of the code we wrote:\n\
    \        // The idea is to check whether the list q is balanced or not.\n    \
    \    // If balanced, then we will fly.\n        // So first we will check if q\
    \ is a palindrome.\n        // if yes, then we will not fly.\n        // else\
    \ we will check if q is balanced.\n        // if yes, then we will not fly.\n\
    \        // else we will fly.\n        // The method will be called by isPalindrome(q).\n\
    \        // But now we will use another method to check whether q is balanced.\n\
    \        // It will check whether the sum of elements in a list is less than or\
    \ equal to w.\n        // If it is, it will return true.\n        // Otherwise,\
    \ returns false.\n        // So we combine isPalindrome(q) with this method, and\
    \ we will get what we want.\n        val palindrome = q.isPalindrome\n       \
    \ if (palindrome) {\n            return false\n        }\n        val balanced\
    \ = q.isBalanced\n        if (balanced) {\n            return false\n        }\n\
    \        return true", "        val l = q.foldLeft(List[Long]())((l, x) => if\
    \ (x == l.last) l.last else l.last :: x)\n        if (l.isEmpty && l == w) false\n\
    \        else willItFly(l, w)", "        val maxWeight = w;\n        val maxSum\
    \ = w;\n        val maxWasBalanced = true;\n        val sum = 0;\n        q.foreach{\
    \ x =>\n            if(sum > maxSum) {\n                maxWasBalanced = false;\n\
    \                break;\n            }\n            sum += x;\n        }\n   \
    \     if(maxWasBalanced) {\n            (q.reverse.sum < maxWeight && q.reverse.forall(x=>x==w))\n\
    \        } else {\n            false\n        }", "        // TODO: Write your\
    \ solution here\n        val w = w.toLong\n        val maxWeight = w * w.toDouble\n\
    \        val max = List(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l).max\n        val maxW\
    \ = max.toLong\n        val numElements = q.size\n        if (maxW + q.sum < w)\
    \ false else if (maxW - q.sum > w) true else {\n            if (numElements <=\
    \ (maxW / w).toInt) true else if (numElements <= (maxW / w).toInt) false else\
    \ {\n                if (q.forall(_.toDouble.toLong == maxW)) true else false\n\
    \            }\n        }", "        if (q.isEmpty)\n            q.palindrome\n\
    \        else {\n            val maxW = math.max(q, w).toLong\n            val\
    \ maxWeight = q.length.toLong\n            val reverseQ = q.tail.reverse\n   \
    \         var sum = 0\n            var i = 0\n            while (i < reverseQ.length)\
    \ {\n                sum += reverseQ(i)\n                i += 1\n            }\n\
    \            sum >= maxW && sum < maxWeight && sum == reverseQ.sum\n        }",
  "        val balanced = q.reverse.forall(x => x == q.reverse.last)\n        val\
    \ sum = q.sum\n        val maxWeight = math.max(w, balanced)\n        sum < maxWeight\
    \ && balanced", "        val qw = q.zipWithIndex\n        qw.forall { case (q,\
    \ index) => q === qw(index-1)._1 }", "        val reversed = q.map(_.asInstanceOf[Long]).reverse\n\
    \        reversed.toSet.subsetOf(w.asInstanceOf[Long].asInstanceOf[Long]) == true",
  "        val max = scala.math.min(w, q.sum.toLong)\n        q.toList.sortWith(_\
    \ <= _) match {\n            case Nil => true\n            case x :: Nil => false\n\
    \            case y :: xs => willItFly(xs, max)\n        }", "        def fly(x\
    \ : List[Long], q : List[Long], w: Long) : Boolean = {\n            if (x == q)\n\
    \                return true\n            else if (x != null && x.tail.isEmpty)\n\
    \                return false\n            else if (x.length != q.length)\n  \
    \              return false\n            else if (x.head != q.reverse)\n     \
    \           return false\n            else if (x.head == 0 && q.length != 0 &&\
    \ w == q.length && x.tail.forall(x => x <= q))\n                return true\n\
    \            else\n                return fly(x.tail, q.tail, w - q.length)\n\
    \        }\n        return fly(q, q, w)", "        q.isEmpty\n            || (q.length\
    \ == 1 && q(0)*q(0) == w)\n            || (q.length == 1 && q(0)*q(0) > w)\n \
    \           || (q.length == 1 && q(0)*q(0) <= w)\n            || (q.length ==\
    \ 1 && q(0)*q(0) >= w)", "        def fly(l : List[Long], r : List[Long]) : Boolean\
    \ = {\n            l == r || fly(l.tail, r.reverse)\n        }\n        fly(q,\
    \ q.reverse) && w.toLong == w.toLong.toLong && w.toLong == w.toLong.toLong ||\
    \ !fly(q, q)", "        // Write your code here.\n        val sum = 0\n      \
    \  var maxSum = 0\n        val maxWeight = math.max(w, 1l.toLong)\n        q.reverse.foreach\
    \ { x =>\n            val sum = sum + x\n            if(sum > maxSum) {\n    \
    \            maxSum = sum\n            }\n        }\n        return sum == maxSum",
  "        def weight(n: Long): Long = n * 100l\n\n        def canBeBalanced(w: List[Long]):\
    \ Boolean = { val n = w.last; w match { case Nil => true ; case h :: Nil => false;\
    \ case h :: t => weight(h) <= weight(n) + weight(t) } }\n        def isPalindromic(a:\
    \ List[Long]): Boolean = a.reverse == a\n        val maxW = weight + 2 * w //\
    \ the sum of the last two elements\n        val sumW = weight + sum(a) // the\
    \ sum of the last two elements + the current one\n        if (canBeBalanced(q)\
    \ && sumW < maxW && isPalindromic(q)) true\n        else false", "        q.isEmpty\
    \ || {\n            if (q.isEmpty) true\n            else {\n                val\
    \ (l, r) = q.span(_ % 2 == 0)\n                val sum = l.sum + r.sum\n     \
    \           if (sum == w) {\n                    val b = q.reverse.span(_ % 2\
    \ == 0)\n                    if (b.forall(x => x.sum == w) && b.forall(x => x.sum\
    \ < w)) {\n                        true\n                    } else {\n      \
    \                  false\n                    }\n                } else {\n  \
    \                  false\n                }\n            }\n        }", "    \
    \    def balancedSum(x : List[Long]) : Double = {\n            def sum(z : List[Long])\
    \ : Double = {\n                z.toStream.foldLeft(0d){ (a, i) => (a + i.toDouble)}\n\
    \            }\n            val len = x.length\n            if(len == 0) 0d else\
    \ sum(z) + sum(x.tail) < (w / len.toDouble)\n        }\n        if(!q.isEmpty)\
    \ {\n            val len = q.length\n            if(len == 0) false\n        \
    \    else {\n                val sum = 0d\n                for( a <- q.toStream)\
    \ {\n                    sum += a\n                }\n                if(sum <\
    \ w / len.toDouble) false\n                else balancedSum(q) <= w\n        \
    \    }\n        }\n        else true", '        q.filter(_ <= w).forall(w => w.toString.reverse.equals(q.toString))',
  "        val newQ = q.filter(_ < w)\n        if(newQ.size == 0)\n            false\n\
    \        else if(newQ.size == 1)\n            true\n        else if(newQ.size\
    \ == 2)\n            newQ.head == newQ.last\n        else\n            newQ.head\
    \ == newQ.reverse.last", "        val len = q.length\n        val r = scala.collection.mutable.Stack[Int]()\n\
    \        var maxSum = w\n        for(i <- 0 until len) {\n            val currentSum\
    \ = q(i) + r.head\n            if(currentSum > maxSum) maxSum = currentSum\n \
    \           if(r.head > 0 && currentSum > w) r.clear()\n            r.push(i)\n\
    \        }\n        if(r.nonEmpty) r.lastOption.isEmpty else false", "       \
    \ def isPalindrome(p: List[Long]) : Boolean = { p match {\n            case Nil\
    \ => true\n            case x :: Nil => x == 0\n            case xs => xs == x\
    \ reverse xs\n        }}\n        val isBalanced = isPalindrome(q) && q.sum <\
    \ w\n        isBalanced && q.forall(x => x < w)", "        val maxSum = w.toLong\
    \ * q.size\n        q.isEmpty || {\n            q.reverse.foldLeft(true)( (a,i)\
    \ => a && {\n                val sum = i.sum\n                if (sum < maxSum)\n\
    \                    false\n                else\n                    sum < w\
    \ && sum % 2 == 0\n            })\n        }", "        // Base case\n       \
    \ if (q.isEmpty)\n            return true\n        // Check balance\n        else\
    \ if (q.length == 1)\n            if (q(0) == q(0))\n                return true\n\
    \            else\n                return false\n        // Compute sum of elements\n\
    \        else\n            if (sum(q) <= w)\n                if (willItFly(q.tail,\
    \ w))\n                    return true\n                else\n               \
    \     return false\n            else\n                if (willItFly(q.tail, w))\n\
    \                    return true\n                else\n                    return\
    \ false", "        if (q.nonEmpty && w == 0)\n            false\n        else\
    \ if (q.nonEmpty)\n            if (w.getOrElse(0) == 0)\n                true\n\
    \            else\n                willItFly(q.reverse, w.getOrElse(0))\n    \
    \    else\n            true"]
stop_tokens:
- "\n    }\n"
