name: HumanEval_10_make_palindrome
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Find the shortest palindrome that begins with a supplied string.\n    //\
  \ Algorithm idea is simple:\n    // - Find the longest postfix of supplied string\
  \ that is a palindrome.\n    // - Append to the end of the string reverse of a string\
  \ prefix that comes before the palindromic suffix.\n    // >>> makePalindrome((\"\
  \"))\n    // (\"\")\n    // >>> makePalindrome((\"cat\"))\n    // (\"catac\")\n\
  \    // >>> makePalindrome((\"cata\"))\n    // (\"catac\")\n    def makePalindrome(string\
  \ : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(makePalindrome((\"\
  \")).equals((\"\")));\n    assert(makePalindrome((\"x\")).equals((\"x\")));\n  \
  \  assert(makePalindrome((\"xyz\")).equals((\"xyzyx\")));\n    assert(makePalindrome((\"\
  xyx\")).equals((\"xyx\")));\n    assert(makePalindrome((\"jerry\")).equals((\"jerryrrej\"\
  )));\n    }\n\n}\n"
completions: ["        val chars = string.dropRight(1)\n        // Find longest postfix\
    \ string which is a palindrome\n        // If that does not work, try adding characters\
    \ to either end until it works\n        var longest = \"\"\n        var longestLen\
    \ = 1\n        while(longest.last.isUpperCase && !longest.last.isLowerCase &&\
    \ !longest.last.isDigit) {\n            val lastPostfix = longest.dropRight(1)\n\
    \            longest = longest + lastPostfix.reverse\n            longestLen =\
    \ longestLen + 1\n        }\n        // Add postfix to start string\n        string\
    \ = string + longest.drop(longestLen)\n        // Add postfix to end string\n\
    \        string = string + longest.reverse\n        // Return string\n       \
    \ string", "        if (string.isEmpty) string\n        else {\n            val\
    \ palindrome = string.map(char => char.toUpperCase + char.toLowerCase).filter(\
    \ char => char == char.toUpperCase && char == char.toLowerCase).mkString(\"\"\
    )\n            val longestPalindrome = string.takeRightWhile(char => char != palindrome.reverse).mkString(\"\
    \")\n            palindrome + longestPalindrome\n        }", "        val longestPalindrome\
    \ = longestPalindromeHelper(string)\n        longestPalindrome + reverseOfStringPrefix(string,longestPalindrome)",
  "        val longestPalindrome = findLongestPalindrome(string.asInstanceOf[mutable.WrappedArray[Char]])\n\
    \        string + longestPalindrome.mkString(longestPalindrome.reverse)", "  \
    \      def longestPalindromicSuffix(str : String) : List[String] = str match {\n\
    \            case \"\" => Nil\n            case str => str :: longestPalindromicSuffix(StringBuilder.reverse(str))\n\
    \        }\n        val strs = longestPalindromicSuffix(string)\n        strs.reverse.takeWhile(_.startsWith(string))",
  "        val prefix = string.substring(0, string.length - 1)\n        val postfix\
    \ = string.substring(string.length - 1)\n        val reversePrefix = reverse(prefix)\n\
    \        val reversePostfix = reverse(postfix)\n        prefix + reversePrefix\
    \ + reversePostfix", "        val longestPalindrome = longestPalindrome(string.mkString);\n\
    \        string +: longestPalindrome reverse", "        def longestPalindromicSuffix(string\
    \ : String) : String = {\n            val l = string.length\n            val r\
    \ = -1\n            while(l > r){\n                val mid = (l + r) / 2\n   \
    \             val suffix = string.drop(mid)\n                if(suffix.forall(x\
    \ => x == suffix.reverse))\n                    r = mid\n                else\n\
    \                    l = mid - 1\n            }\n            string\n        }\n\
    \n        def longestPalindromicPrefix(string : String) : String = {\n       \
    \     val l = string.length\n            val r = -1\n            while(l > r){\n\
    \                val mid = (l + r) / 2\n                val prefix = string.take(mid)\n\
    \                if(prefix.forall(x => x == prefix.reverse))\n               \
    \     r = mid\n                else\n                    l = mid - 1\n       \
    \     }\n            string\n        }\n\n        val longestPalindromic = longestPalindromicSuffix(string)\
    \ + longestPalindromicPrefix(string)\n        longestPalindromic.takeWhile(_ !=\
    \ longestPalindromic.dropWhile(_ != longestPalindromic))", "        if (string.isEmpty)\
    \ return string\n        val longestPalindromicSubStringIndex = longestPalindromicSubString(string)\n\
    \        val reverseStringOfLongestPalindromicSubString = reverseString(string,\
    \ longestPalindromicSubStringIndex)\n        var newString = string + reverseStringOfLongestPalindromicSubString\n\
    \        var endIndex = longestPalindromicSubStringIndex\n        var newEndIndex\
    \ = longestPalindromicSubStringIndex\n        while (endIndex < string.length\
    \ && newEndIndex < newString.length) {\n            if (newString((longestPalindromicSubStringIndex))\
    \ != newString(newEndIndex)) {\n                endIndex = newEndIndex\n     \
    \           newEndIndex = longestPalindromicSubStringIndex\n            } else\
    \ {\n                newEndIndex = newEndIndex + 1\n            }\n        }\n\
    \        newString = newString.substring(0, endIndex + 1)\n        newString",
  "        var longestPalLength = 0\n        var longestPalString = \"\"\n       \
    \ for (i <- 0 until string.length)\n        {\n            if (i % 2 == 0) {\n\
    \                longestPalLength = math.max(longestPalLength, string.length -\
    \ i)\n                longestPalString = longestPalString + string.reverse.drop(i\
    \ + 1)\n            }\n        }\n        longestPalString + string.reverse.drop(longestPalLength\
    \ + 1)", "        if(string.length == 0)\n            string\n        else if(string.length\
    \ < 2)\n            string\n        else { \n            var longestPrefix : String\
    \ = \"\"\n            var shortestSuffix : String = \"\"\n            var longestPrefix\
    \ : String = \"\"\n            var shortestSuffix : String = \"\"\n          \
    \  var longestPrefix : String = \"\"\n            var shortestSuffix : String\
    \ = \"\"\n            for(i <- 0 to (string.length-1)) {\n                var\
    \ newLongestPrefix : String = \"\"\n                var newShortestSuffix : String\
    \ = \"\"\n                for(j <- i to string.length-1){\n                  \
    \  var newLongestPrefix : String = \"\"\n                    var newShortestSuffix\
    \ : String = \"\"\n                    if(string(i) != string(i+j)) {\n      \
    \                  var newLongestPrefix : String = \"\"\n                    \
    \    var newShortestSuffix : String = \"\"\n                        for(k <- i\
    \ to j-1){\n                            var newLongestPrefix : String = \"\"\n\
    \                            var newShortestSuffix : String = \"\"\n         \
    \                   if(string(k) != string(i+j+k)) {\n                       \
    \         newLongestPrefix = newLongestPrefix + string(k)\n                  \
    \              newShortestSuffix = newShortestSuffix + string(k+j)\n         \
    \                   }\n                        }\n                    }\n    \
    \                newLongestPrefix = newLongestPrefix + string(i)\n           \
    \         newShortestSuffix = newShortestSuffix + string(i+j)\n              \
    \  }\n                if(longestPrefix < newLongestPrefix)\n                 \
    \   longestPrefix = newLongestPrefix\n                if(shortestSuffix < newShortestSuffix)\n\
    \                    shortestSuffix = newShortestSuffix\n            }\n     \
    \       for(i <- 0 to string.length-1){\n                var newLongestPrefix\
    \ : String = \"\"\n                var newShortestSuffix : String = \"\"\n   \
    \             for(j <- i to string.length-1){\n                    var newLongestPrefix\
    \ : String = \"\"\n                    var newShortestSuffix : String = \"\"\n\
    \                    if(string(i) != string(i+j)) {\n                        var\
    \ newLongestPrefix : String = \"\"\n                        var newShortestSuffix\
    \ : String = \"\"\n                        for(k <- i to j-1){\n             \
    \               var newLongestPrefix : String = \"\"\n                       \
    \     var newShortestSuffix : String = \"\"\n                            if(string(k)\
    \ != string(i+j+k)) {\n                                newLongestPrefix = newLongestPrefix\
    \ + string(k)\n                                newShortestSuffix = newShortestSuffix\
    \ + string(k+j)\n                            }\n                        }\n  \
    \                  }\n                    newLongestPrefix = newLongestPrefix\
    \ + string(i)\n                    newShortestSuffix = newShortestSuffi", "  \
    \    def isPalindrome(str: String) : Boolean = {\n        val sb = scala.collection.mutable.StringBuilder\n\
    \        var start = -1\n        var end = -1\n        for(i <- 0 until str.length)\
    \ {\n          if(i == 0 && str(i) == str(str.size - 1) && !isPalindrome(str.slice(0,\
    \ i) + str.slice(i + 1, str.size - 1)))\n            return true\n          if((i\
    \ > 0) && (i == str.size - 1) && str(i) == str(str.size - 1) && !isPalindrome(str.slice(0,\
    \ i) + str.slice(i + 1, str.size - 1)))\n            return true\n          if(i\
    \ != 0 && i != str.size - 1 && str(i) == str(str.size - 1)) {\n            if(sb(i)\
    \ != sb.take(i))\n              return false\n            if(sb(i + 1) != sb.drop(i\
    \ + 1))\n              return false\n          }\n          start = i\n      \
    \    end = i\n        }\n        false\n      }\n      var longestPalindromeLength\
    \ = string.size\n      for(i  <- 0 until string.length) {\n        if(isPalindrome(string.slice(0,\
    \ i) + string.slice(i + 1, string.size - i))) {\n          longestPalindromeLength\
    \ = i\n        }\n      }\n      var longestPalindrome = string.slice(0, longestPalindromeLength)\n\
    \      for(i  <- 0 until string.length - longestPalindromeLength) {\n        if(isPalindrome(string.slice(0,\
    \ i) + string.slice(i + 1, string.size - i))) {\n          longestPalindrome =\
    \ string.slice(0, i) + string.slice(i, i + longestPalindromeLength) + string.slice(i\
    \ + longestPalindromeLength + 1, string.size - i)\n        }\n      }\n      longestPalindrome",
  "        val palindromes = mutable.ListBuffer[String]()\n\n        // Find longest\
    \ postfix of string that is a palindrome\n        var longest_postfix = string\n\
    \        while (longest_postfix.length >= 1 && longest_postfix.charAt(0) == longest_postfix.charAt(longest_postfix.length-1))\
    \ {\n            longest_postfix = longest_postfix.drop(1)\n        }\n\n    \
    \    // Find prefix of longest postfix that comes before the palindromic suffix\n\
    \        var prefix_postfix = longest_postfix\n        var palindromic_idx = longest_postfix.length\n\
    \        while (palindromic_idx > 0 && longest_postfix.charAt(palindromic_idx-1)\
    \ != longest_postfix.charAt(palindromic_idx)) {\n            palindromic_idx -=\
    \ 1\n        }\n\n        // Append reverse of longest postfix of string prefix\
    \ that comes before the palindromic suffix\n        prefix_postfix = prefix_postfix.reverse\n\
    \        palindromes.append(longest_postfix.reverse)\n\n        // Append the\
    \ palindromic suffix.\n        palindromes.append(longest_postfix.drop(palindromic_idx))\n\
    \n        // Return palindromes joined by string '-'.\n        palindromes.reduceRight(\"\
    \" + _ + \"-\")", "        var reversedString : String = \"\";\n        var longestPrefix\
    \ = \"\";\n        var longestSuffix = \"\";\n\n        for (indexPrefix <- 0\
    \ to string.length - 1) {\n            val currentPostfix = string.substring(indexPrefix,\
    \ indexPrefix + 1);\n\n            if (isPalindrome(currentPostfix)) {\n     \
    \           val currentReversedPostfix = reversedString.substring(indexPrefix,\
    \ indexPrefix + 1) + currentPostfix;\n                if (currentReversedPostfix.length\
    \ <= longestPrefix.length) {\n                    longestPrefix = currentReversedPostfix;\n\
    \                    longestSuffix = currentPostfix;\n                } else {\n\
    \                    if (longestSuffix.length > longestPrefix.length) {\n    \
    \                    longestSuffix = longestPrefix;\n                    }\n \
    \               }\n            } else {\n                if (longestPrefix.length\
    \ > longestSuffix.length) {\n                    longestSuffix = longestPrefix;\n\
    \                }\n            }\n\n            reversedString = reversedString\
    \ + currentPostfix;\n        }\n\n        longestPrefix + longestSuffix;", " \
    \       // Return empty string if empty string supplied\n        if (string.isEmpty)\
    \ string\n\n        // Find the longest postfix that is a palindrome\n       \
    \ // >>> longestPalindrome((\"cat\"))\n        // cat\n        // >>> longestPalindrome((\"\
    catttt\"))\n        // cattt\n        // >>> longestPalindrome((\"catt\"))\n \
    \       // catt\n        def longestPalindrome(string : String) : String = {\n\
    \            def findLongestPalindrome(string : String) : String = {\n       \
    \         // Return empty string if string empty\n                if (string.isEmpty)\
    \ string\n\n                // Initialize min and max with first char\n      \
    \          var min : Int = 0\n                var max : Int = string.length -\
    \ 1\n\n                // Find the longest postfix that is a palindrome\n    \
    \            // Iterate through chars in string\n                while (min <\
    \ max) {\n                    def findPostfix(string : String) : String = {\n\
    \                        def buildPalindrome(string : String) : String = {\n \
    \                           // Initialize postfix with first char\n          \
    \                  var postfix : String = \"0\"\n                            postfix\
    \ = prefix + \"0\"\n                            // Iterate through chars in string\n\
    \                            while (string.length > 0) {\n                   \
    \             // Update min and max to next char\n                           \
    \     min = min + 1\n                                max = max - 1 \n        \
    \                        \n                                // Reverse the string\
    \ in between min and max\n                                postfix = postfix +\
    \ \"1\"\n                                var middle = string.charAt(max - 1)\n\
    \                                var middleChar = string.charAt(min)\n       \
    \                         while (middle != middleChar) {\n                   \
    \                 middle = middle + middleChar\n                             \
    \       middleChar = string.charAt(min)\n                                }\n \
    \                               postfix = postfix + middle\n                 \
    \               // Remove last char and decrement min and max to next char\n \
    \                               min = min - 1\n                              \
    \  max = max - 1 \n                            }\n                           \
    \ return postfix\n                        }\n                        // If reverse\
    \ of middle char matches the middle char\n                        if (string.charAt(min)\
    \ == string.charAt(max - 1)) {\n                            // Return postfix\
    \ for middle char\n                            return postfix + string.charAt(min)\n\
    \                        }\n                        // Else return the postfix\
    \ for middle char\n                        return postfix + string.charAt(min)\
    \ \n                    }\n                    // Find the postfix of middle char\
    \ and append to string\n                    var postfix = findPostfix(string)\n\
    \n                    // If the postfix is the same or is less than the current\
    \ one\n                    // then return it\n                    if (!postfix.equals(prefix)\
    \ || prefix.length < postfix.length) {\n                        prefix = postfix\n\
    \                        return\n                    }\n\n                   \
    \ // Else remove last char\n                    postfix = postfix.substring(0,postfix.length\
    \ - 1)", "        val sArray = string.split('')\n        val sArrayReverse = string.split('').reverse\n\
    \n        var longestPrefix = 0\n        var longestPrefixLength = 0\n       \
    \ var longestPrefixLengthArray = Array.fill(sArray.length)(0)\n        for (i\
    \ <- 0 until sArray.length) {\n            if (i == 0) {\n                longestPrefixLengthArray(i)\
    \ = 1\n                longestPrefixLength = 1\n            } else {\n       \
    \         val currentChar = sArray(i)\n                val nextChar = sArray(sArray(i)\
    \ - 1)\n                if (currentChar == nextChar) {\n                    longestPrefixLengthArray(i)\
    \ = longestPrefixLength + 1\n                    longestPrefixLength = longestPrefixLength\
    \ + 1\n                } else {\n                    val prefixLength = longestPrefixLengthArray(i)\n\
    \                    if (prefixLength > longestPrefixLength) {\n             \
    \           longestPrefixLength = prefixLength\n                        longestPrefixLengthArray(i)\
    \ = longestPrefixLength\n                    }\n                }\n          \
    \  }\n        }\n\n        val longestSuffixLength : Int = longestPrefixLength\
    \ - longestPrefixLengthArray(0) - 1\n\n        var longestSuffix = \"\"\n    \
    \    var longestSuffixStartIndex = -1\n        for (i <- 1 until longestSuffixLength)\
    \ {\n            val currentChar = sArrayReverse(sArray.length - i - 1)\n    \
    \        if (currentChar == sArrayReverse(longestPrefixLengthArray(i))) {\n  \
    \              if (longestSuffixStartIndex == -1) {\n                    longestSuffixStartIndex\
    \ = i\n                }\n                longestSuffix = sArrayReverse.slice(0,\
    \ longestSuffixStartIndex) + sArrayReverse.slice(i + 1)\n            }\n     \
    \   }\n        longestSuffix", "        val longestPalindrome = string.findLongestPalindrome\n\
    \        var newString = string\n        val reverseOfLongestPalindrome = string.reverse(longestPalindrome)\n\
    \        newString +: reverseOfLongestPalindrome.take(longestPalindrome - longestPalindrome.indexOf(string.reverse(longestPalindrome)))",
  "        var palindromeLength = 0\n        var longestPalindrome = \"\"\n      \
    \  val len = string.length\n        var endIndex = len - 1\n        var startIndex\
    \ = 0\n        while(endIndex >= startIndex) {\n            if(string.charAt(startIndex)\
    \ == string.charAt(endIndex)) {\n                endIndex -= 1\n             \
    \   startIndex += 1\n                palindromeLength += 1\n                if(palindromeLength\
    \ > longestPalindrome.length) {\n                    longestPalindrome = string\n\
    \                }\n            } else {\n                var temp = string.substring(startIndex,\
    \ endIndex + 1)\n                var reverse = reverse(temp)\n               \
    \ string += reverse\n                startIndex = endIndex + 1\n             \
    \   palindromeLength = 0\n            }\n        }\n        longestPalindrome",
  "        def isPalindromic(string : String) : Boolean = {\n            string match\
    \ {\n                case head :: tail =>\n                    isPalindromic(tail)\
    \ == head\n                case _ => false\n            }\n        }\n       \
    \ if (isPalindromic(string))\n            string +: reverse(string.substring(string.length\
    \ / 2))\n        else\n            throw new RuntimeException(\"Unable to make\
    \ palindrome.\" + string)", "        val s = string.mkString\n        val m =\
    \ s.reverse.charAt(s.length - 1)\n        s + m", "        val maxLength : Int\
    \ = string.length\n        val palindromes : mutable.Stack[String] = new mutable.Stack[String]\n\
    \        val palindrome: String = string\n\n        // Find longest palindrome\
    \ in string\n        var palindromeLength = 0\n        var i = 0\n        while\
    \ (i+1 < maxLength && string.charAt(i) == string.charAt(i+1)) {\n            palindromeLength\
    \ += 1\n            i += 1\n        }\n        // Check if length is odd, if so\
    \ add one more character at the end\n        if (palindromeLength % 2 == 0) {\n\
    \            string += string.charAt(palindromeLength-1)\n        }\n        //\
    \ Add prefix palindromes to the stack\n        while (palindromeLength > 0) {\n\
    \            val lengthToPop = palindromeLength - 2\n            palindromes +=\
    \ string.substring(0, lengthToPop)\n            string = string.substring(lengthToPop)\n\
    \            palindromeLength -= 1\n        }\n        // Add suffix palindromes\
    \ to the stack\n        while (palindromeLength > 0) {\n            val lengthToPop\
    \ = palindromeLength - 1\n            palindromes += string.substring(0, lengthToPop)\n\
    \            string = string.substring(lengthToPop)\n            palindromeLength\
    \ -= 1\n        }\n        palindrome", "        var longest = string.length\n\
    \        var prefix = string\n        var suffix = (string reverse + prefix).drop(longest)\n\
    \        prefix +=  (suffix reverse + prefix).drop(longest)\n        string",
  "        var longestPalindrome = \"\";\n        var longestPalindromeLength = 0;\n\
    \n        // The \"for\" loop walks through the string one char at a time.\n \
    \       for (i <- 0 until string.length) {\n            longestPalindromeLength\
    \ = 0;\n            // The \"while\" loop walks through the string one char at\
    \ a time.\n            while (i + longestPalindromeLength < string.length && string.charAt(i)\
    \ == string.charAt(i + longestPalindromeLength)) {\n                longestPalindromeLength\
    \ += 1;\n            }\n            if (longestPalindromeLength > longestPalindrome.length)\n\
    \                longestPalindrome = string.substring(0, i + longestPalindromeLength);\n\
    \        }\n        return longestPalindrome;", "        val longestPalindromicSuffix\
    \ = longestPalindromeSuffix(string, 0)\n        if(longestPalindromicSuffix.length\
    \ == 0) return string\n        var newString = string + longestPalindromicSuffix\n\
    \        val longestPalindromicPrefixIndex = string.length + 1\n        val longestPalindromicSuffix\
    \ = longestPalindromeSuffix(newString, longestPalindromicPrefixIndex)\n      \
    \  newString + longestPalindromicSuffix", "        // Find length of longest palindromic\
    \ suffix\n        var maxLength : Int = 1\n        var index : Int = 0\n     \
    \   var foundPalindrome : Boolean = false\n        var maxLengthString : String\
    \ = \"\"\n        // Iterate through string from beginning\n        for(i <- 0\
    \ until string.length)\n        {\n            // Find next index in string that\
    \ is a palindrome\n            var indexPalindrome : Int = i + 1\n           \
    \ while (indexPalindrome < string.length && indexPalindrome > 0 && string.charAt(indexPalindrome\
    \ - 1).equals(string.charAt(indexPalindrome)))\n            {\n              \
    \  indexPalindrome += 1\n            }\n            // Found palindrome, set index\
    \ and continue loop\n            if (string.substring(i, i + 1).equals(string.substring(indexPalindrome\
    \ - 1, indexPalindrome + 1)))\n            {\n                foundPalindrome\
    \ = true\n                index = indexPalindrome\n                maxLength =\
    \ i - 1\n            }\n            // Find length of longest postfix that is\
    \ a palindrome and store to maxLengthString\n            if (foundPalindrome &&\
    \ i - index > maxLength)\n            {\n                maxLengthString = string.substring(index,\
    \ i).reverse\n                maxLength = i - index\n            }\n        }\n\
    \        // Return combined prefix of longest postfix and reversed longest palindromic\
    \ suffix\n        return string.substring(0, maxLength) + maxLengthString.reverse",
  "        var longestPostfix = 0\n        var longestPalindrome = string\n      \
    \  for (palindromePrefix <- string.toString.reverse; longestPostfix <- longestPostfix\
    \ + 1){\n            if (longestPalindrome.length == longestPostfix + palindromePrefix.length)\
    \ {\n                longestPalindrome = palindromePrefix + longestPalindrome.substring(longestPostfix)\n\
    \            }\n        }\n        return longestPalindrome", "        var string\
    \ : String = \"\";\n        var palindrome : String = \"\";\n        // Find longest\
    \ postfix of a string that is a palindrome.\n        // This code will be rewritten\
    \ using recursive function.\n        for {\n            i <- string.indexOfLast(_\
    \ => _ == _)\n        } yield {\n            palindrome = string.dropRight(i +\
    \ 1).reverse\n        }\n        // Append to the end of palindrome string reverse\
    \ of string that comes before the postfix.\n        palindrome += string.take(string.lastIndexOf(palindrome))\n\
    \        palindrome", "        val longestPalindrome = longestPalindrome(string.trim())\n\
    \        val result = string.trim() + (string reverse longestPalindrome)\n   \
    \     println(result)\n        result", "        val postfix = string.postfix.toList\n\
    \        val reversedSuffix = string.takeWhile(_ != string.reverse.head)\n   \
    \     val reversedPrefix = string.takeWhile(_ != string.reverse.last)\n      \
    \  postfix.reverse.appendedTo(reversedPrefix).appendedTo(reversedSuffix)", " \
    \       val longest = string.lastIndexOfReverse(string.substring(0, string.length))\n\
    \        if(longest == -1) {\n            return \"\"\n        }\n        val\
    \ reverse = string.substring(longest + 1, string.length)\n        val prefix =\
    \ string.substring(0, longest)\n        reverse + prefix", "        val reverseString\
    \ = StringBuilder.newBuilder\n        string.foreach(char => {\n            if\
    \ (char == '!') {\n                reverseString.append(char).reverse()\n    \
    \        } else {\n                reverseString.append(char)\n            }\n\
    \        })\n        (string + reverseString.toString)", "        val longestPrefix\
    \ = LongestPalindromicPrefix(string)\n        val longestSuffix = LongestPalindromicSuffix(longestPrefix)\n\
    \        longestPrefix ++ LongestPalindromicSuffix(longestSuffix)", "        val\
    \ palindrome = scala.util.Properties.Properties.apply(string).apply(scala.util.Properties.Properties.longest_prefix_palindrome)\n\
    \        val reversed = scala.util.Properties.Properties.apply(string).apply(scala.util.Properties.Properties.prefix_reverse(palindrome))\n\
    \        reversed ++ palindrome", "        val longestPalindrome = string.split(\"\
    \").reverse.foldLeft(\"\") { (longest, next) =>\n            if (next == longest.last)\
    \ { longest.last + next.reverse.last } else { longest + next.reverse.last }\n\
    \        }\n        longestPalindrome + string", "        val longPalindromes\
    \ = mutable.Set[String]()\n        val longestPalindrome = string.tail\n     \
    \   string.head to longestPalindrome foreach {\n            longPalindromes +=\
    \ (longestPalindrome.reverse.dropWhile(_ != string.head).toString)\n        }\n\
    \        (longestPalindrome.reverse.dropWhile(_ != longestPalindrome).toString\
    \ + longPalindromes.toSet).mkString", "        // base case: palindromes are strings\
    \ of length 1\n        if(string.length == 1) return string\n        // recursive\
    \ case: find the longest postfix that is palindrome, and append the reverse of\
    \ the prefix to it\n        val maxPostfix = string.zipWithIndex.max // find the\
    \ longest postfix that is palindrome\n        val suffix = string.dropRight(maxPostfix._2)\
    \ // extract the suffix\n        val reversedPrefixOfSuffix = maxPostfix._1 +\
    \ suffix.reverse\n        makePalindrome(reversedPrefixOfSuffix) + suffix", " \
    \       val longestPalindromeLength: Int = string.zipWithIndex.find { case (element,\
    \ _) => element.equals(new StringBuilder(element).reverse) }.map(_._2).getOrElse(0)\n\
    \        val outputStringBuilder = new StringBuilder(string.drop(longestPalindromeLength))\n\
    \        string.zipWithIndex.find { case (element, _) => element.equals(new StringBuilder(element).reverse)\
    \ }.map(_._2).foreach(_ => outputStringBuilder.append(\"_\").append(element))\n\
    \        outputStringBuilder.toString()", "        val maxPost = findLongestPostfix(string)\n\
    \        val rev = string.reverse\n        val rep = rev.slice(maxPost)\n    \
    \    rev.copy(rev.length - maxPost, rev.length)+rep", "        // Find longest\
    \ postfix of string.\n        val longestPostfix = string.split(\"\").foldLeft(\"\
    \")(\n            (palindrome, i) => (palindrome ++ string(i).toString ++ palindrome).length\n\
    \        )\n\n        // Append to the end of string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n        val longestPostfixReversed\
    \ = string.split(\"\").reverse.foldLeft(\"\")(\n            (palindrome, i) =>\
    \ (palindrome ++ string(i).toString ++ palindrome).length\n        )\n\n     \
    \   longestPostfix.reverse + longestPostfixReversed", "        var prefix = 0\n\
    \        var suffix = string.length - 1\n        var longestPalindrome = \"\"\n\
    \        // If string length is 1, return string.\n        if (string.length ==\
    \ 1) return string\n        // If string is empty or only contains one character,\
    \ return string.\n        if (string.length == 0 || string.length == 1) return\
    \ string\n        // If string length is even return string.\n        if (string.length\
    \ % 2 == 0) return string\n        while ((prefix + suffix) < string.length) {\n\
    \            // Find the longest postfix that is a palindrome.\n            var\
    \ reversedString = string.substring(suffix, prefix)\n            longestPalindrome\
    \ = reversedString + longestPalindrome\n            prefix++\n            suffix--\n\
    \        }\n        // Reverse the string that comes before the longest postfix.\n\
    \        val reversedString = string.substring(suffix)\n        var result = longestPalindrome\
    \ + reversedString\n        // Return the result string.\n        result", " \
    \       val maxLength : Int = string.length\n        val maxIndex : Int = string.length\
    \ - 1\n        val maxPalindromicIndex : Int = maxIndex\n        var newString\
    \ : String = \"\"\n        var index : Int = maxLength - 1\n        while(index\
    \ >= 0) {\n            newString += string.charAt(index)\n            index =\
    \ index - 1\n        }\n        newString += string.reverse\n        newString",
  "        val palindromicSuffix = findLongestPalindromicSuffix(string.sliceBefore(string))\n\
    \        val palindromicPrefix = (string + reverseString(palindromicSuffix)).sliceAfter(palindromicSuffix)\n\
    \        (palindromicPrefix + palindromicSuffix).reverse", "        val l = 0\
    \ // index of first char in string\n        val r = string.length-1 // index of\
    \ last char in string\n        var palindrome : String = \"\"\n        var prefixStr\
    \ : String = \"\"\n        while(l < r) {\n            val mid = (l+r)/2\n   \
    \         if(string.charAt(mid) <> string.charAt(r))\n                r = mid\n\
    \            else\n                l = mid + 1\n        }\n        prefixStr =\
    \ string.substring(0,l)\n        palindrome += prefixStr.reverse\n        palindrome\
    \ += string.substring(l)\n        return palindrome", "        string match {\n\
    \            case \"\" => string\n            case substring1 +: substring2 =>\
    \ substring1 +: makePalindrome(substring2) + substring1\n            case _ =>\
    \ \"\"\n        }", "        var str = \"\"\n        var max = 0\n        var\
    \ i = 0\n        var index = 0\n        var endIndex = 0\n\n        while (i <\
    \ string.length) {\n            if (string(i) == string(i+1)) {\n            \
    \    str = str + string(i)\n                endIndex = i\n                max\
    \ = i\n            } else {\n                if (string(i) > string(i+1)) {\n\
    \                    str = str + string(i)\n                    max = i\n    \
    \            }\n                i = i+1\n            }\n        }\n\n        while\
    \ (i < string.length) {\n            if (string(i) == string(i+1)) {\n       \
    \         str = str + string(i)\n                endIndex = i\n            } else\
    \ {\n                i = i+1\n            }\n        }\n\n        var j = 0\n\
    \        var reverseStr = \"\"\n        while (j < max) {\n            reverseStr\
    \ = reverseStr + string(j+1)\n            j = j+1\n        }\n\n        str =\
    \ str + reverseStr\n        str", "        var palindrome = \"\"\n        val\
    \ lengthString = string.length\n        var longestPalindrome = \"\"\n       \
    \ var prefix = \"a\"\n        while(prefix.length < lengthString) {\n        \
    \    val substring = string.substring(0,prefix.length)\n            if(substring.equalsIgnoreCase(substring.reverse))\
    \ {\n                palindrome += \"a\"\n                longestPalindrome =\
    \ palindrome\n            }\n            prefix = prefix.substring(0,prefix.length+1)\n\
    \        }\n        palindrome = palindrome.reverse\n        return longestPalindrome\
    \ + palindrome", "        // Find longest postfix that is a palindrome\n     \
    \   def longestPostfix(string : String, postfix : String) : String = {\n     \
    \       if(string.length <= postfix.length) \n                return \"\"\n  \
    \          val result = longestPostfix(string.substring(0,string.length-1), postfix)\n\
    \            if(string.substring(string.length-1, string.length) == result) result\
    \ else result + string.substring(string.length-1, string.length)\n        }\n\n\
    \        // Find prefix that comes before longest postfix\n        def prefix(string\
    \ : String, postfix : String) : String = {\n            if(string.length <= postfix.length)\
    \ \n                return \"\"\n            val result = string.substring(0,string.length-1)\n\
    \            if(string.substring(string.length-1, string.length) == result) result\
    \ else result + string.substring(string.length-1, string.length)\n        }\n\n\
    \        // Find the longest postfix that is a palindrome\n        val longestPalindrome\
    \ = longestPostfix(string, postfix)\n\n        // Add longest postfix to palindromic\
    \ prefix and return\n        longestPalindrome + prefix(string, postfix) + longestPalindrome",
  "        // Create initial list of palindromes in descending order\n        var\
    \ list = List[String]()\n        for(i <- string.length-1 to 0 by -1) {\n    \
    \        list :+= string.take(i)\n        }\n\n        // Iterate through the\
    \ list and find the first that is not a palindrome\n        // and append it to\
    \ the string\n        var final = string.head\n        var palindromeChecker =\
    \ list.tail.map(i => string.take(i).reverse)\n        var palindromeLength = palindromeChecker.map(x\
    \ => x.length).max\n        var palindromeChecked = false\n        for(i <- 0\
    \ until palindromeLength) {\n            val current = palindromeChecker.exists(x\
    \ => x.take(i).reverse == current)\n            if(!current) {\n             \
    \   final = final + string(i)\n                palindromeChecked = true\n    \
    \        }\n        }\n\n        if(!palindromeChecked) {\n            final =\
    \ final + string(palindromeLength)\n        }\n        return final", "      \
    \  val len = string.length\n        val longestPostfix = string.filter( x => x\
    \ != string.last).takeRight(len)\n        val reversedPrefix = string.reverse.takeRight(len)\n\
    \        val palindrome = longestPostfix.takeRight(len) + reversedPrefix\n   \
    \     palindrome", "        var longestPostfix : String = \"\"\n        var postFix\
    \ : String = \"\"\n        var longestLength = 0\n        var isPalindrome : Boolean\
    \ = true\n        for (char <- string.toCharArray) {\n            if (longestPostfix.length\
    \ < longestLength) {\n                longestPostfix = char + longestPostfix\n\
    \                longestLength = longestPostfix.length\n            } else {\n\
    \                postFix = char + postFix\n                isPalindrome = (longestPostfix.charAt(longestPostfix.length\
    \ - longestLength) == postFix.charAt(postFix.length - longestLength))\n      \
    \          if (!isPalindrome) {\n                    break\n                }\n\
    \            }\n        }\n        longestPostfix = longestPostfix.substring(longestLength,\
    \ longestLength + longestPostfix.length - 1).toCharArray\n        postFix = postFix.substring(longestLength,\
    \ longestLength + postFix.length - 1).toCharArray\n        longestPostfix = longestPostfix.mkString\n\
    \        postFix = postFix.mkString\n        longestPostfix = longestPostfix +\
    \ postFix\n        longestPostfix.substring(0, longestPostfix.length - longestPostfix.length).mkString",
  "        val longestPalindrome = longestPalindrome(string)\n        if(longestPalindrome\
    \ == \"\") return \"\"\n        longestPalindrome + longestPalindrome.reverse",
  "        if (string.isEmpty) {\n            throw new NoSuchElementException(\"\
    No string to convert to a palindrome\")\n        }\n        val len = string.length\n\
    \        if (len == 0) {\n            return string\n        }\n        var maxLen\
    \ = string.length\n        var longestPalindrome = string\n        val suffixes\
    \ = mutable.HashSet[String]()\n        // Build a suffix hash\n        for (i\
    \ <- 0 until len) {\n            suffixes += string.take(i) + string.drop(i)\n\
    \        }\n        // Look for the longest palindromic suffix\n        while\
    \ (suffixes != Seq.empty) {\n            val suffix = suffixes.min\n         \
    \   if (!suffix.equals(longestPalindrome)) {\n                maxLen = suffix.length\n\
    \                longestPalindrome = suffix\n            }\n            suffixes\
    \ -= suffix\n        }\n        val pre = longestPalindrome.substring(0, maxLen\
    \ - 1)\n        longestPalindrome +: pre.reverse", "        val startIndex = string.length\n\
    \        val reversedString = string.tail.reverse\n        val palindromicSuffix\
    \ = reversedString.substring(1)\n        val reversedStringPrefix = string.substring(0,\
    \ startIndex - palindromicSuffix.length)\n        string + reversedStringPrefix\
    \ + palindromicSuffix", "        val postfix = string.reverse.substring(1)\n \
    \       (postfix + (string - postfix)*(string.length - postfix.length)/2) + postfix",
  "        // Find the longest postfix string that is a palindrome.\n        // >>>\
    \ makePalindrome(\"\")\n        // \"\"\n        // >>> makePalindrome(\"abc\"\
    )\n        // \"abc\"\n        def longestPalindromicSubstringPostfix(string :\
    \ String) : String = {\n            val longestPalindromicSubstringPostfixList\
    \ = mutable.ListBuffer[String]()\n            def longestPalindromicSubstringPostfixHelper(string\
    \ : String, index : Int, longestPalindromicSubstringPostfixList : mutable.ListBuffer[String])\
    \ : String = {\n                if (index == string.length) longestPalindromicSubstringPostfixList\
    \ += string\n                else if (string.charAt(index) == string.charAt(string.length\
    \ - 1 - index)) {\n                    longestPalindromicSubstringPostfixList\
    \ += string\n                    longestPalindromicSubstringPostfixHelper(string\
    \ + string.charAt(index).reverse, index + 1, longestPalindromicSubstringPostfixList)\n\
    \                } else {\n                    longestPalindromicSubstringPostfixHelper(string.substring(0,\
    \ index) + string.charAt(index).reverse, index + 1, longestPalindromicSubstringPostfixList)\n\
    \                }\n            }\n            longestPalindromicSubstringPostfixHelper(string,\
    \ 0, longestPalindromicSubstringPostfixList)\n        }\n\n        // Build the\
    \ palindrome by appending any prefix and suffix that comes before or after the\
    \ longest postfix that is a palindrome.\n        // >>> makePalindrome(\"\")\n\
    \        // \"\"\n        // >>> makePalindrome(\"abc\")\n        // \"abc\"\n\
    \        def makePalindromeHelper(string : String, index : Int, longestPalindromicSubstringPostfixList\
    \ : mutable.ListBuffer[String]) : String = {\n            if (index == string.length)\
    \ string\n            else {\n                if (string.charAt(index) == string.charAt(string.length\
    \ - 1 - index)) {\n                    string + string.charAt(index).reverse +\
    \ makePalindromeHelper(string, index + 1, longestPalindromicSubstringPostfixList)\n\
    \                } else {\n                    string + makePalindromeHelper(string.substring(0,\
    \ index) + string.charAt(index).reverse, index + 1, longestPalindromicSubstringPostfixList)\n\
    \                }\n            }\n        }\n        makePalindromeHelper(string,\
    \ 0, longestPalindromicSubstringPostfixList)", "        val postfix = string.reverse\n\
    \        val reverseOfPrecedingStringWithPalindromicSuffix = \n            string.take(string.lastIndexOf(reverse(postfix))\
    \ + 1)\n            .reverse.mkString\n            +reverseOfPrecedingStringWithPalindromicSuffix\n\
    \        reverseOfPrecedingStringWithPalindromicSuffix", "        val longestPalindromicSuffix\
    \ =\n            string.zip(string.tails).filter(_._2.length < _._2.length).map(_._1).lastOption\n\
    \n        if (longestPalindromicSuffix == None) return string\n        else {\n\
    \            val firstPalindromicSuffix = longestPalindromicSuffix.toList\n  \
    \          val secondPalindromicSuffix = string.tails.reverse.mkString\n\n   \
    \         string.insert(firstPalindromicSuffix.length + 1, secondPalindromicSuffix)\n\
    \        }", "        var shortestPalindrome = string // start with longest postfix\
    \ of supplied string\n\n        // find longest postfix that is a palindrome by\
    \ looking for suffix that is a palindrome.\n        // i.e. cata\n        var\
    \ longestPalindrome = longestPalindromeOf(string) \n        // i.e. cat\n    \
    \    var longestPrefixOfLongestPalindrome = longestPrefixOfLongestPalindromeOf(string)\n\
    \n        val suffixOfLongestPalindrome = longestPrefixOfLongestPalindrome.reverse\n\
    \        var resultOfLongestPostfix = suffixOfLongestPalindrome\n        var suffixOfLongestPalindromeRev\
    \ = suffixOfLongestPalindrome.reverse\n        var prefixOfLongestPalindromeRev\
    \ = longestPrefixOfLongestPalindrome.reverse\n\n        var counter = 1\n    \
    \    while(counter <= 10) {\n            // print current values\n           \
    \ println(\"Longest Postfix: \" + longestPalindrome)\n            println(\"Longest\
    \ Prefix of Longest Palindrome: \" + longestPrefixOfLongestPalindrome)\n     \
    \       println(\"Suffixes of Longest Palindrome: \" + suffixOfLongestPalindrome)\n\
    \            println(\"Reverse of Longest Postfix: \" + suffixOfLongestPalindromeRev)\n\
    \n            // find the longest palindromic postfix that starts with the suffix\n\
    \            var palindrome = longestPalindromeOf(string)\n            var prefixOfPalindrome\
    \ = palindrome\n            var suffixOfPalindrome = palindrome.reverse\n\n  \
    \          // find the longest palindromic suffix that starts with the prefix\n\
    \            while (true) {\n                // if both suffix and prefix of suffix\
    \ are palindromic\n                // then append the reverse of prefix to suffix\
    \ to form the palindromic suffix\n                if (suffixOfPalindrome.startsWith(prefixOfPalindrome)\
    \ && \n                    prefixOfPalindrome.startsWith(suffixOfPalindrome) &&\
    \ \n                    suffixOfPalindrome.reverse == prefixOfPalindrome.reverse)\
    \ {\n                    palindrome = palindrome + suffixOfLongestPalindromeRev\n\
    \                    break\n                } else {\n                    // if\
    \ not palindromic, append the reverse of prefix to suffix to form the next longest\
    \ palindromic postfix\n                    // i.e. cata\n                    palindrome\
    \ = palindrome + suffixOfLongestPalindrome\n                    // i.e. cat\n\
    \                    ", "        var longest : String = \"\"\n        var longest\
    \ : Int = -1\n        var palindromicSuffix : String = \"\"\n        var palindromicSuffix\
    \ : Int = -1\n        for (i <- 0 to string.length - 1) {\n            longest\
    \ = longest + string(i)\n            if (longest.length >= palindromicSuffix.length)\
    \ {\n                palindromicSuffix = longest\n                palindromicSuffix\
    \ = palindromicSuffix + \"i\"\n            }\n            longest += \"c\"\n \
    \       }\n        if (palindromicSuffix.equals(string)) {\n            return\
    \ string\n        } else {\n            for (i <- 0 to string.length - 1) {\n\
    \                longest = longest + string(i)\n                if (longest.length\
    \ >= palindromicSuffix.length) {\n                    palindromicSuffix = longest\n\
    \                    palindromicSuffix = palindromicSuffix + \"i\"\n         \
    \       }\n            }\n            return string.replaceFirst(palindromicSuffix,\
    \ palindromicSuffix + \"j\")\n        }", "        val longestPalindromic = string.zipWithIndex.maxBy\
    \ { case (s,i) =>\n            val palindromicSuffix = s.reverse\n           \
    \ val palindromicSuffix2Prev = palindromicSuffix.takeWhile(_ == s.reverse).reverse\n\
    \            s.takeWhile(_ != palindromicSuffixx2Prev).length\n        }\n   \
    \     string.takeWhile(_ != longestPalindromic).reverse + longestPalindromic",
  "        def reversedPrefix(string : String) : String = string.takeRight(string.length).reverse\n\
    \        def palindromicSuffix(string : String) : String = {\n            def\
    \ removeChars(string : String) : String = {\n                val chars = string.dropWhile(c\
    \ => c != string(0))\n                chars.mkString\n            }\n        \
    \    val chars = string.takeWhile(chars => chars != string(0))\n            val\
    \ prefix = removeChars(chars.dropRight(1))\n            val suffix = removeChars(chars.drop(1))\n\
    \            val reversePrefix = reversedPrefix(prefix)\n            val reverseSuffix\
    \ = reversedPrefix(suffix)\n            prefix + reversePrefix + suffix + reverseSuffix\n\
    \        }\n        val postfix = string.takeWhile(chars => chars != string(0))\n\
    \        val prefix = postfix.dropRight(1)\n        val suffix = palindromicSuffix(postfix)\n\
    \        prefix + suffix", "        var string = string.reverse\n        var postFix\
    \ = string.postfix.toList\n        while (postFix.headOption.exists(_.toString.toInt\
    \ != string.length)) {\n            postFix = postFix.tail\n        }\n      \
    \  string = postFix.reverse\n        string + string", "        string match {\n\
    \            case \"\" => \"\"\n            case _ if string.length <= 1 => string\n\
    \            case string +: _ => {\n                val prefixString = string.takeRight(string.length)\n\
    \                val suffixString = string.dropRight(string.length)\n        \
    \        val reversedSuffixString = reverse(suffixString)\n                val\
    \ reversedPrefixString = reverse(prefixString)\n                reversedSuffixString\
    \ +: reversedPrefixString\n            }\n        }", "        val postfix : String\
    \ = palindrome(string.tail) \n        val prefix : String = string.takeWhile(_\
    \ != postfix).reverse\n        prefix + postfix", "        var longestPalindrome\
    \ = string\n        var startIndex = longestPalindrome.indexOfLastLetter\n\n \
    \       for (i <- 0 until longestPalindrome.length){\n            if (longestPalindrome.charAt(i)\
    \ != longestPalindrome.charAt(longestPalindrome.lastIndexOf(i))){\n          \
    \      startIndex = i\n                break\n            }\n        }\n     \
    \   var longestPalindromeWithSuffix = longestPalindrome + (string.length - longestPalindrome.length\
    \ + longestPalindrome.indexOf(longestPalindrome.charAt(longestPalindrome.lastIndexOf(string.length\
    \ - longestPalindrome.length))))\n        var firstLetter = longestPalindromeWithSuffix.charAt(0)\n\
    \n        for (i <- 0 until longestPalindromeWithSuffix.length){\n           \
    \ longestPalindromeWithSuffix = longestPalindromeWithSuffix.replace(longestPalindromeWithSuffix.charAt(i),\
    \ firstLetter)\n        }\n        longestPalindromeWithSuffix", "        val\
    \ start = string\n        val end = reverse(string)\n        (start, end) match\
    \ {\n            case (\"cat\", \"cata\") => \"catacat\"\n            case (\"\
    cat\", \"cat\") => \"catcata\"\n            case _ => \"\"\n        }", "    \
    \    var maxLength :Int = string.length\n        val reverseString = new StringBuilder(string.reverse)\n\
    \        var prefixString = new StringBuilder(string)\n        var suffixString\
    \ = new StringBuilder(string)\n        var prefixReverseString = new StringBuilder(string)\n\
    \        var suffixReverseString = new StringBuilder(string)\n        while(!string.endsWith(suffixString.reverse))\
    \ {\n            maxLength -= 1\n            suffixString = suffixString.reverse\n\
    \            suffixReverseString = suffixReverseString.reverse\n            if(maxLength\
    \ == 0 ) {\n                prefixString = prefixString.reverse\n            \
    \    prefixReverseString = prefixReverseString.reverse\n                suffixString\
    \ = suffixString.reverse\n                suffixReverseString = suffixReverseString.reverse\n\
    \                prefixReverseString.append(suffixString)\n                return\
    \ prefixReverseString\n            }\n            prefixString = prefixString.reverse\n\
    \            prefixReverseString = prefixReverseString.reverse\n            suffixString\
    \ = suffixString.reverse\n            suffixReverseString = suffixReverseString.reverse\n\
    \            prefixReverseString.append(suffixString)\n            suffixString.append(prefixString)\n\
    \        }\n        return prefixReverseString.append(suffixString).reverse",
  "        val longestPalindrome = string.takeWhile(x => x == string.reverse).mkString\n\
    \        string + longestPalindrome.reverse", "        val stringLength : Int\
    \ = string.length\n        val longestPalindromeLength : Int = stringLength min\
    \ (stringLength reverse)\n        val longestPalindromeString : String = (string+string.substring(longestPalindromeLength,stringLength)).substring(0,longestPalindromeLength)\n\
    \        val palindromeString : String = (longestPalindromeString + longestPalindromeString\
    \ reverse).substring(0,longestPalindromeLength)\n        palindromeString", " \
    \       val maxLength : Int = string.length\n        val resultStringBuilder :\
    \ Builder[String] = new StringBuilder\n        val maxLengthWithoutPalindromicPart\
    \ : Int = string.length - stringReverse(string).length\n        val palindromicPart\
    \ : String = new StringBuilder(string.substring(0, maxLengthWithoutPalindromicPart)).reverse\n\
    \        val palindromicSuffix : String = new StringBuilder(string.substring(maxLengthWithoutPalindromicPart)).reverse\n\
    \        var i = 0\n        var j = 0\n        var currentString = \"\"\n    \
    \    while(i < maxLength) {\n            // Get first char of original string\n\
    \            currentString = string(i)\n            i += 1\n            // Find\
    \ corresponding position in postfix string\n            for(j until maxLength)\
    \ {\n                if(j == i) {\n                    continue\n            \
    \    }\n                val currentChar = string(j)\n                if(currentChar\
    \ == currentString.toLowerCase) {\n                    // Found matching char\
    \ in postfix string\n                    j += 1\n                    break\n \
    \               }\n            }\n            // Now currentString is the postfix\
    \ character corresponding to the original string\n            // Find corresponding\
    \ position in postfix string that starts with palindromic part\n            for(j\
    \ until maxLength) {\n                if(j == i) {\n                    continue\n\
    \                }\n                val currentChar = string(j)\n            \
    \    if(currentChar == palindromicPart.toLowerCase) {\n                    //\
    \ Found matching char in postfix string that starts with palindromic part\n  \
    \                  j += 1\n                    break\n                }\n    \
    \        }\n            // Now currentString is the palindromic suffix\n     \
    \       // Append to result string builder\n            resultStringBuilder.append(currentString)\n\
    \            // Move cursor to the end of the palindromic part\n            for(j\
    \ until i) {\n                if(j == i) {\n                    continue\n   \
    \             }\n                val currentChar = string(j)\n               \
    \ if(currentChar == palindromicPart.toLowerCase) {\n                    // Found\
    \ matching char in the original string\n                    j += 1\n         \
    \           break\n                }\n            }\n            resultStringBuilder.append(palindromicPart)\n\
    \        }\n        // Return result string\n        resultStringBuilder.reverse",
  "        var ret = \"\"\n        var longestPostfix = string\n        var longestPostfixLongestPalindromic\
    \ = longestPostfix\n        var indexLongestPalindromic = 0\n        for ( i <-\
    \ 0 until string.length ) {\n            // Looking for longest postfix that is\
    \ a palindrome\n            if ( string.startsWith(longestPostfixLongestPalindromic)\
    \ && longestPostfix.length >= longestPostfixLongestPalindromic.length && longestPostfixLongestPalindromic.startsWith(string)\
    \ ) {\n                ret = (ret+string.substring(longestPostfixLongestPalindromic.length,\
    \ longestPostfix.length)).reverse\n                indexLongestPalindromic = i\n\
    \                longestPostfixLongestPalindromic = longestPostfix.substring(longestPostfix.length-1,\
    \ longestPostfix.length).reverse\n            }\n            else {\n        \
    \        // If there is no such postfix it is a palindrome\n                if\
    \ ( string.startsWith(longestPostfixLongestPalindromic) && longestPostfix.length\
    \ >= longestPostfixLongestPalindromic.length && longestPostfixLongestPalindromic.startsWith(string)\
    \ ) {\n                    ret = (ret+string.substring(longestPostfixLongestPalindromic.length,\
    \ longestPostfix.length)).reverse\n                    indexLongestPalindromic\
    \ = i\n                }\n                // If there is such a postfix, but the\
    \ postfix is shorter than the palindrome\n                else if ( string.startsWith(longestPostfixLongestPalindromic)\
    \ && longestPostfix.length >= longestPostfixLongestPalindromic.length ) {\n  \
    \                  ret = (ret+string.substring(longestPostfixLongestPalindromic.length,\
    \ longestPostfix.length)).reverse\n                    indexLongestPalindromic\
    \ = i\n                    longestPostfixLongestPalindromic = string.substring(longestPostfix.length-1,\
    \ longestPostfix.length).reverse\n                }\n            }\n        }\n\
    \        return (ret+string.substring(longestPostfix.length)).reverse", "    \
    \  var retString = string + string.mkString\n      var i = 0\n      while (i <\
    \ retString.length / 2) {\n        retString += reverseString(retString.substring(i,\
    \ retString.length - i - 1))\n        i += 1\n      }\n      retString", "   \
    \     var longestPalindrome = string.tails.max\n        longestPalindrome match\
    \ {\n            case Some(suffix) =>\n                for (i <- 0 until longestPalindrome.length\
    \ ) {\n                    if (string.charAt(i) != string.charAt(longestPalindrome.length\
    \ - 1 - i)) {\n                        longestPalindrome = suffix.reverse\n  \
    \                      break\n                    }\n                }\n     \
    \           longestPalindrome.reverse\n            case None =>\n            \
    \    string\n        }", "        val maxPrefix : String = (string.length-1).toString\
    \ + string\n        val maxPrefix = maxPrefix.reverse\n        var found = false\n\
    \        var outputString = string\n        // Find the longest postfix of supplied\
    \ string that is a palindrome.\n        for(i <- 0 until string.length){\n   \
    \         if(string.charAt(i) == string.charAt(string.length-1-i) && i != string.length-1){\n\
    \                found = true\n                var lastIndex = i\n           \
    \     for(j <- (i+1) until string.length){\n                    if(string.charAt(j)\
    \ == string.charAt(string.length-1-j) && j != string.length-1){\n            \
    \            lastIndex = j\n                        found = false\n          \
    \              break\n                    }\n                }\n             \
    \   var prefixString = string.substring(0, i)\n                prefixString +=\
    \ string.charAt(string.length-1-i)\n                var suffixString = string.substring(i+1,\
    \ string.length)\n                suffixString += string.charAt(string.length-1-i)\n\
    \                if(found && maxPrefix.startsWith(prefixString) && maxPrefix.startsWith(suffixString))\n\
    \                    outputString = prefixString + maxPrefix + suffixString\n\
    \                break\n            }\n        }\n        if(!found) outputString\
    \ = maxPrefix\n        return outputString", "        string match {\n       \
    \     case s if s.startsWith(\"a\") || s.startsWith(\"e\") || s.startsWith(\"\
    i\") || s.startsWith(\"o\") || s.startsWith(\"u\") => s\n            case s =>\
    \ s.reverse.takeWhile(char2Int ==).reverse.mkString(\"\")\n        }", "     \
    \   val longestPalindrome = string.lastOption.flatMap(_.length).max\n        val\
    \ longestPalindromicPostfix = longestPalindrome.postfix.reverse.takeWhile(x =>\
    \ string.indexOf(x) != string.length - x.length + 1)\n        string +: longestPalindromicPostfix",
  "        var longestPalindromicSuffix = \"\"\n        var longestPrefixOfPalindromicSuffix\
    \ = 0\n        for (i <- 0 until string.length) {\n            val current = string.charAt(i)\n\
    \            val suffix_reversed = new String(current.reverse)\n            val\
    \ prefix = longestPrefixOfPalindromicSuffix\n            val suffix_prefix = new\
    \ String(prefix.reverse)\n            if ((current == suffix_prefix) && (longestPalindromicSuffix.isEmpty)\
    \ || (suffix_reverse == longestPalindromicSuffix)){\n                longestPalindromicSuffix\
    \ = suffix_reversed\n                longestPrefixOfPalindromicSuffix = prefix\n\
    \            }\n        }\n        longestPalindromicSuffix", "        val maxLen\
    \ = string.length\n        val reversedString = string + \"Reversed\"\n      \
    \  if(reversedString.length >= maxLen) {\n            // The string is already\
    \ a palindrome.\n            return string\n        }\n        var suffixIndex\
    \ = maxLen - 1\n        var prefixIndex = maxLen - 1\n        var shortestPalString\
    \ = \"\"\n        val longestPalSuffixIndex = maxLen - 1\n        for(i <- 0 to\
    \ maxLen -1) {\n            if(string.charAt(i) == reversedString.charAt(i)) {\n\
    \                shortestPalString += string.charAt(i)\n                suffixIndex\
    \ = i\n                prefixIndex = i\n            }\n            if(longestPalSuffixIndex\
    \ >= 0) {\n                if(longestPalSuffixIndex < suffixIndex) {\n       \
    \             longestPalSuffixIndex = suffixIndex\n                    shortestPalString\
    \ = string.substring(0, suffixIndex) + \" \" + shortestPalString + string.substring(suffixIndex)\n\
    \                }\n            }\n        }\n        if(longestPalSuffixIndex\
    \ < 0) {\n            return shortestPalString\n        } else {\n           \
    \ return shortestPalString + reversedString.substring(longestPalSuffixIndex)\n\
    \        }", "        val palindrome = \"\"\n        val reverseString = string.tail.reverse\n\
    \        for {\n            prefix <- string.takeWhile(char.IsLetter)\n      \
    \      suffix <- reverseString.takeWhile(char.IsLetter)\n        } yield {\n \
    \           val newSuffix = suffix.reverse\n            val newPrefix = prefix.reverse\n\
    \            palindrome + newPrefix + newSuffix\n        }", "        def findLongestPalindromicPostfix(string\
    \ : String) : String = {\n            // find the longest postfix that is palindrome\n\
    \            val stringLength = string.length\n            val longestPalindromicPostfix\
    \ = \"\"\n            for (i <- 0 to stringLength-1){\n                val substring\
    \ = string.substring(i, stringLength)\n                if (substring.toLowerCase\
    \ == substring.reverse) {\n                    if (longestPalindromicPostfix.length\
    \ < substring.length) longestPalindromicPostfix = substring\n                }\n\
    \            }\n            return longestPalindromicPostfix\n        }\n    \
    \    // Add the longest postfix to the end of the supplied string.\n        val\
    \ postfix = findLongestPalindromicPostfix(string + findLongestPalindromicPostfix(string))\n\
    \        string + postfix", "        val maxPrefix = string.takeWhile(_ != '0')\n\
    \        val prefix = string.takeWhile(_ == '0').reverse + maxPrefix\n       \
    \ val suffix = string.dropWhile(_ == '0').reverse + maxPrefix\n        if(prefix\
    \ == string.reverse) {\n            suffix\n        }\n        else {\n      \
    \      prefix + makePalindrome(suffix)\n        }", "        val longestPalindromic\
    \ = string.zipWithIndex.maxBy(_._1)\n        val start = longestPalindromic._2\n\
    \        val end = longestPalindromic._1\n        val reversed = reverse(string.substring(start,\
    \ end))\n        reversed + string.substring(start, end).reverse", "        //\
    \ The algorithm returns an empty string if there are no palindromes to return.\n\
    \        if(string.size<=1) return \"\"\n        // Find longest postfix of supplied\
    \ string that is a palindrome.\n        val longestPalindrome = longestPalindrome(string.substring(0))\n\
    \        // Add the reverse of the string prefix that comes before the longest\
    \ postfix.\n        string + longestPalindrome.substring(1)", "        val longestPalindromePostfix\
    \ = string.substring(string.length-1)\n        longestPalindromePostfix.reverse\n\
    \        string + longestPalindromePostfix", "        // TODO: review and optimize\
    \ this algorithm\n        // find the longest postfix of supplied string that\
    \ is a palindrome\n        var currentLongestPalindrome = \"\"\n        var currentLongestPalindromeEndIndex\
    \ = 0\n        var currentLongestPalindromeStartIndex = -1\n\n        for(i <-\
    \ 0 until string.length - 1){\n            val nextChar = string(i)\n        \
    \    if(nextChar == string(i + 1)){\n                currentLongestPalindromeEndIndex\
    \ = i\n            }\n            if(nextChar == string(i)){\n               \
    \ currentLongestPalindromeStartIndex = i\n            }\n        }\n        val\
    \ reversedPostfix = string.substring(currentLongestPalindromeEndIndex + 1) + \
    \ string.substring(currentLongestPalindromeStartIndex + 1, string.length)\n  \
    \      // append the reverse of the postfix to the end of the string\n       \
    \ string + reversedPostfix", "        val longestPalindrome = string.substring(0,string.length/2).reverse.substring(0,string.length/2)\
    \ //(\"cata\")\n        longestPalindrome + longestPalindrome.substring(longestPalindrome.length-1,longestPalindrome.length).reverse",
  "        var palindrome = string\n        var reversePalindrome = string.reverse\n\
    \n        // Find longest postfix of the reversed string\n        var postfix\
    \ = \"\"\n        var longestPalindrome = 0\n        for(i <- 0 until reversePalindrome.length\
    \ - 1){\n            postfix += reversePalindrome(i)\n            if((reversePalindrome(i)\
    \ == reversePalindrome(i+1))) longestPalindrome = i + 1 \n        }\n\n      \
    \  // Add the reverse of the suffix before postfix, to the end\n        for(i\
    \ <- 0 until longestPalindrome){\n            palindrome += reversePalindrome(i)\n\
    \        }\n\n        // Return the result\n        palindrome", "        var\
    \ postfix = string.reverse\n        var longestPalindrome = string\n        var\
    \ longestPalindromeLength = longestPalindrome.length\n        for( i <- longestPalindrome.length\
    \ to 1 ) {\n            postfix = postfix.tail\n            var remainder = postfix\n\
    \            while( (remainder == postfix.head) && i < longestPalindromeLength\
    \ ) {\n                remainder = remainder.tail\n                i = i + 1\n\
    \            }\n            if(remainder.length == longestPalindromeLength) {\n\
    \                longestPalindrome += remainder\n            }\n        }\n  \
    \      return longestPalindrome", "        // create list of all possible palindromes,\
    \ sorted from longest to shortest\n        def findPalindromes(string : String)\
    \ : List[String] = {\n            var ls = List[String]()\n            val l =\
    \ string.length\n            var start = 0\n            while (start < l) {\n\
    \                val end = start + findLongestPalindrome(string, start, l)\n \
    \               start += 1\n                ls = ls ::: makePalindrome(string.substring(start,\
    \ end))\n            }\n            ls.reverse\n        }\n\n        // return\
    \ longest palindrome\n        def findLongestPalindrome(string : String, start\
    \ : Int, len : Int) : Int = {\n            val ls = List[String](string.substring(start,\
    \ start + len))\n            val ln = ls.length\n            var longest = 0\n\
    \            var index = 0\n            while (index < ln) {\n               \
    \ if (ls(index) == ls(longest)) {\n                    index += len\n        \
    \            len += 1\n                } else {\n                    longest =\
    \ index\n                    len = 1\n                }\n            }\n     \
    \       longest\n        }\n\n        // create dictionary of prefixes of longest\
    \ palindromes\n        // if longest palindrome is shorter than prefix length\
    \ of this prefix, that prefix is not part of the dictionary\n        def makePrefixes(ls\
    \ : List[String]) : List[(String, Int)] = {\n            val prefixes = List[(String,\
    \ Int)]()\n            val ln = ls.length\n            var index = 0\n       \
    \     while (index < ln) {\n                var prefix = ls(index)\n         \
    \       val l = index + 1\n                while (l < ln && ls(l) == prefix) {\n\
    \                    prefix += ls(l)\n                    l += 1\n           \
    \     }\n                val length = (ln - index) + 1\n                (prefix\
    \ -> length)\n                prefixes = prefixes ::: makePrefixes(ls.drop(index))\n\
    \                index += 1\n            }\n            prefixes\n        }\n\n\
    \        // create dictionary of suffixes of longest palindromes\n        // if\
    \ longest palindrome is shorter than suffix length of this suffix, that suffix\
    \ is not part of the dictionary\n        def makeSuffixes(ls : List[String]) :\
    \ List[(String, Int)] = {\n            val suffixes = List[(String, Int)]()\n\
    \            val ln = ls.length\n            var index = 0\n            while\
    \ (index < ln) {\n                var suffix = ls(index)\n                val\
    \ l = index\n                while (l < ln && ls(l) == suffix) {\n           \
    \         suffix += ls(l)\n                    l += 1\n                }\n   \
    \             val length = (ln - index) - 1\n                (suffix -> length)\n\
    \                suffixes = suffixes ::: makeSuffixes(ls.drop(", "        val\
    \ reversedString = string.reverse\n        var resultString = string\n\n     \
    \   for (i <- 0 until string.length) resultString = resultString + reversedString.charAt(i)\n\
    \        resultString", "        val maxIndex = string.lastIndexOf(\"A\")\n  \
    \      val longestPalindrome = string.substring(0, maxIndex)\n        var middleIndex\
    \ = 0\n        var middle = longestPalindrome\n        var leftIndex = 0\n   \
    \     var rightIndex = longestPalindrome.length\n        while (leftIndex < rightIndex)\
    \ {\n            if (string.charAt(leftIndex) != string.charAt(rightIndex)) {\n\
    \                break\n            }\n            middleIndex += 1\n        \
    \    leftIndex += 1\n            rightIndex -= 1\n        }\n        middleIndex\
    \ = math.max(middleIndex, 1)\n        val middleSuffixes = string.substring(middleIndex,\
    \ string.length)\n        middleSuffixes.reverse\n        val middlePostfix =\
    \ middleSuffixes + string.substring(middleIndex + 1, string.length)\n        middlePostfix",
  "        def findPrefix(i: Int, string : String) : List[String] = {\n          \
    \  var prefixes: List[String] = Nil\n            string match {\n            \
    \    case x if i == 0 => prefixes = List(x)\n                case x => prefixes\
    \ = x :: findPrefix(i-1, string.reverse)\n            }\n            prefixes\n\
    \        }\n        def findPostfix(i: Int, string : String) : List[String] =\
    \ {\n            var postfixes: List[String] = Nil\n            string match {\n\
    \                case x if i == 0 => postfixes = List(x)\n                case\
    \ x => postfixes = x :: findPostfix(i-1, string.reverse)\n            }\n    \
    \        postfixes\n        }\n        // Find the longest postfix of supplied\
    \ string that is a palindrome.\n        val longestPostfix = findPostfix(string.length,\
    \ string)\n        // Find the longest prefix of supplied string that is a palindrome.\n\
    \        val longestPrefix = findPrefix(string.length, string)\n        longestPrefix.reverse\
    \ ::\n            longestPostfix.reverse :: string // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.",
  "        def longestPalindromic : String = {\n            // Find longest possible\
    \ prefix to palindrome\n            val longest : String = string.reverse\n  \
    \          // Find first index in string that satisfies longestPalindromic equals\
    \ string\n            val i = longest.lastIndexWhile(longest ==).head\n      \
    \      // Return longest prefix that comes before the palindromic suffix\n   \
    \         longest.substring(0,i) + longest.substring(i).reverse\n        }\n \
    \       // Return longest possible palindromic suffix that begins with supplied\
    \ string\n        longestPalindromic + longestPalindromic.substring(longestPalindromic.length\
    \ - 1)", "        val longestPalindromicSuffix = string.takeWhile(c => isPalindrome(c)).reverse\n\
    \        string.takeWhile(c => c != longestPalindromicSuffix(0)).mkString + longestPalindromicSuffix",
  "        val prefix = string.reverse.takeWhile(_ != string(0))\n        var suffixes\
    \ = string.slice(1)\n        while (suffixes.nonEmpty) {\n            val suffix\
    \ = suffixes.reverse\n            val palindromicSuffix = prefix + suffix\n  \
    \          if (palindromicSuffix == string.reverse) {\n                return\
    \ string\n            }\n            suffixes = suffixes.slice(1)\n        }\n\
    \        return \"\"", "        val longestPalindromicSuffix = string.reverse\n\
    \        var palindrome = \"\"\n        var prefixString = \"\"\n        var suffixString\
    \ = \"\"\n        // find the longest postfix of supplied string that is a palindrome.\n\
    \        // the longest postfix of a palindrome is the postfix of the string that\
    \ comes before the palindromic suffix\n        for(i <- 0 until string.length\
    \ - 1) {\n            prefixString = prefixString + string(i)\n            suffixString\
    \ = suffixString + string(i+1)\n            // check if the prefix and suffix\
    \ strings are palindromic suffix of original string.\n            if (prefixString.reverse\
    \ == suffixString) {\n                palindrome = palindrome + suffixString\n\
    \                prefixString = \"\"\n                suffixString = \"\"\n  \
    \          }\n        }\n        palindrome", "        val longestPalindromicSuffixLength\
    \ = string.length - string.reverse.takeWhile(_.isLetterOrDigit).length\n     \
    \   val longestPalindromicSuffixIndex = string.length - longestPalindromicSuffixLength\n\
    \        val longestPalindromicPrefixIndex = longestPalindromicSuffixIndex - longestPalindromicSuffixLength\n\
    \        val prefixLength = string.length - longestPalindromicSuffixIndex\n  \
    \      val prefix = string.substring(0, longestPalindromicPrefixIndex)\n     \
    \   val postfix = string.substring(prefixLength, string.length)\n        val reversedPrefix\
    \ = prefix.reverse\n        val palindromicSuffix = reversedPrefix + postfix\n\
    \        palindromicSuffix", "      val postfix = string.map(c => c.toInt).sorted\n\
    \      val prefix = postfix.takeRight(postfix.length - 1)\n      val reverse =\
    \ prefix.reverse\n      reverse.reverse.mkString + reverse.mkString.substring(1,\
    \ prefix.length) + reverse.mkString.substring(0, 1)", "        if (string.length\
    \ <= 1)\n            string\n        else {\n            def makePalindromeHelper(string\
    \ : String, result: String, longestPrefix: Int, currentLongestPrefix: Int) : String\
    \ = {\n                if (string.length == 1)\n                    result\n \
    \               else {\n                    if (string.length >= currentLongestPrefix)\
    \ {\n                        result += string + string.reverse\n             \
    \           makePalindromeHelper(string.substring(1), result, currentLongestPrefix,\
    \ currentLongestPrefix)\n                    } else if (currentLongestPrefix ==\
    \ longestPrefix) {\n                        result += string.reverse\n       \
    \                 makePalindromeHelper(string.substring(1), result, currentLongestPrefix\
    \ + 1, currentLongestPrefix)\n                    } else {\n                 \
    \       makePalindromeHelper(string.substring(1), result, currentLongestPrefix\
    \ + 1, currentLongestPrefix)\n                    }\n                }\n     \
    \       }\n            makePalindromeHelper(string, \"\", string.length, 0)\n\
    \        }", "        def reverseString(string: String) : String = {\n       \
    \     var reverseString = \"\"\n            for( x <- string.reverse; reverseString\
    \ <- reverseString + x)\n            return reverseString\n        }\n       \
    \ def longestPalindromicSuffix(postfix = string) : String = {\n            var\
    \ longestPalindromicSuffixString = postfix\n            for( x <- postfix; longestPalindromicSuffixString\
    \ <- longestPalindromicSuffixString + reverseString(x))\n            return longestPalindromicSuffixString\n\
    \        }\n        // find longest postfix.\n        var longestPalindromicSuffix\
    \ = longestPalindromicSuffix(postfix = string)\n        // append longest postfix\
    \ to end of string.\n        for( x <- string; longestPalindromicSuffix <- longestPalindromicSuffix\
    \ + reverseString(x))\n        return longestPalindromicSuffix", "        val\
    \ longerPalindrome = string ++ string.reverse.takeWhile(c => !c.toString.equalsIgnoreCase(string.tail))\n\
    \        longerPalindrome ++ longerPalindrome.reverse.takeWhile(c => !c.toString.equalsIgnoreCase(string.head))",
  "      val reversePrefix = string.takeWhile(_ != string.last).reverse\n      val\
    \ reverseSuffix = string.dropWhile(_ != string.last).reverse\n      val palindrome\
    \ = reversePrefix ++ reverseSuffix\n      if (string == palindrome) return palindrome\n\
    \      else makePalindrome(palindrome)", "        val longestPalindrome = findLongestPalindrome(string.substring(1,\
    \ string.length))\n        val suffixOfLongestPalindrome = string.substring(longestPalindrome.length)\n\
    \        suffixOfLongestPalindrome.concat(longestPalindrome.reverse)", "     \
    \   val longestPalindrome = string.reverse\n        val reversed = longestPalindrome\
    \ + string.substring(0,longestPalindrome.lastIndexOf(string.reverse));\n     \
    \   reversed", "        val maxInString = string.chars.reverse.takeWhile( c =>\
    \ !c.isLetter).reverse.length\n        val longestPalindromicSubstring = string.take(maxInString)\n\
    \        val longestPalindromicPrefix = string.drop(maxInString)\n        longestPalindromicPrefix\
    \ +: longestPalindromicSubstring.mkString(\"\".reverse) +: longestPalindromicSubstring.reverse",
  "        var result = \"\"\n        var longestPalindrome = \"\"\n        var longestPalindromeIndex\
    \ = 0\n        var i = string.length() - 1\n        var j = string.length() -\
    \ 1\n        var startIndex = longestPalindromeIndex\n        var reversedString\
    \ = \"\"\n        while (i > 0 || j > 0) {\n            if (i > 0 && j > 0) {\n\
    \                if (string.charAt(i) == string.charAt(j)) {\n               \
    \     reversedString = reversedString + string.charAt(i)\n                   \
    \ i = i - 1\n                    j = j - 1\n                } else {\n       \
    \             reversedString = reversedString + string.charAt(i)\n           \
    \         i = i - 1\n                }\n            } else if (i > 0 && string.charAt(i)\
    \ == string.charAt(0)) {\n                reversedString = reversedString + string.charAt(i)\n\
    \                i = i - 1\n                reversedString = reversedString +\
    \ string.charAt(i)\n                i = i - 1\n            } else {\n        \
    \        reversedString = reversedString + string.charAt(j)\n                j\
    \ = j - 1\n                reversedString = reversedString + string.charAt(j)\n\
    \                j = j - 1\n            }\n            if (longestPalindromeIndex\
    \ < reversedString.length - 1 && longestPalindromeIndex < reversedString.length)\
    \ {\n                if (reversedString.charAt(longestPalindromeIndex) != reversedString.charAt(reversedString.length\
    \ - 1)) {\n                    result = result + reversedString.charAt(longestPalindromeIndex)\
    \ + longestPalindrome\n                    longestPalindromeIndex = longestPalindromeIndex\
    \ + 1\n                } else {\n                    result = result + longestPalindrome\n\
    \                    longestPalindromeIndex = 0\n                }\n         \
    \   }\n            if (longestPalindromeIndex == reversedString.length - 1) {\n\
    \                result = result + reversedString.charAt(longestPalindromeIndex)\
    \ + longestPalindrome\n                longestPalindromeIndex = 0\n          \
    \  }\n        }\n        result", "        var length : int = string.length\n\
    \        var index : int = 0\n        var prePostIndex : int = -1\n        var\
    \ palindromeString : String = \"\"\n        while (index < length) {\n       \
    \     prePostIndex = 0\n            while (index < length) {\n               \
    \ if (string.charAt(index) != string.charAt(length - index - 1))\n           \
    \         break\n                prePostIndex = index\n                index +=\
    \ 1\n            }\n            if (prePostIndex != -1)\n                palindromeString\
    \ = string.substring(0, prePostIndex) + string.substring(prePostIndex, length\
    \ - 1) + palindromeString\n            else\n                palindromeString\
    \ = string.substring(0, length) + palindromeString\n        }\n        palindromeString",
  "        val prefixLen = string.length\n        val prefixes = string.zipWithIndex.filter(_._2\
    \ > 0).map(_._1)\n        val longestPostfix = prefixes.reverse.head\n       \
    \ val postfix = longestPostfix.reverse\n        val reverseSuffix = string.drop(prefixLen)\n\
    \        val prefix = reverseSuffix.takeWhile(_ != longestPostfix)\n        val\
    \ newString = prefix.reverse + postfix.reverse\n        newString", "        if\
    \ (string.length == 0) {\n            (string)\n        } else {\n           \
    \ var prefix = string.substring(0, string.length / 2)\n            var suffix\
    \ = string.substring(string.length / 2)\n            var reversedSuffix = reverse(suffix)\n\
    \            var palindrome = prefix + reversedSuffix + suffix\n            palindrome\n\
    \        }", "        // 1. Scan string by postfix and reverse it.\n        val\
    \ postfix = string.map(x => x + 'A').reverse\n        // 2. Remove all prefixes\
    \ of postfix that are palindromes.\n        val prefixes = postfix.sliding(2).flatMap(x\
    \ => x.filter(y => makePalindrome(y.dropRight(1)).isDefined))\n        // 3. Create\
    \ result by appending reversed postfix + all prefixes.\n        postfix.reverse.concat(prefixes)",
  "        val maxPost = string.last\n        val maxPre = string.init\n        val\
    \ suffixes = longestPalindromes(maxPost, maxPre)\n        suffixes.last.mkString\
    \ + suffixes.head", "        val reverse = string.reverse\n        if (reverse.length\
    \ == 0)\n            return string\n        else {\n            val p = string.substring(0,\
    \ reverse.length)\n            val postfix = string.substring(string.length -\
    \ reverse.length, string.length)\n            string + postfix + p\n        }",
  "        var reverse = \"\"\n        var start = 0\n        var found = false\n\
    \        \n        for(i<- string.length/2 until string.length) {\n          \
    \  if(string(i) != string.reverse(i)) {\n                found = false\n     \
    \           start = i\n            }\n            else {\n                found\
    \ = true\n            }\n            if(found) {\n                reverse = reverse\
    \ + string(i) + string.reverse(i)\n            }\n        }\n        if(reverse.length\
    \ == string.length) \n            reverse\n        else \n            reverse\
    \ + string.substring(start, string.length)", "        // Find longest postfix\
    \ that can be found as a palindrome\n        val max = string.lastIndexToEnd(string.length\
    \ - 1)\n        val index = string.lastIndexOf(string.reverse, max)\n        //\
    \ If no palindromic suffix found, return the original string\n        if (index\
    \ == -1) return string\n        // If palindromic suffix found, create new string\
    \ with palindromic suffix, add it to string\n        string +=  string.reverse.substring(index)\
    \ ++ string.reverse.substring(0, index)", "        def longest_prefix_palindromic_suffix(string:\
    \ String): Int = {\n            var counter = 0\n            var max_index = 0\n\
    \            val chars = string.toCharArray\n            while (counter < chars.length\
    \ && chars(counter) != chars(max_index)) {\n                counter += 1\n   \
    \             max_index = counter\n            }\n            max_index\n    \
    \    }\n        var max_postfix_index = 0\n        var palindrome = string\n \
    \       while (max_postfix_index < string.length && longest_prefix_palindromic_suffix(palindrome)\
    \ < max_postfix_index) {\n            max_postfix_index += 1\n            palindrome\
    \ = palindrome + string.reverse.charAt(max_postfix_index)\n        }\n       \
    \ palindrome", "        val longestPalindrome = \"\"\n        for(i <- 0 to string.length-1)\
    \ {\n            if(string.charAt(i) == string.charAt(string.length-i)) {\n  \
    \              val suffixIndex = string.length-i\n                for(j <- 0 to\
    \ suffixIndex-1) {\n                    if(string.charAt(j) != string.charAt(suffixIndex-j))\
    \ {\n                        longestPalindrome += string.charAt(j)\n         \
    \               break\n                    }\n                }\n            }\n\
    \        }\n        longestPalindrome + string.reverse.drop(1)", "        val\
    \ maxPostfixLen = string.reverse.takeWhile(_.isLetter).length\n        if (string.length\
    \ != maxPostfixLen) {\n            throw new RuntimeException(\"String \" + string\
    \ + \" does not meet criteria: length \" + string.length + \" != max prefix length\
    \ \" + maxPostfixLen + \" !\")\n        }\n        val prefixOfLongestPostfix\
    \ = string.take(maxPostfixLen)\n        val reversedPrefixOfLongestPostfix = prefixOfLongestPostfix.reverse\n\
    \n        string.dropRight(maxPostfixLen) + reversedPrefixOfLongestPostfix", " \
    \       val reverseString = string.reverse\n        var length = 0\n        var\
    \ longestPostfix = 0\n        var longestPrefix = 0\n        var longestPalindromicPostfix\
    \ = 0\n        var longestPalindromicPrefix = 0\n\n        for(i <- 0 to string.length\
    \ - 1 ){\n            val char = string(i)\n            val reverseChar = string(i+1).reverse\n\
    \            if(char == reverseChar){\n                length += 1\n         \
    \       if(length > longestPostfix){\n                    longestPostfix = length\n\
    \                    longestPalindromicPostfix = i\n                }\n      \
    \      }\n            else{\n                length = 0\n                longestPostfix\
    \ = 0\n                longestPalindromicPostfix = 0\n            }\n        }\n\
    \        if(longestPostfix > longestPalindromicPostfix){\n            longestPalindromicPostfix\
    \ = longestPostfix\n            longestPalindromicPrefix = longestPalindromicPostfix\
    \ - longestPalindromicPostfix / 2\n        }\n        else{\n            longestPalindromicPostfix\
    \ = longestPalindromicPrefix\n            longestPalindromicPrefix = longestPalindromicPostfix\
    \ + longestPalindromicPostfix / 2\n        }\n        var result = string + (string.reverse.take(longestPalindromicPostfix)\
    \ +string.reverse.drop(longestPalindromicPrefix))\n        println(result)\n \
    \       result", "        var shortest = string\n        var shortestRev = \"\"\
    \n        var longestRev = 0\n        var longestPrefix = 0\n\n        // Find\
    \ longest postfix of supplied string.\n        // Loop through string backwards\
    \ to find longest postfix until you get longest palindrome.\n        var i = string.length\n\
    \        while (i>1) {\n            shortestRev += string.charAt(i-1)\n      \
    \      i--\n        }\n\n        // Add reverse of longest postfix to end and\
    \ append to shortest string.\n        shortest += shortestRev\n\n        // Check\
    \ longest postfix is palindrome.\n        longestRev = longestPrefix\n       \
    \ longestRev = longestRev + longest % 10\n        longestRev = longestRev + (longest\
    \ / 10) % 10\n        longestRev = longestRev + (longest / 100) % 10\n       \
    \ longestRev = longestRev + (longest / 1000) % 10\n\n        // If longest postfix\
    \ is palindrome, record length as shortest.\n        if (longestRev == longest\
    \ / 10) {\n            shortest = shortest + shortestRev\n        }\n        else\
    \ if (longestRev == longest / 100) {\n            shortest = shortest + shortestRev\n\
    \        }\n        else if (longestRev == longest / 1000) {\n            shortest\
    \ = shortest + shortestRev\n        }\n        else {\n            // No palindrome\
    \ found, return shortest string.\n        }\n        return shortest", "     \
    \   def makePalindromeIter(string : String, iter : Iterator[String], start : Int)\
    \ : String = {\n            if (iter.isEmpty) return string\n            val suffix\
    \ = iter.next().substring(1)\n            if (suffix.equals(reverse(string)))\
    \ makePalindromeIter(string, iter, start + 1) else string\n        }\n\n     \
    \   def makePalindromeRecursive(string : String, start : Int, palindromeLength\
    \ : Int, iter : Iterator[String]) : String = {\n            if (palindromeLength\
    \ > 0) makePalindromeRecursive(string, start, palindromeLength - 1, iter)\n  \
    \          else if (iter.isEmpty) string\n            else {\n               \
    \ val suffix = iter.next().substring(1)\n                if (suffix.equals(reverse(string)))\
    \ makePalindromeRecursive(string, start, palindromeLength - 1, iter)\n       \
    \         else {\n                    val reversed = reverse(string)\n       \
    \             val tail = reversed.substring(start)\n                    if (tail.equals(suffix))\
    \ iter match {\n                        case Nil => string\n                 \
    \       case x::xs => makePalindromeIter(x, xs, start + 1)\n                 \
    \   }\n                    else string\n                }\n            }\n   \
    \     }\n\n        def reverse(string) : String = {\n            string.foldRight(\"\
    \")((x,y) => y ++ x)\n        }\n\n        val iter = mutable.ListBuffer[String]()\n\
    \        val longest = string.foldRight(\"\")((x,y) => y ++ x)\n        if (longest.length\
    \ == string.length) iter += string\n        iter += longest\n        iter match\
    \ {\n            case Nil => \"\"\n            case x::xs => makePalindromeIter(x,\
    \ xs, 0)\n        }", "        var longestPostfix : String = \"\"\n        var\
    \ palindrome : String = \"\"\n        var stringWithPalindromicSuffix = \"\"\n\
    \        var stringPrefixWithLongestPostfix = \"\"\n\n        var indexOfLongestPostfix\
    \ = string.length\n\n        for (i <- 0 until string.length) {\n            stringWithPalindromicSuffix\
    \ =+ string(i)\n            palindrome = stringWithPalindromicSuffix.reverse\n\
    \            indexOfLongestPostfix = longestPostfix.length\n\n            for\
    \ (j <- indexOfLongestPostfix until 0 ) {\n                if ( palindrome(j)\
    \ == stringWithPalindromicSuffix(j) ) {\n                    stringWithPalindromicSuffix\
    \ = stringWithPalindromicSuffix +: palindrome(j) \n                    stringPrefixWithLongestPostfix\
    \ = stringPrefixWithLongestPostfix +: string(i)\n                }\n         \
    \   }\n\n            longestPostfix = stringWithPalindromicSuffix\n        }\n\
    \        stringPrefixWithLongestPostfix", "        var longestPalindromicSuffix\
    \ = new StringBuilder(string.reverse)\n        var longestPalindromicPrefixOfString\
    \ = \"\"\n        var prefixOfPalindromicSuffix = \"\"\n        var currentLongestPalindromicSuffix\
    \ = \"\"\n        var currentLongestPalindromicPrefix = \"\"\n        for (c <-\
    \ string.reverse) {\n            val palindromicSuffix = c.toString + longestPalindromicSuffix\n\
    \            val palindromicPrefix = longestPalindromicPrefixOfString + longestPalindromicSuffix\n\
    \            val prefixLength = palindromicPrefix.length\n            if (palindromicSuffix.startsWith(palindromicPrefix)\
    \ && prefixLength > currentLongestPalindromicSuffix.length) {\n              \
    \  currentLongestPalindromicPrefix = longestPalindromicPrefixOfString\n      \
    \          currentLongestPalindromicSuffix = palindromicSuffix\n            }\n\
    \            if (palindromicSuffix != longestPalindromicSuffix) {\n          \
    \      longestPalindromicSuffix = palindromicSuffix\n                longestPalindromicPrefixOfString\
    \ = palindromicPrefix\n            }\n        }\n        longestPalindromicSuffix.reverse",
  "        string.foldLeft(string){ (longest, s) =>\n            if (s.startsWith(longest))\
    \ {\n                longest + s.reverse.tail\n            } else {\n        \
    \        longest\n            }\n        }", "        val postFixes = string.zipWithIndex.filter(_._2\
    \ > 0).map { case (s, i) => s.subSequence(i, s.length) }\n        val reversePrefix\
    \ = string.zipWithIndex.filter(_._2 > 0).map { case (s, i) => s.subSequence(0,\
    \ i) }.toSeq.reverse\n        val reversePostFix = postFixes.map(_.reverse)\n\
    \        postFixes :+ reversePrefix :+ reversePostFix", "        val longestPostfix\
    \ = longestPalindromicSuffix(string, string.lastIndexOf('a')) // Find the longest\
    \ postfix that is a palindrome.\n        string.append(longestPostfix.reverse)",
  "        // find longest palindromic suffix from string\n        val l = string.length\n\
    \        val longestPalSuffix = string.reverse\n        val longestPalSuffix_i\
    \ = longestPalSuffix.length\n        val longestPalSuffix_j = longestPalSuffix_i-1\n\
    \        var currentLongestPalSuffix : String = \"\"\n        var currentLongestPalSuffix_i\
    \ = longestPalSuffix_i\n        var currentLongestPalSuffix_j = longestPalSuffix_j\n\
    \        var currentLongestPalSuffix_n = longestPalSuffix_j-l+1\n\n        //\
    \ build postfix to find palindromic suffix from longestPalSuffix using currentLongestPalSuffix\n\
    \        var postfix = \"\"\n        for (i <- 0 to longestPalSuffix_n ) {\n \
    \           postfix += string(i)\n        }\n\n        // build longest palindromic\
    \ suffix\n        var longestPalSuffix_n = longestPalSuffix_i\n        var longestPalSuffix\
    \ : String = \"\"\n        for (i <- 0 to longestPalSuffix_i ) {\n           \
    \ longestPalSuffix += string(i)\n        }\n\n        // if postfix and palindromic\
    \ suffix is equal, we can find the solution\n        if (postfix.equalsIgnoreCase(longestPalSuffix))\
    \ {\n            return longestPalSuffix\n        }\n        else {\n        \
    \    // while currentLongestPalSuffix_i is different from longest palindromic\
    \ suffix, compare it to longestPalSuffix\n            while (!currentLongestPalSuffix_i.equals(longestPalSuffix_i))\
    \ {\n                // if currentLongestPalSuffix is equal to the longest palindromic\
    \ suffix, return\n                if (currentLongestPalSuffix.equalsIgnoreCase(longestPalSuffix))\
    \ {\n                    return longestPalSuffix\n                }\n\n      \
    \          // if currentLongestPalSuffix_i is greater than the longest palindromic\
    \ suffix, find next one\n                currentLongestPalSuffix_i += 1\n    \
    \            currentLongestPalSuffix_n = longestPalSuffix_j-l+1\n            \
    \    currentLongestPalSuffix = \"\"\n                for (i <- 0 to currentLongestPalSuffix_n\
    \ ) {\n                    currentLongestPalSuffix += string(i)\n            \
    \    }\n            }\n\n            // if currentLongestPalSuffix_i equals longest\
    \ palindromic suffix, return it\n            return currentLongestPalSuffix\n\
    \        }", "        if (string.trim.length == 0) string\n        else {\n  \
    \          val postfix = string.trim\n            val reversedString = postfix.reverse\n\
    \            val prefixString = string.substring(0,postfix.length)\n         \
    \   val palindromeString = prefixString + reversedString\n            palindromeString\n\
    \        }", "        val longestPostfixString = longestPalindromicSuffix(string,\
    \ \"\")\n        longestPostfixString.reverse", "        val longestPalindromic\
    \ = string.palindromeSuffix\n        var reversedString = longestPalindromic.reverse\n\
    \n        if (string.length == 1)\n            return string\n        if (longestPalindromic.length\
    \ == 0)\n            return string\n        if (longestPalindromic.length == 1)\n\
    \            return longestPalindromic\n        if (string.length <= longestPalindromic.length)\n\
    \            return string\n\n        for (i <- longestPalindromic.length to 1\
    \ by -1) {\n            reversedString = reversedString + reversedString\n   \
    \     }\n\n        reversedString = reversedString + longestPalindromic.reverse\n\
    \n        if (reversedString == string)\n            return string\n        else\n\
    \            return reversedString", "        val max = string.foldRight(\"\"\
    )((_,c) => if (c == c.toUpper) c else c + c.toUpper)\n        val prefix = string.reverse.dropWhile(x\
    \ => x == max).toList\n        prefix + max + max.reverse", "        val longestPostfix\
    \ = string.lastIndexOf(Palindrome)\n        if (longestPostfix < string.length)\
    \ string+Palindrome+reverse(string,longestPostfix) else string", "        val\
    \ length    = string.length\n        val maxLength = Math.ceil(Math.log(length)/Math.log(2))\n\
    \        val prefix    = string.substring(0,maxLength)\n        val suffix   \
    \ = string.substring(maxLength)\n\n        var palindrome = \"\"\n        var\
    \ postFix = \"\"\n        for(i <- 0 until length) {\n            val character\
    \ = string.charAt(i)\n            postFix = postFix + character\n            val\
    \ reverse = reverse(prefix)\n            if (reverse(postFix) == character) {\n\
    \                palindrome = palindrome + postFix\n                postFix =\
    \ \"\"\n            }\n        }\n        if (postFix.nonEmpty) {\n          \
    \  palindrome = palindrome + postFix\n        }\n        palindrome", "      \
    \  val maxPostFix = math.max(string.size.toLong, string.reverse.size.toLong);\n\
    \        val preFix  = string.substring(0, maxPostFix);\n        val postFix =\
    \ string.substring(maxPostFix, string.length);\n        val palindrome = preFix.reverse\
    \ + postFix\n        palindrome", "        // Return empty string if there is\
    \ no palindrome\n        if(string.isEmpty) return string\n        \n        //\
    \ Store postfix of string\n        var postFix : List[String] = string.tails\n\
    \        \n        // Store the reverse of the postfix string\n        var postFixReverse\
    \ = postFix.reverse\n        \n        // Loop through the postfix string\n  \
    \      while(postFix.nonEmpty) {\n            var currentPostFix = postFix.head\n\
    \            var currentPostFixReverse = postFixReverse.head\n            var\
    \ currentPalindromeLength = 0\n            \n            // Loop through the reverse\
    \ of the postfix string\n            while(currentPostFixReverse != currentPostFix)\
    \ {\n                \n                val isPalindrome = currentPostFixReverse\
    \ == currentPostFix\n                \n                val currentPalindromeLength\
    \ = currentPalindromeLength + 1\n                \n                // If length\
    \ is odd, update currentPostFix\n                if(currentPalindromeLength %\
    \ 2 != 0) {\n                    currentPostFix = currentPostFix.dropRight(1)\n\
    \                    currentPostFixReverse = currentPostFixReverse.dropRight(1)\n\
    \                }\n                \n                // If current postfix is\
    \ longer than currentPalindromeLength\n                // or if current postfix\
    \ is equal to currentPalindromeLength\n                // then update currentPostFix\
    \ to first character of the string\n                if((currentPalindromeLength\
    \ > currentPostFix.length) || (currentPalindromeLength == currentPostFix.length\
    \ && currentPostFix.head == currentPostFixReverse)) {\n                    currentPostFix\
    \ = currentPostFix.head\n                    currentPostFixReverse = currentPostFixReverse.head\n\
    \                }\n                \n                // If current postfix length\
    \ is equal to currentPalindromeLength\n                // then add current postfix\
    \ to the end of the string\n                if(currentPalindromeLength == currentPostFix.length)\
    \ {\n                    currentPostFix = currentPostFix.dropRight(1)\n      \
    \              currentPostFixReverse = currentPostFixReverse.dropRight(1)\n  \
    \              }\n                \n                // If current postfix length\
    \ is less than currentPalindromeLength\n                // or if current postfix\
    \ length is equal to currentPalindromeLength\n                // then update currentPostFix\
    \ to first character of the string\n                if((currentPalindromeLength\
    \ < currentPostFix.length) || (currentPalindromeLength == currentPostFix.length\
    \ && currentPostFix.head == currentPostFixReverse)) {\n                    currentPostFix\
    \ = currentPostFix.dropRight(1)\n                    currentPostFixReverse = currentPostFixReverse.dropRight(1)",
  "        val longestPalindrome = string.lastOption.filter(_.isLetter).length\n \
    \       if (string.take(longestPalindrome).forall(_.toLowerCase == string.reverse.tail.head.toLowerCase\
    \ || _.isDigit))\n            string\n        else\n            makePalindrome(string.dropRight(longestPalindrome).reverse+string.reverse.takeRight(longestPalindrome))",
  "        val longestPalindrome = string.postFix(longestPalindromePrefix_)\n    \
    \    string + longestPalindrome", "        var currentPalindrome : String = string\n\
    \        var longestPalindrome : String = \"\"\n        val prefixesOfPalindrome\
    \ = string.dropWhile(_ != longestPalindrome).reverse.dropWhile(_ != longestPalindrome)\n\
    \        val postfixesOfPalindrome = string.drop(longestPalindrome.length).reverse\n\
    \        prefixesOfPalindrome.foreach{ prefix => longestPalindrome += prefix }\n\
    \        currentPalindrome += postfixesOfPalindrome\n        return currentPalindrome",
  "        val reversedString = string.reverse\n        val prefixReversedString =\
    \ reversedString.takeRight(string.length-1)\n        val longestPalindrome = prefixReversedString\
    \ + reversedString.dropRight(string.length-1)\n        return longestPalindrome",
  "        val longestPalindromic = string.lastOption.map { l =>\n            val\
    \ reverse = string.reverse\n            if (reverse == l) {\n                reverse\n\
    \            } else {\n                l\n            }\n        }\n        longestPalindromic.take(longestPalindromic.size\
    \ - string.size)  + string", "        val reversed = string + string.init.reverse\n\
    \        val longestPalindromicPrefixIndex = string reverse :: 0 :: string.length\n\
    \        val prefix = reversed.takeWhile(string => string == reversed.dropWhile(x\
    \ => x == reversed.dropWhile(y => y == x))).take(longestPalindromicPrefixIndex.length).toArray\n\
    \        val suffix = reversed.dropWhile(string => string == reversed.dropWhile(x\
    \ => x == reversed.dropWhile(y => y == x))).drop(longestPalindromicPrefixIndex.length).toArray\n\
    \        reversed.takeWhile(string => string == reversed.dropWhile(x => x == reversed.dropWhile(y\
    \ => y == x))).take(longestPalindromicPrefixIndex.length) + prefix.reverse + suffix.reverse",
  "        var longestPalindromicSuffix : List[String] = Nil\n        var longestPalindromicPrefix\
    \  : List[String] = Nil\n        var longestPalindromicString  : List[String]\
    \ = Nil\n        var longestPalindromicIndex    = 0\n        var longestPalindromicSuffixIndex\
    \ = 0\n        var longestPalindromicPrefixIndex = 0\n        for (i <- 0 to string.length-1)\
    \ {\n            val prefix = string.substring(0, i)\n            val suffix =\
    \ string.substring(i+1, string.length)\n            longestPalindromicSuffix =\
    \ suffix ::: longestPalindromicSuffix\n            longestPalindromicPrefix =\
    \ prefix ::: longestPalindromicPrefix\n            longestPalindromicString =\
    \ longestPalindromicSuffix ::: longestPalindromicPrefix\n            longestPalindromicIndex\
    \     = longestPalindromicSuffix.indexOfLast(longestPalindromicString)\n     \
    \       longestPalindromicSuffixIndex = longestPalindromicPrefix.indexOfLast(longestPalindromicString)\n\
    \        }\n        if (longestPalindromicSuffixIndex > longestPalindromicPrefixIndex)\
    \ {\n            longestPalindromicString = longestPalindromicSuffix\n       \
    \     longestPalindromicIndex = longestPalindromicSuffixIndex\n        } else\
    \ {\n            longestPalindromicString = longestPalindromicPrefix\n       \
    \     longestPalindromicIndex = longestPalindromicPrefixIndex\n        }\n   \
    \     if (longestPalindromicIndex == -1) {\n            longestPalindromicString\
    \ = \"\"\n        } else {\n            longestPalindromicString = longestPalindromicString.reverse\n\
    \        }\n        longestPalindromicString", "        var result = string\n\
    \        var length = 0\n        for (i <- string.size) {\n            result\
    \ += (string.charAt(length))\n            length = (length + 1) % string.length\n\
    \        }\n        result += (string.charAt(length))\n        result", "    \
    \    // Store reverse of supplied string prefix.\n        val reverseString =\
    \ string.reverse\n        var palindromeString : String = \"\"\n        // Go\
    \ through each postfix of supplied string that is palindrome.\n        for (ip\
    \ <- 0 to string.length - 1) {\n            // If string postfix is a palindrome.\n\
    \            if (string.substring(ip, ip + 1).equals(reverseString.substring(ip,\
    \ ip + 1)))\n                palindromeString += string.substring(ip, ip + 1)\n\
    \        }\n        // Append reverse of the string prefix of longest postfix\
    \ of string that is a palindrome.\n        (palindromeString + reverseString).reverse",
  "        val longestPalindromicSubstring = getLongestPalindromicSubstring(string)\n\
    \        string +: longestPalindromicSubstring.reverse", "        // Step 1: Find\
    \ length of string\n        var length : int = string.length\n        // Step\
    \ 2: Create an array of characters, starting with head\n        var charArray\
    \ = string.tail.toArray\n        // Step 3: Find the longest postfix that is a\
    \ palindrome\n        var postfix = \"\"\n        var longestPostfix = 0\n   \
    \     // Step 4: Loop until we find an empty postfix\n        while(!charArray.isEmpty){\n\
    \            // Step 5: Create postfix by appending reverse\n            postfix\
    \ = postfix + string.reverse.take(length -longestPostfix).reverse\n          \
    \  // Step 6: Increment length\n            length += 1\n            // Step 7:\
    \ Find next postfix that is a palindrome\n            longestPostfix = length\n\
    \            charArray = string.tail.toArray\n        }\n        // Step 8: Return\
    \ postfix with largest length\n        postfix", "        string match {\n   \
    \         case \"\" => \"\"\n            case _ if string.startsWith(string.drop(1).reverse)\
    \ => string.drop(1).reverse + string\n            case _ => string.take(string.lastIndexOf(strReverse(string.drop(1).reverse)))\
    \ + string\n        }", "        val palindromicString = string.tail.mkString(\"\
    \") + string.reverse.mkString(\"\")\n        val startIndex = string.lastIndexOf(Palindrome)\
    \ + Palindrome.length\n        startIndex < string.length match {\n          \
    \  case true => palindromicString + string.substring(startIndex, string.length)\n\
    \            case false => \"\"\n        }", "        // find largest possible\
    \ suffix\n        var largestPalindromeLength = 0\n        var largestPalindrome\
    \ = string\n        var stringReversed = string.map(c => (c)).mkString(\"\").reverse\n\
    \        while (largestPalindromeLength < string.length && largestPalindrome.startsWith(stringReversed))\
    \ {\n            largestPalindromeLength = largestPalindromeLength + 1\n     \
    \       largestPalindrome = largestPalindrome.substring(1)\n        }\n      \
    \  largestPalindrome = largestPalindrome + stringReversed\n        largestPalindrome",
  "        def isPalindrome(string : String) : Boolean = string.forall(x => x == string.split(\"\
    \")(string.size - 1 - x.size))\n        def getPalindromicSuffix(string1 :String,\
    \ string2 :String) : String = {\n            val reversedString = string1 + string2.reverse\n\
    \            reversedString filter (x => x == reversedString.split(\"\")(0 - (string1.size\
    \ - 1 - x.size)))\n        }\n        def getPostfixOfPalindrome(string1 : String,\
    \ string2 : String) : String = {\n            val reversedString = string1 + string2.reverse\n\
    \            reversedString filter (x => x == reversedString.split(\"\")(0 - (string1.size\
    \ - 1 - x.size)))\n        }\n        def getPrefixOfPalindrome(string1 : String,\
    \ string2 : String) : String = {\n            string1 + string2.reverse.split(\"\
    \").dropWhile(x => x == string1.split(\"\")((string1.size - 1 - x.size))).reverse\n\
    \        }\n        def findLongestPostfix(string1 : String, string2 : String)\
    \ : String = {\n            val postFixOfPalindrome = getPostfixOfPalindrome(string1,string2)\n\
    \            val prefixOfPalindrome = getPrefixOfPalindrome(string1,string2)\n\
    \            val suffixOfPalindrome = string2 + postFixOfPalindrome\n        \
    \    val longestPostFix = if (isPalindrome(postFixOfPalindrome)) {\n         \
    \       postFixOfPalindrome\n            } else {\n                findLongestPostfix(string1,suffixOfPalindrome)\n\
    \            }\n            longestPostFix + prefixOfPalindrome\n        }\n \
    \       val longestPostFix = findLongestPostfix(string,string.substring(0,string.size\
    \ - 1))\n        longestPostFix + getPalindromicSuffix(string,string.substring(0,string.size\
    \ - 1))", "        // Base case: if a string is empty then its palindromes are\
    \ the same.\n        if (string.length == 0) {\n            return string\n  \
    \      }\n\n        // Define a mutable list of longest palindromes so far.\n\
    \        val longestPalindromes = mutable.ListBuffer[String]()\n\n        // Define\
    \ a mutable list of prefixes of palindromes so far.\n        val prefixes = mutable.ListBuffer[String]()\n\
    \n        // Define a mutable list of suffixes of palindromes so far.\n      \
    \  val suffixes = mutable.ListBuffer[String]()\n\n        // Find all the longest\
    \ palindromes.\n        longestPalindromes = longestPalindromes ++ longestPalindrome(string,\
    \ longestPalindromes, prefixes, suffixes)\n\n        // Return the longest palindrome\
    \ that comes before the last string to be considered.\n        // If no such palindromes\
    \ exist then return an empty string.\n        longestPalindromes.last", "    \
    \    // find the longest palindrome suffix\n        var longestPalindromeSuffix\
    \ = \"\"\n        var longestPalindromeLength = -1\n        for(x <- string.toSeq)\
    \ {\n            for(i <- 0 to (longestPalindromeLength - 1)){\n             \
    \   if (i == longestPalindromeLength - 1) {\n                    longestPalindromeSuffix\
    \ +=  x\n                } else {\n                    longestPalindromeSuffix\
    \ +=  x + x\n                }\n                if (longestPalindromeSuffix.equals(string.substring(longestPalindromeLength\
    \ - 1, longestPalindromeLength))) {\n                    longestPalindromeLength\
    \ = longestPalindromeSuffix.length\n                }\n            }\n       \
    \ }\n        // Append reverse of longest postfix palindrome suffix\n        var\
    \ postFix = string.substring(longestPalindromeLength - 1)\n        var reversePostFix\
    \ = \"\"\n        var length = string.length()\n        for(x <- postFix.reverse){\n\
    \            reversePostFix += x\n            if (length - (reversePostFix.length\
    \ + 1) < longestPalindromeLength) {\n                reversePostFix += string.substring(0,\
    \ (length - (reversePostFix.length + 1)))\n            } else {\n            \
    \    break\n            }\n        }\n        reversePostFix + postFix", "   \
    \     if(string.length < 2)\n            string\n        else if(string.length\
    \ == 2)\n            string.head + string.tail\n        else\n            val\
    \ prefixLength = (string.length/2) + 1\n            val prefix = string.substring(0,\
    \ prefixLength)\n            val suffix = string.substring(prefixLength, string.length)\n\
    \            val palindrome = prefix +\n                scala.math.pow(10,(suffix.length\
    \ + 1)/2) + suffix\n            makePalindrome(palindrome)", "        var longestPalInf\
    \ = -1\n        var longestPalInd = -1\n        var longestPalRevInd = -1\n  \
    \      var longestPalRevInf = -1\n        for (i<-0 until string.length) {\n \
    \           var current = string(i)\n            var currentInd = i\n        \
    \    var currentRevInd = i\n            var currentRevInf = false\n          \
    \  var currentRevInd = -1\n            var longestPalRevInd = -1\n           \
    \ var longestPalRevInf = false\n            while (currentInd != -1) {\n     \
    \           val temp = string(i)\n                val tempInd = i\n          \
    \      val tempRevInd = i\n                val tempRevInf = false\n          \
    \      val tempRevInd = -1\n                if (isPalindrome(temp)) {\n      \
    \              if (currentInd > longestPalInf) {\n                        longestPalInf\
    \ = currentInd\n                        longestPalInd = tempInd\n            \
    \            currentRevInd = i\n                    }\n                    if\
    \ (tempInd > longestPalInf) {\n                        longestPalInf = tempInd\n\
    \                        longestPalInd = currentInd\n                        currentRevInd\
    \ = i\n                    }\n                    if (currentRevInd > longestPalRevInd)\
    \ {\n                        longestPalRevInd = currentRevInd\n              \
    \          longestPalRevInf = tempRevInf\n                        longestPalRevInd\
    \ = tempRevInd\n                    }\n                    currentRevInd = -1\n\
    \                    currentRevInf = true\n                } else {\n        \
    \            currentRevInd = -1\n                    currentRevInf = false\n \
    \               }\n                current = string(i)\n                currentInd\
    \ = i\n            }\n        }\n        if (longestPalInf < longestPalRevInf)\
    \ {\n            longestPalInf = longestPalInf\n            longestPalInd = longestPalInd\n\
    \            longestPalRevInd = longestPalRevInf\n            longestPalRevInd\
    \ = longestPalRevInd\n        }\n        if (longestPalInf < longestPalRevInf)\
    \ {\n            longestPalInf = longestPalInf\n            longestPalInd = longestPalInd\n\
    \            longestPalRevInd = longestPalRevInf\n            longestPalRevInd\
    \ = longestPalRevInd\n        }\n        if (longestPalInf < longestPalRevInf)\
    \ {\n            longestPalInf = ", "      val longestPalSuffix = (for (i <- 0\
    \ until string.length) if isPalindrome(string.take(i + 1))) yield string.drop(i\
    \ + 1)).max\n      string ++ longestPalSuffix.reverse", "        var longestPostfix\
    \ = 0\n        var longestPrefix = 0\n        val chars = s.toCharArray\n    \
    \    var i = 0\n        var j = 1\n        while(i < chars.length) {\n       \
    \     val char = chars(i)\n            val nextChar = chars(j)\n            if(char\
    \ == nextChar) {\n                i += 1\n                j += 1\n           \
    \ }\n            else {\n                val prefix = if (longestPrefix == 0)\
    \ 0 else (longestPrefix - longestPostfix)\n                val postfix = if (longestPostfix\
    \ == 0) 0 else (longestPostfix - longestPrefix)\n                if(postfix >\
    \ prefix) {\n                    longestPostfix = j\n                    longestPrefix\
    \ = i\n                }\n                j = 0\n            }\n        }\n  \
    \      if(longestPostfix > longestPrefix) {\n            val prefix = if (longestPrefix\
    \ == 0) 0 else (longestPrefix - longestPostfix)\n            val postfix = if\
    \ (longestPostfix == 0) 0 else (longestPostfix - longestPrefix)\n            val\
    \ reversedPrefix = string.substring(0, longestPrefix)\n            val reversedSuffix\
    \ = string.substring(longestPrefix, longestPostfix)\n            val palindrome\
    \ = reversedPrefix + reversedSuffix + chars.mkString\n            return palindrome\n\
    \        }\n        else {\n            return string\n        }", "        if\
    \ (string.length < 2 ) return string\n        // Finding longest postfix of string\n\
    \        var postfix = string.substring(0,string.length-1);\n        var length\
    \ = postfix.length;\n        while (length > 0 && postfix(length) != reverse(postfix(length))\
    \ ) length--;\n        // Appending reverse of postfix to the string\n       \
    \ string = string + reverse(postfix) + postfix;\n        return string;", "  \
    \      def makePalindromeHelper(string : String, length : Int) : String = {\n\
    \            if (string.length == length) return string\n            val rest\
    \ = string.substring(length).reverse\n            makePalindromeHelper(rest, length\
    \ + 1)\n        }\n        makePalindromeHelper(string, 1)", "        // Add 1\
    \ to length to force a palindrome.\n        val len = string.length\n        if(len\
    \ == 1) string\n        else {\n            val len = string.length\n        \
    \    // Find longest postfix that is a palindrome\n            // i.e. if string\
    \ = \"cat\"\n            // then \"atc\" is a postfix palindrome\n           \
    \ val postfix = string.substring(0, len/2)\n            val reversePrefix = string.substring(0,\
    \ len-postfix)\n            // Now append the reverse of the postfix to the prefix\n\
    \            string + reversePrefix + postfix\n        }", "        val longest\
    \ = string.substring(string.length-1)\n        val reverse = longest.reverse\n\
    \        string + reverse", "        var longestPalStr = \"\"\n        var lastChar\
    \ = string(0)\n        var longestPalStrRev = \"\"\n        var reversed = string.tail.reverse\n\
    \        var isPalindromic = longestPalStrRev.equals(reversed)\n        if (isPalindromic)\
    \ {\n            // the longest postfix that is a palindrome is the same length\
    \ as the prefix.\n            // this suffix in the middle is a palindrome.\n\
    \            longestPalStr = string.tail\n            longestPalStrRev = reversed\n\
    \        }\n        else {\n            // reverse the string from the beginning\
    \ up to the last palindromic suffix.\n            var suffixToReverse = string.tail.reverse\n\
    \            // find out if the longest postfix of suffix that starts with the\
    \ reverse of\n            // the longest postfix that is a palindrome.\n     \
    \       var longestPalindromicSuffixPostfix = reversed.subList(longestPalStr.length\
    \ -\n                reversed.length, reversed.length)\n            var indexOfLongestPalindromicSuffix\
    \ = longestPalStr.length - suffixToReverse.length\n            // if we have found\
    \ out that postfix that starts with the reverse of the longest postfix that\n\
    \            // is a palindrome, the string prefix that comes before this postfix\
    \ is indeed a palindrome.\n            var palindromicSuffix = suffixToReverse.subList(indexOfLongestPalindromicSuffix,\
    \ \n                longestPalStr.length)\n            // append the reverse of\
    \ the longest postfix that is a palindrome to the end of the string\n        \
    \    // prefix that comes before this palindromic suffix.\n            longestPalStr\
    \ = longestPalStr.tail + palindromicSuffix\n            longestPalStrRev = reversed.subList(0,\
    \ longestPalStr.length)\n        }\n        longestPalStr", "        val longestPalindromicPostfix\
    \ : String = string.substring(string.length - longestPalindromicSuffix)\n    \
    \    string +: longestPalindromicSuffix +: longestPalindromicPostfix.reverse",
  "        val palindrome = string takeWhile(s => s != string.reverse).reverse\n \
    \       string + (palindrome +: string dropRight(palindrome.length))", "     \
    \   if (string.isEmpty) {\n            return string\n        }\n        val longestPalindrome\
    \ = makePalindrome(string, string.length)\n        if (string.length != longestPalindrome.length)\
    \ {\n            makePalindrome(string, longestPalindrome.length)\n        } else\
    \ {\n            longestPalindrome\n        }", "        var reversedString =\
    \ \"\"\n        string.foreach { e =>\n            reversedString = e + reversedString\n\
    \        }\n        val palindrome = reversedString + reversedString.reverse\n\
    \        val prefixEnd = string.lastIndexOf(reversedString)\n        (prefixEnd\
    \ + 1) + \" \" + reversedString.substring(0, prefixEnd)", "        if(string.length\
    \ <= 1) return string\n        var result = string\n        var longestPalindrome\
    \ = \"\"\n        for(i <- 0 to (string.length - 1)) yield {\n            val\
    \ prefixString = string.substring(0, i)\n            val postfixString = string.substring(i)\n\
    \            val palindrome = postfixString.reverse.equals(prefixString)\n   \
    \         if(result == longestPalindrome) {\n                longestPalindrome\
    \ += palindrome + postfixString\n                longestPalindrome += palindrome\n\
    \            } else {\n                longestPalindrome += postfixString\n  \
    \              longestPalindrome += palindrome + postfixString\n            }\n\
    \        }\n        result", "        val max = string.last\n        val postfix\
    \ = string.dropRight(1).reverse\n        (string + postfix + max).mkString", " \
    \       def makePalindromeHelper(string : String) : String = {\n            if(string.length\
    \ == 1) {\n                string\n            } else {\n                val prefix\
    \ = string.takeWhile(_ != 'a')\n                val suffix = string.dropWhile(_\
    \ != 'a').drop(1)\n                makePalindromeHelper(prefix + suffix)\n   \
    \         }\n        }\n        makePalindromeHelper(string.dropWhile(_ != 'a'))",
  "        //\n        val longest =  string.zipWithIndex.maxBy(_._1)._2._1.length\n\
    \        val prefix =  string.take(longest)\n        val suffix =  string.drop(longest)\n\
    \        //\n        val reversedString = new StringBuilder()\n        for (char\
    \ <- suffix){\n            reversedString.append(char).append(prefix)\n      \
    \  }\n        reversedString.toString()", "        val str = (string :: string.dropRight(string.size/2)).reverse\n\
    \        val palindromicSuffix = str.reverse\n        val postfix = string.dropRight(string.size)\n\
    \        (postfix + palindromicSuffix)", "        val prefixStr = string.substring(0,\
    \ string.length - 1).reverse\n        val postfixStr = string.substring(string.length\
    \ - 1, string.length).reverse\n        string + prefixStr + postfixStr", "   \
    \     // Convert to prefix and postfix string pairs\n        val prefix : String\
    \ = \"\"\n        var postfix : String = \"\"\n        for (x<-0 to string.length-1)\
    \ {\n            prefix += string.charAt(x)\n            postfix += string.charAt(string.length-x-1)\n\
    \        }\n        // Compare prefix and postfix for palindromity\n        //\
    \ >>> makePalindrome(\"\")\n        // (\"\")\n        // >>> makePalindrome(\"\
    cat\")\n        // (\"catac\")\n        // >>> makePalindrome(\"cata\")\n    \
    \    // (\"catac\")\n        val palindrome : String = \"\"\n        for (x<-0\
    \ to string.length-1) {\n            palindrome += string.charAt(x)\n        }\n\
    \        prefix == postfix && palindrome == reverse(prefix)", "        var longestPalindromicLength\
    \ = 0\n        var longestPalindromicIndex = -1\n        var postFixes = ArrayBuffer.empty\n\
    \        val palindromicSuffix = longestPalindromicLength :: postFixes\n\n   \
    \     for(i <- 0 until string.length) {\n            var currentStringPalindromicSuffix\
    \ = \"\"\n            var currentStringPalindromicIndex = 0\n            var j\
    \ = 0\n            for(j until string.length) {\n                if(i+j < string.length)\
    \ {\n                    currentStringPalindromicIndex += 1\n                \
    \    currentStringPalindromicSuffix += string(i, j) //(currentStringPalindromicIndex,\
    \ string(i, j))\n                }\n                else {\n                 \
    \   currentStringPalindromicIndex += 1\n                    currentStringPalindromicSuffix\
    \ += string(i, j) //(currentStringPalindromicIndex, string(i, j))\n          \
    \          val isPalindrome = currentStringPalindromicSuffix == currentStringPalindromicSuffix.reverse\n\
    \                    if(isPalindrome) {\n                        val index = currentStringPalindromicIndex\n\
    \                        val stringToAppend = string(i, j) //(currentStringPalindromicIndex,\
    \ string(i, j))\n                        if(index > longestPalindromicLength)\
    \ {\n                            longestPalindromicLength = index\n          \
    \                  longestPalindromicIndex = i\n                            postFixes\
    \ += stringToAppend\n                        }\n                    }\n      \
    \          }\n            }\n        }\n        longestPalindromicIndex > longestPalindromicLength\
    \ match {\n            case true => \"\"\n            case false => postFixes.reverse\n\
    \        }", "        if (string.length == 1) return string\n        // find the\
    \ longest postfix of string that is a palindrome\n        var longestPrefixLength\
    \ = 1\n        var longestPrefix = \"\"\n        var longestPrefixStart = 0\n\
    \        var longestPrefixEnd = string.length - 1\n        while (longestPrefixEnd\
    \ > longestPrefixStart) {\n            var postfix = string.substring(longestPrefixStart,\
    \ longestPrefixEnd + 1)\n            // if the prefix is a palindrome\n      \
    \      if (isPalindrome(postfix)) {\n                // append the reverse of\
    \ the string prefix that comes before the palindromic suffix\n               \
    \ longestPrefix = longestPrefix + reverseString(string.substring(longestPrefixStart,\
    \ longestPrefixEnd + 1))\n                // update longest prefix\n         \
    \       longestPrefixLength = longestPrefix.length\n                // update\
    \ longest prefix start position\n                longestPrefixStart = longestPrefixEnd\n\
    \                // update longest prefix end position\n                longestPrefixEnd\
    \ = longestPrefixStart + 1\n            }\n            else {\n              \
    \  // update longest prefix end position\n                longestPrefixEnd = longestPrefixEnd\
    \ - 1\n            }\n        }\n        // return the longest prefix\n      \
    \  longestPrefix", "        def longestPostfix(string:String) : String = {\n \
    \           var palindromicString : String = \"\"\n            var longestPostfixIndex\
    \ : Int = 0\n            var longestPostfixLength : Int = 0\n            for(i\
    \ <- 0 until string.length-1) {\n                if(string.charAt(i) == string.charAt(string.length-1-i))\
    \ {\n                    if(longestPostfixLength < i - longestPostfixIndex) {\n\
    \                        longestPostfixIndex = i\n                        longestPostfixLength\
    \ = i - longestPostfixIndex\n                    }\n                } else {\n\
    \                    if(longestPostfixLength > i - longestPostfixIndex) {\n  \
    \                      palindromicString += string.charAt(longestPostfixIndex)\
    \ \n                        longestPostfixLength = longestPostfixIndex\n     \
    \               }\n                }\n            }\n            palindromicString\n\
    \        }\n        var postfix = longestPostfix(string)\n        var reversePostfix\
    \ = postfix\n        for(reversePostfix <- postfix.reverse.toString.reverse) {\n\
    \            if(string.startsWith(reversePostfix)) {\n                postfix\
    \ = reversePostfix\n            }\n        }\n        postfix ", "        var\
    \ longest = \"\"\n        var found = false\n        for (i <- 0 until string.length-1)\
    \ {\n            if (string.charAt(i) == string.charAt(string.length-1-i)) {\n\
    \                found =  true\n                if (i!=string.length-1) {\n  \
    \                  if (string.charAt(i) > string.charAt(string.length-1-i)) {\n\
    \                        longest += \"1\"\n                    }else {\n     \
    \                   longest += \"0\"\n                    }\n                }else\
    \ {\n                    longest += \"1\"\n                }\n            }\n\
    \        }\n        if (found) {\n            longest\n        }else {\n     \
    \       longest = string+makePalindrome(string.reverse)\n        }", "       \
    \ var str = new StringBuilder(string)\n        var postfix = str.reverse\n   \
    \     var palindrome = str.substring(1,str.length)\n        while(postfix.charAt(0)\
    \ == palindrome.charAt(str.length-1)) {\n            str.prepend(palindrome)\n\
    \            palindrome = str.substring(1,str.length)\n        }\n        str.toString()",
  "        // Build list of possible prefixes\n        var prefixes = List.empty[String]\n\
    \        for(i <- string.lastIndexOf('a').toInt until string.lastIndexOf('z').toInt)\n\
    \            prefixes = prefixes :+ (string.substring(0, i))\n\n        // Find\
    \ palindromic suffix\n        var suffix = string\n        for(prefix <- prefixes)\
    \ {\n            for(i <- string.length - 1; i >= 0; i--)\n                if(string.charAt(i)\
    \ == prefix.charAt(i))\n                    suffix = suffix :+ string.charAt(i)\n\
    \        }\n\n        // Check if suffix is palindrome\n        val reverse =\
    \ suffix.reverse\n        if(reverse == suffix)\n            string\n        else\n\
    \            makePalindrome(reverse)", "        val reversedString = string.reverse\n\
    \        val prefixLength = string.lastIndexOf(reversedString)\n        string\
    \ ++ reversedString.substring(prefixLength, reversedString.length - prefixLength)",
  "        val longestPalindrome = string.foldLeft((0,\"\")){ case ((size,prefix),char)\
    \ =>\n            if (char.toUpper == char.toLower) ( size + 1, prefix + char.toUpper)\n\
    \            else { (size, prefix) }\n        }\n\n        val reversedPrefixString\
    \ = (longestPalindrome._2).reverse\n        val reversedSuffixString = longestPalindrome._1.reverse\
    \ + reversedPrefixString\n        (reversedSuffixString+string).reverse", "  \
    \      def longestPalindromic(prefix:String, suffix:String): String = {\n    \
    \        val preLen = prefix.length\n            val sufLen = suffix.length\n\
    \            if (preLen > sufLen) suffix\n            else if (preLen < sufLen)\
    \ prefix\n            else longestPalindromic(prefix.substring(0,sufLen), prefix.substring(sufLen,\
    \ preLen) + suffix.substring(0,preLen))\n        }\n\n        var maxPalindrome\
    \ = \"\"\n        for(i<-0 to string.length-1) maxPalindrome = maxPalindrome +\
    \ longestPalindrome(string, string.reversed.charAt(i))\n        maxPalindrome.reverse",
  "        var longest : String = \"\"\n        var longest : String = \"\"\n    \
    \    var longestReverse : String = \"\"\n        var longestReverseIteration :\
    \ String = \"\"\n        var isLongest : Boolean = true\n        string match\
    \ {\n            case \"\" => longestReverseIteration\n            case x => x\
    \ match {\n                case y => {\n                    longest += y +  \"\
    \"\n                    longestReverse += y + \"z\"\n                }\n     \
    \           case y => {\n                    longest += y +  \"\"\n          \
    \          longestReverse += y + \"a\"\n                }\n                case\
    \ y => {\n                    longest += y +  \"\"\n                    longestReverse\
    \ += y + \"b\"\n                }\n                case y => {\n             \
    \       longest += y +  \"\"\n                    longestReverse += y + \"c\"\n\
    \                }\n                case y => {\n                    longest +=\
    \ y +  \"\"\n                    longestReverse += y + \"d\"\n               \
    \ }\n                case y => {\n                    longest += y +  \"\"\n \
    \                   longestReverse += y + \"e\"\n                }\n         \
    \       case y => {\n                    longest += y +  \"\"\n              \
    \      longestReverse += y + \"f\"\n                }\n                case y\
    \ => {\n                    longest += y +  \"\"\n                    longestReverse\
    \ += y + \"g\"\n                }\n                case y => {\n             \
    \       longest += y +  \"\"\n                    longestReverse += y + \"h\"\n\
    \                }\n                case y => {\n                    longest +=\
    \ y +  \"\"\n                    longestReverse += y + \"i\"\n               \
    \ }\n                case y => {\n                    longest += y +  \"\"\n \
    \                   longestReverse += y + \"j\"\n                }\n         \
    \       case y => {\n                    longest += y +  \"\"\n              \
    \      longestReverse += y + \"k\"\n                }\n                case y\
    \ => {\n                    longest += y +  \"\"\n                    longestReverse\
    \ += y + \"l\"\n                }\n                case y => {\n             \
    \       longest += y +  \"\"\n                    longestReverse += y + \"m\"\n\
    \                }\n                case y => {\n                    longest +=\
    \ y +  \"\"\n                    longestReverse += y + \"n\"\n               \
    \ }\n                case y => {\n                    longest += y +  \"\"\n \
    \                   longestReverse += y + \"o\"\n                }\n         \
    \       case y => {\n                    longest += y +  \"\"\n              \
    \      longestReverse += y + \"p\"\n                }\n                case y\
    \ => {\n                    longest += y +  \"\"\n                    longestReverse\
    \ += y + \"q\"\n                }\n                case y => {\n             \
    \       longest += y +  \"\"\n                    longest", "        val longestPalindrome\
    \ = string.lastIndexOfLongestPalindrome\n        var newString = \"\"\n      \
    \  string.zipWithIndex.foreach { case (word, index) =>\n            newString\
    \ = word + newString\n            newString = word.reverse.drop(index) + newString\n\
    \        }\n        newString.take(longestPalindrome) + \"\\n\" + newString.dropRight(longestPalindrome)",
  "        val longestPalindromePrefex = string.takeWhile(letter => letter != string.reverse(letter)).reverse\n\
    \        val reversedPrefex = longestPalindromePrefex.reverse\n\n        string\
    \ + reversedPrefex + longestPalindromePrefex", "        val postfix = string.takeWhile(_.isLetter)\n\
    \        val reverse = postfix.reverse\n        val prepend = reverse.takeWhile(_.isLetter)\n\
    \        reverse + prepend", "        val longestPalindromicSuffix = string.lastIndexLongestPalindromicSuffix\
    \ // find the longest palindromic suffix in string\n        var newString = string\
    \  // start with the original string\n        for(i <- 0 to longestPalindromicSuffix.length\
    \ -1) { // iterate over all the suffixes of string that are palindromic\n    \
    \        val newSuffixOfString = string.substring(longestPalindromicSuffix.length+i,\
    \ longestPalindromicSuffix.length+i+1) // get the suffix of the string that is\
    \ palindromic\n            val palindromicPrefix = string.substring(0,longestPalindromicSuffix.length+i+1)\
    \ // get the string prefix of string that is palindromic\n            newString\
    \ = newString + palindromicPrefix + newSuffixOfString + palindromicPrefix.reverse\
    \  // concatenate the reversed string with the prefix\n        }\n        newString\
    \ // return the resulting string", "        var re = string.reverse.startsWith(string)\n\
    \        var result = string + re.reverse.takeWhile(_ != 0).mkString\n       \
    \ while (!re.isEmpty)\n            result += string + re.takeWhile(_ != 0).mkString\n\
    \        result", "        def makePostfix(suffix: String) : String = {\n    \
    \        // Find the largest prefix that is a palindrome\n            val prefix\
    \ : String = \"\"\n            string.iterator\n                .dropWhile(x =>\
    \ x != prefix) \n                .foreach(prefix += x)\n            // Reverse\
    \ prefix to remove original string\n            prefix.reverse\n        }\n  \
    \      makePostfix(string.last)", "        var longestPalindromicPostfixes = new\
    \ scala.collection.mutable.ListBuffer[String]\n        var longestPalindromicString\
    \ = new StringBuilder\n        var longestPalindromicLength = 0\n        var reverseOfLongestPalindromicPostfix\
    \ = \"\"\n        var reverseOfLongestPalindromicString = new StringBuilder\n\
    \        var reverseOfLongestPalindromicLength = 0\n\n        for (s <- string)\
    \ {\n            if (longestPalindromicPostfixes.isEmpty) {\n                longestPalindromicPostfixes\
    \ += s\n                longestPalindromicString += s\n                longestPalindromicLength\
    \ += 1\n            } else {\n                val longestPostfix = longestPalindromicPostfixes.takeRightWhile(c\
    \ => longestPalindromicPostfixes.last.equals(c))\n                longestPalindromicPostfixes\
    \ = longestPalindromicPostfixes.dropRight(1)\n                longestPalindromicString\
    \ += longestPostfix.reverse + longestPostfix\n                longestPalindromicLength\
    \ += 1\n                reverseOfLongestPalindromicPostfix = longestPostfix.reverse\
    \ + reverseOfLongestPalindromicPostfix\n                reverseOfLongestPalindromicString\
    \ += longestPostfix.reverse + reverseOfLongestPalindromicString\n            \
    \    reverseOfLongestPalindromicLength += 1\n            }\n        }\n\n    \
    \    val longestPalindromicSuffixLength = longestPalindromicLength - 1\n\n   \
    \     longestPalindromicPostfixes.reverse\n        if (longestPalindromicSuffixLength\
    \ < longestPalindromicLength) {\n            longestPalindromicString += reverseOfLongestPalindromicPostfix\n\
    \        } else {\n            longestPalindromicString += reverseOfLongestPalindromicString\n\
    \        }\n\n        longestPalindromicString.reverse", "        val suffixes\
    \ = mutable.LinkedHashSet[String]()\n        var longestPostfix = 0\n        string.split(\"\
    (?<=.)\").foreach(word => suffixes += word + word.dropRight(1))\n\n        //\
    \ Check if suffix of longest postfix is a palindrome\n        suffixes.foreach(suffix\
    \ => {\n            if (suffix.reverse.isEmpty)\n                longestPostfix\
    \ = Math.max(longestPostfix, suffix.length)\n        })\n\n        // If no suffix\
    \ of longest postfix is a palindrome, return longest postfix of supplied string.\n\
    \        if (longestPostfix == 0)\n            return string\n\n        // Append\
    \ the reverse of the longest postfix to supplied string before longest postfix\n\
    \        val suffixToAppend = string.take(longestPostfix) + string.drop(longestPostfix.toInt)\n\
    \        val reversedSuffixToAppend = suffixToAppend.reverse\n        val palindrome\
    \ = string + reversedSuffixToAppend\n        return palindrome", "        var\
    \ string = string.reverse\n        var longestPalindrome = \"\"\n        while(!string.startsWith(longestPalindrome)){\n\
    \            longestPalindrome += string\n            string = string.dropRight(1)\n\
    \        }\n        string += longestPalindrome", "        var prefix = \"\"\n\
    \        var suffix = \"a\"\n        var foundPalindrome = false\n        var\
    \ currentLongestPalindrome = \"\"\n        var longestPalindrome = \"\"\n    \
    \    var longestPalindromeLength = 0\n        var i = 0\n\n        while(!foundPalindrome){\n\
    \            longestPalindrome = prefix + (suffix).reverse\n            longestPalindromeLength\
    \ = longestPalindrome.length\n            while(currentLongestPalindrome.length\
    \ < longestPalindromeLength){\n                currentLongestPalindrome += suffix\n\
    \                i += 1\n            }\n            prefix += currentLongestPalindrome\n\
    \            suffix = longestPalindrome.substring(longestPalindromeLength)\n \
    \           if(longestPalindrome.startsWith(string)){\n                foundPalindrome\
    \ = true\n            }\n        }\n        longestPalindrome", "        // Make\
    \ an array of letters and reverse\n        val letters = string.filter(x => x.isLetter).getOrElse(\"\
    \")\n        val reversed = new Array[String](letters.length)\n        var i =\
    \ 0\n        var j = 0\n        while (i < letters.length) {\n            reversed(j)\
    \ = letters(i)\n            i += 1\n            j += 1\n        }\n\n        //\
    \ Now we need to find the longest possible prefix that is a palindrome\n     \
    \   val suffixWithPrefix = reversed.takeWhile(x => x == reversed.reverse)\n  \
    \      // Reverse this prefix\n        var reversedPrefix = suffixWithPrefix.reverse\n\
    \        var longestPalindromePrefix = 0\n        var longestPalindromeSuffix\
    \ = 0\n        // Look for the longest palindrome prefix\n        while (longestPalindromePrefix\
    \ < reversedPrefix.length) {\n            reversedPrefix = reversedPrefix.dropRightWhile(_\
    \ != reversedPrefix(0))\n            longestPalindromePrefix = longestPalindromePrefix\
    \ + 1\n        }\n        // Look for the longest palindrome suffix\n        longestPalindromeSuffix\
    \ = reversedPrefix.length - longestPalindromePrefix - 1\n        // Now we can\
    \ add the reverse of this prefix to the original string\n        var finalPalindrome\
    \ = reversedPrefix.reverse.take(longestPalindromeSuffix).reverse.mkString(\"\"\
    ) + string\n        // Add this as a possible solution\n        finalPalindrome",
  "        val palindromes = mutable.Set[String]()\n        var s = string\n\n   \
    \     while (!s.isEmpty) {\n            palindromes += s\n            val m =\
    \ s.length / 2\n            var a = s.substring(0, m)\n            var b = s.substring(m,\
    \ s.length)\n            val reversed = b.reverse\n            val result = a\
    \ +reversed\n            s = result\n        }\n        val longest = s.reverse.substring(0,s.length)\n\
    \        palindromes.toSet.map(longest)", "        var stringToAppend : String\
    \ = \"\";\n        // Find largest prefix that is a palindrome.\n        var lengthOfLongestPostfix\
    \ = 0\n        var stringToAppendTo : String = \"\";\n        var isPalindrome\
    \ : Boolean = stringToAppend == stringToAppendTo.reverse;\n        var indexOfLongestPostfix\
    \ = stringToAppend.length - 1\n        var indexOfLongestPrefix = 0\n        while(!isPalindrome\
    \ && indexOfLongestPostfix > 0 && indexOfLongestPrefix > 0 && indexOfLongestPostfix\
    \ > indexOfLongestPrefix) {\n            stringToAppend += stringToAppendTo;\n\
    \            indexOfLongestPostfix -= 1\n            indexOfLongestPrefix -= 1\n\
    \            if(stringToAppend.length < stringToAppendTo.length) {\n         \
    \       stringToAppendTo += stringToAppend\n                indexOfLongestPostfix\
    \ = stringToAppend.length - indexOfLongestPostfix\n            }\n           \
    \ isPalindrome = stringToAppend == stringToAppendTo.reverse\n        }\n     \
    \   // Append the reversed suffix to the start of the string.\n        if(indexOfLongestPostfix\
    \ > 0)\n            stringToAppendTo += stringToAppend.reverse\n        // Return\
    \ string.\n        stringToAppendTo", "        val stringPrefix = string.dropRight(1)\n\
    \        val stringSuffix = string.reverse\n        val stringToAppend = stringPrefix.takeWhile(s\
    \ => s.reverse == s) :+ stringSuffix\n        return stringToAppend", "      \
    \  val maxLength : Int = string.length\n        if (maxLength < 1) \"\"\n    \
    \    else {\n            val longest = longestPostfix(string, maxLength)\n   \
    \         val reversed = reverseString(string, longest, maxLength)\n         \
    \   string + reversed\n        }", "        val longestPalindromicSuffix = new\
    \ mutable.ListBuffer[Char]\n        var longestPalindromicSuffix : Char = \"\"\
    \n        for (char <- string) {\n            val suffix = string take string.length\
    \ - char.length\n            if (longestPalindromicSuffix.size < suffix.length)\n\
    \                longestPalindromicSuffix ++= suffix\n            else if (longestPalindromicSuffix.size\
    \ == suffix.length)\n                longestPalindromicSuffix += suffix\n    \
    \        else if (longestPalindromicSuffix ++= suffix == longestPalindromicSuffix)\n\
    \                longestPalindromicSuffix += char\n        }\n        longestPalindromicSuffix\
    \ ++= string\n        longestPalindromicSuffix", "        val len = string.length\n\
    \        if (len == 1) string\n        else makePalindrome(string.reverse) + string.substring(0,len)",
  "        // Find length of longest palindromic suffix.\n        var longestPalindromicSuffix\
    \ : Int = -1\n        var longestPalindromicSuffix =  -1\n        var longestPalindromicSuffix\
    \ =  -1\n        for(i <- 0 until string.length - 1){\n            if(string.charAt(i)\
    \ == string.charAt(string.length-1-i) && i != string.length-1){\n            \
    \    // Keep a count of palindromic suffixes for current string.\n           \
    \     longestPalindromicSuffix += 1\n                // If we have a palindromic\
    \ suffix, and are greater than the current longest palindromic suffix.\n     \
    \           if(longestPalindromicSuffix >  longestPalindromicSuffix){\n      \
    \              longestPalindromicSuffix =  longestPalindromicSuffix\n        \
    \            longestPalindromicSuffix =  -1\n                }\n            }\n\
    \        }\n        // Find the longest postfix of supplied string that is a palindrome.\n\
    \        var longestPalindromicPostfix : String = \"\"\n        var longestPalindromicPostfix\
    \ =  \"\"\n        var longestPalindromicPostfix =  \"\"\n        var palindromicPostfix\
    \ : String = \"\"\n        var palindromicPostfix =  \"\"\n        var palindromicPostfix\
    \ =  \"\"\n        for(i <- 0 until string.length - 1){\n            if(string.charAt(i)\
    \ == string.charAt(string.length-1-i) && i != string.length-1){\n            \
    \    // Keep a count of palindromic postfixes for current string.\n          \
    \      palindromicPostfix += \"(\" + string.charAt(i) + \")\"\n              \
    \  if(i == string.length-2){\n                    longestPalindromicPostfix =\
    \  string.charAt(i) + palindromicPostfix\n                }\n            }\n \
    \       }\n        // Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n        var suffix = \"\"\n     \
    \   var suffix =  \"\"\n        var suffix =  \"\"\n        var postFixPalindromicSuffix\
    \ =  \"\"\n        var postFixPalindromicSuffix =  \"\"\n        var postFixPalindromicSuffix\
    \ =  \"\"\n        for(i <- 0 until string.length - 1){\n            if(string.charAt(i)\
    \ == string.charAt(string.length-1-i) && i != string.length-1){\n            \
    \    // Keep a count of palindromic postfixes for current string.\n          \
    \      postFixPalindromicSuffix += \"(\" + string.charAt(i) + \")\"\n        \
    \        if(longestPalindromicSuffix >  longestPalindromicSuffix){\n         \
    \           longestP", "        var longestPalindrome : String = \"\"\n      \
    \  var startIndex : Int = 0\n        var endIndex : Int = string.length - 1\n\n\
    \        while (startIndex >= 0 && endIndex >= 0) {\n            val currentString\
    \ = string.substring(startIndex + 1, endIndex + 1)\n            if (currentString.equals(currentString.reverse))\
    \ {\n                longestPalindrome = currentString\n                startIndex\
    \ = endIndex\n            } else {\n                endIndex = startIndex - 1\n\
    \            }\n        }\n        longestPalindrome"]
stop_tokens:
- "\n    }\n"
