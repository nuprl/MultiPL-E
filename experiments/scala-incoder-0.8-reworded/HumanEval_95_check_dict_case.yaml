name: HumanEval_95_check_dict_case
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a map, return true if all keys are strings in lower \n    // case\
  \ or all keys are strings in upper case, else return false.\n    // The function\
  \ should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"\
  a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"\
  a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n\
  \    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\"\
  , \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"\
  Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n\
  \    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"\
  12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"\
  p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"\
  p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n\
  \    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"\
  banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"\
  Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n\
  \    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"\
  12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" ->\
  \ \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]()))\
  \ == (false));\n    }\n\n}\n"
completions: ["        dict foreach {\n            case(a,b) => { if(a < 'A' && 'Z'\
    \ <= a) println(a+\" is in lower case in dict\"); else println(a+\" is in upper\
    \ case in dict\"); }\n        }\n        true", "        val keys = dict.keySet\n\
    \        if (keys.length == 0) false\n        else keys.forall(_.isInstanceOf[String])\
    \ && (keys.forall(_.toLowerCase) == keys.forall(_.toUpperCase))", '        !dict.isEmpty',
  "        if(dict.isEmpty)\n            return false\n        val keySet = dict.keys\n\
    \        for(key<-keySet){\n            if(!key.isInstanceOf[Int]){\n        \
    \        return false\n            }\n        }\n        for(key<-keySet){\n \
    \           if(!key.isInstanceOf[Long]){\n                return false\n     \
    \       }\n        }\n        for(key<-keySet){\n            if(!key.isInstanceOf[Float]){\n\
    \                return false\n            }\n        }\n        for(key<-keySet){\n\
    \            if(!key.isInstanceOf[Double]){\n                return false\n  \
    \          }\n        }\n        for(key<-keySet){\n            if(!key.isInstanceOf[String]){\n\
    \                return false\n            }\n        }\n        true", "    \
    \    if (dict == null)\n            return false\n\n        def isStr(key: String,\
    \ value: String) : Boolean = {\n            if (key.isUpperCase && value.isLowerCase\
    \ || key.isLowerCase && value.isUpperCase)\n                true\n           \
    \ else\n                false\n        }\n\n        if (dict.isEmpty)\n      \
    \      return false\n\n        val strs = dict.keySet.toList\n\n        for (x\
    \ <- strs) {\n            if (!isStr(x, dict(x)))\n                return false\n\
    \        }\n\n        true", "        val list = new mutable.ArrayBuffer[String]()\n\
    \        for(key <- dict.keys) {\n            if(key matches regex(\"^[a-z][A-Z]*$\"\
    ) || key matches regex(\"^[A-Z][a-z]*$\"))\n                list += key\n    \
    \    }\n        if(list.size == 0) \n            return true\n        false",
  "        if(dict.isEmpty) false\n        else if(dict.values.forall(_.toString.isEmpty))\
    \ false\n        else if(dict.values.exists(_.toString().toLowerCase) == \"true\"\
    ) false\n        else if(dict.values.exists(_.toString().toUpperCase) == \"true\"\
    ) false\n        else true", "        if(!dict.isEmpty)\n        {\n         \
    \   var flag : Boolean = false\n            for(key <- dict.keySet)\n        \
    \    {\n                if(key.toString.toLowerCase == key.toString)\n       \
    \         {\n                    flag = true\n                    break\n    \
    \            }\n            }\n            return flag\n        }\n        return\
    \ false", "        if (dict.size == 0) return false\n        var allUpper = true\n\
    \        val keys = dict.keySet\n        val keys = keys.toList\n        keys.sortWith((x,y)\
    \ => x < y)\n        keys.foreach { key =>\n            if (!dict.get(key).isInstanceOf[String])\
    \ allUpper = false\n        }\n        allUpper", "        var result = true\n\
    \        for ( (k, v) <- dict) {\n            if (k.asInstanceOf[String].equalsIgnoreCase(k))\
    \ {\n                result = false\n                break\n            }\n  \
    \      }\n        return result", "        val keys = dict.keys.toList\n     \
    \   if (keys.size == 0) {\n            return true\n        } else if (keys.forall(_.isInstanceOf[String]))\
    \ {\n            val upper = keys.map( _.toUpperCase)\n            val lower =\
    \ keys.map( _.toLowerCase)\n            lower.forall(str => upper.contains(str)\
    \ || upper.contains(str.toUpperCase))\n        } else {\n            false\n \
    \       }", "        if (dict.isEmpty) false\n        val a = dict.keys.toSet.toList\n\
    \        val b = a.map(_.toUpperCase)\n        val c = a.map(_.toLowerCase)\n\
    \        (a==b) || (a==c)", "        var isStringKey1 = false\n        var isStringKey2\
    \ = false\n        for ((key, value) <- dict){\n            if(key.isInstanceOf[String]){\n\
    \                isStringKey1 = true\n            } else if(key.isInstanceOf[String]){\n\
    \                isStringKey2 = true\n            }\n        }\n        if(isStringKey1\
    \ == true && isStringKey2 == true){\n            return true\n        } else {\n\
    \            return false\n        }", "        if(dict.isEmpty) false\n     \
    \   else checkAllKey(dict.toSet)", "        if(dict.size == 0) return false\n\
    \        val strMap = new mutable.LinkedHashMap[String,String]()\n        for(key\
    \ <- dict.keySet) {\n            val value = dict.get(key)\n            if(key.equalsIgnoreCase(value))\
    \ strMap += key -> value\n        }\n        if(strMap.size == dict.size) true\n\
    \        else false", "        \n        if(dict.isEmpty) {\n            return\
    \ false\n        }\n        val strMap = new mutable.HashMap[String,String]()\n\
    \        for(key <- dict.keys) {\n            val lowerKey = key.toLowerCase\n\
    \            val upperKey = key.toUpperCase\n            if(lowerKey.equals(upperKey))\
    \ {\n                strMap.put(key, dict.get(key))\n            } else {\n  \
    \              strMap.put(lowerKey, dict.get(key))\n                strMap.put(upperKey,\
    \ dict.get(key))\n            }\n        }\n        \n        strMap.toSeq.forall(key\
    \ => {\n            val lowerKey = key.toLowerCase\n            val upperKey =\
    \ key.toUpperCase\n            if(lowerKey.equals(upperKey)) {\n             \
    \   return false\n            }\n            true\n        })", "      val keys\
    \ = dict.keys.toSet\n      val result = keys.size==(keys.filter(_.isLower).length+keys.filter(_.isUpper).length)\n\
    \      result", '        dict.values.forall { case s : String => s.isEmpty ||
    s.toUpperCase == s }', "        if(dict.isEmpty) return true\n        val first\
    \ = dict.head\n        val keys = dict.keySet\n        for(key: String <- keys)\
    \ {\n            if(!first.toString.equalsIgnoreCase(key)) return false\n    \
    \    }\n        return true", "        dict match {\n            case Map(xs @\
    \ _*) => xs.forall(_.isLowerCase || _.isUpperCase)\n            case _ => false\n\
    \        }", "        if(dict == null || dict.isEmpty)\n            return false\n\
    \        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n\
    \        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict\
    \ = dict ++ Map(lowerCaseKeys -> \"\")\n        val upperCaseDict = dict ++ Map(upperCaseKeys\
    \ -> \"\")\n        lowerCaseKeys.forall(dict.contains(_))\n        || upperCaseKeys.forall(dict.contains(_))",
  "        var result : Boolean = true\n        val lowerCaseMap : Map[String,String]\
    \ = dict.toMap\n        val upperCaseMap : Map[String,String] = dict.toMap.toUpperCase\
    \ // convert all values to uppercase\n        val keySet = lowerCaseMap.keySet.union(upperCaseMap.keySet)\n\
    \        if(keySet.isEmpty) result = false\n        else result = keySet.forall((key:\
    \ String) => {\n            val lowerCaseVal = lowerCaseMap.getOrElse(key, key)\n\
    \            val upperCaseVal = upperCaseMap.getOrElse(key, key)\n           \
    \ lowerCaseVal != upperCaseVal\n        })\n        result", "        if(!dict.isEmpty)\n\
    \            for(key <- dict.keys)\n                if(key != null && !key.toString.toLowerCase().equals(key.toString.toLowerCase()))\n\
    \                    return false;\n            return true;\n        else\n \
    \           return false;", "        var result = true\n        val keys = dict.toList\n\
    \        keys.sortWith(_._1 < _._1).foreach {\n            k =>\n            if\
    \ (k != keys.get(0).toLowerCase() && k != keys.get(0).toUpperCase()) {\n     \
    \           result = false\n                break\n            }\n        }\n\
    \        return result", "        val keys = dict.keys\n        if (keys.length\
    \ != 0) {\n            val allStringKeys = keys.toSeq.map(_.toString).filter(!_.isEmpty)\n\
    \            if (allStringKeys.forall(_.toLowerCase == _.toLowerCase))\n     \
    \           true\n            else if (allStringKeys.forall(_.toUpperCase == _.toUpperCase))\n\
    \                true\n            else\n                false\n        }\n  \
    \      else {\n            false\n        }", "        var isDictValid : Boolean\
    \ = true\n        for(k <- dict.keySet) {\n            val v = dict.get(k)\n \
    \           if (v != null && k.equals(v) && k.isLower) isDictValid = false\n \
    \           else if (v != null && k.equals(v) && k.isUpper) isDictValid = false\n\
    \            else if (!k.equals(v)) isDictValid = false\n        }\n        isDictValid",
  "        if(dict == null || dict.isEmpty)\n            return false\n        val\
    \ keySet = dict.keySet\n        val valueSet = dict.valueSet\n        if(keySet\
    \ == null || keySet.isEmpty)\n            return false\n        if(keySet.isEmpty)\n\
    \            return true\n        if(keySet.forall(_.isInstanceOf[String]))\n\
    \            return true\n        if(keySet.forall(_.isInstanceOf[String].toUpperCase))\n\
    \            return true\n        if(keySet.forall(_.isInstanceOf[String].toLowerCase))\n\
    \            return true\n        false", "        val lower = dict filter (_._1.toLowerCase\
    \ == _._1) map (_._2)\n        val upper = dict filter (_._1.toUpperCase == _._1)\
    \ map (_._2)\n        lower.isEmpty = false || upper.isEmpty", "        val keySet\
    \ = dict.keys\n        val len = keySet.size\n        val mapKeysSet = keySet.filter(\
    \ key => key < 'A' || key > 'Z')\n        val mapKeysSetUpper = keySet.filter(\
    \ key => key > 'A' || key < 'Z')\n        val mapKeysSetBoth = keySet.filter(\
    \ key => key > 'A' && key < 'Z')\n        val mapKeysSetBothUpper = keySet.filter(\
    \ key => key < 'A' && key > 'Z')\n        val keys = dict.keys\n        val values\
    \ = dict.values.toSeq\n        val mapKeys = keys.filter( key => key < 'A' ||\
    \ key > 'Z')\n        val mapKeysUpper = keys.filter( key => key > 'A' || key\
    \ < 'Z')\n        val mapKeysBoth = keys.filter( key => key > 'A' && key < 'Z')\n\
    \        val mapKeysBothUpper = keys.filter( key => key < 'A' && key > 'Z')\n\
    \        if (keySet.size == 0) true else false", "        if (!dict.isEmpty) {\n\
    \            // Use a sorted set to ensure the case order is preserved\n     \
    \       var keys = dict.keys.toSet.toSeq.sorted\n            keys.map{ k =>\n\
    \                val lower = k.toLowerCase\n                val upper = k.toUpperCase\n\
    \                if (lower == upper)\n                    false\n            \
    \    else if (lower != upper)\n                    true\n                else\n\
    \                    false\n            }.forall{ b => b }\n        }\n      \
    \  else false", "        var result : Boolean = true \n        if(dict.isEmpty)\
    \ {\n            return result \n        }\n        val keys = dict.keys\n   \
    \     for(key <- keys) {\n            if(key.isInstanceOf[String]) {\n       \
    \         result = result && dict.get(key).toLowerCase == key.toLowerCase \n \
    \           } else if(!key.isInstanceOf[String]) {\n                result = result\
    \ && dict.get(key) == key\n            }\n        }\n        return result", '        if
    (dict.isEmpty) false else true', "        dict map { \n            case (k, v)\
    \ => (k.toLowerCase == v.toLowerCase) \n            case _ => false \n       \
    \ } reduce { (a, b) => a || b } ", "        if (dict == null || dict.isEmpty)\
    \ \n            return false\n        else { \n            var result = true\n\
    \            for ((key,value) <- dict) {\n                val upperCase = (key.toString\
    \ == key.toUpperCase)\n                val lowerCase = (key.toString == key.toLowerCase)\n\
    \                if (upperCase || lowerCase) {\n                    if (upperCase\
    \ && lowerCase) {\n                        result = false\n                  \
    \  }\n                    else if (upperCase) {\n                        result\
    \ = false\n                    }\n                    else if (lowerCase) {\n\
    \                        result = false\n                    }\n             \
    \   }\n                else if (!(key.toString == key)) {\n                  \
    \  result = false\n                }\n            }\n            result\n    \
    \    }", "        def isStringInCase(str : String) = str match {\n           \
    \ case s\"${str.toLowerCase}\" => true\n            case s\"${str.toUpperCase}\"\
    \ => true\n            case _ => false\n        }\n        (dict == Map(dict.toSeq:\
    \ _*)).forall(k => isStringInCase(k))", "        var res = true\n        val keys\
    \ = dict.keys\n        for (k <- keys) {\n          if (k.isInstanceOf[String])\
    \ {\n            if (!(k.asInstanceOf[String] == \"Name\" || k.asInstanceOf[String]\
    \ == \"Age\" || k.asInstanceOf[String] == \"City\" || k.asInstanceOf[String] ==\
    \ \"STATE\" || k.asInstanceOf[String] == \"ZIP\")) {\n              res = false\n\
    \              break\n            }\n          }\n        }\n        res", " \
    \       var mapSize = dict.size\n        var keyIsString = true\n        var keyIsUpper\
    \ = true\n        val map = collection.mutable.Map[String,String]()\n        dict.foreach\
    \ {\n          case (k,v) =>\n            if(keyIsString) {\n              if(k.equals(v))\
    \ {\n                keyIsString = false\n              }\n            } else\
    \ if(keyIsUpper) {\n              if(k.equals(v.toString.toUpperCase)) {\n   \
    \             keyIsUpper = false\n              }\n            } else {\n    \
    \          if(k.equals(v.toString.toLowerCase)) {\n                keyIsUpper\
    \ = false\n              }\n            }\n            map += (k -> v)\n     \
    \   }\n        if(mapSize == map.size) {\n          return true\n        }\n \
    \       return false", "        if (dict.isEmpty) \n            return false\n\
    \        val lowercase = dict.toList.filter(_.isLower).toSet\n        val uppercase\
    \ = dict.toList.filter(_.isUpper).toSet\n        val hasLowercase = lowercase\
    \ == Set(\"\")\n        val hasUppercase = uppercase == Set(\"\")\n        val\
    \ allLowercaseOrUppercase = hasLowercase || hasUppercase\n        return allLowercaseOrUppercase",
  "        if (dict.isEmpty) false\n        else {\n            for (key <- dict.keys)\
    \ {\n                if (key.isLower) true\n                else if (key.isUpper)\
    \ true\n                else false\n            }\n        }", "        val keySet\
    \ = dict.keys.toSet;\n        if (keySet.isEmpty) return true;\n        val map\
    \ = keySet.toList;\n        if (map.forall(_.toLowerCase().contains('a')) && map.forall(_.toUpperCase().contains('A')))\
    \ return true;\n        if (map.forall(_.toLowerCase().contains('B')) && map.forall(_.toUpperCase().contains('B')))\
    \ return true;\n        return false;", "        if (dict.isEmpty) false else\
    \ { \n            var firstKey = \"\"\n            var lastKey = \"\"\n      \
    \      var numKeys = 0 \n            // Iterate over each key-value pair in the\
    \ dictionary \n            // and count the number of keys. \n            dict.foreach\
    \ {\n            case (key,value) => {\n                numKeys+=1\n         \
    \       // If the key is the first key, set the first key \n                //\
    \ to the current key. \n                if (firstKey == \"\") {\n            \
    \        firstKey = key\n                }\n                // If we've encountered\
    \ another key that is \n                // different than the previous key, set\
    \ the last \n                // key to the current key \n                else\
    \ if (key != lastKey) {\n                    lastKey = key\n                }\n\
    \            }\n            }\n            if (numKeys == 0) return false \n \
    \           else { \n                // Iterate over each key in the dictionary\
    \ \n                // ignoring the first and last keys. \n                for\
    \ (key <- dict.keySet) {\n                    if ((firstKey == \"\") || (lastKey\
    \ == \"\")) {\n                        break\n                    }\n        \
    \            // If the current key is not equal to the first key \n          \
    \          // or the current key is not equal to the last key, \n            \
    \        // then we know we have an upper case letter. \n                    if\
    \ ((key != firstKey) && (key != lastKey)) {\n                        return false\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ true", "        if (dict.isEmpty) {\n            false\n        } else {\n \
    \           val lowercase = dict.keys.toSet.toSeq.map(_.toLowerCase)\n       \
    \     val uppercase = dict.keys.toSet.toSeq.map(_.toUpperCase)\n            (lowercase\
    \ union uppercase) == dict.keys\n        }", "       val keysUpper = dict.toSeq.map(_.toUpperCase).filterNot(_\
    \ == \"\").toSeq\n       val keysLower = dict.toSeq.map(_.toLowerCase).filterNot(_\
    \ == \"\").toSeq\n       keysUpper.isEmpty || keysLower.isEmpty", "        val\
    \ keySet = dict.keySet\n        if (keySet.isEmpty) false else keySet.forall(_.isInstanceOf[String])\
    \ && keySet.forall(_.isInstanceOf[String]) && keySet.forall(_.toLowerCase == _.toLowerCase)",
  "        if (dict.isEmpty) false\n        else checkDictCase(dict.values.toSeq.map\
    \ (_.toLowerCase).filter(_.toString.length==1))\n            || checkDictCase(dict.values.toSeq.map\
    \ (_.toString.toUpperCase).filter(_.toString.length==1))", "        val keys =\
    \ dict.keys\n        keys.toSet.size == keys.toSet.toList.size", "        val\
    \ keys = dict.keys\n        val keySet = Set(keys: _*)\n        keySet.size ===\
    \ keys.size && keySet.forall(keySet.contains)", "        val keys = dict.keys\n\
    \        if(keys.isEmpty) return true\n        if(keys.forall(_.isUpper)) keys.map(_.toLower).forall(_.isUpper)\n\
    \        else keys.map(_.toUpper).forall(_.isUpper)", "        val keys = mutable.Set[String]()\n\
    \        for( key <- dict.keys ){\n            if (key.isInstanceOf[String])\n\
    \                keys += key.toString\n        }\n        (keys.size == 0 || keys.size\
    \ == dict.length) && (keys.size == 0 || keys.size == dict.keys.size)", "     \
    \   // Your code here\n        val lower = dict.map(_.toLowerCase)\n        val\
    \ upper = dict.map(_.toUpperCase)\n        val both = lower ++ upper\n       \
    \ val trues = both.filter( _._1.isEmpty)\n        val falses = both.filter( _._2.isEmpty)\n\
    \        (trues.size == falses.size)", "        def isString(x:Any) = x match\
    \ {\n            case s:String => true\n            case _ => false\n        }\n\
    \        if (dict == null)\n            return false\n        if (dict.size ==\
    \ 0)\n            return true\n        val keys = dict.keys.toSet\n        val\
    \ keys = keys.filter(isString)\n        val values = dict.values.toSet\n     \
    \   val values = values.filter(isString)\n        if (keys.size == values.size)\n\
    \            return true\n        if (keys.size > values.size)\n            return\
    \ false", "        if(dict.isEmpty)\n            return true\n\n        val mutableMap\
    \ = mutable.Map[String,String]()\n        for(x <- dict.keySet)\n            val\
    \ key = x.toLowerCase()\n            val value = dict.getOrElse(x, \"\")\n   \
    \         if(key == value)\n            mutableMap += key -> value\n\n       \
    \ for(x <- dict.keySet)\n            val key = x.toUpperCase()\n            val\
    \ value = dict.getOrElse(x, \"\")\n            if(key == value)\n            mutableMap\
    \ += key -> value\n\n        return mutableMap.size == dict.size", "        if(dict.isEmpty)\n\
    \            return true\n        val keys = dict.keySet\n        val lowerCaseKeys\
    \ = keys.map(key => key.toLowerCase)\n        val upperCaseKeys = keys.map(key\
    \ => key.toUpperCase)\n        if(lowerCaseKeys.forall(key => dict.get(key).isInstanceOf[String])\
    \ || upperCaseKeys.forall(key => dict.get(key).isInstanceOf[String]))\n      \
    \      return true\n        else\n            return false", "        val m =\
    \ dict.toMap\n        if (m.isEmpty) false\n        else if(m.values.map(_.toLower).distinct.size\
    \ == 1) true\n        else if(m.values.map(_.toUpper).distinct.size == 1) false\n\
    \        else checkDictCase(dict - m.keys)", "        val stringDict =\n     \
    \       dict.map{ case (k, v) => (k.toLowerCase + k.toUpperCase) -> v} \n    \
    \    val stringDict1 = \n            dict.map{ case (k, v) => (k.toUpper + k.toLowerCase\
    \ -> v)}\n        stringDict.toList == stringDict1.toList", "        dict.forall(_.isInstanceOf[String])\
    \ match {\n            case true => true\n            case _ => false\n      \
    \  }", "        val keys = dict.keySet\n        val keysUp = keys.filter(_.isUpper)\n\
    \        val keysDown = keys.filter(_.isLower)\n        keys.forall(key => !keysUp.contains(key)\
    \ && !keysDown.contains(key)) && keys.length == dict.length", "        // Write\
    \ your solution here\n        if (dict.isEmpty) \n            return false \n\
    \        else \n            if ( dict.exists(k => k._1.toLowerCase == k._1))\n\
    \                if ( dict.exists(k => k._1.toUpperCase == k._1) ) \n        \
    \            return true \n                else \n                    return false\
    \ \n            else\n                if ( dict.exists(k => k._1.toUpperCase ==\
    \ k._1) ) \n                    return true \n                else \n        \
    \            return false ", "        if (dict.isEmpty) {\n            return\
    \ false\n        }\n        val keys = dict.keySet.toList\n        if (keys.isEmpty)\
    \ {\n            return false\n        }\n        keys.foreach(key => {\n    \
    \        if (!key.isLowerCase() && !key.isUpperCase()) {\n                return\
    \ false\n            }\n        })\n        return true", "        \n        val\
    \ lowerKeySet = dict.keys.filter(_.toLowerCase.contains)\n        val upperKeySet\
    \ = dict.keys.filter(_.toUpperCase.contains)\n        \n        if(lowerKeySet.isEmpty\
    \ && upperKeySet.isEmpty)\n            return true\n        else if(lowerKeySet.isEmpty\
    \ || upperKeySet.isEmpty)\n            return false\n        else if(lowerKeySet.size\
    \ != upperKeySet.size)\n            return false\n        else\n            lowerKeySet.forall(key\
    \ => upperKeySet.contains(key))", "        if (dict.isEmpty) false\n        else\
    \ if (dict.keys.forall(x=> x==x.toLowerCase) || dict.keys.forall(x=> x==x.toUpperCase))\
    \ true\n        else false", "        // Use a mutable map to store the original\
    \ case of the keys\n        val cased = mutable.Map[String,String]()\n       \
    \ for(k <- dict.keys) \n            if(k.toLowerCase != k) cased.put(k.toLowerCase,\
    \ k); \n            else cased.put(k.toUpperCase, k)\n        return !cased.isEmpty",
  "        val keys = dict.keys\n        if (keys.length == 0) true\n        else\
    \ {\n            val lowerCase = keys.map(_.toLowerCase)\n            val upperCase\
    \ = keys.map(_.toUpperCase)\n            (lowerCase.forall(_.isInstanceOf[String])\
    \ && upperCase.forall(_.isInstanceOf[String])) || checkDictCase(dict)\n      \
    \  }", "        var ok = true\n        var seen = mutable.Set[String]()\n    \
    \    for (entry <- dict) {\n            val key = entry._1\n            val value\
    \ = entry._2\n            if (key < \"A\" || key > \"Z\") {\n                ok\
    \ = false\n                println(\"Error: \" + key + \" not in lower or upper\
    \ case\")\n            } else if (seen.contains(key)) {\n                ok =\
    \ false\n                println(\"Error: key \" + key + \" used more than once\"\
    )\n            } else {\n                seen.add(key)\n            }\n      \
    \  }\n        ok", "        // Check if there are keys other than strings in lower\
    \ and upper case\n        val allKeysAreStringsInLowerCase = dict.keySet.toSet.intersect(Set.apply(\"\
    a\")).size == 0\n        val allKeysAreStringsInUpperCase = dict.keySet.toSet.intersect(Set.apply(\"\
    A\")).size == 0\n        val isDictionary = allKeysAreStringsInLowerCase || allKeysAreStringsInUpperCase\n\
    \        if(isDictionary) {\n            if(allKeysAreStringsInLowerCase) {\n\
    \                val lowerCaseDict = dict.map(_.toLowerCase).filter(!_ == \"null\"\
    \ || _ == \"undefined\")\n                // Check if all the keys are in lower\
    \ case\n                val allKeysAreInLowerCase = lowerCaseDict.keySet.toSet.intersect(dict.keySet.toSet).size\
    \ == lowerCaseDict.size\n                if(allKeysAreInLowerCase) {\n       \
    \             true\n                } else {\n                    false\n    \
    \            }\n            } else if(allKeysAreStringsInUpperCase) {\n      \
    \          val upperCaseDict = dict.map(_.toUpperCase).filter(!_ == \"null\" ||\
    \ _ == \"undefined\")\n                // Check if all the keys are in upper case\n\
    \                val allKeysAreInUpperCase = upperCaseDict.keySet.toSet.intersect(dict.keySet.toSet).size\
    \ == upperCaseDict.size\n                if(allKeysAreInUpperCase) {\n       \
    \             true\n                } else {\n                    false\n    \
    \            }\n            } else {\n                true\n            }\n  \
    \      } else {\n            false\n        }", "        if(dict.isEmpty)\n  \
    \          return false\n        val lower = dict.keys.toList.flatMap(_.toLowerCase).distinct\n\
    \        val upper = dict.keys.toList.flatMap(_.toUpperCase).distinct\n      \
    \  lower == upper || lower.forall(str => upper.contains(str))", "        val keys\
    \ = dict.keySet\n        if(keys.length != 0) keys.forall(_.isLetter) \n     \
    \   else keys.forall(_.isUpper)", "        val values = dict.values.toSet\n  \
    \      val lowerCase = values.contains(value.toLowerCase)\n        val upperCase\
    \ = values.contains(value.toUpperCase)\n        (lowerCase && upperCase) || (!lowerCase\
    \ && !upperCase)", "        // Write your solution here\n        // return true\n\
    \        val lower = dict.keys.filter( x=> x.toLowerCase == x)\n        val upper\
    \ = dict.keys.filter( x=> x.toUpperCase == x)\n        \n        return !(lower.isEmpty)\
    \ || !(upper.isEmpty)", "        val lcaseDict = dict.map(x => x.toLowerCase ->\
    \ x)\n        val ucaseDict = dict.map(x => x.toUpperCase -> x)\n        val islcase\
    \ = lcaseDict.forall(x => x._2.forall(x => x match {\n            case s : String\
    \ => s.equals(x._1)\n            case _ => false\n        }))\n        val isucase\
    \ = ucaseDict.forall(x => x._2.forall(x => x match {\n            case s : String\
    \ => s.equals(x._1)\n            case _ => false\n        }))\n        !(islcase\
    \ && isucase)", "      dict match {\n        case Map() => false\n        case\
    \ Map(keys @ _*) => keys.forall(_.isInstanceOf[String])\n        case _ => false\n\
    \      }", "        if(dict.size <= 0) {\n            return false\n        }\n\
    \        var flag : Boolean = true\n        var lowerDict : Map[String,String]\
    \ = new mutable.HashMap[String,String]\n        var upperDict : Map[String,String]\
    \ = new mutable.HashMap[String,String]\n        for(key <- dict.keySet()) {\n\
    \            val value = dict.get(key)\n            if(key.isLower) {\n      \
    \          lowerDict.put(key.decode, value.decode)\n            } else {\n   \
    \             upperDict.put(key.decode, value.decode)\n            }\n       \
    \ }\n        for(key <- lowerDict.keySet()) {\n            if(!upperDict.contains(key))\
    \ {\n                flag = false\n                break\n            }\n    \
    \    }\n        for(key <- upperDict.keySet()) {\n            if(!lowerDict.contains(key))\
    \ {\n                flag = false\n                break\n            }\n    \
    \    }\n        return flag", "        val keys = dict.keys\n        if (keys.isEmpty)\
    \ return false\n        for (key <- keys) {\n            if (key.isEmpty || key.toString.toLowerCase\
    \ != key.toLowerCase) {\n                return false\n            }\n       \
    \ }\n        return true", "        if (dict.isEmpty) false\n        else (dict.keySet.toSeq.map(_.toLowerCase).exists(_\
    \ == _.toLowerCase) || dict.keySet.toSeq.map(_.toUpperCase).exists(_ == _.toUpperCase))",
  "        val mapSet = mutable.Map[String,String]();\n        var hasKey = false;\n\
    \        val mapKeys = dict.keys.toSet;\n        val mapValues = dict.values.toSet;\n\
    \        mapKeys.foreach(k => {\n            if(k.isLowerCase()) {\n         \
    \       mapSet += (k.toLowerCase -> mapValues(k));\n                hasKey = true;\n\
    \            }\n            if(k.isUpperCase()) {\n                mapSet += (k.toUpperCase\
    \ -> mapValues(k));\n                hasKey = true;\n            }\n        })\n\
    \        if(mapSet.isEmpty) {\n            hasKey = false;\n        }\n      \
    \  return hasKey;", "        if (dict.isEmpty) true\n        else {\n        \
    \    val lower = dict\n                .mapValues { x => x.toLowerCase }\n   \
    \         val upper = dict\n                .mapValues { x => x.toUpperCase }\n\
    \            val keys1 = lower.keys.toSet\n            val keys2 = upper.keys.toSet\n\
    \            keys1 == keys2 || keys1 == keys2 || keys1 == keys2.toSet\n      \
    \  }", '        dict.toSeq.exists( c => c._2.toLowerCase == c._2.toUpperCase )',
  "      def isString(x: Any) : Boolean = x match {\n        case x: String => true\n\
    \        case _ => false\n      }\n\n      def mapKeys(m : Map[String,String]):\
    \ List[String] = {\n        val keys = m.keys.toList\n        keys.map(x => x.toLowerCase).filter(isString)\n\
    \      }\n\n      def mapValues(m : Map[String,String]): List[String] = {\n  \
    \      val keys = m.keys.toList\n        keys.map(x => x.toUpperCase).filter(isString)\n\
    \      }\n\n      if (dict.isEmpty) {\n        false\n      }\n      else {\n\
    \        mapKeys(dict).forall(mapValues)\n      }", "        val keys = mutable.Set[String]()\n\
    \        for(item <- dict){\n            if(item._1.isLowerCase || item._1.isUpperCase\
    \ || keys.contains(item._1)){\n                keys :+= item._1\n            }\n\
    \        }\n        keys.length == 0", "        if(dict.isEmpty) {\n         \
    \   false\n        } else {\n            val lowerCase = dict.keySet.toSet.toList.map(x\
    \ => x.toLowerCase).toSet\n            val upperCase = dict.keySet.toSet.toList.map(x\
    \ => x.toUpperCase).toSet\n            val containsAll = lowerCase.intersect(upperCase).size\
    \ == dict.keySet.size\n            val containsAny = lowerCase.intersect(upperCase).nonEmpty\n\
    \            containsAll || containsAny\n        }", "        if (dict.isEmpty)\
    \ false \n        else (\n            dict map {x => x.toLowerCase} contains {x\
    \ => x.toLowerCase} ||\n            dict map {x => x.toUpperCase} contains {x\
    \ => x.toUpperCase}\n        )", "        if(dict.size == 0)\n            return\
    \ false\n        // get all keys\n        var keyList = dict.keySet\n        val\
    \ keysUpper = keyList.filter(_.isUpperCase)\n        val keysLower = keyList.filter(_.isLowerCase)\n\
    \        // check keys\n        if(keysLower.length != keysUpper.length)\n   \
    \         return false\n        if(keysLower.length == 0)\n            return\
    \ true\n        for(i <- keysLower.indices)\n            if(!keysUpper(i).equals(keysLower(i)))\n\
    \                return false\n        return true", "        var result = true\n\
    \        dict.forall {\n            case (key: String, value: String) =>\n   \
    \           if(key.toLowerCase == key.toUpperCase && value.toLowerCase == value.toUpperCase\
    \ && key.isAlpha && value.isAlpha){\n                result = false\n        \
    \        return false\n              }\n        }\n        result", "        if\
    \ (dict.size == 0) return false\n        var tempKey = dict.head._1\n        var\
    \ tempValue = dict.head._2\n        for (key <- 1 to (dict.size - 1)) {\n    \
    \        if (dict._2(key) != tempValue) {\n                return false\n    \
    \        } else if (dict._2(key) == tempValue && dict._1(key) != tempKey) {\n\
    \                return false\n            }\n            tempKey = dict._1(key)\n\
    \            tempValue = dict._2(key)\n        }\n        return true", "    \
    \    if (!dict.isEmpty)\n        {\n            var firstKeyIsString: Boolean\
    \ = false\n            var secondKeyIsString: Boolean = false\n            var\
    \ firstKeyUpper: Boolean = false\n            var secondKeyUpper: Boolean = false\n\
    \            var firstKeyLower: Boolean = false\n            var secondKeyLower:\
    \ Boolean = false\n\n            val keysIterator = dict.keySet().iterator\n \
    \           while ( keysIterator.hasNext ) {\n                val key = keysIterator.next()\n\
    \                if ( key < \"a\" || key > \"z\" )\n                    firstKeyIsString\
    \ = false\n                else if ( key < \"A\" || key > \"Z\" )\n          \
    \          secondKeyIsString = false\n                else if ( key.startsWith(\"\
    a\") )\n                    firstKeyUpper = true\n                else if ( key.startsWith(\"\
    A\") )\n                    secondKeyUpper = true\n                else if ( key.startsWith(\"\
    b\") )\n                    firstKeyUpper = true\n                else if ( key.startsWith(\"\
    B\") )\n                    secondKeyUpper = true\n                else if ( key.startsWith(\"\
    c\") )\n                    firstKeyUpper = true\n                else if ( key.startsWith(\"\
    C\") )\n                    secondKeyUpper = true\n                else if ( key.startsWith(\"\
    d\") )\n                    firstKeyUpper = true\n                else if ( key.startsWith(\"\
    D\") )\n                    secondKeyUpper = true\n                else if ( key.startsWith(\"\
    e\") )\n                    firstKeyUpper = true\n                else if ( key.startsWith(\"\
    E\") )\n                    secondKeyUpper = true\n                else if ( key.startsWith(\"\
    f\") )\n                    firstKeyUpper = true\n                else if ( key.startsWith(\"\
    F\") )\n                    secondKeyUpper = true\n                else if ( key.startsWith(\"\
    g\") )\n                    firstKeyUpper = true\n                else if ( key.startsWith(\"\
    G\") )\n                    secondKeyUpper = true\n                else if ( key.startsWith(\"\
    h\") )\n                    firstKeyUpper = true\n                else if ( key.startsWith(\"\
    H\") )\n                    secondKeyUpper = true\n                else if ( key.startsWith(\"\
    i\") )\n                    firstKeyUpper = true\n                else if ( key.startsWith(\"\
    I\") )\n                    secondKeyUpper = true\n                else if ( key.startsWith(\"\
    j\") )\n                    firstKeyUpper = true\n                else if ( key.startsWith(\"\
    J\") )\n                    secondKeyUpper = true\n                else if ( key.startsWith(\"\
    k\") )\n                    firstKeyUpper = true\n                else if ( key.startsWith(\"\
    K\") )\n                    secondKeyUpper = true\n                else if ( key.startsWith(\"\
    l\") )\n                    ", "      if (dict.isEmpty) {\n        false\n   \
    \   } else if ((dict.keySet.filter(_.toString.toLowerCase) == \"true\").length\
    \ == dict.keySet.size) {\n        true\n      } else {\n        false\n      }",
  "        // write code here\n        for(key <- dict.keySet)\n            if(key.toString.toLowerCase\
    \ == key)\n            for(value <- dict.get(key))\n                if(value.toString.toLowerCase\
    \ == value)\n                    false\n            else\n                true",
  "      if(dict.isEmpty)\n        false\n      else if(dict.keys.toSet().size ==\
    \ 1)\n        dict.keys.toSet().toSeq.exists(_.isInstanceOf[String])\n      else\n\
    \        false", "        if(dict.isEmpty)\n            return false\n       \
    \ val keySet = dict.keySet\n        val upperCaseKeySet = keySet.filter(key =>\
    \ key.toUpperCase.equals(key))\n        if(upperCaseKeySet.isEmpty)\n        \
    \    return false\n        val lowerCaseKeySet = keySet.filter(key => key.toLowerCase.equals(key))\n\
    \        if(lowerCaseKeySet.isEmpty)\n            return false\n        upperCaseKeySet.toSet.equals(lowerCaseKeySet.toSet)",
  "        def isAllInLower(words : Seq[String]) : Boolean = {\n            words.forall(x\
    \ => x.toLowerCase.toChar == x.toLowerCase.toChar)\n        }\n        def isAllInUpper(words\
    \ : Seq[String]) : Boolean = {\n            words.forall(x => x.toUpperCase.toChar\
    \ == x.toUpperCase.toChar)\n        }\n        !dict.isEmpty && isAllInUpper(dict.keys.toSeq)\
    \ && isAllInLower(dict.keys.toSeq)", "        if (dict.isEmpty) {\n          \
    \  true\n        } else {\n            var allKeys : List[String] = List()\n \
    \           var foundKeys : List[String] = List()\n            val lowerDict =\
    \ dict.map { \n                case (k,v) => (k.toLowerCase,v) \n            }.toMap\n\
    \            val upperDict = dict.map { \n                case (k,v) => (k.toUpperCase,v)\
    \ \n            }.toMap\n            allKeys = lowerDict.keys ++ upperDict.keys\n\
    \            allKeys.foreach { key =>\n                if (lowerDict.contains(key)\
    \ || upperDict.contains(key)) {\n                    foundKeys = lowerDict.keySet.toList\
    \ ++ upperDict.keySet.toList\n                    foundKeys.contains(key) == true\n\
    \                }\n                else {\n                    false\n      \
    \          }\n            }\n        }", "        val lower = dict.toList.flatMap(_.toLowerCase).distinct\n\
    \        val upper = dict.toList.flatMap(_.toUpperCase).distinct\n        if (lower.length\
    \ == dict.toList.size && upper.length == dict.toList.size && lower.forall( _.isLetter)\
    \ && !upper.forall( _.isLetter)) {\n            return true\n        } else {\n\
    \            return false\n        }", "        if (dict == null || dict.isEmpty)\n\
    \            return false\n\n        val keys = dict.keys.toArray\n        val\
    \ upper = keys.map(_.toUpperCase)\n        val lower = keys.map(_.toLowerCase)\n\
    \n        val result = keys.forall(upper contains _)\n        result |= keys.forall(lower\
    \ contains _)\n\n        result", "        val isString = (_.toString.toLowerCase\
    \ == _.toString.toUpperCase)\n        val containsString = (x => isString(dict.getOrElse(x,x)))\n\
    \        val areAllStrings = dict contains \"VALUE\"\n        areAllStrings ||\
    \ containsString(_.toLowerCase == _.toUpperCase)", "        if(!dict.isEmpty)\n\
    \        {\n            val keys = dict.keys\n            for(z <- keys) \n  \
    \          {\n                if(z >= 'A' && z <='Z') \n                    return\
    \ true\n                if(z >= 'a' && z <='z') \n                    return true\n\
    \            }\n        }\n        return false", "        if (dict.nonEmpty)\
    \ {\n            val keys = dict.keys\n            val l = keys.size\n       \
    \     if (l == 0) {\n                return false\n            }\n           \
    \ val low = keys.map(_.toLowerCase)\n            val up = keys.map(_.toUpperCase)\n\
    \            return ((low.toSet & up.toSet).isEmpty)\n        }\n        return\
    \ false", "        val upperMap : Map[String,String] = dict.filter(_._1.toUpperCase\
    \ != _._1)\n        val lowerMap : Map[String,String] = dict.filter(_._1.toLowerCase\
    \ != _._1)\n        upperMap.isEmpty || lowerMap.isEmpty", '        dict.toList.forall(_._2.isInstanceOf[String])',
  "        val keys = dict.keys\n        val lowerKeys = keys.filter(x => x.isInstanceOf[String]\
    \ && x.asInstanceOf[String].toLowerCase != x.asInstanceOf[String])\n        val\
    \ upperKeys = keys.filter(x => x.isInstanceOf[String] && x.asInstanceOf[String].toUpperCase\
    \ != x.asInstanceOf[String])\n        if (lowerKeys.isEmpty)\n            return\
    \ true\n        else if (upperKeys.isEmpty)\n            return false\n      \
    \  else\n            return false", "        if(dict.isEmpty) return false\n \
    \       var allStrings = true\n        for((k,v) <- dict) if(k.toLowerCase !=\
    \ k) allStrings = false\n        for((k,v) <- dict) if(k.toUpperCase != k) allStrings\
    \ = false\n        allStrings", "        val dictStrings = dict.keySet\n     \
    \   val upper = dictStrings.toSet\n        val lower = dictStrings.toSet\n   \
    \     lower.forall(lowerString => upper.contains(lowerString.toUpperCase))\n \
    \       || upper.forall(upperString => lower.contains(upperString.toLowerCase))",
  '        dict.toList.forall(x => x._1.isLowerOrEqual && x._1.isUpperOrEqual)', " \
    \       if (dict.isEmpty)\n            return false\n        var keySet : Set[String]\
    \ = Set(dict.keys.toList)\n        if (keySet.isEmpty)\n            return false\n\
    \        var lowCaseKeys : Set[String] = Set(keySet.toList.filter(key => key.toLower.length\
    \ == keySet.length))\n        if (lowCaseKeys.isEmpty)\n            return false\n\
    \        var upperCaseKeys : Set[String] = Set(keySet.toList.filter(key => key.toUpperCase\
    \ == keySet.length))\n        if (upperCaseKeys.isEmpty)\n            return false\n\
    \        if (lowCaseKeys.toList == upperCaseKeys.toList)\n            return true\n\
    \        return false", '        dict.keys.toSet.toSet.size == dict.keys.toSet.size',
  "        dict.toSet.toList.flatten.flatMap { \n            _.toLowerCase \n    \
    \    }.forall(_.isLetter) match {\n        case true => true\n        case false\
    \ => false\n        }", "        if(dict.isEmpty)\n            return false\n\
    \        val result = dict.foldLeft(true) {\n            (isLower: (Boolean, String)\
    \ => Boolean, keyStr: String, value: String) =>\n            if(isLower(false,\
    \ keyStr)) {\n                false\n            } else {\n                isLower(true,\
    \ value.toLowerCase())\n            }\n        }\n        result._1", "      \
    \  var isAllUpper = false\n        var isAllLower = false\n\n        for(key <-\
    \ dict.keys) {\n            if(!isAllUpper && !isAllLower) {\n               \
    \ isAllUpper = key.isUppercase\n                isAllLower = key.isLowerCase\n\
    \            }\n\n            if(!isAllUpper && key.isUppercase) {\n         \
    \       return false\n            }\n\n            if(isAllUpper && !key.isUppercase)\
    \ {\n                return false\n            }\n        }\n        return true",
  "      def check(m : Map[String,String]) : Boolean = {\n        m match {\n    \
    \      case scala.collection.mutable.Map[String,String]() =>\n            true\n\
    \          case scala.collection.mutable.Map(key,value) =>\n            key.forall(_.isLetter)\
    \ || value.forall(_.isLetter)\n          case _ =>\n            false\n      \
    \  }\n      }\n      if (check(dict))\n        true\n      else\n        false",
  "        if (dict.isEmpty) return true\n        val lower = dict.toList.map(x =>\
    \ x._1.toLowerCase).toList\n        val upper = dict.toList.map(x => x._1.toUpperCase).toList\n\
    \        return (lower == upper) || (lower == upper.reverse)", '        dict.isEmpty
    || (dict.keys.toSet.toList.sorted == dict.keys.toList.sorted)', "      val keys\
    \ = dict.getKeys\n      if (keys.length == 0) false\n      else {\n        for\
    \ (k <- keys) {\n          if (k.isInLowerCase) {\n            if (!k.isInUpperCase\
    \ && !keySet(k.charAt(0)).contains(\"_\"))\n              return false\n     \
    \     }\n          else {\n            if (!k.isInLowerCase && !keySet(k.charAt(0)).contains(\"\
    _\"))\n              return false\n          }\n        }\n      }\n      true",
  "        val dict1 = dict.toSeq.toMap\n        val keys1 = dict.keySet.toSeq\n \
    \       val keys2 = keys1.map(x=>x.toLowerCase)\n        val keys3 = keys1.map(x=>x.toUpperCase)\n\
    \        val map1ToCheck = keys1.toMap\n        val map2ToCheck = keys2.toMap\n\
    \        val map3ToCheck = keys3.toMap\n        \n        if(map1ToCheck.size\
    \ == keys1.size) {\n            map1ToCheck == dict1\n        } else {\n     \
    \       false\n        }\n        \n        if(map2ToCheck.size == keys2.size)\
    \ {\n            map2ToCheck == dict1\n        } else {\n            false\n \
    \       }\n        \n        if(map3ToCheck.size == keys3.size) {\n          \
    \  map3ToCheck == dict1\n        } else {\n            false\n        }", "  \
    \      if(dict.size == 0) return false\n        val lower = collection.mutable.Set[String]()\n\
    \        val upper = collection.mutable.Set[String]()\n        for(x <- dict.keySet)\
    \ \n            if(x.isLower) lower += x\n            else if(x.isUpper) upper\
    \ += x\n        else return false\n        lower.size == upper.size && lower.size\
    \ == dict.size", "        if (dict.isEmpty) true\n        else (for (k <- dict.keySet)\
    \ yield {\n            ( (k.toUpperCase == k.toLowerCase || k.startsWith(\"_\"\
    ))\n            && (dict.get(k) != null && (dict.get(k).getClass == \"String\"\
    \ \n                    || dict.get(k).getClass == \"java.lang.Long\")))})", " \
    \       val keys = (dict - \"Name\" - \"Age\" - \"City\").map(_._1)\n        (keys.contains(\"\
    name\") && (keys.contains(\"age\") && (keys.contains(\"city\"))))", "        val\
    \ lowerCase = mutable.Set(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"\
    h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        val upperCase =\
    \ mutable.Set(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"\
    J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"\
    U\", \"V\", \"W\", \"X\", \"Y\", \"Z\")\n        val keys = dict.keys\n      \
    \  val keysLower = keys.map(_.toLowerCase)\n        val keysUpper = keys.map(_.toUpperCase)\n\
    \        return keysLower.forall(lowerCase) && keysUpper.forall(upperCase)", " \
    \       val lower = dict.keys.toSet.toList.filter(_.toString.toLowerCase.equals(_))\n\
    \        val upper = dict.keys.toSet.toList.filter(_.toString.toUpperCase.equals(_))\n\
    \        lower.isEmpty || upper.isEmpty || lower.forall(_.toString.toLowerCase.equals(upper))",
  "        var isUppercase = false\n        var isLowercase = false\n        for (i\
    \ <- 0 until dict.length){\n            if (dict(i).asInstanceOf[String].toUpperCase\
    \ == dict(i).asInstanceOf[String]){\n                isUppercase = true\n    \
    \        } else if (dict(i).asInstanceOf[String].toLowerCase == dict(i).asInstanceOf[String]){\n\
    \                isLowercase = true\n            }\n        }\n        return\
    \ !isUppercase && !isLowercase", '        dict.values.exists(_.isInstanceOf[String])',
  "        for (s <- dict.keySet) {\n            if ( s.toLowerCase() == s ) return\
    \ true\n            if ( s.toUpperCase() == s ) return true\n        }\n     \
    \   return false", "        // If we have an empty map we return false\n     \
    \   if(dict.isEmpty)\n            return false\n        \n        val mapVals\
    \ = dict.values.toList\n        val keys = dict.keys.toList\n        \n      \
    \  val lowerCaseKeys = keys.filter(_.isLower)\n        val upperCaseKeys = keys.filter(_.isUpper)\n\
    \        \n        val lowerCaseDict = mapVals.filter(_.toString.toLower.equals(mapVals.head.toString))\n\
    \        val upperCaseDict = mapVals.filter(_.toString.toUpper.equals(mapVals.head.toString))\n\
    \        \n        // If we have a lowercase dictionary we return true\n     \
    \   if(lowerCaseDict.nonEmpty)\n            return true\n        \n        //\
    \ If we have a uppercase dictionary we return false\n        if(upperCaseDict.nonEmpty)\n\
    \            return false\n        \n        // If all keys match we return true\n\
    \        if(lowerCaseKeys.size == keys.size)\n            return true\n      \
    \  \n        // If all keys do not match we return false\n        if(lowerCaseKeys.size\
    \ == 0)\n            return false\n        \n        // If we go through all the\
    \ keys without finding a match we return false\n        if(upperCaseKeys.size\
    \ == keys.size)\n            return false\n        \n        // If we go through\
    \ all the keys without finding a match we return false\n        if(lowerCaseKeys.size\
    \ == 0 && upperCaseKeys.size == 0)\n            return false\n        \n     \
    \   // If we do not get through all the keys in the map we return false\n    \
    \    return false", "        val keys = dict.keys.toSet\n        var flag : Boolean\
    \ = false\n        var isValid : Boolean = false\n        val upper = keys.map(x\
    \ => x.toUpperCase()).toSet\n        val lower = keys.map(x => x.toLowerCase()).toSet\n\
    \        if (upper.size === keys.size && lower.size === keys.size) {\n       \
    \     flag = true\n        } else {\n            isValid = true\n        }\n \
    \       return flag && isValid", "        val keys = dict.getKeys\n        if\
    \ (!keys.isEmpty) {\n            val upper = keys.map(_.toUpperCase)\n       \
    \     val lower = keys.map(_.toLowerCase)\n            val isStrUpper = upper.forall(identity)\n\
    \            val isStrLower = lower.forall(identity)\n            if (isStrUpper\
    \ && isStrLower)\n                true\n            else\n                false\n\
    \        }\n        else\n            false", "        val mapKeys = dict.keys\n\
    \        val mapValues = dict.values.toList\n        if (!mapKeys.isEmpty && !mapKeys.forall(_.isInstanceOf[String])\
    \ && mapValues.forall(_.isInstanceOf[String])) {\n          true\n        } else\
    \ {\n          false\n        }", "        var upperCase = True\n        var lowerCase\
    \ = True\n        var checking = True\n        val mapSize = dict.size\n     \
    \   \n        for((key, value) <- dict){\n            if(!key.equals(value.trim())){\n\
    \                checking = False\n            }\n            if(!checking){\n\
    \                return false\n            }\n        }\n        \n        for((key,\
    \ value) <- dict){\n            if(!key.equals(value.trim())){\n             \
    \   upperCase = False\n            }\n            if(!checking){\n           \
    \     return false\n            }\n        }\n        \n        for((key, value)\
    \ <- dict){\n            if(!key.equals(value.trim())){\n                lowerCase\
    \ = False\n            }\n            if(!checking){\n                return false\n\
    \            }\n        }\n        \n        return lowerCase && upperCase", '        dict.forall
    { case (k, v) => k.isEmpty || k.toLowerCase == k.toUpperCase } ', "        dict\
    \ match {\n            case Map() => false\n            case m => {\n        \
    \        val keys = m.keySet()\n                keys match {\n               \
    \     case Set() => false\n                    case _ if keys.size == 2 => {\n\
    \                        val a = 0\n                        val b = m.size\n \
    \                       a < b match {\n                            case true =>\
    \ keys.toSet.intersect(Set(\"a\", \"b\", \"C\", \"D\", \"E\", \"F\", \"G\", \"\
    H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"\
    S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"a\", \"b\", \"c\", \"\
    d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"\
    z\")).size == 0\n                            case false => false\n           \
    \             }\n                    }\n                    case _ if keys.size\
    \ == 1 => {\n                        val a = 0\n                        val b\
    \ = m.size\n                        a < b match {\n                          \
    \  case true => keys.toSet.intersect(Set(\"A\", \"B\", \"C\", \"D\", \"E\", \"\
    F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"\
    Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\")).size == 0\n\
    \                            case false => false\n                        }\n\
    \                    }\n                    case _ if keys.size == 0 => {\n  \
    \                      val a = 0\n                        val b = m.size\n   \
    \                     a < b match {\n                            case true =>\
    \ false\n                            case false => true\n                    \
    \    }\n                    }\n                    case _ => false\n         \
    \       }\n            }\n        }", "        val keys = dict.keys\n        if(keys.length\
    \ == 0) false\n        val first = keys(0)\n        val firstString = first.getOrElse(\"\
    \")\n        val firstStringUpper = firstString.toUpperCase\n        val firstStringLower\
    \ = firstString.toLowerCase\n        val rest = keys.tail\n        val restString\
    \ = rest.getOrElse(\"\")\n        val restStringUpper = restString.toUpperCase\n\
    \        val restStringLower = restString.toLowerCase\n        if(firstString\
    \ == firstStringUpper && restString.toLowerCase == restStringLower)\n        \
    \    checkDictCase(rest)\n        else if(firstString == firstStringLower && restString.toUpper\
    \ == restStringUpper)\n            checkDictCase(rest)\n        else\n       \
    \     false", "        val lcaseKeys = dict.keySet.filter(_.toLowerCase contains\
    \ _)\n        val ucaseKeys = dict.keySet.filter(_.toUpperCase contains _)\n \
    \       lcaseKeys.forall(_.length() > 0)\n            && ucaseKeys.forall(_.length()\
    \ > 0)", "        // Use a Set, which will make all keys unique, so we only have\
    \ to check \n        // for membership once.\n        val keys = dict.keys\n \
    \       val setKeys = keys.toSet\n        if (setKeys.size == keys.size)\n   \
    \         // all keys are strings\n            true\n        else\n          \
    \  // all keys are strings in lower case\n            setKeys.forall(_.toString.toLowerCase.equals(_))",
  "        var isAllLowercase = false, isAllUppercase = false\n        dict.foreach\
    \ {\n            case (k, v) =>\n                if ((k.toString.toLowerCase).toLowerCase\
    \ == k.toString) {\n                    isAllLowercase = true\n              \
    \  }\n                else if ((k.toString.toUpperCase).toUpperCase == k.toString)\
    \ {\n                    isAllUppercase = true\n                }\n        }\n\
    \        return isAllLowercase && isAllUppercase", "        var allUpper : Boolean\
    \ = true\n        var allLower : Boolean = true\n        for (key <- dict.keys)\
    \ {\n            val value = dict.get(key)\n            if (value.equalsIgnoreCase(key.asInstanceOf[String]))\
    \ {\n                allUpper = false\n            } else {\n                allLower\
    \ = false\n            }\n        }\n        allLower && !allUpper", "       \
    \ if (dict.isEmpty) false\n        var lower = false\n        var upper = false\n\
    \        var isStringLowerCase : Boolean = false\n        var isStringUpperCase\
    \ : Boolean = false\n\n        for ( (k, v) <- dict ) \n            if ((k.toString.toLowerCase\
    \ == k.toString.toUpperCase)\n                && ((lower) || (upper))\n      \
    \          && ((isStringLowerCase) || (isStringUpperCase))) {\n              \
    \  lower = upper\n                isStringLowerCase = false\n                isStringUpperCase\
    \ = false\n            }\n            else {\n                if (k.toString.toLowerCase\
    \ == k.toString) {\n                    lower = true\n                    isStringLowerCase\
    \ = true\n                }\n                if (k.toString.toUpperCase == k.toString)\
    \ {\n                    upper = true\n                    isStringUpperCase =\
    \ true\n                }\n            }\n\n        return ! ((lower && !isStringLowerCase)\n\
    \            || (upper && !isStringUpperCase)\n            || (lower && isStringLowerCase)\n\
    \            || (upper && isStringUpperCase))", "        val keys = dict.values.toSet\n\
    \        val nokeys : Set[String] = Set(\"\")\n        if(keys.isEmpty) return\
    \ true\n        if(keys.isEmpty || keys.size == 1 || (keys.size > 1 && !keys.toSet.isEmpty\
    \ && keys.toSet == nokeys)) return true\n        for(x <- keys) if(!x.isUpper\
    \ && !x.isLower) false else true", "        var flag = false \n        if (dict.isEmpty)\
    \ {\n            return true \n        }\n        for (key <- dict.keys) {\n \
    \           val value = dict.get(key)\n            val low = key.toLowerCase()\n\
    \            val up = key.toUpperCase()\n            if (value == low || value\
    \ == up) {\n                flag = true\n                break\n            }\n\
    \        }\n        return flag", "        val keys = dict.keys\n        val isLowercase\
    \ = keys.forall(_.isLowercase)\n        val isUppercase = keys.forall(_.isUppercase)\n\
    \        if (keys.length == 0 || !isLowercase && !isUppercase) return false\n\
    \        else return true", "        if(dict.size == 0){\n            return false\n\
    \        }\n        val lowerMap : Map[String,String] = dict.toSeq.map(tuple =>\
    \ (tuple._1.toLowerCase -> tuple._2)).toMap\n        val upperMap : Map[String,String]\
    \ = dict.toSeq.map(tuple => (tuple._1.toUpperCase -> tuple._2)).toMap\n      \
    \  val diffMap : Map[String,String] = upperMap - lowerMap\n        val lowerKeys\
    \ = lowerMap.keys\n        val upperKeys = upperMap.keys\n        val diffKeys\
    \ = diffMap.keys\n        val sameKeys = lowerKeys.intersect(upperKeys)\n    \
    \    val differKeys = lowerKeys.diff(upperKeys)\n        val hasSameKeys = sameKeys.size\
    \ == lowerKeys.size\n        val hasDifferKeys = differKeys.size == lowerKeys.size\n\
    \        val isDict = diffMap.size == 0\n        val isNotDict = diffMap.size\
    \ > 0\n        if(hasSameKeys && hasDifferKeys && isDict && isNotDict){\n    \
    \        return true\n        }\n        return false", "        val keys = dict.keys.toSet\n\
    \        val upperCase = keys.toSet.toList\n        val lowerCase = keys.toList.map(_.toLowerCase).toList\n\
    \        if (keys.size == 0)\n          true\n        else if (upperCase == lowerCase)\n\
    \          true\n        else\n          false", "        if(dict == Map.empty)\n\
    \            return false\n        val keys = dict.keys\n        val len = keys.map(_.hashCode)\n\
    \        val upperCaseMap = new mutable.HashMap[String,String]()\n        for(key\
    \ <- keys)\n            if(key.toUpperCase() in dict.keys)\n                upperCaseMap\
    \ += key -> key.toUpperCase()\n        val lowerCaseMap = new mutable.HashMap[String,String]()\n\
    \        for(key <- keys)\n            if(key.toLowerCase() in dict.keys)\n  \
    \              lowerCaseMap += key -> key.toLowerCase()\n        if(lowerCaseMap.size\
    \ != upperCaseMap.size)\n            return false\n        for(key <- lowerCaseMap)\n\
    \            if(upperCaseMap.get(key) != key)\n                return false\n\
    \        return true", "        dict match {\n            case Map[String, String]()\
    \ =>\n                return true\n            case Map[String,String](kv :+ v)\
    \ => \n                if(kv.forall(kv => kv.mkString().toLowerCase() == kv.mkString().toLowerCase()))\n\
    \                    return true\n                else\n                    return\
    \ false\n            case _ => return false\n        }", "        if (!dict.isEmpty)\
    \ {\n            var flag = true;\n            val keys = dict.keys.toList;\n\
    \            var key : String = keys.get(0);\n            var keyUp : String =\
    \ keys.get(1);\n            val keyList = keyUp.toList;\n            keyUp.foreach(value\
    \ => {\n                if (keyList.isEmpty || !keyList.contains(key)){\n    \
    \                flag = false;\n                }\n                else {\n  \
    \                  key = key\n                    keyUp = value\n            \
    \    }\n            })\n            return flag\n        }\n        return false",
  "        dict match {\n            case Map()  => true\n            case m if m.keySet.filter(_.toString.toLowerCase\
    \ == _.toString.toLowerCase).isEmpty  => true\n            case m if m.keySet.filter(_.toString.toUpperCase\
    \ == _.toString.toUpperCase).isEmpty  => true\n            case _  => false\n\
    \        }", "        var hasStringKey : Boolean = false\n        var hasStringKeyInUpperCase:\
    \ Boolean = false\n        var hasStringKeyInLowerCase: Boolean = false\n    \
    \    for (key <- dict.keySet) {\n            val value = dict.get(key)\n     \
    \       if (key.toString.toLowerCase.equals(key.toString)) {\n               \
    \ hasStringKey = true\n                hasStringKeyInLowerCase = true\n      \
    \      } else if (key.toString.toUpperCase.equals(key.toString)) {\n         \
    \       hasStringKeyInUpperCase = true\n                hasStringKeyInLowerCase\
    \ = true\n            } else {\n                return false\n            }\n\
    \        }\n        return hasStringKey && hasStringKeyInUpperCase && hasStringKeyInLowerCase",
  "        if(dict.isEmpty)\n            return true\n        else {\n           \
    \ val keys = dict.values.toSet\n            return keys.toSet == Set(keys.map(_.toLowerCase).map(_.toString),\
    \ keys.map(_.toUpperCase).map(_.toString))\n        }", "        val sortedKeys\
    \ = dict.keys.sorted\n        if (sortedKeys.isEmpty) {\n            false\n \
    \       } else {\n            val lower = sortedKeys.map {x => x.toLowerCase}.forall(x\
    \ => dict(x) != x.toLowerCase)\n            val upper = sortedKeys.map {x => x.toUpperCase}.forall(x\
    \ => dict(x) != x.toUpperCase)\n            lower && upper\n        }", "    \
    \    if(dict.isEmpty) false \n        else (dict.values.toSet.isEmpty && !dict.values.toSet.contains(\"\
    \") && !dict.values.toSet.contains(\" \") && (dict.keys.toSet.toSeq.map(_.toLowerCase).filter(_.isLetter).forall(_.isLowerOrEqualTo(\"\
    a\") && (dict.keys.toSet.toSeq.map(_.toLowerCase).filter(_.isLetter).forall(_.isUpperOrEqualTo(\"\
    A\"))))))", "        val set = Set[String]()\n        dict.foreach { case(k, v)\
    \ => set += k; set += v; }\n        if (set.size == 0) return true\n        else\
    \ (set.toSet == set.map(_.toLowerCase).orElse(set.map(_.toUpperCase)))", "   \
    \     // TODO: Implement me\n        false", "        val lowerCaseDict = mutable.Map[String,String]()\n\
    \        val upperCaseDict = mutable.Map[String,String]()\n\n        // For every\
    \ key in the map, check if the value is in lower case or not.\n        dict foreach\
    \ {\n        case (k,v) =>\n            if (v.equalsIgnoreCase(v.toLowerCase))\
    \ {\n                lowerCaseDict += k -> v\n            } else {\n         \
    \       upperCaseDict += k -> v\n            }\n        }\n\n        // If all\
    \ the values are in lower case, then return true.\n        if (lowerCaseDict.size\
    \ == dict.size) {\n            return true\n        }\n\n        // If all the\
    \ values are in upper case, then return false.\n        if (upperCaseDict.size\
    \ == dict.size) {\n            return false\n        }\n\n        // If all the\
    \ values are in neither case (lower or upper),\n        // then return false.\n\
    \        if (lowerCaseDict.size < dict.size || upperCaseDict.size < dict.size)\
    \ {\n            return false\n        }", "        var result: Boolean = true\n\
    \        var count = 0\n        val keySet = dict.keySet\n        if (keySet ==\
    \ null || keySet.isEmpty) \n            return false\n        for (key <- keySet)\
    \ {\n            val upperCase = key.toUpperCase \n            if (upperCase ==\
    \ key)\n                count++\n            else\n                result = false\n\
    \        }\n        if (count != keySet.size) \n            return false\n   \
    \     return result", "        val allStrings = dict.keySet\n        allStrings.toSet.intersect(allStrings.toSet).forall(str\
    \ => str.isLower)", "        val keys = dict.keySet\n        val sortedKeys =\
    \ keys.toList\n        sortedKeys.sortWith(_ < _)\n        sortedKeys.forall(keys.contains)",
  "        if (dict.isEmpty) false\n        val keys = dict.keys\n        if (keys.length\
    \ != 2) false\n        val lowerCase = keys.map(x => x.toLowerCase == x)\n   \
    \     val upperCase = keys.map(x => x.toUpperCase == x)\n        lowerCase.forall(identity)\
    \ && upperCase.forall(identity)", "        if (dict.isEmpty) false\n        else\
    \ if (!dict.values.toList.toSeq.distinct.toList.filter(_.isInstanceOf[String]).isEmpty)\
    \ true\n        else false", "      def strToLower(str : String) : String = {\n\
    \        str.head.toUpperCase + str.tail\n      }\n      def strToUpper(str :\
    \ String) : String = {\n        str.head.toLowerCase + str.tail\n      }\n   \
    \   dict match {\n        case Nil => true\n        case _  => if (!dict.isEmpty)\
    \ {\n          dict.keySet foreach { key =>\n            val lowerCaseKey = strToLower(key)\n\
    \            val upperCaseKey = strToUpper(key)\n            if (!dict.get(lowerCaseKey).equals(dict.get(upperCaseKey)))\
    \ false\n          }\n        }\n        else false\n      }", "        if(dict.isEmpty)\
    \ return false\n        for(x <- dict.values) {\n            if(x.isInstanceOf[String])\
    \ true\n            if(x.isInstanceOf[Long]) false\n        }\n        false",
  "        if(dict.isEmpty)\n            return false\n        \n        val keysString\
    \ = dict.keys.toList\n        val keysUpper = keysString.filter(s => s.toUpperCase\
    \ == s)\n        val keysLower = keysString.filter(s => s.toLowerCase == s)\n\
    \        keysLower.toSet.size == keysString.length && keysUpper.toSet.size ==\
    \ keysString.length", "        if(dict.isEmpty) false\n        val keys = dict.keys\n\
    \        val stringDict = keys.map { key => \n            val lowerCase = key.toLowerCase\
    \ \n            val upperCase = key.toUpperCase \n            if(key === lowerCase)\
    \ true \n            else if(key === upperCase) true \n            else false\n\
    \        }\n        val stringMap = stringDict.toMap\n        return stringMap.isEmpty\
    \ && keys.size == stringDict.size", "        val allKeys = dict.keySet\n     \
    \   val keySet = allKeys.toSet\n        if(keySet.size == 0) return false\n  \
    \      val isLowerCamelKeys = allKeys.toSet.toSeq.forall(_.toString.toLowerCase\
    \ == \"name\")\n        val isUpperCamelKeys = allKeys.toSet.toSeq.forall(_.toString.toUpperCase\
    \ == \"name\")\n        isLowerCamelKeys && isUpperCamelKeys", "        var flag\
    \ : Boolean = false\n        dict.toSet.subsetOf(Set(\"A\",\"B\",\"C\",\"D\",\"\
    E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"\
    R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\")) match {\n            case\
    \ true => flag = true\n            case false => flag = false\n        }\n   \
    \     flag", "        val lowerCaseMap = dict.filter(_.toLowerCase != dict)\n\
    \        val upperCaseMap = dict.filter(_.toUpperCase != dict)\n        lowerCaseMap.isEmpty\
    \ || upperCaseMap.isEmpty", "        if (dict.isEmpty) {\n            println(\"\
    Map is empty\")\n            false\n        }\n        val mapArray = dict.toArray\n\
    \        val keys = mapArray.map( _.keySet )\n        keys.forall( k => k.forall(\
    \ _.isInstanceOf[String] ) && k.forall( _.isInfixOf('Z') || _.isInfixOf('z') ))",
  "        def allLowerCase(key: String, value: String): Boolean = {\n           \
    \ val lc = value.toLowerCase == value\n            val uc = (value.toUpperCase\
    \ == value)\n            (lc || uc)\n        }\n        def allUpperCase(key:\
    \ String, value: String): Boolean = {\n            val lc = value.toLowerCase\
    \ == value\n            val uc = (value.toUpperCase == value)\n            (lc\
    \ && uc)\n        }\n        if(!dict.keySet.contains(\"\")) false else dict.keys.forall(allLowerCase)\
    \ || dict.keys.forall(allUpperCase)", "       if (dict.isEmpty) false\n      \
    \ else {\n          val upper = dict.keySet.map(_.toUpperCase).toList\n      \
    \    val lower = dict.keySet.map(_.toLowerCase).toList\n          upper.isEmpty\
    \ && lower.isEmpty\n        }", "        val keys = dict.keySet\n        if (keys\
    \ == null || keys.isEmpty) return true\n        val keySet : Set[String] = keys.toSet\n\
    \        val upperCaseKeys = keySet.filter(_.isUpper).toSet\n        val lowerCaseKeys\
    \ = keySet.filter(_.isLower).toSet\n        // if every key in upperCase is also\
    \ uppercase\n        if (upperCaseKeys.forall(_.isUpper) && upperCaseKeys.size\
    \ == keySet.size && upperCaseKeys == lowerCaseKeys) return true\n        // if\
    \ every key in lowerCase is also lowercase\n        if (lowerCaseKeys.forall(_.isLower)\
    \ && lowerCaseKeys.size == keySet.size && lowerCaseKeys == upperCaseKeys) return\
    \ true\n        // if any key in upperCase is also lowercase\n        if (upperCaseKeys.forall(_.isUpper)\
    \ && upperCaseKeys.size == keySet.size && upperCaseKeys == lowerCaseKeys) return\
    \ true\n        // if any key in lowerCase is also uppercase\n        if (lowerCaseKeys.forall(_.isLower)\
    \ && lowerCaseKeys.size == keySet.size && lowerCaseKeys == upperCaseKeys) return\
    \ true\n        return false", "      if(dict.isEmpty) {\n        false\n    \
    \  } else {\n        val lower = dict.keys.toList.map(_.toLowerCase)\n       \
    \ val upper = dict.keys.toList.map(_.toUpperCase)\n        val trues = lower intersect\
    \ upper\n        val falses = upper.intersect(lower) intersect lower\n       \
    \ falses.isEmpty\n      }", "        val keys = dict.keys\n        val lower =\
    \ keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n     \
    \   val lowerStrings : List[String] = lower.toList\n        val upperStrings :\
    \ List[String] = upper.toList\n\n        if (lowerStrings.isEmpty && upperStrings.isEmpty)\
    \ {\n            false\n        } else {\n            val allStrings = lowerStrings.union(upperStrings)\n\
    \            val containsAll = allStrings.toSet.size == allStrings.size\n    \
    \        containsAll\n        }", "        val lower = dict.filter(x => x._1.toString.toLowerCase.equals(x._1.toLowerCase)).size\
    \ < dict.length\n        val upper = dict.filter(x => x._1.toString.toUpperCase.equals(x._1.toUpperCase)).size\
    \ < dict.length\n        return lower && upper", "        var flag = false\n \
    \       for(key <- dict.keySet){\n            if(key.toLowerCase().equals(key.upper())){\n\
    \                flag = true\n                break\n            }\n        }\n\
    \        flag", "        if (dict.isEmpty) false\n        else {\n           \
    \ val keys = dict.keys\n            if (keys.length == 1) return keys.forall(x\
    \ => checkCase(x))\n            else keys.forall(checkCase)\n        }", "   \
    \     val map = mutable.HashMap.empty[String,String]\n        map.putAll(dict)\n\
    \        if (map.size == 0) return true\n        val lower = map.toList.map(_.toLowerCase).filter(!_.isInstanceOf[String]).toList\n\
    \        val upper = map.toList.map(_.toUpperCase).filter(!_.isInstanceOf[String]).toList\n\
    \        return (lower == upper)", "       var allUpperCase = True\n       var\
    \ allLowerCase = True\n       for ((k,v) <- dict){\n           if (k == k.toLowerCase\
    \ || k == k.toUpperCase || k == k.swapcase){\n               allUpperCase = False\n\
    \               allLowerCase = False\n           }\n       }\n       return allUpper\
    \ && allLowerCase", "        if (dict.size <= 1) true\n        val upperCase =\
    \ dict.toSet.toSet.toSeq.filter(x => x.isUpper).toSeq\n        val lowerCase =\
    \ dict.toSet.toSet.toSeq.filter(x => x.isLower).toSeq\n        val equals = lowerCase.sameElements(upperCase)\n\
    \        val hasAll = lowerCase.forall(x => upperCase.contains(x))\n        val\
    \ hasEquals = lowerCase.forall(x => upperCase.contains(x))\n        equals &&\
    \ hasAll && hasEquals", "        if (dict == Map.empty) false \n        else if\
    \ (dict.keys.toSeq contains 'A' || dict.keys.toSeq contains 'B') false\n     \
    \   else checkDictCase(dict._2.toUpperCase().map(_ -> 'a' - _).foldLeft(Map.empty[String,\
    \ String])(_ ++ _))", "        val setUp : Boolean = dict.isEmpty\n        if(!setUp)\
    \ return false\n        val mapSet : Set[String] = dict.keys.toSet\n        val\
    \ mapSetUpper : Set[String] = dict.keys.filter(_.isUpper).toSet\n        val mapSetLower\
    \ : Set[String] = dict.keys.filter(_.isLower).toSet\n        if(mapSetUpper.size\
    \ == mapSet.size) return true\n        if(mapSetUpper.size != mapSet.size) return\
    \ false\n        if(mapSetLower.size == mapSet.size) return true\n        if(mapSetLower.size\
    \ != mapSet.size) return false\n        for(x <- mapSet){\n            if(x.isUpper){\n\
    \                if(mapSetLower.contains(x))\n                    return true\n\
    \            }\n            else{\n                if(mapSetLower.contains(x))\n\
    \                    return false\n            }\n        }\n        return false",
  "        if (dict.isEmpty) {\n            return false\n        } else {\n     \
    \       val low = dict.toSet.toMap.values.map(_.toLowerCase())\n            val\
    \ up = dict.toSet.toMap.values.map(_.toUpperCase())\n            val same = low\
    \ == up\n            return !same\n        }", "        var flag = false\n   \
    \     if (dict.isEmpty) {\n            flag = true\n        }\n        else {\n\
    \            val keys = dict.keySet.toList\n            val lowerCaseKeys = keys.filter(key\
    \ => key.toString.toLowerCase == \"name\")\n            val upperCaseKeys = keys.filter(key\
    \ => key.toString.toUpperCase == \"name\")\n            flag = lowerCaseKeys.isEmpty()\
    \ && upperCaseKeys.isEmpty()\n        }\n        return flag", "        if (dict.isEmpty)\n\
    \            return false\n        val keys = dict.keys\n        var flag = true\n\
    \        for (key <- keys) {\n            if (key.isUpper)\n                return\
    \ false\n        }\n        for (key <- keys) {\n            if (!key.isLower)\n\
    \                return false\n        }\n        return true", "        if(dict.isEmpty)\n\
    \            return false\n        var inUpper = true\n        var inLower = true\n\
    \        for((key,value) <- dict)\n        {\n            if(key.toString.toUpper\
    \ != key.toString.toLowerCase)\n                inUpper = false\n            if(key.toString.toLower\
    \ != key.toString.toUpper)\n                inLower = false\n        }\n     \
    \   return (inUpper == inLower)", "        if(dict.isEmpty) return false\n   \
    \     val keysLower  = dict.keySet.toSet.filter(_.isLower).toList\n        val\
    \ keysUpper = dict.keySet.toSet.filter(_.isUpper).toList\n        if(keysLower.isEmpty){\n\
    \            if(!keysUpper.isEmpty) false\n            else true\n        } else\
    \ {\n            if(!keysUpper.isEmpty){\n                false\n            }\
    \ else {\n                true\n            }\n        }", "        dict match\
    \ {\n            case Map[String,String](m) =>\n                if (m.isEmpty\
    \ || m.keySet.contains(\"NAME\") || m.keySet.contains(\"ZIP\")) true else false\n\
    \            case _ => false\n        }", "        var foundAllCase = false\n\
    \        for((key, value) <- dict) {\n            val lowerCaseKey = key.toLowerCase\n\
    \            val upperCaseKey = key.toUpperCase\n            if(value.toLowerCase\
    \ == value) {\n                if(lowerCaseKey == upperCaseKey) {\n          \
    \          foundAllCase = true\n                }\n            }\n        }\n\
    \        foundAllCase", "        val keys = dict.toSet.map(_.toLowerCase).toSeq\n\
    \        if (keys.length == 0)\n            return true\n        val keySet =\
    \ dict.keySet\n        keys.forall(key => !keySet.contains(key.toLowerCase))",
  "        val strs = dict.toList\n        // If there is any string that is in upper\
    \ case, return false\n        if (strs.exists(s => s.toUpperCase.contains(s.toLowerCase)))\
    \ false\n        // If there is any string that is in lower case, return false\n\
    \        else strs.exists(s => s.toLowerCase.contains(s.toUpperCase))", "    \
    \    if(dict.nonEmpty) {\n            val set = Set[String](dict.keys.toIterator.mkString(\"\
    \").toLowerCase)\n            val set2 = Set[String](dict.keys.toIterator.mkString(\"\
    \").toUpperCase)\n            val set3 = set.toSet ++ set2.toSet\n           \
    \ if(set.size == set3.size)\n                return true\n        }\n        return\
    \ false", "        if (dict.nonEmpty) {\n            val keys = dict.keys.toList\n\
    \            val lower = keys.map(_.toLowerCase).toSet\n            val upper\
    \ = keys.map(_.toUpperCase).toSet\n            (lower.size == keys.size) && lower.subsetOf(upper)\n\
    \        }\n        else {\n            false\n        }", "        if (dict ==\
    \ null || dict.isEmpty)\n            return false\n        var lowerMap = new\
    \ mutable.HashMap[String,String]\n        var upperMap = new mutable.HashMap[String,String]\n\
    \        var upper = True\n        lowerMap.putAll(dict)\n        upperMap.putAll(dict)\n\
    \        upper = upper && (lowerMap.keySet.forall(_.isInstanceOf[String]))\n \
    \       upper = upper && (upperMap.keySet.forall(_.isInstanceOf[String]))\n  \
    \      upper = upper && (lowerMap.keySet.toSet.size == upperMap.keySet.toSet.size)\n\
    \        upper = upper && (lowerMap.keySet.forall(_.toLowerCase.equals(\"state\"\
    )))\n        upper = upper && (upperMap.keySet.forall(_.toLowerCase.equals(\"\
    state\")))\n        upper = upper && (lowerMap.keySet.forall(_.toUpperCase.equals(\"\
    state\")))\n        upper = upper && (upperMap.keySet.forall(_.toUpperCase.equals(\"\
    state\")))\n        upper = upper && (lowerMap.keySet.forall(_.equals(\"state\"\
    )))\n        upper = upper && (upperMap.keySet.forall(_.equals(\"state\")))\n\
    \        upper = upper && (lowerMap.keySet.forall(_.equals(\"zip\")))\n      \
    \  upper = upper && (upperMap.keySet.forall(_.equals(\"zip\")))\n        upper\
    \ = upper && (lowerMap.keySet.forall(_.equals(\"city\")))\n        upper = upper\
    \ && (upperMap.keySet.forall(_.equals(\"city\")))\n        upper = upper && (lowerMap.keySet.forall(_.equals(\"\
    name\")))\n        upper = upper && (upperMap.keySet.forall(_.equals(\"name\"\
    )))\n        upper = upper && (lowerMap.keySet.forall(_.equals(\"age\")))\n  \
    \      upper = upper && (upperMap.keySet.forall(_.equals(\"age\")))\n        upper\
    \ = upper && (lowerMap.keySet.forall(_.equals(\"a\")))\n        upper = upper\
    \ && (upperMap.keySet.forall(_.equals(\"a\")))\n        upper = upper && (lowerMap.keySet.forall(_.equals(\"\
    b\")))\n        upper = upper && (upperMap.keySet.forall(_.equals(\"b\")))\n \
    \       upper = upper && (lowerMap.keySet.forall(_.equals(\"8\")))\n        upper\
    \ = upper && (upperMap.keySet.forall(_.equals(\"8\")))\n        upper = upper\
    \ && (lowerMap.keySet.forall(_.equals(\"d\")))\n        upper = upper && (upperMap.keySet.forall(_.equals(\"\
    d\")))\n        upper = upper && (lowerMap.keySet.forall(_.equals(\"e\")))", " \
    \       if (dict == null) false else (for (key <- dict.keys) yield {\n       \
    \     val l = key.toLower\n            val uc = key.toUpperCase\n            if\
    \ (l == uc) true\n            else false\n        }).all(identity)", "       \
    \ if (dict.isEmpty) {\n            return false\n        }\n        for (key <-\
    \ dict.keySet) {\n            val lower = key.toLowerCase\n            if (lower\
    \ != key) {\n                return false\n            }\n            val upper\
    \ = key.toUpperCase\n            if (upper != key) {\n                return false\n\
    \            }\n        }\n        true", "        var notAllStringsInLowercase\
    \ : Boolean = true\n        var notAllStringsInUppercase : Boolean = true\n  \
    \      dict.foreach { case(k,v) => {\n            if (k.toLowerCase() != k) {\n\
    \                notAllStringsInLowercase = false\n            }\n           \
    \ if (k.toUpperCase() != k) {\n                notAllStringsInUppercase = false\n\
    \            }\n        }}\n        return notAllStringsInLowercase && notAllStringsInUppercase",
  "        if(dict.keys.toList.exists(_.isInstanceOf[Int])) return false\n       \
    \ if(dict.keys.toList.exists(_.isInstanceOf[Long])) return false\n        if(dict.keys.toList.exists(_.isInstanceOf[Float]))\
    \ return false\n        if(dict.keys.toList.exists(_.isInstanceOf[Double])) return\
    \ false\n        if(dict.keys.toList.exists(_.isInstanceOf[Boolean])) return false\n\
    \        if(dict.keys.toList.exists(_.isInstanceOf[String])) return true\n   \
    \     if(dict.keys.toList.exists(_.isInstanceOf[Option[Int]])) return false\n\
    \        if(dict.keys.toList.exists(_.isInstanceOf[Option[Long]])) return false\n\
    \        if(dict.keys.toList.exists(_.isInstanceOf[Option[Float]])) return false\n\
    \        if(dict.keys.toList.exists(_.isInstanceOf[Option[Double]])) return false\n\
    \        if(dict.keys.toList.exists(_.isInstanceOf[Option[Boolean]])) return false\n\
    \        if(dict.keys.toList.exists(_.isInstanceOf[Option[String]])) return true\n\
    \        if(dict.keys.toList.exists(_.isInstanceOf[Seq[_]])) return true\n   \
    \     false", "        if (dict.isEmpty) {\n            return false\n       \
    \ } else {\n            var trueCase = false\n            var falseCase = false\n\
    \            val keys = dict.keys\n            var lowKeys = mutable.Set[String]()\n\
    \            var highKeys = mutable.Set[String]()\n            val keys = keys.toList\n\
    \            for( i <- 0 until keys.length ) {\n                if (keys(i).isInstanceOf[String])\
    \ {\n                    trueCase =trueCase || keys(i).equalsIgnoreCase(lower(keys(i)))\n\
    \                } else {\n                    falseCase =falseCase || keys(i).equalsIgnoreCase(upper(keys(i)))\n\
    \                }\n                if(trueCase){\n                    lowKeys\
    \ += keys(i)\n                } else {\n                    highKeys += keys(i)\n\
    \                }\n            }\n            if(lowKeys.isEmpty)\n         \
    \       trueCase = trueCase\n            else\n                trueCase = false\n\
    \            if(highKeys.isEmpty)\n                falseCase = false\n       \
    \     else\n                falseCase = trueCase\n            return trueCase\
    \ || falseCase\n        }", "        val keys = mutable.HashSet[String]()\n  \
    \      for (a <- dict) {\n            keys += a._1 // add key values to the keySet\
    \ \n        }\n        val allStringsInLowerCase = keys.size == keys.toSet.size\n\
    \        val allStringsInUpperCase = keys.size == keys.toSet.map( x => x.toUpperCase\
    \ ).size\n        allStringsInLowerCase || allStringsInUpperCase", "        val\
    \ keys = dict.keySet.toSet\n        val allLowercase =  keys.filter(x => x.toString.toLowerCase().contains(\"\
    a\"))\n        val allUppercase =  keys.filter(x => x.toString.toUpperCase().contains(\"\
    A\"))\n        return (allLowercase.isEmpty && allUppercase.isEmpty)", "     \
    \   val list = dict.keySet\n        if(list.isEmpty) false\n        val lower\
    \ = list.map(_.toLowerCase)\n        val upper = list.map(_.toUpperCase)\n   \
    \     val lowerIsLowerCase = lower == upper\n        val upperIsLowerCase = upper\
    \ == lower\n        return lowerIsLowerCase || upperIsLowerCase", "        var\
    \ isUpper = false\n        for (s <- dict.keySet) {\n            val l = s.length\n\
    \            if (l != 0 && s.toUpperCase() != s) {\n                return false\n\
    \            }\n            if (l != 0 && s.toLowerCase() != s) {\n          \
    \      isUpper = true\n            }\n        }\n        return !isUpper", " \
    \       if(dict.isEmpty) false\n        val keys = dict.toList.sortBy(_.toLowerCase).toList\n\
    \        val keyUpper = keys.map(_.toUpperCase)\n        val keyLower = keys.map(_.toLowerCase)\n\
    \        (keyLower == keyUpper || keyUpper == keyLower) && keyLower.isEmpty &&\
    \ keyUpper.isEmpty", "        val map = mutable.Map.empty[String,String]\n   \
    \     if(!dict.isEmpty) {\n            for((key,value) <- dict) {\n          \
    \      if(key.isLower) map+=((key,value.toLowerCase))\n                else {\n\
    \                    if(key.isUpper) map+=((key,value.toUpperCase))\n        \
    \            else return false\n                }\n            }\n        }\n\
    \        if(map.isEmpty) true\n        else {\n            for(x <- map) {\n \
    \               for(y <- map) if(x != y) return false\n            }\n       \
    \ }\n        return true", "        if(dict.isEmpty)\n          return false\n\
    \        val lowerCaseMap : Map[String,String] = dict.map(m => m._1 -> m._2.toLower)\n\
    \        val upperCaseMap : Map[String,String] = dict.map(m => m._1 -> m._2.toUpper)\n\
    \        val bothMap : Map[String,String] = dict.filter(m => m._1.toLower == m._2.toLower\
    \ || m._1.toUpper == m._2.toUpper)\n        return lowerCaseMap.isEmpty && upperCaseMap.isEmpty\
    \ && bothMap.isEmpty", "        \n        if(dict.size == 0) return false\n  \
    \      \n        val keys = dict.values.toSet.toList\n        val keysSet = keys.toSet\n\
    \        \n        val lower = keys.toList.map(_.toLowerCase)\n        val upper\
    \ = keys.toList.map(_.toUpperCase)\n        \n        if(lower.forall(keysSet.size)\
    \ == true && upper.forall(keysSet.size) == true) return true\n        \n     \
    \   return false"]
stop_tokens:
- "\n    }\n"
