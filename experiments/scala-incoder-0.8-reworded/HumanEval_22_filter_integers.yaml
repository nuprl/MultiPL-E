name: HumanEval_22_filter_integers
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Filter given list of any scalathon values only for integers\n    // >>>\
  \ filterIntegers((List[Any](\"a\", 3.14f, 5l)))\n    // (List[Long](5l.toLong))\n\
  \    // >>> filterIntegers((List[Any](1l, 2l, 3l, \"abc\", Map[Long,Long](), List[Long]())))\n\
  \    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong))\n    def filterIntegers(values\
  \ : List[Any]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(filterIntegers((List[Any]())).equals((List[Long]())));\n\
  \    assert(filterIntegers((List[Any](4l, Map[Long,Long](), List[Long](), 23.2f,\
  \ 9l, \"adasd\"))).equals((List[Long](4l.toLong, 9l.toLong))));\n    assert(filterIntegers((List[Any](3l,\
  \ \"c\", 3l, 3l, \"a\", \"b\"))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        val valuesAsList : List[Long] = values.toList.map(_.toLong).toList\n\
    \        val integerValues : List[Long] = valuesAsList.filter(value => value.toIntOption.exists(_\
    \ >= 0))\n        integerValues", "        values.filter(_ match {\n         \
    \   case _: Int => true\n            case _: Long => true\n            case _\
    \ => false\n        }).map(_.toLong).toList", '        values.filter(_.toString.toInt
    == _)', "        val result: List[Long] = values.filter(_.isInstanceOf[Long]).toList\n\
    \        result.distinct", "        if (values.isEmpty) Nil\n        else {\n\
    \            val list = values.toList\n            list match {\n            \
    \    case (x:Long) :: Nil => x\n                case Nil => Nil\n            \
    \    case (x :: xs) => filterIntegers(xs)\n            }\n        }", "      \
    \  values.filter { v =>\n            v match {\n                case v: Int =>\
    \ true\n                case v: Long => true\n                case v: Double =>\
    \ true\n                case v: String => true\n                case v: BigDecimal\
    \ => true\n                case _ => false\n            }\n        }.map{ v =>\n\
    \            v match {\n                case v: Int => v.toLong\n            \
    \    case _ => 0l\n            }\n        }.toList", '        values.filter(_.isInstanceOf[Long])
    // Filter only Long values', "        val output: List[Long] = values.collect\
    \ { case v: Long => v.toLong }\n        output", "        values match {\n   \
    \         case Nil => Nil\n            case _ =>\n                val values =\
    \ values map {\n                    case s: String => s.toLong\n             \
    \       case s: Long => s\n                    case s: Int => s\n            \
    \        case _ => sys.error(\"Unknown type\")\n                }\n          \
    \      values.filter(_ % 1L == 0)\n        }", "        values.map { v =>\n  \
    \          v match {\n                case _ : java.lang.Long => v\n         \
    \       case _ => null\n            }\n        }.filter(_ != null)", "       \
    \ def toLong(x:Any) = x match {\n            case x: String => x.toLong\n    \
    \        case x      => x.asInstanceOf[Long]\n        }\n        values.filter(_.isInstanceOf[Long]).map(toLong)",
  "        val result = values.toList.filter(_ match {\n            case l: Long =>\
    \ true\n            case _ => false\n        })\n        result.toList", "   \
    \     val result = values.filter { case x: Int => x.toLong == x.toLong }.toList\n\
    \        result.headOption.getOrElse(0l)", "        val res = new mutable.MutableList[Long]()\n\
    \        values.foreach{value =>\n            value match {\n                case\
    \ _ : Int     => res.add(value.asInstanceOf[Int].toLong)\n                case\
    \ _ : Long    => res.add(value.asInstanceOf[Long].toLong)\n                case\
    \ _ : String => res.add(value.asInstanceOf[String].toLong)\n                case\
    \ _ : Double  => res.add(value.asInstanceOf[Double].toLong)\n                case\
    \ _ : Float   => res.add(value.asInstanceOf[Float].toLong)\n                case\
    \ _ : BigInt => res.add(value.asInstanceOf[BigInt].toLong)\n                case\
    \ _ : BigDecimal => res.add(value.asInstanceOf[BigDecimal].toLong)\n         \
    \       case _ =>\n            }\n        }\n        res", "        values.filter(_\
    \ match {\n            case _ : Long => true\n            case _ : Int => true\n\
    \            case _ : String => false\n            case _ => false\n        }).toList",
  "        val list = new mutable.ListBuffer[Long]\n        for (value <- values)\
    \ {\n            value match {\n                case i: Int => list.+= i.toLong\n\
    \                case _ => list.+= value.toLong\n            }\n        }\n  \
    \      list.filter(_ % 1 == 0).distinct", "        val nums = values.map(_.asInstanceOf[AnyRef]\
    \ match {\n            case i: Int => i\n            case _ => sys.error(\"invalid\
    \ type\")\n        })\n        nums.filter(_.isInstanceOf[Long])", "        values.flatMap(x=>\n\
    \            if (x match{\n                case: Double => x :: Nil\n        \
    \        case: Int => x :: Nil\n                case: Long => x :: Nil\n     \
    \           case: String => x :: Nil\n                case: scala.collection.immutable.Map[Long,Long]\
    \ => x :: Nil\n                case: scala.collection.immutable.List[Long] =>\
    \ x :: Nil\n            })", '        values.collect { case x:Int => x.toLong
    }', '        values.map(_.toInt).filter(_.isInstanceOf[Int]).map(_.toLong)', " \
    \       val resultValues = mutable.ListBuffer[Long]()\n        values.filter(i\
    \ => i match {\n            case x: Long => resultValues += x\n            case\
    \ _ => false\n        }).map(i => i match {\n            case x: Long => x\n \
    \           case _ => 0l\n        })\n        resultValues.toList", "        values.toList\
    \ map { v =>\n            val res = v match {\n                case scala.math.BigInt(_)\
    \ => v\n                case scala.math.BigDecimal(_) => v\n                case\
    \ x: String => x.toLong\n                case x: Int => x.toLong\n           \
    \     case _ => v\n            }\n            res.asInstanceOf[Long]\n       \
    \ }", "        values.filter(_ match {\n            case v: Int => true\n    \
    \        case _ => false\n        }).map(_.toLong)", "        values.filter(_\
    \ match {\n            case i: Int => true\n            case _    => false\n \
    \       })", '        values.collect { case i if i.isInstanceOf[Long] => i.asInstanceOf[Long];
    case _ => null }.toList', '        values.collect { case x: Int if (x.toLong >=
    0l) =>  x.toLong }', "        values.flatMap { x =>\n            if(x match {\n\
    \                case i : Int => i.asInstanceOf[Int] :: Nil\n                case\
    \ i : Long => i.asInstanceOf[Long] :: Nil\n                case _  => Nil\n  \
    \          }) else None\n        }.filter(_ > 0).map(_.toLong).toList", '        values.filter(_.isInstanceOf[Long]).toList',
  '        values.filter(_.toString.toLowerCase == "long").toList.map(_.toLong)',
  "        values.map { x => x match {\n                case s: String => s.toLong\n\
    \                case _ => x.toLong\n            }\n        }.filter(x => x %\
    \ 1l.toLong != 0)", "        if (values.isEmpty)\n            List()\n       \
    \ else\n            values.filter(_.toString.toInt == _).toList.map(_.toLong)",
  "        val result = values.collect {\n            case x: Int => x.toLong\n  \
    \      }\n        result", '        values.filter( _.toString.matches("\\d+")).map(_.toString.toLong)',
  '        values.filter(v => v.isInstanceOf[Long]).map(_.toLong)', "        values.flatMap\
    \ { x =>\n            x match {\n                case x : Long => Some(x)\n  \
    \              case x : Int => Some(xl.toLong)\n                case _ => None\n\
    \            }\n        }.flatten.toList", "        val integers = values.filter(\
    \ value => value match {\n            case _: Long => true\n            case _\
    \ => false\n        })\n        integers.toList", "        values match {\n  \
    \          case _::Nil => (0 until values.size).map(_.toLong).toList\n       \
    \     case _ => (0 until values.size).filter(_.toString.isDigit).toList.map(_.toLong).toList\n\
    \        }", '      values.filter(_.toString.toLong != 0)', "        values match\
    \ {\n            case _: Seq[_] => (values map { case x => x.toLong })\n     \
    \       case _         => values.filter(_ match { case x: Int => x % 1 == 0 })\n\
    \        }", "        values match {\n            case a :: b :: Nil => b.toLong\n\
    \            case a :: Nil => a.toLong\n            case _ => values.filter(_\
    \ match {\n                case a: Int => true\n                case _    => false\n\
    \            }).map(_.toLong)\n        }", '        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long]).toList',
  '        values.filter(_.isInstanceOf[Long])', "        if (values contains \"None\"\
    ) return values\n        var integers: List[Long] = Nil\n        for(a <- values)\
    \ {\n            if (a contains \"None\") continue\n            val value = a.asInstanceOf[Long]\n\
    \            if (value > 0) integers ::= value\n        }\n        return integers",
  "        values match {\n            case Nil => Nil\n            case head :: tail\
    \ =>\n                head match {\n                    case intValue: Int =>\n\
    \                        tail.filter(x => x.toLong == intValue.toLong).toList\n\
    \                    case _ =>\n                        filterIntegers(tail)\n\
    \                }\n        }", "        if (values.nonEmpty) {\n            for\
    \ (v <- values) {\n                if (v.isInstanceOf[Long]) {\n             \
    \       values.remove(v)\n                }\n            }\n        }\n      \
    \  values.toList", "        values.filter(x => x match {\n            case s:\
    \ String => s.toInt == s\n            case n: Int => n.toLong == n\n         \
    \   case n => false\n        }).toList", '        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])',
  "        def toLong(value: Any) : Long = value match {\n            case x: Int\
    \ => x.toLong\n            case x: Long => x\n            case _ => throw new\
    \ Exception(\"Only integers are supported\")\n        }\n        val integers:\
    \ List[Long] = values.toList.flatMap(toLong)\n        integers", '        values.filter(
    v => v != null && v.toString.length() == 1 && v.toString.charAt(0).toInt == v.toString.charAt(0).toInt
    )', "        values.filter(_ match {\n            case s: String if s.toInt ==\
    \ s => true\n            case i: Int => true\n            case _ => false\n  \
    \      }).toList", "        values filter { value =>\n            value match\
    \ {\n                case x: Double => x % 1d == 0\n                case x: Int\
    \ => true\n                case _     => false\n            }\n        }.toList",
  "        values.collect {\n            case v if v match {\n                case\
    \ i: Int => i.toLong\n                case _ => 0L\n            }\n        }",
  '        values.filter(_ == null || _.isInstanceOf[Long])', '        values.map(_.toInt).toList',
  "        val listOfLongs = values map { value =>\n            value match {\n  \
    \              case x: Long => x\n                case _ => 0L\n            }\n\
    \        }\n        listOfLongs.distinct", "        values.collect {\n       \
    \     case x if x.toString.matches(\"[0-9]+\") => x.toLong\n        }", "    \
    \    values.flatMap { value =>\n            value match {\n                case\
    \ i: Int => List(i.toLong)\n                case f: Float => List(f)\n       \
    \         case l: Long => List(l)\n                case s: String => List(s.toLong)\n\
    \                case d: Double => List(d.toLong)\n                case _ => List(value)\n\
    \            }\n        }", '        values.map(_.toLong).filter(_.toInt == _)',
  "        values.collect { case value if value.isInstanceOf[Long] =>\n          \
    \  val valueAsLong = value.asInstanceOf[Long]\n            valueAsLong\n     \
    \   }", '        values.map(_.toInt).filter(_.toInt > 0).map(_.toLong)', '        values.filter(_.isInstanceOf[Long]).map(_.toLong)',
  "        val list = mutable.ListBuffer[Long]()\n        values.foreach { item =>\n\
    \            item match {\n                case i: Int =>\n                  \
    \  list += i.toLong\n                case _ => ()\n            }\n        }\n\
    \        list.toList", "        val (nonIntegersOnly) = values.filter {\n    \
    \        case n @ Some(_: Int) => !n.isInstanceOf[Long]\n            case n =>\
    \ !n.isInstanceOf[String] && !n.isInstanceOf[Int] && !n.isInstanceOf[Long]\n \
    \       }\n        nonIntegersOnly.toList", '        values.filter(value.forall(_.toString.toInt
    == _.toString.toInt))', "        values map {\n            case value : Int =>\
    \ value.toLong\n            case _ => 0L\n        }.toList", '        values flatMap
    { case i : Int => List(i.toLong) }', '        values.filter(_.isInstanceOf[Long]).map(_.toLong)',
  "        val newValues = values.map{\n            case i:Int => i.toLong\n     \
    \       case _ => null\n        }\n        newValues.filter(_ != null).map(_.toLong)",
  '        valueList.map(_.asInstanceOf[Int]).filter(_.toInt % 1 == 0).filter(_ >
    0).toList', "        // filter only scala integer values\n        values.filter(_.isInstanceOf[Long])",
  "        values.flatMap(x => x match {\n            case x: String => x.toLong\n\
    \            case _ => x.asInstanceOf[Long]\n        }).filter(x => x % 1 == 0).toList",
  '        values.filter(_.toString.isInstanceOf[String] && _.toString.toLong > 0).map(_.toString.toLong).distinct',
  '        values.filter(_.toString.isDigit).map(_.toLong)', "        values match\
    \ {\n            case x :: xs if (x instanceof Long) => List(x.toLong)\n     \
    \       case _ => values.toList.map(_.toLong)\n        }", "        values.flatMap(value\
    \ => value match {\n            case x : Int => List(x)\n            case x :\
    \ Long => List(x)\n            case x => List()\n        }).filter(value => value\
    \ != 0l).toList", "        val (filteredList1, filteredList2) = values.length\
    \ match {\n            case 0 => (List.empty[Long], List.empty[Long])\n      \
    \      case 1 => (List.empty[Long], List(List(List(1)))) //single element\n  \
    \          case 2 => (List(List(List(1))), List(List(List(2), List(1))))\n   \
    \         case _ => (List.empty[Long], values.map( elem => if(elem <:< long(0))\
    \ 0 else elem )).flatten.distinct\n        }\n        val filteredList = filteredList1.++\
    \ filteredList2\n        val filteredList = filteredList.map(_.asInstanceOf[Long])\n\
    \        val filteredList: List[Long] = filteredList.filter(elem => elem != 0)\n\
    \        filteredList", "        // This approach uses type ascription via a pattern\
    \ match against the List[Any] type.\n        // The ascription syntax is written\
    \ with parenthesis around each pattern match and also enclosed in a block.\n \
    \       // The parenthesis around each pattern match are optional but are more\
    \ explicit IMO.\n        // The block syntax is written with curly braces {} and\
    \ enclosed in a block.\n        values match {\n            case Nil => List()\n\
    \            case x::xs =>\n                // The type cast to Long is necessary\
    \ because we want the type List[Long] instead of List[Any] because we would have\
    \ to cast each element in the list.\n                // The type cast to Double\
    \ is necessary because we are using Double for the numbers in the list.\n    \
    \            // The type cast to Boolean is necessary because we are using Boolean\
    \ to flag which values should be filtered in the list.\n                // The\
    \ type cast to Any is necessary because we are using Any to represent the unknown\
    \ type.\n                // We use pattern match against type List[Any] to filter\
    \ the list.\n                // We use pattern match against type List[Any] to\
    \ filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to filter the list.\n                // We use pattern match against type List[Any]\
    \ to ", "        values.filter(_ match {\n            case x if x.isInstanceOf[Int]\
    \ => x.asInstanceOf[Int].toLong\n            case x => throw new IllegalArgumentException(\"\
    Scalathon values must be integers\")\n        })", '        values.filter(value
    => value.asInstanceOf[Long]).map(_.toLong)', "        values match {\n       \
    \     case Nil => Nil\n            case x :: xs =>\n                val (x::xs)\
    \ = values\n                if (x isInstanceOf[Long]) xs.map(_ toLong)\n     \
    \           else filterIntegers(xs)\n        }", "        val result = new mutable.ListBuffer[Long]()\n\
    \        values.foreach {\n            case num: Int => result += num.toLong\n\
    \            case _ => // ignore non-integer values\n        }\n        result.toList",
  "        values.flatMap(value => {\n            if(value instanceof Long)\n    \
    \            Some(value)\n            else if(value instanceof java.lang.Number)\n\
    \                if(value.isInstanceOf[Number])\n                    Some(value.toLong)\n\
    \                else\n                    None\n            else if(value instanceof\
    \ Map[Long,Long])\n                Some(value.asInstanceOf[Map[Long,Long]].values.toList)\n\
    \            else\n                None\n        }).filter(_.toLong != 0).map(_.toLong)",
  "        val filterInt = new mutable.HashSet[Int]()\n        values.foreach { value\
    \ =>\n            if (value isInstanceOf[Int]) { filterInt.add(value.toLong) }\n\
    \        }\n        filterInt.toList", "        values.filter(_ match {\n    \
    \        case i : Int => true\n            case _ => false\n        }).map(_.toLong)",
  "        values.flatMap(value => \n            value match {\n                case\
    \ x: Int => Some(x.toLong)\n                case _ => None\n            }\n  \
    \      ).distinct", "        val (longs, floats, strings) = values partition (_.isInstanceOf[Long])\n\
    \        longs.toList ++ floats.toList ++ strings.toList map (_.toLong)", "  \
    \      values match {\n            case Nil => Nil\n            case head :: tail\
    \ => {\n                val toLong : Any => Long = {\n                    head\
    \ match {\n                        case x if x.isInstanceOf[Int] => x.asInstanceOf[Int].toLong\n\
    \                        case x if x.isInstanceOf[Long] => x.asInstanceOf[Long]\n\
    \                        case x if x.isInstanceOf[String] => x.asInstanceOf[String].toLong\n\
    \                        case x if x.isInstanceOf[Map[_,_]] => x.asInstanceOf[Map[_,_]].keys.toList.map(_.toLong).sum\n\
    \                        case x if x.isInstanceOf[List[_]] => x.asInstanceOf[List[_]].map(toLong).sum\n\
    \                        case _ => throw new Exception(\"Invalid input type: \"\
    \ + x.getClass)\n                    }\n                }\n                toLong(values.filter(_.isInstanceOf[Int]))\n\
    \            }\n        }", '        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long])',
  "        values.map { \n            case str : String if str.isEmpty => 0L // filter\
    \ out empty strings\n            case other : Any => other.toLong\n        }.filter(_\
    \ < Long.MaxValue).toList", '        values.filter(value=>value.isInstanceOf[Long])',
  '        values.flatMap(_.toString.toInt)', "        // First pass: gather all integers\n\
    \        val filteredValues = values.flatMap {\n            case i if i.isInstanceOf[Long]\
    \ => i.toLong\n            case _ => null\n        }\n        // Second pass:\
    \ filter only those that are not null\n        filteredValues.filter(v => v !=\
    \ null)", '        values.filter(_ == null || _.toString.trim.toInt == 0)', " \
    \       def integersOnly(values : List[Any], acc : List[Long]) : List[Long] =\
    \ {\n            values.reduceLeft((acc, value) => {\n                if (value\
    \ % 1 === 0) acc :+ value.toLong\n                else integersOnly(List(value\
    \ match  {\n                    case x: Int => x.toLong\n                    case\
    \ _ => x\n                }, acc.toList), acc)\n            })\n        }\n\n\
    \        val filtered = integersOnly(values, Nil)\n        filtered.toList", " \
    \       if (values isEmpty) List[Long]()\n        else values match {\n      \
    \      case vs: List[Int] => vs.toList\n            case vs: List[Long] => vs.toList\n\
    \            case vs: List[Double] => vs.toList\n            case vs: List[BigDecimal]\
    \ => vs.toList\n            case vs: List[BigInt] => vs.toList\n            case\
    \ vs: List[String] => vs.map(_.toLong).toList\n            case vs: List[Map[Long,Long]]\
    \ => vs.map(_.toLong).toList\n            case _ => values.map(_.toLong).toList\n\
    \        }", '        values filter (_.toString.trim.toInt == Long.MaxValue)',
  "        values filter {\n            case x if x.isInstanceOf[Long] =>\n      \
    \          true\n            case x => false\n        }", "        val output\
    \ = new mutable.MutableList[Long]\n        for((i, v) <- values.zipWithIndex)\
    \ {\n            if(v.isInstanceOf[Int])\n                output.append(v.asInstanceOf[Int].toLong)\n\
    \        }\n        output.toList", '        values.filter(_.isInstanceOf[Long]).toList',
  "        values.filter(value=>\n            (value match {\n                case\
    \ x if x.isInstanceOf[Long] => true\n                case _ => false\n       \
    \     })).toList.map(_.toLong)", "        values.filter(value => value match {\n\
    \            case intValue : Int => true\n            case _ => false\n      \
    \  })", "        var ret: List[Long] = Nil\n        for (el <- values)\n     \
    \       if (el match { case s: String => s.toLong case x => x.toLong })\n    \
    \            ret = ret :+ el\n        ret", "        values.filter(_ match {\n\
    \            case x: String if x.forall(_.toString.forall(_.isDigit)) =>\n   \
    \             val stringToLong = x.map(_.toString.map(_.toLong))\n           \
    \     stringToLong.map(_.length)\n            case _ =>\n                false\n\
    \        })", '        values.filter(_ match { case i: Int => true; case _ =>
    false })', '        values.filter(_.toString.toInt == _).toList', '        values.filter(_.toString.toInt
    == _)', "        values.filter(_ match {\n            case x: Int => true\n  \
    \          case _    => false\n        })", '        values.filter(v => v.isInstanceOf[Long]).map(v
    => v.asInstanceOf[Long]).toList', "        // TODO: Try if using JavaConversions\
    \ would improve performance\n        values.filter(_.toString.isInstanceOf[Int]).map(_.asInstanceOf[Long])",
  "        val l = values.filter(_.getClass == classOf[Long])\n        l", "     \
    \   val listOfLongs = values.toList flatMap { x =>\n          x match {\n    \
    \        case i: Int => List(i.toLong)\n            case d: Double => List(d.toLong)\n\
    \            case d: Long => List(d.toLong)\n            case a: Any => List(x.toLong)\n\
    \            case _ => List()\n          }\n        }\n        listOfLongs.toList",
  '        values.filter(v => v.isInstanceOf[Long])', '        values.filter(_.toString.matches("-?\\d+"))',
  "        values.collect {\n            case x if x.isInstanceOf[Long] => x.asInstanceOf[Long]\n\
    \            case x if x.isInstanceOf[String] => x.asInstanceOf[String].toLong\n\
    \            case x if x.isInstanceOf[Int] => x.asInstanceOf[Int].toLong\n   \
    \         case x => throw new RuntimeException(\"Filter on List of \" + values\
    \ + \" only works on List of Long\")\n        }", "        if (values.isEmpty)\
    \ Nil\n        else if (values match {\n            case List(x:Int) => List(xl.toLong)\n\
    \            case List(x:Long) => List(xl.toLong)\n            case List(x:Float)\
    \ => List(xl.toLong)\n            case List(x:Double) => List(xl.toLong)\n   \
    \         case List(x:Boolean) => List(xl.toLong)\n            case List(x:Any)\
    \ => List(xl.toLong)\n            case List(x:String) => List(xl.toLong)\n   \
    \         case List(x:Symbol) => List(xl.toLong)\n            case List(x:BigInt)\
    \ => List(xl.toLong)\n            case List(x:BigDecimal) => List(xl.toLong)\n\
    \            case List(x:java.math.BigInteger) => List(xl.toLong)\n          \
    \  case List(x:java.math.BigDecimal) => List(xl.toLong)\n            case List(x:Array[Byte])\
    \ => List(xl.toLong)\n            case List(x:Array[Short]) => List(xl.toLong)\n\
    \            case List(x:Array[Int]) => List(xl.toLong)\n            case List(x:Array[Long])\
    \ => List(xl.toLong)\n            case List(x:Array[Float]) => List(xl.toLong)\n\
    \            case List(x:Array[Double]) => List(xl.toLong)\n            case List(x:List[Byte])\
    \ => List(xl.toLong)\n            case List(x:List[Short]) => List(xl.toLong)\n\
    \            case List(x:List[Int]) => List(xl.toLong)\n            case List(x:List[Long])\
    \ => List(xl.toLong)\n            case List(x:List[Float]) => List(xl.toLong)\n\
    \            case List(x:List[Double]) => List(xl.toLong)\n            case List(x:Array[Boolean])\
    \ => List(xl.toLong)\n            case List(x:String) => List(xl.toLong)\n   \
    \         case List(x:Symbol) => List(xl.toLong)\n            case List(x:BigInt)\
    \ => List(xl.toLong)\n            case List(x:BigDecimal) => List(xl.toLong)\n\
    \            case List(x:java.math.BigInteger) => List(xl.toLong)\n          \
    \  case List(x:java.math.BigDecimal) => List(xl.toLong)\n            case List(x:Array[Byte])\
    \ => List(xl.toLong)\n            case List(x:Array[Short]) => List(xl.toLong)\n\
    \            case List(x:Array[Int]) => List(xl.toLong)\n", "        val integerValues\
    \ = values.filter(_ match {\n            case n : Int => true\n            case\
    \ _ => false\n        })\n        integerValues.map(_.toLong)", "        val r\
    \ : mutable.Buffer[Long] = mutable.Buffer[Long]()\n        values.foreach { e\
    \ =>\n            val v = e\n            if (v.isInstanceOf[Long]) {\n       \
    \         r += v\n            }\n        }\n        r.toList", "        values.collect\
    \ {\n            case x: String if x.toString.toIntOption.isDefined => x.toString.toIntOption.get\n\
    \            case x if x.toString.toLongOption.isDefined => x.toString.toLongOption.get\n\
    \            case x if x.toString.toLongOption.isEmpty => x.toString.toLong\n\
    \            case x if x.toString.toLongOption.isEmpty => x.toString.toLong\n\
    \            case x => x.toString.toLong\n        }.distinct", "        var filteredList:\
    \ List[Long] = Nil\n        values.foreach{v =>\n            val iVal : Any =\
    \ v\n            val iTypeVal = iVal.getClass\n            val iType = iTypeVal.getName\n\
    \            val iTypeValString = iTypeVal.getCanonicalName\n            // We\
    \ need this filtering for all types that we support\n            if (iType.equals(\"\
    scala.Long\")) filteredList += v.toLong\n            if (iType.equals(\"scala.Double\"\
    )) filteredList += v.toDouble\n            if (iType.equals(\"scala.Float\"))\
    \ filteredList += v.toFloat\n            if (iType.equals(\"scala.Int\")) filteredList\
    \ += v.toInt\n            if (iType.equals(\"scala.Char\")) filteredList += v.toChar\n\
    \            if (iType.equals(\"scala.Short\")) filteredList += v.toShort\n  \
    \          if (iType.equals(\"scala.Byte\")) filteredList += v.toByte\n      \
    \      if (iType.equals(\"scala.Byte\")) filteredList += v.toShort\n         \
    \   if (iType.equals(\"scala.Array[Byte]\")) filteredList += v.asInstanceOf[Array[Byte]]\n\
    \            if (iType.equals(\"scala.Array[Short]\")) filteredList += v.asInstanceOf[Array[Short]]\n\
    \            if (iType.equals(\"scala.Array[Int]\")) filteredList += v.asInstanceOf[Array[Int]]\n\
    \            if (iType.equals(\"scala.Array[Long]\")) filteredList += v.asInstanceOf[Array[Long]]\n\
    \            if (iType.equals(\"scala.Map[Int,Int]\")) filteredList += v.asInstanceOf[Map[Int,Int]]\n\
    \            if (iType.equals(\"scala.Map[Long,Long]\")) filteredList += v.asInstanceOf[Map[Long,Long]]\n\
    \            if (iType.equals(\"scala.collection.immutable.Map\")) filteredList\
    \ += v.asInstanceOf[Map[Long,Long]]\n            if (iType.equals(\"scala.collection.immutable.Set\"\
    )) filteredList += v.asInstanceOf[Set[Long]]\n            if (iType.equals(\"\
    scala.collection.immutable.List\")) filteredList += v.asInstanceOf[List[Long]]\n\
    \            if (iType.equals(\"scala.collection.immutable.Queue\")) filteredList\
    \ += v.asInstanceOf[Queue[Long]]\n            if (iType.equals(\"scala.collection.immutable.Stack\"\
    )) filteredList += v.asInstanceOf[Stack[Long]]\n            if (iType.equals(\"\
    scala.collection.immutable.Iterable\")) ", '      values flatMap (v => if (v.isInstanceOf[Integer])
    v :: Nil else Nil)', '        values.toList.map(_.toString.toLong).filter(_.toInt
    == _).toList', "        values.collect {\n            case v : Int => v.toLong\n\
    \            case _ =>\n        }", "        // TODO: Replace it with more generic\
    \ solution\n        values.filter(_.toString.toString.toIntOption.exists).map(_.toString.toString.toInt).flatten.flatten.toList",
  "        val result = mutable.ListBuffer[Long]()\n        values.foreach(v => if\
    \ (v.isInstanceOf[Long]) result += v.toLong else if (!v.isInstanceOf[Int]) throw\
    \ new IllegalArgumentException(s\"Can't convert $v to Long.\"))\n        result.toList",
  "        if (values.length == 0) List()\n        else {\n            val (resultValues,\
    \ remainingValues) = values.span(_.isInstanceOf[Long])\n            if (remainingValues.length\
    \ == 0) resultValues\n            else {\n                val remainingValuesWithoutLongs\
    \ = remainingValues.filter(x => !x.isInstanceOf[Long])\n                val remainingValuesWithLongsAsString\
    \ = remainingValuesWithoutLongs.map(_.toString)\n                val remainingValuesWithLongsAsList\
    \ = remainingValuesWithoutLongs.map(_.toList)\n                val remainingValuesWithLongsAsMap\
    \ = remainingValuesWithoutLongs.map(_.toMap)\n                remainingValuesWithLongsAsList\
    \ ++ filterIntegers(remainingValuesWithLongsAsMap)\n            }\n        }",
  "        values match {\n            case Nil => Nil\n            case _ => values\
    \ match {\n                case x :: xs if (x.toString.isDigit) => xs.filter(_.toString.toLong\
    \ == x.toString.toLong)\n                case x :: xs => filterIntegers(xs)\n\
    \            }\n        }", "        if (values.isEmpty) List()\n        else\
    \ {\n            def collect[T >: java.lang.Number](a: Traversable[T]): List[T]\
    \ =\n                a collect { case x: T => x } : java.util.List[T]\n\n    \
    \        def collect[T >: java.lang.Number](a: Iterable[T]): List[T] =\n     \
    \           a.toList collect { case x: T => x } : java.util.List[T]\n\n      \
    \      def collect[T >: java.lang.Number](a: Array[T]): List[T] =\n          \
    \      a.toList collect { case x: T => x } : java.util.List[T]\n\n           \
    \ // Test if values are numbers\n            def isInteger(a : Any) : Boolean\
    \ = {\n                collect(a).forall(_.isInstanceOf[java.lang.Integer])\n\
    \            }\n\n            val integersOnly = values filter { a =>\n      \
    \          collect(a).forall(isInteger(_))\n            }\n            integersOnly.asInstanceOf[List[Long]]\n\
    \        }", "        values.filter(x => x match {\n            case i : Int =>\
    \ true\n            case _ => false\n        }).map(_.toLong)", "        // Initialize\
    \ mutable list of integers\n        var intList : List[Long] = Nil\n        //\
    \ Loop over given values\n        for(value <- values) {\n            // Make\
    \ sure that value is not of String type\n            if(value.asInstanceOf[String].length\
    \ > 0)\n                // If value is not of String type, then append it to mutable\
    \ list\n                intList += value.asInstanceOf[Long]\n        }\n     \
    \   // Return list of integers\n        intList", "        values.collect {\n\
    \            case x: Int => x.toLong\n            case _ => 0l\n        }", " \
    \       val integers = values.filter(value => value match {\n            case\
    \ i: Int => true\n            case _ => false\n        }).toList;\n        integers.map(_.toLong)",
  "        values match {\n            case a :: _ if a.isInstanceOf[Long] => a ::\
    \ Nil\n            case _ :: tail => filterIntegers(tail)\n        }", "     \
    \   // For any scala value, check if it is an Int and if so return the Long\n\
    \        values.filter(_ match {\n            case scala.math.Int(x) => x % 1L\
    \ == 0L\n            case _ => false\n        }).map(_.toLong)", '        values.collect
    { case x : Int if x.toLong < Long.MaxValue => x.toLong case _ => 0 }.toList',
  "        def toLong(i: Any) : Long = i match {\n            case i: Int => i.toLong\n\
    \            case i: Long => i\n            case _: String => 0L\n           \
    \ case _: Map[Long,Long] => 0L\n            case _: java.util.List[Long] => 0L\n\
    \            case _ => 0L\n        }\n        values.flatMap(toLong).filter(_.isInstanceOf[Long])",
  "        val filtered = values.filter(_ match {\n            case i if i.getClass.getSimpleName.startsWith(\"\
    Int\") => true\n            case _ => false\n        })\n        val converted\
    \ = filtered.map(_.toLong)\n        converted.toList", "        values.filter(_\
    \ match {\n            case i: Int if Integer.valueOf(i).isInstanceOf[Long] =>\n\
    \                true\n            case _ =>\n                false\n        })",
  "        values.filter(x => x match {\n            case intVal : Int => true\n \
    \           case _ => false\n        }).map(_.toLong)", '        values.filter(v
    => v.isInstanceOf[Long]).map(_.toLong)', "        val result = mutable.ListBuffer[Long]()\n\
    \        values.foreach(v => {\n            if(v == null || v.isInstanceOf[Int])\
    \ result += v.toLong\n        })\n        result.toList", "        values.foldLeft[List[Long]](List[Long]()){\n\
    \            case (acc, value) =>\n                if (value.isInstanceOf[Long])\n\
    \                    acc :+ value.asInstanceOf[Long]\n                else if\
    \ (value.isInstanceOf[Int])\n                    acc :+ value.asInstanceOf[Int]\n\
    \                else acc\n        }", "        values.filter(_.toString.trim.forall(_.toString.forall(_.toString.forall(_.toString.forall(_\
    \ == '0' || _.toString.forall(_.toString.forall(_ == '1' || _.toString.forall(_\
    \ == '2' || _.toString.forall(_ == '3' || _.toString.forall(_ == '4' || _.toString.forall(_\
    \ == '5' || _.toString.forall(_ == '6' || _.toString.forall(_ == '7' || _.toString.forall(_\
    \ == '8' || _.toString.forall(_ == '9'))))))))))", '        values.filter(_.toString.toInt
    == _).toList.map(_.toLong)', "        values.filter(_ match {\n            case\
    \ v: Long => true\n            case _ => false\n        }).map(_.toLong).toList",
  "        values.map{\n            case i : String =>\n                if(i.toInt\
    \ == i) i.toLong\n                else 0l\n            case i : Long =>\n    \
    \            i\n            case i : Float =>\n                i.toInt\n     \
    \       case i : Double =>\n                i.toInt\n            case i : List[_]\
    \ => filterIntegers(i)\n            case i : Map[Long, Long] => filterIntegers(i.values.toList)\n\
    \            case i : Option[_] => 0l\n            case _ => 0l\n        }.filter(_\
    \ != 0).filter(_ != 0l).filter(_ != 0f).filter(_ != 0d)", "        val list =\
    \ new collection.mutable.ListBuffer[Long]()\n        val iterator = values.iterator\
    \ // Iterator[Any]\n        while (iterator.hasNext) {\n            if (iterator.next().isInstanceOf[Long])\
    \ {\n                list += iterator.next().asInstanceOf[Long]\n            }\n\
    \        }\n        list.toList", "        values.filter(_.toString.startsWith(\"\
    [\")  &&  _.toString.endsWith(\"]\")).map { x =>\n            x.toString().replace(\"\
    [\", \"\").replace(\"]\", \"\").split(\",\").map(_.toLong).sum\n        }", " \
    \       val nums    = values.filter(_.toString.toInt == _).toList\n        val\
    \ longNums = nums.filter(_.toString.toLong == _).toList\n        nums.map(_.toString.toLong).toList\
    \ ::: longNums", "        def filter(value: Any) : Boolean = {\n            val\
    \ asInt : Int = value.asInstanceOf[Int]\n            asInt.isDefined && asInt\
    \ < Integer.MIN_VALUE && asInt > Integer.MAX_VALUE\n        }\n        values.filter(filter(_)).toList.map(_.toLong)",
  "        val valuesInt = values.toList.filter(_.toString.matches(\"[+-]?\\\\d+\"\
    ))\n        val valuesLong = valuesInt.map(_.toLong)\n        valuesLong", '        values.filter(_.isInstanceOf[Long]).map(_.asInstanceOf[Long]).toList',
  "        values.filter(_ match {\n            case i if i.isInstanceOf[Long] =>\
    \ true\n            case _ => false\n        }).map(_.toLong)", "        // Filter\
    \ only integers\n        values filter (_.toString match {\n            case \"\
    Infinity\" | \"-Infinity\" | \"NaN\" => false\n            case _ => true\n  \
    \      }).toList map {\n            // If value is integer, then convert it\n\
    \            x => x.toLong\n        }", "        values.filter(_.toString.forall(_.isDigit))\
    \ match {\n            case Nil => Nil\n            case x::xs => x :: filterIntegers(xs)\n\
    \        }", "        val valuesToFilter = new mutable.HashSet[Any]()\n      \
    \  valuesToFilter.add(values.head)\n        values.tail.foreach {\n          \
    \  case value : Any => valuesToFilter.add(value)\n            case value : Long\
    \ => valuesToFilter.add(value.toLong)\n            case value : Double => valuesToFilter.add(value.toInt)\n\
    \            case value : Int => valuesToFilter.add(value.toLong)\n          \
    \  case value : String => valuesToFilter.add(value.toLong)\n            case value\
    \ : Map => valuesToFilter.add(value.toLong)\n            case value : List[Long]\
    \ => valuesToFilter.add(value.toLong)\n        }\n        valuesToFilter.filter(_\
    \ > 0L)", "        values.filter(_ match {\n            case x : Int => x > 0\n\
    \            case _      => false\n        })", "        val filtered = values.filter(v\
    \ => v.isInstanceOf[Long])\n        val result = filtered.map(_.asInstanceOf[Long]).toList\n\
    \        result", '        values.collect { case x : Int if (x % 1) == 0L => x.toLong
    }.toList', "        values match {\n            case values :List[Long] => values\n\
    \            case values :List[Long] => values\n            case values :List[Int]\
    \ => values.filter(_.toLong==values)\n            case values :List[Float] =>\
    \ values.filter(_.toDouble==values)\n            case values :List[Double] =>\
    \ values.filter(_.toDouble==values)\n            case values :List[Any] => values.filter(_.toLong==values)\n\
    \            case values :List[AnyVal] => values.filter(_.toLong==values)\n  \
    \          case _ => values.filter(_.toLong==values)\n        }", "        values.flatMap\
    \ { x =>\n            if (x eq null) List() else {\n                if (x.isInstanceOf[Int])\
    \ x match { case l: Long => List(l.toLong) }\n                else if (x.isInstanceOf[Long])\
    \ List(x)\n                else Nil\n            }\n        }", "        values\
    \ filter {\n            case x if x match {\n                case  i: Int => i.toLong\n\
    \                case _ => false\n            } => true\n        }", "       \
    \ val ret = new mutable.ListBuffer[Long]()\n        // TODO: this can be done\
    \ better\n        values.foreach{\n            case i : Long => ret.append(i)\n\
    \            case i : Int => ret.append(i.toLong)\n            case x => ret.append(x.toLong)\n\
    \        }\n        ret.toList", '        values.map(_.toString.toInt).filter(_.toString.toInt
    == _).toList.flatMap(_.toLong)', "        val integers = values.filter(_.toString.length\
    \ < 10) // or some similar check\n        val toReturn = mutable.LinkedHashSet.empty[Long]\n\
    \        for(i <- integers)\n            if(i % 2 == 0)\n                toReturn\
    \ += i.toLong\n        toReturn.toList", "        values.map { a =>\n        \
    \    if (a.isInstanceOf[Number]) a.asInstanceOf[Number].toLong\n            else\
    \ a.toLong\n        }.filter(_ > 0).distinct", "        values.collect {\n   \
    \         case v: Double => v.toLong\n            case v: Float => v.toLong\n\
    \            case v: Long => v\n            case v: Int => v.toLong\n        \
    \    case v: String => v.toLong\n            case v: Map[Long, Long] => (v._1).toLong,\
    \ (v._2).toLong\n            case v: List[Long] => v.toLong\n            case\
    \ _ => 0L\n        }.filter(_ != 0)", "        values.collect {\n            case\
    \ v if v isInstanceOf[Int] => v.toLong\n        }", "        values.map { v =>\n\
    \            v.forall(_.isInstanceOf[Int])\n        }.filter { _ => true }.map\
    \ { _ => v.asInstanceOf[Long] }.toList", "        def isInt(x : Any) = x match\
    \ {\n            case x if x.isInstanceOf[Int] => true\n            case _ =>\
    \ false\n        }\n\n        values filterNot { x => !isInt(x) } map { x => x.toLong\
    \ }.toList", "        val filteredList = mutable.ListBuffer[Long]()\n        for\
    \ (value <- values) {\n            if (value match {\n                case v:\
    \ Integer => filteredList += v.toLong\n                case _ => filteredList\
    \ += 0\n            }\n        }\n        filteredList.toList", '        values.flatMap(_.toString.toLong).filter(_.toString.isDigit)',
  '      values.filter(_.toString.forall(_.matches("[-+]?\\d+")))', "        val (filteredValues\
    \ : List[Long]) =  values.collect {\n            case v: Int if v < 0L || v >\
    \ 0L => v.toLong\n            case v => throw new IllegalArgumentException(s\"\
    Found $v with type: ${v.getClass}\")\n        }\n        filteredValues", "  \
    \      values.map(x => {\n            x match {\n                case Int => x.toLong\n\
    \                case Long => x.toLong\n                case _ =>\n          \
    \  }\n        })", "        var res = List[Long]()\n        values.foreach{\n\
    \            case x: Int => res += x.toLong\n            case _: Float => ()\n\
    \            case _: Long => ()\n            case x: String => ()\n          \
    \  case x => res += x.toLong\n        }\n        res", '        values.collect
    { case x: String if (x.toString.trim.isDigit) => x.toLong }.distinct', '        values.filter(_.toString.isInstanceOf[Long]).map(_.toString.asInstanceOf[Long])',
  '        values.filter(_ match { case i: Int => true; case _ => false })', "   \
    \     def filterIntsImpl(value : Any) = {\n            if (value isInstanceOf[Int])\
    \ value.toLong else null\n        }\n        values.filter(filterIntsImpl)", '        values.filter(_.toString.contains("_$")
    && !_.toString.contains("$") && !_.toString.contains("List")).map(_.toString.replace("_$",
    "").replaceFirst("^List", ""))', "        values.toList flatMap { \n         \
    \   case x: List[Any] =>\n                x.toList flatMap { y: Any =>\n     \
    \               if(y.isInstanceOf[Int]) List(y.asInstanceOf[Int]) else List(()\
    \ => y)\n                }\n            case _: Any => List()\n        }.toList",
  "        val filteredValues = values.filter(_ match {\n            case n : Int\
    \ =>\n                !(null | n.isInstanceOf[Double] || n.isInstanceOf[Long])\n\
    \            case _ =>\n                false\n        })\n        val numbers\
    \ = filteredValues.toList.map(_ match {\n            case n : Int =>\n       \
    \         n.toLong\n            case n : Long =>\n                n\n        \
    \    case _ =>\n                0L\n        })\n        return numbers.toList.distinct",
  "        val valuesMap = values.toMap\n        if (valuesMap.isEmpty) List()\n \
    \       else valuesMap.filter{case (_,v) => v.toInt == v.asInstanceOf[Long]}.map{case\
    \ (k,v) => v.toLong}.distinct", "        var result : List[Long] = Nil\n     \
    \   for (x <- values) {\n            if (x match {\n                case i: Int\
    \ => result += (i.toLong)\n                case _ => result += (0l)\n        \
    \    })\n        }\n        result", "        values match {\n            case\
    \ Nil  => Nil\n            case x :: Nil => x.toLong\n            case x :: xs\
    \ =>\n                val asList = x.asInstanceOf[List[Long]]\n              \
    \  asList filter (x => x.toInt == x.toInt)\n        }", '        values.filter(value
    => value.isInstanceOf[Long]).map(value.asInstanceOf[Long])', "        val numbers\
    \ = values.map(_.toLong).filter(_.isInstanceOf[Long])\n        numbers.toList",
  '        values.filter(_.toString.toInt == _).toList.map(_.toLong)', '        values.filter(v
    => v.toString.toIntOption.isDefined)', '        values.filter(_ == 1).map(_.toLong)',
  '        values.filter(x=>x.isInstanceOf[Long])', "        val filtered = mutable.ListBuffer.empty[Long]\n\
    \        for (value <- values) {\n            if (value match {\n            \
    \    case i: Int => filtered += i.toLong\n                case l : List[Long]\
    \ => filtered += l.head\n                case _ => filtered\n            })\n\
    \        }\n        filtered.toList", '        values.map(_.toLong).filter(_.isInstanceOf[Long]).toList',
  "        val mutableList = mutable.MutableList[Long]()\n        values.foreach(x\
    \ => x match {\n            case _ : String => mutableList += x.toLong\n     \
    \       case _ : Number => mutableList += x.toLong\n            case _ : Map[_,_]\
    \ => mutableList += x._2.toLong\n            case _ : List[_] => mutableList +=\
    \ x.toLong\n            case null => mutableList += null.toLong\n            case\
    \ _ => ()\n        })\n        mutableList.toList", '        values.filter(v =>
    v.isInstanceOf[Long])', "        values flatMap { x =>\n            x match {\n\
    \                case x: String => x.toLong\n                case x: Int => x.toLong\n\
    \                case x: Long => x\n                case x: Double => x.toLong\n\
    \                case _ => sys.error(\"Unsupported type!\")\n            }\n \
    \       }.toList", "        val result = mutable.ArrayBuffer[Long]()\n       \
    \ for (value <- values) {\n            if (value match {\n                case\
    \ x:Int => result += x.toLong\n                case _ => \n            }\n   \
    \     }\n        result.toList", "        val r = values.filter(_.isInstanceOf[Long])\n\
    \        if (values.size != r.size) throw new Exception(\"filterIntegers :: Non\
    \ list type elements detected\")\n        r.toList", "        val filteredValues:\
    \ List[Long] = values.filter(_.toString.matches(\"-?\\\\d+\")).map(_.toLong)\n\
    \        filteredValues.asInstanceOf[List[Long]]", '        values.map { case
    v: Any => v.asInstanceOf[Long] }.toList']
stop_tokens:
- "\n    }\n"
