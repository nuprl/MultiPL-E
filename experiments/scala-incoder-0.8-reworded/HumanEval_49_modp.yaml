name: HumanEval_49_modp
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n\
  \    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l),\
  \ (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l),\
  \ (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
  \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
  \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
  \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
  \ == (3l));\n    }\n\n}\n"
completions: ["        if(n <= p) return n\n        var result : Long = 0\n      \
    \  var divisor : Long = p\n        while(divisor > 1l) {\n            result +=\
    \ (n >>> 1) % divisor\n            divisor >>= 1\n        }\n        result",
  "        if (p == 0 || n == 0) 0\n        else n ^ ((n&p)-1)", "        var result\
    \ = n % p\n        if (result < 0)\n            result += p\n        result",
  "        val x = n >>> 0\n        val y = p >>> 0\n        while (x >= y) {\n  \
    \          x = (x & y) | (~x & -y)\n        }\n        if (x != 0L)\n        \
    \    1L << x\n        else\n            -1L", "        val a = n % p\n       \
    \ if (a < p) p * 2 - a + 1 else a", "        def mod2(n: Long, d: Long) : Long\
    \ = {\n            val q: Long = (n % d).toInt\n            n / d\n        }\n\
    \n        // Calculate d's square root modulo p\n        // by dividing by (p\
    \ - 1) until\n        // we get an integral quotient.\n        val d: Long = p\
    \ - 1\n        var d: Long = 0\n        while ((n % d) != 0) {\n            d\
    \ = mod2(n, d)\n        }\n\n        // Now d is between 0 and p-1\n        //\
    \ We can get the square root of the number by using the modulo operator\n    \
    \    var sqroot: Long = n\n        while (!(n % d)) {\n            n /= d\n  \
    \          sqroot = n\n        }\n\n        // Return the square root modulo p\
    \ as a long\n        sqroot", "        var modP = BigInteger.ZERO\n        while(modP.compareTo(p)\
    \ >= 0) {\n            modP = modP.multiply(p)\n        }\n        return modP.mod(p)",
  "        val s = 1l\n        val result = 1l\n        while (n > 1l) {\n       \
    \     val temp = n % p\n            n -= temp\n            result += temp\n  \
    \      }\n        result", "        var res = 1\n        while (res <= n) {\n\
    \            res = (res * res) % p\n        }\n        if (res == n) {\n     \
    \       res = 1\n        }\n        return res", "        if (n == 0L)\n     \
    \       return 0L\n        val res = n % p\n        if (res == 0L)\n         \
    \   return n\n        res + (p - res)", "        val m = 2l\n        val res =\
    \ 1l\n        while (m <= n) res = (res*m) % p\n        res % p", "        var\
    \ result : Long = 1\n        for (i <- 2 to math.pow(2, math.floor(math.log(n,\
    \ 2))))\n        {\n            result *= 2\n            result %= p\n       \
    \ }\n        result", "        var m : Long = 0\n        while (n >= p) m = p;\
    \ m := m + (n % p)\n        m", "        var res = n & (p - 1L);\n        while\
    \ (n > 0L && res < p) { res = res + 1L; n /= 2L; }\n        n", "        // 2^n\
    \ modulo p\n        var result : Long = scala.math.pow(2, n)\n        val mask\
    \ : Long = p^result\n        result = result*mask & p\n        result", "    \
    \    if (n == 0) {\n            return 1l\n        } else if (n <= p) {\n    \
    \        return 1l\n        } else if (n < p) {\n            return 1l + (n -\
    \ p)\n        }\n        val a = n.toInt\n        val r = a % p\n        r + (if\
    \ (a == p) 0 else p - r)", "        var bits = n.toInt\n        var rem = n %\
    \ p\n        while (bits and rem != 0) {\n            bits -= 1;\n           \
    \ rem += p\n        }\n        bits += rem\n        if (bits > 0)\n          \
    \  bits += p\n        bits", "        var result : Long = 1\n        while(n >\
    \ result) {\n            result += (n % result)\n            n /= result\n   \
    \     }\n        result", "        if( n.toInt < p.toInt) 1l + (n % p).toInt\n\
    \        else n % p", "        def mod(n : Long, p : Long) : Long = {\n      \
    \      val m = math.abs(n) % p\n            if (m == 0) n else m\n        }\n\
    \        mod(n, p)", "      var result = n\n      while(result > p) {\n      \
    \  result = result % p\n      }\n      result", "        if (n < 0) throw new\
    \ IllegalArgumentException\n        if (p < 1) throw new IllegalArgumentException\n\
    \        if (p.compareTo(0l) < 0) throw new IllegalArgumentException\n       \
    \ var result = 1l\n        while (n > 1) {\n            if (p.compareTo(n) < 0)\
    \ {\n                result = result * p\n                if (n != 0l)\n     \
    \               result %= n\n            }\n            n -= 1\n            p\
    \ = p / 2l\n        }\n        if (n != 0l)\n            result %= n\n       \
    \ result", '        if (n == 0) 1 else if (n % p == 0) n % p else n % p + modp(n-n,
    p)', "        require(n > 0 && p > 0, \"modp requires n and p > 0\")\n       \
    \ var n2 = n % p\n        if (n2 < 0) { n2 = p + n2 }\n        n / p2", '        if
    (n % p == 0) n else n - (n % p)', "        val s = modPow(2, n, p)\n        val\
    \ t = s % p\n        if (t == 0)\n            s\n        else\n            s",
  "        val x = n % p;\n        if(x == 0) 1l else x", "        if (n == 0L)\n\
    \            return n\n        else\n            if (p == 0)\n               \
    \ return 1L\n            else\n                if (p < n)\n                  \
    \  modp(n - 1, p-1)\n                else if (p > n)\n                    modp(n,\
    \ p % n)\n                else\n                    modp(n + (p - (n % p)) % n,\
    \ p)", "        val q : Long = BigInteger(n)\n        val r : Long = BigInteger(p)\n\
    \        // TODO: implement modp with BigInteger.\n        val qBig = BigInt(q)\n\
    \        val rBig = BigInt(r)\n        BigInt(qBig modPow BigInt(rBig))", "  \
    \      def pow(i : Long, d : Long) : Long = {\n            if (i >= d) {\n   \
    \             return 1l\n            } else if (i == d) {\n                return\
    \ 1l\n            } else {\n                return i * pow(i , d-1)\n        \
    \    }\n        }\n        pow(n, p.toLong).toLong % p", "        val ans = n\n\
    \        while (ans > p) {\n            ans = ans % p\n        }\n        ans",
  "        val n = n.toInt\n        val p = p.toInt\n        val result = n.toLong\n\
    \        while (n > 0) {\n            result %= p\n            n -= 1\n      \
    \  }\n        result", "        val pow = pow(n, p)\n        val mod = pow % p\n\
    \        if (mod < 0) mod+p\n        else mod", "        val r = n % p\n     \
    \   if (r == 0)\n            r\n        else\n            modp(n, p - r)", " \
    \       if(n == 0)\n            return 1l\n        if(n == p)\n            return\
    \ n\n        val x = scala.math.pow(n, (-1l))\n        val y = scala.math.mod(x,\
    \ p)\n        if(x == 0)\n            return y\n        val z = scala.math.mod(y,\
    \ p)\n        if(z == 0)\n            return y\n        if(z < p)\n          \
    \  return modp(z, p)\n        modp(y, p)", "        // Convert n and p to BigDecimal\n\
    \        val bn = BigDecimal(n);\n        val bp = BigDecimal(p);\n\n        //\
    \ Multiply by the mod power of bp and subtract from b.\n        val b = bn.multiply(BigDecimal(\"\
    %\").multiply(bp)).subtract(BigDecimal(\"0\"));\n\n        // Truncate to Long\n\
    \        val ln = b.intValue().toLong;\n\n        // Return Long\n        return\
    \ ln", "        val d = n - p;\n        if (d < 0l)\n            throw new ArithmeticException(\"\
    modp failed: negative operands \" + n + \" and \" + p);\n        if (d == 0l)\n\
    \            return n;\n        val m = (1l << d) - 1l;\n        if (m < p) //\
    \ not in the domain\n            throw new ArithmeticException(\"modp failed:\
    \ no such exponent \" + d + \" modulo \" + p);\n        return m;", "        val\
    \ z = n % p\n        if (z == 0) {\n            return n\n        } else {\n \
    \           return z\n        }", "        var result : Long = 1\n        while\
    \ (n > p) {\n            if (n >= p) {\n                result += 1\n        \
    \        n -= p\n            }\n        }\n        result", "        val res =\
    \ 1L\n        res *= n\n        res %= p\n        res", "        val t = math.pow(n.toLong,\
    \ p.toLong)\n        t.mod(p).toLong", "        var r = 1l\n        for(i <- 1l\
    \ until n.toInt) {\n            r = (r * p) % n\n        }\n        if(r > n)\n\
    \            (n-r)\n        else\n            r", "        val d = n.toDouble\n\
    \        val e = p.toDouble\n        val q = d.quot(e)\n        return q * (p\
    \ / q)", "        val m = math.min(p.abs,n.abs)\n        val result = n % m\n\
    \        if (result < 0) -result else result", "        var r = n % p\n      \
    \  while (r != 0) {\n            r = (r + p) % p\n        }\n        r", '        //
    TODO Implement this function.', "        if((n & (n-1)) == 0) (n + p) % p\n  \
    \      else modp(n/2, p) % (p*2)", "        val pow = math.pow(n, 2)\n       \
    \ math.modf(pow)", '        if (n == 0) 1l else (2l*((n % p) + p - 1) + (n % p))',
  '        return ((n.toLong + p.toLong) % p.toLong).toLong', "        var result\
    \ = 1\n        for(i <- 1 until n) {\n            result *= p\n            result\
    \ %= p\n        }\n        result", "        def modpMod2(n : Long, p : Long)\
    \ : Long = {\n            // The magic number in modular arithmetic: x^n mod p\n\
    \            val q = ((p * n) % p).toLong\n            n - (q * (q % p))\n   \
    \     }\n\n        if (n == 0l) return 1l\n        if (p == 0l) return 0l\n\n\
    \        // The base case: the exponent must be less than or equal to the\n  \
    \      // modulus \"p\".\n        if (n < p)\n            modpMod2(n,p)\n\n  \
    \      // The recursive case: we must take \"p\" digits out of \"n\" digits.\n\
    \        val rem = modpMod2(n,p)\n        if ((rem == 0l) && ((rem % p) == 0l))\
    \ {\n            // We must not take 0 digits out of \"n\" digits.\n         \
    \   rem + 1\n        } else {\n            // We must take \"p\" digits out of\
    \ \"n\" digits.\n            (rem) % p\n        }", "        def mod2(a : Long)\
    \ : Long = (a%p)*(a%p)\n        def mod3a(a1 : Long) : Long = (101l % a1)\n  \
    \      def mod3(a1 : Long) : Long = mod3a(a1) + mod2(a1)\n        def mod4(a1\
    \ : Long) : Long = mod3(a1) ^ mod2(a1)\n        val l = ((n%p)*(n%p)) % p\n  \
    \      if (l == 0)\n            1\n        else\n            mod4(l) * mod3(n)",
  "        val m = BigDecimal(n).mod(BigDecimal(p))\n        val s = m.toDouble\n\
    \        val e = 1l\n        // If s is an integer and e is even,\n        //\
    \ then n is in the form p * 2^e * 2^(n/e)\n        if ((s % e == 0) && BigInt(s)\
    \ % 2 == 0) else BigInt(s * e)", "        val p = p.toInt\n        val n = n.toInt\n\
    \        val r : Long = Math.pow(2l, n % p)\n        r", "        val nBits =\
    \ n.bitLength\n        val pBits = p.bitLength\n        var rem = 0L\n       \
    \ var i = 0\n        while (i < nBits || rem < pBits) {\n            val a = if\
    \ (i < nBits) n else (rem & p)\n            val b = if (rem < pBits) rem.pow(i)\
    \ else (rem & p).pow(i)\n            val res = a * b\n            rem += res\n\
    \            i += 1\n        }\n        rem", '        if (n >= p) n % p else
    n % p + p', "        (p mod n) match {\n            case 0 => n\n            case\
    \ 1 => p\n            case _ => (p mod n) match {\n                case 0 => n\n\
    \                case 1 => p\n                case _ => p % n\n            }\n\
    \        }", "        val result = n\n        var i = 1\n        while (i <= p)\
    \ {\n            if (n % i == 0) {\n                result = result - n%i\n  \
    \          }\n            i += 1\n        }\n        result", "        val ret\
    \ = scala.math.BigInt(n).mod(p)\n        if(ret == 0)\n            ret.longValue()\n\
    \        else\n            ret.longValue()", "        val n = n\n        val p\
    \ = p\n\n        val x = BigInteger.valueOf(n)\n        val y = BigInteger.valueOf(p)\n\
    \n        val q = x.mod(y)\n        if (q.signum < 0)\n            q.add(BigInteger.ONE)\n\
    \        q", "        val x = n.toDouble\n        val y = p.toDouble\n       \
    \ val r = scala.math.mod(x,y)\n        r.toLong", "        val a = n.toInt\n \
    \       val b = p.toInt\n        if (a < 0 || b < 0) 0\n        else b * a * ModPow(b,\
    \ a)", "      val (x, y) =  n.divmod(p)\n      y + (x % p) match {\n        case\
    \ 0    => 0\n        case n    => n\n      }", "        if (n == 0)\n        \
    \    return 1\n        if (n == 1)\n            return p\n        if (n < p)\n\
    \            return modp(n - 1, p) % p\n        return (n % p + modp((n - 1) %\
    \ p, p)) % p", "      val x = 2\n      val y = p // p is odd, so (p - 1) must\
    \ be even and will overflow\n      val z = (n - 1) * (x + y) //(x * y) mod p\n\
    \      // z mod p is still > p but is closer than x - y\n      // So we just have\
    \ to add one more.\n      val m = z + p + 1\n      if (m < n)\n        m\n   \
    \   else\n        x", "        val m = math.pow(p.toLong, n)\n        if (m %\
    \ p != 0) (m % p).toLong else m", "        val d = n - p\n        if (d < 0L)\
    \ d + (p - 1L)\n        else d", "        val pmod = p % (p % p % p) // prime\
    \ modulo p\n        if(n == 0) 1l else n & (pmod - 1)", "        val n = n % p\n\
    \        if (n == 0) 1\n        else 2 * n % p", "        var result = n\n   \
    \     while (result > 0) {\n            result = result % p\n        }\n     \
    \   result", "        val res = n.toLong.pow(p).toLong\n        if(n.toLong >\
    \ 0) res = (p.toLong * res) % p\n        res", "        val l = n.toInt\n    \
    \    if(l < 0)\n            -l\n        else\n            n - (l % (p.toInt))",
  "      val r = n % (p - 1)\n      if (r == 0) {\n        r\n      } else {\n   \
    \     modp(r, p)\n      }", "        val m = math.max(n.toInt, p.toInt)\n    \
    \    val r = n % m\n        if (m == 0)\n            r\n        else\n       \
    \     modp(r, m)", "        if( n <= 0 || p == 0 ) return 0;\n        var remainder\
    \ = 0;\n        var quotient = 0;\n        val result = ((n << 32) >> 32) % p;\n\
    \        val mask = (1 << 32) - 1;\n        for(i <- 0 until 32) {\n         \
    \   quotient = ((result & mask) >> i) % p;\n            if( quotient != 0 ) {\n\
    \                remainder = (remainder << i) + quotient;\n            }\n   \
    \         mask = mask - 1;\n        }\n        if( remainder != 0 ) {\n      \
    \      return remainder;\n        } else {\n            return result;\n     \
    \   }", "        val res = ((n & p) >>> 1) + ((n & p) >>> 1) >>> 1\n        if\
    \ (res < p)\n            (res << 1) + 1\n        else\n            res", "   \
    \     var x : Long = (1l*p).scalb(n).toInt\n        if (x <= 0) x = 0\n      \
    \  (x-1l).scalb(n).toInt", "        val modP = scala.math.pow(2, n)\n        val\
    \ divModP = scala.math.divMod(modP, p)\n        divModP._1", "        val bits\
    \ = n.toInt\n        val n = bits % p\n        if (n == 0) 1L else 2L << n", " \
    \       val q = n/p\n        if(p%q > 0) q else q + p", "        var r = n % p\n\
    \        if(r > 0) {\n            r = p + r\n        }\n        r %= p\n     \
    \   return r", "        val q = n / p\n        if (q >= p) {\n            q -\
    \ p\n        } else {\n            q * p\n        }", "        require(n >= 0,\
    \ \"Negative arguments\")\n        require(p >= 0, \"Negative modulus\")\n   \
    \     if (n % p == 0) {\n            return n\n        } else {\n            val\
    \ r : Long = modp(p & (p - 1), p) %  p\n            val k : Long = n % p\n   \
    \         if (r == 0) {\n                return k\n            } else {\n    \
    \            return k + r\n            }\n        }", "        if (n.toInt > p.toInt)\n\
    \            modp(n.toInt, p)\n        else\n            ((n - (n * p.toInt)).abs).mod",
  "        val m = n % (p - 1l)\n        if (m == 0l)\n            m\n        else\n\
    \            m", "        val m = (n^2)%p\n        if (m==0) 1l else m", "   \
    \     if (n == 0) 1\n        else n % p", "      def div(x : Long, y : Long) :\
    \ Long = Math.max(x / y, y / x)\n      val n = ((n - p) / p).toInt\n      if (n\
    \ == 0) 1l else div((1l), n).abs.toLong", "        if (n == 0l) {\n          \
    \  return 0l\n        } else if (n == 1l) {\n            return p\n        } else\
    \ {\n            var res : Long = 0l\n            var m : Long = n & p.toLong\n\
    \            while (m != 0l) {\n                res = (res << 1) + (m & 1l)\n\
    \                m >>>= 1l\n            }\n            res\n        }", "    \
    \    val z : Long = n % p\n        val q = p * p - n\n        if (q < 0) (-q)\
    \ + p\n        else q", "        val rem = n % p\n        if (rem == 0l)\n   \
    \         n\n        else\n            n - (rem + p) % p", "        if (n == 0)\
    \ {\n            return 0\n        }\n        val m = 1l\n        val q = p\n\
    \        val r = n % p\n        val x = n % q\n        val xq = x * q\n      \
    \  val y = (n-1) * r\n        val yq = y * q\n        val z = ((n-1) * x) % q\n\
    \        val zz = z * q\n        var i = 1l\n        while (xq < zz) {\n     \
    \       m = m ^ m\n            i = i + 1l\n            xq = xq + (xq * i)\n  \
    \          yq = yq + y\n            zz = zz + (zz * i)\n        }\n        (m*q)\
    \ % p", '        (1l << (n %  p)) % p', "        val d = n % p\n        if (d\
    \ < 0L) d + p else d", "      var res = 0\n      var power = 2L\n      while(power\
    \ <= n) {\n        res = (res + power) % p\n        power = power * 2L\n     \
    \ }\n      res", "        var result : Long = modPow(n.toInt,p)\n        if(result\
    \ == 0)\n            result = (n.toLong.toInt).toLong % p.toLong\n        result",
  "        val mod = if (n >= p) p else p\n        val rem = n - (mod * mod)\n   \
    \     (mod * mod)", "        // TODO: implement it (return 0)\n        /*\n  \
    \      val r = scala.util.Random(123)\n        if (n <= 0) {\n            return\
    \ 1\n        } else if (n % 2 == 0) {\n            if (n % p == 0) {\n       \
    \         return n // no remainder\n            } else {\n                return\
    \ n - 1\n            }\n        } else {\n            if (n % p == 0) {\n    \
    \            return n // no remainder\n            } else {\n                return\
    \ r.getInt() % p\n            }\n        }\n        */\n        return 0", " \
    \       val m = p.asInstanceOf[BigInteger]\n        val x = n.asInstanceOf[BigInteger]\n\
    \        val y = x.modPow(x, m).asInstanceOf[BigInteger]\n        val z = y.modPow(y,\
    \ m)\n        if (z.equals(BigInteger.valueOf(1))) z\n        else z", "     \
    \   val b = 2l\n        val r = p.toLong\n        val m = n.toLong\n        (m\
    \ * b) % (r * r) match {\n            case 0 => 0l\n            case a => (2l\
    \ * b) % r\n            case _ => (n * r) % r\n        }", "        var result\
    \ = 1\n        while (n > 0) {\n            result *= p\n            result %=\
    \ p\n            n -= 1\n        }\n        result", "        val n = n.toInt\n\
    \        val p = p.toInt\n        n & (-p) == 0\n            ? ((n & (-p)) | (n\
    \ << (32 - (p * 32))))\n            : ((n & (-p)) | (n << (32 - (p * 32))))",
  "        def pow2(n : Long) : Long = {\n            if(n > p) {\n              \
    \  n * n\n            } else {\n                n * (n * 2)\n            }\n \
    \       }\n        pow2(math.pow(n, 1 / 2.0))", "        val mod = n % p\n   \
    \     mod", "        var result = n\n        var rem = n\n        while(n > p)\
    \ {\n            rem = (rem % p) + p\n            n -= rem\n            result\
    \ += 1\n        }\n        result", "        // Use scala.math.BigDecimal instead\
    \ of scala.math.BigInt if you want to\n        // have exact results (no rounding).\n\
    \        scala.math.BigDecimal(n).mod(scala.math.BigDecimal(p))", "        n mod\
    \ p match {\n            case 0 => n\n            case p => modp(n + p, p)\n \
    \       }", "        val z = n % p\n        val a = p / z\n        val c = z *\
    \ a - n\n        if (c < p) c else p // overflow", "        val a = scala.math.modPow(2,\
    \ n, p)\n        if (a >= p) a - (p << 1)\n        else a", "        val result\
    \ = BigInt(n) << (p % BigInt(2l))\n        if (result < 0) (result + BigInt(2l))\n\
    \        else result", "        var q = p\n        while (true) {\n          \
    \  q = q * 2 // unroll loop\n            q %= p\n            if (n == q)\n   \
    \             return q\n        }", "        val d = (p.toLong ^ (p.toLong >>>\
    \ 32)) % p.toLong\n        if ((n % p.toLong) == 0) {\n            d % p.toLong\n\
    \        } else {\n            d + n % p.toLong\n        }", "        val m =\
    \ n.toInt % p.toInt\n        if (m == 0) m else p + (p - m)", "        val res\
    \ = n % p\n        val div = if (res == 0) p else p\n        (n / div) % p", " \
    \       if (n == 0l) 1l\n        else n % p", "        val q = p / (n / p)\n \
    \       p % q", "      var r = 1\n      var q = p / 2\n      var m = 0\n     \
    \ while (q != 0) {\n        if (n % q == 0) {\n          m = m+1\n          n\
    \ = q\n        }\n        q = (q / 2)\n      }\n      r += (n % p) % p\n     \
    \ r", "      var p = p\n      var mod = 0\n      while (n != 0) {\n        mod\
    \ = mod * (n % p)\n        n /= p\n        p = p * p\n      }\n      if (p ==\
    \ 1) 0\n      else mod", "        val res = scala.math.mod(n, p)\n        if (res\
    \ < 0) res + p else res", "      if(n < p)\n        modp(2 * n + 1, p)\n     \
    \ else\n        n & (p-1)", "        val d = modInv(p, 2)\n        val q = n /\
    \ d\n        n % d == 0 ? q : modp(q, p)", "        var remainder = n\n      \
    \  while(remainder > 0) {\n            val quotient = remainder / p\n        \
    \    remainder = remainder % p\n            n = quotient\n        }\n        n",
  "        // The multiplication by 2 is very cheap, so we compute it only once.\n\
    \        // We also check that the value is in range.\n        val m = (2 * n)\
    \ % (p + 1)\n        if (m < 0 || m > p + 1) {\n            throw new ArithmeticException(\"\
    modp called with negative value\")\n        }\n        m", "        val r = n\
    \ % p\n        if (r > 0) (r + p) else r", "        val a = n % p\n        if(a\
    \ == 0) a else p", "        var mod = n\n        while (mod>p)\n            mod\
    \ = mod & (-mod)\n        mod", "        val m = 2l\n        val r = n % m\n \
    \       if (r < 0l) m + r else r", '        (n << 1) | (n >>> 63) % (p << 1)',
  '        (n >>> 0) % p', "        val r = n.toString match {\n            case \"\
    0\" => 0\n            case \"1\" => 1\n            case \"2\" => 2\n         \
    \   case \"3\" => 3\n            case \"4\" => 4\n            case \"5\" => 5\n\
    \            case \"6\" => 6\n            case \"7\" => 7\n            case \"\
    8\" => 8\n            case \"9\" => 9\n            case x =>\n               \
    \ throw new Exception(s\"modp: invalid number $n\")\n        }\n        p.pow(r)",
  "        if (n < 0) {\n            n % p\n        } else {\n            n\n    \
    \    }", "        val r = n % p\n        if (r < 0) -r + p else r", '        if
    (n == 0) 1l else n >>> 1', "        val n2 = n\n        val m = (n2 & 0x55555555)\
    \ << 1\n        val m1 = ((n2 & 0xAAAAAAA) >> 1) | ((n2 & 0x55555555) << 1)\n\
    \        val r = ((n2 & 0xCCCCCCCC) >> 2) | ((n2 & 0x33333333) << 2)\n       \
    \ val r1 = ((n2 & 0xF0F0F0F0) >> 4) | ((n2 & 0x0F0F0F0F) << 4)\n        val r2\
    \ = ((n2 & 0xF3F3F3F3) >> 6) | ((n2 & 0x33333333) << 6)\n        val d = (n2 &\
    \ 0xFF00FFFF) >> 8\n        val u = ((n2 & 0xFFFF0000) >> 16) | ((n2 & 0x0000FFFF)\
    \ << 16)\n        val a = ((n2 & 0xF8000000) >> 20) | ((n2 & 0x3F000000) << 20)\n\
    \        val p1 = (n2 & 0xFFFF0000) | ((n2 & 0x0000FFFF) << 16)\n        val c\
    \ = ((n2 & 0xC0000000) >> 21) | ((n2 & 0x0000000F) << 21)\n        var b = ((n2\
    \ & 0xFF00FF00) >> 8)\n        var b = ((n2 & 0x00FF00FF) << 8) | ((n2 & 0xFF00FF00)\
    \ << 8)\n        b = ((b & 0x00FF00FF) | (b >> 8))\n        var n = n2\n     \
    \   var c = 0\n        var d = n - p\n        while ((d & 0x80000000) != 0) d\
    \ = d << 1\n        b = ((d & 0xFF00FF00) >> 8) | ((d & 0x00FF00FF) << 8)\n  \
    \      b = ((b & 0x00FF00FF) | (b >> 8))\n        n = ((n - b) | a)\n        n\
    \ = ((n & 0x00FFFF00) | (n >> 16))\n        n = (n1 ^ d)\n        n = (m ^ n ^\
    \ p1)\n        n = ((n & 0x55555555) << 1) | ((n & 0xAAAAAAA) >> 1) | ((n & 0x55555555)\
    \ << 1)\n        n = ((n & 0xCCCCCCCC) >> 2) | ((n & 0x33333333) << 2) | ((n &\
    \ 0xCCCCCCCC) >> 2) | ((n & 0x33333333) << 2)\n        n = ((n & 0x0F0F0F0F) <<\
    \ 4) | ((n & 0xF0F0F0F0) >> 4) | ((n & 0x0F0F0F0F) << 4) | ((n & 0xF0F0F0F0) >>\
    \ 4)\n        n = ((n & 0xF3F3F3F3) << 6) | ((n & 0xF3F3F3F3) >> 6) | ((n & 0xF3F3F3F3)\
    \ << 6) | ((n & 0xF3F3F3F3) >> 6)\n        n = ((n & 0xFF00FFFF) << 8) | ((n &\
    \ 0xFFFF", "        require(n > 0 && p > 0)\n        if (n <= p) {\n         \
    \   return n\n        }\n        if (n >= (p.toLong - n)) {\n            return\
    \ p.toLong\n        }\n        val m = p.toLong - n\n        (p - (n & m)).toLong",
  "        var ret = n\n        var p2 = 1l\n        while (n > p2) {\n          \
    \  ret %= p2\n            if (ret < p)\n                ret += 1\n           \
    \ p2 *= 2\n        }\n        return ret", "        val r = n % p\n        if(p\
    \ > n)\n            modp(r, p)\n        else\n            r", "        if (n ==\
    \ 0 || p == 0)\n            0\n        else if (n % p == 0)\n            n\n \
    \       else\n            modp(n / p, p)", "        val a = n % p\n        val\
    \ b = a % p\n        if(a == 0 || b == 0) 1\n        else if(a == p) n\n     \
    \   else ((n % p) + p) % p", "        // Simpler approach: use binary division\
    \ instead of powers of 2 modulo.\n        // Use bitmasks for simplicity.\n  \
    \      val b1 = n & 0xff\n        val b2 = ((n>>8)&0xff) & 0xff\n        val b3\
    \ = ((n>>16)&0xff) & 0xff\n        val b4 = ((n>>24)&0xff) & 0xff\n\n        val\
    \ p0 = p & 0xff\n        val p1 = ((p>>8)&0xff) & 0xff\n        val p2 = ((p>>16)&0xff)\
    \ & 0xff\n        val p3 = ((p>>24)&0xff) & 0xff\n\n        val r1 = b1 | (((b1&b2)<<1)\
    \ | (((b1&b3)<<2) | ((b1&b4)<<3)) | (((b2&b3)<<1) | (((b2&p0)<<2) | ((b2&p1)<<3))\
    \ | ((b3&p1)<<1) | ((b3&p2)<<2) | ((b3&p3)<<3)) & 0xff\n        val r2 = ((b1&p0)\
    \ | (b1&p1) | (b1&p2) | (b1&p3)) & 0xff\n        val r3 = ((b2&p0) | (b2&p1) |\
    \ (b2&p2) | (b2&p3)) & 0xff\n        val r4 = ((b3&p0) | (b3&p1) | (b3&p2) | (b3&p3))\
    \ & 0xff\n\n        r1 | (r2<<8) | (r3<<16) | (r4<<24) & 0xff", '        n ==
    0 ? n : modp(n / 2, p) + (n % 2 * p) % p', "        val d = (p - 1) << (32 - 32\
    \ - n)\n        ((n & d) + d) % p", "        val m = 1L\n        val r = scala.math.pow(m,\
    \ n)\n        r.modPow(p, m)", '        (2l) ^ (n) % (p)', "        val nbin =\
    \ Binary.fromLong(n).toBinaryString\n        val pbin = Binary.fromLong(p).toBinaryString\n\
    \        val mod = nbin.substring(nbin.length - 1) == '1' ^ pbin.substring(pbin.length\
    \ - 1) == '1'\n        (mod ? 1l : n) % (1l * p)", "      val mod = (n ^ (n *\
    \ p)) & ((-1l) * p + 1)\n      if (mod < p) mod else n", "        val r = n.mod(p)\n\
    \        if(!r != 0) r else p", "        val q = 2l / p\n        ((n % q) * (p\
    \ % q)) % q", "        var result = n\n        while (result != 0) {\n       \
    \     result := result % p\n        }\n        result", "        val ans = n.xor(p).and(0xFFFFFFFF).shiftRightUnsigned(32);\n\
    \        if (ans.lessThan(p)) ans else 0l", '        (n << 1) ^ (n & p - 1l)',
  "        val m = p.toLong\n        val r = n.toLong\n        val t = r % m;\n  \
    \      if(t == 0L) 1L else t % m;", "        val a = n >>> 0\n        val b =\
    \ p >>> 0\n        var r = a\n        var q = 0\n        // Start from right to\
    \ left because we will need to do \n        // modulo 2^n for every value we subtract\
    \ from n.\n        // We will also add 1 to the result of modulo when we \n  \
    \      // subtract from n. \n        while(n != 0) {\n            // We subtract\
    \ 2^n from n. The result is 0 when \n            // subtraction result is 0. \n\
    \            val r = (n % 2L) - (b << 1) - (a << 2) - (a << 3)\n            //\
    \ If r has a lower bit than the value we are subtracting\n            // then\
    \ we have to add 2^q to r. \n            if(r < 0) r = r + 2L << q\n         \
    \   q = q + 1\n            a = a + (r << 1)\n            // Remember to do modulo\
    \ 2^n for every value we subtract from\n            // n.\n            n = n >>>\
    \ 1\n        }\n        // Return a.\n        a", "        assert(n % p == 0,\
    \ s\"n must be multiple of p $n %  p $p\")\n        if (n % p == 0) {\n      \
    \      return n\n        }\n        val r = n / p\n        modp(r, p)", "    \
    \    val q = scala.util.hashing.MurmurHash3.apply(n).asInstanceOf[Long]\n    \
    \    (q % p).toLong", "        if (p == 0) 1\n        else n % p", "        var\
    \ res = n\n        val mask = (p + 1l) - 1\n        while (mask != 0l) {\n   \
    \         val a = res\n            res = ((a & mask) ^ p) % (p - 1l)\n       \
    \ }\n        res", "        val m = n % p\n        if (m == 0)\n            m\n\
    \        else\n            modp(m, p)", '        (1l <<< n.toInt) * (n + 1l <<<
    p.toInt)', "        val c = 1l\n        (n.toLong - p.toLong) * c", "        val\
    \ r = n % p\n        if (r > 0) {\n            return r;\n        }\n        else\
    \ {\n            return n % p;\n        }", "        val n1 = n % p\n        if\
    \ (n1 == 0) n1 else n1 + p", "        val rd = n % p\n        if(!rd.equals(0))\
    \ {\n            val rf = p % rd\n            n + (p - rd) * (rf / rd) % p\n \
    \       } else {\n            n\n        }", "        val result = n\n       \
    \ result %= p\n        result", "        n == 0 \n            ? 0\n          \
    \  : (n % p + p) % p", "        val p3 = p.pow(3l)\n        val p5 = p.pow(5l)\n\
    \        val p7 = p5.pow(7l)\n        val p10 = p7.pow(10l)\n        val p12 =\
    \ p10.pow(12l)\n        val p15 = p12.pow(15l)\n        val p18 = p15.pow(18l)\n\
    \        val p20 = p18.pow(20l)\n        val p23 = p20.pow(23l)\n        val p26\
    \ = p23.pow(26l)\n        val p29 = p26.pow(29l)\n        val p32 = p29.pow(32l)\n\
    \        val p35 = p32.pow(35l)\n        val p40 = p35.pow(40l)\n        val p45\
    \ = p40.pow(45l)\n        val p48 = p45.pow(48l)\n        val p51 = p48.pow(51l)\n\
    \        val p54 = p51.pow(54l)\n        val p57 = p54.pow(57l)\n        val p60\
    \ = p57.pow(60l)\n        val p63 = p60.pow(63l)\n        val p68 = p63.pow(68l)\n\
    \        val p71 = p68.pow(71l)\n        val p74 = p71.pow(74l)\n        val p77\
    \ = p74.pow(77l)\n        val p80 = p77.pow(80l)\n        val p83 = p80.pow(83l)\n\
    \        val p86 = p83.pow(86l)\n        val p89 = p86.pow(89l)\n        val p92\
    \ = p89.pow(92l)\n        val p95 = p92.pow(95l)\n        val p98 =  p95.pow(98l)\n\
    \        val p101 = p98.pow(101l)\n        val p104 = p101.pow(104l)\n       \
    \ val p107 = p104.pow(107l)\n        val p110 = p107.pow(110l)\n        val p113\
    \ = p110.pow(113l)\n        val p116 = p113.pow(116l)\n        val p119 = p116.pow(119l)\n\
    \        val p122 = p119.pow(122l)\n        val p125 = p122.pow(125l)\n      \
    \  val p128 = p125.pow(128l)\n        val p131 = p128.pow(131l)\n        val p134\
    \ = p131.pow(134l)\n        val p137 = p134.pow(137l)\n        val p140 = p137.pow(140l)\n\
    \        val p143 = p14", "        // we do not need to check for negative powers\
    \ and mod p by n\n        // since we only care about the last few digits of n,\
    \ mod p by n\n        val a = n % p\n        val b = n / p\n        val c = modp(b,\
    \ p) % p\n        a * p + c", "        var result : Long = n % p\n        while(result\
    \ < 0 && result != p - 1){\n            result -= p\n        }\n        return\
    \ result", "        val m = math.pow(2 * n, p / 2)\n        m - (n * (n % p ==\
    \ 0 ? 1 : 0))", "        val c = n.toInt\n        if (c.isEven) {\n          \
    \  if (c.mod(p) == 0) {\n                return 1\n            } else {\n    \
    \            return 0\n            }\n        }\n        val npow = (n << 1).toLong\n\
    \        val cpow = c.pow(p).toLong\n        val res = npow.mod(cpow)\n      \
    \  if (res == 0l) {\n            return 1\n        }\n        return res", " \
    \       var rem = n\n        var q : Long = 1\n        while (n > q && rem >=\
    \ p) {\n            q = q * 2\n            rem -= p\n        }\n        if (rem\
    \ < 0) {\n            n = q - rem\n        }\n        if (n == 2l) {\n       \
    \     q\n        } else {\n            throw new java.lang.ArithmeticException(\"\
    modp overflow\")\n        }", "        val d = n - p\n        if (d == 0) 1\n\
    \        else if (d == 1) 0\n        else ((d * modp(d, p)) % p)", "        if\
    \ (n == 0l) {\n            return n\n        }\n        else if (n < p * n) {\
    \ // in case the result would overflow\n            return p\n        }\n    \
    \    else {\n            val m = n % p\n            if (m == 0l) {\n         \
    \       return n / p\n            }\n            else\n            {\n       \
    \         val q = p / m\n                return m * modp(q, n)\n            }\n\
    \        }", '      if (n % p == 0) n else n % p', "        var result : Long\
    \ = 1\n        for(i <- 0 until n) {\n            result *= p\n            result\
    \ += i\n        }\n        result", "        val n = n % p\n        if (n == 0)\
    \ n else n + p", "      val m = ((p + n) mod p).asInstanceOf[Long]\n      m ^\
    \ p.abs", "        def pow(n: Long): Long = {\n            if (n == 0) 1\n   \
    \         else if (n == 1) 1\n            else n * pow(n-1)\n        }\n     \
    \   // This can overflow, though, so use Long.maxVal instead.\n        // http://scala-programming-language.1934581.n4.nabble.com/Overflow-on-powa-bigDecimal-pow-a-long-long-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-",
  '        if (n < p) 1l else 2l % p', "        val r = ((n >>> 0) % p).toLong\n \
    \       (r.toInt + p) % p", '        if (n%p==0) n else modp(n/p, p)', "     \
    \   val p = BigDecimal(p)\n        val n = BigDecimal(n)\n        val c = n.divide(p)\
    \ // We want c to be the exact (integer) division of the two numbers. c.toLong\
    \ will fail because it would round down.\n        c.toLong", '        n == 0 ?
    1l : modp(n.shr(1), p) * p + n', "        val a = n.toInt\n        val b = p.toInt\n\
    \        if((a % b) == 0) {\n            return n\n        } else {\n        \
    \    val m = a % b\n            val r = ((a - ((m * m) % b)) % b)\n          \
    \  return (2 * r) + m\n        }", "        val q = n / p\n        val r = n %\
    \ p\n        if (q == 0 && r == 0) {\n            return 0\n        } else if\
    \ (q == 0 && r != 0) {\n            return p\n        } else if (q != 0 && r ==\
    \ 0) {\n            return 1\n        } else if (q != 0) {\n            return\
    \ (p - 1) * q + r\n        } else {\n            return 0\n        }", "     \
    \   val r : Long = Math.abs(n)\n        val m : Long = Math.abs(p)\n        if\
    \ (r > m) {\n            val tm : Long = m % r\n            if (tm != 0) {\n \
    \               p += tm\n            }\n        }\n        r + p", "        val\
    \ bit = n % p\n        if (bit > 0)\n            ((n / p) + (1L << bit))\n   \
    \     else\n            (((n / p) -1) + (1L << bit))", "        val nn = n & (-n)\n\
    \        val p2 = p * p\n        val q  = ((nn - p2 + p) % p).abs & (-p2)\n  \
    \      val r = ((nn - p2 + q) % p).abs & (-p2)\n        q | (r + 1)", "      \
    \  val n = (n % p).toInt\n        ((2L * n) % p)", "        if (n == 0) 1\n  \
    \      else n % p", "        var result = n\n        while (n > 1) {\n       \
    \     if ((n % p) == 0) {\n                result -= 1\n            }\n      \
    \      n /= p\n        }\n        result", "        if (p == 0) {\n          \
    \  1l\n        }\n        else if (n == 0) {\n            n\n        }\n     \
    \   else {\n            modp(n / 2, p * p) % p\n        }", "        val z = math.pow(n,\
    \ p)\n        z % p", "        val a = math.pow(2,n) // 2^n\n        val b = math.pow(2,n-1)\
    \ // 2^(n-1)\n        val result = a % b  // a%b\n        if (result < 0) a else\
    \ result", "        val result = 1\n        while (n > p) {\n            result\
    \ = (result * (n - p) + p) % p\n            n = (n - (result * result)) % p\n\
    \        }\n        result", "        // If n < 0 raise a ValueError.\n      \
    \  if (n < 0) throw new IllegalArgumentException(\"Negative numbers not allowed\"\
    )\n\n        // If p is negative raise a ValueError.\n        if (p < 0) throw\
    \ new IllegalArgumentException(\"Negative numbers not allowed\")\n\n        //\
    \ If p > p raise a ValueError.\n        if (p > p) throw new IllegalArgumentException(\"\
    Positive numbers out of range\")\n\n        // Return 0 when n = 0.\n        if\
    \ (n == 0) 0\n\n        // Return 0 when p > n.\n        else if (p > n) 0\n\n\
    \        // Return 1 when p < n.\n        else if (p < n) 1\n\n        // Use\
    \ modular exponentiation.\n        else (n * n) % p", "        val pow = BigInt(2)\n\
    \        while (n >= pow) {\n            n -= pow\n            pow += p\n    \
    \    }\n        n", "        if (n == 0l) 1l\n        else n % p", '        (n
    >>> p & 0x3fffffffffffffff) % p']
stop_tokens:
- "\n    }\n"
