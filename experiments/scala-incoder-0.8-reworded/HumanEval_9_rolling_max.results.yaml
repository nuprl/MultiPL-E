language: scala
name: HumanEval_9_rolling_max
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var current = List.empty[Long]\n        var maximum = numbers.head\n   \
    \     var tempList = List.empty[Long]\n        numbers.tail.foreach{value =>\n\
    \            val current = current :+ value\n            val tempListWithCurrentMax\
    \ = tempList :+ maximum\n            maximum = Math.max(maximum, value)\n    \
    \        tempListWithCurrentMax.foreach{max => if (max > maximum) current = current\
    \ :+ max}\n        }\n        current :+ maximum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5_27xhfh.scala:13:26 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mval\e[0m \e[36mcurrent\e[0m = current\
    \ :+ value\n\e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e\
    [0m                          Recursive \e[33mvalue\e[0m \e[35mcurrent\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp5_27xhfh.scala:16:77\
    \ -----------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            tempListWithCurrentMax.foreach{\e\
    [36mmax\e[0m => \e[33mif\e[0m (max > maximum) current = current :+ max}\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \                    Reassignment to val current\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010918
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxVals = numbers.takeWhile(_ > 0).reverse\n        val maxCounts =\
    \ numbers.dropWhile(_ < 0).reverse\n        (maxVals, maxCounts)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_pce2488.scala:11:8\
    \ ---------------------\e[0m\e[0m\n\e[31m11 |\e[0m        (maxVals, maxCounts)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \  Found:    \e[1m\e[31m(\e[0mList[Long\e[1m\e[31m]\e[0m\e[1m\e[31m,\e[0m\e[1m\e\
    [31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31mLong\e[0m]\e[1m\e[31m)\e\
    [0m\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max_list = ListBuffer[Long]()\n        var rolling_max = 0\n\n     \
    \   for (number <- numbers) {\n            if (number > rolling_max) {\n     \
    \           rolling_max = number\n                max_list += rolling_max\n  \
    \          } else if (number == rolling_max) {\n                max_list += number\n\
    \            }\n        }\n        max_list.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq47memtk.scala:14:30\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m                rolling_max =\
    \ number\n\e[31m\e[31m   |\e[0m                              ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                              Found:    (number : Long)\n\e[31m   |\e\
    [0m                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = 0\n        numbers.reverse foreach { x =>\n            if (x >\
    \ max) {\n                max = x\n            }\n        }\n        max :: rollingMax(numbers.dropRight(1));\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7pn5kaep.scala:12:22\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m                max = x\n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   Found:    (x : Long)\n\e[31m   |\e[0m                      Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = 0\n        var maxIndex = 0\n        var currentMax = 0\n    \
    \    var rollingMax = scala.collection.mutable.ArrayBuffer.empty[Long]()\n   \
    \     var currentIndex = numbers.head\n\n        var sum = 0\n\n        while(numbers.length\
    \ > 0) {\n            sum = numbers(currentIndex).asInstanceOf[Long]\n       \
    \     rollingMax = rollingMax.:+(numbers(currentIndex))\n            currentIndex\
    \ += 1\n\n            if(sum > currentMax) {\n                currentMax = sum\n\
    \                maxIndex = currentIndex\n                rollingMax = rollingMax.:+(numbers(maxIndex))\n\
    \            }\n\n            if(currentIndex < numbers.size) {\n            \
    \    sum = 0\n                currentMax = 0\n                maxIndex = 0\n \
    \               currentIndex = numbers.head\n            }\n        }\n\n    \
    \    rollingMax.subList(0, maxIndex + 1).map((elem) => elem.asInstanceOf[Long]).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp11m_v4gn.scala:12:73 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mrollingMax\e[0m = scala.collection.mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter n of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mclass\e[0m \e[35mArrayBuffer\e[0m: (n: Int): Long\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp11m_v4gn.scala:18:26 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            sum = numbers(currentIndex).asInstanceOf[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    (currentIndex : Long)\n\
    \e[31m   |\e[0m                          Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp11m_v4gn.scala:24:27 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                maxIndex = currentIndex\n\e[31m\e[31m\
    \   |\e[0m                           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                     Found:    (currentIndex : Long)\n\e[31m   |\e[0m       \
    \                    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010926
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxValues = mutable.Buffer[Long]()\n        val currentMax = numbers.head\n\
    \        for(i <- 1 until numbers.size) {\n            val value = numbers.lift(i).max\n\
    \            if(value > currentMax) {\n                currentMax = value\n  \
    \              maxValues += currentMax\n            } else if(value == currentMax)\
    \ {\n                maxValues += currentMax\n            } else {\n         \
    \       maxValues += currentMax\n                maxValues += value\n        \
    \    }\n        }\n        maxValues\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3a62zw4i.scala:9:24 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxValues\e[0m = mutable.Buffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                        Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp3a62zw4i.scala:14:27 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                currentMax = value\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val currentMax\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010920
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollMax = mutable.ArrayBuffer.empty[Long]\n        numbers.reverse.foreach(rollMax\
    \ += _)\n        rollMax.reverse.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgklbuhqn.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollMax\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010918
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = numbers(0)\n        numbers.reverse.foldLeft(List[Long]()) { (result,\
    \ num) =>\n            if(num > max)\n                result :+ num\n        \
    \    else \n                result\n        }.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpfybvmjk5.scala:9)\n\tat Problem$.main(tmpfybvmjk5.scala:18)\n\
    \tat Problem.main(tmpfybvmjk5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010927
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = numbers.foldLeft[List[Long]](List.empty[Long]) { \n      \
    \      case (acc, x) =>\n                if (acc contains x) \n              \
    \      acc else acc :+ x \n        }\n        val tail = numbers.dropRight(1)\n\
    \        if (tail.isEmpty) maxList else rollingMax(tail).flatMap { acc =>\n  \
    \          maxList :+ max(acc)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqfpfxbcp.scala:16:23 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            maxList :+ max(acc)\n\e[31m\e[31m   |\e[0m\
    \                       ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((acc : Long))\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010919
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxes = mutable.Buffer.empty[Long]\n        var max = 0l\n        for\
    \ (n <- numbers) {\n            if (n > max) {\n                maxes += n\n \
    \               max = n\n            } else if (n == max) {\n                maxes\
    \ += n\n            } else if (n > max) {\n                maxes = maxes ++ List(max)\n\
    \                max = n\n            }\n        }\n        maxes += max\n   \
    \     return maxes.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpahkrledj.scala:9:20 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mvar\e[0m \e[36mmaxes\e[0m = mutable.Buffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                    ^^^^^^^\e[0m\n\e[31m \
    \ |\e[0m                    Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010918
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // base case\n        if(numbers.isEmpty) return numbers.tail\n        val\
    \ first = numbers.head\n        if(numbers.size == 1) List(first)\n        else\
    \ {\n            // recursive case\n            val tail = rollingMax(numbers.tail)\n\
    \            val middle = numbers.take(numbers.size / 2).max\n            val\
    \ maxes = tail filter (_ >= middle)\n            val maxes.reverse.foldLeft(maxes)(\
    \ (curMax: List[Long], elem: Long) =>\n                curMax :+ elem :+ curMax.last\n\
    \            )\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjp1900c3.scala:18:45 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m maxes.reverse.foldLeft(maxes)(\
    \ (curMax: List[Long], elem: Long) =>\n\e[31m\e[31m   |\e[0m                 \
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \                    '=' expected, but '(' found\n\e[31m\e[31m-- [E127] Syntax\
    \ Error: /tmp/tmpjp1900c3.scala:18:16 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m            \e[33mval\e[0m maxes.reverse.foldLeft(maxes)( (curMax:\
    \ List[Long], elem: Long) =>\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxes.reverse.foldLeft cannot be used as an extractor in a\
    \ pattern because it lacks an unapply or unapplySeq method\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjp1900c3.scala:21:9 ---------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m\
    \   |\e[0m         Found:    Unit\n\e[31m   |\e[0m         Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def rollingMaxHelper(numbers: List[Long], maxSoFar: List[Long]) : List[Long]\
    \ = {\n            if (numbers.isEmpty) return maxSoFar\n            if (numbers.size\
    \ == 1) return maxSoFar\n            val first = numbers.head\n            val\
    \ tail = numbers.tail\n            maxSoFar :+ first\n            val nextMax\
    \ = tail.foldLeft(first)(max(_, number))\n            rollingMaxHelper(tail, nextMax)\n\
    \        }\n        rollingMaxHelper(numbers, List[Long]())\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpr6xna8zx.scala:15:47 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e[0m \e[36mnextMax\e[0m = tail.foldLeft(first)(max(_,\
    \ number))\n\e[31m\e[31m   |\e[0m                                            \
    \   ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 Wrong\
    \ number of parameters, expected: 2\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpr6xna8zx.scala:16:35 --------------------\e[0m\e[0m\n\e[31m16 |\e[0m\
    \            rollingMaxHelper(tail, nextMax)\n\e[31m\e[31m   |\e[0m          \
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \             Found:    (nextMax : Long)\n\e[31m   |\e[0m                    \
    \               Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010925
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxNumbers = numbers.map(_.toLong).toList\n        val rollingMaxNumbers\
    \ = maxNumbers.tail.zip(maxNumbers.tail.dropRight(1)).map(a => a._1 + a._2)\n\
    \        rollingMaxNumbers.takeWhile(a => a > maxNumbers.head).reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: tail of empty list\n\tat scala.collection.immutable.Nil$.tail(List.scala:664)\n\
    \tat scala.collection.immutable.Nil$.tail(List.scala:661)\n\tat Problem$.rollingMax(tmpibmw9ikc.scala:10)\n\
    \tat Problem$.main(tmpibmw9ikc.scala:14)\n\tat Problem.main(tmpibmw9ikc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010926
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val len = numbers.size\n        var maxList = numbers.tail\n        var\
    \ maxNumber = numbers.last\n        var rollingMaxList = ListBuffer.empty[Long]\n\
    \        val rollingMax = new mutable.Buffer[Long]()\n        for (i <- 0 until\
    \ len) {\n            rollingMax += numbers(i)\n            rollingMaxList +=\
    \ numbers(i)\n            if (rollingMax.last > maxNumber) {\n               \
    \ maxNumber = rollingMax.last\n                maxList = rollingMaxList\n    \
    \        }\n        }\n        rollingMaxList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqbr6l_5e.scala:13:29 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = \e[33mnew\e\
    [0m mutable.Buffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                 \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqbr6l_5e.scala:19:26\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                maxList = rollingMaxList\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m  Found:    (rollingMaxList : scala.collection.mutable.ListBuffer[Long])\n\e\
    [31m   |\e[0m  Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqbr6l_5e.scala:22:8 ---------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        rollingMaxList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m  Found:    (rollingMaxList : scala.collection.mutable.ListBuffer[Long])\n\
    \e[31m   |\e[0m  Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // For a rolling max, we just need to maintain a list of maximum elements\
    \ seen so far\n        // and just append the current element to it when we see\
    \ it again. The only time we add a\n        // new element is when we reach the\
    \ end.\n        val maxes = new mutable.ListBuffer[Long]\n        maxes += numbers.head\n\
    \        numbers foreach { number =>\n            if (number > maxes.last) {\n\
    \                maxes += number\n            }\n        }\n        maxes.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgcsfs35f.scala:12:24 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mmaxes\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m               \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010917
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     require(numbers.nonEmpty, \"numbers cannot be empty\")\n        val listMax\
    \ = numbers.map(x => x)\n        var max = 0L\n        var current = 1L\n    \
    \    var listMaxMax = List[Long]()\n        for (i <- numbers) {\n           \
    \ if (current > x) {\n                listMaxMax = listMax.takeWhile(x => current\
    \ >= x).toList\n                current = 1L\n                max = x\n      \
    \      }\n            if (max < i) current = i\n            else max = i\n   \
    \     }\n        listMaxMax = listMaxMax.map(x => x + 1).toList\n        listMaxMax\
    \ :: listMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphfx1p6al.scala:15:26 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mif\e[0m (current > x) {\n\e[31m\e[31m\
    \   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m                  \
    \        Not found: x\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphfx1p6al.scala:18:22\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m                max = x\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Not found: x\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphfx1p6al.scala:24:8 ---------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        listMaxMax :: listMax\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (listMaxMax : List[Long])\n\e[31m   |\e\
    [0m        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010923
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(List[Long]()) { (sum, current) =>\n            val index\
    \ = sum.size - 1\n            if (index <= current) sum :+ current\n         \
    \   else sum.updated(index, current max sum)\n        }.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3710s471.scala:12:48\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m            \e[33melse\e[0m sum.updated(index,\
    \ current max sum)\n\e[31m\e[31m   |\e[0m                                    \
    \            ^^^\e[0m\n\e[31m   |\e[0m                                       \
    \     Found:    (sum : List[Long])\n\e[31m   |\e[0m                          \
    \                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(List[Long]()) { (res, x) => {\n            val max = res.max\
    \ { t => if (t > x) t else x }\n            val res = res.init :+ max\n      \
    \      res\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmped1jh_i6.scala:23:0 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmped1jh_i6.scala:22:1\
    \ ---------------------\e[0m\e[0m\n\e[31m22 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmped1jh_i6.scala:15:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m15 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1660010925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = 0\n        var maxElem = numbers(0)\n\n        for (i <- 1 to\
    \ numbers.length - 1) {\n            max = numbers(i)\n            if (max > maxElem)\
    \ {\n                maxElem = max\n            }\n        }\n        maxElem\
    \ :: rollingMax(numbers.drop(1))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphlvfvhnm.scala:13:25\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m            max = numbers(i)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \            Found:    Long\n\e[31m   |\e[0m                  Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty) return Nil\n        val r = new mutable.ListBuffer[Long]\n\
    \        var index = 0\n        var max = 0L\n        val r = new mutable.ListBuffer[Long]\n\
    \        for (i <- 1 to numbers.size) {\n            if (numbers(i) > max) {\n\
    \                index = i\n                max = numbers(i)\n            }\n\
    \            else {\n                val r = numbers.drop(i).filterNot(x => x\
    \ == numbers(i)).iterator\n                if (r.hasNext) r else null\n      \
    \      }\n        }\n        r :+ max\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbhhll8y2.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpbhhll8y2.scala:10:20 ------------------------\e[0m\e[0m\n\e[31m10 |\e\
    [0m        \e[33mval\e[0m \e[36mr\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Sort list to make it more interesting\n        val sortedNumbers = numbers.sortWith((x,\
    \ y) => x < y)\n        \n        // Sum up all elements except the last\n   \
    \     var cummulativeSum = sortedNumbers(0)\n        var cummulativeSumMax = cummulativeSum\n\
    \        for(i <- 1 to sortedNumbers.length-1) {\n            cummulativeSum +=\
    \ sortedNumbers(i)\n            cummulativeSumMax = Math.max(cummulativeSum, cummulativeSumMax)\n\
    \        }\n        \n        // Append the last\n        numbers :+ cummulativeSumMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax(tmp66ulqntf.scala:13)\n\tat Problem$.main(tmp66ulqntf.scala:24)\n\
    \tat Problem.main(tmp66ulqntf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010927
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(List[Long]()){ \n            (acc: List[Long], number:\
    \ Long) => {\n                number match {\n                    case x :: xs\
    \ => x :: acc\n                    case _ => acc :+ number\n                }\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbp3oyutw.scala:12:36\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m                    \e[33mcase\e\
    [0m x :: xs => x :: acc\n\e[31m\e[31m   |\e[0m                               \
    \     ^\e[0m\n\e[31m   |\e[0m                                    Found:    (x\
    \ : Any)\n\e[31m   |\e[0m                                    Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMaxList = mutable.MutableList[Long]()\n        var max = numbers.last\n\
    \        numbers.foreach{ n =>\n            if (n > max) {\n                max\
    \ = n\n            }\n        }\n        var index = numbers.length\n        while\
    \ (!numbers(index).equals(max)) {\n            rollingMaxList += max\n       \
    \     index += 1\n        }\n        rollingMaxList.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdulaw13f.scala:9:29 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMaxList\e[0m = mutable.MutableList[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m  |\e[0m                             Not found: mutable\n\e[31m  |\e[0m\n\
    \e[31m  |\e[0m longer explanation available when compiling with `-explain`\n1\
    \ error found\n"
  stdout: ''
  timestamp: 1660010919
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = mutable.ListBuffer[Long]()\n        var maxNum = numbers(0)\n\
    \        for (i<- 1 to numbers.size)\n        {\n            maxNum = numbers(i)\n\
    \            for (j<- 0 to i-1)\n            {\n                if (numbers(j)\
    \ > maxNum)\n                {\n                    maxNum = numbers(j)\n    \
    \            }\n            }\n            rollingMax += maxNum\n        }\n \
    \       rollingMax.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps4_tw556.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010931
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   val result = ListBuffer[Long]()\n      var rollingMax = numbers.get(0)\n \
    \     for (num <- numbers) {\n        if (num > rollingMax) {\n          rollingMax\
    \ = num\n          result += rollingMax.toLong\n        }\n      }\n      result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptoo663v2.scala:10:31 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m      \e[33mvar\e[0m \e[36mrollingMax\e[0m = numbers.get(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m     value get is not a member of List[Long] - did you mean numbers.seq?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptoo663v2.scala:17:6 ---------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m      result\n\e[31m\e[31m   |\e[0m      ^^^^^^\e[0m\n\
    \e[31m   |\e[0m      Found:    (result : scala.collection.mutable.ListBuffer[Long])\n\
    \e[31m   |\e[0m      Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010939
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft((List[Long](), 0)){ (x, y) =>\n            // Add new number\
    \ at the head of list\n            val temp_list = x match {\n               \
    \ case (acc, 0) => (y :: acc, 0)\n                case (acc, m) => (y :: acc,\
    \ m)\n            }\n            val max_element = temp_list._2\n            //\
    \ Append new element to the head of previous list\n            val temp_list =\
    \ x match {\n                case (acc, 0) => (y :: acc, 0)\n                case\
    \ (acc, m) => (y :: acc, m)\n            }\n            // Find index of max_element\
    \ from previous list\n            val index = temp_list._1.indexOfMax(max_element)\n\
    \            // Append max_element to last element of list\n            temp_list._1\
    \ :+ max_element :: temp_list._2(index).tail\n        }._1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E041] Syntax Error: /tmp/tmp9xwfvbbp.scala:24:28 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            temp_list._1 :+ max_element :: temp_list._2(index).tail\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m:+ (which\
    \ is left-associative) and :: (which is right-associative) have same precedence\
    \ and may not be mixed\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9xwfvbbp.scala:17:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e\
    [0m \e[36mtemp_list\e[0m = x \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m       \
    \     ^\e[0m\n\e[31m   |\e[0mtemp_list is already defined as \e[33mvalue\e[0m\
    \ \e[35mtemp_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m18 |\e\
    [0m                \e[33mcase\e[0m (acc, \e[31m0\e[0m) => (y :: acc, \e[31m0\e\
    [0m)\n\e[31m19 |\e[0m                \e[33mcase\e[0m (acc, m) => (y :: acc, m)\n\
    \e[31m20 |\e[0m            }\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9xwfvbbp.scala:22:37\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m\
    \ \e[36mindex\e[0m = temp_list._1.indexOfMax(max_element)\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ indexOfMax is not a member of List[Long] - did you mean _1.indexOf?\n\e[31m\e\
    [31m-- [E050] Type Error: /tmp/tmp9xwfvbbp.scala:24:53 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            temp_list._1 :+ max_element :: temp_list._2(index).tail\n\
    \e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      \e[33mgetter\e[0m \e[35m_2\e[0m in \e\
    [33mclass\e[0m \e[35mTuple2\e[0m does not take parameters\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010939
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = numbers(0l).max(numbers(numbers.size - 1l))\n        val list\
    \ = new collection.mutable.ListBuffer[Long]()\n        for (i <- 0 until numbers.size\
    \ - 1l) {\n            if (numbers(i + 1l) == max) {\n                list +=\
    \ numbers(i).toLong\n            }\n        }\n        list.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbtpfdu44.scala:9:26\
    \ ---------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e\
    [0m = numbers(\e[31m0l\e[0m).max(numbers(numbers.size - \e[31m1l\e[0m))\n\e[31m\e\
    [31m  |\e[0m                          ^^\e[0m\n\e[31m  |\e[0m                \
    \          Found:    (\e[31m0L\e[0m : Long)\n\e[31m  |\e[0m                  \
    \        Required: Int\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbtpfdu44.scala:9:42\
    \ ---------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e\
    [0m = numbers(\e[31m0l\e[0m).max(numbers(numbers.size - \e[31m1l\e[0m))\n\e[31m\e\
    [31m  |\e[0m                                          ^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m  |\e[0m                                          Found:    Long\n\e[31m\
    \  |\e[0m                                          Required: Int\n\e[31m  |\e\
    [0m\n\e[31m  |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbtpfdu44.scala:11:26 --------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m until numbers.size\
    \ - \e[31m1l\e[0m) {\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Long\n\e[31m   |\e[0m\
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpbtpfdu44.scala:12:24 --------------------\e[0m\e\
    [0m\n\e[31m12 |\e[0m            \e[33mif\e[0m (numbers(i + \e[31m1l\e[0m) == max)\
    \ {\n\e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010941
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers(0))\n        val listOfMaxElements = List[Long]()\n\
    \        val maxElement = numbers(0)\n        numbers.foreach {\n            number\
    \ => {\n                if(number > maxElement) {\n                    maxElement\
    \ = number\n                    listOfMaxElements = ListBuffer(maxElement)\n \
    \               } else {\n                    listOfMaxElements = listOfMaxElements\
    \ :+ number\n                }\n                result = result ++ listOfMaxElements\n\
    \            }\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp36rxeki9.scala:15:31 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                    maxElement = number\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \              Reassignment to val maxElement\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp36rxeki9.scala:16:50 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                    listOfMaxElements = ListBuffer(maxElement)\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m   |\e[0m                     Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp36rxeki9.scala:18:38 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                    listOfMaxElements = listOfMaxElements\
    \ :+ number\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Reassignment to val listOfMaxElements\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010939
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMaxResult = mutable.List[Long]()\n        var max = 0\n     \
    \   var maxIndex = 0\n        for ((number, index) <- numbers.zipWithIndex) {\n\
    \            if (number > max) {\n                max = number\n             \
    \   maxIndex = index\n            }\n        }\n        for (i <- 0 until maxIndex)\
    \ {\n            val currentMax = numbers(maxIndex - i)\n            if (max ==\
    \ currentMax) {\n                rollingMaxResult += currentMax\n            }\
    \ else {\n                rollingMaxResult += max\n            }\n        }\n\
    \        rollingMaxResult\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppjok5gqi.scala:9:31 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMaxResult\e[0m = mutable.List[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                               ^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                               Not found: mutable\n\e[31m \
    \ |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppjok5gqi.scala:14:22 --------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                max = number\n\e[31m\e[31m   |\e[0m \
    \                     ^^^^^^\e[0m\n\e[31m   |\e[0m                      Found:\
    \    (number : Long)\n\e[31m   |\e[0m                      Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010940
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val res = numbers.foldLeft(List[Long]()) { case (acc, number) =>\n     \
    \       number :: acc\n        }\n        res.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf_yqe3jz.scala:17)\n\tat Problem.main(tmpf_yqe3jz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010943
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = new mutable.Array[Long]\n        var maximum = 0L\n   \
    \     var rollingMaxNumber = 0\n        var i = 1\n        var rollingMaxIndex\
    \ = 0\n        while(i < numbers.length) {\n            rollingMax(rollingMaxNumber)\
    \ = numbers(i)\n            rollingMaxNumber += 1\n            i += 1\n      \
    \      maximum = max(maximum, numbers(i))\n        }\n        rollingMaxIndex\
    \ = 1\n        while(rollingMaxIndex < rollingMaxNumber) {\n            maximum\
    \ = max(maximum, rollingMax(rollingMaxIndex))\n            i += 1\n          \
    \  rollingMaxIndex += 1\n        }\n        rollingMax(rollingMaxNumber)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyq1q26cn.scala:9:29 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = \e[33mnew\e\
    [0m mutable.Array[\e[35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                     \
    \        ^^^^^^^\e[0m\n\e[31m  |\e[0m                             Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010935
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List.empty[Long])((acc, x) => acc max\
    \ x)\n        val rollingMaxList: List[Long] = rollingMax.toList\n        rollingMaxList.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqygxqyzu.scala:9:80\
    \ ---------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e\
    [0m = numbers.foldLeft(List.empty[\e[35mLong\e[0m])((\e[36macc\e[0m, \e[36mx\e\
    [0m) => acc max x)\n\e[31m\e[31m  |\e[0m                                     \
    \                                           ^\e[0m\n\e[31m  |\e[0m           \
    \                                       Found:    (x : Long)\n\e[31m  |\e[0m \
    \                                                 Required: Ordering[Long]\n\e\
    [31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010942
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Using mutable collection to store all rolling maximum elements\n    \
    \    // The purpose of this mutable collection is to prevent multiple time searching\
    \ same rolling\n        // max element in the rolling max list\n        val rollingMaxList\
    \ = mutable.Buffer[Long]()\n        numbers.foreach{number =>\n            if(number\
    \ > rollingMaxList.last){\n                rollingMaxList += number\n        \
    \    }\n        }\n        return rollingMaxList.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_fskhhrt.scala:12:29 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mrollingMaxList\e[0m = mutable.Buffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: mutable\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010936
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Use a scala.collection.mutable.Stack to keep track of the current max\
    \ values seen so far.\n        val stack = new mutable.Stack[Long]()\n       \
    \ for (i <- numbers) {\n            if (stack.size > 0)\n                stack\
    \ += max( stack.last , i)\n            else {\n                stack += i\n  \
    \          }\n        }\n        stack.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw33rqm3z.scala:10:24 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length <= 0) return Nil\n        val max = 0\n        val maxElement\
    \ = numbers.head\n        val maxList = List(numbers.tail.max) ::: Nil\n     \
    \   val nextElements = numbers.tail\n        nextElements.tail.foldLeft(List[Long]())((acc,\
    \ element) => {\n            if (element > max) {\n                max = element\n\
    \                maxElement = element\n                maxList = acc\n       \
    \     }\n            if (element == maxElement) {\n                maxList = maxList\
    \ :+ element\n            }\n            if (element < maxElement) maxList = maxList\
    \ :+ element\n            maxList ::: acc\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwn9ns5xa.scala:16:22\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m                max = element\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Found:    (element : Long @uncheckedVariance)\n\e[31m   |\e\
    [0m                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpwn9ns5xa.scala:17:27 -----------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m                maxElement = element\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val maxElement\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpwn9ns5xa.scala:18:24\
    \ -----------------------------\e[0m\e[0m\n\e[31m18 |\e[0m                maxList\
    \ = acc\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Reassignment to val maxList\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpwn9ns5xa.scala:21:24 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                maxList = maxList :+ element\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Reassignment to val maxList\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpwn9ns5xa.scala:23:46 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (element < maxElement) maxList\
    \ = maxList :+ element\n\e[31m\e[31m   |\e[0m                                \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                  Reassignment to val maxList\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010944
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxElements = mutable.ListBuffer[Long]()\n        for (elem <- numbers)\
    \ {\n            maxElements += elem\n        }\n        val maxIndex = maxElements.max\n\
    \        maxIndex.until(maxIndex.head + 1).foreach { maxIndex =>\n           \
    \ maxElements.updated(maxIndex, maxElements(maxIndex))\n        }\n        return\
    \ maxElements.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9ihugi0p.scala:9:26 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxElements\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m  |\e[0m                          Not found: mutable\n\e[31m  |\e[0m\n\e\
    [31m  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010936
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val m = numbers(numbers.size - 1)\n        var i = numbers.size - 1\n  \
    \      while (i >= 0) {\n            if (numbers(i) > m)\n                m =\
    \ numbers(i)\n            i--\n        }\n        numbers\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpmsx853gu.scala:14:15 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            i--\n\e[31m\e[31m   |\e[0m              \
    \ ^\e[0m\n\e[31m   |\e[0m               expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpmsx853gu.scala:13:18\
    \ -----------------------------\e[0m\e[0m\n\e[31m13 |\e[0m                m =\
    \ numbers(i)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Reassignment to val m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010939
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Initialize a list to hold rolling maximum\n        val rollingMax = new\
    \ scala.collection.mutable.ListBuffer[Long]()\n        for (n <- numbers) {\n\
    \            // If number is not in the rolling maximum list, add the number to\
    \ the list\n            if (!rollingMax.contains(n)) {\n                rollingMax.append(n)\n\
    \            }\n        }\n        // Return the rolling maximum list\n      \
    \  rollingMax.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp317spvso.scala:23)\n\tat Problem.main(tmp317spvso.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = numbers.foldLeft(List.empty[Long]){\n            (maxList,\
    \ elem) =>\n                if (elem > maxList.head) maxList :+ elem\n       \
    \         else maxList\n        }\n        val list: List[Long] = maxList.drop(maxList.size\
    \ - 3)\n        list\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.$anonfun$1(tmp752l2ayr.scala:11)\n\
    \tat Problem$.$anonfun$adapted$1(tmp752l2ayr.scala:12)\n\tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\
    \tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\
    \tat Problem$.rollingMax(tmp752l2ayr.scala:12)\n\tat Problem$.main(tmp752l2ayr.scala:19)\n\
    \tat Problem.main(tmp752l2ayr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = scala.collection.mutable.ListBuffer.empty[Long]\n        for\
    \ (number <- numbers) {\n            val maxIndex = numbers.indexWhere(_ > number)\n\
    \            val maxValue = numbers(maxIndex)\n            if (maxes.isEmpty ||\
    \ maxes.last > maxValue)\n                maxes += maxValue\n        }\n     \
    \   maxes.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.rollingMax$$anonfun$1(tmpv3n3klnt.scala:12)\n\tat scala.runtime.java8.JFunction1$mcVJ$sp.apply(JFunction1$mcVJ$sp.scala:18)\n\
    \tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat Problem$.rollingMax(tmpv3n3klnt.scala:15)\n\
    \tat Problem$.main(tmpv3n3klnt.scala:20)\n\tat Problem.main(tmpv3n3klnt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010947
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxSeq = new mutable.ListBuffer[Long]()\n        numbers.foreach { x\
    \ =>\n            val maxIndex = maxSeq.findIndex(_.longValue < x)\n         \
    \   maxSeq.update(maxIndex + 1, x)\n        }\n        maxSeq.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4i2kkg16.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxSeq\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m              \
    \           ^^^^^^^\e[0m\n\e[31m  |\e[0m                         Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010939
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList : List[Long] = List.empty[Long]\n        var maxVal : Long =\
    \ 0\n        var maxIndex = 0\n        numbers.zipWithIndex.foreach {\n      \
    \      x => {\n                if (x._2 >= maxIndex){\n                    maxVal\
    \ = x._1\n                    maxIndex = x._2\n                }\n           \
    \     if (x._2 == maxIndex && x._1 > maxVal) {\n                    maxVal = x._1\n\
    \                    maxIndex = x._2\n                }\n            }\n     \
    \   }\n        maxList.add(maxVal)\n        return maxList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpum80q7e3.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        maxList.add(maxVal)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value add is not a member of List[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010943
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val numList = numbers.toList\n        val numListLen = numList.size\n  \
    \      val numListMax = numList(0).toLong\n        // generate numListLen rolling\
    \ max list\n        val numMaxList = new Array[Long](numListLen)\n        var\
    \ j = 0\n        for(i <- 0 until numListLen){\n            numMaxList(i) = numList(i)\n\
    \        }\n        // append rolling max list\n        while(j < numListLen){\n\
    \            val maxNum = numMaxList(j)\n            val index = j\n         \
    \   val k = 1\n            while(k <= numListLen){\n                if(numMaxList(index\
    \ + k) > maxNum){\n                    numMaxList(index + k) = maxNum\n      \
    \          }\n                k++\n            }\n            j++\n        }\n\
    \        numMaxList.map(_.toLong)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkv2qx71a.scala:27:19 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                k++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkv2qx71a.scala:29:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            j++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpkv2qx71a.scala:31:8 ---------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        numMaxList.map(_.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mArray\e[0m[Long]\n\e[31m   |\e\
    [0m        Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010946
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        numbers.foreach { n\
    \ =>\n            result += n.toList #:: rollingMax(result.slice)\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqbhvh5ig.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m              \
    \           ^^^^^^^\e[0m\n\e[31m  |\e[0m                         Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010940
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     require(numbers.length >= 1)\n        var max = 0\n        val maxElem =\
    \ numbers(0)\n        var index = 0\n        var newMax = maxElem\n        for(i\
    \ <- 1 to numbers.length - 1){\n            val newElem = numbers(i)\n       \
    \     if (newElem > maxElem){\n                max = newMax\n                index\
    \ = i\n            }\n            newMax = math.max(newElem, max)\n        }\n\
    \        val result = List(maxElem, index)\n        return result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp38utkz06.scala:17:22\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m                max = newMax\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                Found:    (newMax : Long)\n\e[31m   |\e[0m                  \
    \    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp38utkz06.scala:23:15\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[AnyVal])\n\e[31m   |\e[0m               Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010947
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.sortWith(_ < _)\n            .reverse\n       \
    \     .sliding(numbers.size)\n            .map { n =>\n                val rollingMax\
    \ = n.sortWith(_ < _)\n                    .reverse\n                    .sliding(numbers.size)\n\
    \                    .max\n                rollingMax.max(numbers.last)\n    \
    \        }\n            .reverse\n            .toList\n        rollingMax\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8gnirj_8.scala:17:39\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m                rollingMax.max(numbers.last)\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                               Found:    Long\n\e[31m   |\e[0m     \
    \                          Required: Ordering[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010946
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   def accumulator(current: Long, accumulator: Long) : Long = if (current > accumulator)\
    \ current else accumulator\n      numbers.foldLeft(0l.toLong)(accumulator)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxjda6kbb.scala:10:33\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m      numbers.foldLeft(\e[31m0l\e\
    [0m.toLong)(accumulator)\n\e[31m\e[31m   |\e[0m      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m      Found:    Long\n\e[31m   |\e[0m      Required: \e[1m\e\
    [32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010951
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def computeMax(n: Long, max: List[Long]) : List[Long] = {\n            if\
    \ (n == 0) max\n            else computeMax(n - 1, max :+ Math.max(n-1, numbers(n-1)))\n\
    \        }\n        computeMax(numbers.size, List.empty)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuqe_w4m2.scala:11:64\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m            \e[33melse\e[0m computeMax(n\
    \ - \e[31m1\e[0m, max :+ Math.max(n-\e[31m1\e[0m, numbers(n-\e[31m1\e[0m)))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \      ^^^\e[0m\n\e[31m   |\e[0m                                             \
    \             Found:    Long\n\e[31m   |\e[0m                                \
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010953
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def isMax(x : Long, m : List[Long], s : List[Long]) : Boolean = {\n    \
    \        if(m.head == x) {\n                true\n            } else {\n     \
    \           m.head < x && (s = m :: s)\n            }\n        }\n        def\
    \ maxRolling(n : List[Long], s : List[Long]) : List[Long] = {\n            n match\
    \ {\n                case Nil => s\n                case x :: Nil => maxRolling(s,\
    \ List(x.toLong))\n                case x :: xs => maxRolling(isMax(x, xs, s),\
    \ xs)\n            }\n        }\n        maxRolling(numbers, Nil)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpis8cpy9f.scala:13:33 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                m.head < x && (s = m :: s)\n\e[31m\e\
    [31m   |\e[0m                               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\e\
    [33mmethod\e[0m \e[35m&&\e[0m in \e[33mclass\e[0m \e[35mBoolean\e[0m: (x: Boolean):\
    \ Boolean does not have a parameter s\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpis8cpy9f.scala:20:48 --------------------\e[0m\e[0m\n\e[31m20 |\e[0m\
    \                \e[33mcase\e[0m x :: xs => maxRolling(isMax(x, xs, s), xs)\n\e\
    [31m\e[31m   |\e[0m                                           ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                           Found:    Boolean\n\
    \e[31m   |\e[0m                                           Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010954
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def rolling(list : List[Long], max: Long, current : Long) : List[Long] =\
    \ {\n            list match {\n                case Nil => List(current)\n   \
    \             case head :: tail => if(head > current) rolling(tail, max, head)\
    \ else rolling(tail, max, current)\n            }\n        }\n        rolling(numbers,\
    \ Int.MaxValue, Int.MaxValue).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdd6_bog5.scala:18)\n\tat Problem.main(tmpdd6_bog5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010957
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val numbersList = numbers.toList\n        val result = new mutable.ListBuffer[Long]()\n\
    \        numbersList.iterator\n                .takeWhile(_ <= numbersList(numbersList.size\
    \ - 1))\n                .foreach(result.add((numbersList(numbersList.length -\
    \ 1))))\n        result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7kmuqkw1.scala:10:25 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     require(numbers.nonEmpty, \"rollingMax requires non-empty list of numbers\"\
    )\n        var result = List[Long]()\n        numberIter(numbers, result)\n  \
    \      result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp16bd1brq.scala:11:8 -------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        numberIter(numbers, result)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Not found: numberIter\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010951
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.ArrayBuffer[Long]()\n        for (n <- numbers) {\n\
    \            if (n.toInt > max.toInt) max += n.toLong\n            else n = max\n\
    \        }\n        list(a.max(a.last, max.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4jpaswd_.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m               \
    \       ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp4jpaswd_.scala:12:19 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33melse\e[0m n = max\n\e[31m\e[31m   |\e\
    [0m                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Reassignment\
    \ to val n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4jpaswd_.scala:14:8\
    \ -------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        list(a.max(a.last,\
    \ max.max))\n\e[31m\e[31m   |\e[0m        ^^^^\e[0m\n\e[31m   |\e[0m        Not\
    \ found: list\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4jpaswd_.scala:14:13\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        list(a.max(a.last,\
    \ max.max))\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e[0m       \
    \      Not found: a\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010951
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty)\n            List()\n        else {\n            val\
    \ list = numbers.tail\n            val currentMax = list.head\n            val\
    \ rollingMax = numbers.toList match {\n                case x :: y :: xs => if\
    \ (x == currentMax) y :: rollingMax\n                     else y :: rollingMax.map(v\
    \ => if (v > currentMax) v else currentMax)\n                case _ => numbers.toList\n\
    \            }\n            rollingMax ++ rollingMax.tail\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpan6oh_vy.scala:15:63 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                \e[33mcase\e[0m x :: y :: xs => \e[33mif\e\
    [0m (x == currentMax) y :: rollingMax\n\e[31m\e[31m   |\e[0m                 \
    \                                              ^\e[0m\n\e[31m   |\e[0m       \
    \                            Recursive \e[33mvalue\e[0m \e[35mrollingMax\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpan6oh_vy.scala:16:31\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m                     \e\
    [33melse\e[0m y :: rollingMax.map(v => \e[33mif\e[0m (v > currentMax) v \e[33melse\e\
    [0m currentMax)\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e\
    [31m   |\e[0m                               Recursive \e[33mvalue\e[0m \e[35mrollingMax\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldRight[List[Long]](List[Long]())((acc, x) => {\n            if\
    \ (acc.last >= x) return acc\n            if (acc contains x) acc :+ x\n     \
    \       else acc :+ acc.last + 1\n        })\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr_jnm_jy.scala:10:20 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mif\e[0m (acc.last >= x) \e[33mreturn\e\
    [0m acc\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \               value last is not a member of Long\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpr_jnm_jy.scala:10:38 --------------------\e[0m\e[0m\n\
    \e[31m10 |\e[0m            \e[33mif\e[0m (acc.last >= x) \e[33mreturn\e[0m acc\n\
    \e[31m\e[31m   |\e[0m                                      ^^^\e[0m\n\e[31m  \
    \ |\e[0m                                      Found:    (acc : Long)\n\e[31m \
    \  |\e[0m                                      Required: List[Long]\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr_jnm_jy.scala:11:20 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            \e[33mif\e[0m (acc contains x) acc :+ x\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \          value contains is not a member of Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpr_jnm_jy.scala:11:36 ------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m            \e[33mif\e[0m (acc contains x) acc :+ x\n\e[31m\e[31m   |\e\
    [0m                                ^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                  value :+ is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpr_jnm_jy.scala:12:21 ------------------------\e[0m\e[0m\n\
    \e[31m12 |\e[0m            \e[33melse\e[0m acc :+ acc.last + \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m                 ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \    value :+ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpr_jnm_jy.scala:12:28 ------------------------\e[0m\e[0m\n\e[31m12 |\e\
    [0m            \e[33melse\e[0m acc :+ acc.last + \e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \         value last is not a member of Long\n6 errors found\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // For each element in the list, generate the maximum (max or rolling max)\n\
    \        // until that moment, then add it to the list and return it.\n      \
    \  numbers.foldLeft(List[Long]())((accumulator, element) => accumulator :+ math.max(element))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpocj797hy.scala:11:85 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        numbers.foldLeft(List[\e[35mLong\e[0m]())((\e\
    [36maccumulator\e[0m, \e[36melement\e[0m) => accumulator :+ math.max(element))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                        ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((element : Long))\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(List[Long]()){\n            (x: mutable.Buffer, n: Long)\
    \ => {\n                if (x.size < n) x ++= List(n.toLong)\n               \
    \ else\n                { val maxEle = x.lastOption.getOrElse(x.size)\n      \
    \              x ++= List(maxEle - 1, maxEle)}\n            }\n        }.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppydqteer.scala:10:16 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            (\e[36mx\e[0m: mutable.Buffer, \e[36mn\e\
    [0m: \e[35mLong\e[0m) => {\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010953
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.PriorityQueue[Long]() //max value found so far\n \
    \       numbers.foreach { n =>\n            max.enqueue(math.max(n, max.head))\n\
    \        }\n        val result = new mutable.PriorityQueue[Long]()\n        number.foreach\
    \ { n =>\n            if (max.size > 0) result.enqueue(math.max(n, max.dequeue))\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjkjr4609.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.PriorityQueue[\e[35mLong\e[0m]() \e[34m//max value found so far\e[0m\n\
    \e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m  |\e[0m       \
    \               Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpjkjr4609.scala:13:25 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.PriorityQueue[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpjkjr4609.scala:14:8 -------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        number.foreach { \e[36mn\e[0m =>\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Not found: number\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010953
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val list = numbers.toList\n        val max = list.max\n        val max =\
    \ list.max\n        val max = list.max\n        val max = list.max\n        val\
    \ max = list.max\n        val max = list.max\n        val max = list.max\n   \
    \     val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        val max = list.max\n\
    \        val max = list.max\n        val max = list.max\n        \n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx99dwqjy.scala:11:12 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = list.max\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax is already\
    \ defined as \e[33mvalue\e[0m \e[35mmax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx99dwqjy.scala:12:12 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = list.max\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax is already\
    \ defined as \e[33mvalue\e[0m \e[35mmax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx99dwqjy.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = list.max\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax is already\
    \ defined as \e[33mvalue\e[0m \e[35mmax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx99dwqjy.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = list.max\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax is already\
    \ defined as \e[33mvalue\e[0m \e[35mmax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx99dwqjy.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = list.max\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax is already\
    \ defined as \e[33mvalue\e[0m \e[35mmax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx99dwqjy.scala:16:12 ---------------------------\e\
    [0"
  stdout: ''
  timestamp: 1660010961
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty) {\n            numbers\n        } else {\n        \
    \    var maxNumbers : List[Long] = List(numbers.head)\n            var currentNumbers\
    \ = List(numbers.tail)\n            var rollingMaxNumber = numbers.head\n\n  \
    \          while (currentNumbers.nonEmpty) {\n                var foundRollingMaxNumber\
    \ = false\n                var rollingMaxIndex = -1\n\n                for (i\
    \ <- 0 until currentNumbers.size) {\n                    if (maxNumbers.exists(number\
    \ => number > currentNumbers(i))) {\n                        if (foundRollingMaxNumber)\
    \ {\n                            maxNumbers = List(currentNumbers(i))\n      \
    \                      foundRollingMaxNumber = false\n                       \
    \ } else {\n                            maxNumbers = maxNumbers.head :: List(currentNumbers(i))\n\
    \                            rollingMaxIndex = i + 1\n                       \
    \     foundRollingMaxNumber = true\n                        }\n              \
    \      }\n                }\n\n                if (!foundRollingMaxNumber) {\n\
    \                    maxNumbers = rollingMaxNumber :: maxNumbers\n           \
    \     }\n\n                currentNumbers = currentNumbers.tail\n            \
    \    rollingMaxNumber = maxNumbers(rollingMaxIndex)\n            }\n\n       \
    \     maxNumbers\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpb9wo43ve.scala:21:59 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    \e[33mif\e[0m (maxNumbers.exists(\e\
    [36mnumber\e[0m => number > currentNumbers(i))) {\n\e[31m\e[31m   |\e[0m     \
    \                                               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35m>\e[0m in \e[33mclass\e\
    [0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m \
    \  |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e\
    [0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x:\
    \ Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments\
    \ (List[Long])\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb9wo43ve.scala:23:60\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                            maxNumbers\
    \ = List(currentNumbers(i))\n\e[31m\e[31m   |\e[0m                           \
    \                   ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                            Found:    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                             \
    \ Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb9wo43ve.scala:26:41\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                            maxNumbers\
    \ = maxNumbers.head :: List(currentNumbers(i))\n\e[31m\e[31m   |\e[0m        \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                         Found:    List[Matchable]\n\
    \e[31m   |\e[0m                                         Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var currentMax = numbers(0)\n        var currentMaxIndex = -1\n\n      \
    \  var maxRolling = 0\n        var maxRollingIndex = 0\n        var maxRollingValue\
    \ = 0\n        var maxRollingIndexValue = 0\n        var rollingValue = 0\n  \
    \      var rollingIndex = 0\n\n        for (i <- 0 until numbers.length) {\n \
    \           rollingIndex = 0\n            currentMaxIndex = i\n\n            for\
    \ (j <- 0 until numbers.length) {\n                if (i != j) {\n           \
    \         rollingValue = numbers(j)\n                    if (rollingValue > currentMax)\
    \ {\n                        currentMax = rollingValue\n                     \
    \   currentMaxIndex = j\n                    }\n                    rollingIndex\
    \ += 1\n                }\n            }\n\n            if (currentMaxIndex !=\
    \ maxRollingIndex) {\n                maxRollingIndex = currentMaxIndex\n    \
    \            maxRollingValue = currentMax\n                maxRollingIndexValue\
    \ = currentMaxIndex\n                rollingValue = currentMax\n             \
    \   rollingIndex = currentMaxIndex\n            } else {\n                rollingIndex\
    \ += 1\n                rollingValue = currentMax\n                rollingIndexValue\
    \ = currentMaxIndex\n                if (rollingValue > maxRollingValue) {\n \
    \                   maxRollingValue = rollingValue\n                    maxRollingIndexValue\
    \ = currentMaxIndex\n                }\n            }\n        }\n\n        return\
    \ numbers(maxRollingIndexValue) ++ rollingValue\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy_6dfq3_.scala:25:42\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                    rollingValue\
    \ = numbers(j)\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Found:    Long\n\e[31m\
    \   |\e[0m                                   Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy_6dfq3_.scala:36:34 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                maxRollingValue = currentMax\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                  Found:    (currentMax : Long)\n\e[31m   |\e\
    [0m                                  Required: Int\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpy_6dfq3_.scala:38:31 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                rollingValue = currentMax\n\e[31m\e[31m\
    \   |\e[0m                               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                           Found:    (currentMax : Long)\n\e[31m   |\e[0m   \
    \                            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpy_6dfq3_.scala:42:31 --------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m                rollingValue = currentMax\n\e[31m\e[31m  \
    \ |\e[0m                               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                         Found:    (currentMax : Long)\n\e[31m   |\e[0m     \
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpy_6dfq3_.scala:43:16 ------------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m                rollingIndexValue = currentMaxIndex\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \       Not found: rollingIndexValue\n\e[31m"
  stdout: ''
  timestamp: 1660010964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = numbers.map(_.toLong).scanLeft(0L)(_ + _).tail\n        val\
    \ rollingMax = maxList.max\n        maxList.map { max =>\n            if (max\
    \ > rollingMax) rollingMax else max\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.rollingMax(tmpgxv02ldo.scala:10)\n\tat Problem$.main(tmpgxv02ldo.scala:16)\n\
    \tat Problem.main(tmpgxv02ldo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010965
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val m = new mutable.HashMap[Long, Int]\n        var rollingMax = List[Long]()\n\
    \        for(i <- numbers ) {\n            val curMax = m.getOrElse(i, -1)\n \
    \           if(curMax == -1) { // first time we encounter this element\n     \
    \           rollingMax:::=i\n                m.put(i, 1)\n            }\n    \
    \        else { // we have not seen the element before and we need to check its\
    \ rollingMax\n                val newMax = Math.max(curMax, i)\n             \
    \   m.put(i, newMax)\n                if(newMax > rollingMax.last) {\n       \
    \             rollingMax:::=newMax\n                }\n            }\n       \
    \ }\n        rollingMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx274pqxc.scala:9:20 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]\n\e[31m\e[31m  |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                    Not found: mutable\n\e[31m  |\e[0m\n\e\
    [31m  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpx274pqxc.scala:14:26 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                rollingMax:::=i\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value :::= is not a member\
    \ of List[Long] - did you mean List[Long].:::?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010962
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.map(_ => (numbers.reduceLeftOption(_ > _).getOrElse(0L),\
    \ numbers)).groupBy(x => x(0)).mapValues(x => x.map(y => (y(1), y(2)))).mapValues(x\
    \ => x.map(_._1).max).toList\n        rollingMax.map(_._2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphfooddzm.scala:9:68\
    \ ---------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e\
    [0m = numbers.map(_ => (numbers.reduceLeftOption(_ > _).getOrElse(\e[31m0L\e[0m),\
    \ numbers)).groupBy(\e[36mx\e[0m => x(\e[31m0\e[0m)).mapValues(\e[36mx\e[0m =>\
    \ x.map(\e[36my\e[0m => (y(\e[31m1\e[0m), y(\e[31m2\e[0m)))).mapValues(\e[36mx\e\
    [0m => x.map(_._1).max).toList\n\e[31m\e[31m  |\e[0m                         \
    \                                           ^^^^^\e[0m\n\e[31m  |\e[0m       \
    \                                                  Found:    Boolean\n\e[31m \
    \ |\e[0m                                                         Required: Long\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmphfooddzm.scala:9:153 -----------------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = numbers.map(_\
    \ => (numbers.reduceLeftOption(_ > _).getOrElse(\e[31m0L\e[0m), numbers)).groupBy(\e\
    [36mx\e[0m => x(\e[31m0\e[0m)).mapValues(\e[36mx\e[0m => x.map(\e[36my\e[0m =>\
    \ (y(\e[31m1\e[0m), y(\e[31m2\e[0m)))).mapValues(\e[36mx\e[0m => x.map(_._1).max).toList\n\
    \e[31m\e[31m  |\e[0m                                                         \
    \                                                                            \
    \                    ^\e[0m\n\e[31m  |\e[0m        Match type reduction failed\
    \ since selector  EmptyTuple.type\n\e[31m  |\e[0m        matches none of the cases\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m            case x *: xs => (\e[31m0\e[0m : Int)\e\
    [33m match \e[0m{\n\e[31m  |\e[0m          case (\e[31m0\e[0m : Int) => x\n\e\
    [31m  |\e[0m          case scala.compiletime.ops.int.S[n1] => scala.Tuple.Elem[xs,\
    \ n1]\n\e[31m  |\e[0m        }\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphfooddzm.scala:10:25\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        rollingMax.map(_._2)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                Found:    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e\
    [0m\n\e[31m   |\e[0m                       Required: Long\n\e[31m  "
  stdout: ''
  timestamp: 1660010968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def rollingMaxHelper(numbers: List[Long], max: Long, prev: List[Long], result:\
    \ List[Long]) : List[Long] = {\n            if (numbers.isEmpty) {\n         \
    \       result\n            } else {\n                val x = numbers.head\n \
    \               if (prev.isEmpty || x > prev) {\n                    rollingMaxHelper(numbers.tail,\
    \ max, List(numbers(0)), result :+ max)\n                } else {\n          \
    \          rollingMaxHelper(numbers.tail, max, List(max), result :+ x)\n     \
    \           }\n            }\n        }\n        rollingMaxHelper(numbers, numbers(0),\
    \ numbers.init, List.empty)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpuxnuh2x9.scala:14:38 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                \e[33mif\e[0m (prev.isEmpty || x > prev)\
    \ {\n\e[31m\e[31m   |\e[0m                                    ^^^\e[0m\n\e[31m\
    \   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m>\e[0m\
    \ in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\
    \e[31m   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m\
    \   |\e[0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m   |\e\
    [0mmatch arguments ((prev : List[Long]))\n1 error found\n"
  stdout: ''
  timestamp: 1660010961
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val numbersWithMax = numbers.foldLeft(List[Long]()){case (numbers, i) =>\
    \ if (numbers(numbers.size - 1) < i) numbers :+ i else numbers}\n        val numbersWithMaxSize\
    \ = numbersWithMax.size\n        val max = numbersWithMax.last\n        val maxSize\
    \ = numbersWithMaxSize - 1\n        val numbersRolled = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < maxSize) {\n            numbersRolled +=\
    \ numbersWithMax(i).abs\n            i += 1\n        }\n        numbersRolled.take(maxSize).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: last of empty list\n\tat scala.collection.immutable.Nil$.last(List.scala:665)\n\
    \tat scala.collection.immutable.Nil$.last(List.scala:661)\n\tat Problem$.rollingMax(tmpgzx99q9e.scala:11)\n\
    \tat Problem$.main(tmpgzx99q9e.scala:22)\n\tat Problem.main(tmpgzx99q9e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010970
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     require(numbers contains numbers.length, \"The rolling max number list must\
    \ contain its length\")\n        require(numbers contains numbers.head, \"The\
    \ rolling max number list must contain its head\")\n        require(numbers contains\
    \ numbers.tail, \"The rolling max number list must contain its tail\")\n     \
    \   var max = 0l\n        numbers.foreach { number =>\n            val currentMax\
    \ = Math.max(max, number)\n            max = (currentMax + 1).toLong\n       \
    \ }\n        numbers.reverse.takeWhile(number => max < number).toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IllegalArgumentException: requirement failed: The rolling max\
    \ number list must contain its length\n\tat scala.Predef$.require(Predef.scala:337)\n\
    \tat Problem$.rollingMax(tmpd0suueu8.scala:9)\n\tat Problem$.main(tmpd0suueu8.scala:20)\n\
    \tat Problem.main(tmpd0suueu8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxSoFar = -1L\n        var rollingMaxSoFar = -1L\n        var rollingMax\
    \ = List[Long]()\n        var rollingMaxIndex = List[Int]()\n        numbers.foreach(x\
    \ => {\n            rollingMaxSoFar = x\n            if (x > maxSoFar) {\n   \
    \             maxSoFar = x\n            }\n            rollingMaxIndex += 1 //\
    \ update max index\n            rollingMax = rollingMax.toList :+ maxSoFar\n \
    \       })\n        rollingMaxIndex.toList.map(x => rollingMax(x)) // return list\
    \ of rolling max\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgmwu9udm.scala:18:28 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            rollingMaxIndex += \e[31m1\e[0m \e[34m//\
    \ update max index\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m      value += is not a member of List[Int] - did you mean\
    \ List[Int].!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = 0L\n        val ret: List[Long] = numbers.map { n =>\n       \
    \     if (max <= n) max = n\n            n else 0L\n        }\n        return\
    \ ret.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp9zzmrfdk.scala:12:14 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            n \e[33melse\e[0m \e[31m0L\e[0m\n\e[31m\e\
    [31m   |\e[0m              ^^^^\e[0m\n\e[31m   |\e[0m              end of statement\
    \ expected but 'else' found\n1 error found\n"
  stdout: ''
  timestamp: 1660010960
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = numbers.head\n        var maxIndex = numbers.lastIndex\n     \
    \   numbers.tail.foreach {\n            if (_ > max) {\n                max =\
    \ _\n                maxIndex = _\n            }\n        }\n        if (maxIndex\
    \ - numbers.lastIndex < maxIndex) {\n            numbers = numbers.init :+ max\n\
    \        }\n        numbers :+ max\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaqjhe_6q.scala:10:31 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mvar\e[0m \e[36mmaxIndex\e[0m = numbers.lastIndex\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue lastIndex is not a member of List[Long] - did you mean numbers.lastIndexOf?\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmpaqjhe_6q.scala:12:16 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33mif\e[0m (_ > max) {\n\e[31m\e[31m \
    \  |\e[0m                ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$1\
    \ of expanded function:\n\e[31m   |\e[0m   _$1 => _$1 > max.\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmpaqjhe_6q.scala:13:22 -----------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m                max = _\n\e[31m\e[31m   |\e[0m           \
    \           ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m   I could not infer the type of the parameter _$2 of expanded\
    \ function:\n\e[31m   |\e[0m   _$2 => max = _$2.\n\e[31m\e[31m-- [E081] Type Error:\
    \ /tmp/tmpaqjhe_6q.scala:14:27 -----------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m                maxIndex = _\n\e[31m\e[31m   |\e[0m                  \
    \         ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m   I could not infer the type of the parameter _$3 of expanded function:\n\
    \e[31m   |\e[0m   _$3 => maxIndex = _$3.\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpaqjhe_6q.scala:18:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            numbers\
    \ = numbers.init :+ max\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val numbers\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660010968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMaxValues = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { x =>\n            rollingMaxValues.append(rollingMaxValues(rollingMaxValues.size-1))\n\
    \        }\n        rollingMaxValues.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp64ipwl4l.scala:9:31 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMaxValues\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                               ^^^^^^^\e[0m\n\
    \e[31m  |\e[0m                               Not found: mutable\n\e[31m  |\e[0m\n\
    \e[31m  |\e[0m longer explanation available when compiling with `-explain`\n1\
    \ error found\n"
  stdout: ''
  timestamp: 1660010965
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def maxRoll(list: List[Long], acc: Long) : Long = {\n            if (list.isEmpty)\
    \ acc\n            else {\n                val max = math.max(list._1, acc)\n\
    \                list.tail.tail.foreach(x => acc += x)\n                if (max\
    \ < acc) max else maxRoll(list.tail, acc)\n            }\n        }\n        numbers.tail.init.reverse.map(x\
    \ => maxRoll(numbers.init, x)).reverse.drop(numbers.size - 1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn_uegm04.scala:12:40 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m                \e[33mval\e[0m \e[36mmax\e[0m = math.max(list._1,\
    \ acc)\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  value _1 is not a member of List[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn_uegm04.scala:13:48 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                list.tail.tail.foreach(\e[36mx\e[0m =>\
    \ acc += x)\n\e[31m\e[31m   |\e[0m                                           \
    \ ^^^^^^\e[0m\n\e[31m   |\e[0m                 value += is not a member of Long\
    \ - did you mean acc.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result: List[Long] = Nil\n        val map = mutable.HashMap[Long, Long]()\n\
    \n        numbers foreach { n =>\n            if (map.contains(n)) {\n       \
    \         val previous = map.get(n)\n                map.put(n, previous + 1)\n\
    \            } else {\n                map.put(n, 1L)\n            }\n       \
    \ }\n\n        numbers.foldLeft(map)((acc: Map[Long, Long], n: Long) => {\n  \
    \          if (acc.contains(n)) {\n                val previous = acc.get(n)\n\
    \                acc.put(n, previous + 1)\n            } else {\n            \
    \    acc.put(n, 1L)\n            }\n        })\n\n        acc flatMap {\n    \
    \        case (k, v) =>\n                if (k > v) {\n                    v\n\
    \                } else {\n                    Nil\n                }\n      \
    \  } toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp10vfzv9b.scala:37:16 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        } toList\n\e[31m\e[31m   |\e[0m             \
    \   ^\e[0m\n\e[31m   |\e[0m                expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp10vfzv9b.scala:10:18\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mmap\e[0m = mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp10vfzv9b.scala:24:36\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                acc.put(n,\
    \ previous + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of Option[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp10vfzv9b.scala:30:8 -------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        acc flatMap {\n\e[31m\e[31m   |\e[0m        ^^^\e\
    [0m\n\e[31m   |\e[0m        Not found: acc\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var curr = numbers(0)\n        numbers.tail.foreach { n =>\n           \
    \ if (curr < n) curr = n\n            else numbers = numbers :+ n\n        }\n\
    \        numbers :+ curr\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp2mq20j48.scala:12:25 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33melse\e[0m numbers = numbers :+ n\n\e\
    [31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                 Reassignment to val numbers\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxIndex = numbers.lastIndex\n        if (maxIndex == -1) numbers else\
    \ numbers.drop(maxIndex).map(x => numbers.takeWhile(y => y > x).max)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprtct7cmx.scala:9:31 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = numbers.lastIndex\n\
    \e[31m\e[31m  |\e[0m                       ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0mvalue lastIndex is not a member of List[Long] - did you mean numbers.lastIndexOf?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val res = new ListBuffer[Long]()\n        var max = 0\n        for {\n \
    \           n <- numbers\n        } max += n\n\n        while (max < numbers.length)\
    \ {\n            max += numbers.length\n            res += numbers(max)\n    \
    \    }\n\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpozkpvge5.scala:13:14 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        } max += n\n\e[31m\e[31m   |\e[0m          ^^^^^^\e\
    [0m\n\e[31m   |\e[0m          value += is not a member of Int - did you mean Int.!=?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpozkpvge5.scala:20:8 ---------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        res\n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e\
    [31m   |\e[0m        Found:    (res : scala.collection.mutable.ListBuffer[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty) List(1l.toLong)\n        else {\n            var max\
    \ = 0L\n            var rollingMax: Option[Long] = None\n            for (x <-\
    \ numbers) {\n                if (x > max) max = x\n                else {\n \
    \                   if (rollingMax.isEmpty) rollingMax = x\n                 \
    \   else rollingMax = Some(rollingMax.get + x)\n                }\n          \
    \  }\n            rollingMax.get\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6_le4rg2.scala:16:57\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m                    \e[33mif\e\
    [0m (rollingMax.isEmpty) rollingMax = x\n\e[31m\e[31m   |\e[0m               \
    \                                          ^\e[0m\n\e[31m   |\e[0m           \
    \                                       Found:    (x : Long)\n\e[31m   |\e[0m\
    \                                                  Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6_le4rg2.scala:20:23\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            rollingMax.get\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  Found:    Long\n\e[31m   |\e[0m            Required: \e[1m\e[32mList\e[0m\e\
    [1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010973
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var current = List[Long]()\n        var max = 0l\n        numbers.foreach\
    \ {n =>\n            var newMax = math.max(max, n)\n            current = current\
    \ :+ newMax\n            max = newMax\n        }\n        current\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = 0L\n        var rollMax = 0L\n        var rollMaxIndex = 0L\n\
    \        var rollMaxIndexList = List[Long]()\n        var maxIndex = 0L\n\n  \
    \      numbers.foreach { number =>\n            if (number > max) {\n        \
    \        max = number\n                maxIndex = number\n                rollMaxIndexList.clear()\n\
    \                rollMaxIndexList.push(number)\n                rollMaxIndex =\
    \ 0L\n            } else if (number == max) {\n                rollMaxIndexList.push(number)\n\
    \                rollMaxIndex += 1\n                rollMaxIndexList.push(number)\n\
    \            } else {\n                if (rollMaxIndexList.contains(maxIndex\
    \ - rollMax)) {\n                    rollMaxIndexList.clear()\n              \
    \      rollMaxIndexList.push(maxIndex)\n                    rollMaxIndex += 1\n\
    \                    rollMaxIndexList.push(maxIndex)\n                }\n    \
    \        }\n        }\n        rollMaxIndexList.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8vyvqabd.scala:19:33 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                rollMaxIndexList.clear()\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue clear\
    \ is not a member of List[Long] - did you mean List[Long].clone?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp8vyvqabd.scala:20:33 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                rollMaxIndexList.push(number)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ push is not a member of List[Long] - did you mean List[Long].last?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp8vyvqabd.scala:23:33 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                rollMaxIndexList.push(number)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ push is not a member of List[Long] - did you mean List[Long].last?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp8vyvqabd.scala:25:33 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                rollMaxIndexList.push(number)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ push is not a member of List[Long] - did you mean List[Long].last?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp8vyvqabd.scala:28:37 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    rollMaxIndexList.clear()\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ clear is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8vyvqabd.scala:29:37\
    \ ---------"
  stdout: ''
  timestamp: 1660010978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val currentMax = numbers.reduceLeftOption(_ > _).getOrElse(-1L)\n      \
    \  numbers.reverse.map { n =>\n            if (n < currentMax) {\n           \
    \     currentMax = n\n                n\n            } else {\n              \
    \  currentMax\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl8h8ro_k.scala:9:50\
    \ ---------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mcurrentMax\e\
    [0m = numbers.reduceLeftOption(_ > _).getOrElse(-\e[31m1L\e[0m)\n\e[31m\e[31m\
    \  |\e[0m                                                  ^^^^^\e[0m\n\e[31m\
    \  |\e[0m                                                  Found:    Boolean\n\
    \e[31m  |\e[0m                                                  Required: Long\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpl8h8ro_k.scala:12:27 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m                currentMax = n\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val currentMax\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val l = numbers.asInstanceOf[mutable.WrappedArray[Long]]\n        val maxIndexes\
    \ = mutable.ListBuffer[Int]()\n\n        def rollingMaxHelper(i : Int) : List[Long]\
    \ = {\n            if (i >= l.length) {\n                maxIndexes += i\n   \
    \             return l\n            }\n            val current = l(i)\n      \
    \      val index = i\n            val leftIndexes = maxIndexes ++ List(index -\
    \ 1)\n\n            val leftMaxs = rollingMaxHelper(index)\n            val rightMaxs\
    \ = rollingMaxHelper(index + 1)\n            val leftMax = leftMaxs.max\n    \
    \        val rightMax = rightMaxs.max\n\n            val leftGreaterThanRight\
    \ = current > rightMax\n            if (leftGreaterThanRight) leftMaxs else rightMaxs\n\
    \        }\n\n        rollingMaxHelper(0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpevocmony.scala:9:37 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = numbers.asInstanceOf[mutable.WrappedArray[\e\
    [35mLong\e[0m]]\n\e[31m\e[31m  |\e[0m                                     ^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                                     Not found: mutable\n\e\
    [31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpevocmony.scala:10:25\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxIndexes\e[0m = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = -math.inf\n        for(i <- numbers) {\n            if (max <\
    \ i) max = i\n        }\n        numbers.foldLeft(List[Long]())((l, number) =>\
    \ l.head == number ? l :+ number)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbos6cxgl.scala:9:24 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mvar\e[0m \e[36mmax\e[0m = -math.inf\n\e\
    [31m\e[31m  |\e[0m                   ^^^^^^^^\e[0m\n\e[31m  |\e[0m           \
    \        value inf is not a member of math\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpbos6cxgl.scala:13:71 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        numbers.foldLeft(List[\e[35mLong\e[0m]())((\e[36ml\e[0m, \e[36mnumber\e\
    [0m) => l.head == number ? l :+ number)\n\e[31m\e[31m   |\e[0m               \
    \                                                 ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                         value ? is not a member of Long\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxs = mutable.ListBuffer.empty[Long]\n        numbers foreach { x =>\n\
    \            while (true) {\n                x match {\n                    case\
    \ 3 => maxs += x.toLong\n                    case 2 => maxs += x.toLong\n    \
    \                case 1 => maxs += x.toLong\n                    case 0 => break\n\
    \                    case _ => x -= 1\n                }\n            }\n    \
    \    }\n        maxs.toList\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbcqtwpri.scala:9:19 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxs\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                   ^^^^^^^\e[0m\n\e[31m  |\e\
    [0m                   Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpbcqtwpri.scala:16:30 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m                    \e[33mcase\e[0m \e[31m0\e[0m => break\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpbcqtwpri.scala:17:32 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                    \e[33mcase\e[0m _ => x -= \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e\
    [0m                   value -= is not a member of Long - did you mean x.!=?\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) List(1l.toLong)\n        else {\n            val\
    \ maxIndex = numbers.length - 1\n            val maxValue = numbers.last\n   \
    \         var currentMax = maxValue\n            var currentIndex = 0\n      \
    \      val result = new mutable.ArrayBuffer(maxValue)\n            var i = 0\n\
    \            for (i <- numbers.indices){\n                if (i < maxIndex) {\n\
    \                    currentMax = numbers(i)\n                    currentIndex\
    \ = i\n                }\n                if (currentMax < maxValue) {\n     \
    \               result.synchronized {\n                        result += currentMax\n\
    \                        currentMax = numbers(currentIndex)\n                \
    \    }\n                    currentIndex = currentIndex + 1\n                }\n\
    \            }\n            result.synchronized {\n                result += currentMax\n\
    \            }\n            result.toList\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppyp61314.scala:15:29 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer(maxValue)\n\e[31m\e[31m   |\e[0m                     \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010976
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var currentMax = 0\n        var maxIndex = 0\n        var maxRolling = List[Long]()\n\
    \        for (i <- 0 until numbers.length) {\n            if (maxIndex < i) {\n\
    \                currentMax = numbers(i)\n                maxIndex = 0\n     \
    \       } else {\n                if (currentMax > numbers(i)) {\n           \
    \         maxIndex = i + 1\n                    maxRolling = (numbers(maxIndex)\
    \ :: maxRolling)\n                    currentMax = numbers(i)\n              \
    \  } else {\n                    maxIndex = i\n                }\n           \
    \ }\n        }\n        maxRolling\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsexyoc0q.scala:14:36\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m                currentMax =\
    \ numbers(i)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             Found:    Long\n\e[31m   |\e[0m  \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpsexyoc0q.scala:20:40 --------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m                    currentMax = numbers(i)\n\e[31m\e[31m\
    \   |\e[0m                                 ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                               Found:    Long\n\e[31m   |\e[0m              \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(List[Long]())(\n            (l: List[Long], n: Long) =>\
    \ {\n                if (l.length < 5) {\n                    l.updated(l.length,\
    \ n)\n                } else {\n                    val l2 = l.drop(l.length -\
    \ 1).drop(1)\n                    l2.max(n) :: l\n                }\n        \
    \    })\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa0w4g6sw.scala:15:27\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m                    l2.max(n)\
    \ :: l\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m\
    \                           Found:    (n : Long)\n\e[31m   |\e[0m            \
    \               Required: Ordering[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max: Long = numbers(0)\n        var result: List[Long] = List()\n\n\
    \        numbers match {\n            case x :: tail =>\n                x.toLong\
    \ match {\n                    case max: Long =>\n                        result\
    \ = x :: result\n                    case max =>\n                        max\
    \ = x\n                }\n\n                rollingMax(tail) match {\n       \
    \             case x :: tail =>\n                        max == x.toLong match\
    \ {\n                            case true =>\n                              \
    \  result = x :: result\n                            case false =>\n         \
    \                       rollingMax(tail)\n                        }\n        \
    \            case _ =>\n                        result\n                }\n  \
    \          case Nil =>\n                result\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp51fc_0fk.scala:18:28 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                        max = x\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \ Reassignment to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp51fc_0fk.scala:25:39 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                                result = x :: result\n\e[31m\e[31m   |\e\
    [0m                                ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                Found:    Unit\n\e[31m   |\e[0m             \
    \                   Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.toList.tail.reverse.foldLeft(List[Long]())((max, element) => {\n\
    \            val last = max.last\n            val currMax = last match {\n   \
    \             case None =>\n                    element\n                case\
    \ _ =>\n                    if (element > last) element else last\n          \
    \  }\n            val newMax = currMax :: max\n            newMax\n        })\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvot0h6w9.scala:12:21\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m                \e[33mcase\e\
    [0m None =>\n\e[31m\e[31m   |\e[0m                     ^^^^\e[0m\n\e[31m   |\e\
    [0m                     Found:    None.type\n\e[31m   |\e[0m                 \
    \    Required: Long\n\e[31m   |\e[0m                     pattern type is incompatible\
    \ with expected type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var res = ListBuffer[Long]()\n        var max = 0L\n        numbers.foreach{\
    \ n =>\n            if(n <= max) {\n                max = n\n                res\
    \ = res :+ max\n            }\n        }\n        return res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqg4onh06.scala:17:15\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mreturn\e[0m res\n\
    \e[31m\e[31m   |\e[0m               ^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    (res : scala.collection.mutable.ListBuffer[Long])\n\e[31m   |\e[0m      \
    \       Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMaxList = mutable.ListBuffer[Long]()\n        for (i <- 0 until\
    \ numbers.length) {\n            val current = numbers(i)\n            rollingMaxList\
    \ += current\n            for (j <- 0 until rollingMaxList.length) {\n       \
    \         if (current > rollingMaxList(j)) {\n                    rollingMaxList(j)\
    \ = current\n                }\n            }\n        }\n        rollingMaxList.take(numbers.length)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp790n31za.scala:9:29 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMaxList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m  |\e[0m                             Not found: mutable\n\e[31m  |\e[0m\n\
    \e[31m  |\e[0m longer explanation available when compiling with `-explain`\n1\
    \ error found\n"
  stdout: ''
  timestamp: 1660010981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max: mutable.Map[Int, Long] = new mutable.HashMap[Int, Long]\n     \
    \   var maxIndex = -1L\n        numbers.foreach { n =>\n            if (max.containsKey(n))\
    \ {\n                max.put(maxIndex, n)\n            } else {\n            \
    \    if (maxIndex != -1) {\n                    maxIndex += 1\n              \
    \      max.put(maxIndex, numbers.last)\n                }\n                maxIndex\
    \ = -1L\n            }\n        }\n        if (maxIndex != -1L) {\n          \
    \  maxIndex += 1\n            max.put(maxIndex, numbers.last)\n        }\n   \
    \     max.toList.sortBy(_._2).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprxzy7tcu.scala:9:17 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m: mutable.Map[\e\
    [35mInt\e[0m, \e[35mLong\e[0m] = \e[33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m,\
    \ \e[35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                 ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                 Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmprxzy7tcu.scala:9:46 -------------------------\e[0m\e\
    [0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m: mutable.Map[\e[35mInt\e\
    [0m, \e[35mLong\e[0m] = \e[33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mLong\e\
    [0m]\n\e[31m\e[31m  |\e[0m                                              ^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                                              Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010982
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val m = numbers.head\n        var current = numbers.tail.max\n        numbers\
    \ match {\n            case head :: tail => {\n                val max = tail.max\n\
    \                if (current < max) head :: rollingMax(tail)\n               \
    \ else rollingMax(tail)\n            }\n            case _ => List(current)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.rollingMax(tmpv14sbtbf.scala:9)\n\
    \tat Problem$.main(tmpv14sbtbf.scala:21)\n\tat Problem.main(tmpv14sbtbf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        numbers.foreach { number\
    \ =>\n            number match {\n                case x if x >= result.last.max\
    \ => result.last :+ x\n                case x => result :+ x\n            }\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpak9_1o25.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m              \
    \           ^^^^^^^\e[0m\n\e[31m  |\e[0m                         Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = numbers(0)\n        val max_max_so_far = numbers.tail.foldLeft(0l){\
    \ (a,b) => if (a > b) a else b}\n        val max_in_tail = numbers.tail.foldLeft(0l){\
    \ (a,b) => if (a > b) a else b}\n        val min_max_so_far = numbers.head.foldLeft(0l){\
    \ (a,b) => if (a > b) a else b}\n        val min_max_in_head = numbers.head.foldLeft(0l){\
    \ (a,b) => if (a > b) a else b}\n\n        numbers.drop(1).sliding(2).collect\
    \ {\n            x => if (x == max_max_so_far) max_in_tail else if (x == max_max_so_far\
    \ - max_in_tail) max else if (x == max_max_so_far - min_max_so_far) max_in_tail\
    \ else if (x == max_max_so_far - min_max_so_far - max_in_tail) max else min_max_in_head\n\
    \        }.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp721_1y3g.scala:12:42 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mmin_max_so_far\e[0m = numbers.head.foldLeft(\e\
    [31m0l\e[0m){ (\e[36ma\e[0m,\e[36mb\e[0m) => \e[33mif\e[0m (a > b) a \e[33melse\e\
    [0m b}\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value foldLeft is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp721_1y3g.scala:13:43\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mmin_max_in_head\e[0m = numbers.head.foldLeft(\e[31m0l\e[0m){ (\e[36ma\e[0m,\e\
    [36mb\e[0m) => \e[33mif\e[0m (a > b) a \e[33melse\e[0m b}\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                             value foldLeft is not a member of Long\n\e[31m\e\
    [31m-- Error: /tmp/tmp721_1y3g.scala:16:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[36mx\e[0m => \e[33mif\e[0m (x == max_max_so_far)\
    \ max_in_tail \e[33melse\e[0m \e[33mif\e[0m (x == max_max_so_far - max_in_tail)\
    \ max \e[33melse\e[0m \e[33mif\e[0m (x == max_max_so_far - min_max_so_far) max_in_tail\
    \ \e[33melse\e[0m \e[33mif\e[0m (x == max_max_so_far - min_max_so_far - max_in_tail)\
    \ max \e[33melse\e[0m min_max_in_head\n\e[31m\e[31m   |\e[0m                 \
    \    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types List[Long] and\
    \ Long cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp721_1y3g.scala:16:63\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m16 |\e[0m       \
    \     \e[36mx\e[0m => \e[33mif\e[0m (x == max_max_so_far) max_in_tail \e[33melse\e\
    [0m \e[33mif\e[0m (x == max_max_so_far - max_in_tail) max \e[33melse\e[0m \e[33mif\e\
    [0m (x == max_max_so_far - min_max_so_far) max_in_tail \e[33melse\e[0m \e[33mif\e\
    [0m (x == max_max_so_far - min_max_so_far - max_in_tail) max \e[33melse\e[0m min_max_in_head\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types\
    \ List[Long] and Long cannot be comp"
  stdout: ''
  timestamp: 1660010991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val nums = numbers.toList\n        val result = mutable.ArrayBuffer.empty[Long]\n\
    \        val window = nums.head\n        nums.reverse.tail.foreach(num => {\n\
    \            var maxNum = num\n            while (num > window) {\n          \
    \      maxNum = num - maxNum\n            }\n            val value = result.length\n\
    \            if (value > 0 && result(value-1) > maxNum) {\n                result.update(value-1,\
    \ maxNum)\n            }\n        })\n        result.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1ggvb075.scala:10:21 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val ret = new mutable.ListBuffer[Long]()\n        for (i <- numbers) {\n\
    \            val lastRet = ret.toList.reverse.tail.last\n            val next\
    \ = i + lastRet\n            if (next > numbers(0))\n                ret.append(next)\n\
    \        }\n        return ret.toList.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiwrkbfu2.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mret\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                \
    \      ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found: mutable\n\e\
    [31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty) return List()\n        numbers.reverse.foldLeft(numbers.reverse.maxBy(_.toLong).asInstanceOf[Long])((max,\
    \ x) =>\n            if (x <= max) x else max)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpacrgf7hh.scala:10:84\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        numbers.reverse.foldLeft(numbers.reverse.maxBy(_.toLong).asInstanceOf[\e\
    [35mLong\e[0m])((\e[36mmax\e[0m, \e[36mx\e[0m) =>\n\e[31m\e[31m   |\e[0m     \
    \   ^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m11 |\e[0m\
    \            \e[33mif\e[0m (x <= max) x \e[33melse\e[0m max)\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Create a mutable list to hold rolling max\n        var maxRolling : mutable.Buffer[Long]\
    \ = mutable.Buffer.empty\n\n        // Start with largest element in the list\n\
    \        var largestNum = numbers(0)\n        // Keep iterating the numbers and\
    \ find the rolling max\n        for (i <- 1 to numbers.size)\n        {\n    \
    \        // If the current number is the largest so far, then add to list\n  \
    \          if (numbers(i) > largestNum)\n            {\n                maxRolling\
    \ = maxRolling.+(largestNum)\n                largestNum = numbers(i)\n      \
    \      }\n        }\n\n        // Return the max rolling number list\n       \
    \ maxRolling.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_awno6pi.scala:10:25 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mvar\e[0m \e[36mmaxRolling\e[0m : mutable.Buffer[\e\
    [35mLong\e[0m] = mutable.Buffer.empty\n\e[31m\e[31m   |\e[0m                 \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_awno6pi.scala:10:48\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mvar\e[0m \e\
    [36mmaxRolling\e[0m : mutable.Buffer[\e[35mLong\e[0m] = mutable.Buffer.empty\n\
    \e[31m\e[31m   |\e[0m                                                ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010988
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val buffer = new mutable.ListBuffer[Long]()\n        numbers.foreach( x\
    \ => { if (x < buffer.last) buffer :+= x else buffer.lastOption match {\n    \
    \        case Some(x) => buffer :+= x\n            case None => buffer.last }})\n\
    \        buffer.reverse.foldLeft(List[Long]())( (a,b) => b:: a).reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt7iv09g8.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mbuffer\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m              \
    \           ^^^^^^^\e[0m\n\e[31m  |\e[0m                         Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010987
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Rolling maximum starts at zero (0)\n        val maxes = new mutable.ListBuffer[Long]()\n\
    \        var max = 0\n\n        // Rolling maximum found\n        for (number\
    \ <- numbers) {\n            if (number > max) {\n                max = number\n\
    \                maxes += number\n            } else if (number == max) {\n  \
    \              maxes += number\n            }\n        }\n\n        // Rolling\
    \ maximum found\n        val result = maxes.toList\n        if (maxes.size ==\
    \ 1)\n            result\n        else\n            rollingMax(result)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6ki54bde.scala:10:24 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mmaxes\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6ki54bde.scala:16:22\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m                max = number\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                Found:    (number : Long)\n\e[31m   |\e[0m                  \
    \    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def generateMax(x: Int, numbers: List[Long], result: List[Long]): List[Long]\
    \ = {\n            if (x == numbers.size) {\n                result:::numbers.reverse\n\
    \            } else {\n                generateMax(x+1, numbers, generateMax(x,\
    \ numbers, result))\n            }\n        }\n        generateMax(0, numbers,\
    \ Nil)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\
    \tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpii"
  stdout: ''
  timestamp: 1660010996
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = new mutable.ArrayBuffer[Long]()\n        var max = 0L\n   \
    \     var temp = 0L\n        for (i <- 0 until numbers.size - 1) {\n         \
    \   temp = 0L\n            max = numbers(i)\n            if (temp > max)\n   \
    \             max = temp\n            result += max :: Nil\n        }\n      \
    \  result.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9srn56gf.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m  |\e[0m                         Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val listMax = numbers.foldLeft(List[Long]()) ((l, v) => v :: l)\n      \
    \  val maxIndex = listMax.length\n        val result: List[Long] = new mutable.MutableList[Long]()\n\
    \        for (i <- 0 until maxIndex) {\n            val index = i \n         \
    \   val sum = numbers(index).foldLeft(0l) { \n                case (v, acc) =>\
    \ acc + v \n            }\n            result += (sum / numbers(index))\n    \
    \    }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb3nwldze.scala:11:37 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = \e[33mnew\e[0m mutable.MutableList[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb3nwldze.scala:14:37 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36msum\e[0m = numbers(index).foldLeft(\e\
    [31m0l\e[0m) { \n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value foldLeft is not a member of Long\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb3nwldze.scala:17:19 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            result += (sum / numbers(index))\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not\
    \ a member of List[Long] - did you mean result.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010998
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft((List[Long](), numbers.head)) {\n            case ((current,\
    \ max), i) =>\n                val newMax = max max i\n                val newCurrent\
    \ = (current :+ i, newMax)\n                (newCurrent, newMax)\n        }._1.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpczgzfdyn.scala:13:17\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m                (newCurrent,\
    \ newMax)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                 Found:    (newCurrent : (List[Long], Long))\n\e[31m   |\e\
    [0m                 Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010996
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def rollingMaxRecursively(numbers: List[Long], i: Int, j : Int, result :\
    \ List[Long]): List[Long] = {\n            if (i >= j)\n                result\n\
    \            else\n                rollingMaxRecursively(numbers, i + 1, j, result\
    \ :+ max(numbers(i), numbers(i + 1)))\n        }\n\n        val n = numbers.size\n\
    \        rollingMaxRecursively(numbers, 0, 0, List.empty[Long])\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt4q4ezde.scala:21)\n\tat Problem.main(tmpt4q4ezde.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660011002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var current = List[Long](numbers(0))\n        var max = [Long](numbers(0),\
    \ numbers(0), numbers(0))\n        // Roll until maximum value is found\n    \
    \    for(i <- 1 until numbers.size)\n            for(j \u2190 0 until 3) {\n \
    \               if(j == 0)\n                    current = numbers(i)\n       \
    \         else {\n                    val newMax = current((j-1).toInt) + (current((j).toInt)-current((j-1).toInt))\n\
    \                    if(newMax > max(0))\n                        max = (max(0),\
    \ max(1), max(2))\n                    current = newMax\n                }\n \
    \           }\n        numbers.size\n            match max {\n               \
    \ case x :: y :: z :: _ => x :: y :: z :: rollingMax(numbers.filter(_ != x))\n\
    \                case x :: y :: _ => x :: rollingMax(numbers.filter(_ != x))\n\
    \                case x :: _ => x\n            }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7m6umtne.scala:10:24 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mvar\e[0m \e[36mmax\e[0m = [Long](numbers(\e\
    [31m0\e[0m), numbers(\e[31m0\e[0m), numbers(\e[31m0\e[0m))\n\e[31m\e[31m   |\e\
    [0m                        ^\e[0m\n\e[31m   |\e[0m                        '=>'\
    \ expected, but '(' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7m6umtne.scala:24:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mmatch\e\
    [0m max {\n\e[31m\e[31m   |\e[0m                  ^^^\e[0m\n\e[31m   |\e[0m  \
    \                '{' expected, but identifier found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmp7m6umtne.scala:38:0 ----------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7m6umtne.scala:15:37\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m                    current =\
    \ numbers(i)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    Long\n\e[31m   |\e\
    [0m                              Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e\
    [0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmp7m6umtne.scala:18:32 -----------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m                    \e[33mif\e[0m(newMax > max(\e[31m0\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                ^^^\e[0m\n\e[31m   |\e[0m       \
    \                         \e[33mvariable\e[0m \e[35mmax\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmp7m6umtne.scala:19:31 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                        max = (max(\e[31m0\e[0m), max(\e\
    [31m1\e[0m), max(\e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m                       \
    \        ^^^\e[0m\n\e[31m   |\e[0m                               \e[33mvariable\e\
    [0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation ava"
  stdout: ''
  timestamp: 1660011003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var ret: List[Long] = Nil\n        val mum = numbers.foldRight(0l) { (m:\
    \ Long, i: Long) => if (m < i) m else i }\n        var k = 0\n        for (i <-\
    \ numbers) {\n            while ( k < i && mum == numbers(k)) {\n            \
    \    k += 1\n            }\n            if ( k == i) ret::= mum\n            else\
    \ ret::= mum\n            mum = i\n            k += 1\n        }\n        ret.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpgiurxogy.scala:18:16 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            mum = i\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val mum\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010996
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val numberSet = numbers.toSet\n        if (numberSet.isEmpty) {\n      \
    \      List()\n        }\n        else {\n            var max_val : Long = numbers.head\n\
    \            val numbers = numbers.tail\n            var maxList = List()\n  \
    \          var currentList = List()\n            numbers.foreach { number =>\n\
    \                if (number > max_val) {\n                    max_val = number\n\
    \                }\n                else {\n                    currentList +=\
    \ max_val\n                    max_val = number\n                }\n         \
    \   }\n            currentList += max_val\n            maxList += currentList.toList\n\
    \            maxList\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbo8ok2df.scala:15:26 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e[0m \e[36mnumbers\e[0m = numbers.tail\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   Recursive \e[33mvalue\e[0m \e[35mnumbers\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbo8ok2df.scala:27:24\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            currentList +=\
    \ max_val\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue += is not a member of List[Nothing] - did you mean List[Nothing].!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbo8ok2df.scala:28:20 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            maxList += currentList.toList\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member\
    \ of List[Nothing] - did you mean List[Nothing].!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660011002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = numbers.head\n        val index = numbers.indexOf(0)\n       \
    \ numbers.dropWhile(_ < max).map { x =>\n            if (x > max) {\n        \
    \        max = x\n                index\n            } else {\n              \
    \  numbers.updated(index, x)\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp6cpkbbgr.scala:13:20 -----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                max = x\n\e[31m\e[31m   |\e[0m      \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val max\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6cpkbbgr.scala:16:31\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m                numbers.updated(index,\
    \ x)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                Found:    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660011001
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max_rolling = 0\n        val rolling_max = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(num => \n            if (rolling_max.length < max_rolling\
    \ + num) \n                rolling_max += num\n            else if (rolling_max\
    \ exists (_ == num))\n                max_rolling = rolling_max.length\n     \
    \   )\n        rolling_max.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp_vsoltms.scala:15:28 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                max_rolling = rolling_max.length\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Reassignment to val max_rolling\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010995
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxRollingWindow = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        var sum = 0l\n        var max = 0L\n        for(i <- numbers)\n     \
    \   {\n            sum += i\n            if(sum > max)\n            {\n      \
    \          maxRollingWindow.clear()\n                maxRollingWindow.append(sum)\n\
    \            }\n            else if(sum < max)\n            {\n              \
    \  maxRollingWindow.append(sum)\n            }\n        }\n        if(maxRollingWindow.length\
    \ == 0)\n        {\n            List()\n        }\n        else\n        {\n \
    \           maxRollingWindow.reverse\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxszry3e6.scala:31:29\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m            maxRollingWindow.reverse\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            Found:    scala.collection.mutable.ListBuffer[Long]\n\e[31m   |\e\
    [0m            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty) numbers\n        else {\n            val list = numbers.head\
    \ :: numbers.tail\n            val rollingMax = list.reduce({\n              \
    \  case (a, b) if a.isDefined => a.get\n                case (a, b) if b.isDefined\
    \ => b.get\n                case (a, b) => b\n            })\n            rollingMax\
    \ :: rollingMax(list.drop(1))\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppp1u22t6.scala:13:33 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                \e[33mcase\e[0m (a, b) \e[33mif\e[0m\
    \ a.isDefined => a.get\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value isDefined is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppp1u22t6.scala:13:48\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m                \e[33mcase\e\
    [0m (a, b) \e[33mif\e[0m a.isDefined => a.get\n\e[31m\e[31m   |\e[0m         \
    \                                     ^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                           value get is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmppp1u22t6.scala:14:33 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                \e[33mcase\e[0m (a, b) \e[33mif\e[0m\
    \ b.isDefined => b.get\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value isDefined is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppp1u22t6.scala:14:48\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m                \e[33mcase\e\
    [0m (a, b) \e[33mif\e[0m b.isDefined => b.get\n\e[31m\e[31m   |\e[0m         \
    \                                     ^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                           value get is not a member of Long\n\e[31m\e[31m--\
    \ [E050] Type Error: /tmp/tmppp1u22t6.scala:17:26 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            rollingMax :: rollingMax(list.drop(\e[31m1\e\
    [0m))\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          \e[33mvalue\e[0m \e[35mrollingMax\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660011004
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val newNumbers = numbers.reverse.tail.takeWhile(max => {\n             \
    \   val lastMax = numbers.reverse.tail.last\n                numbers.reverse.tail.indexWhere(x\
    \ => x > max) === numbers.reverse.tail.size\n        }.reverse.tail.map(i => numbers.reverse.tail.drop(i).max).getOrElse(numbers.reverse.tail.max))\n\
    \        rollingMaxHelper(newNumbers, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp91u_bp3r.scala:11:62 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m                numbers.reverse.tail.indexWhere(\e[36mx\e\
    [0m => x > max) === numbers.reverse.tail.size\n\e[31m\e[31m   |\e[0m         \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                value === is not a member of Int - did you mean Int.==?\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp91u_bp3r.scala:13:8 -------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        rollingMaxHelper(newNumbers, \e[31m0\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Not found:\
    \ rollingMaxHelper\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660011003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList : mutable.MutableList[Long] = mutable.MutableList[Long]()\n\
    \        var maxVal = numbers.head\n        var current = 0\n        var currentIndex\
    \ = 0\n        while(current < numbers.size) {\n            if(numbers.exists(x\
    \ => x == maxVal)) {\n                maxList += maxVal\n                maxVal\
    \ += numbers.drop(currentIndex).head\n                currentIndex++\n       \
    \     } else if(numbers.exists(x => x == maxVal)) {\n                maxVal +=\
    \ numbers.drop(currentIndex).head\n                currentIndex++\n          \
    \  } else {\n                maxVal += numbers.drop(currentIndex).head\n     \
    \           currentIndex++\n            }\n            current++\n        }\n\
    \        return maxList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpymd3e485.scala:17:30 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                currentIndex++\n\e[31m\e[31m   |\e[0m\
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \       expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E018] Syntax Error: /tmp/tmpymd3e485.scala:20:30 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                currentIndex++\n\e[31m\e[31m   |\e[0m\
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \       expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E018] Syntax Error: /tmp/tmpymd3e485.scala:23:30 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                currentIndex++\n\e[31m\e[31m   |\e[0m\
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \       expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E018] Syntax Error: /tmp/tmpymd3e485.scala:25:21 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            current++\n\e[31m\e[31m   |\e[0m        \
    \             ^\e[0m\n\e[31m   |\e[0m                     expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpymd3e485.scala:9:22 -------------------------\e[0m\e[0m\n\e[31m9 |\e\
    [0m        \e[33mval\e[0m \e[36mmaxList\e[0m : mutable.MutableList[\e[35mLong\e\
    [0m] = mutable.MutableList[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m          \
    \            ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpymd3e485.scala:9:50\
    \ -------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxList\e[0m : mutable.MutableList[\e[35m"
  stdout: ''
  timestamp: 1660010999
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rolling = mutable.ListBuffer.empty[Long]\n        var rollingMax = numbers(0)\n\
    \        for (i<-0 to numbers.length-1) {\n            if (i == numbers.length\
    \ - 1) {\n                rolling += rollingMax\n            } else if (numbers(i)\
    \ < rollingMax) {\n                rollingMax += numbers(i + 1)\n            }\
    \ else {\n                rollingMax -= numbers(i + 1)\n                rolling\
    \ += rollingMax\n            }\n        }\n        rolling\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4bwbyruu.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrolling\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011000
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxElement = numbers.head - 1\n        val result = List.newBuilder[Long]\n\
    \        var index = 1\n        while (index < numbers.length) {\n           \
    \ val currElement = numbers(index)\n            if (currElement > maxElement)\
    \ {\n                if (result == null) result.addLast(maxElement)\n        \
    \        else result.addAll(maxElement.toString.split('').map(Long.parseLong(_)).asInstanceOf[List[Long]])\n\
    \            }\n            result.addLast(currElement)\n            index +=\
    \ 1\n        }\n        result.result()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpiesaxquh.scala:16:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                \e[33melse\e[0m result.addAll(maxElement.toString.split('').map(Long.parseLong(_)).asInstanceOf[List[Long]])\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \ empty character literal\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiesaxquh.scala:15:43\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m                \e[33mif\e\
    [0m (result == \e[31mnull\e[0m) result.addLast(maxElement)\n\e[31m\e[31m   |\e\
    [0m                                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ addLast is not a member of scala.collection.mutable.Builder[Long, List[Long]]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiesaxquh.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            result.addLast(currElement)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue addLast is not\
    \ a member of scala.collection.mutable.Builder[Long, List[Long]]\n3 errors found\n"
  stdout: ''
  timestamp: 1660011005
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def getMin(x : Int) : Int = {\n            if(x > 0) {\n               \
    \ getMin(x - 1)\n            } else {\n                if(x == 0) 1\n        \
    \        else 0\n            }\n        }\n\n        val minIndex = new Int()\n\
    \        val maxIndex = new Int()\n        val max = Int.MinValue\n        val\
    \ maxSize = 0\n        var counter = 0\n        var currentMax = 0\n        var\
    \ currentMaxIndex = 0\n        val arr = numbers.toArray\n        for(i <- 0 until\
    \ arr.length)\n        {\n            if(arr(i) < min)\n            {\n      \
    \          min = arr(i)\n                minIndex = counter\n            }\n \
    \           if(arr(i) > max)\n            {\n                max = arr(i)\n  \
    \              maxIndex = counter\n            }\n            if(arr(i) == max)\n\
    \            {\n                currentMax = arr(i)\n                currentMaxIndex\
    \ = counter\n            }\n            counter += 1\n        }\n        var rollingMax:\
    \ List[Long] = List()\n        for(i <- 0 until arr.length)\n        {\n     \
    \       if(minIndex == currentMaxIndex)\n            {\n                if(arr(i)\
    \ > currentMax)\n                {\n                    currentMax = arr(i)\n\
    \                    rollingMax = List()\n                    rollingMax = List((arr.indexOf(i),\
    \ currentMax))\n                }\n                else\n                {\n \
    \                   rollingMax = List((arr.indexOf(i), currentMax))\n        \
    \        }\n            }\n            else\n            {\n                if(arr(i)\
    \ > currentMax)\n                {\n                    currentMax = arr(i)\n\
    \                    rollingMax = List()\n                    rollingMax = List((arr.indexOf(i),\
    \ currentMax))\n                }\n                else\n                {\n \
    \                   rollingMax = rollingMax.takeRight(rollingMax.length)\n   \
    \                 rollingMax += List((arr.indexOf(i), currentMax))\n         \
    \       }\n            }\n        }\n        return rollingMax\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpdel8iv9g.scala:28:22 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m(arr(i) < min)\n\e[31m\e[31m\
    \   |\e[0m               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m<\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float):\
    \ Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\
    \e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m\
    \   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments ((Int, Int) => Int)\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdel8iv9g.scala:30:25 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                min = arr(i)\n\e[31m\e[31m   |\e[0m \
    \                     ^^^^^^\e[0m\n\e[31m   |\e[0m                      Found:\
    \    Long\n\e[31m   |\e[0m                      Required: (Int, Int) => Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpdel8iv9g.scala:31:25 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                minIndex = counter\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val minIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdel8iv9g.scala:35:25\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m                max = arr(i)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                Found:    Long\n\e[31m   |\e[0m                      Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpdel8iv9g.scala:36:25\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                maxIndex\
    \ = counter\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                Reassignment to val maxIndex\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when c"
  stdout: ''
  timestamp: 1660011009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val index = new mutable.ListBuffer[Long]()\n        var max = 0L\n     \
    \   var sum = 0L\n        numbers.foreach{n => {\n            sum += n\n     \
    \       if(sum > max) {\n                max = sum\n            }\n          \
    \  index += 1\n            sum = 0L\n        }}\n        index ++ List(max)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp21bbwqgs.scala:9:24 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m              \
    \          ^^^^^^^\e[0m\n\e[31m  |\e[0m                        Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011004
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val res = []\n\n        // rolling max with 1 element as we start from the\
    \ beginning\n        for (i <- 0 until numbers.size)\n            res = res.append(numbers.drop(i).max)\n\
    \n        res\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4bzhtpfj.scala:9:19 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = []\n\e[31m\e[31m\
    \  |\e[0m                   ^\e[0m\n\e[31m  |\e[0m                   an identifier\
    \ expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4bzhtpfj.scala:12:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mfor\e[0m\
    \ (i <- \e[31m0\e[0m until numbers.size)\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\e[31m\
    \   |\e[0m'=>' expected, but 'end of statement' found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp4bzhtpfj.scala:13:22 ------------------------\e[0m\e[0m\n\
    \e[31m13 |\e[0m            res = res.append(numbers.drop(i).max)\n\e[31m\e[31m\
    \   |\e[0m                  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \ value append is not a member of Null\n3 errors found\n"
  stdout: ''
  timestamp: 1660011008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = new collection.mutable.HashSet[Long]()\n        var max = 0L\n\
    \        var index = 0\n        while(index < numbers.size && numbers.size > 0)\
    \ {\n            val current = numbers(index)\n            if(maxes.contains(current))\
    \ {\n                max = current\n            }\n            else {\n      \
    \          maxes.add(current)\n                max = Math.max(max, current)\n\
    \                index++\n            }\n        }\n        numbers.take(index).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmprx3tjezu.scala:20:23 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                index++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011006
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Use a mutable list to store the result\n        val maxResult = mutable.ListBuffer[Long]()\n\
    \        // A list to store all rolling maximum\n        val allMax = mutable.ListBuffer[Long]()\n\
    \        // Loop the list until we reached a moment where the rolling max number\
    \ is no larger than the actual number in list\n        var index = 0\n       \
    \ for (number <- numbers) {\n            val rollingMaxNumber = number + index\n\
    \            // If we found a rolling maximum number larger than the current max\
    \ number, then add the current max number\n            if (rollingMaxNumber >\
    \ maxResult.last)\n                maxResult += maxResult.last\n            index\
    \ += 1\n            // Add the current rolling max number to the all rolling max\
    \ list\n            allMax += rollingMaxNumber\n        }\n        // Return the\
    \ max result\n        maxResult.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpak4b6o3z.scala:10:24 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mmaxResult\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpak4b6o3z.scala:12:21 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mallMax\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660011005
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = new mutable.ArrayBuffer(numbers)\n        val max = numbers(0)\n\
    \        val maxElement = numbers(0)\n        for (i<-1 to numbers.size-1) {\n\
    \            if (result(i) > max) {\n                max = result(i)\n       \
    \         maxElement = result(i)\n            } else if (result(i) == max) {\n\
    \                maxElement = max(result(i), maxElement)\n            }\n    \
    \        result(i) = max\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqsy_ls0q.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer(numbers)\n\e[31m\e[31m  |\e[0m                       \
    \  ^^^^^^^\e[0m\n\e[31m  |\e[0m                         Not found: mutable\n\e\
    [31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqsy_ls0q.scala:14:20 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                max = result(i)\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqsy_ls0q.scala:15:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m                maxElement\
    \ = result(i)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Reassignment to val maxElement\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E050] Type Error: /tmp/tmpqsy_ls0q.scala:17:29 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                maxElement = max(result(i), maxElement)\n\
    \e[31m\e[31m   |\e[0m                             ^^^\e[0m\n\e[31m   |\e[0m  \
    \                           \e[33mvalue\e[0m \e[35mmax\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660011006
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = numbers.foldLeft(List[Long]()) {\n            (acc, value)\
    \ => {\n                val candidate = acc.lastOption.orElse(value)\n       \
    \         val currentRoll = candidate.rollingMax\n                if((currentRoll\
    \ == 0l) && (candidate.number > value)) {\n                    acc.reverse::[Long](value)\n\
    \                }\n                else acc\n            }\n        }\n     \
    \   result.last\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpm6i1rqko.scala:14:33 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                    acc.reverse::[Long](value)\n\e[31m\e\
    [31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m        \
    \                         expression expected but \e[31m'['\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm6i1rqko.scala:11:54 --------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m                \e[33mval\e[0m \e[36mcandidate\e[0m =\
    \ acc.lastOption.orElse(value)\n\e[31m\e[31m   |\e[0m                        \
    \                              ^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                             Found:    (value : Long)\n\e[31m   |\e[0m      \
    \                                          Required: Option[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm6i1rqko.scala:12:44 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m                \e[33mval\e[0m \e[36mcurrentRoll\e[0m\
    \ = candidate.rollingMax\n\e[31m\e[31m   |\e[0m                              \
    \    ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        value rollingMax\
    \ is not a member of Option[Long]\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpm6i1rqko.scala:19:15 --------------------\e[0m\e[0m\n\e[31m19 |\e[0m\
    \        result.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: \e[1m\e[32mList\e\
    [0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660011014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var index = 0\n        var max = 0\n        var temp : List[Long] = ListBuffer.empty\n\
    \        for (n <- numbers) {\n            if (index >= n.toInt) {\n         \
    \       if (n == max) {\n                    temp = temp + (n - max)\n       \
    \             index -= (max - max).toInt\n                } else {\n         \
    \           temp = temp + (max - n)\n                    index = n.toInt\n   \
    \             }\n                max = n\n            }\n        }\n        temp.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbox2v41m.scala:11:32\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mtemp\e\
    [0m : \e[35mList\e[0m[\e[35mLong\e[0m] = ListBuffer.empty\n\e[31m\e[31m   |\e\
    [0m                                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                    Found:    scala.collection.mutable.ListBuffer[A]\n\e[31m\
    \   |\e[0m                        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m                        where:    A is a type variable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbox2v41m.scala:15:32 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                    temp = temp + (n - max)\n\e[31m\e\
    [31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is\
    \ not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpbox2v41m.scala:18:32 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                    temp = temp + (max - n)\n\e[31m\e\
    [31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is\
    \ not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpbox2v41m.scala:21:22 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                max = n\n\e[31m\e[31m   |\e[0m      \
    \                ^\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1660011018
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxElem = math.max(numbers)\n        val maxList = mutable.ListBuffer[Long]()\n\
    \        var rollingMax : List[Long] = numbers\n        var i = 1\n        while\
    \ ( i <= maxElem ) {\n            var currentMax = rollingMax(i).toLong\n    \
    \        while ( rollingMax.tail.isEmpty || rollingMax.tail.head.toLong < currentMax\
    \ ) {\n                rollingMax :+= rollingMax.head\n            }\n       \
    \     rollingMax :+= rollingMax.head\n            if ( rollingMax.last == maxElem\
    \ ) {\n                maxList :+= rollingMax.last\n            }\n          \
    \  rollingMax :+= rollingMax.tail\n            i += 1\n        }\n        return\
    \ maxList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmptqhv3i4c.scala:9:27 ------------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxElem\e[0m = math.max(numbers)\n\
    \e[31m\e[31m  |\e[0m                      ^^^^^^^^\e[0m\n\e[31m  |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m  |\e[0m (x: Double, y: Double): Double\n\
    \e[31m  |\e[0m (x: Float, y: Float): Float\n\e[31m  |\e[0m (x: Long, y: Long):\
    \ Long\n\e[31m  |\e[0m (x: Int, y: Int): Int\n\e[31m  |\e[0mmatch arguments ((numbers\
    \ : List[Long]))\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptqhv3i4c.scala:10:22\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxList\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptqhv3i4c.scala:22:23\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            rollingMax :+=\
    \ rollingMax.tail\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m   value :+= is not a member of List[Long] - did you mean List[Long].:+?\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660011016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = new scala.collection.mutable.ArrayList[Long]\n        numbers.foreach(x\
    \ => result.add(x)) // add all elements to list\n        val maxValue = max(result.toList)\n\
    \        result.toList.map(x => if (x == maxValue) x else x + 1) // get all possible\
    \ rolling maximum elements from list\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2h2ey6ud.scala:9:50 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m scala.collection.mutable.ArrayList[\e[35mLong\e[0m]\n\e[31m\e[31m  |\e[0m\
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  |\e\
    [0m                type ArrayList is not a member of scala.collection.mutable\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660011016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Initialize max list\n        var maxList = List[Long]()\n\n        //\
    \ Go through all the elements until the current moment\n        for (number <-\
    \ numbers) {\n            // If the current number is greater than the maximum\
    \ found so far,\n            // update max with the current element\n        \
    \    if (number > maxList.getOrElse(-1l) {\n                maxList :+= number\n\
    \            }\n        }\n\n        // Return the resulting list\n        return\
    \ maxList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbnaxctdd.scala:19:8 ----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        }\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m\
    \   |\e[0m        ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpbnaxctdd.scala:16:33 ------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m            \e[33mif\e[0m (number > maxList.getOrElse(-\e[31m1l\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         value getOrElse is not a member of List[Long]\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660011017
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val results = new mutable.MutableList[Long]()\n        for (x<-numbers)\n\
    \        results ::= math.max(x-results.last, results.last)\n        \n      \
    \  results\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnog3rjca.scala:9:26 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mresults\e[0m = \e[33mnew\e\
    [0m mutable.MutableList[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m             \
    \             ^^^^^^^\e[0m\n\e[31m  |\e[0m                          Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011010
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maximums = scala.collection.mutable.LinkedHashMap[Long, Int]()\n   \
    \     var maximum = numbers(0)\n\n        for (number <- numbers) {\n        \
    \    if (maximums.contains(maximum)) {\n                val prevMax = maximums.last.get\
    \ + 1\n                maximums.last.put(number, prevMax)\n                maximums.put((number\
    \ - prevMax), prevMax)\n            } else {\n                maximums.put(number,\
    \ 0)\n            }\n\n            maximum = max(number, maximum)\n        }\n\
    \n        val keys = maximums.keys\n        val values = maximums.values\n\n \
    \       // Return the maximum element of each group\n        (keys zip values\
    \ map (x => (x._1 - x._2, x._2)))\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppet0bbqy.scala:14:44 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                \e[33mval\e[0m \e[36mprevMax\e[0m = maximums.last.get\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value get is not a member of\
    \ (Long, Int)\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppet0bbqy.scala:15:30\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m                maximums.last.put(number,\
    \ prevMax)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value put is not a member of (Long, Int)\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmppet0bbqy.scala:28:9 ---------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        (keys zip values map (\e[36mx\e[0m => (x._1 -\
    \ x._2, x._2)))\n\e[31m\e[31m   |\e[0m         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m         Found:    Iterable[(Long, Int)]\n\e[31m   |\e[0m\
    \         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660011020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result: List[Long] = List();\n        numbers.foreach(x => {\n     \
    \       val max = results.last\n            if (max > x)\n                result.add(x)\n\
    \            else {\n                if (result.last > x)\n                  \
    \  result.last = x\n            }\n        })\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx0tw6xgu.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            \e[33mval\e[0m \e[36mmax\e[0m = results.last\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: results\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpx0tw6xgu.scala:13:23 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m                result.add(x)\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value add is not a\
    \ member of List[Long]\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpx0tw6xgu.scala:16:32\
    \ -----------------------------\e[0m\e[0m\n\e[31m16 |\e[0m                   \
    \ result.last = x\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Reassignment to val last\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660011020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def lastMax(n: Long): Long = {\n            if(numbers.length <= n){\n \
    \               return numbers(n)\n            } else {\n                return\
    \ if(numbers(n) > numbers(n-1)) numbers(n) else numbers(n-1)\n            }\n\
    \        }\n        def min(n1: Long, n2: Long) : Long = {\n            if(n1\
    \ > n2){\n                n1\n            } else {\n                n2\n     \
    \       }\n        }\n        def max(n1: Long, n2: Long) : Long = {\n       \
    \     if(n1 > n2){\n                n2\n            } else {\n               \
    \ n1\n            }\n        }\n        val maxNums = ListBuffer[Long]()\n   \
    \     numbers.foldLeft(maxNums){\n            (maxNums, number) => {\n       \
    \         val newMax = lastMax(number)\n                val newMin = lastMax(number\
    \ - 1)\n                val newMaxs = if(newMax > newMin) newMax, newMin else\
    \ newMin, newMax\n                maxNums ++= newMaxs\n            }\n       \
    \ }\n        return maxNums\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp36ltzat5.scala:35:56 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33mval\e[0m \e[36mnewMaxs\e[0m = \e\
    [33mif\e[0m(newMax > newMin) newMax, newMin \e[33melse\e[0m newMin, newMax\n\e\
    [31m\e[31m   |\e[0m                                                        ^\e\
    [0m\n\e[31m   |\e[0m                                 end of statement expected\
    \ but ',' found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp36ltzat5.scala:11:31\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m                \e[33mreturn\e\
    [0m numbers(n)\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e\
    [31m   |\e[0m                               Found:    (n : Long)\n\e[31m   |\e\
    [0m                               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp36ltzat5.scala:13:34 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                \e[33mreturn\e[0m \e[33mif\e[0m(numbers(n)\
    \ > numbers(n-\e[31m1\e[0m)) numbers(n) \e[33melse\e[0m numbers(n-\e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                  Found:    (n : Long)\n\e[31m   |\e[0m     \
    \                             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp36ltzat5.scala:13:47 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                \e[33mreturn\e[0m \e[33mif\e[0m(numbers(n)\
    \ > numbers(n-\e[31m1\e[0m)) numbers(n) \e[33melse\e[0m numbers(n-\e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                               ^^^\e[0m\n\
    \e[31m   |\e[0m                                               Found:    Long\n\
    \e[31m   |\e[0m                                               Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp36ltzat5.scala:13:61\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m                \e[33mreturn\e\
    [0m \e[33mif\e[0m(numbers(n"
  stdout: ''
  timestamp: 1660011024
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft((List[Long](0l.toLong), 0)) {\n            (acc, n) =>\n\
    \                val max = acc._1\n                val current = acc._2\n    \
    \            if (n <= current) (n, max) else (max, n)\n        }._1.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4q_q9ekm.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m                \e[33mif\e[0m\
    \ (n <= current) (n, max) \e[33melse\e[0m (max, n)\n\e[31m\e[31m   |\e[0m    \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \             Found:    (n : Long)\n\e[31m   |\e[0m                          \
    \         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp4q_q9ekm.scala:13:38 --------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m                \e[33mif\e[0m (n <= current) (n, max) \e[33melse\e[0m\
    \ (max, n)\n\e[31m\e[31m   |\e[0m                                      ^^^\e[0m\n\
    \e[31m   |\e[0m                                      Found:    (max : List[Long])\n\
    \e[31m   |\e[0m                                      Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4q_q9ekm.scala:13:54 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                \e[33mif\e[0m (n <= current) (n, max)\
    \ \e[33melse\e[0m (max, n)\n\e[31m\e[31m   |\e[0m                            \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \                         Found:    (n : Long)\n\e[31m   |\e[0m              \
    \                                      Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660011023
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft((numbers.head,List[Long]())) {\n            case ((max,\
    \ rolling),i) => (if (i > numbers.length) max else rolling.max,i.toLong::rolling)\n\
    \        }._2\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.rollingMax(tmppbrzkgsm.scala:9)\n\
    \tat Problem$.main(tmppbrzkgsm.scala:14)\n\tat Problem.main(tmppbrzkgsm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660011026
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxList : List[Long] = Nil\n        var maxValue : Long = 0\n      \
    \  var currentMax = 0\n\n        // Sort the list to find the rolling max element\n\
    \        numbers.sortWith(_.compare(_.toLong)) // Sorting in ascending order\n\
    \n        // Find the rolling max element\n        for (number <- numbers) {\n\
    \            if (maxValue < number) {\n                maxValue = number\n   \
    \             maxList = numbers :: Nil\n                currentMax = number\n\
    \            }\n            else {\n                if (currentMax == number)\
    \ {\n                    maxList = maxList :+ number\n                }\n    \
    \            else {\n                    maxList = maxList :+ currentMax\n   \
    \                 currentMax = number\n                }\n            }\n    \
    \    }\n        return maxList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpn1lidb2t.scala:14:25 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        numbers.sortWith(_.compare(_.toLong)) \e[34m//\
    \ Sorting in ascending order\e[0m\n\e[31m\e[31m   |\e[0m                     \
    \    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         Wrong number\
    \ of parameters, expected: 2\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn1lidb2t.scala:20:26\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                maxList = numbers\
    \ :: Nil\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          Found:    (numbers : List[Long])\n\e[31m \
    \  |\e[0m                          Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpn1lidb2t.scala:21:29 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                currentMax = number\n\e[31m\e[31m   |\e\
    [0m                             ^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \            Found:    (number : Long)\n\e[31m   |\e[0m                      \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn1lidb2t.scala:29:33\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m                    currentMax\
    \ = number\n\e[31m\e[31m   |\e[0m                                 ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 Found:    (number : Long)\n\e\
    [31m   |\e[0m                                 Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660011025
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     require(numbers.nonEmpty, \"rollingMax: Empty list provided\");\n      \
    \  val maxRollings = numbers.length\n        val maxIndex = 0\n        // The\
    \ first rolling is the maximum of the whole list\n        val max = numbers.head\n\
    \        // The rest rollings is the maximum of the part after the current rolling\
    \ list\n        val rest = numbers.tail.takeWhile{ _ != max }\n        // Starting\
    \ from the second rolling, compare the highest rolling with the current one and\
    \ update the rolling index\n        // when the rolling index is equal to the\
    \ maximum rolling index\n        val rollingIndex = 1\n        rest.foreach{ n\
    \ => if (n == max) {\n                            max <- max\n               \
    \             maxIndex <- maxRollings\n                        } else {\n    \
    \                        maxIndex <- rollingIndex\n                        } }\n\
    \        if (maxRollings == rollingIndex) {\n            List(max)\n        }\
    \ else {\n            rollingMax rest\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpjiuoxw72.scala:20:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                            max <- max\n\e[31m\e[31m\
    \   |\e[0m                                ^^\e[0m\n\e[31m   |\e[0m           \
    \                     end of statement expected but '<-' found\n\e[31m\e[31m--\
    \ Error: /tmp/tmpjiuoxw72.scala:21:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                            maxIndex <- maxRollings\n\
    \e[31m\e[31m   |\e[0m                                     ^^\e[0m\n\e[31m   |\e\
    [0m                                end of statement expected but '<-' found\n\e\
    [31m\e[31m-- Error: /tmp/tmpjiuoxw72.scala:23:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                            maxIndex <- rollingIndex\n\
    \e[31m\e[31m   |\e[0m                                     ^^\e[0m\n\e[31m   |\e\
    [0m                                end of statement expected but '<-' found\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpjiuoxw72.scala:28:27 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            rollingMax rest\n\e[31m\e[31m   |\e[0m  \
    \                         ^\e[0m\n\e[31m   |\e[0m                           expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- [E129] Potential Issue\
    \ Warning: /tmp/tmpjiuoxw72.scala:20:28 ----------------\e[0m\e[0m\n\e[33m20 |\e\
    [0m                            max <- max\n\e[33m\e[33m   |\e[0m             \
    \               ^^^\e[0m\n\e[33m   |\e[0mA pure expression does nothing in statement\
    \ position; you may be omitting necessary parentheses\n\e[33m   |\e[0m\n\e[33m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660011019
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Start with empty rolling max\n        var maxList : List[Long] = Nil\n\
    \n        // Iterate over the given numbers, for each iteration find the max of\
    \ the rolling max and the given number\n        for (i <- numbers) {\n       \
    \     var max = 0\n            val rollingMax: List[Long] = maxList\n\n      \
    \      // For each element find the max of the previous max and the given number\
    \ i\n            var j = 1\n            while (rollingMax.head <= j && rollingMax.head\
    \ < i) {\n                max = math.max(max, rollingMax.head)\n             \
    \   rollingMax = rollingMax :: numbers(i to j)\n                j += 1 // Increment\
    \ the iteration index\n            }\n\n            // If the maximum element\
    \ found until moment j is greater than current maximum add it to the rolling max\n\
    \            if (max > numbers(i to j)) {\n                maxList ::= numbers(i\
    \ to j)\n            }\n        }\n\n        // Return the rolling max list\n\
    \        return maxList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3qx91tk1.scala:20:47\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                max = math.max(max,\
    \ rollingMax.head)\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Found:    Long\n\e[31m\
    \   |\e[0m                                    Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3qx91tk1.scala:21:51 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                rollingMax = rollingMax :: numbers(i\
    \ to j)\n\e[31m\e[31m   |\e[0m                                               \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m       Found:    scala.collection.immutable.NumericRange.Inclusive[Long]\n\
    \e[31m   |\e[0m       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp3qx91tk1.scala:26:30 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            \e[33mif\e[0m (max > numbers(i to j)) {\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^\e[0m\n\e[31m   |\e[0m       Found:   \
    \ scala.collection.immutable.NumericRange.Inclusive[Long]\n\e[31m   |\e[0m   \
    \    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3qx91tk1.scala:27:24\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                maxList ::=\
    \ numbers(i to j)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m   value ::= is not a member of List[Long] - did you mean List[Long].::?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3qx91tk1.scala:27:36 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                maxList ::= numbers(i to j)\n\e[31m\e\
    [31m   |\e[0m                                    ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \       Found:    scala.collection.immutable.NumericRange.Inclusive[Long]\n\e\
    [31m   |\e[0m       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling w"
  stdout: ''
  timestamp: 1660011026
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def rollingMaxRec(list: List[Long], max: Long, acc: List[Long]): List[Long]\
    \ = {\n            if (list.isEmpty)\n                return  acc\n          \
    \  rollingMaxRec(list.tail, list.head, list match {\n                case Nil\
    \ =>  acc.reverse\n                case _ => rollingMaxRec(list.tail, max, acc\
    \ :+ max)\n            })\n        }\n        rollingMaxRec(numbers.reverse, numbers.head)\
    \ match {\n            case Nil => Nil\n            case _ => numbers.reverse\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpmww5b1rp.scala:17:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        rollingMaxRec(numbers.reverse, numbers.head)\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter acc of \e[33mmethod\e[0m \e\
    [35mrollingMaxRec\e[0m: (list: List[Long], max: Long, acc: List[Long]): List[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660011019
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val currentMax = numbers.head\n        val nextMax = numbers.last\n    \
    \    val nextMaxToCheck = currentMax + 1\n        val nextMaxList = new mutable.LinkedList[Long]()\n\
    \        nextMaxList += currentMax\n        while (nextMaxToCheck < numbers.last)\
    \ {\n            nextMaxList += nextMax\n            nextMaxToCheck += currentMax\
    \ + 1\n        }\n        nextMaxList.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpys69a1uk.scala:12:30 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mnextMaxList\e[0m = \e[33mnew\e\
    [0m mutable.LinkedList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpys69a1uk.scala:16:27\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            nextMaxToCheck\
    \ += currentMax + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m      value += is not a member of Long - did you mean nextMaxToCheck.!=?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660011023
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = new mutable.LinkedList[Long]()\n        var currentMax\
    \ = 0L\n        var i = 0\n        while(i < numbers.size) {\n            currentMax\
    \ = Math.max(currentMax, numbers(i))\n            i += 1\n            if(rollingMax.size\
    \ < i)\n                rollingMax.add(numbers(i))\n            if(currentMax\
    \ == numbers(i)) {\n                i += 1\n                currentMax = numbers(i)\n\
    \                while(i < numbers.size) {\n                    if(currentMax\
    \ == numbers(i)) {\n                        i += 1\n                        currentMax\
    \ = numbers(i)\n                        rollingMax.add(currentMax)\n         \
    \           } else {\n                        currentMax = numbers(i)\n      \
    \                  rollingMax.add(currentMax)\n                        break\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ rollingMax.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8h7afezc.scala:9:29 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = \e[33mnew\e\
    [0m mutable.LinkedList[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m              \
    \               ^^^^^^^\e[0m\n\e[31m  |\e[0m                             Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8h7afezc.scala:28:24\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                        break\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660011020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(List[Long]()){ (acc: List[Long], x: Long) => acc match\
    \ {\n            case Nil =>\n                acc.append(x)\n            case\
    \ _ => if (acc.last > x) acc else acc :+ x\n        }}.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi1sotem2.scala:11:20 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m                acc.append(x)\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value append is not a member\
    \ of List[Long] - did you mean acc.appended?\n1 error found\n"
  stdout: ''
  timestamp: 1660011025
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach{n =>\
    \ max += n -> math.max(n)}\n        max match {\n            case Nil => Nil\n\
    \            case m :: Nil => m\n            case m :: tl =>\n               \
    \ val tl_max = rollingMax(tl)\n                m._2 match {\n                \
    \    case n if n > tl_max(m._1) => m :: tl_max\n                    case n if\
    \ n < tl_max(m._1) => m :: Nil\n                    case n => m :: tl_max\n  \
    \              }\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7qz6pa78.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7qz6pa78.scala:13:29\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m            \e[33mcase\e\
    [0m m :: Nil => m\n\e[31m\e[31m   |\e[0m                             ^\e[0m\n\e\
    [31m   |\e[0m                             Not found: m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp7qz6pa78.scala:15:40 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                \e[33mval\e[0m \e[36mtl_max\e[0m = rollingMax(tl)\n\
    \e[31m\e[31m   |\e[0m                                        ^^\e[0m\n\e[31m \
    \  |\e[0m                                        Not found: tl\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp7qz6pa78.scala:16:16 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                m._2 \e[33mmatch\e[0m {\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Not found: m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7qz6pa78.scala:17:50\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m                    \e[33mcase\e\
    [0m n \e[33mif\e[0m n > tl_max(m._1) => m :: tl_max\n\e[31m\e[31m   |\e[0m   \
    \                                               ^\e[0m\n\e[31m   |\e[0m      \
    \                                            Not found: m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp7qz6pa78.scala:18:50 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                    \e[33mcase\e[0m n \e[33mif\e[0"
  stdout: ''
  timestamp: 1660011020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty) List(1l)\n        else {\n            val maxList =\
    \ numbers.maxBy { number =>\n                val index = number % numbers.size\n\
    \                number - numbers(index)\n            }\n            rollingMax(maxList\
    \ :: numbers)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_pn78gv7.scala:13:33\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m                number - numbers(index)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                 Found:    (index : Long)\n\e[31m   |\e[0m\
    \                                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011027
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val nums = numbers.toList\n        val len = nums.size\n        var max\
    \ = 0l\n        var rollingMax = nums.toList.tail.foldLeft(0l)( (a,b) => if (b\
    \ > a) b else a )\n        var rollingMaxIndex = 0\n        for ( i <- 1 to len-1\
    \ ) {\n            rollingMaxIndex = i\n            val prev = nums(i - 1)\n \
    \           val current = nums(i)\n            if ( current > max ) {\n      \
    \          max = current\n                rollingMax = nums.toList.tail.foldLeft(0l)(\
    \ (a,b) => if (b > a) b else a )\n            }\n            else if ( current\
    \ == max ) {\n                rollingMax = nums.toList.tail.foldLeft(0l)( (a,b)\
    \ => if (b > a) b else a )\n            }\n            else if ( current < max\
    \ ) {\n                rollingMax = nums.toList.tail.foldLeft(0l)( (a,b) => if\
    \ (b > a) a else b )\n                max = current\n                rollingMaxIndex\
    \ = i\n            }\n        }\n        return rollingMax\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxg92gtkw.scala:31:15\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mreturn\e[0m rollingMax\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \      Found:    (rollingMax : Long)\n\e[31m   |\e[0m               Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011026
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     require(numbers != null)\n        val rollingMaxElem = mutable.Stack.empty[Long]\n\
    \        val maxVal = numbers(0)\n        for (x <- numbers) {\n            if\
    \ (x < maxVal) {\n                rollingMaxElem += x\n            } else {\n\
    \                rollingMaxElem.pop\n                rollingMaxElem += x\n   \
    \         }\n            maxVal = rollingMaxElem.last\n        }\n        rollingMaxElem\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzu72cym3.scala:10:29 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mrollingMaxElem\e[0m = mutable.Stack.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpzu72cym3.scala:19:19 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            maxVal = rollingMaxElem.last\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \       Reassignment to val maxVal\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660011023
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // We will keep a map of rolling max element so far.\n        // We will\
    \ also keep a rolling max index so that we can remove the element when the moment\
    \ is reached.\n        val maxes = new mutable.HashMap[Long, Long]\n        val\
    \ rollingMaxIndex = new mutable.ArrayBuffer[Long]()\n        var currentMax =\
    \ -1l\n\n        // Start looping through the numbers from the end of the list\
    \ up to the beginning.\n        numbers.reverse.foreach{\n            // If the\
    \ current number is greater than the rolling max we just found then update it.\n\
    \            if(currentMax < _) maxes += (_ -> currentMax)\n            // Otherwise\
    \ if the current number is greater than the rolling max in the map of rolling\
    \ max elements\n            // then we will update it with the current max and\
    \ add the current index to the list of rolling max indices.\n            else\
    \ if(!maxes.contains(_)) maxes += (_ -> currentMax)\n            // Otherwise\
    \ the numbers are equal, thus we will add the index of the current max to the\
    \ list of rolling max indices.\n            else {\n                maxes += (_\
    \ -> currentMax)\n                rollingMaxIndex += currentMax\n            }\n\
    \            currentMax = maxes.values.max\n        }\n\n        // Remove the\
    \ rolling max index at the end as it is no longer needed.\n        rollingMaxIndex.removeAll(_\
    \ == currentMax)\n\n        // Return the list of rolling max elements.\n    \
    \    maxes.toList.sortBy(_._2)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps9dft4aj.scala:11:24 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mmaxes\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m \
    \                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps9dft4aj.scala:12:34\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mrollingMaxIndex\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                  Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E081] Type Error: /tmp/tmps9dft4aj.scala:18:28 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e[0m(currentMax < _) maxes += (_\
    \ -> currentMax)\n\e[31m\e[31m   |\e[0m                            ^\e[0m\n\e\
    [31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$1 of expanded function:\n\e[31m   |\e\
    [0m   _$1 => currentMax < _$1.\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmps9dft4aj.scala:21:36\
    \ -----------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33melse\e\
    [0m \e[33mif\e[0m(!maxes.contains(_)) maxes += (_ -> currentMax)\n\e[31m\e[31m\
    \   |\e[0m                                    ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$3 of expanded function:\n\e[31m   |\e[0m   _$3 => ! maxes.contains(_$3).\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps9dft4aj.scala:27:23 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            currentMax = maxes.values.max\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \        Found:    Unit\n\e[31m   |\e[0m            Required: Long => Any\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation availabl"
  stdout: ''
  timestamp: 1660011031
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.reverse.foldLeft(List[Long]())((list, number) => {\n           \
    \ if (numbers.length == list.length) list :+ number\n            else {\n    \
    \            if (number > list.last) list :+ number\n                else {\n\
    \                    list :+ list.last\n                }\n            }\n   \
    \     })\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: last of empty list\n\tat scala.collection.immutable.Nil$.last(List.scala:665)\n\
    \tat scala.collection.immutable.Nil$.last(List.scala:661)\n\tat Problem$.rollingMax$$anonfun$1(tmp3s_y6g5t.scala:12)\n\
    \tat Problem$.rollingMax$$anonfun$adapted$1(tmp3s_y6g5t.scala:17)\n\tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\
    \tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\
    \tat Problem$.rollingMax(tmp3s_y6g5t.scala:17)\n\tat Problem$.main(tmp3s_y6g5t.scala:21)\n\
    \tat Problem.main(tmp3s_y6g5t.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660011034
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = numbers.foldLeft((-1l, 0l)) { (x, y) =>\n            if (y._1\
    \ < x._1) (y._1, y._2) else (x._1, x._2)\n        }\n        if (max._1 < 0) numbers\
    \ else numbers.takeWhile(x => x._2 < max._1).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbuaw0fhe.scala:10:18 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mif\e[0m (y._1 < x._1) (y._1, y._2)\
    \ \e[33melse\e[0m (x._1, x._2)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\
    \e[31m   |\e[0m                value _1 is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpbuaw0fhe.scala:10:32 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mif\e[0m (y._1 < x._1) (y._1, y._2)\
    \ \e[33melse\e[0m (x._1, x._2)\n\e[31m\e[31m   |\e[0m                        \
    \      ^^^^\e[0m\n\e[31m   |\e[0m                              value _1 is not\
    \ a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbuaw0fhe.scala:10:38\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m            \e[33mif\e[0m\
    \ (y._1 < x._1) (y._1, y._2) \e[33melse\e[0m (x._1, x._2)\n\e[31m\e[31m   |\e\
    [0m                                    ^^^^\e[0m\n\e[31m   |\e[0m            \
    \                        value _2 is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpbuaw0fhe.scala:12:62 ------------------------\e[0m\e\
    [0m\n\e[31m12 |\e[0m        \e[33mif\e[0m (max._1 < \e[31m0\e[0m) numbers \e[33melse\e\
    [0m numbers.takeWhile(\e[36mx\e[0m => x._2 < max._1).reverse\n\e[31m\e[31m   |\e\
    [0m                                                            ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                        value _2 is not a member of\
    \ Long\n4 errors found\n"
  stdout: ''
  timestamp: 1660011036
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxIndex  = numbers.indexWhere(_.isMax)\n        val rollingMax = new\
    \ mutable.ListBuffer[Long]()\n        val currentMax = numbers(maxIndex)\n   \
    \     var i = 0\n        while(i < maxIndex) {\n            rollingMax += numbers(i)\n\
    \            currentMax = numbers(i) if maxIndex - i + 1 > rollingMax.size \n\
    \                || numbers(i) > rollingMax(rollingMax.size-1)\n            i\
    \ += 1\n        }\n        rollingMax.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp77ygykgn.scala:15:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            currentMax = numbers(i) \e[33mif\e[0m maxIndex\
    \ - i + \e[31m1\e[0m > rollingMax.size \n\e[31m\e[31m   |\e[0m               \
    \                     ^^\e[0m\n\e[31m   |\e[0m                               \
    \ end of statement expected but 'if' found\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp77ygykgn.scala:9:45 -------------------------\e[0m\e[0m\n\e[31m9 |\e\
    [0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m  = numbers.indexWhere(_.isMax)\n\
    \e[31m\e[31m  |\e[0m                                           ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                                       value isMax is not a member\
    \ of Long\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp77ygykgn.scala:10:29\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mrollingMax\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp77ygykgn.scala:15:23 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            currentMax = numbers(i) \e[33mif\e[0m maxIndex\
    \ - i + \e[31m1\e[0m > rollingMax.size \n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val currentMax\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660011036
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = mutable.ArrayBuffer.empty[Long]\n        val size = numbers.size\n\
    \        def rollingMaxHelper(index: Int, numbers: List[Long], result: List[Long]):\
    \ Unit = {\n            if (index == size) {\n                result.addAll(numbers.sortBy(_._1).reverse)\n\
    \            } else {\n                for (i <- 0 until numbers.size - 1) {\n\
    \                    result(i) = if (numbers(i) <= numbers(index)) { numbers(index)\
    \ } else { numbers(i) }\n                    rollingMaxHelper(index + 1, numbers,\
    \ result)\n                }\n            }\n        }\n        rollingMaxHelper(0,\
    \ numbers, result)\n        result.result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp000q4d65.scala:9:21 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                     Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp000q4d65.scala:13:23 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                result.addAll(numbers.sortBy(_._1).reverse)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ addAll is not a member of List[Long] - did you mean result.zipAll?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp000q4d65.scala:13:47 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                result.addAll(numbers.sortBy(_._1).reverse)\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^\e[0m\n\e\
    [31m   |\e[0m                                        value _1 is not a member\
    \ of Long\n\e[31m\e[31m-- Error: /tmp/tmp000q4d65.scala:13:50 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                result.addAll(numbers.sortBy(_._1).reverse)\n\
    \e[31m\e[31m   |\e[0m                                                  ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp000q4d65.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                    result(i) = \e[33mif\e[0m (numbers(i)\
    \ <= numbers(index)) { numbers(index) } \e[33melse\e[0m { numbers(i) }\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not\
    \ a member of List[Long] - did you mean result.updated?\n5 errors found\n"
  stdout: ''
  timestamp: 1660011038
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty) return List()\n        val maxRolling = numbers.tail.foldLeft[Long](numbers.head){\
    \ (acc,x) => if (acc > x) acc else x }\n        val rest = rollingMax(numbers.tail)\n\
    \        rest ::: List(maxRolling.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphb_72xzr.scala:16)\n\tat Problem.main(tmphb_72xzr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660011040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Define a function to get list of rolling max elements\n        // From\
    \ a given list of integers, generate a list of rolling maximum element found until\
    \ given moment\n        // E.g. (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong))\n        // rollingMax(numbers) will return\
    \ a List containing [1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong]\n        numbers.foldLeft(List[Long]()){ case (acc, number) => acc.zip(rollingMaxUntil(number:_*))\
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfmr8d4j9.scala:13:70 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        numbers.foldLeft(List[\e[35mLong\e[0m]()){ \e\
    [33mcase\e[0m (acc, number) => acc.zip(rollingMaxUntil(number:\e[35m_*\e[0m))\
    \ }\n\e[31m\e[31m   |\e[0m                                                   \
    \                   ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                          Not found: rollingMaxUntil\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpfmr8d4j9.scala:13:86 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        numbers.foldLeft(List[\e[35mLong\e[0m]()){ \e\
    [33mcase\e[0m (acc, number) => acc.zip(rollingMaxUntil(number:\e[35m_*\e[0m))\
    \ }\n\e[31m\e[31m   |\e[0m                                                   \
    \                                   ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                            Found:    (number : Long)\n\e[31m   |\e[0m      \
    \                                   Required: Seq[<?>] | Array[<?>]\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660011038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.length == 0) numbers.reverse\n        val max = numbers(0)\n\
    \        val rollingMax = List[Long]()\n        for (i <- 1 to numbers.size) {\n\
    \            val current = numbers(i)\n            if (current > max) {\n    \
    \            max = current\n            }\n            else {\n              \
    \  rollingMax += max\n                max = current\n            }\n        }\n\
    \        rollingMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmps19za5ns.scala:15:20 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                max = current\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps19za5ns.scala:18:27\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m                rollingMax\
    \ += max\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m    value += is not a member of List[Long] - did you mean rollingMax.!=?\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmps19za5ns.scala:19:20 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                max = current\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660011038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val r = mutable.ArrayBuffer.empty[Long]\n        numbers.foreach { number\
    \ =>\n            val rm = r.reverse.foldLeft(number) { case (rm, num) =>\n  \
    \              if (rm > num)\n                    rm\n                else\n \
    \                   num\n            }\n            r.append(rm)\n        }\n\
    \        r.foldRight(List[Long]())(_ > _)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr288830n.scala:9:16 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                ^^^^^^^\e[0m\n\e[31m  |\e\
    [0m                Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011031
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = 0L\n        var maxes = new mutable.ArrayList[Long]\n        for\
    \ (number <- numbers) {\n            max += number\n            maxes += number\n\
    \            if (max > number) {\n                max = 0L\n                maxes\
    \ = new mutable.ArrayList[Long]\n            }\n        }\n        maxes\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3ncxzbtn.scala:10:24 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mvar\e[0m \e[36mmaxes\e[0m = \e[33mnew\e\
    [0m mutable.ArrayList[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3ncxzbtn.scala:16:28\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m                maxes = \e\
    [33mnew\e[0m mutable.ArrayList[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m       \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660011034
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = 0\n        numbers.reverse.foreach { number =>\n            if(number\
    \ > max) max = number\n        }\n        numbers = numbers :+ max\n        numbers.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqmh7disj.scala:11:35\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m            \e[33mif\e[0m(number\
    \ > max) max = number\n\e[31m\e[31m   |\e[0m                                 \
    \  ^^^^^^\e[0m\n\e[31m   |\e[0m                                   Found:    (number\
    \ : Long)\n\e[31m   |\e[0m                                   Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqmh7disj.scala:13:16 -----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        numbers = numbers :+ max\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment\
    \ to val numbers\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660011039
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def rollingMaxHelper(numbers : List[Long], acc : List[Long]) : List[Long]\
    \ = {\n            val maxNum = numbers.min\n            if (numbers.length ==\
    \ 1) acc :+ maxNum\n            else {\n                val nextNum = numbers(0)\n\
    \                val index = numbers.indexOf(0)\n                val updatedNums\
    \ = rollingMaxHelper(numbers.tail, acc :+ maxNum)\n                if (index <\
    \ numbers.indexOf(0)) {\n                    updatedNums\n                } else\
    \ {\n                    updatedNums :+ nextNum\n                }\n         \
    \   }\n        }\n        rollingMaxHelper(numbers, List(0l))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.rollingMaxHelper$1(tmpbv43ffsc.scala:10)\n\tat Problem$.rollingMax(tmpbv43ffsc.scala:23)\n\
    \tat Problem$.main(tmpbv43ffsc.scala:26)\n\tat Problem.main(tmpbv43ffsc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660011043
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(List.empty[Long]) { case (acc, x) => \n            if (acc\
    \ contains x) acc else acc ++ List(max(x,acc.last))\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: last of empty list\n\tat scala.collection.immutable.Nil$.last(List.scala:665)\n\
    \tat scala.collection.immutable.Nil$.last(List.scala:661)\n\tat Problem$.rollingMax$$anonfun$1(tmpgp_rhiht.scala:10)\n\
    \tat Problem$.rollingMax$$anonfun$adapted$1(tmpgp_rhiht.scala:11)\n\tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\
    \tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\
    \tat Problem$.rollingMax(tmpgp_rhiht.scala:11)\n\tat Problem$.main(tmpgp_rhiht.scala:15)\n\
    \tat Problem.main(tmpgp_rhiht.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660011042
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = numbers(0)\n        var result : List[Long] = List()\n       \
    \ for (number <- numbers) {\n            if (number > max) {\n               \
    \ max += number\n                result ::= max\n            }\n            else\
    \ {\n                result += number\n            }\n        }\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7d23_a6z.scala:17:23 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                result += number\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member\
    \ of List[Long] - did you mean List[Long].!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660011042
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var max = numbers(0)\n        var maxCount = 1\n        var index = 0\n\
    \        var rollingMaxResult = new mutable.ArrayList[Long]\n        for(x <-\
    \ numbers){\n            if(x < max){ \n                rollingMaxResult.add(max)\n\
    \                rollingMaxResult.add(index)\n                maxCount = 1\n \
    \               max = x\n            }else{\n                maxCount+=1\n   \
    \             max = x\n            }\n            index += 1\n        }\n    \
    \    rollingMaxResult\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd2kdi9yt.scala:12:35 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mrollingMaxResult\e[0m =\
    \ \e[33mnew\e[0m mutable.ArrayList[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m   \
    \                                ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val m = numbers.head\n        val rollingMax = m :: rollingMax(numbers.tail)\n\
    \        rollingMax.max(numbers.last)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpc3v4rhg8.scala:10:30 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = m :: rollingMax(numbers.tail)\n\
    \e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m   \
    \                           Recursive \e[33mvalue\e[0m \e[35mrollingMax\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011037
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = new mutable.MutableList[Long]()\n        val max = new\
    \ Long(0)\n        val maxSeq = Seq(numbers)\n        val rollingMaxSeq = rollingMax\
    \ ++= maxSeq\n        val sumRollingMax = rollingMaxSeq.sum\n        rollingMaxSeq.filter(i\
    \ => i > max).foreach(i => rollingMaxSeq.filter(_ != i).foreach(x => rollingMaxSeq.filter(_\
    \ != x).foreach(y => rollingMaxSeq.filter(_ != y)))) \n        rollingMaxSeq.filter(_\
    \ > sumRollingMax).foreach(x => rollingMaxSeq.filter(_ != x).foreach(y => rollingMaxSeq.filter(_\
    \ != y)))\n        rollingMax\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp18hbfr05.scala:9:29 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = \e[33mnew\e\
    [0m mutable.MutableList[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m             \
    \                ^^^^^^^\e[0m\n\e[31m  |\e[0m                             Not\
    \ found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp18hbfr05.scala:10:27\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m10 |\e[0m       \
    \ \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m \e[35mLong\e[0m(\e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \   too many arguments for \e[33mconstructor\e[0m \e[35mLong\e[0m in \e[33mclass\e\
    [0m \e[35mLong\e[0m: (): Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660011038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // Keep track of the max found so far\n        var max = 0l\n        //\
    \ Keep track of how many items are left of the list \n        var left = 0L\n\n\
    \        // If the list is empty, just return an empty list\n        if(numbers.isEmpty)\
    \ Nil\n\n        // Loop through the numbers until we reach the moment we wanted\n\
    \        numbers.takeWhile{number => left > 0 || number > max}.\n            //\
    \ Then find the max of the remaining items\n            foldRight((max, left)){(max,\
    \ left) => (number, left) =>\n                if(number > max) max = number\n\
    \                left -= 1\n                (max, left)}\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp9_0xmk1y.scala:20:51 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            foldRight((max, left)){(\e[36mmax\e[0m, \e\
    [36mleft\e[0m) => (\e[36mnumber\e[0m, \e[36mleft\e[0m) =>\n\e[31m\e[31m   |\e\
    [0m                                                   ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                     Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m                     I could not infer the type of the parameter number.\n\e\
    [31m\e[31m-- [E081] Type Error: /tmp/tmp9_0xmk1y.scala:20:59 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            foldRight((max, left)){(\e[36mmax\e[0m, \e\
    [36mleft\e[0m) => (\e[36mnumber\e[0m, \e[36mleft\e[0m) =>\n\e[31m\e[31m   |\e\
    [0m                                                           ^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Missing parameter type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m                       I could not infer the type of the parameter left.\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp9_0xmk1y.scala:21:37 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mif\e[0m(number > max) max = number\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                 Reassignment to val max\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmp9_0xmk1y.scala:15:28 ----------------\e\
    [0m\e[0m\n\e[33m15 |\e[0m        \e[33mif\e[0m(numbers.isEmpty) Nil\n\e[33m\e\
    [33m   |\e[0m                            ^^^\e[0m\n\e[33m   |\e[0mA pure expression\
    \ does nothing in statement position; you may be omitting necessary parentheses\n\
    \e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660011040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxIndex = 0\n        var max = 0L\n        var currentIndex = 0\n \
    \       var current = 0L\n        for(i <- 0 until numbers.size) {\n         \
    \   current = numbers(i)\n            if(i == maxIndex) {\n                max\
    \ = current\n            }\n            if(i == currentIndex) {\n            \
    \    max = max max > current ? max : current\n            }\n            if(i\
    \ == numbers.size-1) {\n                maxIndex = i\n                max = max\n\
    \            }\n        }\n        return maxIndex.toList.map(n => n.toLong).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpnvjeabms.scala:19:46 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                max = max max > current ? max : current\n\
    \e[31m\e[31m   |\e[0m                                              ^\e[0m\n\e\
    [31m   |\e[0m                                         expression expected but\
    \ \e[31m:\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnvjeabms.scala:19:30\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m                max = max\
    \ max > current ? max : current\n\e[31m\e[31m   |\e[0m                       \
    \       ^\e[0m\n\e[31m   |\e[0m                              Not found: >\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnvjeabms.scala:19:40\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m                max = max\
    \ max > current ? max : current\n\e[31m\e[31m   |\e[0m                       \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \    Not found: ?\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnvjeabms.scala:26:24\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mreturn\e[0m\
    \ maxIndex.toList.map(\e[36mn\e[0m => n.toLong).reverse\n\e[31m\e[31m   |\e[0m\
    \               ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value toList is\
    \ not a member of Int - did you mean Int.toInt?\n4 errors found\n"
  stdout: ''
  timestamp: 1660011044
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val len = numbers.length\n        var max = 0l\n        var rollingMax =\
    \ 0l\n        var i = 0\n        while (i < len) {\n            max = max(numbers(i),\
    \ max)\n            if (max > rollingMax) {\n                rollingMax = max\n\
    \            }\n            i += 1\n        }\n        rollingMax.asInstanceOf[List[Long]]\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpoo0_q87o.scala:14:18 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            max = max(numbers(i), max)\n\e[31m\e[31m\
    \   |\e[0m                  ^^^\e[0m\n\e[31m   |\e[0m                  \e[33mvariable\e\
    [0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val res = numbers.foldLeft(List[Long]())((l,cur) => {\n            val max\
    \ = l(0)\n            for (i <- 0 until l.size) {\n                if (cur <=\
    \ l(i)) {\n                    max = l(i)\n                }\n            }\n\
    \            l.updated(l.size, max)\n        })\n        res.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpfg8yxgtu.scala:13:24 -----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                    max = l(i)\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment\
    \ to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011041
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = numbers.last\n        val list = numbers.dropRight(numbers.last)\n\
    \        val result = new ListBuffer[Long]()\n        for (number <- list) {\n\
    \            if (number > max) {\n                result += (number -> max)\n\
    \            }\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphqd49mdf.scala:10:45\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mlist\e\
    [0m = numbers.dropRight(numbers.last)\n\e[31m\e[31m   |\e[0m                 \
    \                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \               Found:    Long\n\e[31m   |\e[0m                              \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphqd49mdf.scala:14:27\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m                result += (number\
    \ -> max)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Found:    (Long, Long)\n\e[31m   |\e\
    [0m                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660011046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val ret = new mutable.MutableList[Long]()\n        numbers.tail.foreach{\
    \ x =>\n            val maxIndex = ret.lastIndex\n            val maxValue = ret(maxIndex)\n\
    \            val newMax = if (x == maxValue) x else x + 1\n            if (newMax\
    \ > maxValue) {\n                ret.updated(maxIndex, newMax)\n            }\n\
    \        }\n        return ret.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9wsuasli.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mret\e[0m = \e[33mnew\e[0m\
    \ mutable.MutableList[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m               \
    \       ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011042
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxNumbersSoFar = mutable.LinkedHashMap[Long, Long]()\n        val rollingMax\
    \ = mutable.LinkedHashMap[Long, Long]()\n\n        for (i <- 0 to numbers.length-1)\
    \ {\n            val thisMax = maxNumbersSoFar.getOrElse(numbers(i), -1l)\n  \
    \          if (thisMax == -1l) {\n                maxNumbersSoFar.put(numbers(i),\
    \ numbers(i))\n                rollingMax.put(numbers(i), numbers(i))\n      \
    \      } else {\n                rollingMax.put(numbers(i), max(rollingMax.getOrElse(numbers(i),\
    \ -1l), numbers(i)))\n            }\n        }\n\n        maxNumbersSoFar.values\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb7rjt_yv.scala:9:30 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxNumbersSoFar\e[0m = mutable.LinkedHashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      \
    \        ^^^^^^^\e[0m\n\e[31m  |\e[0m                              Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb7rjt_yv.scala:10:25\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mrollingMax\e[0m = mutable.LinkedHashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660011045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = mutable.MutableList[Long]()\n        numbers.foreach {\n  \
    \          number =>\n                val maxNumber = rollingMaxHelper(result,\
    \ number).max\n                result.add((maxNumber, number))\n        }\n  \
    \      result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp80fjlaf6.scala:9:21 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.MutableList[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                     Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp80fjlaf6.scala:12:32 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m                \e[33mval\e[0m \e[36mmaxNumber\e[0m =\
    \ rollingMaxHelper(result, number).max\n\e[31m\e[31m   |\e[0m                \
    \                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \          Not found: rollingMaxHelper\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660011044
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val m = numbers.foldLeft(0l)(\n            (max, num) => max max if num\
    \ > max else num\n        )\n        val n = numbers.size - 1\n        (m to n).map\
    \ { index => numbers(index) }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0xieuou2.scala:10:34 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            (\e[36mmax\e[0m, \e[36mnum\e[0m) => max max\
    \ \e[33mif\e[0m num > max \e[33melse\e[0m num\n\e[31m\e[31m   |\e[0m         \
    \                         ^^\e[0m\n\e[31m   |\e[0m                           \
    \       expression expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp0xieuou2.scala:13:40 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        (m to n).map { \e[36mindex\e[0m => numbers(index)\
    \ }\n\e[31m\e[31m   |\e[0m                                        ^^^^^\e[0m\n\
    \e[31m   |\e[0m                                        Found:    (index : Long)\n\
    \e[31m   |\e[0m                                        Required: Int\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660011053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val indexed = numbers.zipWithIndex\n        val rollingMaxedIndex = mutable.ListBuffer[Long]()\n\
    \        while(indexed.hasNext) {\n            val value = indexed.next()._2._1.toLong\n\
    \            rollingMaxedIndex += value\n        }\n        rollingMaxedIndex.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyqxj_t8n.scala:10:32 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mrollingMaxedIndex\e[0m =\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m               \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyqxj_t8n.scala:11:22\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mwhile\e[0m(indexed.hasNext)\
    \ {\n\e[31m\e[31m   |\e[0m              ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \              value hasNext is not a member of List[(Long, Int)]\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpyqxj_t8n.scala:12:32 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33mval\e[0m \e[36mvalue\e[0m = indexed.next()._2._1.toLong\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ next is not a member of List[(Long, Int)] - did you mean indexed.head?\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660011056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if(numbers == null || numbers.size == 0) List()\n        val result = new\
    \ mutable.ListBuffer[Long]()\n        var nextMax = numbers.head\n        var\
    \ current = numbers.head\n        val lastElements = numbers.tail\n        for((index,\
    \ element) <- 0 until lastElements.size) {\n            if(element > nextMax)\
    \ {\n                result += List((current, nextMax))\n                nextMax\
    \ = element\n            } else if(element == nextMax) {\n                nextMax\
    \ += 1\n            }\n            current = element\n        }\n        if(nextMax\
    \ < numbers.last) result += List((current, nextMax))\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz615ecw_.scala:10:25 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz615ecw_.scala:15:23\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mif\e[0m(element\
    \ > nextMax) {\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue > is not a member of Any, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz615ecw_.scala:17:26\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m                nextMax = element\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                         Found:    (element : Any)\n\e[31m   |\e[0m         \
    \                 Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpz615ecw_.scala:21:22 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            current = element\n\e[31m\e[31m   |\e[0m                 \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Found:    (element :\
    \ Any)\n\e[31m   |\e[0m                      Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660011058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxSeq = List[Long]()\n        for (i <- numbers.iterator) maxSeq +=\
    \ i\n        var result = List[Long]()\n        for (i<- 1 to numbers.size) {\n\
    \            val maxSeqI = maxSeq.takeWhile{ x => x <= numbers(i) }\n        \
    \    if (maxSeqI.size == 0) {\n                result += numbers(i)\n        \
    \    }\n            else if (maxSeqI.size == 1) {\n                result += numbers(i)\n\
    \            }\n            else {\n                result +=  maxSeqI.toList.max\n\
    \            }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkfipij03.scala:10:43 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mfor\e[0m (i <- numbers.iterator) maxSeq\
    \ += i\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        value += is not a member of List[Long] - did you mean maxSeq.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkfipij03.scala:15:23 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                result += numbers(i)\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member\
    \ of List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpkfipij03.scala:18:23 ------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m                result += numbers(i)\n\e[31m\e[31m   |\e[0m          \
    \      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of List[Long]\
    \ - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkfipij03.scala:21:23\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m                result +=\
    \  maxSeqI.toList.max\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660011059
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maximum = 0\n        var sum = 0\n        var maxNums = List[Long]()\n\
    \        for( x <- numbers ) {\n            if(maximum < x) {\n              \
    \  maximum = x\n            }\n            sum += x\n            if(sum == maximum)\
    \ {\n                maxNums = List(maximum)\n            } else {\n         \
    \       maxNums = maxNums :+ maximum\n            }\n        }\n        return\
    \ maxNums\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6yo7qorm.scala:14:26\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m                maximum = x\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   Found:    (x : Long)\n\e[31m   |\e[0m                    \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6yo7qorm.scala:16:16\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            sum += x\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660011059
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = new scala.collection.mutable.ListBuffer[Long]()\n        for\
    \ (i<- 0 until numbers.size) {\n            val rollingMax = numbers.slice(i+1,\
    \ numbers.size)\n            val rollingMaxElement = rollingMax.max\n        \
    \    result.append(rollingMaxElement)\n        }\n        return result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.rollingMax$$anonfun$1(tmpwo76ygcx.scala:12)\n\tat Problem$.rollingMax$$anonfun$adapted$1(tmpwo76ygcx.scala:14)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.rollingMax(tmpwo76ygcx.scala:14)\n\
    \tat Problem$.main(tmpwo76ygcx.scala:19)\n\tat Problem.main(tmpwo76ygcx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660011062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty)\n            numbers\n        else\n            if\
    \ (numbers.last > numbers.head) {\n                numbers :+ numbers.last\n \
    \               rollingMax(numbers.dropRight(numbers.last + 1))\n            }\
    \ else {\n                rollingMax(numbers.dropRight(numbers.head + 1))\n  \
    \          }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_r8nds88.scala:14:45\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m                rollingMax(numbers.dropRight(numbers.last\
    \ + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                                    \
    \         ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \                Found:    Long\n\e[31m   |\e[0m                             \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp_r8nds88.scala:16:45 --------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m                rollingMax(numbers.dropRight(numbers.head + \e[31m1\e\
    [0m))\n\e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    Long\n\
    \e[31m   |\e[0m                                             Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660011059
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     // First find the rolling maximum element found\n        var maxElement\
    \ = numbers.head\n        numbers = numbers.tail\n        var currentIndex = 0\n\
    \n        for(number <- numbers) {\n            if(number > maxElement) {\n  \
    \              currentIndex = 0\n                maxElement = number\n       \
    \     } else {\n                currentIndex += 1\n            }\n        }\n\n\
    \        // Then generate the sequence of rolling maximum element found\n    \
    \    var finalList = []\n        for(number <- numbers until numbers.last){\n\
    \            finalList += number\n        }\n\n        finalList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8lzf33t7.scala:24:25 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36mfinalList\e[0m = []\n\e\
    [31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m          \
    \               an identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmp8lzf33t7.scala:25:0 ----------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mfor\e[0m(number <- numbers until numbers.last){\n\e\
    [31m\e[31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m'=>' expected, but 'end of statement'\
    \ found\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp8lzf33t7.scala:11:16 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        numbers = numbers.tail\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val\
    \ numbers\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8lzf33t7.scala:25:30\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mfor\e[0m(number\
    \ <- numbers until numbers.last){\n\e[31m\e[31m   |\e[0m                     \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value until is not a member of List[Long]\
    \ - did you mean numbers.unzip?\n4 errors found\n"
  stdout: ''
  timestamp: 1660011057
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   val result = mutable.List.empty[Long]\n      def findMax(nums: List[Long],\
    \ currentIndex : Int, currentSum : Long, currentMax: Long): Unit = {\n       \
    \ if(nums.length <= currentIndex) {\n          result :+= currentMax\n       \
    \   return\n        }\n        val maxIndex = currentIndex\n        val maxSum\
    \ = currentSum + nums(maxIndex)\n        val maxNum = nums(maxIndex)\n       \
    \ if(maxSum > currentMax) {\n          currentMax = maxSum\n          currentSum\
    \ = maxNum\n        }\n        findMax(nums.drop(maxIndex), currentIndex + 1,\
    \ maxSum, currentMax)\n      }\n      findMax(numbers, 0, numbers.head, numbers.head)\n\
    \      result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1vsjt96o.scala:9:19 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m      \e[33mval\e[0m \e[36mresult\e[0m = mutable.List.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                   ^^^^^^^\e[0m\n\e[31m  |\e\
    [0m                   Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmp1vsjt96o.scala:19:21 -----------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m          currentMax = maxSum\n\e[31m\e[31m   |\e[0m     \
    \     ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          Reassignment to val currentMax\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp1vsjt96o.scala:20:21 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m          currentSum = maxNum\n\e[31m\e[31m   |\e[0m\
    \          ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          Reassignment to\
    \ val currentSum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660011050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = numbers.head\n        val maxList = numbers.tail\n        val\
    \ result = mutable.ListBuffer.empty[Long]\n        // Iterate through all element\
    \ in the tail of maxList, if current is greater than max, then update max with\
    \ current element\n        maxList.foreach{ x =>\n            if(x>max) {\n  \
    \              max = x\n            }\n        }\n        // Append current max\
    \ to result\n        result += max\n        // Reverse the result and return it.\n\
    \        result reverse ::: maxList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpbap06x9f.scala:21:34 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        result reverse ::: maxList\n\e[31m\e[31m   |\e\
    [0m                                  ^\e[0m\n\e[31m   |\e[0m                 \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpbap06x9f.scala:11:21 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpbap06x9f.scala:15:20 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                max = x\n\e[31m\e[31m   |\e[0m      \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val max\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660011050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft((List[Long](numbers(0).asInstanceOf[Long]),\
    \ 0)) {\n            case ((acc, value), number) => acc._1 + (number > acc._2\
    \ ? number : acc._2)\n            case (acc, value) => acc -> value\n        }._1\n\
    \        rollingMax.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0gcdcw_7.scala:10:47 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mcase\e[0m ((acc, value), number) =>\
    \ acc._1 + (number > acc._2 ? number : acc._2)\n\e[31m\e[31m   |\e[0m        \
    \                                   ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                     value _1 is not a member of List[Long]\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp0gcdcw_7.scala:11:33 --------------------\e[0m\e\
    [0m\n\e[31m11 |\e[0m            \e[33mcase\e[0m (acc, value) => acc -> value\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                 Found:    (\e[1m\e[31m(\e[0mList[Long],\
    \ Int\e[1m\e[31m)\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mLong\e[0m)\n\
    \e[31m   |\e[0m                                 Required: (List[Long], Int)\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660011060
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val list = numbers.toList.sortWith((a, b) => math.min(a, b))\n        val\
    \ result = new mutable.ListBuffer[Long]()\n        for (i <- 0 until list.length)\
    \ {\n            val x = list.take(i)\n            val y = list.drop(i)\n    \
    \        val z = (x ++ y ).foldLeft((0,0)){\n                ((x, y) , (i: Int)\
    \ => math.max(x, y))\n            }\n            result.append(z)\n        }\n\
    \        return result.toList.sortWith((a, b) => math.min(a, b))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu5q1uwib.scala:9:61\
    \ ---------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mlist\e\
    [0m = numbers.toList.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => math.min(a, b))\n\
    \e[31m\e[31m  |\e[0m                                                     ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                                                     Found:\
    \    Long\n\e[31m  |\e[0m                                                    \
    \ Required: Boolean\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu5q1uwib.scala:10:25\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpu5q1uwib.scala:15:43 -----------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m                ((x, y) , (\e[36mi\e[0m: \e[35mInt\e[0m) => math.max(x,\
    \ y))\n\e[31m\e[31m   |\e[0m                                      ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e\
    [0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e\
    [31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\
    \e[31m   |\e[0mmatch arguments ((x : List[Long]), (y : List[Long]))\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660011060
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = numbers(0)\n        val rollingMax = numbers.tail\n\n        for\
    \ (i <- 0 until numbers.size) {\n            if (rollingMax(i) > max) {\n    \
    \            max = rollingMax(i)\n            }\n        }\n        rollingMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp9_n7jksx.scala:14:20 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                max = rollingMax(i)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val result: List[Long] = List()\n        var maxNumber: Long = 0\n     \
    \   var maxIndex: Long = -1\n        var currentNumber: Long = 0\n        var\
    \ currentIndex: Long = 0\n        for (currentNumber <- numbers) {\n         \
    \   if (maxIndex == -1) {\n                if (currentNumber > maxNumber) {\n\
    \                    maxNumber = currentNumber\n                    maxIndex =\
    \ currentIndex\n                }\n            } else {\n                if (currentNumber\
    \ > maxNumber) {\n                    maxIndex = currentIndex\n              \
    \      maxNumber = currentNumber\n                }\n            }\n         \
    \   currentIndex += 1\n        }\n        result.add(maxIndex)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp59f445xo.scala:28:15 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        result.add(maxIndex)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value add is not a member of List[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660011062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max_so_far = numbers.last\n        val result: List[Long] = numbers.sliding(numbers.size\
    \ % numbers.size).foldLeft(List[Long](max_so_far)) {\n            (sum: List[Long],\
    \ el: Long) => {\n                sum.lastOption match {\n                   \
    \ case None => sum.append(el)\n                    case Some(curMax) =>\n    \
    \                    if(curMax > el) list(sum.head :: sum.tail)\n            \
    \            else list\n                }\n            }\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3z0eakxm.scala:13:37 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                    \e[33mcase\e[0m None => sum.append(el)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m value append is not a member of List[Long] - did you mean sum.appended?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3z0eakxm.scala:15:40 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                        \e[33mif\e[0m(curMax > el) list(sum.head\
    \ :: sum.tail)\n\e[31m\e[31m   |\e[0m                                        ^^^^\e\
    [0m\n\e[31m   |\e[0m                                        Not found: list\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3z0eakxm.scala:16:29\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m                        \e\
    [33melse\e[0m list\n\e[31m\e[31m   |\e[0m                             ^^^^\e[0m\n\
    \e[31m   |\e[0m                             Not found: list\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660011061
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = mutable.ArrayBuffer.empty[Long]()\n        numbers.foreach\
    \ { n =>\n            if (rollingMax.isEmpty) {\n                rollingMax.clear()\n\
    \                rollingMax += n\n                return\n            }\n    \
    \        var max = 0\n            var index = 0\n            rollingMax.foreach((e,\
    \ i) => {\n                if (i <= index) {\n                    return\n   \
    \             }\n                if (e > max) {\n                    max = e\n\
    \                }\n            })\n            index += 1\n            rollingMax\
    \ += max\n        }\n        rollingMax.clear()\n        rollingMax += numbers(0)\n\
    \        return rollingMax\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl183qixs.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpl183qixs.scala:14:16 --------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                \e[33mreturn\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                Found:    Unit\n\
    \e[31m   |\e[0m                Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660011062
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var currentMax = -1l.toLong\n        var results: List[Long] = Nil\n   \
    \     numbers.foreach{number => currentMax = max(number, currentMax)}\n      \
    \  results = numbers :+ currentMax\n        results.distinct\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_k6vnym4.scala:16)\n\tat Problem.main(tmp_k6vnym4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660011064
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.tail.foldLeft(numbers.head){ (max: Long, element: Long) =>\n   \
    \         if (element > max)\n                (element.toLong, element)\n    \
    \        else (max.toLong, max)\n        }.map(_._2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr32zwdro.scala:9:45\
    \ ---------------------\e[0m\e[0m\n\e[31m 9 |\e[0m        numbers.tail.foldLeft(numbers.head){\
    \ (\e[36mmax\e[0m: \e[35mLong\e[0m, \e[36melement\e[0m: \e[35mLong\e[0m) =>\n\e\
    [31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m             Found:    (\e[1m\e[31mLong\e[0m, Long) => Matchable\n\e\
    [31m   |\e[0m             Required: (\e[1m\e[32mMatchable\e[0m, Long\e[1m\e[32m\
    \ \e[0m\e[1m\e[32m@\e[0m\e[1m\e[32muncheckedVariance\e[0m) => Matchable\n\e[31m10\
    \ |\e[0m            \e[33mif\e[0m (element > max)\n\e[31m11 |\e[0m           \
    \     (element.toLong, element)\n\e[31m12 |\e[0m            \e[33melse\e[0m (max.toLong,\
    \ max)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011063
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     if (numbers.isEmpty) List() else (numbers zip rollingMax(numbers.tail)).filter(_._2\
    \ == numbers.head).map(_._1)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdalwadfp.scala:13)\n\tat Problem.main(tmpdalwadfp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660011066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxCount = numbers.count(_.toLong > 0)\n        if(maxCount == 0) List(numbers.head)\n\
    \        else {\n            val rollingMaxes = List.fill(maxCount)(numbers.head)\n\
    \            val curMax = numbers.head\n\n            var maxIndex = maxCount\n\
    \            var curIndex = 0\n            for(i <- 1 to maxCount) {\n       \
    \         rollingMaxes(i) = if (numbers(i) > curMax) numbers(i) else curMax\n\
    \                maxIndex -= 1\n                curIndex += 1\n            }\n\
    \            rollingMaxes\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpub4zw68x.scala:18:16 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                rollingMaxes(i) = \e[33mif\e[0m (numbers(i)\
    \ > curMax) numbers(i) \e[33melse\e[0m curMax\n\e[31m\e[31m   |\e[0m         \
    \       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member of List[Long]\
    \ - did you mean rollingMaxes.updated?\n1 error found\n"
  stdout: ''
  timestamp: 1660011064
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var list = numbers\n        var max: Long = numbers.head\n        var nextMax:\
    \ Long = numbers.tail.max\n        while(nextMax != numbers.tail.last) {\n   \
    \         val nextMaxMinusOne = nextMax.min - 1\n            list = list.tail.filter(elem\
    \ => elem > nextMax && (elem - nextMaxMinusOne) < max)\n            max = nextMax\n\
    \            nextMax = list.max\n        }\n        list.filterNot(elem => elem\
    \ == nextMax)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyol5qutb.scala:13:46 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mval\e[0m \e[36mnextMaxMinusOne\e[0m\
    \ = nextMax.min - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                        \
    \          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of Long\
    \ => Long, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660011066
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxNumbers = List[Long]()\n        var maxCount = 0\n        for(i <-\
    \ 0 until numbers.size) {\n            val number = numbers(i)\n            if(maxCount\
    \ < number) {\n                maxCount = 0\n                maxNumbers = List(number)\n\
    \            } else if (maxCount == number) {\n                maxNumbers = maxNumbers\
    \ :+ number\n            }\n            else {\n                maxCount += 1\n\
    \            }\n        }\n        return maxNumbers\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpalgiqae2.scala:27)\n\tat Problem.main(tmpalgiqae2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660011068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     def rollingMaxIteration(startIndex : Int) : List[Long] = {\n           \
    \ if (startIndex >= numbers.size) {\n                return List() :: rollingMaxIteration(startIndex)\n\
    \            }\n\n            val maxIndex = getMaxIndex(startIndex)\n       \
    \     val maxValue = numbers(maxIndex)\n            rollingMaxIteration(startIndex\
    \ + 1) ::: List(maxValue) :: rollingMaxIteration(startIndex)\n        }\n\n  \
    \      rollingMaxIteration(0) :::\n            rollingMaxIteration(0)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1aq7jo4i.scala:11:27\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m                \e[33mreturn\e\
    [0m List() :: rollingMaxIteration(startIndex)\n\e[31m\e[31m   |\e[0m         \
    \              ^^^^^^\e[0m\n\e[31m   |\e[0m                       Found:    List[Nothing]\n\
    \e[31m   |\e[0m                       Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1aq7jo4i.scala:14:27 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = getMaxIndex(startIndex)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           Not found: getMaxIndex\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp1aq7jo4i.scala:16:12 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            rollingMaxIteration(startIndex + \e[31m1\e\
    [0m) ::: List(maxValue) :: rollingMaxIteration(startIndex)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    List[Matchable]\n\e[31m   |\e[0m   \
    \         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660011067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.zipWithIndex.filter(_._2 % 2 == 0).map(_._1).maxBy(_.toLong)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb4qkobh3.scala:9:8 ----------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        numbers.zipWithIndex.filter(_._2 % \e[31m2\e[0m\
    \ == \e[31m0\e[0m).map(_._1).maxBy(_.toLong)\n\e[31m\e[31m  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m        Found:    Long\n\e[31m  |\e[0m        Required: \e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660011068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.view.zip(numbers.drop(1)).foldLeft(List[Long]())((a,b) => a ++ b).reverse.takeRight(1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdf6kfysp.scala:9:79\
    \ ---------------------\e[0m\e[0m\n\e[31m9 |\e[0m        numbers.view.zip(numbers.drop(\e\
    [31m1\e[0m)).foldLeft(List[\e[35mLong\e[0m]())((\e[36ma\e[0m,\e[36mb\e[0m) =>\
    \ a ++ b).reverse.takeRight(\e[31m1\e[0m)\n\e[31m\e[31m  |\e[0m              \
    \                                                                 ^\e[0m\n\e[31m\
    \  |\e[0m                                              Found:    (b : (Long, Long))\n\
    \e[31m  |\e[0m                                              Required: IterableOnce[Long]\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val size = numbers.size \n        var maxIndex = 0\n        var tempMax\
    \ = 0l\n        var rollingMax: List[Long] = List()\n        // loop through each\
    \ element\n        for (i <- 0 until size) {\n            // if number is greater\
    \ than previous maximum \n            if (numbers(i) > tempMax) {\n          \
    \      // assign new max to previous maximum\n                tempMax = numbers(i)\n\
    \                // set new maximum to zero\n                maxIndex = 0\n  \
    \          }\n            // if number is equal to previous maximum \n       \
    \     else if (numbers(i) == tempMax) {\n                // increment maximum\
    \ index\n                maxIndex = maxIndex + 1\n            }\n            //\
    \ if current maximum index is greater than max index \n            // then save\
    \ rolling max element and reset\n            if (maxIndex > rollingMax.length)\
    \ {\n                // save max element\n                rollingMax(maxIndex)\
    \ = tempMax\n                maxIndex = 0\n            }\n        }\n        return\
    \ rollingMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc19z2ube.scala:31:16 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                rollingMax(maxIndex) = tempMax\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not\
    \ a member of List[Long] - did you mean List[Long].updated?\n1 error found\n"
  stdout: ''
  timestamp: 1660011069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val largest = numbers.reduceRight( _ max )\n        val result: List[Long]\
    \ = numbers.takeWhile( x => x != largest )\n        result ::: numbers.dropWhile(\
    \ x => x == largest )\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmptyb8okqn.scala:9:49 ----------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mlargest\e[0m = numbers.reduceRight(\
    \ _ max )\n\e[31m\e[31m  |\e[0m                                              \
    \   ^\e[0m\n\e[31m  |\e[0m                                         expression\
    \ expected but \e[31m')'\e[0m found\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011067
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \   numbers match {\n        case Nil => Nil\n        case x :: Nil => List(x.toLong)\n\
    \        case x :: xs => for (n <- numbers) yield {\n          x max n match {\n\
    \            case n0 if n0 == x => x\n            case n0 => n0\n          }\n\
    \        }\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpostzsr1q.scala:24)\n\tat Problem.main(tmpostzsr1q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660011070
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     var maxes = scala.collection.mutable.ArrayBuffer.empty[Long]\n        var\
    \ index = 0\n        var rollingMax = numbers.head\n        while(maxes.size <\
    \ numbers.size) {\n            if(numbers(index) > rollingMax) {\n           \
    \     maxes += numbers(index)\n                index += 1\n            } else\
    \ {\n                maxes += numbers(index)\n            }\n        }\n     \
    \   while(index != numbers.size)\n            maxes += numbers(index)\n      \
    \  return maxes\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph58manqv.scala:22:15\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mreturn\e[0m maxes\n\
    \e[31m\e[31m   |\e[0m               ^^^^^\e[0m\n\e[31m   |\e[0m          Found:\
    \    (maxes : scala.collection.mutable.ArrayBuffer[Long])\n\e[31m   |\e[0m   \
    \       Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660011069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     numbers.foldLeft(List[Long]())((acc, cur)=> {\n            val list = new\
    \ mutable.ListBuffer[Long]()\n            var max = cur\n            while(max\
    \ < acc.last){\n                list += max\n                max = max(acc)\n\
    \            }\n            list += max\n            list += cur\n           \
    \ acc\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmkv18n0z.scala:10:27 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mlist\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpmkv18n0z.scala:14:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m14 |\e[0m                max\
    \ = max(acc)\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e[31m   |\e\
    [0m                      \e[33mvariable\e[0m \e[35mmax\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660011069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxSeq = new mutable.ArrayBuffer[Long]()\n        numbers.foreach {\
    \ number =>\n            maxSeq.clear()\n            numbers = maxSeq.appended(number).reverse\n\
    \        }\n        numbers = maxSeq.filter( (x) => x > numbers ).reverse\n  \
    \      numbers\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphbjqoajz.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxSeq\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m  |\e[0m                         Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphbjqoajz.scala:12:20 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            numbers = maxSeq.appended(number).reverse\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            Reassignment to val numbers\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmphbjqoajz.scala:14:16 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        numbers = maxSeq.filter( (\e[36mx\e[0m) => x\
    \ > numbers ).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val numbers\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660011068
