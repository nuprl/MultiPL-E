name: HumanEval_42_incr_list
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n\
  \    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
  \ 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong,\
  \ 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong,\
  \ 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n\
  \    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong,\
  \ 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong,\
  \ 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong,\
  \ 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong,\
  \ 124l.toLong))));\n    }\n\n}\n"
completions: ["        val r : List[Long] = l.copy\n        for(i <- r.indices) {\n\
    \            r(i+1) += 1\n        }\n        return r", "        val r = new mutable.ArrayList\n\
    \        for (i <- 0 until l.length) {\n            r.add(l(i) + 1)\n        }\n\
    \        r", "        val r = l.map(x => x + (1l to 0l)).zipWithIndex.map(\n \
    \           x => if (x._2 % 2 == 0) x._1 else x._1 + 1\n        )\n        l.clear()\n\
    \        l.zip(r).flatMap(x => x).distinct", '        l.flatMap { x => x :: List.fill(x){x+1}}',
  "        var newList = l\n        var prev = 0\n        var current = 0\n      \
    \  var counter = 0\n        for (i <- 0 until newList.length) {\n            current\
    \ = newList(i)\n            prev = newList(i - 1)\n            if (prev >= current)\
    \ {\n                counter = counter + 1\n            } else {\n           \
    \     counter = 1\n                newList(i - counter) = prev\n            }\n\
    \        }\n        newList", "        val newList = mutable.ListBuffer.empty[Long]\n\
    \        for (ix <- 0 until l.length){\n          newList += (ix + 1)\n      \
    \  }\n        newList", "        val newL = l.toList\n        newL :+ newL.lastOption.getOrElse(0)\
    \ + 1l", "        var tmpList = l\n        for((i, e) <- tmpList.zipWithIndex)\
    \ {\n            tmpList(i, e+1) = e+1\n        }\n        tmpList", "       \
    \ var result : List[Long] = l\n        result ++= result.map { _ + 1}\n      \
    \  result", "        val result = l.iterator\n        while (result.hasNext) {\n\
    \            val cur = result.next\n            result.append(cur + 1)\n     \
    \   }\n        return result", "        var res = l.foldLeft(List.empty[Long])((acc,n)\
    \ => acc + n.toLong)\n        acc = res.toList.sortWith((x,y) => x - y).toList.head\
    \ + res.last + 1\n        acc.toList", "        val ls = l.toList\n        var\
    \ res = List.empty[Long]\n        for( i <- 0 until ls.size )\n            res\
    \ :+= i ++ 1\n        res", "        def incr(l1 : List[Long]) : List[Long] =\
    \ {\n            def incr2(l1 : List[Long]) : List[Long] = {\n               \
    \ if (l1.isEmpty) {\n                    l1.toList\n                }\n      \
    \          else {\n                    val c = l1(0)\n                    val\
    \ t = l1.tail\n                    val r: List[Long] = List(c, c + 1.toLong, c\
    \ + 2.toLong, c + 3.toLong)\n                    if (t.isEmpty) {\n          \
    \              r\n                    }\n                    else {\n        \
    \                incr2(t.tail)\n                    }\n                }\n   \
    \         }\n            incr2(l)\n        }\n        incr(l)", "        var new_l\
    \ = new ListBuffer[Long]\n        for (i <- 0 until l.length) {\n            new_l\
    \ += l(i)\n        }\n        new_l.toList", "        val ll = mutable.ListBuffer[Long]()\n\
    \        l.foreach(x => {\n           ll += x + 1\n        })\n        ll.clear()\n\
    \        ll.toList", "        val l = l.sorted\n        val newList = new collection.mutable.ListBuffer[Long]()\n\
    \        var curVal: Long = l.head\n        newList.append(curVal)\n        while(l.tail\
    \ != l.tail) {\n            curVal = curVal + 1\n            newList.append(curVal)\n\
    \        }\n        newList.toList", "        def incr(l : List[Long]) : List[Long]\
    \ = {\n            l match {\n                case Nil => Nil\n              \
    \  case x :: xs => {\n                    x += 1\n                    xs.foldRight(x)\
    \ { case (acc, x) => acc :: x }\n                }\n            }\n        }\n\
    \        incr(l)", "        val newList = mutable.Buffer.empty[Long]\n       \
    \ l foreach { elem =>\n            newList += elem.toLong\n        }\n       \
    \ newList", "        val l1 = l.size\n        val l2 = l.size\n        var list\
    \ = new ListBuffer[Long]()\n        list ++= l\n        while(l1 > 0) {\n    \
    \        list += (l(l1 - 1).toLong + 1)\n            l1 -= 1\n        }\n    \
    \    list += (l(l2 - 1).toLong + 1)\n        list.toList", "        var ret =\
    \ 0\n        var x = 1\n        val a = l\n        a.foreach {\n            a\
    \ => ret += a\n        }\n        val n = (l + ret).length\n        for (i <-\
    \ 1 to n) {\n            val rm = a.take(i)\n            a.drop(i).foreach {\n\
    \                a => ret += a\n            }\n            a.insert(i, rm)\n \
    \       }\n        if (ret == l.length) a\n        else (incrList(a) + ret)",
  "        val res = (0 until l.length).foldLeft(l)((xs, x) => {\n            val\
    \ r = xs.drop(1).head\n            xs.updated(0,r+x.toLong)\n        })\n    \
    \    res", "        val lst = l.toList\n        val newList = mutable.ListBuffer.empty[Long]\n\
    \        lst.foreach { x =>\n            newList += x + 1\n        }\n       \
    \ newList.toList", "        val newList = new ListBuffer[Long]()\n        var\
    \ current = 0l\n        for (elem <- l)\n            newList += elem\n       \
    \     current += 1l\n            while (current < newList.last)\n            \
    \    newList += (current)\n            newList", "        val l2 = l.filterNot(x\
    \ => x == 0)\n        val l3 = l2.filterNot(x => x == 0)\n        val l4 = l3.filterNot(x\
    \ => x == 0)\n        val l5 = l4.filterNot(x => x == 0)\n        val l6 = l5.filterNot(x\
    \ => x == 0)\n        val l7 = l6.filterNot(x => x == 0)\n        val l8 = l7.filterNot(x\
    \ => x == 0)\n        val l9 = l8.filterNot(x => x == 0)\n        val l10 = l9.filterNot(x\
    \ => x == 0)\n        val l11 = l10.filterNot(x => x == 0)\n        val l12 =\
    \ l11.filterNot(x => x == 0)\n        val l13 = l12.filterNot(x => x == 0)\n \
    \       val l14 = l13.filterNot(x => x == 0)\n        val l15 = l14.filterNot(x\
    \ => x == 0)\n        val l16 = l15.filterNot(x => x == 0)\n        val l17 =\
    \ l16.filterNot(x => x == 0)\n        val l18 = l17.filterNot(x => x == 0)\n \
    \       val l19 = l18.filterNot(x => x == 0)\n        val l20 = l19.filterNot(x\
    \ => x == 0)\n        val l21 = l20.filterNot(x => x == 0)\n        val l22 =\
    \ l21.filterNot(x => x == 0)\n        val l23 = l22.filterNot(x => x == 0)\n \
    \       val l24 = l23.filterNot(x => x == 0)\n        val l25 = l24.filterNot(x\
    \ => x == 0)\n        val l26 = l25.filterNot(x => x == 0)\n        val l27 =\
    \ l26.filterNot(x => x == 0)\n        val l28 = l27.filterNot(x => x == 0)\n \
    \       val l29 = l28.filterNot(x => x == 0)\n        val l30 = l29.filterNot(x\
    \ => x == 0)\n        val l31 = l30.filterNot(x => x == 0)\n        val l32 =\
    \ l31.filterNot(x => x == 0)\n        val l33 = l32.filterNot(x => x == 0)\n \
    \       val l34 = l33.filterNot(x => x == 0)\n        val l35 = l34.filterNot(x\
    \ => x == 0)\n        val l36 = l35.filterNot(x => x == 0)\n", "        val newL\
    \ = new mutable.ListBuffer[Long]()\n        for(i <- l.iterator) {\n         \
    \   newL += i + 1\n        }\n        newL.toList", "      var i = l.length\n\
    \      while (i > 0) {\n        i -= 1\n        l(i) = l(i) + 1\n      }\n   \
    \   l", "        val len = l.length\n        for(i <- 0 until len - 1) yield {\n\
    \            if (l(i) == l(i + 1)) l(i + 1) :: l(i + 2) else l(i + 1) + 1 :: l(i\
    \ + 2)\n        }", "        if (l.isEmpty)\n            l\n        else {\n \
    \           var list = l.headOption.toList\n            var next = list.headOption\n\
    \            list :=  list.tail\n            l := l :+ next.toLong\n         \
    \   incrList(l)\n        }", "        var res = l.toList\n        var i = l.length\n\
    \        while (i > 0) {\n            i = i - 1\n            res = res.head +\
    \ 1 :: res\n        }\n        res", "        val newList: mutable.Buffer[Long]\
    \ = mutable.Buffer()\n        l.foreach { elem =>\n            newList += elem.toLong\
    \ + 1\n        }\n        newList.clear()\n        newList.toList", "        val\
    \ newList = mutable.ListBuffer.empty[Long]\n        l.foreach { x =>\n       \
    \     newList += x+1\n        }\n        newList.toList", "        val newList\
    \ = l.toSet\n        val newSet = new HashSet[Long](newList)\n        newSet ++=\
    \ newSet ++= newSet ++= newSet\n        newSet.toList", '        l.tails.reverse.foldLeft(l.head)(_
    + _)', "        var r: List[Long] = ListBuffer[Long]()\n        var x: Long =\
    \ l.head\n        var y = l.last\n        r ++= List(x, y, x + 1, y + 1)\n   \
    \     l ++= List(x, y, x + 1, y + 1)\n        l ++= List(x, y, x + 1, y + 1)\n\
    \        l", "        val m = new mutable.LinkedHashMap[Long, Long]()\n      \
    \  for (v <- l)\n            m.put(v + 1, v)\n        m.values().toList", "  \
    \      def incrIter(li : List[Long]) : List[Long] = {\n            li match {\n\
    \                case Nil => Nil\n                case x :: xs => x :: incrIter(xs)\n\
    \            }\n        }\n        incrIter(l).reverse", "        var n = 0\n\
    \        l.foreach(x => {\n            n += x\n        })\n        val r = n until\
    \ l.length\n        var m = n until r.length\n        while (m.size != 1) {\n\
    \            if (m[m.size - 1] >= r[r.size - 1]) {\n                m.remove(m.size\
    \ - 1)\n                r.remove(r.size - 1)\n            } else {\n         \
    \       m.remove(0)\n                r.add(0)\n            }\n        }\n    \
    \    r.tail.foreach(x => l.add(x+1))\n        l", "        var l1 = l\n      \
    \  while(l.head < l1.last){\n            l1.last += 1\n        }\n        l1",
  "        val len = l.length\n        var result : List[Long] = null\n        var\
    \ lastVal = 0\n        // create mutable list\n        var mutable : mutable.MutableList[Long]\
    \ = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n\
    \        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n   \
    \     var mutable : mutable.MutableList[Long] = mutable.MutableList()\n      \
    \  var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var\
    \ mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable\
    \ : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long]\
    \ = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n\
    \        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n   \
    \     var mutable : mutable.MutableList[Long] = mutable.MutableList()\n      \
    \  var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var\
    \ mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable\
    \ : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long]\
    \ = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n\
    \        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n   \
    \     var mutable : mutable.MutableList[Long] = mutable.MutableList()\n      \
    \  var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var\
    \ mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable\
    \ : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long]\
    \ = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n\
    \        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n   \
    \     var mutable : mutable.MutableList[Long] = mutable.MutableList()\n      \
    \  var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var\
    \ mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable\
    \ : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long]\
    \ = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n\
    \        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n   \
    \     var mutable : mutable.MutableList[Long] = mutable.MutableList()\n      \
    \  var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var\
    \ mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable\
    \ : mutable.MutableList[Long] = mutable.MutableList()", "        var sum = 0L\n\
    \        var out = new mutable.Buffer[Long]()\n        for (i <- l) {\n      \
    \      sum += i\n            if (sum > 2L)\n                out.append(sum.toLong)\n\
    \            sum = 1\n        }\n        if (sum > 0L)\n            out.append(sum.toLong)\n\
    \        out", "        val l1 = l.toArray\n        for (i <- 0 until l1.length)\
    \ {\n            val curr = l1(i)\n            val next = curr + 1\n         \
    \   l1(i) = next\n        }\n        l.toList", "        var result: List[Long]\
    \ = Nil\n        var i = 0\n        l foreach (x => { result += List(x, i + 1);\
    \ i += 1; })\n        result", "        val l = l.toList\n        var i = 0\n\
    \        var sum = 0L\n        for (i <- 0 until l.length) {\n            sum\
    \ = sum + l(i)\n        }\n        for (i <- 0 until l.length) {\n           \
    \ l(i) = sum\n            sum = sum + l(i)\n        }\n        l", "        if\
    \ (l.isEmpty) l\n        else l.head :: incrList(l.tail)", "        val l2 = l.map(_\
    \ + 1)\n        l2.toList", "        l.foldLeft(List[Long](l.head.toLong)) {\n\
    \            case (acc: List[Long], next: Long) => acc + List(next)\n        \
    \    case _ => acc\n        }", "        l match {\n            case Nil => l\n\
    \            case x :: xs => {\n                val r = new ListBuffer[Long]()\n\
    \                var c = x\n                for (i <- 0 until xs.length-1) {\n\
    \                    r.add(x+c(i))\n                    c = c + xs(i)\n      \
    \          }\n                r.toList\n            }\n        }", "        var\
    \ n = 0\n        var r = l(0)\n        for (i <- 1 until l.length) {\n       \
    \     n += 1\n            r = (r * i) + l(n)\n        }\n        r", "       \
    \ val newList = mutable.ListBuffer[Long]()\n        l.foldLeft(newList){ (res,\
    \ l) =>\n            res :+ l + 1 }", '        l.map(_ + 1)', "        val nums\
    \ = l.toList\n        val ans = List[Long]()\n        for (i<-nums.indices) {\n\
    \            ans ::= nums(i) + nums(i+1)\n        }\n        return ans", "  \
    \      val newList = mutable.Buffer.empty[Long]\n        var k = 0\n        l.foreach\
    \ { \n            x => newList += (x+1l.toLong)\n        }\n        newList.toList",
  "        val newList = mutable.MutableList[Long]()\n        l.foreach{ x => newList.add(x+1l.toLong)\
    \ }\n        newList", "        l match {\n            case Nil => Nil\n     \
    \       case x::xs => (x.toLong + xs.reduceLeft(_ + _)).toList\n        }", " \
    \       val m = Map(\"list\" -> l, \"i\" -> 0)\n        def inc(i: Int, v: Long)\
    \ =\n            m.get(\"list\")(i) = m.get(\"list\")(i) + v\n\n        def get(i:\
    \ Int) =\n            m.get(\"list\")(i)\n        def next(i: Int) =\n       \
    \     val r = m.get(\"list\")(i + 1)\n            if (r > m.get(\"i\")) r\n  \
    \          else 0\n        val iter = (1 to l.size).iterator\n        m.set(\"\
    i\", 0)\n        while (iter.hasNext) {\n            val i = iter.next\n     \
    \       val nextVal = if (iter.hasNext) get(i) + next(i) else 0\n            val\
    \ newVal = if (nextVal > m.get(\"i\")) nextVal else 0\n            inc(i + 1,\
    \ newVal)\n        }\n        m.get(\"list\")", "        val result = mutable.ListBuffer[Long]()\n\
    \        l.foreach { a => result = result :+ a + 1L }\n        result.toList",
  "        // Make copy to avoid modifying original list.\n        val listCopy =\
    \ l.toList\n        // Add 1 to all elements.\n        listCopy foreach (x =>\
    \ x = x + 1l)\n        // Return new list.\n        listCopy", '        l.map(i
    => i + 1).toList', "        val m = l.size\n        var result : List[Long] =\
    \ Nil\n        var count : Int = 1\n        var x = 0\n        while(count <=\
    \ m){\n            x += l(x)\n            result = (x :: result) \n          \
    \  count += 1\n        }\n        result", "        def recurse(n : List[Long],\
    \ acc : List[Long]) : List[Long] = {\n            n match {\n                case\
    \ x :: xs => (x :: acc) :: (recurse(xs, acc :: List(x)))\n                case\
    \ _ => acc\n            }\n        }\n        recurse(l, List[Long]())", "   \
    \     val l1 = l.toIndexedSeq\n        var i = l.length\n        while (i > 0)\
    \ l(i) = l(i-1) + 1 \n        l1 ", "        var result : List[Long] = l\n   \
    \     result.foreach(x => result = (x += 1))\n        result", "        l.foldLeft(List(1l.toLong))\
    \ { \n          case (hl, x) => x+1l.toLong :: hl }", "        val newList = new\
    \ mutable.ListBuffer[Long]\n        l.foreach { l =>\n            val l = l\n\
    \            newList += l + l.toLong + 1\n        }\n        newList.distinct",
  "        var i = l.head\n        var j = i + 1\n        val l = List(l.tail)\n \
    \       val s = l.foldLeft(1l.toLong)( (acc, cur) => acc.+(cur*(j/acc)) )\n  \
    \      val ret = List(l.head + s)\n        while ( i < l.last ) {\n          \
    \  i = i + 1 \n            j = i + 1\n            ret = ret + List(i.toLong +\
    \ s)\n        }\n        return ret", "        val newL = new mutable.ArrayBuffer[Long]()\n\
    \        var cur = l.head\n        newL += cur\n        for(i <- 1 to l.tail.length-1){\n\
    \            val next = (cur + i).toLong\n            newL += next\n         \
    \   cur = next\n        }\n        newL += cur\n        newL.toList", "      \
    \  l.foldLeft[List[Long]](mutable.List.empty[Long]) {\n            (l2,e) => e\
    \ :: l2.last + 1 }", "        var list = l\n        list = list.map{ _ + 1l }\n\
    \        list", "        var res = List(1l.toLong)\n        var l = l\n      \
    \  var l = l\n        for (i <- 0 until l.length-1){\n            l.updated(i,\
    \ l(i+1))\n            res = res + l\n        }\n        res", "        if (l.isEmpty)\
    \ Nil\n        else {\n            val m = l.head\n            val n = m.toLong\
    \ + 1\n            l.init(n::l)\n        }", "        val l1 = l.map { x =>\n\
    \            x + 1\n        }\n        l1", "        var result = new Array[Long](l.size)\n\
    \        var i = 0\n        for (elem <- l) {\n            result(i) = elem +\
    \ 1\n            i = i + 1\n        }\n        result", "        val ls = mutable.MutableList[Long]()\n\
    \        ls ++= l\n        ls.map( x => x+1 )\n        ls.toList", "        val\
    \ m = l.head\n        val r : List[Long] = l tail\n        m.toLong :: r.foldLeft(m\
    \ :: List(0l.toLong))( (l, acc) => l.head + acc.last )", '        l.map(x => x
    + 1l.toLong)', '        l.zipWithIndex.map { case (n, i) => i + n.toLong }', " \
    \       val newList = new collection.mutable.ListBuffer[Long]()\n        var i\
    \ = 0\n        var sum = 0\n\n        for(i <- 0 until l.size){\n            sum\
    \ += l(i)\n            newList.+=(i)\n        }\n\n        for(i <- 0 until newList.size){\n\
    \            sum += 1l\n            newList += sum\n        }\n\n        newList.drop(l.size)",
  "        val l1 = l.map(i => i + 1).toList\n        l1.reverse.foldLeft(List((0l.toLong,\
    \ 0l.toLong))) { \n          case (acc, v) => \n            acc :+ ((v._1 + 1l.toLong)\
    \ * v._2)\n          }", '        l.map((_ + 1, _ + 1, _ + 1)).toList', "    \
    \    val r = mutable.Buffer.empty[Long]\n        for (l1 <- l) {\n           \
    \ l match {\n                case l::l1 => {\n                    r.append(l1)\n\
    \                    l match {\n                        case l1 :: l2 => r.append((l1\
    \ + l2))\n                        case _ => r\n                    }\n       \
    \         }\n                case _ => r\n            }\n        }\n        r ",
  "        l.tails match {\n            case Nil => l // return list with elements\
    \ incremented by 1\n            case x :: xs => incrList(xs) // recurse\n    \
    \        case x1 :: x2 :: x3 :: x4 :: x5 :: x6 :: xs => x1 :: x2 :: x3 :: x4 ::\
    \ x5 :: x6 :: xs // tail recurse\n        }", "        val res = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        for (elem <- l) elem match {\n            case 0 =>\
    \ res += 0\n            case 1 => res += 1\n            case n => res += n\n \
    \       }\n        res.toList", "        val counter = collection.mutable.Map()\n\
    \        for(i <- l) {\n            if(counter.getOrElse(i, 0l) <= 1l)\n     \
    \           counter(i) = 1l\n            else\n                counter(i) = counter(i)\
    \ + 1l\n        }\n        val res = (for {\n            k <- counter\n      \
    \  } yield k).map(_ + 1l).toList\n        res", "        var sum = 0L\n      \
    \  var i = 0\n        for(elem <- l) sum = sum + elem\n        if(sum < 2L) l.toList\n\
    \        else {\n            var sum1 = 0L\n            var j = 0\n          \
    \  for(elem <- l) sum1 = sum1 + elem\n            if(sum1 < 2L) l.toList\n   \
    \         else {\n                var sum2 = 0L\n                var k = 0\n \
    \               for(elem <- l) sum2 = sum2 + elem\n                if(sum2 < 2L)\
    \ l.toList\n                else {\n                    while(i < l.length) l.append(l(i).toLong\
    \ + 1)\n                    i\n                }\n            }\n        }", " \
    \       val newList = mutable.ListBuffer.empty[Long]\n        val startValue =\
    \ l.head\n        newList += startValue\n        for (i <- l.tail) {\n       \
    \     newList += i + 1\n        }\n        newList.toList", "        if (l.isEmpty)\
    \ l\n        else {\n            var x = 0L\n            var y = l.head\n    \
    \        var list = new List[Long]()\n            var newList = new List[Long]()\n\
    \            while (y > 1l) {\n                x += 1l\n                y = y\
    \ / 2l\n                newList += x * y\n            }\n            list += x\
    \ + newList.head\n            list += newList\n            list.tail\n       \
    \ }", "        var sum = 0\n        for (i <- 0 until l.length) {\n          \
    \  sum = sum + i\n            l(i) = sum\n        }\n        l", "        val\
    \ nums = l\n        nums.foldLeft(0l){ (sum, i) =>\n            sum + i\n    \
    \    }", "        var i = l.head + 1\n        var j = 0\n        var k = l.length\n\
    \        while(j < k) {\n            i = i + 1\n            i = i.toLong + k.toLong\n\
    \            k = k - 1\n            j = j + 1\n        }\n        return i.toList",
  "      val newList = mutable.Buffer[Long]()\n      var prevVal = -1L\n      l.foreach\
    \ { elem =>\n        if (elem == prevVal) {\n          newList += elem + 1L\n\
    \        } else {\n          newList += elem\n          prevVal = elem\n     \
    \   }\n      }\n      newList.toList", "        val result = new ListBuffer[Long]()\n\
    \        var count = 0\n        l.foreach { x => count = x + 1; result += count}\n\
    \        result.toList", "        val i = l.iterator.zipWithIndex.map { case (item,\
    \ index) => index + 1 }.dropWhile(item => item > l.size).sum\n        l.slice(0,\
    \ i) ++ l.slice(i).reverse", "        val rec =  l match {\n            case Nil\
    \ => Nil\n            case (x::xs) => incrList(xs) :: x\n        }\n        rec",
  "        var newList: List[Long] = l.toList\n        newList.foreach{\n        \
    \    x => if (x % 2 == 0) x = x + 1\n        }\n        newList", "        var\
    \ new_list : List[Long] = l.clone()\n        new_list.zipWithIndex.foreach { \n\
    \          case (elem,i) => if (elem == l(i)) new_list(i) = (l(i)+1).toLong else\
    \ new_list(i) = elem\n        }\n        new_list", "        val retList = mutable.Buffer.empty[Long]\n\
    \        for(i <- l) {\n            val ni = i + 1\n            if(ni < 0) ni\
    \ = 0\n            if(ni > 100) ni = 100\n            retList.append(ni)\n   \
    \     }\n        retList.toList", "        var i = l.head\n        var r = l.tail\n\
    \        var r = r.tail\n        val m = r.head\n        while(i + 1 < r.head)\
    \ {\n            i = i + 1\n            r = r.tail\n            r = r.tail\n \
    \           val j = r.head\n            r.head = j\n            r.tail = List(i)\n\
    \            val f = r.head\n            r.head = f(m)\n            r.tail = List(f)\n\
    \            val k = r.head\n            r.head = f(k)\n            r.tail = List(f)\n\
    \        }\n        if (i != m) {\n            r.head = r.reverse.head\n     \
    \       r.tail = r.reverse.tail\n            r.head = f(m)\n            r.tail\
    \ = List(f)\n            r.head = r.tail.head\n            r.tail = r.tail.tail\n\
    \        }\n        val x = r.head\n        val y = r.tail\n        r.reverse.head\
    \ = x\n        r.reverse.tail = y\n        r.reverse", "        val r = new ListBuffer[Long]()\n\
    \        var i = l.head\n        var j = l.tail.head\n        for(x <- l.tail.tail)\
    \ r = r :+ i + x\n        r.toList", "      val listCopy = l.map(_ + 1)\n    \
    \  l.zip(listCopy)", "        val n = l.size\n        val result = new scala.collection.mutable.ListBuffer[Long](n)\n\
    \        (0 until n).foreach(i => result(i) = l(i)+1l)\n        result.toList",
  "        if (l.isEmpty) l\n        else {\n            def incr (l1 : List[Long],\
    \ l2 : List[Long]) : List[Long] = {\n                if (l1.isEmpty) l2\n    \
    \            else {\n                    def incr1 (l1 : List[Long], acc : List[Long])\
    \ : List[Long] =\n                        if (l1.isEmpty) acc\n              \
    \          else incr1(l1.tail, l2 :: acc)\n                    incr1(l1, Nil)\n\
    \                }\n            }\n            incr(l, l)\n        }", "     \
    \   var newList = List()\n        val size = l.length\n        var i = 1\n   \
    \     while (i < size) {\n            newList :+= l(i) + i\n            i += 1\n\
    \        }\n        newList", "        val result = mutable.ArrayBuffer.empty[Long]\n\
    \        l.foreach(x => result += x.toLong)\n        result.toList", "       \
    \ val ans = List(l.head)\n        l match {\n            case Nil => ans\n   \
    \         case head :: tail => ans ++ incrList(tail)\n        }", "        val\
    \ l = l.toSeq\n        val ns = l.map(_+1).toSeq\n        l.inits\n          \
    \      .filter(_ != 0)\n                .foldRight(ns)( (l2, l2i) => l2.updated(l2i,\
    \ l2(l2i) + 1) )", '        l.map { x => x += 1; x }', "        val r = mutable.Buffer[Long]()\n\
    \        for (a <- l) {\n            r += a\n        }\n        r.toList", " \
    \       // use recursion to increase elements by 1\n        if (l.length < 2)\n\
    \            l\n        else\n            incrList(l.tail ::: l.head :: Nil)",
  "        // Use mutable to avoid return a new object reference.\n        var res\
    \ = l\n        var i = 0\n        while (i+1 < res.length) {\n            res(i+1)\
    \ = res(i)+1\n            i = i + 1\n        }\n        return res", "       \
    \ val l = l\n        var res = new ListBuffer[Long]()\n        for (l1 <- l.iterator;\
    \ l2 <- l.iterator) {\n            val res = l1.toLong + l2.toLong\n         \
    \   res += res\n            res += res\n            res += res\n            res\
    \ += res\n            res += res\n            res += res\n            res += res\n\
    \            res += res\n            res += res\n            res += res\n    \
    \        res += res\n            res += res\n            res += res\n        \
    \    res += res\n            res += res\n            res += res\n            res\
    \ += res\n            res += res\n            res += res\n            res += res\n\
    \            res += res\n            res += res\n            res += res\n    \
    \        res += res\n            res += res\n            res += res\n        \
    \    res += res\n            res += res\n            res += res\n            res\
    \ += res\n            res += res\n            res += res\n            res += res\n\
    \            res += res\n            res += res\n            res += res\n    \
    \        res += res\n            res += res\n            res += res\n        \
    \    res += res\n            res += res\n            res += res\n            res\
    \ += res\n            res += res\n            res += res\n            res += res\n\
    \            res += res\n            res += res\n            res += res\n    \
    \        res += res\n            res += res\n            res += res\n        \
    \    res += res\n            res += res\n            res += res\n            res\
    \ += res\n            res += res\n            res += res\n            res += res\n\
    \            res += res\n            res += res\n            res += res\n    \
    \        res += res\n            res += res\n            res += res\n        \
    \    res += res\n            res += res\n            res += res\n            res\
    \ += res\n            res += res\n            res += res\n            res += res\n\
    \            res += res\n            res += res\n            res += res\n    \
    \        res += res\n            res += res\n            res += res\n        \
    \    res += res\n            res += res\n            res += res\n            res\
    \ += res\n            res += res\n            res += res\n            res += res\n\
    \            res += res\n            res += res\n            res += res\n    \
    \        res += res\n            res += res\n            res += res\n        \
    \    res += res\n            res += res\n            res += res\n            res\
    \ += res\n            res += res\n            res += res\n            res += res\n\
    \            res += res\n            res += res\n            res += res\n    \
    \        res += res\n            res += res\n            res += res\n        \
    \    res += res\n            res += res\n            res += res\n            res\
    \ += res\n            res += res\n            res += res\n            res += res\n\
    \            res += res\n            res += res\n            res += res\n    \
    \        res += res\n            res += res\n            res += res\n        \
    \    res += ", "        val result = new ListBuffer[Long]()\n        for(i <-\
    \ l.iterator) {\n            result.append(i + 1)\n        }\n        result.toList",
  "        val ll = l\n        ll map { x=>\n            x+1\n        }", '        l.map(_+1).toList',
  "        var i = 0\n        var ret = new ListBuffer[Long]()\n        while(i <\
    \ l.length) {\n            i = i + 1\n            ret.append(l(i))\n        }\n\
    \        return ret", "        var res : List[Long] = Nil\n        l foreach (x\
    \ => res = x :: res)\n        return res", '        l :+ l.last', "        var\
    \ result = l.toList\n        result.foreach(e => e+1)\n        result", "    \
    \    val list = l.toList\n        val res = mutable.Buffer.empty[Long]\n     \
    \   for (i <- 0 until list.length) res = res :+ list(i + 1).asInstanceOf[Long]\n\
    \        list.toList.flatMap(_.asInstanceOf[Long])", "        val newList = l.map\
    \ { x =>\n            x + 1\n        }\n        newList", "        // Create new\
    \ list\n        val list = l.toList\n        // Create new counter\n        var\
    \ cnt = 0\n        // Loop through list\n        for (ele <- list) {\n       \
    \     // If current element is not the last element\n            if (cnt != list.size\
    \ -1) {\n                // Increment the counter\n                cnt += 1\n\
    \            }\n            // If element is the last element\n            else\
    \ if (cnt == list.size -1) {\n                // Increment the counter by one\n\
    \                cnt += 1\n            }\n            // Else element is not the\
    \ last element\n            else {\n                // Add 1 to counter\n    \
    \            cnt += 1\n            }\n            // Append the current element\
    \ to the list\n            list :+= ele\n        }\n        // Return the list\n\
    \        list", "        l.foldLeft((0l, List.empty[Long])) {\n            (sum,\
    \ element) =>\n            val curSum = sum._1 + 1\n            val newSum = (sum._1,\
    \ sum._2 ++ List(element))\n            (newSum, curSum)\n        }._2", "   \
    \     val newL = new ListBuffer[Long]()\n        var i = 1\n        for (el <-\
    \ l)\n            newL += el * i\n            i += 1\n        newL.toList", " \
    \       var res = l\n        res.foldLeft(List[Long]()){ (res, e) => res + e +\
    \ 1}", '        l.map(x => x + 1).toList', "        val m = l.head\n        val\
    \ n = l.tail.foldLeft(m)((a, b) => a + b)\n        n :: l", '        l.tail.zip(l.tail.head
    +: l.tail).flatMap{ x => x }', "        // use mutable.ListBuffer\n        val\
    \ b = mutable.ListBuffer[Long]()\n        for(x <- l)\n            b.append(b.lastOrElse(0)\
    \ + 1)\n        return b", "        var tmpList = l\n        tmpList.zipWithIndex.foreach\
    \ {\n            case (v, i) =>\n                tmpList(i) = v + 1\n        }\n\
    \        tmpList", '        l.zipWithIndex.map { case (l: Long, i) => l + 1 }.filter(_
    <= l.length).map(_ + 1).toList', "        var cur = 0\n        var ret: List[Long]\
    \ = Nil\n        for (x <- l) {\n            x match {\n                case 1\
    \ => ret :+= 1\n                case _ => ret :+= x + 1\n            }\n     \
    \   }\n        return ret", "        val newList = ListBuffer.empty[Long]\n  \
    \      l foreach (x => newList += (x+1))\n        newList.toList", "      val\
    \ l = l flatMap (x => List(x+1,x+2))\n      l", "        val s = l.toSet\n   \
    \     val n = l.size\n        val d = s.foldLeft(0L)((acc,e) => (acc + e))\n \
    \       (l ++ List.fill(n)(d+1l)).toList", "        for (i <- 0 until l.length)\
    \ {\n            l(i) += 1\n        }\n        l", "        def iterate(l : List[Long],\
    \ acc : List[Long]) : List[Long] = {\n            if (l.isEmpty) acc\n       \
    \     else iterate(l.tail, acc.head :: acc)\n        }\n        iterate(l, List())",
  "      val li = l map (n => n + 1) //increments the elements\n      li", "     \
    \   // Use Scala collections instead of mutable List\n        var newList = ListBuffer[Long]()\n\
    \        var total = 0\n        // Use `foreach` instead of `map` to avoid side\
    \ effects\n        // from side effects in `map` accumulator.\n        l.foreach\
    \ { elem =>\n            total += elem\n            newList += elem\n        }\n\
    \        newList += total\n        // Return list\n        newList.toList", " \
    \       var result: List[Long] = null\n        for(i <- l)\n            result\
    \ += List(i)\n        return result", "        val res = mutable.ListBuffer.empty[Long]\n\
    \        for (e <- l) {\n            res += e + 1\n        }\n        res.toList",
  "        val map = new mutable.HashMap[Long, Long]()\n        for (ele <- l) {\n\
    \            if (map.contains(ele)) {\n                map.update(ele, map.get(ele)\
    \ + 1)\n            } else {\n                map.put(ele, 1)\n            }\n\
    \        }\n        val result = new mutable.ListBuffer[Long]()\n        for (ele\
    \ <- map) {\n            result.add(ele._2)\n        }\n        return result.toList",
  "        val x = l.foldLeft((0l, List())){\n            (y, x) => x ++ List(y._1\
    \ + 1l.toLong, y._2)\n        }._2\n        x", "        var i : Long = 1\n  \
    \      var l : List[Long] = l.map(l => i + l.toLong).toList\n        for(l <-\
    \ l) {\n            i ++\n            l ++\n        }\n        l", "        val\
    \ result = new ListBuffer[Long]()\n        l foreach { x => result.add((x + 1).toLong)\
    \ }\n        result.toList", "        val newL = new mutable.ListBuffer[Long]()\n\
    \        val list = l.toList\n        for (i <- list) {\n            newL += i\
    \ + 1\n        }\n        newL.toList", "        val m = l.max\n        val n\
    \ = m.toLong + 1\n        l.map {\n            case x => x + 1\n        } ++ List(n.toLong)",
  "      val res = l.foldLeft((l.head, 1L)) { case ((x, y), i) => if (i == 1L) (x,\
    \ y + 1L) else (y, x); case (z, i) => (z, 1L) }\n      res._1.toList", "     \
    \   val l2 = l.map(_ + 1)\n        l2.tail", "        var l1 = List(l.head)\n\
    \        var l2 = List(l.last)\n        var l3 = List(l.last)\n        var l4\
    \ = List(l.last)\n        while (l2.last < l3.last && l2.last < l4.last) {\n \
    \           l1.last:=l1.last + 1\n            l2.last:=l2.last + 1\n         \
    \   l3.last:=l3.last + 1\n            l4.last:=l4.last + 1\n        }\n      \
    \  while (l2.last > l3.last && l2.last > l4.last) {\n            l1.last:=l1.last\
    \ - 1\n            l2.last:=l2.last - 1\n            l3.last:=l3.last - 1\n  \
    \          l4.last:=l4.last - 1\n        }\n        while (l2.last < l3.last &&\
    \ l2.last > l4.last) {\n            l1.last:=l1.last + 1\n            l2.last:=l2.last\
    \ - 1\n            l3.last:=l3.last - 1\n            l4.last:=l4.last - 1\n  \
    \      }\n        while (l2.last > l3.last && l2.last < l4.last) {\n         \
    \   l1.last:=l1.last - 1\n            l2.last:=l2.last + 1\n            l3.last:=l3.last\
    \ - 1\n            l4.last:=l4.last + 1\n        }\n        while (l2.last < l3.last\
    \ && l2.last > l4.last) {\n            l1.last:=l1.last - 1\n            l2.last:=l2.last\
    \ - 1\n            l3.last:=l3.last + 1\n            l4.last:=l4.last + 1\n  \
    \      }\n        while (l2.last > l3.last && l2.last < l4.last) {\n         \
    \   l1.last:=l1.last + 1\n            l2.last:=l2.last - 1\n            l3.last:=l3.last\
    \ - 1\n            l4.last:=l4.last - 1\n        }\n        while (l2.last < l3.last\
    \ && l2.last < l4.last) {\n            l1.last:=l1.last + 1\n            l2.last:=l2.last\
    \ + 1\n            l3.last:=l3.last + 1\n            l4.last:=l4.last - 1\n  \
    \      }\n        while (l2.last > l3.last && l2.last > l4.last) {\n         \
    \   l1.last:=l1.last - 1\n            l2.last:=l2.last - 1\n            l3.last:=l3.last\
    \ - 1\n            l4.last:=l4.last + 1\n        }\n        while (l2.last < l3.last\
    \ && ", "        l match {\n            case Nil => Nil\n            case head\
    \ :: tail => \n                val newHead = head + 1\n                incrList(tail\
    \ map { n => n + newHead }) \n        }", "        var result = l.map(_ + 1).distinct\n\
    \        var i = 0\n        while (i < l.length) {\n            if (l(i) != l(i\
    \ + 1))\n                result += (l(i))\n            i += 2\n        }\n   \
    \     result", "        val n = l.length\n        var l1 = l.head\n        var\
    \ l2 = l.tail\n        val r : List[Long] = new ListBuffer[Long](n)\n        var\
    \ i : Int = 0\n        while(i < n) {\n            l1 += 1\n            l2 +=\
    \ 1\n            i +=1\n            l.tail.foreach(x => l.head += x)\n       \
    \     l += l1 +l2\n        }\n        r.reverse", "        l match {\n       \
    \     case Nil => Nil\n            case _ => {\n                val list1 = l.toList\n\
    \                val list2 = list1.map(x => x + 1l.toLong).toList\n          \
    \      list2.reverse\n            }\n        }", "        var n = 0\n        var\
    \ l = l.toList\n        for (elem <- l) {\n            n += 1\n            l +=\
    \ n\n        }\n        l", "        val newList : mutable.Buffer[Long] = new\
    \ mutable.Buffer[Long]()\n        for (elem <- l) {\n            newList += elem\n\
    \        }\n        for (elem <- newList) {\n            newList -= elem\n   \
    \     }\n        newList += 1\n        newList", "        l match {\n        \
    \    case Nil => Nil\n            case x::xs => (x + 1l) :: incrList(xs)\n   \
    \     }", "        val list = mutable.ListBuffer[Long]()\n        var index =\
    \ 0\n        for (el <- l) {\n            index += 1\n            list += el\n\
    \            list += index\n        }\n        list.toList", "        var l2 =\
    \ l.map(_ + 1).toList\n        var l3 = l.map(x => x + 1).toList\n        var\
    \ l4 = l.map(x => x + (10 * x)).toList\n        var l5 = l.map(x => x + (100 *\
    \ x)).toList\n        var l6 = l.map(x => x + (1000 * x)).toList\n        var\
    \ l7 = l.map(x => x + (10000 * x)).toList\n        var l8 = l.map(x => x + (100000\
    \ * x)).toList\n        var l9 = l.map(x => x + (1000000 * x)).toList\n      \
    \  var l10 = l.map(x => x + (10000000 * x)).toList\n        var l11 = l.map(x\
    \ => x + (100000000 * x)).toList\n        var l12 = l.map(x => x + (1000000000\
    \ * x)).toList\n        var l13 = l.map(x => x + (10000000000 * x)).toList\n \
    \       var l14 = l.map(x => x + (100000000000 * x)).toList\n        var l15 =\
    \ l.map(x => x + (1000000000000 * x)).toList\n        var l16 = l.map(x => x +\
    \ (10000000000000 * x)).toList\n        var l17 = l.map(x => x + (100000000000000\
    \ * x)).toList\n        var l18 = l.map(x => x + (1000000000000000 * x)).toList\n\
    \        var l19 = l.map(x => x + (10000000000000000 * x)).toList\n        var\
    \ l20 = l.map(x => x + (100000000000000000 * x)).toList\n        var l21 = l.map(x\
    \ => x + (1000000000000000000 * x)).toList\n        var l22 = l.map(x => x + (10000000000000000000\
    \ * x)).toList\n        var l23 = l.map(x => x + (100000000000000000000 * x)).toList\n\
    \        var l24 = l.map(x => x + (1000000000000000000000 * x)).toList\n     \
    \   var l25 = l.map(x => x + (10000000000000000000000 * x)).toList\n        var\
    \ l26 = l.map(x => x + (100000000000000000000000 * x)).toList\n        var l27\
    \ = l.map(x => x + (1000000000000000000000000 * x)).toList\n        var l28 =\
    \ l.map(x => x + (10000000000000000000000000 * x)).toList\n        var l29 = l.map(x\
    \ => x + (100000000000000000000000000 * x)).toList\n        var l30 = l.map(x\
    \ => x + (1000000000000000000000000000 * x)).toList\n        var l31 = l.map(x\
    \ => x + (10000000000000000000000000000 * x)).toList\n        var l32 = l.map(x\
    \ => x + (100", "        val nim  = l.toList\n        val list = n.tail.init\n\
    \        val rem = n.tail.last\n        val n   = l.toInt\n        val k   = l.toInt\n\
    \        val k1 = n.toInt\n        val k2 = k.toInt\n\n        var i = 0\n   \
    \     var j = 0\n        var k3 = 1\n        var k4 = k3\n        var k5 = k4\n\
    \        var k6 = k5\n        var k7 = k6\n        val k = k1.toInt\n\n      \
    \  var k9 = k2.toInt\n        var k10 = k9\n        var k11 = k10\n        var\
    \ k12 = k11\n\n        var k13 = k3.toInt\n        var k14 = k13\n        var\
    \ k15 = k14\n        var k16 = k15\n\n        val newList = List[Long](k13.toLong)\n\
    \        var k17 = k14.toInt\n        var k18 = k17\n        var k19 = k18\n \
    \       var k20 = k19\n\n        val nk = k17.toLong\n\n        var k21 = 0\n\
    \        var k22 = k21\n        var k23 = k22\n        var k24 = k23\n       \
    \ val k25 = k22\n\n        var k26 = k25.toInt\n        var k27 = k26\n      \
    \  var k28 = k27\n        var k29 = k28\n\n        var k30 = k27.toInt\n     \
    \   var k31 = k30\n        var k32 = k31\n        var k33 = k32\n\n        var\
    \ k34 = k28.toInt\n        var k35 = k34\n        var k36 = k35\n        var k37\
    \ = k36\n\n        var k38 = k37.toInt\n        var k39 = k38\n        var k40\
    \ = k39\n        var k41 = k40\n\n        var k42 = k37.toInt\n        var k43\
    \ = k42\n        var k44 = k43\n        var k45 = k44\n\n        var k46 = k43.toInt\n\
    \        var k47 = k46\n        var k48 = k47\n        var k49 = k48\n\n     \
    \   var k50 = k47.toInt\n        var k51 = k50\n        var k52 = k51\n      \
    \  var k53 = k52\n\n        var k54 = k48.toInt\n        var k55 = k54\n     \
    \   var k56 = k55\n        var k57 = k56\n\n        var k58 = k55.toInt\n    \
    \    var k59 = k58\n        var k60 = k59\n        var k61 = ", "        if (l.isEmpty)\
    \ l\n        else incrList(l.tail) ++ (l.head + 1l.toLong)", "        val result\
    \ = mutable.Buffer.empty[Long]\n        l.foreach{\n            i => result +=\
    \ i\n        }\n        result", "        var result = List[Long]()\n        l.foreach{elem\
    \ => result ::=  elem + 1}\n        return result", '        l.zip(l.tail).map
    { case (e, i) => i + e }.drop(1)', "        def loop(acc : List[Long], acc : List[Long])\
    \ : List[Long] = {\n            if(acc.isEmpty) {\n                return acc\n\
    \            }\n            else if(acc.headOption.exists(_ > acc.last)) {\n \
    \               acc :+ acc.last\n            }\n            else {\n         \
    \       acc :+ acc.head + 1\n            }\n            loop(acc :+ acc.last,\
    \ acc)\n        }\n        loop(l, l.headOption)", "        l.map{ x =>\n    \
    \        x + 1\n        }", "        val listCopy = l.toList\n        listCopy.map(l\
    \ => (l + l.toLong).toLong)", "        l match {\n            case Nil => Nil\n\
    \            case x :: xs => {\n                var newList = x.toList\n     \
    \           var newSize = x.toLong + 1.toLong\n                for (y <- xs) {\n\
    \                    newSize += y.toLong\n                    newList += y.toLong\n\
    \                }\n                newList + newSize\n            }\n       \
    \ }", "        var result = l\n        result foreach (l => { result = result\
    \ :+ l + 1 })\n        result", "        val l1 = l.reverse\n        val l2 =\
    \ l1.zipWithIndex.filter(a => a._2 == l1.indexOf(a._1))\n        val l3 = l2.flatMap(a\
    \ => a._2.toLong +: List(1l.toLong))\n        l3.reverse", "        var res =\
    \ l \n        for( n <- 1 to l.size){\n            val temp: List[Long] = res\
    \ \n            res = temp + List(l(n).toLong)\n        }\n        res ", "  \
    \      val m = scala.collection.mutable.ListBuffer.empty[Long]\n        l.foldLeft(m)\
    \ { (buffer, elem) => buffer.+=(elem + 1l) }\n        m.toList", '        l.map(x
    => x + 1)', "        val l2 = l.map(l => l+1)\n        l2.toList", "        val\
    \ n = l.length\n        val s = l.reduceLeft((l,r) => l + r)\n        val v =\
    \ s.toLong\n        val rs = List.range(0, n).toList\n        rs.toList match\
    \ {\n            case 0 :: _ => List(1l.toLong)\n            case 1 :: x => List(1l.toLong\
    \ + v.toLong)\n            case x :: xs => x :: incrList(xs.tail)\n        }",
  "        val result = l.foldLeft(List.empty[Long])((acc, cur) => {\n           \
    \ if (acc.isEmpty) {\n                acc.append(cur)\n            } else {\n\
    \                val lastElem = acc.last\n                acc.last += 1\n    \
    \            acc.last :: cur\n            }\n        })\n        result.reverse",
  "        val n = l.foldLeft(0l, Long.MaxValue) { case (nm, x) => (nm + x).toLong\
    \ } + 1\n        l.map { x => x + n }", '        l.foldLeft(List())(_ :+ _ + 1.toLong)',
  "        val newList = mutable.List.empty[Long]\n        for(i <- 0 until l.size)\
    \ {\n            newList += i + 1l\n        }\n        newList.toList", "    \
    \    var res = l\n        for (i<- 0 until l.size) {\n          res += i\n   \
    \     }\n        return res", '        l.map(v => v.toLong + 1)', "        var\
    \ current = l.head\n        val newList = new mutable.ListBuffer[Long]\n     \
    \   for(i <- 1 to l.length){\n            current = current + 1\n            newList\
    \ += current\n        }\n        newList.toList", '        l.foldRight(List.empty[Long])
    { (l, acc) => acc + l }', "        val m = mutable.ListBuffer.empty[Long]()\n\
    \        l foreach { i =>\n            m += i\n        }\n        m sortWith (_\
    \ < _) match {\n            case Nil => l map (_.toLong)\n            case _ =>\
    \ (l map (_.toLong) ::: m.toList)\n        }", "        if (l == Nil)\n      \
    \      Nil\n        else {\n            var i : Long = 0\n            val l =\
    \ scala.util.sorting.Ordering[Long].on[Long](_.toLong).reverse.from(l.head)\n\n\
    \            // iterate backwards\n            while (i < l.length) {\n      \
    \          l(i) += i\n                i += 1\n            }\n            l\n \
    \       }", '        l flatMap { x => List(x + 1l.toLong) }', "        val newList\
    \ = mutable.ListBuffer[Long]()\n        l foreach { _ => newList += 1l.toLong\
    \ }\n        newList.toList", "        var new_list = l.clone\n        new_list.reverse.foreach(x\
    \ => {\n            x += 1\n        })\n        new_list.reverse", "        if\
    \ (l.length < 2) return l\n        val n = l.head\n        val m = l.tail.head\n\
    \        l.head +: l.tail.tail.zipWithIndex.map { case (v, i) => i + v }.drop(1)",
  "        val l1 = l filter (_ <= l.last)\n        val l2 = l filter (_ >  l.last)\n\
    \        val l3 = l1 ++ l2\n        l3", "        // TODO: write your solution\
    \ here\n        val incr = l.tail\n        val newHead = incr.head\n        val\
    \ newTail = incr.tail\n        incrList :: newTail", "        val i = l.head +\
    \ 1\n        val r = List(i)\n        l.reverse.zip(l).foreach(x => r += x._2)\n\
    \        r", "        val m = (l.length/2 + 1) // number of odd elements\n   \
    \     var i = 0;\n        for(l <- l) {\n            if(i++ < m) {\n         \
    \       l+=(l-1)\n            }\n        }\n        l", "        val result =\
    \ new mutable.MutableList[Long]()\n        for(i <- l)\n            result.add(i+1)\n\
    \        l.clear()\n        result.toList", "        val r = l.toBuffer\n    \
    \    val r2 = r.map(_ + 1).reverse\n        r2 ++ r", "        val m = scala.math.max(l.toList.max)\n\
    \        var t = l.toList\n        t foreach { i =>\n            t -= 1\n    \
    \        t += m.toLong\n        }\n        t.toList", "       val l = l.toSeq\n\
    \       var ret = 0\n       var sum = 0\n       l.foreach{\n            i => \n\
    \            sum += i\n            ret = sum + i\n       }\n       val ret2 =\
    \ List(ret.asInstanceOf[Long])\n       ret", "        val x = l.length\n     \
    \   var i = 0\n        val rt = scala.collection.mutable.MutableList[Long]()\n\
    \        while (i < x) {\n            i += 1\n            rt += l.apply(i)\n \
    \       }\n        rt", "        if(l.length == 1)\n            List(l.head +\
    \ 1)\n        else {\n            var res = l\n            var i = l.head + 1\n\
    \            var tail = l\n            while (tail.length != 1) {\n          \
    \      tail = tail.tail\n                i = i + 1\n            }\n          \
    \  res = res :+ i\n            res\n        }", "        var result = ListBuffer[Long]()\n\
    \        val iter = l.iterator\n        while (iter.hasNext) {\n            result\
    \ += iter.next\n        }\n        result.toList", "        def incrByOne(l: List[Long],\
    \ acc: List[Long], index: Int) : List[Long] = { \n          if (index > l.length)\n\
    \            acc\n          else { \n            incrByOne(l :+ acc.head, acc.tail,\
    \ index + 1)\n          }\n        }\n        incrByOne(l, List[Long](), 0)\n\
    \      }\n}\n</code>\nThe above Scala solution does not require any mutable lists.\
    \ The function incrByOne builds up a new list by combining the head of the accumulator\
    \ with the current element from the list, then adds 1 to the index and so on.\n\
    <|/ a |>\n<| a tags=scala dscore=3 |>\nHere's a more functional style solution,\
    \ based on some functional programming ideas from Daniel Sobral and Christian\
    \ Hauer\n<code>\ndef incrList(list: List[Long]) = {\n  def getList(l:List[Long]):\
    \ List[Long] = {\n    if (l.isEmpty || l.head < 1) l\n    else getList(l.tail::List(l.head+1))\n\
    \  }\n  getList(List(1).toList)\n}\n</code>\n<|/ a |>\n<| c |>\nYes, this is really\
    \ nice. But I don't understand the purpose of the `getList` function.\n<|/ c |>\n\
    <| c |>\nWhat happens to `l` after you call `getList(l.tail::List(l.head+1))`?\n\
    <|/ c |>\n<| c |>\n`l` remains a `List[Long]` after `l.head < 1` is false\n<|/\
    \ c |>\n<| a dscore=3 |>\nHere is another solution which I think expresses nicely\
    \ what you want to do:\n<code>\ndef incrList(list: List[Long]) = {\n  val head\
    \ = list.head\n  val tail = list.tail\n  val i = tail.indexWhere { _ >= head }\
    \ + 1\n  new Iterator(head +: tail.take(i)) ++ incrList(tail.drop(i))\n}\n</code>\n\
    It works with all cases, and it may perform better than the solutions posted here\
    \ (thanks for the tips by the way!).\n<|/ a tags=scala |>\n<| c |>\nI think it\
    \ would be nice if it was possible to eliminate the `Iterator` in the last line\
    \ by returning something like `list.take(i).reverse ++ incrList(tail.drop(i))`\n\
    <|/ c |>\n<| a dscore=2 |>\nAnother version using recursion:\n<code>\ndef incrList(list:\
    \ List[Long]): List[Long] = {\n  def loop(list: List[Long", "        for (i <-\
    \ 1 to l.length) {\n            l += i\n        }\n        l"]
stop_tokens:
- "\n    }\n"
