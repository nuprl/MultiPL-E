name: HumanEval_108_count_nums
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function count_nums which takes a list of integers and returns\n\
  \    // the number of elements which has a sum of digits > 0.\n    // If a number\
  \ is negative, then its first signed digit will be negative:\n    // e.g. -123 has\
  \ signed digits -1, 2, and 3.\n    // >>> countNums((List[Long]()))\n    // (0l)\n\
  \    // >>> countNums((List[Long](-1l.toLong, 11l.toLong, -11l.toLong)))\n    //\
  \ (1l)\n    // >>> countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong)))\n  \
  \  // (3l)\n    def countNums(arr : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]()))\
  \ == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong)))\
  \ == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong,\
  \ 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong,\
  \ 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n\
  \    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong,\
  \ 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong,\
  \ 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n   \
  \ assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong)))\
  \ == (1l));\n    }\n\n}\n"
completions: ["        // Count the number that has the sum of digits > 0, the number\
    \ is negative\n        // and has the first sign digit negative\n        // e.g.\n\
    \        // >>> countNums([1, 2, 3, -4, 5, -5, 6, 7, 8, -9, 0])\n        // 2\n\
    \        // >>> countNums([1, -3, 4, -5, 6, 7, 8, -9, 0])\n        // 1\n    \
    \    // >>> countNums([1, -3, 4, -5, 6, 7, 8, 0, -9, 0])\n        // 0\n     \
    \   // >>> countNums([1, -3, 4, -5, 6, 7, 8, -9, 0])\n        // 1\n        val\
    \ firstSign = (arr map (_.toInt) filter (_.signum != 0) get 0).signum\n      \
    \  val first = arr filter (_.toInt > 0) take 1\n        if (firstSign < 0) first\
    \ else first filter (a => firstSign < 0 || (a.toInt.signum * firstSign < 0))",
  "      val ns = arr.toSet\n      val n1 = arr.filter { n => n.toInt == 1L}.toSet\n\
    \      val n2 = arr.filter { n => n.toInt == 2L}.toSet\n      val n3 = arr.filter\
    \ { n => n.toInt == 3L}.toSet\n      val n4 = arr.filter { n => n.toInt == 4L}.toSet\n\
    \      val n5 = arr.filter { n => n.toInt == 5L}.toSet\n      val n6 = arr.filter\
    \ { n => n.toInt == 6L}.toSet\n      val n7 = arr.filter { n => n.toInt == 7L}.toSet\n\
    \      val n8 = arr.filter { n => n.toInt == 8L}.toSet\n      val n9 = arr.filter\
    \ { n => n.toInt == 9L}.toSet\n      if (ns.contains(0L)) {\n        0L\n    \
    \  }\n      else if (n1.size > 0) {\n        n1.size\n      }\n      else if (n2.size\
    \ > 0) {\n        n2.size\n      }\n      else if (n3.size > 0) {\n        n3.size\n\
    \      }\n      else if (n4.size > 0) {\n        n4.size\n      }\n      else\
    \ if (n5.size > 0) {\n        n5.size\n      }\n      else if (n6.size > 0) {\n\
    \        n6.size\n      }\n      else if (n7.size > 0) {\n        n7.size\n  \
    \    }\n      else if (n8.size > 0) {\n        n8.size\n      }\n      else if\
    \ (n9.size > 0) {\n        n9.size\n      }\n      else {\n        0L\n      }",
  "        val digits = arr.reverse.map(_.toInt).zipWithIndex\n        val firstDigit\
    \ = digits(0)._2\n        val secondDigit = digits(1)._2\n        val thirdDigit\
    \ = digits(2)._2\n        val sum = firstDigit + secondDigit + thirdDigit + 2\n\
    \        if (sum < 0 || sum > 9)\n            0\n        else\n            sum.toLong",
  "        arr.foldLeft(0l)((acc, num) => {\n            val digit = num % 10\n  \
    \          val firstDigit = num / 10\n            if (digit > 0 && firstDigit\
    \ > 0) {\n                val num1 = firstDigit % 10\n                val num2\
    \ = digit + num1\n                acc += num2\n            }\n            acc\n\
    \        })", "        arr.foldLeft(0L) {\n            (count, num) =>\n     \
    \           val (digits, isNegative) = num.abs\n                if (digits.isMultipleOf(2))\
    \ {\n                    val sign = if (isNegative) -1 else 1\n              \
    \      count + sign * digits.toInt\n                }\n                else count\n\
    \        }", "        var count = 0\n        var n = 0\n        var cur = 0\n\n\
    \        arr.zipWithIndex.foreach(n => { \n            cur += n._2 % 10 \n   \
    \         if (cur > 0) \n                count += 1\n            cur = 0 \n  \
    \      })\n        count ", "        val nums = arr.filter(x => x >= 0)\n    \
    \    val sum = arr.filter(x => x == 0).reduceLeft(_ + _)\n        if (sum > 0)\
    \ {\n            val numSums = nums.filter(x => x >= 0).filter(x => x >= 0).size\n\
    \            if (numSums == 0) 0 else numSums\n        } else {\n            0\n\
    \        }", "        val total = 0L\n        arr.foreach( x => {\n          \
    \  val digits = x - x.toInt\n            if(digits > 0) {\n                total\
    \ += digits\n            }\n        })\n        total", "        val arr = arr.sortBy(_\
    \ * _)\n        val sum = 0L\n        var sum1 = -1L\n        var sum2 = -1L\n\
    \        var sum3 = -1L\n        for(i <- 0 until arr.size) {\n            if(sum\
    \ + arr(i).toLong <= 0) {\n                if(sum1 == -1L) {\n               \
    \     sum1 = sum + arr(i).toLong\n                } else {\n                 \
    \   sum2 = sum + arr(i).toLong\n                }\n            } else {\n    \
    \            sum3 = sum + arr(i).toLong\n                if(sum1 == -1L && sum2\
    \ == -1L) {\n                    if(sum3 == -1L) return sum\n                }\
    \ else {\n                    if(sum2 == -1L) return sum\n                }\n\
    \            }\n            sum += arr(i).toLong\n        }\n        sum3", " \
    \       // Your code goes here.\n        var n = 0\n        var lastsum = 0\n\
    \        arr.foreach{x => lastsum = lastsum + x}\n        arr.foreach{x => if\
    \ (lastsum > 0 && ((lastsum / 10) % 10) != 0) n = n + 1}\n        n", "      \
    \  var nums = arr.toList\n        var count = 0\n        while(nums.nonEmpty){\n\
    \            val sum = nums.reduce{\n                case(acc, elem) => acc +\
    \ elem\n            }\n            if(sum > 0) count = count + 1\n           \
    \ nums = nums.tail\n        }\n        count ", "      var count = 0\n      var\
    \ num: Long = 0\n      for (i <- arr.length) {\n        num = arr(i)\n       \
    \ count = count + 1\n        while (num > 0) {\n          num -= (Math.pow(10,i)\
    \ % num).toLong\n          i += 1\n          if (i == arr.length) break\n    \
    \    }\n      }\n      count", "        arr match {\n            case Nil => 0\n\
    \            case x :: Nil => 1\n            case x :: y => 1 + countNums(y.map(z\
    \ => z match {\n                case x if x < (0 | 0) => x.toLong\n          \
    \      case x => -x\n            }))\n        }", '       arr.filter(x => x.toString.sum.toLong
    > 0l).length', "        arr match {\n            case List() => (0l)\n       \
    \     case xs => (xs.foldLeft((0l))((acc, x) => {\n                if (acc >=\
    \ 10) {\n                    acc += x\n                } else {\n            \
    \        acc += (x - acc.toInt)\n                }\n                acc\n    \
    \        }))\n        }", "        var count = 0\n        var digit = arr.head\n\
    \        while (digit > 0) {\n            digit = digit.signum\n            count\
    \ += 1\n        }\n        arr.toList.sortWith(_.signum < 0).foreach(x => {\n\
    \            if (x < 0) {\n                count += 1\n            }\n       \
    \ })\n        count", "        val digits = arr.map(_.toInt)\n        val n =\
    \ arr.map(_.toInt)\n        digits.scanLeft(0)((_ + _ + _) * _) match {\n    \
    \        case 0 => n\n            case n if (n > 0) => n\n            case n =>\
    \ n\n        }", '        arr.count(num(arr))', "        var i = 0\n        var\
    \ total = 0\n        var nums = arr.toSet\n        while (i < arr.size) {\n  \
    \          total += nums(i)\n            if (total > 9)\n                total\
    \ -= 10\n            i += nums.size\n        }\n        total", "        val nums\
    \ = arr.filter(i => i >= 0).toList\n        val res = arr.filter(i => i >= 0 &&\
    \ !i.isMinusOne).foldLeft[Long](0) {\n            (a, b) => if (a >= 0) (b + a)\
    \ else if (b >= 0) a else b\n        }\n        res + nums.map(_.toString.map(_.digits).sum).sum",
  "       val list = arr.toList.sortWith(_ < _)\n       var cnt = 0\n       list.foreach\
    \ { x => \n         if (x >= 0) cnt += math.floor(x/10) + math.mod(x,10)\n   \
    \      else cnt += math.floor(x/10) + math.mod(x,10)*2\n       }\n       cnt",
  "        if(arr.isEmpty) 0\n        else arr.map(i => math.abs(i)).filter(_ > 0).toList.foldLeft(0)(_\
    \ + _)", "        var sum = 0\n        for (i <- arr ) {\n            var digit\
    \ = i % 10\n            sum += if (digit < 0) digit * 10 - digit else digit\n\
    \        }\n        arr.count(x => sum % 10 == 0)", "        var count = 0L\n\
    \        var neg = 0\n        for (num <- arr) {\n            val digit = num\
    \ % 10\n            if (num >= 0) {\n                if (digit >= 0) {\n     \
    \               if (num % 100 >= 0) count+=1\n                    else {\n   \
    \                     if (digit < 0) neg+=1\n                    }\n         \
    \       } else {\n                    if (num < 0) neg+=1\n                }\n\
    \            } else {\n                if (digit < 0) neg+=1\n            }\n\
    \        }\n        return count", "        val nums = arr.filter(x => x > 0).map(x\
    \ => (x / 10).toInt)\n        val sum = (0 to 9).filter(x => nums.contains(x)).map(x\
    \ => (x / 10).toInt).sum\n        arr.count(x => x > 0 && sum > 0)", '      arr.map(x
    => x + 1).filter(x => x >= 0).sum', "        val n = arr.length\n        val m\
    \ = arr.max\n        val nums = new mutable.HashSet[Long]()\n        for (i<-\
    \ 0 until n) {\n            val num = (arr(i) - m).abs\n            if (num >\
    \ 0) {\n                nums += num\n            }\n        }\n        nums.size",
  '        arr.size', "        var sum : Long = 0\n        arr.map(i => sum += (i\
    \ / 10).toInt)\n        if(arr.isEmpty) 0\n        else {\n            var sumOfFirstDigits\
    \ : Long = 0\n            var sumOfOtherDigits : Long = 0\n            arr.map(i\
    \ => sumOfFirstDigits += (i % 10).toInt)\n            arr.map(i => sumOfOtherDigits\
    \ += i.toInt)\n            var countDigit = 0\n            sumOfFirstDigits +\
    \ sumOfOtherDigits - sum\n        }", "        // If the list is empty\n     \
    \   if(arr.isEmpty) {\n            return 0\n        }\n\n        // Get the first\
    \ element\n        var first_element = arr.head\n\n        // If the first element\
    \ is a negative number then add its first digit\n        // to the total number\n\
    \        if(first_element < 0) {\n            return countNums(arr.tail)\n   \
    \     }\n\n        // If the first element is 0, count it\n        if(first_element\
    \ == 0) {\n            return countNums(arr.tail)\n        }\n\n        // If\
    \ it has a first digit greater than 0, then add it to the total\n        // number\
    \ of elements which has a sum of digits > 0.\n        // The final return value\
    \ is the sum of (first_element + digits_sum)\n        var sum_of_digits = 0\n\n\
    \        // Iterate through the list and add up the digits of the numbers\n  \
    \      // whose sum is > 0.\n        for(i <- 0 until arr.size) {\n          \
    \  var digit_sum = arr(i)\n            for(j =  0 until digit_sum) {\n       \
    \         var digit = digit_sum - j\n                sum_of_digits += digit\n\
    \            }\n        }\n\n        // Return the total numbers of elements whose\
    \ sum is > 0\n        return sum_of_digits + countNums(arr.tail)", "        var\
    \ n = 0\n        for (i <- 0 until arr.length) {\n            val cur = arr(i)\n\
    \            if (cur < 0l) {\n                val s = math.abs(cur)\n        \
    \        n += (s - math.min(s).toInt).toLong\n            } else {\n         \
    \       n += 1\n            }\n        }\n        n", "        def count_nums(arr\
    \ : List[Long]) : Long = {\n            var i = 0\n            var n = 0\n   \
    \         var neg = 0\n            while (i < arr.length) {\n                if\
    \ (arr(i) < 0) {\n                    neg = 1\n                }\n           \
    \     else {\n                    var sum = arr(i)\n                    for (j\
    \ <- 0 until arr(i).length-1) {\n                        val remainder = arr(i).mod(10).asInstanceOf[Int]\n\
    \                        sum = sum + remainder\n                        if (sum\
    \ > 9) {\n                            sum = 1\n                        }\n   \
    \                 }\n                    if (neg) {\n                        sum\
    \ = sum * -1\n                    }\n                    n = n + 1 if (sum > 0)\n\
    \                }\n                i += 1\n            }\n            n - (neg)\n\
    \        }\n        count_nums(arr)", "        var total = 0L\n        for (i\
    \ <- arr) {\n            total += i / 10\n        }\n        return arr.filter(i\
    \ => { i / 10 > 0 }).length", '        arr.filter(x => (x % 10).signum > 0).size',
  "        val digits = arr.map(_ % 10).asInstanceOf[List[Int]]\n        val sumDigits\
    \ = arr.map(_ % 10).sum\n        val count = digits.count(_ > 0)\n        val\
    \ result = count / Math.pow(10, sumDigits)\n        val sign = sumDigits < 0 \n\
    \        if(sign) -result else result", "        arr.foldLeft(0l){\n         \
    \   (total,num)=>\n                val rem = num % 10\n                if(rem\
    \ > 0) total + rem\n                else total - (10 - rem)\n        }", "   \
    \     val nums = arr.foldLeft(0)(_ + _)\n        if(nums < 0) -nums.signum else\
    \ nums", "        def sum(l: List[Long]) : Long = {\n            l match {\n \
    \               case List() => 0\n                case Nil => 0\n            \
    \    case x::xs => x.toLong + sum(xs)\n            }\n        }\n        val m\
    \ = sum(arr)\n        (m % 10).signum match {\n            case 0 => 0\n     \
    \       case 1 => 1\n            case _ => m / 10 match {\n                case\
    \ m if m > 9 => m\n                case m => 1 + countNums(arr.drop(1))\n    \
    \        }\n        }", "        var total = 0L\n        for(n <- arr){\n    \
    \        total += n\n        }\n        for(n <- arr){\n            val m = n.toInt\n\
    \            total -= m\n        }\n        total", "        val positiveSum =\
    \ arr.filter { x =>\n            val x = Math.abs(x)\n            val z = x.toString.split('')\n\
    \            if (z.length == 1) 1\n            else {\n                val last\
    \ = z.last\n                if (last >= 10) 0\n                else z.last.toInt\
    \ - 10\n            }\n        }\n        positiveSum.size", "        val sum\
    \ = arr.foldLeft(0){\n            (sum, value) =>\n                if (value >\
    \ 0) sum + value * value else sum\n        }\n        sum :: arr.filter(n => n\
    \ % sum == 0).length", "        var total = 0\n        var count = 0\n       \
    \ for ( i <- arr.iterator ) total += i\n        arr.foreach {\n          i =>\n\
    \            if ( i < 0 || i >= 10 ) {\n              if ( i < 0 ) count = count\
    \ + 1\n              else {\n                for ( j <- 0 until -i-10 ) {\n  \
    \                total -= 10\n                  total += i\n                 \
    \ if ( total > 10 ) break\n                }\n              }\n            } else\
    \ {\n              if ( i < 0 ) count = count + 1\n              else {\n    \
    \            for ( j <- 0 until i-10 ) {\n                  total -= 10\n    \
    \              total += i\n                  if ( total > 10 ) break\n       \
    \         }\n              }\n            }\n        }\n        count", "    \
    \  val firstDig = arr(0)\n      val arrCopy = arr.toList\n      val digitCount\
    \ = arr.length\n      val sumDig = arrCopy.foldLeft(0) { (sum, n) =>\n       \
    \ sum + n.signum\n      }\n      firstDig == arrCopy.head && sumDig == arrCopy.last",
  "      var sum = 0l\n      val arr = arr.reverse\n      for (i <- arr) {\n     \
    \   sum += i\n      }\n      if (sum == 0) 0l\n      else if (sum < 0) arr.takeWhile(_.isNegative).reverse\
    \ |> count { n => n % 10 > 0 }\n      else arr.count { n => n % 10 > 0 }", " \
    \       // TODO: use foldLeft, map, and a mutable count\n        val count_arr\
    \ : mutable.Map[Long, Long] = mutable.Map.empty[Long, Long]\n        arr.map(_\
    \ % 100).toList.foreach(x => count_arr += x -> (count_arr.getOrElse(x, 0) + 1l))\n\
    \        count_arr.reduceLeft((a, b) => (a + b)).sum", "      arr.foreach( x =>\
    \ {\n        if( x < 0 ){\n          x = x * -1\n        }\n        for( i <-\
    \ 0 until 10 ){\n          if( x % 10 == i ){\n            if( x % 100 != 0 )\
    \ x += 1\n          }\n        }\n        if( x >= 10 ){\n          x += 1\n \
    \       }\n      })\n      arr.count( x => x > 0 )", "        val first = arr.head\n\
    \        val rest = arr.tail\n        val negative = arr.head.signum\n       \
    \ val n = rest.length\n        if (n < 2) first\n        else (negative) ? ((rest.sum\
    \ >= 0) ? (n + 1) : ((rest(n - 1) - first).signum + 1) + 1) : (rest.sum >= 0)\
    \ ? ((rest.sum + first).signum + 1) : 1", "        arr.foldLeft(0l){ (acc, elem)\
    \ =>\n            acc + (math.abs(elem).asDigits(10).filter(_.isDigit).sum > 0\
    \ ? 1 : 0)\n        }", "        arr.foldLeft((0l, 0)) { ((acc, element), (acc1,\
    \ digit)) =>\n            digit.signum match {\n                case -1 => acc\
    \ -> (acc1 + 1l)\n                case _ =>\n                    if (element %\
    \ 10 != 0) acc -> (acc1 + 1)\n                    else acc -> (acc1 + digit)\n\
    \            }\n        }._1", "        // We need to do two passes:\n       \
    \ // Pass 1: Count the number of positive numbers in the array\n        val nums\
    \ = arr.filter(_ > 0).toList\n        var count = 0L\n        for (n <- nums)\n\
    \            if ((n - 1).toString.sum > 0)\n                count = count + 1L\n\
    \        \n        // Pass 2: Remove all those negative numbers we counted in\
    \ pass 1\n        var newArr = (0 until count).map(_ => -1).toList\n        newArr\
    \ = newArr ++ nums\n        \n        // Convert the new array to an array\n \
    \       val newNums = (0 until newArr.length).map(_ => newArr.toArray[Long](0))\n\
    \        \n        // Now do the count\n        var numsWithSum = 0\n        for\
    \ (n <- newNums)\n            if ((n - 1).toString.sum > 0)\n                numsWithSum\
    \ = numsWithSum + 1L\n        \n        numsWithSum", '        arr.map(i => abs(i)).filter(_
    > 0).count() ', "       val sum = arr.filter(_ % 10).length\n       if (sum <\
    \ 0) (-arr.head % 10).asInstanceOf[Int] else sum", "       var count = 0\n   \
    \    arr.foreach(x => {\n           val sum = x.toString.toLong\n           if\
    \ (sum > 0) count += sum\n       })\n       count", "        val digits = arr.map(i\
    \ => math.abs(i)).toSet\n        // Sum all digits if they're positive => sum\
    \ if x > 0 else sum if x < 0\n        var sum = 0\n        for( i <- digits if\
    \ i > 0 ){ sum += i}\n        // Sum all negative digits if they're positive =>\
    \ sum if x < 0 else sum if x > 0 \n        for( i <- digits if i < 0 ){ sum +=\
    \ i}\n        sum", "        if (arr.isEmpty) 0\n        else {\n            var\
    \ count = 0\n            var sign = 1\n            var i = -1\n            while\
    \ (i < arr.length) {\n                val digit = arr(i).toInt\n             \
    \   i += sign\n                if (digit > 0) {\n                    count +=\
    \ 1\n                }\n                sign *= -1\n            }\n          \
    \  count\n        }", "        if(arr.isEmpty) return 0\n        val n = arr.size\n\
    \        val res = mutable.ListBuffer.empty[Long]\n        var nSum = 0\n    \
    \    var last: Long = 0\n        arr.foreach(x => {\n            if(x == 0) return\n\
    \            if(nSum > 0) last = x % 10\n            nSum += x % 10\n        })\n\
    \        if(last.signum <= 0) nSum -= last\n        res += nSum\n        arr.filter(_\
    \ > 0).foreach(x => {\n            val diff = last - x % 10\n            if(diff\
    \ > 0) res += diff\n        })\n        res.sum", "        var total = 0l\n  \
    \      var i = 0\n        while (i < arr.length) {\n            if (arr(i) <=\
    \ 0) break\n            if (arr(i) > 0 && arr(i) != arr(i - 1)) total += 1\n \
    \           i += 1\n        }\n        total", "        arr.map {\n          \
    \  case x if x.signum <= 0 => -x.signum\n            case x => x.signum\n    \
    \    }.distinct().count { x => x > 0 }", "        arr match {\n            case\
    \ x :: xs => x.toString.map(_.asDigit).toList.filter(d => d > 0).sum\n       \
    \     case Nil => 0\n            case _   => sys.error(\"Not a List[Long]\")\n\
    \        }", "        def sumDigits(num : Long) : List[Int] = num.toString.map(_.toInt).map(_.toInt)\n\
    \        // For each number in the array, see if it is negative by looking at\
    \ the\n        // first sign of the number.\n        val negativeCount = arr.count(x\
    \ => x < 0)\n        var count = 0L\n        var negSum = Long.MinValue\n    \
    \    for(num <- arr) {\n            if(num < 0)\n                negSum += num\n\
    \            val digits = sumDigits(num)\n            for((digit, countDigit)\
    \ <- digits) {\n                count += countDigit\n                if( negSum\
    \ <= digit * countDigit )\n                    count -= (digit * countDigit -\
    \ negSum)\n            }\n        }\n        count - negativeCount", "       \
    \ val nums = arr.filter(_ > 0)\n        val list = nums.takeWhile(_ < Integer.MAX_VALUE).toList\n\
    \        val neg = (list.head - list.last).abs\n        val len = list.size -\
    \ neg.toLong\n        val sum = (list.sum - list.take(len).toList.sum).toLong\n\
    \        len.abs() * sum", "      var counter = 0\n      for (i <- arr) {\n  \
    \      if (i < 0l) {\n          i += 10\n        }\n        val digit = math.abs(i)\n\
    \        if (digit > 9) {\n          counter += digit % 10\n        } else {\n\
    \          counter += digit\n        }\n      }\n      counter", "        var\
    \ cnt = 0\n        arr.foreach(n => {\n            if (n > 0) cnt += math.gcd(n,\
    \ arr.sum)\n        })\n        cnt", "        val arr2 = arr.map{x => if(x >\
    \ 0) x else -x}\n        arr2.count(x=> x > 0)", "        var count = 0\n    \
    \    val arr = arr.toList\n        for (i <- arr) {\n            if (i != 0l)\
    \ {\n                val sum = i.asInstanceOf[Long].toString.dropWhile(x => x\
    \ < 48).drop(1).dropWhile(x => x < 58).toString.toInt\n                if (sum\
    \ > 0) count += 1 \n            }\n        }\n        arr match {\n          \
    \  case x :: y => countNums(y)\n            case Nil => count\n        }", " \
    \       arr.filter(_.nonEmpty).foldLeft((0l,0l)) { case ((sum, digits), n) =>\
    \ \n            val d = n.toString.toLong;\n            (sum + d.toInt*10, digits\
    \ + (if (d < 0) -d.toInt else 0))}._1", "        arr.foldLeft(0l){ \n        \
    \    case (nums, num) => \n                val digits = num.toString.reverse.foldLeft(\"\
    \")(_ + _)\n                (digits.tail.toLong, nums, digits.head.toLong * 10)\
    \ match {\n                    case (acc, (acc, sum, mult)) => (acc + sum * mult)\
    \ \n                }\n        }._2", "        val m = arr.head\n        val d\
    \ = arr.tail.foldLeft(0L)((i, x) => i + x * x.toLong)\n        m / d + 1", " \
    \       val res = new mutable.HashMap[Long, Long]()\n        for (i <- arr.indices)\n\
    \            if ((arr(i).toLong & 0xFFFF0000) < 0)\n                res.update(-(arr(i).toLong\
    \ & 0xFFFF0000), (1L*res.size))\n            else\n                res.update(arr(i).toLong,\
    \ (1L*res.size))\n        res.values.sum", "        val digitSums = arr.foldLeft(Map[Long,\
    \ Int]())((map, x) => {\n            val digit = math.abs(x)\n            val\
    \ oldValue = map.getOrElse(digit, 0)\n            val newValue = oldValue + digit\n\
    \            map += digit -> newValue\n            map\n        })\n        digitSums.values.sum",
  "        arr.foreach { x =>\n            // If x is negative, get the absolute value\
    \ of x and add 1 to the count\n            val absVal = math.abs(x)\n        \
    \    if (absVal < 1L) x + 1L\n            else 0L\n        }.sum", "        val\
    \ nums = arr.map(x => x.toString.toInt)\n        var numOfPositive = 0\n     \
    \   var numOfNegative = 0\n        for (xs <- nums) {\n            val n = xs.toInt\n\
    \            if (n < 0) numOfNegative += 1\n            else if (n >= 0) numOfPositive\
    \ += 1\n        }\n        numOfPositive + numOfNegative", "        val result\
    \ = arr.foldLeft(0l) { (acc: Long, num: Long) => acc + num / 10 }\n        if\
    \ (result < 0L) -result else result", "        val list = arr.toList\n       \
    \ val n = list.size\n        var sum : Long = 0\n        var lastDigit : Option[Long]\
    \ = None\n\n        for (i <- 0 until n) {\n            val curDigit = if (list(i)\
    \ > 0) list(i).asDigit else 0\n            sum = sum + curDigit\n\n          \
    \  // if sum >= 10, then the last digit must be zero\n            if (sum >= 10)\
    \ {\n                lastDigit = Some(sum % 10)\n                sum = 0\n   \
    \         }\n        }\n\n        // the last digit must be zero\n        sum\
    \ = sum + lastDigit.get // use getOrElse to handle None case\n        list.length.filter(_\
    \ > 0).foldLeft(0)((count, i) => count + i)", "        val sum = 0\n        var\
    \ count = 0\n        for (num <- arr) {\n            if (num > 0) {\n        \
    \        count += (math.ceil(num / 10.toDouble) * 10)\n                sum +=\
    \ num % 10\n            }\n            else {\n                count += 1\n  \
    \              sum += num.toLong % 10\n            }\n        }\n        sum +\
    \ (math.ceil((count - 1) / 10) * 10) - sum", "        var count = 0\n        var\
    \ num = 0\n        for (i <- 0 until arr.size) {\n            if (arr(i) < 0)\
    \ {\n                val d = arr(i) mod 10 // get first digit of number\n    \
    \            val sign = if (d < 0) -1 else 1\n                num += sign * d\n\
    \            }\n            else {\n                num += arr(i)\n          \
    \  }\n            num %= 10 // remove the first digit\n            count += 1\n\
    \            if (count == arr.size) {\n                num\n            }\n  \
    \      }", "        if(arr.isEmpty) {\n            return 0\n        }\n\n   \
    \     val digits = arr.map(_.toString.toDouble)\n            .map(_.toInt)\n\n\
    \        if(digits.isEmpty) {\n            return 0\n        }\n\n        val\
    \ max = digits.max()\n        val maxIdx = digits.indexOf(max)\n        val sumOfDigits\
    \ = digits.sum\n\n        // negative numbers have negative first (sign) digit\n\
    \        if(arr.head < 0){\n            sumOfDigits *= -1\n        }\n\n     \
    \   if(sumOfDigits == 0){\n            return 1\n        }\n\n        val currSum\
    \ = sumOfDigits / (1l / 10)\n        val currIdx = (maxIdx + 1) % arr.length\n\
    \        val newSum = digits(currIdx) + digits(currIdx + 1)\n\n        if(newSum\
    \ == 0){\n            return 1\n        }\n\n        val nextIdx = (currIdx +\
    \ 1) % arr.length\n        val nextSum = digits(nextIdx) + digits(nextIdx + 1)\n\
    \n        val newSumNewIdx = currIdx + (newSum / digits(currIdx))\n        val\
    \ nextSumNewIdx = nextIdx + (nextSum / digits(nextIdx))\n\n        if(newSumNewIdx\
    \ == 0 && nextSumNewIdx == 0){\n            return 1\n        }\n\n        if(newSumNewIdx\
    \ < 0){\n            newSumNewIdx += 1\n        }\n\n        if(nextSumNewIdx\
    \ < 0){\n            nextSumNewIdx += 1\n        }\n\n        if(newSumNewIdx\
    \ > arr.length){\n            newSumNewIdx -= 1\n        }\n\n        if(nextSumNewIdx\
    \ > arr.length){\n            nextSumNewIdx -= 1\n        }\n\n        val newDigits\
    \ = digits.drop(newSumNewIdx)\n        val nextDigits = digits.drop(nextSumNewIdx)\n\
    \        val newMaxIdx = newDigits.indexOf(newDigits.max())\n        val nextMaxIdx\
    \ = nextDigits.indexOf(nextDigits.max())\n\n        val newIdx = (newMaxIdx +\
    \ 1) % newDigits.length\n        val nextIdx = (nextMaxIdx + 1) % nextDigits.length\n\
    \n        val newSumNewIdx2 = newSumNewIdx + (newSum / newDigits(newSumNewIdx))\n\
    \        val nextSumNewIdx2 = nextSumNewIdx + (nextSum / nextDigits(nextSumNewIdx))\n\
    \n        if(newSumNewIdx2 == 0 && nextSumNewIdx2 == 0){\n            return 1\n\
    \        }\n\n        if(newSumNewIdx < 0){\n            newSumNewIdx2 += 1\n\
    \        }\n\n        if(nextSumNewIdx < 0){\n            nextSumNew", "     \
    \   val m = arr.foldLeft(new mutable.HashMap[Long, Int]()){\n            case\
    \ (acc, x) =>\n                acc.getOrElse(x * 10 + x.signum(), 0) += 1;\n \
    \               acc\n            }\n        m.values.sum;", "        val digits\
    \ = arr.map(_.toInt)\n        val sumOfDigits = digits.foldLeft(0)((acc, x) =>\
    \ acc + x)\n        sumOfDigits > 0", "        val counts = mutable.Map[Long,\
    \ Int]()\n        arr.foreach{numOfDigits =>\n            val countOfDigits =\
    \ counts(numOfDigits)\n            countOfDigits += 1\n            counts(numOfDigits)\
    \ = countOfDigits\n        }\n        arr.zipWithIndex.filter(f => f._2 > 0).map(f\
    \ => f._1).sum", "      var count = 0\n      arr.foreach(x => {\n        if ((x\
    \ % 10) > 0) {\n          count += 1\n        }\n      })\n      count", "   \
    \     arr.foldLeft(0l)((n, x) => n + (x % 10 > 0 ? 1 :\n            (x % 10 <\
    \ 0 ? -1 : 0)))", "        if (arr.isEmpty)\n            return 0l\n        if\
    \ (arr(0) < 0)\n            return countNums(arr diff 0l)\n        var sum = 0l\n\
    \        val digits = arr.map(_.toString.map(_.toInt))\n        val nums = digits(0)\n\
    \        var sumOfDigits = 0\n        for (i<-0 to nums.size-1)\n            if\
    \ (nums(i) > 0)\n                sumOfDigits += nums(i)\n        if (sumOfDigits\
    \ >= 10)\n            sum += nums.size\n        else\n            for ((digit,\
    \ index) <- digits.zip(Array.range(0, digits.size))) {\n                if (digit\
    \ > 0)\n                    sum += digit\n            }\n        return sum",
  "        var sum = 0L\n        for (num <- arr) {\n            if (num > 0) sum\
    \ += num\n            else return sum\n        }\n        return sum", "     \
    \   val nums = arr.filter(_ > 0)\n        if (nums.isEmpty) {\n            return\
    \ 0\n        }\n        val first = nums.head\n        val last  = nums.last\n\
    \        var count = 0\n        for (i<- first until last){\n            count\
    \ += i / 10 + (i % 10 != 0)\n        }\n        count", "        var sum = 0\n\
    \        var count = 0\n        for (i <- arr) {\n            if (i <= 0)\n  \
    \              continue\n            sum += i\n            count += 1\n      \
    \  }\n        sum", "        val counts = mutable.Map.empty[Long, Long]\n    \
    \    val minSum = 0\n        arr.foreach { e =>\n            val sum = e.toString.sum.toLong\n\
    \            val sumOfDigits = sum % 10\n            if (sumOfDigits > 0)\n  \
    \              if (minSum == 0 || sumOfDigits < minSum)\n                    minSum\
    \ = sumOfDigits\n                counts(sumOfDigits) = counts(sumOfDigits) + 1\
    \ \n            }\n        minSum", "        var count = 0\n        for (el <-\
    \ arr) {\n            val l = abs(el)\n            val digits = l % 10\n     \
    \       val num = (l / 10).floor\n            if (num > 0) {\n               \
    \ // we know all digits must be positive, so if the remaining\n              \
    \  // digits are negative, then they will be positive and we'll want\n       \
    \         // to count them.\n                if (digits < 0) {\n             \
    \       count += 1\n                }\n            }\n        }\n        count",
  "        var count = 0\n        var sum = 0\n        var sumOfDigits = 0\n     \
    \   arr.foreach(x => {\n            sum += x\n            sumOfDigits += x.toString.reverse.foldLeft(0)(_\
    \ + _)\n        })\n        if (sumOfDigits > 0) count += sumOfDigits / 10\n \
    \       count += arr.length\n        count += arr.count(x => x < 0)\n        val\
    \ nums = arr.filter(x => x.toString.reverse.foldLeft(0)(_ + _) <= 9 && x.toString.reverse.foldLeft(0)(_\
    \ + _) >= 0)\n        count += nums.count(x => x.toString.reverse.foldLeft(0)(_\
    \ + _) > 9)\n        count += arr.count(x => x > 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLeft(0)(_ + _) < 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLeft(0)(_ + _) >= 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLeft(0)(_ + _) <= 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLeft(0)(_ + _) < 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLeft(0)(_ + _) <= 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLeft(0)(_ + _) >= 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLeft(0)(_ + _) <= 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLeft(0)(_ + _) >= 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLeft(0)(_ + _) <= 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLeft(0)(_ + _) >= 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLeft(0)(_ + _) <= 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLeft(0)(_ + _) >= 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLeft(0)(_ + _) <= 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLeft(0)(_ + _) >= 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLeft(0)(_ + _) <= 9)\n        count += arr.count(x\
    \ => x.toString.reverse.foldLe", "        val ns = arr.groupBy(x => Math.abs(x).toInt).values\n\
    \        ns.reduce{(x, y) => x + y.toLong}", "        val counter = scala.collection.mutable.Map[Long,\
    \ Long]()\n        for (i <- arr.indices) {\n            val firstDigit = arr(i).toInt\n\
    \            val secondDigit = arr(i+1).toInt\n            val thirdDigit = arr(i+2).toInt\n\
    \            val fourthDigit = arr(i+3).toInt\n            val fifthDigit = arr(i+4).toInt\n\
    \            val sixthDigit = arr(i+5).toInt\n            val seventhDigit = arr(i+6).toInt\n\
    \            val eighthDigit = arr(i+7).toInt\n            val ninthDigit = arr(i+8).toInt\n\
    \            val tenthDigit = arr(i+9).toInt\n            if (firstDigit > 0 &&\
    \ firstDigit < 10 && secondDigit > 0 && secondDigit < 10 && thirdDigit > 0 &&\
    \ thirdDigit < 10 && fourthDigit > 0 && fourthDigit < 10 && fifthDigit > 0 &&\
    \ fifthDigit < 10 && sixthDigit > 0 && sixthDigit < 10 && seventhDigit > 0 &&\
    \ seventhDigit < 10 && eighthDigit > 0 && eighthDigit < 10 && ninthDigit > 0 &&\
    \ ninthDigit < 10 && tenthDigit > 0 && tenthDigit < 10) {\n                val\
    \ sum = firstDigit * 10 + secondDigit * 10 + thirdDigit * 10 + fourthDigit * 10\
    \ + fifthDigit * 10 + sixthDigit * 10 + seventhDigit * 10 + eighthDigit * 10 +\
    \ ninthDigit * 10 + tenthDigit\n                counter.put(sum, 0)\n        \
    \        counter.getOrElseUpdate(sum, 1)._1\n            }\n        }\n      \
    \  counter.size + 1", "        var cnt = 0\n        var num = 0\n        for (x\
    \ <- arr) {\n            num = (x.toInt)*10\n            if (num > 0){\n     \
    \           cnt += num\n            }\n        }\n        cnt", "        // Initialize\
    \ countNums\n        var count = 0;\n        // Initialize a mutable list to hold\
    \ numbers with positive sums\n        var arr2 = arr.filter(_ > 0);\n        for\
    \ (n <- arr2) count += n.abs\n        // Return the count of numbers with positive\
    \ sums\n        count", "        var count = 0\n        for (x <- arr) {\n   \
    \         count += count_nums(x).toLong\n        }\n        count", '        arr.filter(x
    => x > 0).length', "        if (arr.isEmpty || arr.head < 0)\n            return\
    \ 0\n        var sum : Long = 0\n        for (i<-arr.indices) {\n            val\
    \ n = arr(i)\n            var sum : Long = 0\n            while (n > 0) {\n  \
    \              sum = sum + n % 10\n                n = n / 10\n            }\n\
    \            if (sum > 0) {\n                sum = 1\n            }\n        \
    \    sum = sum * 10 + sum\n        }\n        return sum", "        var result\
    \ : Long = 0\n        var currentSum : Long = 0\n        for (i <- arr) {\n  \
    \          currentSum += i\n            if (currentSum > 0) {\n              \
    \  result+=1\n            }\n        }\n        result", "        val zeros =\
    \ arr.count(i => i <= 0)\n        val numbers = arr.count(_ > 0)\n        val\
    \ firstPositive = arr.count(_ > 0 && _ > 0)\n        (numbers - firstPositive)\
    \ / arr.size.toLong", "        val n = arr.length\n        var nums : List[Long]\
    \ = null\n        var j = 0\n        var sum : Long = 0\n        while (j < n)\
    \ {\n            sum += arr(j)\n            j += 1\n        }\n        nums =\
    \ arr.filter(_ > 0).filter(_ % 10 != 0)\n        nums.filter(_ > 0).filter(_ %\
    \ 10 == 0).foldLeft((0l)) { (acc, val) =>\n            val d = math.signum(val)\n\
    \            val i = acc._2 + (d * 10)\n            val j = (d * 10) - i\n   \
    \         (i, j) match {\n                case (null, 0) -> acc\n            \
    \    case (null, 1) => acc\n                case (i, 0) -> acc\n             \
    \   case (i, 1) -> if (i < n) acc + 1 else acc\n            }\n        }._2",
  "        // TODO: write your code here\n        return arr.filter(x => x % 2 !=\
    \ 0) match {\n            case x :: y => x + y\n            case _ => 0\n    \
    \    }", "        if (arr.isEmpty) 0\n        else {\n            var result =\
    \ arr.foldLeft(0l)( (acc, e) => acc + math.abs(e) )\n            if (result <\
    \ 0) result * -1\n            else result\n        }", "        val count = mutable.HashMap.empty[Long,\
    \ Long]\n        var sum = 0l\n        for (i <- arr) {\n            sum += i\n\
    \            count.get(sum) match {\n                case None =>\n          \
    \          count(sum) = i\n                case Some(count) => count.get += 1\n\
    \            }\n        }\n        count.filter(_._2 > 0).size", "        var\
    \ count = 0\n        arr.foreach(x => {\n            val sum = x.toString.toLong.sum\n\
    \            val sign = if (x.toString.toLong.signum <= 0) 1 else -1\n       \
    \     if (sum > 0) count += sign * sum\n        })\n        count", "        var\
    \ sum = 0\n        for (i <- arr) {\n            if (i < 0)\n                sum\
    \ += i.toInt - Math.max(0l, i.toInt)\n            else\n                sum +=\
    \ i.toInt\n        }\n        sum", "        var nums = arr.filter(x => x >= 0).map(x\
    \ => x - x.toInt).distinct\n        nums.foldLeft(0)((acc, x) => acc * x).toLong",
  "        if(arr.isEmpty) 0\n        else if(arr.head._2 >= 0) arr.head._1 + countNums(arr.tail)\n\
    \        else -countNums(arr.tail)", "        if (arr.isEmpty) 0\n        else\
    \ arr.head + countNums(arr.tail)", "        val n = arr.length\n        var count\
    \ = 0\n        for ((sum, val) <- arr.zipWithIndex collect {case (s, i) => if\
    \ (s > 0) (s, i) }) {\n            val rem = sum % 10\n            if (rem ==\
    \ 0) count += 1\n        }\n        count", "        var sum = 0\n        var\
    \ last = 0\n        var count = 0\n        for (i <- arr.length) {\n         \
    \   val temp = arr(i)\n            sum += temp\n            if (temp > 0) {\n\
    \                if (sum > 0) {\n                    last = temp\n           \
    \     } else {\n                    if (temp < 0)\n                        count\
    \ -= 1\n                }\n            }\n        }\n        if (count == 0)\n\
    \            count\n        else\n            countNums(arr.drop(count).toList).filter(_\
    \ > 0).last", "        arr.foreach { x =>\n            var count = 0\n       \
    \     var s = Math.abs(x)\n            while (s != 0) {\n                count\
    \ += 1\n                if (s % 10 > 0) {\n                    s = s / 10\n  \
    \              } else {\n                    s = s * 10\n                }\n \
    \           }\n            if (count > 0) {\n                arr.remove(x)\n \
    \           }\n        }\n        arr.length", "        var count : Long = 0\n\
    \        for (i <- arr) count += i.asInstanceOf[Long]\n        count + arr.filter(_.asInstanceOf[Long]\
    \ < 0).headOption.map(_.asInstanceOf[Long]).getOrElse(0)", "        val digits\
    \ = arr.flatMap(_.toString.toLong)\n        val zero = digits.sum - digits.filter(_\
    \ < 0).sum\n        if (zero > 0) zero else digits.foldLeft(0)((sum, digit) =>\
    \ sum + digit)", "        var count = new collection.mutable.HashMap[Long, Long]();\n\
    \        for(number <- arr) {\n            val digits = math.abs(number);\n  \
    \          var newCount = count.get(number);\n            if (newCount == null)\n\
    \                newCount = digits;\n            else\n                newCount\
    \ += digits;\n            count.put(number, newCount);\n        }\n        val\
    \ total = count.values.sum;\n        return total;", "        // Iterate through\
    \ each element in the list until you find a negative\n        // number and stop\
    \ when you have found all the positive numbers.\n        var pos = arr.head -\
    \ 1\n        var neg = 0\n        for(n <- arr) {\n            if (n < 0) pos\
    \ = n\n            else {\n                neg += 1\n                break\n \
    \           }\n        }\n        // Now that you have all the positive numbers,\
    \ count the number of numbers\n        // whose sum of the digits is > 0 (i.e.\
    \ the first positive number is the\n        // answer)\n        var ans = 1\n\
    \        for(n <- arr) {\n            if (n < 0) break\n            ans += 1\n\
    \            val d = n.toString.split('')\n            val sum = d.sum.toLong\n\
    \            if (sum > 0) continue\n            val sumDigits = sum / 10 % 10\n\
    \            if (sumDigits < 0) sumDigits *= -1\n            if (sumDigits ==\
    \ 0) continue\n            if (sumDigits < 3) sumDigits *= -1\n            ans\
    \ += (sumDigits.toLong)\n        }\n        ans + (arr.length - neg)", "     \
    \   val nums   = arr.filter(x => x != 0).map(x => math.abs(x)).sum\n        val\
    \ sign   = arr.takeWhile(_ < 0).last\n        val digits = math.abs(sign / 10)\n\
    \        val rest  = arr.drop(sign)\n        nums * digits", "        arr match\
    \ {\n            case Nil => 0\n            case x :: xs => val result = countNums(xs)\n\
    \                           if (x >= 0) (x + result) else if (x < 0) (-x + result)\
    \ else result\n        }", "        var count = 0\n        for(i <- arr)\n   \
    \         count += count_nums(i.toList)\n        count", "        // TODO: Write\
    \ your solution here\n        val list = arr.toList\n        val sum = (list.foldLeft(1l){_\
    \ + _ })\n        val digits = list.map(_.toString.toLong).sum\n        if(sum\
    \ > digits) {\n            sum - digits\n        } else {\n            0\n   \
    \     }", "        def countNums_helper(acc: Long, i : Long, acc2 : List[Long])\
    \ : Long = {\n            if (i >= 0) {\n                acc += i\n          \
    \      countNums_helper(acc, i-1, acc2)\n            } else if (i < 0) {\n   \
    \             acc2 += i\n                acc += i\n                countNums_helper(acc,\
    \ i, acc2)\n            }\n        }\n        countNums_helper(0l, arr.head.asInstanceOf[Long],\
    \ Nil)", "        // Initialize two counters, i and j\n        var i = 0\n   \
    \     var j = 0\n        var sum = 0\n\n        // Find the sum of the digits\
    \ of the given number\n        for( x <- arr ) {\n            sum += x\n     \
    \       if( sum > 10 ) {\n                sum += x-10\n                i += 1\n\
    \                j = 0\n            } else if( sum < -10 ) {\n               \
    \ sum -= x\n                i += 1\n                j = 0\n            } else\
    \ {\n                j += 1\n            }\n        }\n\n        // Return the\
    \ count of elements with sum greater than 0\n        return j", "        arr.foldLeft(0l)\
    \ { (sum, el) =>\n            val sum = sum + el % 10;\n            val sign =\
    \ el % 10 < 0 ? -1 : 1;\n            sum * sign\n        }", "        if (arr.isEmpty)\
    \ 0\n        else arr.head match {\n            case 0 => arr.length\n       \
    \     case x if (x > 0) => countNums(arr.tail) if (isSigned(x)) else (countNums(arr.tail)\
    \ * -1)\n            case x if (x < 0) => countNums(arr.tail) * (isSigned(x) ?\
    \ -1 : 1l)\n            case x => countNums(arr.tail) + (isSigned(x) ? x.toLong\
    \ % 10 : 0l)\n        }", "        // initialize counts\n        val counts =\
    \ (0 until arr.length).map(i => 0 until arr.length).map(j => 0)\n        var cnt\
    \ = 0\n        for (i <- 0 until arr.length) {\n            val v = arr(i).toInt\n\
    \            val l = v.floor.toInt\n            val h = v.ceil.toInt\n       \
    \     if (l < 0) counts(l-1) += 1\n            if (h < 0) counts(h-1) += 1\n \
    \       }\n        cnt", "        arr.foldLeft((0l,0l)) {\n            (sum, elem)\
    \ => elem.toString.toLong.signum match {\n                case -1 => (sum._1 +\
    \ 1, sum._2)\n                case 0 => (sum._1, sum._2 + 1)\n               \
    \ case 1 => (sum._1 + 1, sum._2)\n            }\n        }._1", "      val zero\
    \ = new Array[Int](arr.size)\n      zero.foreach(x => arr(x) >= 0)\n      arr.foldLeft((0l,\
    \ zero)) {\n        case ((a, zero), x :: tail) => (a + x, zero) //(a,x) + zero\n\
    \      }._1 //the final result", "        val summedArr = arr.foldLeft(List[Long]())((acc,\
    \ element) => {\n            if(element < 0) {\n                acc.flatMap(x\
    \ => List[Long](x - element.toLong, element + x.toLong, x))\n            } else\
    \ {\n                acc ++ List(element + x.toLong, x)\n            }\n     \
    \   })\n        summedArr.foldRight(0) {\n            case (acc, element) => acc\
    \ if element % 10 == 0 else acc + element % 10\n        }", "        def digitSum(x:\
    \ Long, digits: List[Long]) : Long = {\n            digits(x) ++ digits(x + 1)\n\
    \        }\n        var count = 0\n        val digitSums = arr.map(digitSum)\n\
    \        for (sum <- digitSums) {\n            if (sum > 0) {\n              \
    \  count += 1\n            }\n        }\n        count", '        arr.foldLeft(0l)
    { (res, num) => res + num / 10 }', '        arr.foldLeft(0L){(sum, v) => sum +
    math.pow(10, math.abs(v.toInt))}', "        if (arr.isEmpty)\n            return\
    \ 0\n        val nums = arr.toSet\n        var sum = 0\n        while(sum < 10)\n\
    \            sum += nums.foldLeft(0){\n                case (acc, x) => acc +\
    \ (x.signum() * ((10 - sum) * x.toLong))\n            }\n        return sum",
  "        def countDigits(arr : List[Long], sum : Long) : Long = {\n            val\
    \ n = arr.length\n            if (n == 0) sum\n            else {\n          \
    \      val lSum = arr.foldLeft(0)( (sum, element) => sum + element%10 )\n    \
    \            if (lSum < 0) sum + Math.abs(lSum) * Math.signum(arr(n - 1))\n  \
    \              else countDigits(arr.dropRight(1), lSum)\n            }\n     \
    \   }\n        countDigits(arr, 0l)", "        if (arr.isEmpty) return 0\n   \
    \     val maxSum = arr.foldLeft(0l)( (maxSum, v) => v > 0 ? maxSum + v % 10 +\
    \ (v / 10).abs : 0)\n        val digitSums = arr.map { v => (v % 10).abs + v /\
    \ (10).abs }.distinct\n        digitSums.filter(_ > 0).sum * maxSum", "      \
    \  var sum = 0\n        for (x <- arr) if (x > 0) sum+= abs(x)\n        sum",
  "        val total = 0L\n        for (i <- 0 until arr.length) {\n            total\
    \ += arr(i).abs\n            if (total < 0) {\n                return total.toLong\
    \ - arr(i).toLong\n            }\n        }\n        return 0", "        val newArr:\
    \ mutable.Buffer[Long] = arr.filter(i => i.isPositive)\n        if (newArr(0).isPositive)\
    \ {\n            newArr.drop(1).sum\n        } else {\n            arr.sum\n \
    \       }", "        var ans = 0\n        var sum = 0\n        for (i <- arr.indices)\
    \ {\n            sum += arr(i)\n            if (sum > 0) {\n                ans\
    \ += sum\n            }\n        }\n        ans", '        arr.reduceLeft(l =>
    if(l.toString.filter(_.isDigit).isEmpty) 0 else 1) + (arr.filter(_.toString.filter(_.isDigit).nonEmpty).isEmpty)',
  "        var count = 0\n        for( n <- arr if n > 0 ) count += sum(n/10.toInt).drop(1).map(\
    \ x => (x*10+n.toInt) ).drop(1).length\n        count", "        val result =\
    \ arr.filter(_ > 0).length\n        result + (if (arr.head < 0l) -arr.head else\
    \ 0)", "        var result = 0\n        arr.foreach { i =>\n            if ((i\
    \ > 0L) && (i % 10L > 0L)) {\n                result = result + 1\n          \
    \  }\n        }\n        result", "        arr match {\n            case Nil =>\
    \ 0\n            case h :: t => {\n                val d = Math.max(h.signum,\
    \ t) //first signed digit\n                val sign = if (d < 0) -d else d\n \
    \               (h % 10) + sign * countNums(t.filter(_ < h))\n            }\n\
    \        }", '        arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.sumDigits > 0) ? arr.foldRight(0)(_
    + _.sumDigits > 0) ? arr.foldRight(0)(_ + _.', "        if(arr.isEmpty) 0\n  \
    \      else arr.map(x => (x * x).toInt).count(x => x > 0)", "        val s = arr.foldLeft(0l){\n\
    \            case (count, e) => if (e < 0) -count else count}\n        if (s ==\
    \ 0) 0 else (Math.log10(s).toDouble - Math.log10(s)).toLong", "        val count\
    \ = mutable.Map[Long, Int]()\n        for(i <- arr) {\n            if(i.signum\
    \ <= 0)\n                count += i -> 0\n            else {\n               \
    \ val j = i - i.abs\n                if(j > 0)\n                    count += i\
    \ -> count.getOrElse(i, 0) + 1\n                else {\n                    count\
    \ += i -> 0\n                }\n            }\n        }\n        count.values.sum",
  "        val n = arr.size\n        var count = 0\n        var sum = 0\n        for\
    \ (x <- arr) {\n            sum = sum + x.toInt\n            if (sum < 0) {\n\
    \                count = count - 1\n                sum = sum + 10\n         \
    \   }\n            else {\n                count = count + 1\n            }\n\
    \        }\n        (count) //.toLong", "        val digits = arr.map(_.toString.toInt)\n\
    \        digits.foldLeft(0l)((acc, digit) =>\n            if (digits.tail.forall(digit2\
    \ => digit + digit2 > 0)) acc + 1\n            else acc\n        )", "       \
    \ // Your code here!\n        val list = arr.map(_.toString.toInt)\n        val\
    \ n = arr.length\n        val sum = 0\n        for(i <- 0 until n)\n         \
    \   sum = sum + list(i)\n        sum", "        var n = 0L\n        var sum =\
    \ 0L\n        var firstDigit = arr(0)\n        for (x <- arr) {\n            if\
    \ (x > 0) sum += x\n            else {\n                if (firstDigit < 0)\n\
    \                    firstDigit = -x\n                sum += firstDigit + x\n\
    \                n++\n                firstDigit = 0\n            }\n        }\n\
    \        n", '        arr.map(x => if(x<0) x+(x%10)*-1 else x).foldLeft(0L){(x,n)
    => x+n}', "       var cnt : Long = 0\n       for (i <- 0 until arr.length) {\n\
    \          val s = arr.take(i).sum\n          if (s > 0) cnt += 1\n       }\n\
    \       cnt", "       var n = arr.size\n       val n1 = arr.foldLeft(0)(_ + _)\n\
    \       n = arr.size - n1\n       val n2 = arr.foldRight(0)(_ + _)\n       return\
    \ (n2 - n) / n ", "        val nums = arr.flatMap{\n            // Get each digit\n\
    \            val digit = (it + 10).floorToInt\n            // Get the last digit\
    \ of the sum\n            val last = it.subtract(digit)\n            if (last\
    \ < 0) then -last else digit\n        }\n        nums.length", "      var sum\
    \ = 0\n      var neg = 0\n      arr.foreach(x => {\n        if(x >= 0) {\n   \
    \       sum += x\n          neg = 0\n        } else {\n          sum += x * Math.pow(10,-neg)\n\
    \          neg = -1\n        }\n      })\n      return arr.size * (sum / 10)",
  "        val sum: Long = 0\n        for (i <- arr.indices) {\n            sum +=\
    \ arr(i)\n        }\n        sum", "        val totalSum = 0\n        arr.foreach\
    \ { x => totalSum+=x }\n        arr.toSet.filter(x => x == totalSum).length",
  "        val res = mutable.Map[Long, Int]()\n        for (i <- arr) {\n        \
    \    if (i < 0)\n                res.put(i.toInt.abs, res.getOrElse(i.toInt, 0)\
    \ + 1L)\n            else\n                res.put(i.toInt, res.getOrElse(i.toInt,\
    \ 0) + 1L)\n        }\n        res.filter(_._2 > 0).size", "        val counts\
    \ = mutable.Map.empty[Long, Int]\n        for {\n            i <- arr\n      \
    \  } if (i.toString.length() > 0 && i.signum <= 0) counts += (i.toLong -> 1)\n\
    \        val res = counts.toSeq.sum\n        res match {\n            case 0 =>\
    \ 0\n            case l => l\n        }", "        var n = 0\n        for (x <-\
    \ arr) {\n            if (x < 0) x += BigInt(10) * (-x)\n            n = math.max(n,\n\
    \                math.max(math.min(x - BigInt(9), BigInt(0)) - BigInt(9), 0))\n\
    \        }\n        n", "        arr match {\n            case Nil => 0\n    \
    \        case _ => {\n                var sum : Long = 0\n                var\
    \ sign = 0\n                for (i <- arr) {\n                    if (i >= 0)\
    \ {\n                        sum += i\n                    } else if (i < 0) {\n\
    \                        sign = i\n                        sum += sign\n     \
    \               } else {\n                        sum -= sign\n              \
    \      }\n                }\n                sum\n            }\n        }", " \
    \       if(arr.isEmpty) 0\n        else {\n            val positiveSum = 0\n \
    \           arr.foreach {\n                case x if x >= 0 && positiveSum + x\
    \ > 0\n                    => positiveSum += x\n                case x if x >=\
    \ 0 && positiveSum + x < 0\n                    => positiveSum = Math.abs(positiveSum)\
    \ + Math.abs(x)\n                case x if x >= 0 && positiveSum + x == 0\n  \
    \                  => positiveSum += 1\n            }\n            positiveSum\n\
    \        }", "        def isSmall(xs : List[Long], digits : List[Int]) : Boolean\
    \ = xs.headOption.exists(x=> digits.exists(y => y % x == 0))\n        def sumDigits(digits\
    \ : List[Int], i : Int, ndigits : Int) : Long = {\n            if (i == ndigits)\
    \ {\n                digits.sum\n            } else {\n                sumDigits(digits,\
    \ i+1, ndigits)*10 + digits.last\n            }\n        }\n        if (arr.isEmpty)\
    \ 0\n        else if (arr.head < 0 || arr.head > 9) -1\n        else {\n     \
    \       var n : Long = 0\n            var digits : List[Int] = List(0)\n     \
    \       while (!isSmall(arr,digits)) {\n                n += sumDigits(digits,\
    \ 0, digits.size)\n                digits = List(remainder(digits.last, arr.head))\n\
    \            }\n            n\n        }", "        var cnt = 0\n        var nums\
    \ = arr\n        val len = nums.length\n        for(i <- 0 until len) {\n    \
    \        if(nums(i) < 0) nums = nums.drop(1)\n            val d = nums(i).abs\n\
    \            val x = d.toInt\n            for(j <- 0 until x) cnt += (10L * (x.toLong\
    \ - j)).toLong\n        }\n        cnt", "        val m = arr.map(_ % 10).filter(_\
    \ > 0).length\n        if (arr.isEmpty) 0\n        else if (arr.forall(_.isNeg))\
    \ arr.sum.toLong\n        else {\n            val (positives, negatives) = arr.foldLeft((0l,\
    \ 0l)) {\n                case ((p, _), (neg, _)) => (p, neg + m.toLong)\n   \
    \         }\n            positives + negatives\n        }", "      var count =\
    \ 0\n      for(i <- 0 until arr.length) {\n        if(arr(i) >= 0) {\n       \
    \   if(arr(i) < 10) count += 1\n          else {\n            val temp = (arr(i)\
    \ - 10).toInt\n            if(temp > 0) count += 1\n          }\n        }\n \
    \       else {\n          val temp = arr(i).toInt\n          if(temp > 0) count\
    \ += 1\n        }\n      }\n      count", "        val nums = arr.map(x => math.abs(x))\n\
    \        val countNums = nums.filter(x => x > 0).size\n        val firstDigits\
    \ = nums.filter(x => x < 0).takeWhile(x => x < 0).size\n        val signs = nums.takeWhile(x\
    \ => x < 0).reverse.map(x => math.abs(x) < 0).reverse\n        val firstSigns\
    \ = signs.takeWhile(_ == 1).size\n        signs.drop(firstSigns).size", "    \
    \    if (arr.isEmpty) 0\n        else {\n            val count = arr.filter {\
    \ i => i > 0 }.size\n            arr.head > 0 ? -count : count\n        }", " \
    \     val nums     = arr.filter(_ >= 0).map(_.toInt)\n      val sums     = nums.map(_.toLong).sum\n\
    \      arr.filter(_ > 0).map(_.toInt).count(sums.toLong)", "        arr.foldLeft(0l){\
    \ (x, y) =>\n            val z = Math.abs(y)\n            if (y < 0) z - y < 0\
    \ ? y + 11 : y else z\n        }", "        if (arr.isEmpty) {\n            return\
    \ 0\n        }\n        var totalSum = 0\n        var sumOfDigits = 0\n      \
    \  var sign = 0\n        for (i<-arr.indices) {\n            sum = arr(i) + sign*sumOfDigits\n\
    \            sumOfDigits *= 10\n            sign = 1-sign\n            totalSum\
    \ += sum\n        }\n        arr.toList.count( x => x % 10 > 0 )", "        val\
    \ arr = arr.reverse\n        arr.foldLeft(0) { (cnt, cur) =>\n            val\
    \ digit = math.abs(math.signum(cur).toInt)\n            cnt + (digit > 0)\n  \
    \      }", "        val arr = arr.reverse\n        val n = arr.length\n      \
    \  if (n < 1) 0\n        else {\n            val digitSums = arr.map(x => x -\
    \ x.toString.toLong).scanLeft(0)(_ + _)\n            val filteredDigitSums = digitSums.filter(_\
    \ > 0).last\n            if (filteredDigitSums == 0) 0\n            else {\n \
    \               val totalDigits = digitSums.sum\n                val filteredSum\
    \ = digitSums.filter(x => x < 0).last\n                if (filteredSum < 0) totalDigits\
    \ - filteredDigitSums\n                else if (filteredSum > 0) filteredDigitSums\n\
    \                else 0\n            }\n        }", "        val n = arr.size\n\
    \        var result : Long = 0\n        for ((x, i) => arr(i) < 0) arr(i) *= -1\n\
    \        for ((x, i) => arr(i) == 0) result += n\n        for ((x, i) => arr(i)\
    \ > 0) result += countNums(arr.drop(i+1))\n        result", "        var count\
    \ = 0;\n        arr.foreach(x => if (x < 0) x *= -1l else x += x%10l.toLong);\n\
    \        arr.foreach(x => if (x == 0 && !arr.contains(x)) count += 1) else count\
    \ += arr.count(_ == x))\n        count", "        arr match {\n            case\
    \ Nil => 0\n            case x :: Nil => x.toInt\n            case x :: xs =>\n\
    \                var count = 0\n                var sum = 0\n                var\
    \ digits = 0\n                for (i <- x to xs.head) sum += i.toInt\n       \
    \         while (sum > 0) {\n                    if (sum >= 10) {\n          \
    \              digits += 1\n                        sum -= 10\n              \
    \      } else if (sum < 0) {\n                        digits -= 1\n          \
    \              sum -= Math.abs(sum)\n                    } else {\n          \
    \              sum -= digits\n                    }\n                    count\
    \ += 1\n                }\n                count\n        }", "        var count\
    \ = 0\n        var prev = 0L\n        for (i <- arr) {\n            prev = i\n\
    \            val digit = math.abs(math.floor((i - prev) / 10)) + 1\n         \
    \   count += (digit > 0)\n        }\n        count", "        if (arr.isEmpty)\
    \ 0\n        else if (arr.head < 0) arr.head - arr(0)\n        else arr.head -\
    \ arr(0)", "        var cnt = 0\n        arr.foreach{ x =>\n            if (x\
    \ > 0) {\n                cnt += math.abs(math.log10(x))\n            }\n    \
    \    }\n        cnt", "        val m = arr.size\n        arr.foreach { num =>\n\
    \            if (num < 0) num *= -1\n            var count = 0\n            while\
    \ (num > 0) {\n                val d = num %10\n                num /= 10\n  \
    \              count += d*d\n            }\n            if (num >= 0 && count\
    \ > 0) count\n            else 0\n        }.sum", "      var count = 0L\n    \
    \  arr foreach (x => if (x < 0) -x else x)\n      for (x <- arr) {\n        for\
    \ (y <- arr) {\n          if (x != y) { count += Math.signum(x - y) * (y - x +\
    \ 1) }\n        }\n      }\n      count", "        if (arr.isEmpty) {\n      \
    \      return 0\n        }\n        val firstDigit = arr(0)\n        if (firstDigit.signum\
    \ <= 0)\n            countNums(arr.filter(_ > 0))\n        else\n            countNums(arr.filter(_\
    \ >= 0 && _ % firstDigit != 0))", "        val len = arr.size\n        val counter\
    \ = mutable.Map.empty[Long, Long]\n        for (i <- 0 until len){\n         \
    \   val tmp = arr(i)\n            if(tmp <= 0) break\n            val lastDigit\
    \ = tmp % 10\n            val count = counter.get(lastDigit)\n            val\
    \ newCount = if (count == null) 0 else count + 1\n            val newCount = newCount.max(tmp\
    \ / 10)\n            counter.put(lastDigit, newCount)\n        }\n        val\
    \ result = counter.keys.toSet.count() match {\n            case 0 => 0\n     \
    \       case 1 => counter.get(0) + 1\n            case _ => counter.keys.toSet.count()\
    \ + 1\n        }\n        result", "        // Your code here\n        var sum\
    \ = 0\n        for(i <- 0 until arr.length) {\n            sum = sum + arr(i)\n\
    \        }\n        return sum", '        arr.filter(x => x.isDefined).count(x
    => if (x.toString.reverse.length == 1) x.toString.reverse else x.toString.reverse.head
    + x.toString.reverse.last) > 0', "      var count = 1\n      for(v <- arr) {\n\
    \        val d = (v >>> 0) % 10\n        val sign = if (v < 0) -1 else 1\n   \
    \     count *= sign\n        if(count > 9) count -= 10\n      }\n      count",
  "        var sum = 0\n        for (i<- arr) {\n            sum += math.abs(i)\n\
    \        }\n        if (arr.isEmpty) 0\n        else if (sum < 0) arr.head * -1\n\
    \        else arr.size", "        var count = 0;\n        for (i <- arr) {\n \
    \           if (i < 0) i += Math.pow(10, i.toInt)\n            var sum = 0\n \
    \           for (j <- 0 until i) {\n                sum += j % 10\n          \
    \  }\n            if (sum > 0) count++\n        }\n        count", "        arr.headOption\
    \ match {\n            case Some(num) =>\n                var numSum = 0\n   \
    \             val digits = arr.map(_.toString.toLong).toList\n               \
    \ for (i <- 0 until digits.length) {\n                    if (digits(i) < 0)\n\
    \                        digits(i) *= -1\n                    numSum += digits(i)\n\
    \                }\n                numSum\n            case None =>\n       \
    \         0\n        }", "        val count = mutable.HashMap[Long, Long]().withDefaultValue(0l)\n\
    \        arr.foreach{ x =>\n            val l = x.toInt\n            if (l > 0)\
    \ {\n                val l = scala.math.abs(l)\n                if (count.contains(l))\
    \ {\n                    count(l) = (count(l) + 1)\n                } else {\n\
    \                    count(l) = 1\n                }\n            }\n        }\n\
    \        count(arr.head) match {\n            case (_, 0) => 0\n            case\
    \ (n, 1) => n\n            case (n, _) => countNums(arr.tail)\n        }", " \
    \       arr.foldLeft(0L) { (acc,num) =>\n            if(num < 0) num * -num.toLong\
    \ - acc\n            else num.toLong * acc\n        }", "        arr.groupBy(x\
    \ => (x % 9).abs).map {\n        case (k,v) => (k,v.size)\n        }.filter(_._2\
    \ > 0).sum", "      val len = arr.size\n      val sumOfDigit = arr.foldLeft(0)(\
    \ (s, x) => s + (x/10).abs.asInstanceOf[Long])\n      val numOfNums = arr.filter(i\
    \ => i > 0).size\n      numOfNums * (len - sumOfDigit + numOfNums)", "       \
    \ arr.foldLeft(0l) { (n,x) => n + (x match {\n            case Long(0) => 1\n\
    \            case Long(x) if (x>0) => x - math.pow(10,math.log10(x)) + 1\n   \
    \         case _ => 0\n        })}", "        val zeroIndex = arr.indexWhere(_\
    \ > 0)\n        val len = arr.length\n        if (arr.isEmpty) 0\n        else\
    \ if (arr.last > 0) arr.last + countNums(arr.init)\n        else len - zeroIndex\
    \ + 1 + countNums(arr.init.reverse)", "        var num = 0\n        arr.foreach(x\
    \ => {\n            val n = Math.abs(x)\n            if(n > 0) {\n           \
    \     num += 1\n                if(n % 10 > 0) num += 1\n            }\n     \
    \   })\n        num", "        val nums = arr.map(_/10).distinct\n\n        val\
    \ result: Map[Int, Int] = Map()\n\n        nums.foreach { num =>\n           \
    \ val digits = num.abs\n            val digitSum = digits.toInt\n            if\
    \ (digitSum > 0) {\n                num.abs match {\n                    case\
    \ -l if l > 0 =>\n                        result(0) = result(0) + 1\n        \
    \            case _ =>\n                        result(1) = result(1) + 1\n  \
    \              }\n            }\n        }\n\n        if (result.size > 1) {\n\
    \            val maxKeyValue = result.maxBy(_._1)\n            val maxKey = maxKeyValue._1\n\
    \            val maxVal = maxKeyValue._2\n            val nonMaxKeys = nums.filter(_\
    \ <= maxKey).toList\n            val nonMaxVals = nonMaxKeys.map { _ =>\n    \
    \            val digitSum = (_/10).abs\n                val digits = (_/10).abs\n\
    \                val val = digits * maxVal + _\n                val firstDigit\
    \ = if (val < 0) -digitSum + digits else digits\n                firstDigit *\
    \ 10\n            }\n            val result = nonMaxVals.reduce((x, y) => x +\
    \ y)\n            result\n        }\n        else {\n            0\n        }",
  "        var sum = 0\n        var index = 0\n        var num = 0\n        while(index\
    \ < arr.length) {\n            sum += arr(index)\n            if(sum > 0) {\n\
    \                num += 1\n            }\n            index += 1\n        }\n\
    \        num", "        val res = mutable.MutableList[Long]()\n        var i =\
    \ 0\n        var sum = 0L\n        while (i < arr.size) {\n            sum = arr(i)\
    \ + sum\n            if (sum > 0) {\n                res.add(sum)\n          \
    \      sum = 0L\n            }\n            i += 1\n        }\n        \n    \
    \    if (sum > 0) {\n            res.add(sum)\n        }\n\n        res.length",
  "        var count = 0\n        arr.filter(_ > 0).foreach(num => {\n           \
    \ val s = num.toString.reverse.charAt(0)\n            if (s.toLong > 0) {\n  \
    \              count += 1\n            }\n        })\n        count", "      \
    \  var count = 0\n        var sign = arr(0) < 0\n        var signCount = 1\n \
    \       var digit = arr(0)\n        var digitCount = 0\n        for (i<-arr.indices-1)\
    \ {\n            val l = arr(i).toLong\n            digitCount += 1\n        \
    \    if (sign && !l.isMinusOne)\n                signCount += 1\n            sign\
    \ <- (l < 0)\n            l % 10 == 0 ? l += 10 else sign -= 1\n            digit\
    \ += l\n            digit %= 10\n            if (digit == 0 && count < signCount)\n\
    \                count += 1\n        }\n        count"]
stop_tokens:
- "\n    }\n"
