name: HumanEval_1_separate_paren_groups
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input to this function is a string containing multiple groups of nested\
  \ parentheses. Your goal is to\n    // separate those group into separate strings\
  \ and return the list of those.\n    // Separate groups are balanced (each open\
  \ brace is properly closed) and not nested within each other\n    // Ignore any\
  \ spaces in the input string.\n    // >>> separateParenGroups((\"( ) (( )) (( )(\
  \ ))\"))\n    // (List[String](\"()\", \"(())\", \"(()())\"))\n    def separateParenGroups(paren_string\
  \ : String) : List[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(separateParenGroups((\"\
  (()()) ((())) () ((())()())\")).equals((List[String](\"(()())\", \"((()))\", \"\
  ()\", \"((())()())\"))));\n    assert(separateParenGroups((\"() (()) ((())) (((())))\"\
  )).equals((List[String](\"()\", \"(())\", \"((()))\", \"(((())))\"))));\n    assert(separateParenGroups((\"\
  (()(())((())))\")).equals((List[String](\"(()(())((())))\"))));\n    assert(separateParenGroups((\"\
  ( ) (( )) (( )( ))\")).equals((List[String](\"()\", \"(())\", \"(()())\"))));\n\
  \    }\n\n}\n"
completions: ["        // We start by creating a stack whose size is the number of\
    \ groups in our string.\n        val paren_stack = new mutable.Stack[String]()\n\
    \n        // We start by pushing every element of our string into the stack one\
    \ at a time.\n        for (element <- paren_string.split(\"\")) {\n          \
    \  paren_stack +=+ element\n        }\n\n        // While the stack is not empty:\n\
    \        while (paren_stack.nonEmpty) {\n            // Pop an element off of\
    \ our stack\n            val popped = paren_stack.pop()\n\n            // If the\
    \ popped item equals \")\", then we know we are in a group, so we push a new group\
    \ to the stack\n            if (popped == \")\")\n                paren_stack\
    \ ++= \"(\"\n\n            // If the popped item equals \")\", then we know we\
    \ are in an open group, so we close the group and push a new group to the stack\n\
    \            if (popped == \"(\")\n                paren_stack ++= \"(\"\n\n \
    \           // If the popped item equals \")\", then we know we are in an open\
    \ group, so we close the group and push a new group to the stack\n           \
    \ if (popped == \")\")\n                paren_stack ++= \")\"\n        }\n   \
    \     // Once we leave the loop, we have our final list of groups\n        paren_stack.reverse",
  "        def balancedParens(paren_string) : List[String] = {\n            var parens\
    \ : List[String] = Nil\n            var open : List[String] = Nil\n          \
    \  var closed : List[String] = Nil\n            var temp : List[String] = Nil\n\
    \            paren_string.split(\"\\\\s\").foreach { part =>\n               \
    \ if (part == \"(\") {\n                    if (parens.isEmpty) {\n          \
    \              open ::= part\n                    } else {\n                 \
    \       open ::= part\n                        closed = parens\n             \
    \           parens = Nil\n                    }\n                } else if (part\
    \ == \")\") {\n                    if (closed == Nil) {\n                    \
    \    if (parens.nonEmpty) {\n                            parens = parens ::: Nil\n\
    \                        } else {\n                            parens = closed\n\
    \                        }\n                    } else {\n                   \
    \     closed = closed ::: part\n                    }\n                } else\
    \ if (part == \" \") {\n                    if (parens.nonEmpty) {\n         \
    \               parens = parens ::: Nil\n                    } else {\n      \
    \                  parens = closed\n                    }\n                }\n\
    \            }\n            if (parens.isEmpty) {\n                temp = open\n\
    \            } else {\n                temp = open ::: parens\n            }\n\
    \            temp\n        }\n        val groups = balancedParens(paren_string)\n\
    \        val result = groups.map(_.split(\"\").toList).filter(_.length == 1).flatMap(_.toList)\n\
    \        List(result.toList.mkString(\"\")) //.mkString(\"\")", "        val regex\
    \ = \"\"\"[(]|\\\\(|\\\\[|\\\\{|}\"|}]|\\\\)|\\\\]|\\\\}|[^\\\\(|\\\\[|\\\\{|\\\
    \\]|\"|}]+\"\"\".r\n        var output : Seq[String] = Seq.empty\n        var\
    \ open_brace : Int = paren_string.indexOf('{')\n        var closed_brace : Int\
    \ = paren_string.lastIndexOf('}')\n        var open_paren : Int = paren_string.indexOf('(')\n\
    \        var close_paren : Int = paren_string.lastIndexOf(')')\n\n        while\
    \ ( open_brace != -1 && closed_brace != -1 ) {\n            if (open_brace < closed_brace)\
    \ {\n                val sub_string = paren_string.substring(open_brace, closed_brace)\n\
    \                if (regex.findFirstIn(sub_string).isEmpty) throw new Exception(\"\
    Invalid input\")\n                output += sub_string\n                open_brace\
    \ = paren_string.indexOf('{', open_brace + 1)\n                closed_brace =\
    \ paren_string.lastIndexOf('}', closed_brace - 1)\n            } else if (open_brace\
    \ > closed_brace) {\n                val sub_string = paren_string.substring(closed_brace,\
    \ open_brace)\n                if (regex.findFirstIn(sub_string).isEmpty) throw\
    \ new Exception(\"Invalid input\")\n                output += sub_string\n   \
    \             open_brace = paren_string.indexOf('{', closed_brace + 1)\n     \
    \           closed_brace = paren_string.lastIndexOf('}', open_brace - 1)\n   \
    \         } else if (open_paren != -1 && close_paren != -1 ) {\n             \
    \   val sub_string = paren_string.substring(open_paren, close_paren)\n       \
    \         if (regex.findFirstIn(sub_string).isEmpty) throw new Exception(\"Invalid\
    \ input\")\n                output += sub_string\n                open_paren =\
    \ paren_string.indexOf('(', open_paren + 1)\n                close_paren = paren_string.lastIndexOf(')',\
    \ close_paren - 1)\n            } else {\n                val sub_string = paren_string.substring(open_paren,\
    \ close_paren)\n                if (regex.findFirstIn(sub_string).isEmpty) throw\
    \ new Exception(\"Invalid input\")\n                output += sub_string\n   \
    \             open_paren = paren_string.indexOf('(', open_paren + 1)\n       \
    \         close_paren = paren_string.lastIndexOf(')', open_paren - 1)\n      \
    \      }\n        }\n        return output.filterNot( _.isEmpty)", "        val\
    \ paren_groups = paren_string.split(\"(\").filter(x => x.endsWith(\")\")).distinct\n\
    \        val open_brace_groups = paren_groups.filter(_.replace(\"(\", \"\").replace(\"\
    )\", \"\").length > 0).distinct\n\n        open_brace_groups.filter(x => paren_groups.count(_.replace(x\
    \ + \"(\", \"\").replace(x, \"\").replace(_ + \")\", \"\").replace(_ + \")\",\
    \ \"\").length > 0).distinct", "        var list_to_return = Nil\n        var\
    \ current_string = \"\"\n        for(c <- paren_string) {\n            if(c ==\
    \ '(') {\n                current_string += c\n                list_to_return\
    \ = list_to_return :+ current_string\n                current_string = \"\"\n\
    \            } else if(c == ')') {\n                list_to_return = list_to_return\
    \ :+ current_string\n                current_string = \"\"\n            } else\
    \ {\n                current_string += c\n            }\n        }\n        if(current_string\
    \ != \"\") {\n            list_to_return = list_to_return :+ current_string\n\
    \        }\n        list_to_return.toList", "        def balanced : Boolean =\
    \ { for( i <- 0 to paren_string.length - 1 ) if(paren_string(i) != paren_string(i+1))\
    \ break; paren_string.length > 1 }\n        def open_braces : { (i: Int, j: Int)\
    \ => Boolean } = { (i, j) => ( paren_string(i) == paren_string(j) ) && (paren_string(i)\
    \ != \" \") }\n        def close_braces : { (i: Int, j: Int) => Boolean } = {\
    \ (i, j) => ( paren_string(i) == paren_string(j) ) && (paren_string(i) == \" \"\
    ) }\n        val paren_count = paren_string.length\n        if (paren_count ==\
    \ 0) return Nil\n        val groups = mutable.ListBuffer.empty[String]\n     \
    \   val open_brace = mutable.ListBuffer.empty[Int]\n        val close_brace =\
    \ mutable.ListBuffer.empty[Int]\n        for( i <- 0 to paren_count - 1 ) {\n\
    \            if(open_braces(i, i)) open_brace += i\n            if(close_braces(i,\
    \ i)) close_brace += i\n        }\n        if(open_brace.isEmpty) Nil\n      \
    \  else {\n            for(i <- 0 to open_brace.length - 1 ) {\n             \
    \   if(!close_braces(open_brace(i), open_brace(i+1))) {\n                    groups\
    \ += paren_string.substring(open_brace(i), open_brace(i+1))\n                \
    \    open_brace += i\n                    if(close_brace.isEmpty) break\n    \
    \            }\n            }\n        }\n        return groups.toList", "   \
    \     def separateParenGroupsRecurse(s: String) : List[String] = {\n         \
    \   if (s.length() <= 0) Nil\n            else {\n                val open_brace\
    \ = s.charAt(0)\n                if (open_brace == ')') {\n                  \
    \  val open_paren = s.charAt(1)\n                    if (open_paren == ')') {\n\
    \                        val open_paren_2 = s.charAt(2)\n                    \
    \    if (open_paren_2 == ')') {\n                            val open_paren_3\
    \ = s.charAt(3)\n                            if (open_paren_3 == ')')\n      \
    \                          Nil\n                            else\n           \
    \                     List(open_paren + open_paren_2 + open_paren_3)\n       \
    \                 } else {\n                            val open_paren_4 = s.charAt(3)\n\
    \                            if (open_paren_4 == ')')\n                      \
    \          List(open_paren + open_paren_2)\n                            else\n\
    \                                List(open_paren + open_paren_2 + open_paren_3\
    \ + open_paren_4)\n                        }\n                    } else {\n \
    \                       val open_paren_5 = s.charAt(2)\n                     \
    \   if (open_paren_5 == ')')\n                            List(open_paren + open_paren)\n\
    \                        else\n                            List(open_paren + open_paren_2\
    \ + open_paren_5)\n                    }\n                } else {\n         \
    \           val open_paren_6 = s.charAt(1)\n                    if (open_paren_6\
    \ == ')')\n                        List(open_paren + open_brace)\n           \
    \         else\n                        List(open_paren + open_brace + open_paren_6)\n\
    \                }\n            }\n        }\n\n        val parens = paren_string.splitToList\n\
    \        var list = parens.map(l => separateParenGroupsRecurse(l))\n        list\
    \ = list.flatten.distinct\n        list", "        val paren_groups = paren_string.split(\"\
    \\\\(\").filter(_.matches(\"^\\\\)\")).map(x => x.replaceAll(\"^\\\\)$\", \"\"\
    )).filter(x => !x.equals(\"()\"))\n        if (paren_groups.isEmpty) return List()\n\
    \        val depth = paren_groups.map(x => x.length).toList.max\n        val result\
    \ = new mutable.HashMap[String, mutable.ListBuffer[String]]()\n        for ((idx,\
    \ paren_group) <- paren_groups zip paren_groups.dropRight) {\n            var\
    \ current = mutable.ListBuffer[String]()\n            var opened_braces = 0 //\
    \ Number of open braces in group so far\n            for (character <- paren_group)\
    \ {\n                val closed = paren_group(opened_braces)\n               \
    \ val opened = paren_group(opened_braces + 1)\n                if (opened == \"\
    \") current += character // Open braces count as part of the brace\n         \
    \       else if (character == \"(\") opened_braces += 1\n                else\
    \ if (character == \")\") opened_braces -= 1\n                else if (character\
    \ == \" \") opened_braces = 0\n                else if (character == \")\" &&\
    \ opened_braces == 0) {\n                    val result = current.dropWhile(x\
    \ => !x.equals(\"(\")).toList\n                    if (!result.isEmpty) {\n  \
    \                      if (result.head == \"()\") result += \"()\"\n         \
    \               result.removeAt(0)\n                        result += \"(\" +\
    \ result.mkString(\",\") + \")\"\n                        result.add(\"()\")\n\
    \                    }\n                    current.clear()\n                \
    \    current.addAll(result)\n                }\n                else {\n     \
    \               current.addAll(character :: current)\n                }\n    \
    \        }\n            result += (paren_group(0) -> (mutable.ListBuffer[String]().addAll(current.toList)).toList)\n\
    \        }\n        result.values.map(_.flatMap(_.mkString(\",\")).distinct).toList",
  "        // TODO: Implement this function\n        throw new UnsupportedOperationException(\"\
    Not yet implemented\");", "        paren_string.trim.split('(').filter(_ != ')').filter(_\
    \ != '(').toList", "        // Create a stack\n        val opening_parens = Stack[String]()\n\
    \        // Initialize output array\n        var output_array = List[String]()\n\
    \        // Iterate through each char in the paren_string\n        for(chr <-\
    \ paren_string)\n            // if the current char is a (\n            if(chr\
    \ == '(') opening_parens.push(chr)\n            // if the current char is a )\n\
    \            if(chr == ')'){\n                // Get the opening brace char\n\
    \                val opening_paren = opening_parens.pop()\n                //\
    \ If the opening brace is still an opening brace and the current closing brace\
    \ is a closing brace\n                // then add the opening brace to the output\
    \ array followed by the closing brace\n                if(opening_paren == '('\
    \ && chr == ')') output_array :+ opening_paren :+ chr\n                // If the\
    \ opening brace is still a closing brace and the current closing brace is a closing\
    \ brace\n                // then remove the opening brace from the output array\
    \ followed by the closing brace\n                if(opening_paren == '(' && chr\
    \ == ')') output_array :- opening_paren :+ chr\n            }\n        // Convert\
    \ the array to a list\n        output_array.toList", "        paren_string.split(\"\
    \\\\(\").map(x => {\n            val paren_count = paren_string.split(x).length\
    \ - 1\n            paren_string.split(x)(paren_count.toInt)\n        }).filter(_\
    \ => !_.getOrElse(\"\").equals(\"\")).map(x => x.get(0))", "        paren_string.split(\"\
    \"\"\\s+\"\"\")\n            .map(_.split(\"\\\\(\")\n                .map(_.trim())\n\
    \                .toList\n                .filter(_.nonEmpty)\n              \
    \  .map(p => p.replace(\" \", \"\"))\n                .toList)\n            .flatMap(_.groupBy(_.nonEmpty))\n\
    \            .toList", "        var list_of_strings: List[String] = List()\n \
    \       var open_braces : Int = 0\n\n        for (c <- paren_string) {\n     \
    \       if (c == '(') {\n                open_braces += 1\n            } else\
    \ if (c == '{') {\n                open_braces += 2\n            } else if (c\
    \ == '}') {\n                open_braces -= 1\n            }\n            if (open_braces\
    \ == 0) {\n                list_of_strings += c\n            }\n        }\n  \
    \      list_of_strings", '        paren_string.split("""\W+""")', "        val\
    \ list = paren_string.split(' ');\n        val balanced = new mutable.ArrayBuffer(list.size)\n\
    \        list.foreach(l => {\n            val tokens = l.split('(');\n       \
    \     if (tokens.size == 0) return;\n            var open_count : Int = 0\n  \
    \          tokens.foreach(t => {\n                if (open_count > 0) {\n    \
    \                balanced(open_count) += t\n                    open_count +=\
    \ 1;\n                }\n                else {\n                    balanced.prepend(t)\n\
    \                }\n            })\n        })\n        val groups = new mutable.ArrayBuffer(list.size)\n\
    \        balanced.foreach((open, close) => {\n            if (open != close) {\n\
    \                groups.prepend(list)\n                list = null\n         \
    \   }\n        })\n        groups.map(_.reverse.toList).toList", "        var\
    \ result = Nil\n        var open_paren = 0\n        var closed_paren = 0\n   \
    \     var open_brace = 0\n        var closed_brace = 0\n        var brace_count\
    \ = 0\n\n        // for each char in the string, add it to result if the char\
    \ is a valid open paren or brace or close paren\n        paren_string.foreach\
    \ {\n            case ' ' => ()\n            case c: Character if open_brace ==\
    \ 0 && closed_brace == 0 && open_brace < closed_paren && c != ')' && c != '('\
    \ =>\n                if (c == ')') {\n                    result ::= paren_string.drop(open_brace)\n\
    \                    open_brace = closed_paren\n                    closed_paren\
    \ = 0\n                }\n                result ::= c\n            case c: Character\
    \ if open_brace > 0 && closed_brace == 0 && open_brace < closed_paren && c !=\
    \ ')' && c != '(' =>\n                if (c == '(') {\n                    result\
    \ ::= paren_string.drop(open_brace)\n                    open_brace = 0\n    \
    \                closed_paren = closed_brace\n                    closed_brace\
    \ = 0\n                }\n                result ::= c\n            case c: Character\
    \ if open_brace > 0 && closed_brace > 0 && open_brace < closed_paren && c != ')'\
    \ && c != '(' =>\n                if (c == ')' && closed_brace > open_brace) {\n\
    \                    result ::= paren_string.drop(open_brace)\n              \
    \      open_brace = closed_paren\n                    closed_paren = 0\n     \
    \               closed_brace -= 1\n                }\n                result ::=\
    \ c\n            case c: Character if open_brace == 0 && closed_brace > 0 && open_brace\
    \ < closed_paren && c != ')' && c != '(' =>\n                if (c == ')' && closed_brace\
    \ > open_brace) {\n                    result ::= paren_string.drop(open_brace)\n\
    \                    open_brace = 0\n                    closed_paren = closed_brace\n\
    \                    closed_brace = 0\n                    closed_brace -= 1\n\
    \                }\n                result ::= c\n            case c: Character\
    \ if open_brace == 0 && closed_brace == 0 && open_brace < closed_paren && c !=\
    \ ')' && c != '(' =>\n                if (c == '(') {\n                    result\
    \ ::= paren_string.drop(open_brace)\n                    open_brace = 0\n    \
    \                closed_paren = closed_brace\n                    closed_brace\
    \ = 0\n                }\n                result ::= c\n            case c: Character\
    \ if open_bra", "        def separateParenGroups(input : String,\n           \
    \                    paren_count : Int,\n                               current_depth\
    \ : Int,\n                               current_string : List[String],\n    \
    \                           parens : List[Int]): List[String] = {\n          \
    \  if (paren_count == 0) current_string ::: parens\n            else { \n    \
    \            val open_brace =\n                    if (paren_count > current_depth)\
    \ {\n                        paren_count - current_depth\n                   \
    \ } else {\n                        0\n                    }\n               \
    \ val close_brace = open_brace - current_depth\n                if (paren_count\
    \ == current_depth) {\n                    val open = paren_count + current_depth\n\
    \                    val close = open_brace\n                    current_string\
    \ ::: parens.take(close) ::: parens.drop(open)\n                } else {\n   \
    \                 val open = paren_count + current_depth\n                   \
    \ val close = open_brace\n                    if (parens[(open + close)] == (paren_count\
    \ + current_depth)) {\n                        val open_ = open + 1\n        \
    \                val close_ = close\n                        separateParenGroups(input,\
    \ open_, close + 1, current_string ::: parens.take(close) ::: parens.drop(open_),\
    \ parens.drop(open_))\n                    } else {\n                        separateParenGroups(input,\
    \ open, close + 1, current_string ::: parens.take(close) ::: parens.take(open_),\
    \ parens.drop(open_))\n                    }\n                }\n            }\n\
    \        }\n        val result = new mutable.ArrayBuffer[String]\n        val\
    \ paren_groups = paren_string.flatMap(x => x.toList)\n        val open_brace_count\
    \ = paren_groups.flatMap(x => x.countBy(x => x == ('('))).sum\n        val close_brace_count\
    \ = paren_groups.flatMap(x => x.countBy(x => x == (')'))).sum\n        for (i\
    \ <- 0 until open_brace_count) {\n            result.add(\"(\" + paren_groups.take(i).mkString(\"\
    (\", \", \", \")\"))\n        }\n        for (j <- 0 until close_brace_count)\
    \ {\n            result.add(\")\" + paren_groups.drop(j).mkString(\"(\", \", \"\
    , \")\"))\n        }\n        result.toList", "        paren_string.grouped(5).map(parens\
    \ => parens.foldLeft(List.empty[String]){\n            (x, y) => y match {\n \
    \               case (\")\") => x :+ y\n                case (\"(\") => x :+ y\n\
    \                case _ => x :+ y\n            }\n        }.toList).distinct",
  "        val inputStringList = paren_string.trim().split(\"\\\\s+\").map(_.trim())\n\
    \n        // Create a stack to store the string currently being processed. Since\
    \ the stack acts as a LIFO queue, we store strings popped from the top of the\
    \ stack onto the head of the stack.\n        var parenStringStack: List[String]\
    \ = Nil\n        var index = 0\n\n        // Iterate over the string and push\
    \ all the parenthesis strings to the stack\n        for (nextString <- inputStringList)\
    \ {\n            if (nextString.startsWith(\"(\")) {\n                parenStringStack\
    \ += nextString\n            } else {\n                if (nextString.startsWith(\"\
    )\")) {\n                    val parenthesisString = parenStringStack.takeWhile(_.startsWith(\"\
    (\"))\n                    parenStringStack = parenStringStack.drop(parenthesisString.length)\n\
    \                    parenStringStack += nextString\n                }\n     \
    \       }\n        }\n\n        // Return the stack contents\n        parenStringStack.mkString(\"\
    (\", \",\", \")\")", "        val paren_groups = paren_string.split(\"(?<=\\\\\
    )))(?=\\\\()\").filterNot(_.isEmpty)\n        val paren_groups_with_outside_parens\
    \ = paren_groups\n            .map(x => paren_groups.filterNot(y => x == y))\n\
    \            .filter(_ => _.nonEmpty)\n        paren_groups_with_outside_parens.map(x\
    \ => paren_groups_with_outside_parens.filterNot(y => x == y))", "        def helper(paren_strings:\
    \ List[String], group: List[String], paren_count: Int) : List[String] = {\n  \
    \          // If all parens are closed, we have a string where all parens are\
    \ grouped together and return it\n            if (paren_count == 0) {\n      \
    \          group\n            }\n            // If one open paren is closed, we\
    \ have an extra open paren and return that\n            else if (paren_count ==\
    \ 1) {\n                group += \"(\"\n            }\n            // If there\
    \ are multiple open parens, we must keep adding them until they are balanced\n\
    \            else if (paren_count > 1) {\n                group += \"(\"\n   \
    \             group += paren_strings.takeWhile(_.length != paren_count)\n    \
    \            group += \")\"\n                val newGroup = paren_strings.dropWhile(_.length\
    \ != paren_count)\n                newGroup match {\n                    case\
    \ List() => helper(paren_strings, group, paren_count)\n                    case\
    \ _ => helper(newGroup, group, paren_count - 1)\n                }\n         \
    \   }\n        }\n        helper(paren_string.split(\"\\\\W+\"), List.empty, paren_string.split(\"\
    \\\\W+\").length)", "        def unbalancedParensChecker(string: String) : Boolean\
    \ = {\n            val openParen = string.indexWhere(c => c == \"(\")\n      \
    \      val closeParen = string.indexWhere(c => c == \")\")\n            if (openParen\
    \ < 0) return false\n            if (closeParen == string.length) return false\n\
    \            if (closeParen > openParen) unbalancedParensChecker(string.substring(openParen\
    \ + 1, closeParen))\n            else unbalancedParensChecker(string.substring(openParen\
    \ + 1, closeParen - 1))\n        }\n        val stringList = ListBuffer[String]()\n\
    \        stringList.append (\"(\")\n        stringList.append (paren_string)\n\
    \        stringList.append (\")\")\n        var outputString = stringList.mkString\n\
    \        while (true) {\n            if (unbalancedParensChecker(outputString))\
    \ throw new Exception(\"Unbalanced parens found: \" + outputString)\n        \
    \    val open = outputString.indexWhere(c => c == \"(\")\n            val close\
    \ = outputString.indexWhere(c => c == \")\")\n            if (open < 0 || close\
    \ < 0) return outputString.drop(1).dropRight(1)\n            outputString = outputString.substring(open\
    \ + 1, close + 1)\n            stringList.append (outputString)\n        }", " \
    \       val stack = new Stack[String]()\n        val result = new mutable.ListBuffer[String]()\n\
    \        val open_braces = paren_string.filter(x => x == '{')\n        val close_braces\
    \ = paren_string.filter(x => x == '}')\n        val open_parentheses = paren_string.filter(x\
    \ => x == '(')\n        val close_parentheses = paren_string.filter(x => x ==\
    \ ')')\n\n        open_braces.foreach(x => {\n            stack.push(x)\n    \
    \    })\n\n        close_braces.foreach(x => {\n            if (stack.isEmpty)\
    \ {\n                result += x\n            } else {\n                stack.pop\n\
    \            }\n        })\n\n        open_parentheses.foreach(x => {\n      \
    \      stack.push(x)\n        })\n\n        close_parentheses.foreach(x => {\n\
    \            if (stack.isEmpty) {\n                result += x\n            }\
    \ else {\n                stack.pop\n            }\n        })\n\n        result.toList",
  "        val paren_count = paren_string.groupCount\n        var paren_stack = new\
    \ mutable.Stack[String]()\n        var paren_open = paren_stack.empty\n      \
    \  for (i <- 0 until paren_count) {\n            val char = paren_string(i)\n\
    \            if (char == '(') {\n                paren_open += true\n        \
    \        paren_stack.push(char)\n            } else if (char == ')') {\n     \
    \           paren_open += false\n                if (paren_open) {\n         \
    \           val last_char = paren_stack.last\n                    val last_count\
    \ = paren_stack.last.length\n                    val count = paren_stack.size\n\
    \                    if (last_count > count) {\n                        paren_stack.pop()\n\
    \                    } else if (last_count == count && last_char != '(') {\n \
    \                       paren_stack.pop()\n                    } else {\n    \
    \                    paren_stack.pop()\n                    }\n              \
    \  }\n            } else {\n                paren_stack.pop()\n            }\n\
    \        }\n        paren_stack.toList", "        paren_string.split(\"\\\\(\"\
    )\n            .map { inner =>\n                // If no inner parens are found,\
    \ return the outer paren group\n                if (inner.isEmpty) {\n       \
    \             paren_string\n                } else {\n                    // Otherwise,\
    \ get the next open paren, add it to the outer paren group\n                 \
    \   val next_open = inner.indexOf(\"\\\\(\")\n                    if (next_open\
    \ == -1) {\n                        inner.trim match {\n                     \
    \       case \"\\\\)\" => inner.substring(0, next_open)\n                    \
    \        case _ => inner\n                        }\n                    } else\
    \ {\n                        inner.substring(0, next_open)\n                 \
    \   }\n                }\n            }\n            .filterNot { inner =>\n \
    \               // Ignore the inner parens within each other and any spaces outside\
    \ of them\n                !inner.contains(\"\\\\(|\\\\)\")\n                \
    \    && !inner.isEmpty\n                    && !inner.contains(\" \")\n      \
    \      }\n            .toList", "        // Iterate over all the parens\n    \
    \    var parens: List[String] = Nil\n        var paren_depth = 0\n        for\
    \ (c <- paren_string) {\n            // If the character is a paren increase the\
    \ depth\n            if (c == '(') {\n                paren_depth += 1\n     \
    \       } else if (c == ')') {\n                // If depth is zero then add paren\
    \ to list\n                if (paren_depth == 0) {\n                    parens\
    \ = parens :+ c\n                } else {\n                    // If depth not\
    \ zero then decrease depth\n                    paren_depth -= 1\n           \
    \     }\n            }\n        }\n        // If depth is zero then add paren\
    \ to list\n        if (paren_depth == 0) {\n            parens = parens :+ paren_string\n\
    \        } else {\n            // If depth not zero then decrease depth\n    \
    \        paren_depth -= 1\n        }\n        // Return the list of parens\n \
    \       return parens", "        val groups = mutable.Set[String]()\n        val\
    \ parens = mutable.Set[String]()\n        var open_brace_count = 0\n        val\
    \ len = paren_string.length\n        val i = 1\n        while (i + 2 < len) {\n\
    \            if (paren_string(i) == '(') {\n                if (paren_string(i\
    \ + 1) == '(') {\n                    open_brace_count += 1\n                }\
    \ else if (paren_string(i + 1) == ')') {\n                    if (open_brace_count\
    \ == 1) {\n                        open_brace_count = 0\n                    \
    \    parens += paren_string(i)\n                    } else {\n               \
    \         open_brace_count -= 1\n                    }\n                } else\
    \ {\n                    open_brace_count = 0\n                    parens += paren_string(i)\n\
    \                }\n            }\n            i += 2\n        }\n\n        val\
    \ closed_paren_count = parens.size - open_brace_count\n        if (closed_paren_count\
    \ > 0) {\n            val new_paren_string = parens.toSeq.toList.mkString\n  \
    \          groups += new_paren_string\n            separateParenGroups(new_paren_string)\n\
    \        }\n        if (closed_paren_count == 0) {\n            groups.toList\n\
    \        }", "        var list_groups : List[String] = Nil\n        var last_paren_char\
    \ : Char = ' ' // initialize last paren character to be a space\n        var paren_count\
    \ : Int = 1 // initialize paren count\n        var paren_string : List[String]\
    \ = Nil\n        for(i <- 0 until paren_string.length) {\n            paren_count\
    \ match {\n                case 0 => last_paren_char match {\n               \
    \     case ' ' =>\n                        list_groups = paren_string.filterNot(_.isEmpty)\n\
    \                        paren_count match {\n                            case\
    \ 0 => Nil\n                            case _ => Nil\n                      \
    \  }\n                        paren_string = Nil\n                    case ')'\
    \ =>\n                        list_groups = paren_string.filterNot(_.isEmpty)\n\
    \                        paren_count match {\n                            case\
    \ 0 => Nil\n                            case _ => Nil\n                      \
    \  }\n                        paren_string = Nil\n                }\n        \
    \        case 1 => paren_string.filterNot(_.isEmpty)\n                case _ =>\
    \ paren_string.filterNot(_.isEmpty)\n            }\n        }\n        return\
    \ list_groups", "        val paren_groups : Set[String] = paren_string.split(\"\
    \\\\(\").map(_.trim).filter(_.nonEmpty)\n        val open_paren = paren_groups.filter(_\
    \ == \"(\" || _ == \"[\")\n        val close_paren = paren_groups.filter(_ ==\
    \ \")\" || _ == \"]\")\n        val open_paran = open_paren.foldLeft(mutable.Set[String]())\
    \ { (acc, cur) =>\n            if (acc contains cur) {\n                acc\n\
    \            } else {\n                acc ++ cur\n            }\n        }\n\
    \        val close_paran = close_paren.foldLeft(mutable.Set[String]()) { (acc,\
    \ cur) =>\n            if (acc contains cur) {\n                acc\n        \
    \    } else {\n                acc ++ cur\n            }\n        }\n        val\
    \ all_paran = open_paran.union(close_paran)\n        all_paran.filter(!_.startsWith(\"\
    (\") && !_.startsWith(\"[\")) // Remove nested parenthesis", "        // Find\
    \ all the matches of \"(\" and \")\" \n        val open_paren = paren_string.r.findAllIn(\"\
    ()\").toList\n        val close_paren = paren_string.r.findAllIn(\")\").toList\n\
    \n        // For each open paren, find its index in the string\n        val open_p_index\
    \  = open_paren.zipWithIndex.collect { case (open_paren, i) => i }\n\n       \
    \ // For each close paren, find its index in the string\n        val close_p_index\
    \ = close_paren.zipWithIndex.collect { case (close_paren, i) => i }\n\n      \
    \  // For each pair of indexes, see if they are adjacent and add them to the list\
    \ if they are adjacent\n        (open_paren.zip(open_paren.tail) ::\n        \
    \    close_p_index.zip(close_p_index.tail) ::\n            close_p_index.zip(close_p_index.tail)\
    \ ::\n            close_p_index.zip(close_p_index.tail) ::\n            open_paren.zip(open_paren.tail))\n\
    \            .filterNot(_._1 == _._2)\n            .flatMap(x => List(x, x._1\
    \ - 1))\n            .drop(x._1)", "        val paren_list: List[String] = new\
    \ ListBuffer[String]()\n        val open_braces_count: Int = 0\n        val nested_parentheses_count:\
    \ Int = 0\n\n        // iterate through each character in the input string one\
    \ at a time\n        for (i <- 1 to paren_string.length) {\n            val c\
    \ = paren_string(i)\n\n            // a character is a new group of parentheses\
    \ encountered\n            if (c == '(') {\n                paren_list += c\n\
    \                open_braces_count += 1\n                nested_parentheses_count\
    \ += 1\n            }\n            // a closing parenthesis is encountered\n \
    \           else if (c == '(') {\n                if (nested_parentheses_count\
    \ == open_braces_count) {\n                    paren_list += c\n             \
    \       open_braces_count -= 1\n                }\n                nested_parentheses_count\
    \ += 1\n            }\n            // an opening parenthesis is encountered\n\
    \            else if (c == ')') {\n                if (nested_parentheses_count\
    \ < open_braces_count) {\n                    paren_list += c\n              \
    \      open_braces_count -= 1\n                }\n                nested_parentheses_count\
    \ += 1\n            }\n            // any other character is ignored and placed\
    \ into the paren_list variable\n            else {\n                paren_list\
    \ += c\n            }\n        }\n        // return the paren_list\n        paren_list.toList",
  "        def isClosingParenGroup(brace_level : Int) : Boolean = brace_level > 0\
    \ && paren_string match {\n            case \"\" => true\n            case _ if\
    \ paren_string contains (\")\")\n                || paren_string contains (\"\
    )\")\n                || paren_string contains (\")\")\n                || paren_string\
    \ contains (\")\")\n                || paren_string contains (\")\")\n       \
    \         || paren_string contains (\")\")\n                || paren_string contains\
    \ (\")\")\n                || paren_string contains (\")\")\n                ||\
    \ paren_string contains (\")\")\n                || paren_string contains (\"\
    )\")\n                || paren_string contains (\")\")\n                || paren_string\
    \ contains (\")\")\n                || paren_string contains (\")\")\n       \
    \         || paren_string contains (\")\")\n                || paren_string contains\
    \ (\")\")\n                || paren_string contains (\")\")\n                ||\
    \ paren_string contains (\")\")\n                || paren_string contains (\"\
    )\")\n                || paren_string contains (\")\")\n                || paren_string\
    \ contains (\")\")\n                || paren_string contains (\")\")\n       \
    \         || paren_string contains (\")\")\n                || paren_string contains\
    \ (\")\")\n                || paren_string contains (\")\")\n                ||\
    \ paren_string contains (\")\")\n                || paren_string contains (\"\
    )\")\n                || paren_string contains (\")\")\n                || paren_string\
    \ contains (\")\")\n                || paren_string contains (\")\")\n       \
    \         || paren_string contains (\")\")\n                || paren_string contains\
    \ (\")\")\n                || paren_string contains (\")\")\n                ||\
    \ paren_string contains (\")\")\n                || paren_string contains (\"\
    )\")\n                || paren_string contains (\")\")\n                || paren_string\
    \ contains (\")\")\n                || paren_string contains (\")\")\n       \
    \         || paren_string contains (\")\")\n                || paren_string contains\
    \ (\")\")\n                || paren_string contains (\")\")\n                ||\
    \ paren_string contains (\")\")\n                || paren_string contains (\"\
    )\")\n                || paren_string contains (\")\")\n                || paren_string\
    \ contains (\")\")\n                || paren_string contains (\")\")\n       \
    \         || paren_string contains (\")\")\n                || paren_string contains\
    \ (\")\")\n                || paren_string contains (\")\")\n                ||\
    \ paren_string contains (\")\")\n                || paren_string contains (\"\
    )\")\n                || paren_string contains (\")\")\n                || paren_string\
    \ contains (\")\")\n                || paren_string contains (\")\")\n       \
    \         || paren", "        val result = new ListBuffer[String]()\n        var\
    \ open_braces = 0 // track open braces\n        var group = \"\"  // keep track\
    \ of brace group\n\n        // Iterate through each character in string and keep\
    \ track of the character type\n        // and number of open braces\n        for\
    \ (i <- paren_string.indices) {\n            val c = paren_string(i)\n       \
    \     if (c == ')') {\n                result.append((group + c.toString))\n \
    \               open_braces -= 1\n            }\n            else if (c == '(')\
    \ {\n                result.append((group + c.toString))\n                open_braces\
    \ += 1\n            }\n            else if (c == ' ') {\n                result.append((group\
    \ + c.toString))\n            }\n            else {\n                // If this\
    \ is a open brace or space, then accumulate the current group\n              \
    \  // and reset group string to the empty string\n                if ((open_braces\
    \ % 2) == 0) {\n                    group ++= c.toString\n                }\n\
    \                else {\n                    group = c.toString\n            \
    \    }\n            }\n        }\n\n        return result.toList", '      paren_string.split("(?<!\\)\\s+(?=(?<=\\()|\\))").filter(_.nonEmpty).toList',
  "        if (paren_string.isEmpty) return Nil\n\n        var stack = ListBuffer[String]()\n\
    \        var paren_groups = mutable.Buffer[String]()\n\n        for (c <- paren_string.chars())\
    \ {\n            if (c == '(')\n                paren_groups += c\n\n        \
    \    if (c == '{')\n                stack push c\n\n            if (c == '{')\n\
    \                paren_groups += c\n\n            if (c == '}')\n            \
    \    if (stack.last == '(')\n                    paren_groups += c\n         \
    \       else\n                    stack.pop\n        }\n\n        if (paren_groups.length\
    \ != stack.length) return Nil\n\n        stack.toList.reverse", "        val strArray\
    \ = paren_string.split(\"\"\"\\W+\"\"\")\n        var result : List[String] =\
    \ Nil\n        strArray.filter(_.startsWith(\"(\")).toList.foreach(l => result\
    \ = result :+ l.substring(1).toLowerCase)\n        strArray.filter(_.startsWith(\"\
    )\")).toList.foreach(l => result = result :+ l.substring(1).toLowerCase)\n   \
    \     result", "        // This list will be the result strings. \n        var\
    \ result: List[String] = Nil\n\n        // To check whether we are done with the\
    \ current paren_string \n        var done = false\n\n        // To keep track\
    \ of whether we have encountered an opening or closing brace in the current paren_string\n\
    \        var current_open_brace = 0\n\n        // To keep track of whether we\
    \ have encountered a closing or opening brace in the current paren_string\n  \
    \      var current_close_brace = 0\n\n        // To keep track of whether we have\
    \ encountered a closing or opening brace in the current paren_string\n       \
    \ var current_close_brace = 0\n\n        // To keep track of whether we have encountered\
    \ a closing or opening brace in the current paren_string\n        var current_close_brace\
    \ = 0\n\n        // For traversing over the paren_string and making sure that\
    \ we are not having any open braces\n        var open_braces = 0\n\n        //\
    \ For traversing over the paren_string and making sure that we are not having\
    \ any closing braces\n        var close_braces = 0\n\n        // For traversing\
    \ the paren_string and making sure that we are not having any nested braces\n\
    \        var nested_braces = 0\n\n        // For traversing the paren_string and\
    \ making sure that we are not having any nested braces\n        var nested_braces\
    \ = 0\n\n        // For traversing the paren_string and making sure that we are\
    \ not having any nested braces\n        var nested_braces = 0\n\n        // Keep\
    \ a count of how many times the given char appears in the paren_string and\n \
    \       // the count of how many times the given char appears in the paren_string.\n\
    \        val paren_count = paren_string.length\n        var count_in_paren_string\
    \ = paren_string.count(_ == '(')\n        var count_in_paren_string2 = paren_string.count(_\
    \ == ')')\n\n        // Iterate over all the characters in the paren_string and\
    \ make sure\n        // that we are not having any nested braces \n        while\
    \ (paren_count > 0) {\n            // If the current character is a opening brace,\
    \ we need to increment its counter\n            if (paren_count == count_in_paren_string)\
    \ {\n                open_braces += 1\n                count_in_paren_string =\
    \ paren_string.count(_ == '(')\n                count_in_paren_string2 = paren_string.count(_\
    \ == ')')\n                // Now update the counter so that when we come across\
    \ another opening brace\n                // we know we are done with current paren_string\n\
    \                paren_count -= 1\n                // Now if we have encountered\
    \ an opening brace, we need to decrement its counter\n                done = open_braces\
    \ == 0\n            } else if (paren_count == count_in_paren_string2) {\n    \
    \            close_braces += 1\n                count_in_paren_string = paren_string.count(_\
    \ == '(')\n                count_in_paren_string2 = paren_string.", "        var\
    \ groups: List[String] = Nil\n        var strings: List[String] = Nil\n      \
    \  var string: String = paren_string.trim\n\n        var paren_count: Int = 0\n\
    \        var open_paren_count: Int = 0\n        while (string != \"\") {\n   \
    \         if (string == \"(\") {\n                open_paren_count += 1\n    \
    \        } else if (string == \")\") {\n                paren_count += 1\n   \
    \         }\n            string += string\n        }\n\n        if (open_paren_count\
    \ == paren_count) {\n            if (string == \"\") {\n                strings\
    \ += \"()\"\n            } else {\n                strings += string\n       \
    \     }\n        }\n        \n        var next_group: List[String] = Nil\n   \
    \     var next_group_count = 1\n        while (open_paren_count != 0) {\n    \
    \        next_group += \"()\"\n            next_group_count += 1\n           \
    \ open_paren_count -= 1\n        }\n        \n        while (next_group_count\
    \ != 0) {\n            groups += next_group\n            next_group = \"\"\n \
    \           next_group_count = 1\n            while (open_paren_count != 0) {\n\
    \                next_group += \"()\"\n                next_group_count += 1\n\
    \                open_paren_count -= 1\n            }\n        }\n        \n \
    \       groups = groups.reverse\n        return strings", "        val paren_groups\
    \ = paren_string.split(\"\\\\((?!\\\\()\")\n        var paren_groups_list: List[String]\
    \ = Nil\n        for(i <- 0 until paren_groups.length){\n            if(paren_groups[i].endsWith(\"\
    \\\\)\")) paren_groups_list = paren_groups.subList(0,i)\n            else paren_groups_list\
    \ = paren_groups.subList(i+1, paren_groups.length)\n        }\n        return\
    \ paren_groups_list.toList", "        val paren_groups = paren_string.split(\"\
    \ \").filterNot(_ == \")\").map(s => {\n            // Add space for each group\
    \ of nested parentheses.\n            val paren_groups_without_parens = s.split(\"\
    \ \").filterNot(_ == \"(\")\n            val parens_within_group = paren_groups_without_parens.filter(s\
    \ => s.contains(\"(\"))\n            parens_within_group.length match {\n    \
    \            // If the group contains at least one paren, add the parentheses\
    \ back to the string\n                case 0 => s\n                // If the group\
    \ doesn't contain parentheses, add it to the list.\n                case 1 =>\n\
    \                    parens_within_group.head\n            }\n        }).filterNot(_.contains(\"\
    (\"))\n        paren_groups.filter(s => s.contains(\"(\"))", "        def separateParenGroup(paren_string\
    \ : String) : List[String] = {\n            paren_string.flatMap(c =>\n      \
    \          {\n                    val cur = c.toChar\n                    if(cur\
    \ == '(')\n                        List(cur)\n                    else if(cur\
    \ == ')')\n                        if(paren_string.head == '(')\n            \
    \                List(cur)\n                        else\n                   \
    \         List()\n                    else\n                        List()\n \
    \               }).filter(_ != '(' && _ != ')').filter(c => c != ' ')\n      \
    \  }\n\n        val paren_groups = paren_string.split('(').map( c => c.split(')').filter(_\
    \ != ' '))\n        val result_list = paren_groups.map( c => c.head).flatMap(c\
    \ => c.reverse.map( c => c+c).flatMap(c => c.reverse).map(c => c+c))\n       \
    \ result_list.distinct", "        def parseParenString(paren_string : String)\
    \ : String = {\n            val strings: List[String] = paren_string\n       \
    \         .split(\",\")\n                .flatMap(x => x.split(\"(,())\").toList)\n\
    \                .map(x => x.replace(\")\", \" \"))\n                .toList\n\
    \            return strings\n        }\n        val strings: List[String] = parseParenString(paren_string)\n\
    \        var open_braces : List[Int] = Nil\n        var closed_parens : List[Int]\
    \ = Nil\n        var output : List[String] = Nil\n        var paren_count = 0\n\
    \        for (x <- strings) {\n            if (x startsWith \"(\") {\n       \
    \         if (open_braces.isEmpty) {\n                    paren_count += 1\n \
    \                   open_braces = List(x)\n                } else {\n        \
    \            open_braces = open_braces ::: List(List(x))\n                   \
    \ open_braces.last.last.last.toInt match {\n                        case 0 =>\n\
    \                            paren_count += 1\n                            open_braces\
    \ = open_braces.last\n                        case x => paren_count -= 1\n   \
    \                 }\n                }\n            } else if (x endsWith \"(\"\
    ) {\n                if (closed_parens.isEmpty) {\n                    paren_count\
    \ += 1\n                    closed_parens = List(x)\n                } else {\n\
    \                    closed_parens = closed_parens ::: List(List(x))\n       \
    \             closed_parens.last.last.last.toInt match {\n                   \
    \     case 0 =>\n                            paren_count += 1\n              \
    \              closed_parens = closed_parens.last\n                        case\
    \ x => paren_count -= 1\n                    }\n                }\n          \
    \  } else if (x endsWith \"{\") {\n                open_braces = Nil\n       \
    \         closed_parens = Nil\n            } else if (x endsWith \"}\") {\n  \
    \              closed_parens = Nil\n            } else if (x endsWith \"(\") {\n\
    \                open_braces = Nil\n            } else if (x endsWith \"}\") {\n\
    \                closed_parens = Nil\n            } else if (\"(,()\".indexOf(x)\
    \ >= 0) {\n                paren_count += 1\n            } else if (\"(,()\".indexOf(x)\
    \ < 0) {\n                paren_count -= 1\n            }\n        }\n       \
    \ if (paren_count == 0) {\n            if (open_braces.isEmpty) {\n          \
    \      output = strings\n            } else {\n                output = open_braces\
    \ ::: strings\n            }\n        } else {\n            if (closed_parens.isEmpty)\
    \ {\n                output = strings\n            } else {\n                output\
    \ = strings ::: closed_parens\n            }\n        }\n        output", "  \
    \      val paren_group_string : String = paren_string.replaceAll(\"\\\\s+\", \"\
    \ \")\n        val paren_group_string_reverse = paren_group_string.reverse\n \
    \       val paren_group_string_list = paren_group_string_reverse.split(\" \")\n\
    \        val paren_group_string_list: List[String] = paren_group_string_list.map(s\
    \ => paren_group_string_reverse.split(s)).toList\n        paren_group_string_list.map(l\
    \ => l.foldLeft(List[String]())((acc, s) => {\n            if (acc.isEmpty) List(s)\n\
    \            else {\n                if (acc.last == \"\") acc.head :: s\n   \
    \             else acc.last + \", \" + s\n            }\n        }).toList.sorted)",
  "        val paren_chars = paren_string.chars\n        val open_brace_indexes =\
    \ mutable.HashSet[Int]()\n        var open_brace_level = 0\n        var open_brace_level\
    \ = paren_chars.takeWhile(_ != '(').length\n        var close_brace_level = 0\n\
    \        var close_brace_level = paren_chars.takeWhile(_ != ')').length\n\n  \
    \      paren_chars.foreach {\n            case c if c != '(' && (c == ')' || c\
    \ == ' ') => {\n                close_brace_level += 1\n            }\n      \
    \      case c if c == '(' => {\n                open_brace_indexes += open_brace_level\n\
    \                open_brace_level += 1\n            }\n            case c if c\
    \ == ')' => {\n                close_brace_level -= 1\n            }\n       \
    \     case c if c == ' ' => {\n                if (open_brace_level == 0 && close_brace_level\
    \ == 0) {\n                    open_brace_indexes += open_brace_level\n      \
    \              open_brace_level += 1\n                }\n                close_brace_level\
    \ += 1\n            }\n        }\n        val stringBuilder = StringBuilder()\n\
    \        open_brace_indexes.foreach {\n            open_brace_level => {\n   \
    \             if (open_brace_level > 0) {\n                    stringBuilder.append('(')\n\
    \                }\n            }\n        }\n        paren_chars.foreach {\n\
    \            case c if c != '(' && (c == ')' || c == ' ') => {\n             \
    \   stringBuilder.append(c)\n            }\n            case c if c == '(' =>\
    \ {\n                stringBuilder.append('(')\n            }\n            case\
    \ c if c == ')' => {\n                if (close_brace_level == 0 && stringBuilder.length()\
    \ > 0) {\n                    stringBuilder.append(')')\n                }\n \
    \               stringBuilder.append(')')\n            }\n            case c if\
    \ c == ' ' => {\n                if (stringBuilder.length() > 0) {\n         \
    \           stringBuilder.append(\" \")\n                }\n            }\n  \
    \      }\n        if (stringBuilder.length() > 0) {\n            stringBuilder.toString()\n\
    \        } else {\n            List()\n        }", "        def toParenGroups(string:\
    \ List[String], acc : List[String]): List[String] = {\n            if(string.isEmpty)\
    \ acc\n            else {\n                val head = string.head\n          \
    \      toParenGroups(string.tail, acc :+ head :+ \"(\" + acc :+ \")\")\n     \
    \       }\n        }\n        val open_paren_count = 0\n        val closed_paren_count\
    \ = 0\n        val paren_string_list = paren_string.trim().split(\"\\\\s+\").filter(_.nonEmpty)\n\
    \        val open_paren = paren_string_list.foldLeft(\"\") {\n            case\
    \ (acc,element) =>\n                element.head match {\n                   \
    \ case \"(\" => acc :+ \"(\" + acc :+ \")\"\n                    case \")\" =>\
    \ acc :+ \"(\" + acc :+ \")\"\n                    case \"{\" => acc :+ \"(\"\
    \ + acc :+ \"{\" + acc :+ \"})\"\n                    case \"}\" => acc :+ \"\
    (\" + acc :+ \"{\" + acc :+ \"})\"\n                    case _ => acc\n      \
    \          }\n        }\n        val closed_paren = paren_string_list.foldLeft(\"\
    \") {\n            case (acc, element) =>\n                element.head match\
    \ {\n                    case \")\" => acc :+ \"(\" + acc :+ \"{\" + acc :+ \"\
    })\"\n                    case \")\" => acc :+ \"(\" + acc :+ \"{\" + acc :+ \"\
    })\"\n                    case \"}\" => acc :+ \"(\" + acc :+ \"}\" + acc :+ \"\
    })\"\n                    case \"}\" => acc :+ \"(\" + acc :+ \"}\" + acc :+ \"\
    })\"\n                    case _ => acc\n                }\n        }\n      \
    \  toParenGroups(paren_string_list, \"\") match {\n            case List(paren_string)\
    \ => paren_string\n            case _ =>\n                val open_paren_count\
    \ = paren_string.count(_ == \"(\")\n                val closed_paren_count = paren_string.count(_\
    \ == \")\")\n                val result = open_paren_count + closed_paren_count\n\
    \                if(open_paren_count == 0 && closed_paren_count == 0) result else\
    \ open_paren_count :+ closed_paren_count\n        }", "        val paren_groups:\
    \ List[String] = Nil\n\n        for(i <- 0 to paren_string.length - 1) {\n   \
    \         val brace_match = \"((.))\".r.findAllIn(paren_string(i)).toList\n  \
    \          val open_match = \"(.)\".r.findAllIn(paren_string(i)).toList\n    \
    \        if(open_match.length < brace_match.length) {\n                paren_groups\
    \ = paren_groups ++ paren_string(i) ++ open_match\n            }\n           \
    \ else if(open_match.length == brace_match.length) {\n                paren_groups\
    \ = paren_groups ++ paren_string(i) ++ brace_match\n            }\n          \
    \  else if(open_match.length > brace_match.length) {\n                paren_groups\
    \ = paren_groups ++ paren_string(i) ++ brace_match ++ open_match\n           \
    \ }\n        }\n\n        paren_groups", "        val paren_groups = paren_string.split(\"\
    \"\"[\\(\\)]+\"\"\")\n        var paren_group_strings = List[String]()\n     \
    \   paren_groups.foreach{ group =>\n            if(paren_group_strings.isEmpty)\
    \ {\n                paren_group_strings = ListBuffer(group)\n            } else\
    \ {\n                val found_end = paren_group_strings.last.end\n          \
    \      val found_index = paren_group_strings.last.index\n                val start_index\
    \ = paren_group_strings.last.start\n                val final_start = paren_group_strings.last.start\n\
    \                val last_group = paren_group_strings.last\n                val\
    \ final_end = paren_group_strings.last.end\n\n                val is_balanced\
    \ = final_start <= found_index && found_index < final_end\n                if(!is_balanced)\
    \ {\n                    paren_group_strings = paren_group_strings :+ group\n\
    \                } else if(found_index > final_start && found_index < last_group.end)\
    \ {\n                    paren_group_strings = paren_group_strings :+ group\n\
    \                }\n            }\n        }\n        return paren_group_strings.toList",
  "        val paren_stack = mutable.Stack[String]()\n        val result_list = new\
    \ mutable.ListBuffer[String]()\n        paren_string.split(\"\\\\s\").foreach(x\
    \ => {\n            val temp_str = x\n            val open_brace_index =\n   \
    \             (temp_str.indexOf(\"(\") + temp_str.indexOf(\")\"))\n\n        \
    \    while (open_brace_index != -1) {\n                paren_stack += temp_str.substring(0,\
    \ open_brace_index)\n                val clos_brace_index =\n                \
    \    (temp_str.indexOf(\")\", open_brace_index + 1) + temp_str.indexOf(\"(\",\
    \ open_brace_index + 1))\n                paren_stack += temp_str.substring(clos_brace_index)\n\
    \                temp_str = temp_str.substring(0, clos_brace_index)\n        \
    \        open_brace_index =\n                    (temp_str.indexOf(\"(\") + temp_str.indexOf(\"\
    )\"))\n\n            }\n            if (paren_stack.size == 0) result_list +=\
    \ temp_str\n        })\n        result_list.result", "        def isBalanced(s\
    \ : String) : Boolean = \n            if (s.isEmpty) true\n            else {\
    \ \n                if (s.charAt(0) == '(') isBalanced(s.substring(1))\n     \
    \           else if (s.charAt(s.length-1) == ')') isBalanced(s.substring(0, s.length-1))\n\
    \                else false\n            }\n        val parens = paren_string.split(\"\
    \").filter(x => x == '(' || x == ')').map(x => x.toString).filter(x => !x.isEmpty)\n\
    \        val groupedParens = parens.groupBy(x => x)\n        var balanced : List[String]\
    \ = Nil\n        for (paren in groupedParens.keys) {\n            balanced ::=\
    \ paren\n            for (next <- groupedParens(paren).keys) {\n             \
    \   if (groupedParens(paren).count(y => y == next) == groupedParens(paren).count(y\
    \ => y == '(')) {\n                    balanced ::= next\n                }\n\
    \            }\n        }\n        (balanced.toList ::: groupedParens.values.toList.filter(_.keys.size\
    \ == 0))", "        val parens = paren_string.split(\"\"\"\\\\(\\)\"\"\")\n  \
    \      val paren_array = new mutable.Array[String]()\n\n        // Use a state\
    \ machine to determine whether the parentheses are balanced\n        var paren_is_balanced\
    \ = 0\n        // Keep track of opening and closing parens index\n        var\
    \ parens_index = 0\n        // Keep track of how many times the inner parentheses\
    \ are opened and closed\n        var parens_open = 1\n        for ((index, char)\
    \ <- parens.zipWithIndex) yield {\n            val open_char = parens(parens_index)\n\
    \            paren_array += char\n\n            if (char == '(') {\n         \
    \       paren_is_balanced += 1\n            } else if (char == ')') {\n      \
    \          paren_is_balanced -= 1\n            }\n\n            parens_index +=\
    \ 1\n\n            if (paren_is_balanced == 0) {\n                parens_open\
    \ = 1\n            }\n\n            if (parens_open == 0) {\n                parens_index\
    \ += 1\n            }\n\n        }\n\n        if (parens_index != parens.length)\
    \ {\n            throw new RuntimeException(\"Invalid paren string\")\n      \
    \  }\n\n        paren_array.dropRight(1)", "        if(paren_string == \"\") return\
    \ Nil\n        def find_open_bracket(s : String, index : Int) : Option[(Int, Int)]\
    \ = {\n            if(index == s.length - 1)\n                if (s.charAt(index)\
    \ == '(')\n                    Some((index, index+1))\n                else\n\
    \                    None\n            else if(s.charAt(index) == '(')\n     \
    \           Some((index, index+1))\n            else\n                find_open_bracket(s,\
    \ index+1)\n        }\n        def find_close_bracket(s : String, index : Int)\
    \ : Option[(Int, Int)] = {\n            if(index >= s.length)\n              \
    \  None\n            else if(s.charAt(index) != ')')\n                find_close_bracket(s,\
    \ index+1)\n            else\n                Some((index, index+1))\n       \
    \ }\n        val groups = mutable.ArrayBuffer.empty[String]\n        val index\
    \ = paren_string.length\n        while(index > 0) {\n            val open_pos\
    \ = find_open_bracket(paren_string, index).map(_._1)\n            val close_pos\
    \ = find_close_bracket(paren_string, index).map(_._1)\n            val group_start\
    \ = open_pos.orElse(close_pos)\n            val group_end = close_pos.orElse(open_pos.map(_._1))\n\
    \            val group_content = paren_string.substring(group_start._1, group_end._1+1)\n\
    \            groups.+=(group_content)\n            index = close_pos.map(_._2)\n\
    \        }\n        groups", "        val paren_splits = paren_string.split(\"\
    \\\\s+\")\n        val return_list = scala.collection.mutable.ListBuffer[String]()\n\
    \        var next_index = -1\n        for (i <- 0 until paren_splits.length) {\n\
    \            val current_group_size = (paren_splits(i).length / 2) - 2\n     \
    \       if (current_group_size != 0) {\n                return_list.append(paren_splits(i).substring(next_index,\
    \ next_index + current_group_size))\n                return_list.append(paren_splits(i\
    \ + 1).substring(current_group_size, current_group_size + 1))\n            }\n\
    \            next_index += current_group_size\n        }\n        return_list.toList",
  "        // The algorithm implemented below is as follows:\n        // 1) Parse\
    \ the paren_string into a tree\n        // 2) Perform inorder traversal on tree,\
    \ storing strings of groups as they are encountered in the tree\n        // 3)\
    \ Return list of strings of groups\n        val paren_string =  paren_string.trim\n\
    \        val paren_string =  paren_string.dropWhile(c => c != ' ').drop(1)\n \
    \       val paren_string =  paren_string.dropWhile(c => c != ' ').dropRight(1)\n\
    \        val paren_string =  paren_string.dropWhile(c => c != ' ').dropRight(2)\n\
    \        val paren_string =  paren_string.dropWhile(c => c != ' ').dropRight(3)\n\
    \n        val tokens = paren_string.split(\"\").map(_.toInt)\n        val groups\
    \ = new mutable.HashMap[Int, String]()\n        // Traverse the tree and store\
    \ strings of groups encountered in it\n        def traverse(node : TreeNode[Int],\
    \ group_string : String) : Unit = { \n            val children = node.getChildren()\n\
    \            if (children.isEmpty) \n                if (node.getType() == TreeNodeType.Leaf)\
    \ \n                    groups += (paren_string.indexOf(node.getLabel()) -> (group_string+node.getLabel()))\n\
    \                else\n                    groups += (paren_string.indexOf(node.getLabel())\
    \ -> (group_string+node.getLabel()))\n            else {\n                for\
    \ (child <- children)\n                    traverse(child, group_string+node.getLabel())\n\
    \            }\n        }\n        traverse(new TreeNode[Int](tokens.toSeq:_*),\
    \ \"()\")\n\n        var result = new ListBuffer[String]()\n        for (group\
    \ <- groups.keys) {\n            result.append(groups.get(group))\n        }\n\
    \        return result.result()", "        var group_list : List[String] = Nil\n\
    \        var open_braces : mutable.Set[Char] = mutable.Set()\n        for (i <-\
    \ 0 until paren_string.length) {\n            if (paren_string(i) == '(') {\n\
    \                if (open_braces.contains(paren_string(i))) {\n              \
    \      group_list = group_list :+ paren_string(i + 2)\n                } else\
    \ {\n                    open_braces += paren_string(i + 2)\n                }\n\
    \            } else if (paren_string(i) == ')') {\n                open_braces\
    \ -= paren_string(i + 2)\n            } else if (paren_string(i) == ' ') {\n \
    \               // Ignore spaces as part of the group\n            } else {\n\
    \                group_list += paren_string(i)\n            }\n        }\n   \
    \     group_list", "        //We are going to count the open and close braces\
    \ of paren_string with each loop\n        var open_paren = 0\n        var close_paren\
    \ = 0\n        var brace_count = 0\n        \n        //The output list will be\
    \ stored here\n        val output = ListBuffer[String]()\n        \n        //Iterate\
    \ over all the characters in the string\n        for (c <- paren_string) {\n \
    \           //We just increment the brace_count when encounter the opening brace\n\
    \            if (c == '(') open_paren += 1\n            \n            //We just\
    \ decrement the brace_count when encounter the closing brace\n            else\
    \ if (c == ')') close_paren += 1\n            \n            //When we encounter\
    \ a space or a line break\n            else if (c == ' ' || c == '\\n') ()\n \
    \           \n            //When we encounter an opening brace and are within\
    \ a set of parentheses\n            else if (open_paren > 0 && c == '(') {\n \
    \               brace_count += 1\n                \n                //If we hit\
    \ the closing brace too early, we must add the last element of the output to the\
    \ output list\n                if (close_paren == brace_count) output += paren_string.substring((open_paren\
    \ + 1), close_paren)\n            }\n            \n            //When we encounter\
    \ a closing brace and are within a set of parentheses\n            else if (open_paren\
    \ > 0 && c == ')') {\n                brace_count -= 1\n                \n   \
    \             //If we hit the opening brace too early, we must add the last element\
    \ of the output to the output list\n                if (open_paren == brace_count)\
    \ output += paren_string.substring((open_paren + 1), close_paren)\n          \
    \  }\n        }\n        \n        //Finally, return output\n        output.toList",
  "        // Your code here\n        val lst_str = paren_string.split(\"\\\\s(?=\\\
    \\()|(?<=\\\\))\\\\s)\").toList\n        val lst = lst_str.foldLeft((List[String]()))(\
    \ (acc, elem) => { val lst_str = elem.split(\"\\\\s(?=\\\\()|(?<=\\\\))\\\\s)\"\
    ).toList; acc.++(lst_str) })\n        val lst_lst = lst.foldLeft((List[List[String]]))((acc,\
    \ elem) => {\n            val (lst_str, lst_lst) = elem.split(\"\\\\s(?=\\\\()|(?<=\\\
    \\))\\\\s)\").toList\n            val lst = lst_lst.foldLeft((List[List[String]]))((acc,\
    \ elem) => {\n                val lst_str = elem.split(\"\\\\s(?=\\\\()|(?<=\\\
    \\))\\\\s)\").toList\n                val lst = lst_str.foldLeft((List[String]()))(\
    \ (acc, elem) => { acc.++(List(elem)) })\n                lst\n            })\n\
    \            (lst_str, lst)\n        })\n        lst_lst.foldLeft((List[List[String]]))((acc,\
    \ elem) => {\n            val lst_str = elem.split(\"\\\\s(?=\\\\()|(?<=\\\\))\\\
    \\s)\").toList\n            val lst = lst_str.foldLeft((List[String]()))( (acc,\
    \ elem) => { acc.++(elem) })\n            lst\n        })", "        var paren_string\
    \ = paren_string.toLowerCase\n        var paren_groups: List[String] = Nil\n \
    \       var open_brace = paren_string.indexOf('(')\n        var open_paren = paren_string.indexOf('(')\n\
    \        while (open_brace >= 0) {\n            paren_groups = paren_string.substring(open_brace,\
    \ paren_string.length).split(')')\n            paren_string = paren_string.substring(paren_groups(0).length\
    \ + 1, paren_string.length)\n            paren_string = paren_groups.reverse.mkString(\"\
    )\") + paren_string\n            paren_groups = Nil\n            open_brace =\
    \ paren_string.indexOf('(')\n        }\n        paren_groups = paren_string.split(')')\n\
    \        paren_groups.reverse.mkString(\")\")", "        def isParenGroup(paren_string\
    \ : String) : Boolean = {\n            paren_string match {\n                case\
    \ \"(\" => true\n                case \")\" => true\n                case _ =>\
    \ false\n            }\n        }\n\n        def isBraceGroup(paren_string : String)\
    \ : Boolean = {\n            paren_string match {\n                case \"{\"\
    \ => true\n                case \"}\" => true\n                case _ => false\n\
    \            }\n        }\n\n        def isBalanced(paren_string : String) : Boolean\
    \ = {\n            // check if paren_string contains a closing brace\n       \
    \     paren_string match {\n                case \"{\" => true\n             \
    \   case \"}\" => false\n                case _ => false\n            }\n    \
    \    }\n\n        def isNested(paren_string : String) : Boolean = {\n        \
    \    // check if paren_string contains a closing brace\n            paren_string\
    \ match {\n                case \"{\" => false\n                case \"}\" =>\
    \ true\n                case _ => false\n            }\n        }\n\n        val\
    \ brace_groups = mutable.ListBuffer[String]()\n\n        var paren_string : String\
    \ = \"\"\n\n        for (character <- paren_string) {\n            if (character\
    \ == '(') {\n                if (isParenGroup(paren_string)) {\n             \
    \       paren_string = \"\"\n                    brace_groups += paren_string\n\
    \                } else {\n                    paren_string += \"(\"\n       \
    \         }\n            } else if (character == ')') {\n                if (!isParenGroup(paren_string))\
    \ {\n                    paren_string = \"\"\n                    brace_groups\
    \ += paren_string\n                }\n            } else if (character == '{')\
    \ {\n                if (!isBraceGroup(paren_string)) {\n                    paren_string\
    \ = \"\"\n                    brace_groups += paren_string\n                }\n\
    \            } else if (character == '}') {\n                if (!isBraceGroup(paren_string))\
    \ {\n                    paren_string = \"\"\n                    brace_groups\
    \ += paren_string\n                } else {\n                    if (isBalanced(paren_string))\
    \ {\n                        paren_string = \"\"\n                        brace_groups\
    \ += paren_string\n                    }\n                }\n            }\n\n\
    \            paren_string += character\n        }\n\n        brace_groups += paren_string\n\
    \n        if (paren_string != \"\") {\n            throw new RuntimeException(\"\
    Error: Unbalanced parentheses\")\n        }\n\n        brace_groups.toList", " \
    \       if (paren_string.isEmpty) return Nil\n        var parens_open : Option[Int]\
    \ = None\n        var parens_close : Option[Int] = None\n        var curr_group_string\
    \ : List[String] = Nil\n        var curr_group_string : List[String] = Nil\n \
    \       var open_parens_stack : List[Int] = Nil\n        var close_parens_stack\
    \ : List[Int] = Nil\n        var is_closed : Boolean = false\n        var curr\
    \ : Int = -1\n        var i : Int = 0\n        var count : Int = 0\n        var\
    \ group_index = 0\n        for (c <- paren_string.toCharArray) {\n           \
    \ if (c == '(') open_parens_stack ::= parens_open\n            if (c == '(') parens_open\
    \ = Some(parens_open.getOrElse(-1))\n            if (c == ')') {\n           \
    \     is_closed = true\n                if (parens_open.getOrElse(-1) != -1) {\n\
    \                    open_parens_stack = open_parens_stack.filterNot(_ == parens_open.getOrElse(-1))\n\
    \                    parens_open = None\n                    parens_close = None\n\
    \                }\n            }\n            if (c == ')' && parens_open.getOrElse(-1)\
    \ != -1) {\n                is_closed = false\n                open_parens_stack\
    \ = open_parens_stack.filterNot(_ == parens_open.getOrElse(-1))\n            \
    \    parens_open = None\n                parens_close = None\n            }\n\
    \            if (is_closed && parens_close.getOrElse(-1) != -1) {\n          \
    \      close_parens_stack = close_parens_stack :+ parens_close.getOrElse(-1)\n\
    \                parens_close = None\n            }\n            if (!is_closed\
    \ && parens_open.getOrElse(-1) != -1) {\n                close_parens_stack =\
    \ close_parens_stack :+ parens_open.getOrElse(-1)\n                parens_open\
    \ = None\n            }\n            if (c == '(') open_parens_stack = open_parens_stack\
    \ :+ parens_open.getOrElse(-1)\n            if (c == ')') parens_close = parens_close\
    \ :+ parens_close.getOrElse(-1)\n            if (parens_open.getOrElse(-1) ==\
    \ -1 && parens_close.getOrElse(-1) == -1) {\n                if (c == '(') curr_group_string\
    \ = curr_group_string.++'('\n                if (c == ')') curr_group_string =\
    \ curr_group_string.++')'\n            }\n            if (parens_open.getOrElse(-1)\
    \ != -1 || parens_close.getOrElse(-1) != -1) {\n                if (c == '(')\
    \ curr_group_string = curr_group_string.++'('\n                if (c == ')') curr_group_string\
    \ = curr_group_string.", "        def parse(str: String): List[String] = {\n \
    \           def parseToList(remainingStr: String): List[String] = {\n        \
    \        if (remainingStr.length == 0)\n                    Nil\n            \
    \    else {\n                    val remainderStr = remainingStr.trim\n      \
    \              if (remainderStr.length == 0)\n                        Nil\n  \
    \                  else if (remainderStr.charAt(0) == '(') {\n               \
    \         parseToList(remainderStr.substring(1))\n                    }\n    \
    \                else {\n                        val openBraces = remainingStr.trim('(',\
    \ '[', '{')\n                        val openBrace = openBraces.charAt(0)\n  \
    \                      val closeBrace = openBraces.charAt((openBraces.length -\
    \ 1))\n                        remainingStr.substring(openBraces.length - 1).trim\n\
    \                                .split(\"(\" + openBrace + \")\" + closeBrace\
    \ + \"(\")\n                                .filter(_ != \"\")\n             \
    \                   .map(parseToList)\n                                .flatten.toList\n\
    \                    }\n                }\n            }\n            str.split(\"\
    \\\\(\").filter(_ != \"\").map(parseToList).flatten.toList\n        }\n      \
    \  return parse(paren_string)", "        // Initialize a List to store the result\n\
    \        val parenGroups = ListBuffer[String]()\n\n        // Iterate through\
    \ the paren_string and add everything in paren_string to the parenGroups ListBuffer\n\
    \        for (i <- 0 until paren_string.length) {\n            parenGroups +=\
    \ paren_string(i) //append paren_string (i) to parenGroups\n        }\n\n    \
    \    // return the parenGroups list\n        return parenGroups.toList", "   \
    \     val group_strings = paren_string.split(\"\\\\(\")\n        var current_group\
    \ = \"\"\n        var group_string = \"\"\n        var result: List[String] =\
    \ List()\n        for (group_str <- group_strings) {\n            if (group_str.length\
    \ == 1) {\n                current_group += group_str\n            } else {\n\
    \                if (current_group != \"\") {\n                    result += current_group\n\
    \                }\n                current_group = group_str\n            }\n\
    \        }\n        if (current_group != \"\") {\n            result += current_group\n\
    \        }\n        return result", "        var stack: List[String] = Nil\n \
    \       paren_string.foreach {x => if(x.equals(')')) { stack :+ x }\n        else\
    \ if( x.equals('(') ) { stack = stack :+ x }\n        else if( !stack.isEmpty\
    \ && x.equals('(') && stack.isEmpty) { stack.head :+ x }\n        else { stack\
    \ :+ x }\n        }", "      val paren_groups = paren_string.split(\" \").map(x\
    \ => x.split(\"(\")).map(x => x.map(y => y.trim))\n      paren_groups.foldLeft(List[String]()){\n\
    \        case (acc, elem) =>\n          if(elem.head.length == 1 && elem.last.length\
    \ == 1) acc ::: (elem.last.head)\n          else if(elem.head.length == 1 && !elem.last.length)\
    \ acc ::: (elem.head.last)\n          else if(elem.head.length == elem.last.length)\
    \ acc ::: (elem.last.head) ::: elem.last.last\n          else paren_groups\n \
    \     }", "        val group_list = mutable.MutableList[String]()\n        for\
    \ (i <- 1 to paren_string.length-1) {\n            if (paren_string(i) == '(')\
    \ {\n                if (paren_string(i+1).isLetter) {\n                    paren_string\
    \ += paren_string(i+1)\n                    group_list += paren_string(i+1)\n\
    \                    paren_string = paren_string.slice(0,i+1)\n              \
    \  }\n            }\n            if (paren_string(i) == ')') {\n             \
    \   paren_string = paren_string.slice(0,i)\n            }\n        }\n       \
    \ group_list += paren_string\n        val group_string = paren_string.slice(0,paren_string.length-1)\n\
    \        val group_string_rest = paren_string.slice(paren_string.length-1)\n \
    \       group_list.toList.flatMap(_.split(' '))", "        var output: List[String]\
    \ = Nil\n\n        val opening_closing_pairs = paren_string.split(\"\\\\(\").map(x\
    \ => (x.replaceAll(\"\\\\(|\\\\)\", \"\"), x)).groupBy(x => x._1)\n\n        for\
    \ (opening_closing_pair <- opening_closing_pairs) {\n            val open_string\
    \ = opening_closing_pair._2.replaceAll(\"\\\\(|\\\\)\", \"\").trim\n         \
    \   val close_string = opening_closing_pair._2.replaceAll(\"\\\\(|\\\\)\", \"\"\
    ).trim\n            val close = close_string.split(\" \").map(x => x.replaceAll(\"\
    \\\\(|\\\\)\", \"\").trim)\n\n            if(open_string.equals(close_string))\
    \ {\n                output += open_string\n            } else {\n           \
    \     output += open_string + close\n            }\n        }\n\n        output",
  "        val paren_groups = paren_string.split(\"[()]\")\n        var paren_group:\
    \ List[String] = Nil\n        var open_paren = 0\n        for (paren_string <-\
    \ paren_groups)\n        {\n            paren_string.trim()\n            if (paren_string\
    \ != \"\")\n            {\n                if (paren_group.isEmpty)\n        \
    \        {\n                    paren_group = List(paren_string)\n           \
    \     }\n                else if (open_paren > 0 && paren_group.isEmpty)\n   \
    \             {\n                    paren_group = List(paren_group.head)\n  \
    \              }\n                else if (paren_group.isEmpty)\n            \
    \    {\n                    open_paren -= 1\n                }\n             \
    \   else if (paren_group.isEmpty && open_paren == 0)\n                {\n    \
    \                open_paren += 1\n                }\n                else\n  \
    \              {\n                    open_paren += 1\n                    paren_group.insert(open_paren,\
    \ paren_string)\n                }\n            }\n        }\n        return paren_group.distinct",
  "        val paren_group_stack = mutable.Stack[String]()\n        var paren_group_result:\
    \ List[String] = List()\n        for (paren_group <- paren_string.split(' '))\
    \ {\n            if (paren_group.startsWith(\"(\")) {\n                paren_group_result\
    \ ::= paren_group\n                paren_group_stack.push(paren_group)\n     \
    \       } else if (paren_group.endsWith(\")\")) {\n                paren_group_result\
    \ ::= paren_group_stack.pop()\n            }\n        }\n        paren_group_result",
  "        //split string by space and keep space and bracket\n        val tokens\
    \ = paren_string.split(\" \").filter(s => s != \"\")\n        val brackets = mutable.ListBuffer[String]()\n\
    \        //add parentheses to list for left paren\n        for(i <- 0 until tokens.length\
    \ - 1){\n            if(tokens(i) == \"(\"){\n                brackets += \"(\"\
    \n            }\n            else{\n                brackets += \"[\"\n      \
    \      }\n        }\n        //add brackets to list for right paren\n        for(i\
    \ <- tokens.length - 1 until tokens.length){\n            if(tokens(i) == \")\"\
    ){\n                brackets += \"]\"\n            }\n            else{\n    \
    \            brackets += \"]\"\n            }\n        }\n        //now we create\
    \ a list of strings. Each string has brackets in it. Now we simply remove braces\n\
    \        //from each string and concatenate all the strings. We should have a\
    \ list of string that are\n        //separated by parenthesis.\n        val listOfStrings\
    \ = for (t <- tokens) yield \"(\" + brackets.toList.mkString(\"\") + \")\"\n \
    \       listOfStrings.toList", "        if (paren_string.length == 0)\n      \
    \      return Nil\n        val groups = paren_string.split(\"\\\\)\")\n      \
    \  val res = []\n        for (group <- groups) {\n            if (group.startsWith(\"\
    (\")) {\n                val index = groups.indexOf(group).asInstanceOf[Int]\n\
    \                val open_braces = groups.lastIndex - index\n                if\
    \ (open_braces == 0) {\n                    // This group is a standalone opening\
    \ (\n                    res.append(group)\n                } else {\n       \
    \             // This group is balanced. Move it to the front\n              \
    \      val new_group = groups(index - 1)\n                    val new_groups =\
    \ groups.drop(index - 1)\n                    val new_res = res.reverse.slice(0,\
    \ open_braces + 1).reverse.take(open_braces + 1)\n                    new_res.append(new_group)\n\
    \                    val new_group_string = groups.take(open_braces + 1).mkString(\"\
    (\", \")\") + groups.drop(open_braces + 1)\n                    val new_res_list\
    \ = separateParenGroups(new_group_string)\n                    new_res.append(new_res_list)\n\
    \                }\n            } else {\n                res.append(group)\n\
    \            }\n        }\n        res", "        var groups = List.empty[String]\n\
    \        val paren_chars = paren_string\n        paren_chars.foreach {\n     \
    \       case c: Char =>\n                if( c == '(') {\n                   \
    \ groups = groups ::: List()\n                }\n                else {\n    \
    \                if( groups.length == 0)\n                        groups = List(c.toString)\n\
    \                    else if( groups.length == 1 && groups(0) == \"()\" )\n  \
    \                      groups = List(c.toString)\n                    else if(\
    \ groups.last.startsWith(\"(\") && groups.last.length() > 1 )\n              \
    \          groups = List(groups.last + c.toString)\n                    else if(\
    \ groups.last.startsWith(\"(\") && groups.last.length() < 1 )\n              \
    \          groups = List(c.toString)\n                    else {\n           \
    \             if( groups.last == (\"())\") && groups.last.length() > 1 )\n   \
    \                         groups = List(groups.last + c.toString)\n          \
    \              else if( groups.last == (\"())\") && groups.last.length() < 1 )\n\
    \                            groups = List(groups.last + c.toString)\n       \
    \                 else if( groups.last == (\"())()\") && groups.last.length()\
    \ > 2 )\n                            groups = List(groups.last + c.toString)\n\
    \                        else if( groups.last == (\"())()\") && groups.last.length()\
    \ < 2 )\n                            groups = List(groups.last + c.toString)\n\
    \                        else if( groups.last == (\"(())\") && groups.last.length()\
    \ > 2 )\n                            groups = List(groups.last + c.toString)\n\
    \                        else if( groups.last == (\"(())\") && groups.last.length()\
    \ < 2 )\n                            groups = List(groups.last + c.toString)\n\
    \                        else\n                            groups = groups :::\
    \ List(c.toString)\n                    }\n                }\n            case\
    \ _ : String =>\n                groups = groups ::: List()\n        }\n     \
    \   groups.toList", "        val paren_stack = ListBuffer[String]()\n\n      \
    \  for(i <- 1 to paren_string.length){\n            if(paren_string.charAt(i)\
    \ == '('){\n                paren_stack += paren_string.substring(0,i)\n     \
    \       }else if(paren_string.charAt(i) == ')'){\n                paren_stack\
    \ += paren_string.substring(0,i)\n            }\n        }\n        paren_stack.toList",
  "        var result : List[String] = Nil\n        var open_count : Int = 0\n   \
    \     var open_parens : List[String] = Nil\n        var is_close_parens : List[Boolean]\
    \ = Nil\n        for (i <- 0 to paren_string.length - 1) {\n            if (paren_string(i)\
    \ == paren_string(i+1)) {\n                open_count += 1\n            } else\
    \ {\n                if (open_count > 0) {\n                    if (open_parens\
    \ != Nil) {\n                        result += open_parens\n                 \
    \       open_parens = Nil\n                    }\n                    result +=\
    \ Nil\n                    open_count = 0\n                }\n               \
    \ open_parens = open_parens :+ paren_string(i)\n            }\n\n            is_close_parens\
    \ = is_close_parens :+ paren_string(i+1) != paren_string(i)\n        }\n     \
    \   if (open_count > 0) {\n            if (open_parens != Nil) {\n           \
    \     result += open_parens\n            }\n        }\n        result :+ paren_string.take(paren_string.length-open_count).filterNot(_\
    \ == \")\").toList", "        paren_string.flatMap { s =>\n            if(s.startsWith(\"\
    (\") && s.endsWith(\")\"))\n                List(s)\n            else if(s.startsWith(\"\
    (\"))\n                List(s, \"\")\n            else if(s.endsWith(\")\"))\n\
    \                List(\"\", s)\n            else\n                List(\"\", s)\n\
    \        }.filter(s => s.nonEmpty).filter(s => s.head != \"(\").filter(s => s.head\
    \ != \")\").filter(s => s.head != \"()\").filter(s => s.head != \")()\").filter(s\
    \ => s.head != \"()()\").filter(s => s.head != \"(())\").filter(s => s.head !=\
    \ \")()()\").filter(s => s.head != \"()()()\").filter(s => s.head != \"(())()\"\
    ).filter(s => s.head != \")()()()\").filter(s => s.head != \"()()()()\").filter(s\
    \ => s.head != \"(())()()\").filter(s => s.head != \")()()()\").filter(s => s.head\
    \ != \"()()()()\").filter(s => s.head != \"(())()()\").filter(s => s.head != \"\
    )()()()()\").filter(s => s.head != \"()()()()\").filter(s => s.head != \"(())()()\"\
    ).filter(s => s.head != \")()()()()\").filter(s => s.head != \"()()()()\").filter(s\
    \ => s.head != \"(())()()\").filter(s => s.head != \")()()()()\").filter(s =>\
    \ s.head != \"()()()()\").filter(s => s.head != \"(())()()\").filter(s => s.head\
    \ != \")()()()()\").filter(s => s.head != \"()()()()\").filter(s => s.head !=\
    \ \"(())()()\").filter(s => s.head != \")()()()()\").filter(s => s.head != \"\
    ()()()()\").filter(s => s.head != \"(())()()\").filter(s => s.head != \")()()()()\"\
    ).filter(s => s.head != \"()()()()\").filter(s => s.head != \"(())()()\").filter(s\
    \ => s.head != \")()()()()\").filter(s => s.head != \"()()()()\").filter(s =>\
    \ s.head != \"(())()()\").filter(s => s.head != \")()()()()\").filter(s => s.head\
    \ != \"()()()()\").filter(s => s.head != \"(())()()\").filter(s => s.head != \"\
    )()()()()\").filter(s => s.head != \"()()", "        var paren_groups: List[String]\
    \ = Nil\n        paren_string.splitWhile(c => !(\"(\" < c && c <= \"(\"))\n  \
    \          .foreach { str =>\n                if(str.startsWith(\"(\") && str.endsWith(\"\
    )\")) {\n                    paren_groups = paren_groups :+ str\n            \
    \    }\n            }\n        paren_groups", "        val paren_stack = mutable.Stack[String]()\n\
    \        paren_string match {\n            case \"\" => Nil\n            case\
    \ _ =>\n                for (char <- paren_string.toCharArray) {\n           \
    \         if (char == '(') paren_stack.push(char)\n                    if (char\
    \ == ')') paren_stack match {\n                        case Nil => paren_string\
    \ match {\n                            case \"\" => Nil\n                    \
    \        case _ => Nil\n                        }\n                        case\
    \ _ =>\n                            val newParen = paren_stack.pop()\n       \
    \                     paren_string = newParen + char\n                       \
    \     if (newParen != \"\") paren_stack.push(newParen)\n                    }\n\
    \                }\n        }", "        val group_stack = mutable.Stack[String]()\n\
    \        val result_list = mutable.ListBuffer[String]()\n        var temp_str\
    \ : String = \" \"\n\n        for (i <- 0 until paren_string.length) {\n     \
    \       // If the next character is an opening paren, add it to the group\n  \
    \          if (paren_string(i) == '(') {\n                group_stack += '('\n\
    \                temp_str = \"\"\n            } else {\n                temp_str\
    \ = temp_str + paren_string(i)\n            }\n\n            // If the next character\
    \ is a closing paren, pop one level\n            if (paren_string(i) == ')') {\n\
    \                val last_char = group_stack.pop()\n                // If the\
    \ last character, a left brace, was not a left brace, then\n                //\
    \ this paren was not a proper group of paren\n                if (last_char !=\
    \ '(') result_list += temp_str + \")\"\n                else {\n             \
    \       // If the last character was a left brace, then\n                    //\
    \ this paren was properly closed, so add it to the result list\n             \
    \       result_list += temp_str\n                }\n                temp_str =\
    \ \" \"\n            }\n        }\n\n        // If there's a left brace on the\
    \ stack, then there were too many close parens.\n        // If the last item on\
    \ the stack is a right brace, then it didn't close enough\n        // parens.\n\
    \        if (group_stack.last == '(') result_list += temp_str + \")\"\n      \
    \  else result_list.toList", "        // Base Case\n        if (paren_string.isEmpty)\
    \ {\n            return Nil\n        }\n        // Check for opening braces and\
    \ closing braces\n        val opening_braces = paren_string.substring(0, paren_string.length-1)\n\
    \            .split(\"(?<=\\\\))\")\n            .map(x => paren_string.substring(0,\
    \ paren_string.length - x.length))\n            .filter(_ != \"\")\n        if\
    \ (opening_braces.size != opening_braces.toList.size) {\n            return Nil\n\
    \        }\n        val closing_braces = paren_string.substring(paren_string.length-1,\
    \ paren_string.length).split(\"(?<=\\\\()\")\n            .filter(x => !x.isEmpty)\n\
    \            .map(x => paren_string.substring(paren_string.length-x.length, paren_string.length))\n\
    \        if (closing_braces.size != closing_braces.toList.size) {\n          \
    \  return Nil\n        }\n        val result = closing_braces.map(x => opening_braces.dropRight(closing_braces.indexOf(x)).mkString(\"\
    \")) ::: opening_braces.filter(_ != \"\").map(x => x)\n        return result.filter(x\
    \ => !x.isEmpty)", "        // initialize a list to hold the separate groups\n\
    \        var groups: List[String] = Nil\n\n        // use some basic pattern matching\
    \ to find the groups\n        paren_string.trim match {\n            case \"\"\
    \ => Nil\n            case \")\" =>\n                groups = groups :+ \")\"\n\
    \            case \")(\") =>\n                groups = groups :+ \")(\"\n    \
    \        case \")(\") => groups = groups :+ \")(\"\n            case \")(\") =>\
    \ groups = groups :+ \")(\"\n            case \")(\") => groups = groups :+ \"\
    )(\"\n            case _ => // keep matching until the parens are closed\n   \
    \             paren_string.split(\"\"\"[(][)]\"\"\").map(_.trim).toList match\
    \ {\n                    case Nil => Nil\n                    case parens => parens.map(_.trim)\
    \ match {\n                        case Nil => Nil\n                        case\
    \ _ =>\n                            // check if we have closed parens on the right\
    \ side\n                            if ((parens.head.length == parens.last.length)\
    \ &&\n                                (parens.head == parens.last.tail.head))\
    \ {\n                                // if so, add the closing paren to the list\n\
    \                                groups = groups :+ parens.last\n            \
    \                } else {\n                                // otherwise, add a\
    \ new item to the list\n                                groups = groups :+ \"\
    )\"\n                            }\n                    }\n                }\n\
    \        }\n\n        // return the groups\n        return groups", "        var\
    \ stack: Stack[String] = new Stack[String]()\n        val strings: List[String]\
    \ = paren_string.split(\"\"\"\\s+\"\"\").toList\n        strings.foreach{ s =>\n\
    \            val new_string: List[String] = s.split(\"\"\"\\(|\\)\"\"\").toList\n\
    \            val paren_open: List[String] = new_string.takeWhile(_ != \"(\")\n\
    \            val paren_close: List[String] = new_string.dropWhile(_ != \")\")\n\
    \            if (paren_close.isEmpty) stack += \"(\" + s + \"()\"\n          \
    \  else {\n                val paren_open_without_close = paren_open.takeRight(1)\n\
    \                val close_brace = paren_close.last\n                val open_paren\
    \ = paren_open.last\n                stack += \"(\" + open_paren + \")\"\n   \
    \             stack += close_brace\n            }\n        }\n        strings.reverse",
  "        val paren_open = mutable.ListBuffer[String]()\n        val paren_close\
    \ = mutable.ListBuffer[String]()\n\n        paren_string.split(\"[()]\").foreach(s\
    \ => {\n            val new_s = if (s.startsWith(\"(\"))\n                paren_open\
    \ += s\n            else if (s.endsWith(\")\"))\n                paren_close +=\
    \ s\n            else if (paren_open.nonEmpty && paren_close.nonEmpty)\n     \
    \           paren_open += s.stripPrefix(\"(\").stripSuffix(\")\")\n        })\n\
    \n        paren_open.distinct", "        def paren_stack = new Stack[String]()\n\
    \        def paren_levels = new mutable.Stack[Int]()\n\n        paren_string.split(\"\
    \"\"\\s+\"\"\").map(x => {\n            if(x.equals(\"\"))\n                return\
    \ List()\n            if(paren_stack.isEmpty)\n                paren_levels.push(0)\n\
    \            if(paren_stack.isEmpty)\n                paren_stack.push(x.charAt(0))\n\
    \            if(paren_levels.isEmpty)\n                paren_levels.push(0)\n\
    \            if(x.equals(paren_stack.pop()))\n                paren_levels -=\
    \ 1\n            if(paren_levels.isEmpty)\n                paren_stack.push(x.charAt(0))\n\
    \            else\n                paren_levels.push(paren_levels.pop() + 1)\n\
    \        })\n            .filter(x => x != \"\")\n            .map(x => paren_stack.pop())\n\
    \            .filter(x => x != \"\")", "        val paren_array = paren_string.split(\"\
    \\\\)\\\\(\")\n        val result_list : List[String] = Nil\n        val open_braces_array\
    \ : List[Array[Int]] = paren_array.toArray.map(_ => {\n            val open_brace\
    \ = paren_array.length\n            val close_brace = open_brace - 1\n       \
    \     (open_brace, close_brace)\n        })\n        val open_braces : List[Int]\
    \ = open_braces_array.toList\n\n        // Find any left open braces in the array\
    \ (indicated by -1 value in array). For every open brace that is\n        // left\
    \ open, add all remaining close_braces to the result list.\n        for (open_count\
    \ <- open_braces.indices) {\n            val open_brace : Int = open_braces(open_count)\n\
    \            if (open_brace > -1) {\n                val close_brace : Int = open_braces(open_count\
    \ + 1)\n                result_list ++= paren_array.slice(1, close_brace).map(s\
    \ => s.trim).filter(!_.isEmpty)\n            }\n        }\n        return result_list",
  "        def groupList(n: Int, paren_string : String) : List[String] = {\n     \
    \       val l = paren_string.length\n            val groups = List.fill(n)(\"\
    ()\")\n            for (i<- 0 until paren_string.length) {\n                if\
    \ (paren_string(i) == '(') {\n                    if (paren_string(i+1).equals('('))\
    \ {\n                        groups(i) = paren_string(i+1)\n                 \
    \   }\n                    else {\n                        groups(i) = \"(\"\n\
    \                        groupList(i + 1, paren_string)\n                    }\n\
    \                }\n                else {\n                    if (paren_string(i).equals(')'))\
    \ {\n                        groups(i) = \")\"\n                        if (groups(i-1)\
    \ == \"(\") {\n                            groupList(i-1, paren_string)\n    \
    \                    }\n                    }\n                }\n           \
    \ }\n            groups\n        }\n        groupList(0, paren_string)", "   \
    \     var group_list : List[String] = Nil\n        var open_count = paren_string.count(\"\
    (\")\n        var close_count = paren_string.count(\")\")\n        var open_balance\
    \ = 0\n        var close_balance = 0\n\n        for ( _ <- 0 until close_count\
    \ ) {\n            if ( paren_string.charAt(close_count - _) == '(' ) {\n    \
    \            close_balance += 1\n            } else if ( paren_string.charAt(close_count\
    \ - _) == ')' ) {\n                close_balance -= 1\n            }\n       \
    \ }\n\n        for ( _ <- 0 until open_count ) {\n            if ( paren_string.charAt(open_count\
    \ - _) == '(' ) {\n                open_balance += 1\n            } else if (\
    \ paren_string.charAt(open_count - _) == ')' ) {\n                open_balance\
    \ -= 1\n            }\n        }\n\n        open_count -= close_count\n\n    \
    \    for( i <- 0 to open_count ) {\n            if ( open_balance >= 0 ) {\n \
    \               group_list.append ( paren_string.charAt(open_count + i) ) \n \
    \           } else {\n                group_list.append ( paren_string.charAt(open_count\
    \ + i) ) \n            }\n        }\n\n        if ( open_balance >= 0 ) {\n  \
    \          for ( _ <- 0 until close_count ) {\n                if ( paren_string.charAt(close_count\
    \ - _) == '(' ) {\n                    close_balance += 1\n                } else\
    \ if ( paren_string.charAt(close_count - _) == ')' ) {\n                    close_balance\
    \ -= 1\n                }\n            }\n        }\n\n        group_list.\n \
    \           map( x => paren_string.substring(close_count + x+1, close_count +\
    \ x + open_count + 1) ).\n            filter( x => !x.equals(\"\") ).\n      \
    \      toList", "        // Use a stack to store the parens\n        val parens\
    \ = new mutable.Stack[String]\n        // Push each paren in the parens stack\n\
    \        for (c <- paren_string) {\n            if (c == '(')\n              \
    \  parens.push(c)\n            else if (c == ')') {\n                // Pop the\
    \ stack until '(' is found\n                while (!parens.isEmpty && parens.head\
    \ != '(')\n                    parens.pop\n            }\n        }\n        //\
    \ Add the first paren at the top of the stack\n        parens.push('(')\n    \
    \    val result = ListBuffer[String]()\n        // Add the first paren at the\
    \ top of the result list\n        result += '('\n        // Iterate through all\
    \ remaining parens\n        while (parens.nonEmpty) {\n            // Get the\
    \ current paren from the stack\n            val current_paren = parens.pop\n \
    \           // If this is the last paren encountered, add the paren at the end\
    \ of the result\n            if (parens.isEmpty)\n                result += current_paren\n\
    \            // Else if this is an open paren, then add it at the start of the\
    \ result list\n            else if (current_paren == '(')\n                result\
    \ += current_paren\n            // Otherwise, add the paren to the result list\n\
    \            else {\n                // If the current paren is not an open paren,\
    \ then close the paren in the result list and open a new one\n               \
    \ if (current_paren != ')')\n                    result += current_paren\n   \
    \             result += '('\n            }\n        }\n        // Return the result\
    \ list\n        result.toList", "        // Initialize empty list\n        var\
    \ paren_groups: List[String] = Nil\n\n        // Loop through all the characters\
    \ in the input string\n        for(c: String <- paren_string) {\n            switch(c)\
    \ {\n                // If c is a left parenthesis, then append it to paren_groups\n\
    \                case '(': paren_groups = paren_groups ::: List(c)\n         \
    \       // If c is a right parenthesis, then add c to paren_groups if it isn't\
    \ already there\n                case ')': paren_groups = if (paren_groups.contains(c))\
    \ paren_groups ::: List(c) else paren_groups\n                // If c is not a\
    \ left or right parenthesis, add it to paren_groups\n                default:\
    \ paren_groups = paren_groups ::: List(c)\n            }\n        }\n\n      \
    \  // Return the resulting list of paren_groups\n        paren_groups", "    \
    \    // If input string is empty, return empty list\n        if (paren_string\
    \ == \"\")\n            return Nil\n        // If input string is only one open\
    \ paren, return empty list\n        if (paren_string.length == 1 && !(paren_string.head\
    \ == '('))\n            return Nil\n        // Create empty mutable list of strings\
    \ for result\n        var result : List[String] = Nil\n        // Add first paren\
    \ string to result list, since first paren is already in the result list\n   \
    \     result ::= paren_string.head\n        // If the first open paren is also\
    \ the first close paren, then add all the contents of the string to the result\n\
    \        // list\n        if (paren_string.head == '(') {\n            var currentPosition\
    \ = 0\n            while (currentPosition < paren_string.length) {\n         \
    \       if (paren_string.charAt(currentPosition) == '(') {\n                 \
    \   // If current position is also the first close paren, add all the contents\
    \ of the string to the result\n                    if (currentPosition == paren_string.length\
    \ - 1)\n                        result ::= paren_string.substring(currentPosition\
    \ + 2)\n                    currentPosition = currentPosition + 1\n          \
    \      } else {\n                    // If the current position is not the first\
    \ close paren, add all the contents of the string to the result\n            \
    \        result ::= paren_string.substring(currentPosition)\n                \
    \    // If the current position was the first close paren, add the current character\
    \ to the result list\n                    if (currentPosition == 0)\n        \
    \                result ::= paren_string.charAt(currentPosition)\n           \
    \         currentPosition = currentPosition + 1\n                }\n         \
    \   }\n        }\n        result", "        // Create a stack\n        val stack:\
    \ List[String] = Nil\n        // Keep track of braces we encounter\n        var\
    \ braces: Int = 0\n        for (i <- 0 until paren_string.length) {\n        \
    \    if(i == paren_string.length - 1) {\n                if (paren_string(i) ==\
    \ '(') stack += '('\n                else stack += paren_string(i)\n         \
    \       braces += 1\n            } else if (paren_string(i) == ')') {\n      \
    \          if (braces > 0) {\n                    stack += paren_string(i)\n \
    \                   braces -= 1\n                } else {\n                  \
    \  stack += paren_string(i)\n                }\n            } else if (paren_string(i)\
    \ == '(') {\n                if (braces > 0) stack += paren_string(i)\n      \
    \          else stack += '('\n                braces += 1\n            }\n   \
    \     }\n        return stack.reverse.toList", "        val inputString = paren_string.trim.replaceAll(\"\
    \\\\s\", \"\")\n        // Step 1 is to keep track of balanced parenthesis.\n\
    \        // To do this, we'll maintain a stack of open parenthesis. \n       \
    \ var parenstack = Stack[String]()\n        val outputList = new mutable.LinkedList[String]()\n\
    \        for (paren \u2190 inputString) {\n            if (paren eq \")\") {\n\
    \                // If the current paren has a balanced pair, we need to pop it\
    \ from the stack\n                if (parenstack.isEmpty)\n                  \
    \  throw new IllegalArgumentException(\"Unbalanced Parenthesis\")\n          \
    \      val nextParen = parenstack.pop()\n                // If the current paren\
    \ doesn't have a balanced pair, we add it to the stack\n                if (!nextParen\
    \ eq \"(\")\n                    parenstack.push(nextParen)\n            } else\
    \ if(paren eq \"(\") {\n                // If the current paren doesn't have a\
    \ balanced pair, we add it to the stack\n                if (!parenstack.isEmpty)\n\
    \                    throw new IllegalArgumentException(\"Unbalanced Parenthesis\"\
    )\n                parenstack.push(paren)\n            } else {\n            \
    \    // If the current paren doesn't have a balanced pair, we add it to the stack\n\
    \                if (!parenstack.isEmpty)\n                    throw new IllegalArgumentException(\"\
    Unbalanced Parenthesis\")\n                outputList.push(paren)\n          \
    \  }\n        }\n        // Step 2 is to separate each group of balanced parenthesis,\
    \ by putting each balanced parenthesis\n        // into a separate list\n    \
    \    // For each group of balanced parenthesis encountered, \n        // add all\
    \ non-parenthesis to outputList\n        // For each group of balanced parenthesis\
    \ encountered, \n        // add all non-parenthesis to the parenstack \n     \
    \   // Then recursively call this function on each of the groups encountered.\n\
    \        for (paren \u2190 outputList) {\n            // If current parenthesis\
    \ is encountered, add it to parenstack\n            if (paren eq \"(\")\n    \
    \            parenstack.push(paren)\n            // If current parenthesis is\
    \ not encountered, add it to outputList\n            else {\n                outputList.push(paren)\n\
    \            }\n        }\n        // Step 3 is to recursively call this function\
    \ to separate each group of balanced parenthesis\n        // If no group is left,\
    \ return an empty list because there are no more parenthesis to be separated\n\
    \        if (parenstack.isEmpty)\n            List()\n        else {\n       \
    \     val groups = parenstack.pop()\n            val returnValue = separateParenGroups(groups)\n\
    \            for (paren \u2190 returnValue) {\n                if (paren eq \"\
    (\")\n                    parenstack.push(paren)\n                else {\n   \
    \                 outputList.push(paren", "        var group_strs: List[String]\
    \ = Nil\n        var bracket_count = 0\n\n        val group_start = \"(\"\n  \
    \      val group_end = \")\"\n\n        var inside_brackets = false\n        paren_string.foreach\
    \ { c =>\n            if(c == group_start && !inside_brackets) {\n           \
    \     inside_brackets = true\n                group_strs = Nil\n             \
    \   bracket_count = 0\n            } else if(c == group_end && inside_brackets)\
    \ {\n                inside_brackets = false\n                group_strs = group_strs\
    \ :+ group_strs.last\n            } else if(!inside_brackets) {\n            \
    \    group_strs = group_strs :+ c\n                bracket_count += 1\n      \
    \      }\n        }\n\n        group_strs", "        var paren_groups = mutable.LinkedHashSet[String]()\n\
    \n        // Look at each character of the input string\n        // If it's a\
    \ left paren, add it to the paren_groups Set\n        // If it's a right paren,\
    \ remove it from the paren_groups Set\n        for ( char : String <- paren_string.toList)\
    \ match {\n            case _ if (char == \"(\") =>\n                paren_groups\
    \ += char\n            case _ if (char == \")\") =>\n                paren_groups\
    \ -= char\n            case _ =>\n        }\n\n        // If the paren_groups\
    \ is still empty, it means that we have nested brackets\n        // The correct\
    \ way is to have nested brackets, so remove the outer brackets\n        if (paren_groups.isEmpty)\
    \ paren_string.substring(1)\n        // Otherwise, we have no nested brackets,\
    \ just return paren_string\n        else paren_string", "        // Use stack\
    \ to solve this problem\n        // In each level of parenthesis, if an opening\
    \ brace is encountered, push it on the stack, and if a\n        // closing brace\
    \ is encountered, pop it off the stack until you reach the top level.\n      \
    \  // When you reach the top level, you have separated all nested brackets.\n\
    \        val paren_string_list = paren_string.split(\"( )\").toList\n        val\
    \ open_brace_stack = mutable.Stack[String]()\n        var output: List[String]\
    \ = Nil\n        for(paren_string <- paren_string_list) {\n            val open_brace_index\
    \ = paren_string_list.indexOf(paren_string)\n            val close_brace_index\
    \ = paren_string_list.lastIndexOf(paren_string)\n            val open_brace_count\
    \ = open_brace_index + 1\n            val close_brace_count = close_brace_index\
    \ - open_brace_index - 1\n            for(open_brace <- 0 until open_brace_count)\
    \ {\n                paren_string match {\n                    case \" \" => //\
    \ Ignore spaces in parenthesis\n                    case open_brace :: _ =>\n\
    \                        open_brace_stack push (paren_string.substring (open_brace_index,\
    \ open_brace + 1))\n                    case _ =>\n                        val\
    \ open_brace_string = paren_string substring (0, open_brace)\n               \
    \         val close_brace_string = paren_string substring (open_brace + 1, close_brace)\n\
    \                        val next_paren_string = paren_string substring (close_brace\
    \ + 1)\n                        if(open_brace_stack.isEmpty || open_brace_stack.last.contains(open_brace_string))\
    \ {\n                            output += next_paren_string\n               \
    \         } else {\n                            open_brace_stack push open_brace_string\n\
    \                            output += next_paren_string\n                   \
    \     }\n                }\n            }\n            for(close_brace <- 0 until\
    \ close_brace_count) {\n                paren_string match {\n               \
    \     case \" \" => // Ignore spaces in parenthesis\n                    case\
    \ close_brace :: _ =>\n                        close_brace_stack pop\n       \
    \             case _ =>\n                        if(close_brace_stack.isEmpty)\
    \ {\n                            output += paren_string\n                    \
    \    } else {\n                            val open_brace_string = paren_string\
    \ substring (0, close_brace)\n                            val close_brace_string\
    \ = paren_string substring (close_brace + 1, close_string)\n                 \
    \           val next_paren_string = paren_string substring (close_brace + 1)\n\
    \                            if(open_brace_stack.isEmpty) {\n                \
    \                output += ", "        var paren_group_string : List[String] =\
    \ Nil\n        var paren_group : List[String] = Nil\n        var paren_count :\
    \ Int = 0\n        var paren_open_braces : List[Char] = Nil\n        var paren_close_braces\
    \ : List[Char] = Nil\n        var paren_brace_count : Int = 0\n        var paren_closed_paren_brace_count\
    \ : Int = 0\n\n        var paren_group_open_braces : List[Char] = Nil\n      \
    \  var paren_group_brace_count : Int = 0\n\n        var paren_group_open_brace_count\
    \ : Int = 0\n        var paren_group_close_brace_count : Int = 0\n\n        paren_string.foreach\
    \ {\n            c => {\n                if (c == '(') {\n                   \
    \ paren_group_string = Nil\n                    paren_group = Nil\n          \
    \          paren_group_string ::= Nil\n                    paren_group ::= Nil\n\
    \                    paren_group_open_braces ::= Nil\n                    paren_group_open_brace_count\
    \ ::= 0\n                    paren_group_close_brace_count ::= 0\n           \
    \         paren_group_brace_count ::= 0\n                }\n                else\
    \ if (c == ')') {\n                    if (paren_group_brace_count == 0) {\n \
    \                       paren_group_string ::= paren_group\n                 \
    \       paren_group ::= Nil\n                        paren_group_open_braces ::=\
    \ paren_group_open_braces\n                        paren_group_open_brace_count\
    \ ::= paren_group_open_brace_count\n                        paren_group_close_brace_count\
    \ ::= paren_group_close_brace_count\n                    }\n                 \
    \   else {\n                        paren_group_brace_count -= 1\n           \
    \         }\n                }\n                else if (paren_group_brace_count\
    \ > 0) {\n                    if (paren_group_brace_count == 1) {\n          \
    \              paren_group_string = paren_group\n                        paren_group\
    \ ::= Nil\n                        paren_group_open_braces ::= paren_group_open_braces\n\
    \                        paren_group_open_brace_count ::= paren_group_open_brace_count\n\
    \                        paren_group_close_brace_count ::= paren_group_close_brace_count\n\
    \                    }\n                    else {\n                        paren_group_brace_count\
    \ -= 1\n                        paren_group_string ::= paren_group\n         \
    \               paren_group ::= Nil\n                        paren_group_open_braces\
    \ ::= paren_group_open_braces\n                        paren_group_open_brace_count\
    \ ::", "        val paren_groups = new mutable.ListBuffer[String]()\n        var\
    \ depth = 0\n        // Iterate through each paren group\n        for(c <- paren_string)\
    \ {\n            // If current character is a space, ignore it\n            if(c\
    \ == ' ')\n                continue\n            // If current character is a\
    \ close brace, increase depth\n            if(c == '(') {\n                depth\
    \ += 1\n            }\n            // If current character is a close brace, decrease\
    \ depth\n            if(c == ')') {\n                depth -= 1\n            \
    \    // If current depth is zero, add the current group to our list\n        \
    \        if(depth == 0)\n                    paren_groups += c\n            }\n\
    \        }\n        // Return our list\n        paren_groups.toList", "      \
    \  // This function will take a single string and return a list of the strings\
    \ separated by any nested\n        // parentheses.\n        // The nested parentheses\
    \ are returned in a list, with each string containing the nested parentheses\n\
    \        // that surround it.\n        // The function will ignore any spaces\
    \ in the input string and return the list of strings\n        // (List[String])\
    \ containing the strings separated by any nested parentheses.\n        def separateParenGroups_rec(string\
    \ : String, paren_list : List[String]) : List[String] = {\n            // The\
    \ function should return a list of strings containing any nested parentheses if\
    \ there is any\n            // surrounding parentheses.\n            // The list\
    \ is empty if there are no nested parentheses in the input string\n          \
    \  \n            if (paren_string.length == 0) {\n                return paren_list\n\
    \            } else {\n                val first_char = string.charAt(0)\n   \
    \             val next_chars = string.substring(1)\n                val next_string\
    \ = next_chars.trim\n                \n                if (first_char == \"(\"\
    ) {\n                    paren_list += string\n                    separateParenGroups_rec(next_string,\
    \ paren_list)\n                } else if (first_char == \")\") {\n           \
    \         paren_list = separateParenGroups_rec(next_string, paren_list)\n    \
    \                paren_list += string\n                } else {\n            \
    \        paren_list = separateParenGroups_rec(next_string, paren_list)\n     \
    \           }\n            }\n        }\n        \n        // The return value\
    \ will be a List[String]\n        separateParenGroups_rec(paren_string, List())",
  "        // Your code here\n        val paren_group = paren_string.split(\"\\\\\
    (\").toList\n        val paren_groups = paren_group.groupBy(p => p(0).equals(p(0).trim))\n\
    \        val result = paren_groups.map(p => (p._1, p._2.map(i => i.trim).filterNot(_\
    \ == \"\")).toList).toList\n        println(result)", "        val paren_array\
    \ = paren_string.split(\"\\\\W+\").toList\n        val open_brace_array = (paren_array.toSet)\
    \ - (paren_array.toList.map(_.contains(\"{\")).filter(_.isDefined))\n        val\
    \ closed_brace_array = (paren_array.toSet) - (paren_array.toList.map(_.contains(\"\
    }\")).filter(_.isDefined))\n        val resulting_list = List[String]()\n    \
    \    val open_brace_count = open_brace_array.size\n        val closed_brace_count\
    \ = closed_brace_array.size\n        var paren_count = 0\n        var open_brace_pos\
    \ = 0\n        var closed_brace_pos = 0\n        open_brace_array.foreach { item\
    \ =>\n            closed_brace_array.foreach { close =>\n                if (paren_count\
    \ >= open_brace_count) {\n                    open_brace_pos = paren_array.toSet.size\
    \ - closed_brace_array.size + (open_brace_count - 1)\n                }\n    \
    \            closed_brace_pos = closed_brace_array.size + paren_count + 1\n  \
    \              if (item.contains(\"{\") && item.contains(\"}\")) {\n         \
    \           if (closed_brace_array.contains(close) && paren_count < closed_brace_count)\
    \ {\n                        paren_count += 1\n                    } else {\n\
    \                        paren_pos = closed_brace_pos\n                      \
    \  resulting_list :+= paren_array.take(open_brace_pos).toString + \"(\" + paren_array.drop(paren_pos\
    \ + 1).toString + \")\"\n                        paren_count = 0\n           \
    \             open_brace_count = 0\n                        closed_brace_count\
    \ = 0\n                    }\n                } else if (item.contains(\"{\"))\
    \ {\n                    if (paren_count < closed_brace_count) {\n           \
    \             paren_count += 1\n                    } else {\n               \
    \         paren_pos = closed_brace_pos\n                        resulting_list\
    \ :+= paren_array.take(open_brace_pos).toString + \"(\" + paren_array.drop(paren_pos\
    \ + 1).toString + \")\"\n                        paren_count = 0\n           \
    \             open_brace_count = 0\n                        closed_brace_count\
    \ = 0\n                    }\n                } else if (item.contains(\"}\"))\
    \ {\n                    if (paren_count > open_brace_count) {\n             \
    \           open_brace_count += 1\n                    } else {\n            \
    \            open_brace_pos = paren_array.toSet.size - closed_brace_array.size\
    \ + (open_brace_count - 1)\n                        resulting_list :+= paren_array.take(open_brace_pos).toString\
    \ + \"(\" + paren_array.drop(paren_pos + 1).toString ", "        val regex = \"\
    \"\"\\s*\\(\\s*\\(([^\\(\\)]+)\\)\\s*\\)\\s*\"\"\".r\n        val paren_groups:\
    \ List[String] = paren_string.findAll(regex).toList\n        val result_groups:\
    \ List[String] = paren_groups.filter(group => isBalanced(group)).map(group =>\
    \ group.trim)\n        result_groups.toList", "        // We need mutable list\
    \ of paren groups here, because we will add new group when encounter a matching\n\
    \        // closing brace\n        var paren_groups = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until paren_string.length) {\n            // We will add new\
    \ group if current character is not a closing brace or opening brace\n       \
    \     if((paren_string(i) != \")\") && (paren_string(i) != \"(\")) {\n       \
    \         paren_groups += paren_string(i)\n            } else {\n            \
    \    // Encountered matching closing brace, we will add new group if this closing\
    \ brace has not been\n                // matched already, otherwise we will discard\
    \ this closing brace\n                if(paren_groups.nonEmpty) {\n          \
    \          paren_groups += \")\"\n                } else {\n                 \
    \   paren_groups += \"()\"\n                }\n            }\n        }\n    \
    \    paren_groups.toList", "        var groups: List[String] = Nil\n        for\
    \ (paren \u2190 paren_string.toList) match {\n            case \" \" \u2190 Nil\n\
    \            case \")\" \u2190 Nil\n            case _ \u2190 {\n            \
    \    var open_brace_count = paren_string indexOfFirst paren\n                val\
    \ closed_paren_count = paren_string indexOfLast paren\n                for (open_paren\
    \ \u2190 paren_string.subList(open_brace_count + 1, closed_paren_count)) \u2190\
    \ paren.toList {\n                    val open_paren_count = paren_string indexOfFirst\
    \ open_paren\n                    val close_paren_count = paren_string indexOfLast\
    \ open_paren\n                    if (open_paren_count != close_paren_count &&\
    \ open_paren_count > close_paren_count) {\n                        val open_brace_start_index\
    \ = paren_string indexOfFirst paren\n                        val open_brace_end_index\
    \ = paren_string lastIndexOf paren\n                        val open_paren_start_index\
    \ = paren_string indexOfFirst open_paren\n                        val open_paren_end_index\
    \ = paren_string lastIndexOf open_paren\n                        val close_paren_start_index\
    \ = paren_string indexOfFirst close_paren\n                        val close_paren_end_index\
    \ = paren_string lastIndexOf close_paren\n                        val open_brace_count_diff\
    \ = closed_paren_count - open_paren_count\n                        val open_paren_count_diff\
    \ = closed_paren_count - open_paren_count\n                        val close_paren_count_diff\
    \ = closed_paren_count - close_paren_count\n                        val open_brace_start_index_diff\
    \ = open_brace_end_index - open_brace_start_index\n                        val\
    \ open_paren_start_index_diff = open_paren_end_index - open_paren_start_index\n\
    \                        val close_paren_start_index_diff = close_paren_end_index\
    \ - close_paren_start_index\n                        val open_brace_end_index_diff\
    \ = open_brace_start_index - open_brace_end_index\n                        val\
    \ open_paren_end_index_diff = open_paren_start_index - open_paren_end_index\n\
    \                        val close_paren_end_index_diff = close_paren_start_index\
    \ - close_paren_end_index\n                        val open_brace_count_diff_plus_1\
    \ = open_brace_count_diff + 1\n                        val open_paren_count_diff_plus_1\
    \ = open_paren_count_diff + 1\n                        val close_paren_count_diff_plus_1\
    \ = close_paren_count_diff + 1\n                        val open_brace_start_index_diff_plus_1\
    \ = open_brace_end_index_diff + 1\n                        val open_paren_start_index_diff_plus_1\
    \ = open_paren_end_index_diff + 1\n                        val ", "        val\
    \ paren_groups = paren_string.split(\"(?<=\\\\))(?=\\\\()\")\n        var paren_group:\
    \ List[String] = Nil\n        for ((index, value) <- paren_groups.zipWithIndex)\
    \ {\n            if (index > 0) {\n                paren_group += value\n    \
    \        }\n        }\n        return paren_group", "        // Write your code\
    \ here.\n        def checkGroup(group : String) : Boolean = {\n            var\
    \ open_count = 0\n            for (c <- group) {\n                if (c == ')')\n\
    \                    open_count -= 1\n                if (c == '(')\n        \
    \            open_count += 1\n                if (open_count < 0)\n          \
    \          return false\n            }\n            return true\n        }\n \
    \       def separateGroups(group : String) : List[String] = {\n            var\
    \ groups: List[String] = Nil\n            val paren_count = paren_string.length\n\
    \            val group_length = group.length\n            if (paren_count == 0)\n\
    \                groups = group\n            else {\n                // For the\
    \ first time the open parens are encountered, the count will be greater than 0\n\
    \                // and we'll need to recur till the count is zero.\n        \
    \        var open_index = group_length\n                while (open_count > 0)\
    \ {\n                    var open_index = group_length\n                    while\
    \ (open_index > 0 && checkGroup(group.substring(open_index - 1, open_index)))\
    \ {\n                        open_index -= 1\n                    }\n        \
    \            // If there are unclosed parens, we need to recur till we reach the\
    \ end of the string.\n                    if (open_index == 0)\n             \
    \           break\n                    groups = groups ::: group.substring(0,\
    \ open_index)\n                    group = group.substring(open_index)\n     \
    \               open_index -= 1\n                    open_count -= 1\n       \
    \         }\n                groups = groups ::: group\n                groups\
    \ = separateGroups(groups)\n            }\n            return groups\n       \
    \ }\n        var groups: List[String] = Nil\n        groups = separateGroups(paren_string)\n\
    \        return groups", "        val paren_regex = \"\"\"\\((?!\\()\"\"\".r\n\
    \        paren_string match {\n            case paren_regex(_, \"\") => List(\"\
    \")\n            case paren_regex(_, s) => separate_paren_strings(s)\n       \
    \ }", "        if (paren_string == null) List(\"\")\n        else {\n        \
    \    var cur = List[String]()\n            var next = 0\n            for (i <-\
    \ 0 until paren_string.length) {\n                if (paren_string(i) == '(')\
    \ {\n                    next += 1\n                    if (paren_string(i + 1)\
    \ == '(') next += 1\n                    if (paren_string(i + 2) == '(') next\
    \ += 1\n                    if (paren_string(i + 3) == '(') next += 1\n      \
    \              if (paren_string(i + 4) == '(') next += 1\n                   \
    \ if (paren_string(i + 5) == '(') next += 1\n                    if (paren_string(i\
    \ + 6) == '(') next += 1\n                    if (paren_string(i + 7) == '(')\
    \ next += 1\n                    if (paren_string(i + 8) == '(') next += 1\n \
    \                   if (paren_string(i + 9) == '(') next += 1\n              \
    \      if (paren_string(i + 10) == '(') next += 1\n                    if (paren_string(i\
    \ + 11) == '(') next += 1\n                    if (paren_string(i + 12) == '(')\
    \ next += 1\n                    if (paren_string(i + 13) == '(') next += 1\n\
    \                    if (paren_string(i + 14) == '(') next += 1\n            \
    \        if (paren_string(i + 15) == '(') next += 1\n                    if (paren_string(i\
    \ + 16) == '(') next += 1\n                }\n                else if (paren_string(i)\
    \ == ')') {\n                    next -= 1\n                    if (next == 0)\
    \ cur = cur + (paren_string(i + 1))\n                }\n            }\n      \
    \      cur\n        }", "        val open_parens : List[String] = ListBuffer[String]()\n\
    \        val open_parens_count : Int = paren_string.count(_ == '(')\n        val\
    \ close_parens_count : Int = paren_string.count(_ == ')')\n\n        // iterate\
    \ over all parenthesis\n        for (i <- 0 until close_parens_count) {\n    \
    \        for (j <- 0 until open_parens_count) {\n                // if current\
    \ open parenthesis matches with next close parenthesis, add current open parenthesis\n\
    \                // to open_parens list\n                if (paren_string(i) ==\
    \ '(' && paren_string(i + j + 1) == paren_string(i + j)) {\n                 \
    \   open_parens ::= paren_string(i)\n                }\n                // if\
    \ current open parenthesis matches with previous close parenthesis, add current\
    \ close parenthesis\n                // to open_parens list\n                else\
    \ if (paren_string(i) == '(' && paren_string(i + j) == paren_string(i + j + 1))\
    \ {\n                    open_parens ::= paren_string(i + 1)\n               \
    \ }\n                // if current close parenthesis matches with next open parenthesis,\
    \ add current close parenthesis\n                // to open_parens list\n    \
    \            else if (paren_string(i) == ')' && paren_string(i + j + 1) == paren_string(i\
    \ + j)) {\n                    open_parens ::= paren_string(i + 1)\n         \
    \       }\n                // if current close parenthesis matches with previous\
    \ open parenthesis, add current open parenthesis\n                // to open_parens\
    \ list\n                else if (paren_string(i) == ')' && paren_string(i + j)\
    \ == paren_string(i + j + 1)) {\n                    open_parens ::= paren_string(i)\n\
    \                }\n            }\n        }\n\n        // traverse over the open_parens\
    \ list and add opening parenthesis strings to close_parens list\n        var close_parens\
    \ : List[String] = List()\n        for (i <- open_parens) {\n            close_parens\
    \ ::= i\n        }\n\n        // traverse over the close_parens list and add closing\
    \ parenthesis strings to open_parens list\n        var open_parens : List[String]\
    \ = List()\n        for (i <- close_parens) {\n            open_parens ::= i\n\
    \        }\n\n        open_parens.reverse", "        val paren_string = paren_string.trim\n\
    \        if (paren_string.isEmpty) {\n            Nil\n        }\n        else\
    \ {\n            val open_groups = mutable.ListBuffer[String]()\n            val\
    \ close_groups = mutable.ListBuffer[String]()\n            val open_parens = mutable.Map[String,\
    \ Int]()\n            paren_string.foreach(char => {\n                char match\
    \ {\n                    case \"{\" => {\n                        open_groups\
    \ += char\n                        open_parens(char) = open_parens(char).b + 1\n\
    \                    }\n                    case \"}\" => {\n                \
    \        close_groups += char\n                    }\n                    case\
    \ _ => {\n                        close_groups += char\n                    }\n\
    \                }\n            })\n            for (open_group <- open_groups)\
    \ {\n                if (open_parens(open_group) == open_parens(open_group).b)\
    \ {\n                    if (open_parens(open_group).b <= close_groups.indexOf(open_group))\
    \ {\n                        close_groups -= open_group\n                    }\n\
    \                }\n            }\n            close_groups.toList.sortWith((open_group_one,\
    \ open_group_two) =>\n                open_parens(open_group_one) < open_parens(open_group_two))\n\
    \        }", "        val paren_groups = paren_string.split(\"\\\\(|\\\\)\")\n\
    \        var current_string = \"\"\n        val result = paren_groups.filter(x\
    \ => x.trim.nonEmpty).flatMap(x => { if (x.nonEmpty) current_string + x.trim else\
    \ \"\"\n                                                                     \
    \    current_string = x \n                                                   \
    \                      Some(current_string) })\n        result.filterNot(x =>\
    \ x.equals(\"()\"))", "        val parentheses = paren_string.split(\"\")\n  \
    \      // Iterate through all the parenthesis\n        parentheses.filter(_ !=\
    \ ')').filter(_ != '{').filter(_ != '(').filter(_ != ')}').filter(_ != '}(').filter(_\
    \ != '{')", "      val paren_group_list: List[String] = ListBuffer.empty[String]\n\
    \n      // Use Stack to keep track of how many open braces are in the string\n\
    \      val stack = new Stack[String]\n      stack.push(\"(\")\n\n      // While\
    \ there are still braces left in the stack\n      while (!stack.isEmpty) {\n \
    \       val curr = stack.pop()\n\n        // Only interested in opening braces.\n\
    \        if (curr == \"(\") {\n          // If there are still open braces in\
    \ the string\n          if (paren_string.forall(c => c == \"(\")) {\n        \
    \    // We have found an opening brace. Add to our stack\n            paren_group_list.clear()\n\
    \            paren_group_list.push(curr)\n          }\n        } else {\n    \
    \      // If the stack is empty we are at a closing brace. Remove the top element\n\
    \          if (paren_string.forall(c => c == curr)) {\n            paren_group_list.append(\"\
    )\")\n          }\n        }\n      }\n\n      // Return our list of groups\n\
    \      paren_group_list.toList", "        val paren_groups: List[String] = mutable.ListBuffer.empty[String]\n\
    \        paren_string.foreach {\n            c =>\n                if (c == '(')\
    \ {\n                    paren_groups.append(\"\")\n                } else {\n\
    \                    val open_count = getOpenCount(paren_groups)\n           \
    \         if (open_count > 0) {\n                        val curr_str = paren_groups.take(open_count).mkString\n\
    \                        paren_groups.append(curr_str + c)\n                 \
    \   } else {\n                        paren_groups.append(c)\n               \
    \     }\n                }\n        }\n        paren_groups.size", "        val\
    \ parens = paren_string.stripPrefix(\"(\")\n        val nonParens = paren_string.stripSuffix(\"\
    )\")\n        val nonParensArray = nonParens.toString.split(\"\\\\)\")\n     \
    \   val parensArray = parens.toString.split(\"\\\\(\")\n        parensArray.zipWithIndex.flatMap\
    \ { case(parens, i) =>\n            if (parens.isEmpty) List()\n            else\
    \ (parens :: nonParensArray(i) :: nonParensArray.take(i+1))\n        }.toList",
  "        //Initialize result list, we will add strings to it when encountering opening\
    \ parens\n        var result : List[String] = List()\n        //Loop through characters\
    \ in string\n        for (i <- 0 to paren_string.length - 1) {\n            //Check\
    \ if the current character is a '('\n            if (paren_string(i) == '(') {\n\
    \                //If it is, add it to the result list\n                result\
    \ ::= paren_string(i)\n                //Now check if that next character is ')'\n\
    \                //If it is, add it to the result list\n                if (paren_string(i\
    \ + 1) == ')') {\n                    result ::= paren_string(i)\n           \
    \         //Finally, check if that next character is ')'\n                   \
    \ //If it is, add it to the result list\n                    if (paren_string(i\
    \ + 2) == ')') {\n                        result ::= paren_string(i)\n       \
    \             }\n                }\n            }\n        }\n        result",
  "        val paren_string_list = paren_string.trim().replaceAll(\" \", \"\").split(\"\
    ,\")\n        val paren_stack = new mutable.Stack[String]()\n        val paren_groups\
    \ = new mutable.ArrayBuffer[String]()\n        for(i <- 0 until paren_string_list.length)\
    \ {\n            val current_string = (paren_stack.lastOption match {\n      \
    \          case None => paren_string_list(i)\n                case Some(current_string)\
    \ => current_string + paren_string_list(i)\n            })\n            paren_stack\
    \ += current_string\n            if(current_string.matches(\"\\\\)\")) {\n   \
    \             val closed_string = current_string.substring(0,current_string.length-1)\n\
    \                if(closed_string != \"\" && paren_stack.lastOption.exists(closed_string.matches(\"\
    \\\\(\"))) {\n                    paren_groups += closed_string\n            \
    \    } else {\n                    paren_groups += current_string\n          \
    \      }\n                paren_stack.pop\n            }\n        }\n        paren_groups.toList",
  "        val paren_groups = paren_string.split(\"\\\\(|\\\\)\").toList\n       \
    \ val strings_stack = Stack[String]()\n        val strings = mutable.ListBuffer[String]()\n\
    \        var strings_to_add = paren_groups.reverse.foldLeft(mutable.Stack[String]())((string_stack,\
    \ paren_group) => {\n            if (paren_group.length <= 0) {\n            \
    \    strings_stack push string\n                string\n            } else if\
    \ (\"\\\\(\" == paren_group) {\n                strings_stack push paren_group\n\
    \            } else if (\"\\\\)\" == paren_group) {\n                strings_stack\
    \ push string\n                strings_stack push paren_group\n            } else\
    \ {\n                strings_stack push string\n                string\n     \
    \       }\n        })\n        while (!strings_to_add.isEmpty) {\n           \
    \ strings push strings_to_add take strings_to_add length\n        }\n        strings.reverse",
  "        def closeParen(group_str : String) : Boolean = {\n            val closeParen_index\
    \ = paren_string.indexOf(group_str)\n            group_str.contains(\" \") &&\
    \ closeParen_index == -1\n        }\n\n        val group_strs = paren_string.split(\"\
    \\\\()\")\n        val group_sizes = group_strs.map(paren_string => paren_string.length)\n\
    \n        val open_counts = group_sizes.scanLeft(0)(_ + 1).filter(_ > 0)\n   \
    \     val group_to_close = open_counts.scanLeft(0)(_ + 1)\n\n        val closing\
    \ = group_sizes.zip(group_to_close)\n        val opening = open_counts.zip(group_to_close)\n\
    \n        val final_closing = closing.filter(_._2 > 0)\n        val final_opening\
    \ = opening.filter(_._2 > 0)\n\n        val closed = final_closing.filter(_._2\
    \ > 0)\n        val opening = final_opening.filter(_._2 > 0)\n\n        closed.map(str\
    \ => paren_string.split(str._1).head).distinct", "        var list_of_strings\
    \ = List[String]()\n        var current_string = \"\"\n        var open_braces\
    \ : Int = paren_string.count('(')\n        var close_braces : Int = paren_string.count(')')\n\
    \        var current_string = \"\"\n        var new_string_list : List[String]\
    \ = List[String]()\n\n        for (i <- 0 until paren_string.length){\n      \
    \      // If the character is an open bracket\n            if (paren_string(i)\
    \ == '('){\n                // If the current string is empty, add it to the list\
    \ of strings\n                if (current_string.isEmpty){\n                 \
    \   current_string += \"(\"\n                }\n                // Otherwise,\
    \ add it to the list of strings if the previous string has just one element\n\
    \                else {\n                    if (new_string_list.length == 0){\n\
    \                        list_of_strings ::= current_string\n                \
    \    }\n                    else {\n                        list_of_strings ::=\
    \ current_string\n                    }\n                    new_string_list ::=\
    \ \"\"\n                    current_string = \"\"\n                }\n       \
    \     }\n            \n            // If the character is a closing bracket\n\
    \            if (paren_string(i) == ')'){\n                // If the current string\
    \ is empty, add it to the list of strings\n                if (current_string.isEmpty){\n\
    \                    current_string += \")\"\n                }\n            \
    \    // Otherwise, add it to the list of strings if the previous string has just\
    \ one element\n                else {\n                    if (new_string_list.length\
    \ == 0){\n                        list_of_strings ::= current_string\n       \
    \             }\n                    else {\n                        list_of_strings\
    \ ::= current_string\n                    }\n                    new_string_list\
    \ ::= \"\"\n                    current_string = \"\"\n                }\n   \
    \         }\n            \n            // If the character is a space\n      \
    \      if (paren_string(i) == ' '){\n                // If the current string\
    \ is empty, add it to the list of strings\n                if (current_string.isEmpty){\n\
    \                    current_string += \" \"\n                }\n            \
    \    // Otherwise, add it to the list of strings if the previous string has just\
    \ one element\n                else {\n                    if (new_string_list.length\
    \ == 0){\n                        list_of_strings ::= current_string\n       \
    \             }\n                    else {\n                        list_of_strings\
    \ ::= current_string\n                    }\n                    new_string_list\
    \ ::= \"\"\n                    current_string = \"\"\n                }\n   \
    \         }\n        }\n\n        // If an open brace is left over, add it to\
    \ the list of strings\n        if (new_string_list.length > 0){\n            if\
    \ (new_string_list.length == 1){\n                list_of_strings ::= new_string_list\n\
    \            }\n            else {\n                list_of_strings ::= new_string_list\n\
    \            }\n        }\n\n        // If there are still open braces left over,\
    \ add those to the list of strings\n        if (open_braces > close_braces){\n\
    \            for (i <- 0 until open_braces - close_braces){\n                list_of_strings\
    \ ::= \"\"\n            }\n        }\n\n        // If the parenthesis groups are\
    \ balanced, remove ", "        val open_braces = mutable.ListBuffer.empty[String]\n\
    \        val closed_braces = mutable.ListBuffer.empty[String]\n\n        val stack\
    \ = mutable.Stack[String]()\n\n        for (c <- paren_string) {\n           \
    \ if (c == '(') {\n                stack += '('\n                open_braces +=\
    \ c\n            } else if (c == '[') {\n                stack += '['\n      \
    \      } else if (c == '{') {\n                stack += '{'\n            } else\
    \ if (c == '[' || c == '{') {\n                stack += c\n            } else\
    \ if (c == '(') {\n                if (stack.isEmpty)\n                    throw\
    \ new Exception(\"Mismatched brackets\")\n                else {\n           \
    \         val top = stack.pop()\n                    if (top == '(')\n       \
    \                 closed_braces += top\n                    else if (top == '{')\n\
    \                        closed_braces += top\n                    else if (top\
    \ == '[')\n                        closed_braces += top\n                    else\
    \ if (top == ')')\n                        open_braces += top\n              \
    \  }\n            }\n        }\n\n        // Check to make sure that the stack\
    \ only contains parens\n        if (!stack.isEmpty && !stack.head == ')')\n  \
    \          throw new Exception(\"Mismatched brackets\")\n\n        stack.foreach\
    \ { _ => }\n\n        // Make sure that every brace has been closed\n        if\
    \ (closed_braces.nonEmpty)\n            throw new Exception(\"Mismatched closing\
    \ braces\")\n\n        open_braces.toList", "        def separateGroups(paren_string:\
    \ String) : List[String] = {\n            def getOpenParens() : List[String] =\
    \ paren_string.trim().split(\"\\\\(\").toList\n            def closeParens = getOpenParens().map(s\
    \ => { if (s.endsWith(\")\")) s + \"}\" else s + \"}\" })\n            def closeParensGroups:\
    \ List[String] = closeParens.map(s => { if (s.endsWith(\"(\")) s + \"(\" else\
    \ s + \"(\") })\n            def isBalanced(str: List[String]) : Boolean = str.map(b\
    \ => { if (b.endsWith(\")\")) true else false }).sum == 1\n            def getRemainingParantheses(str:\
    \ List[String]) : List[String] = str.filterNot( s => { if (s.endsWith(\")\"))\
    \ true else false }).reverse\n            def getRemainingGroups(str: List[String])\
    \ : List[String] = getRemainingParantheses(getOpenParens()).reverse.map(s => {\
    \ if (s.endsWith(\")\")) s + \"(\" else s + \"(\" })\n\n            val remainingParantheses\
    \ = getRemainingParantheses(getOpenParens())\n            val remainingGroups\
    \ = getRemainingGroups(remainingParantheses)\n            val remainingGroupsList\
    \ = remainingGroups.map(s => \"(\" + s + \")\").filter(s => s.endsWith(\")\")).reverse\n\
    \            val remainingParanthesesList = remainingParantheses.map(s => \"(\"\
    \ + s + \")\").filter(s => s.endsWith(\")\")).reverse\n            val openGroups\
    \ = getOpenParens().map(s => { if (s.endsWith(\")\")) s + \"(\" else s + \"(\"\
    \ })\n            val openGroupsList = openGroups.map(s => \"(\" + s + \")\").filter(s\
    \ => s.endsWith(\")\")).reverse\n            val remainingParanthesesList: List[String]\
    \ = remainingParantheses.filter(s => s.endsWith(\")\")).reverse\n            if\
    \ (remainingGroupsList.size == remainingParanthesesList.size) {\n            \
    \    remainingGroupsList\n            } else if (remainingGroupsList.size == (openGroupsList.size\
    \ + remainingParanthesesList.size)) {\n                remainingGroupsList.zip(openGroupsList).filter(_._1.endsWith(\"\
    )\")).map(_._1).reverse\n            } else if (remainingGroupsList.size == remainingParanthesesList.size\
    \ + 1) {\n                remainingGroupsList.zip(remainingParantheses).filter(_._1.endsWith(\"\
    )\")).map(_._1).reverse\n            } else {\n                println(\"Group\
    \ count mismatch with parantheses count\")", "        var cur_string = \"\"\n\
    \        var group_stack : Stack[String] = new Stack[String]()\n        var group_list\
    \ : List[String] = Nil\n        var cur_group_str = \"\"\n\n        for(c <- paren_string)\n\
    \        {\n            cur_group_str += c\n            if(c == '(')\n       \
    \     {\n                group_stack.push(cur_group_str)\n                cur_group_str\
    \ = \"\"\n            }\n            else if(c == ')')\n            {\n      \
    \          cur_group_str = group_stack.pop()\n                group_list ::= cur_group_str\n\
    \            }\n        }\n\n        cur_group_str", "        val paren_groups\
    \ = paren_string.split(\"\\\\(|\\\\)\").filter(x => x.trim().length > 0)\n   \
    \     val open_parens = paren_groups.map(x => x.count(\"\\\\(\") + x.count(\"\\\
    \\)\")).toArray\n        val closed_parens = paren_groups.map(x => x.count(\"\\\
    \\)\") - x.count(\"\\\\(\")).toArray\n        val final_parens = open_parens.zip(closed_parens).toList.map(x\
    \ => (x._1, x._2))\n        final_parens.toList.flatten.filter(x => !x._1.contains(\"\
    (\") && !x._1.contains(\")\")).map(x => x._2)", "        var parentheses = mutable.Set[Char]()\n\
    \        var paren_groups = mutable.Set[String]()\n        paren_string.foreach(c\
    \ => {\n            if (c == '(' || c == '[' || c == '{') {\n                parentheses\
    \ += c\n            } else if (c == '}') {\n                if (parentheses.size\
    \ == 0) {\n                    throw new Exception(\"Unexpected closing brace:\
    \ \" + c)\n                }\n                paren_groups += parenthesis.head\
    \ + c\n                parentheses.clear\n            } else if (c == ')' && parentheses.nonEmpty)\
    \ {\n                if (parentheses.size == 0) {\n                    throw new\
    \ Exception(\"Unexpected closing parenthesis: \" + c)\n                }\n   \
    \             paren_groups += parenthesis.head + c\n                parentheses.clear\n\
    \            } else {\n                parentheses.clear\n            }\n    \
    \    })\n        paren_groups.toList", "        // This list will hold all the\
    \ separate groups of parentheses\n        var groups: List[String] = Nil\n   \
    \     // This list will hold all the unpaired opening brackets\n        var unpaired_groups:\
    \ List[String] = Nil\n        // This counter will help us know when a closing\
    \ bracket is found\n        var brace_count = 0\n        // Loop through every\
    \ character in the string\n        for(c <- paren_string) {\n            // Ignore\
    \ space\n            if(c == ' ') continue\n            // If the current character\
    \ is a left parenthesis\n            if(c == '(') {\n                // If there\
    \ are unpaired groups of parenthesis\n                if(unpaired_groups.length\
    \ > 0) {\n                    // If all unpaired groups are closed right after\
    \ a left parenthesis\n                    if(brace_count == unpaired_groups.length)\
    \ {\n                        // Add the unpaired groups to the groups list\n \
    \                       groups = unpaired_groups.::groups\n                  \
    \      // Empty the unpaired groups as we found the closing right parenthesis\n\
    \                        unpaired_groups = Nil\n                    }\n      \
    \              // Else, add all the unpaired groups to the unpaired groups list\n\
    \                    else unpaired_groups = unpaired_groups.::groups\n       \
    \         }\n                // Else, add that left parenthesis to the unpaired\
    \ groups list\n                unpaired_groups = Nil\n                // Increment\
    \ the brace count\n                brace_count += 1\n            }\n         \
    \   // Else, check if it is an opening bracket\n            else if(c == '[')\
    \ {\n                // If there are unpaired groups of brackets\n           \
    \     if(unpaired_groups.length > 0) {\n                    // If all unpaired\
    \ groups are closed right before a left bracket\n                    if(brace_count\
    \ == unpaired_groups.length) {\n                        // Add the unpaired groups\
    \ to the groups list\n                        groups = unpaired_groups.::groups\n\
    \                        // Empty the unpaired groups as we found the closing\
    \ right bracket\n                        unpaired_groups = Nil\n             \
    \       }\n                    // Else, add all the unpaired groups to the unpaired\
    \ groups list\n                    else unpaired_groups = unpaired_groups.::groups\n\
    \                }\n                // Else, add that left bracket to the unpaired\
    \ groups list\n                unpaired_groups = Nil\n                // Increment\
    \ the brace count\n                brace_count += 1\n            }\n         \
    \   // Else, add the character to the groups list\n            groups = groups.::c\n\
    \        }\n        // Add the unpaired groups to the groups list\n        groups\
    \ = groups.::unpaired_groups\n        // Return all the groups\n        return\
    \ groups", "        var paren_groups = ListBuffer[String]()\n        var in_paren_group\
    \ : Boolean = false\n        var open_paren = 0\n        paren_string.foreach{\
    \ c =>\n            if(in_paren_group) paren_groups += c\n            if(c ==\
    \ ')' && !in_paren_group) {\n                open_paren -= 1\n               \
    \ in_paren_group = false\n            } else if(c == '(' && !in_paren_group) {\n\
    \                open_paren += 1\n                in_paren_group = true\n    \
    \        } else if(open_paren > 0 && c == '(') {\n                open_paren -=\
    \ 1\n            }\n        }\n        paren_groups.toList", "      val paren_groups\
    \ = paren_string.chars.toList\n      val pairs = paren_groups .grouped(2)\n  \
    \      .filter(group => group.head == paren_groups.head) &&\n          group.tail.zipWithIndex.flatMap(_\
    \ => {\n            val group_index = group.tail.indexWhere(_ == pair.head) +\
    \ 1\n            val group_size = (group.length - group_index) // -1 for head\
    \ index\n            val is_pair = (pair.tail.head == paren_groups.tail(group_size))\
    \ &&\n              (pair.tail.tail.size == paren_groups.size - group_size)\n\
    \            val is_paired = pair.tail.head == pair.head &&\n              (pair.tail.tail.size\
    \ == (paren_groups.length - 1))\n            val is_open = pair.tail.head == pair.head\
    \ &&\n              (pair.tail.tail.size == 1)\n            if (is_pair && is_paired\
    \ && is_open)\n              (group_index, group_size)\n            else\n   \
    \           Nil\n          }).toList\n      paren_groups.flatMap(group => pairs.find(pair\
    \ => pair.indexOf { x =>\n        pair._1 == group.size\n      }).map(pair =>\
    \ group.substring(pair._1, pair._2))).distinct", "        // Use a regex to match\
    \ groups of nested parentheses\n        val nestedParens = \"\"\"[(]([^)]*[)]*)\"\
    \"\".r\n\n        // Create a mutable buffer of results to return\n        var\
    \ results: List[String] = Nil\n\n        // Iterate through the string character-by-character,\
    \ updating the mutable buffer as the string changes.\n        // When a closing\
    \ paren is found, add it to the list of results and clear the buffer\n       \
    \ val group = new mutable.StringBuilder\n        for (ch <- paren_string.toCharArray)\
    \ {\n            group append ch\n            if (ch == '(') {\n             \
    \   group append ch\n            } else if (ch == '[') {\n                group\
    \ append ch\n            } else if (ch == '{') {\n                group append\
    \ ch\n            } else if (ch == ')') {\n                results = results :+\
    \ group.toString\n                group.clear()\n            } else {\n      \
    \          // If anything else is found, just add the ch to the buffer and clear\
    \ it\n                group append ch\n                group.clear()\n       \
    \     }\n        }\n        // Finally, add the final part of the buffer (if it\
    \ exists)\n        results = results :+ group.toString\n\n        // Return the\
    \ list of results\n        results", '        paren_string.split("((\\(|\\s))+").filter(x
    => x.startsWith("(") && x.endsWith(")")).map(x => x.substring(1,x.length-1)).filter(x
    => !x.startsWith("(") && !x.endsWith(")")).toList', "        var parens : List[String]\
    \ = Nil\n        var open_braces : List[String] = Nil\n        var closed_braces\
    \ : List[String] = Nil\n        var in_parens : List[String] = Nil\n        var\
    \ output : List[String] = Nil\n        paren_string.foreach {\n            case\
    \ c if c == '(' => open_braces = open_braces :+ c\n            case c if c ==\
    \ '{' => closed_braces = closed_braces :+ c\n            case c if c == '}' =>\
    \ if (closed_braces.isEmpty) in_parens = in_parens :+ c\n                    \
    \              else parens = parens :+ c\n            case c if in_parens.isEmpty\
    \  => parens = parens :+ c\n            case c if in_parens.contains(c) => in_parens\
    \ = in_parens :+ c\n            case c if parens.isEmpty  => in_parens = in_parens\
    \ :+ c\n            case c if parens.contains(c) => parens = parens :+ c\n   \
    \         case c if open_braces.isEmpty  => in_parens = in_parens :+ c\n     \
    \       case c if open_braces.contains(c) => open_braces = open_braces :+ c\n\
    \            case c if closed_braces.isEmpty  => in_parens = in_parens :+ c\n\
    \            case c if closed_braces.contains(c) => closed_braces = closed_braces\
    \ :+ c\n            case c if c == ')' && open_braces.isEmpty  => in_parens =\
    \ in_parens :+ c\n            case c if c == ')' && open_braces.contains(c) =>\
    \ open_braces = open_braces :+ c\n            case c if c == '}' && closed_braces.isEmpty\
    \  => in_parens = in_parens :+ c\n            case c if c == '}' && closed_braces.contains(c)\
    \ => closed_braces = closed_braces :+ c\n            case c => output = output\
    \ :+ c\n        }\n        parens", "        // Create a list of characters in\
    \ the input string\n        val input_string  = paren_string.filterNot(_.isWhitespace).toList\n\
    \        // Create a list of stacked paren characters (i.e. ()())\n        val\
    \ paren_list   = mutable.Stack[Char]()\n        // Create a list for the final\
    \ result (a stacked list of the above stacked paren characters)\n        val result_list\
    \ = mutable.Stack[String]()\n        // Create an empty list to hold the results\
    \ of any recursion call\n        var result_stack: List[String] = Nil\n      \
    \  // The actual recursion function. Takes a single character from the input string,\
    \ checks it for\n        // a valid paren character, and pushes that character\
    \ onto the appropriate stack\n        def recurse(character : Char) : Unit = {\n\
    \            val open_paren = if (paren_list.nonEmpty) paren_list.head else character\n\
    \            val close_paren = if (paren_list.nonEmpty) paren_list.head else character\n\
    \            if (open_paren == '(' && close_paren == ')') paren_list.push(')')\n\
    \            else paren_list.push(open_paren)\n        }\n        // Iterate over\
    \ the characters in the input string\n        for (ii <- input_string.indices)\
    \ {\n            val current_character = input_string(ii)\n            recurse(current_character)\n\
    \            result_list += current_character\n            if (paren_list.nonEmpty)\
    \ {\n                val stacked_paren = paren_list.mkString\n               \
    \ if (stacked_paren.length == 1) {\n                    result_stack += stacked_paren\n\
    \                } else {\n                    result_stack += (paren_list.mkString)\n\
    \                }\n                paren_list.clear()\n            }\n      \
    \  }\n        result_stack", "        val groups: List[String] = ListBuffer[String]()\n\
    \n        for (c <- paren_string.dropRight(1)) {\n            val char = c\n \
    \           val isGroup = char == \")\"\n            if (isGroup) {\n        \
    \        groups += c\n            } else {\n                groups.reverse.toList\
    \ match {\n                    case head :: tail => if (tail.length == 0) List(head)\
    \ else head :: tail\n                    case Nil => List(head)\n            \
    \    }\n            }\n        }\n        groups.reverse.toList", "        //\
    \ TODO: Your code goes here\n        val paren_str = paren_string.trim\n     \
    \   val groups = new mutable.Stack[String]\n        var curr = new mutable.Stack[String]\n\
    \        for(i <- 0 until paren_str.length) {\n            if(paren_str(i) ==\
    \ '(') groups.push('(')\n            else if(paren_str(i) == ')') {\n        \
    \        curr.toList.reverse.foreach(x => {\n                    groups.push(curr.toList.toList)\n\
    \                    groups.toList.reverse.foreach { y => \n                 \
    \       if(y == '(') groups.remove(x)\n                        if(y == ')') {\n\
    \                            groups.remove(x)\n                            if(groups.size\
    \ == 0) groups.push(')')\n                        }\n                    }\n \
    \               })\n            }\n            else {\n                curr.push(paren_str(i))\n\
    \            }\n        }\n        val output = groups.toList.reverse.foreach(x\
    \ => if(x.toString.length == 1 || x.toString.length == 2) x else x + \"+\")\n\
    \        output", "        val ps = paren_string.split(\"\\\\s+\")\n        var\
    \ ret_string = List[String]()\n        var level = 0\n        ps.foreach( x =>\
    \ {\n            if(x.equals(\"(\")) {\n                level += 1\n         \
    \   }\n            if(x.equals(\")\")) {\n                level -= 1\n       \
    \     }\n            if(level == 0) {\n                ret_string ::= x\n    \
    \        }\n        })\n        ret_string", "        if(paren_string.length ==\
    \ 0) return Nil\n        if(paren_string.indexOf(\"(\") != -1 && paren_string.indexOf(\"\
    )\") != -1) return List(paren_string)\n        val open_parens = mutable.HashSet[Char]()\n\
    \        var new_paren_string = paren_string\n        for(i <- 0 until new_paren_string.length)\
    \ {\n            val c = new_paren_string(i)\n            if(!open_parens.contains(c))\
    \ {\n                if(!(c == '(' && open_parens.contains('('))) open_parens\
    \ += c\n                new_paren_string = new_paren_string.substring(0, i) +\
    \ \")\" + new_paren_string.substring(i + 1)\n            }\n        }\n      \
    \  val close_parens = mutable.HashSet[Char]()\n        open_parens.foreach { c\
    \ =>\n            if(!close_parens.contains(c)) {\n                if(!(c == ')'\
    \ && close_parens.contains('('))) close_parens += c\n            }\n        }\n\
    \        close_parens.foreach { c =>\n            if(!new_paren_string.contains(c))\
    \ {\n                new_paren_string = new_paren_string.substring(0, new_paren_string.length\
    \ - 1) + \"(\" + new_paren_string.substring(new_paren_string.length - 1)\n   \
    \         }\n        }\n        close_parens.reverse.map(c => new_paren_string.substring(0,\
    \ new_paren_string.length - 1) + \"(\" + new_paren_string.substring(new_paren_string.length\
    \ - 1)\n                + \")\" + c).distinct", "        val paren_groups: List[String]\
    \ = new mutable.MutableList[String]()\n        var open_braces : Int = 0\n\n \
    \       // Iterate over string\n        for (i <- 0 until paren_string.length)\
    \ {\n            // If character is (\n            if (paren_string(i) == '(')\
    \ {\n                // Add open brace and increment the count of open braces\n\
    \                paren_groups.add(paren_string(i))\n                open_braces\
    \ += 1\n            }\n            // Else if character is )\n            else\
    \ if (paren_string(i) == ')') {\n                // Remove 1 from the count of\
    \ open braces\n                open_braces -= 1\n            }\n            //\
    \ If open brace count is 0\n            if (open_braces == 0) {\n            \
    \    // Add element to the list\n                paren_groups.add(paren_string(i))\n\
    \            }\n        }\n\n        // Return the list of strings\n        return\
    \ paren_groups", "        val paren_groups = mutable.ArrayBuffer.empty[String]\n\
    \        paren_string.split(\"\"\"\\s+\"\"\").foreach { paren_string =>\n    \
    \        if(paren_string.length > 1) {\n                paren_groups += paren_string.slice(1,\
    \ paren_string.length - 1)\n            } else {\n                paren_groups\
    \ += paren_string\n            }\n        }\n        paren_groups.toList", " \
    \       paren_string.trim\n            .split(\"\\\\s+\".r) //split on whitespace\n\
    \            .map(s => if (s.startsWith(\"(\")) s.drop(1) else s) //drop the paren\
    \ char at the beginning of the string if it exists\n            .filter(!paren_string.startsWith(\"\
    (\")) //filter out all paren strings starting with paren\n            .filter(!paren_string.endsWith(\"\
    )\")) //filter out all paren strings ending with paren\n            .filter(!paren_string.contains(\"\
    (\") || !paren_string.contains(\")\"))  //filter out nested paren strings\n  \
    \          .distinct", "        val paren_array = new mutable.ArrayBuilder[String]\n\
    \        def paren_collector(paren_string : String) : Unit = {\n            paren_array\
    \ += paren_string\n        }\n        def brace_collector(paren_string : String)\
    \ : Unit = {\n            if(paren_string.startsWith(\"{\")) paren_collector(paren_string)\n\
    \            else if(!paren_string.startsWith(\"}\"))\n                paren_collector(paren_string)\n\
    \            else\n                brace_collector(paren_string.substring(0,paren_string.length-1))\n\
    \        }\n        for(i <- 0 until paren_string.length) {\n            if(paren_string(i)\
    \ == \")\") brace_collector(paren_string(i+1))\n        }\n        paren_array.toList",
  "        // Step 1: Build a stack that stores the position of every open brace encountered\n\
    \        val stack = mutable.Stack.empty[Int]\n        // Step 2: Push the start\
    \ index of the parentheses, this will be the top of the stack\n        paren_string.indexOf('(')\n\
    \        paren_string.indexOf(')') match {\n            case -1 => paren_string\n\
    \            case index => paren_string.substring(0, index) + paren_string.substring(index\
    \ + 1)\n        }\n        // Step 3: Push the length of every opened brace\n\
    \        paren_string.indexOf('(') match {\n            case -1 => paren_string\n\
    \            case index => paren_string.length\n        }\n        // Step 4:\
    \ Push zero to indicate a closed brace\n        paren_string.indexOf('(') match\
    \ {\n            case -1 => paren_string\n            case index => paren_string.length\n\
    \        }\n        // Step 5: Keep going while there are unmatched opening braces\n\
    \        while(!stack.isEmpty) {\n            // Step 6: Pop the length of the\
    \ previously open brace\n            val length = stack.pop()\n            //\
    \ Step 7: Pop out the last opened brace\n            val lastOpenedBrace = paren_string.length\
    \ - length\n            // Step 8: Remove that last opened brace\n           \
    \ paren_string = paren_string.substring(0, lastOpenedBrace) + paren_string.substring(lastOpenedBrace\
    \ + 1)\n            // Step 9: Push the length of the new opened brace\n     \
    \       paren_string.indexOf('(') match {\n                case -1 => paren_string\n\
    \                case index => paren_string.length\n            }\n        }\n\
    \        // Step 10: If the parentheses are not balanced, return an empty list\n\
    \        if(paren_string.length != paren_string.indexOf('(')) {\n            return\
    \ Nil\n        } else {\n            // Step 11: Return any extra parentheses\n\
    \            paren_string.indexOf('(')\n        }", "        if (paren_string\
    \ == \"\") List(\"\")\n        else paren_string.groupBy(x => x).mapValues(_.map(_._1).mkString).toList",
  "        val paren_paren_groups = mutable.ListBuffer[String]()\n        paren_string.split(\"\
    \\\\s+\".r).foreach {\n            group => {\n                // If open paren\
    \ is encountered and it is already in the list, add it to the list\n         \
    \       if (group === \"(\") {\n                    paren_paren_groups synchronized\
    \ { paren_paren_groups += group }\n                }\n                // If closing\
    \ paren is encountered and it is already in the list, remove it from the list\n\
    \                else if (group === \")\") {\n                    val current_paren_group\
    \ = paren_paren_groups.takeWhile(_ != \"(\")\n                    paren_paren_groups\
    \ synchronized { paren_paren_groups -= current_paren_group }\n               \
    \ }\n                // If open paren is encountered and it is NOT already in\
    \ the list, add it to the list\n                else if (group === \"(\") {\n\
    \                    paren_paren_groups synchronized { paren_paren_groups += group\
    \ }\n                }\n                // If closing paren is encountered and\
    \ it is NOT already in the list, add it to the list\n                else if (group\
    \ === \")\") {\n                    val current_paren_group = paren_paren_groups.takeWhile(_\
    \ != \"(\")\n                    paren_paren_groups synchronized { paren_paren_groups\
    \ += current_paren_group + \"(\" + group + \")\" }\n                }\n      \
    \      }\n        }\n        paren_paren_groups.toList", "      val paren_splits\
    \ = paren_string.split(\"\\(\")\n      val groups = paren_splits.flatMap(_.split(\"\
    \\)\")).groupBy(x => if (x.trim().isEmpty) \"\" else x.trim())\n      groups.map(_._2).map(_.replaceAll(\"\
    \\(.*\\)\",\"\")).distinct", "        // Initialize the list of empty strings\n\
    \        var listOfParens = List[String]()\n\n        // Iterate over the input\
    \ string and check for matching open/close paren brackets\n        var open_brace_counter\
    \ = 0\n        paren_string.foreach { c =>\n            if (c == \" \") {\n  \
    \              // A space is encountered. Ignore it.\n            } else if (c\
    \ == \"(\") {\n                // Found a new parenthesis. Increase its counter.\n\
    \                open_brace_counter += 1\n            } else if (c == \"[\") {\n\
    \                // Found a bracket (a square bracket). Decrease its counter.\n\
    \                open_brace_counter -= 1\n            } else if (c == \")\") {\n\
    \                // Found a closing parenthesis. Check if the counter is still\
    \ positive. If not, it means\n                // that there are no more open/close\
    \ parenthesis.\n                if (open_brace_counter < 0) {\n              \
    \      // Close the parenthesis without increasing the counter since they are\
    \ balanced\n                    listOfParens = listOfParens.filterNot(c => c ==\
    \ \")\")\n                } else {\n                    // Increase the counter\n\
    \                    open_brace_counter += 1\n                }\n            }\
    \ else if (c == \"]\") {\n                // Found a closing square bracket. Check\
    \ if the counter is still positive. If not, it means\n                // that\
    \ there are no more open/close parenthesis.\n                if (open_brace_counter\
    \ < 0) {\n                    // Close the parenthesis without increasing the\
    \ counter since they are balanced\n                    listOfParens = listOfParens.filterNot(c\
    \ => c == \"]\")\n                } else {\n                    // Decrease the\
    \ counter\n                    open_brace_counter -= 1\n                }\n  \
    \          } else {\n                // A character other than space, open/close\
    \ parenthesis or a bracket is encountered. Ignore\n                // it.\n  \
    \          }\n        }\n        return listOfParens", "        paren_string.split(\"\
    \ +\").filterNot( _.isEmpty).map {\n          string => string.substring(1, string.length-1)\n\
    \        }", "        val parenGroups: List[String] = new mutable.ListBuffer[String]()\n\
    \        def separateGroup(parenGroup: List[String], curString : String, currentIndex\
    \ : Int, totalIndex : Int) : String = {\n            if (totalIndex == currentIndex\
    \ || parenGroup.isEmpty) curString\n            else if (parenGroups(currentIndex).equals(\"\
    ()\") || parenGroups(currentIndex).equals(\"()()\")) \"\"\n            else parenGroups(currentIndex)\
    \ + curString\n        }\n\n        def separateParenGroup(parenGroup: List[String],\
    \ curString : String, currentIndex : Int) : Unit = {\n            val totalIndex\
    \ = parenGroup.length\n            if (totalIndex > currentIndex) {\n        \
    \        val nextParenIndex = parenGroups(currentIndex + 1).equals(\"()\")\n \
    \               if (nextParenIndex) {\n                    parenGroups += separateGroup(parenGroup,\
    \ \"\", currentIndex + 1, totalIndex)\n                    separateParenGroup(parenGroup,\
    \ \"\", currentIndex + 1)\n                }\n                else {\n       \
    \             parenGroups += separateGroup(parenGroup, curString, currentIndex,\
    \ totalIndex)\n                }\n            }\n        }\n\n        var currentIndex\
    \ = 0\n        for (currentChar <- paren_string) {\n            if (currentChar\
    \ == '(') {\n                parenGroups += \"\"\n                separateParenGroup(parenGroups,\
    \ \"\", currentIndex)\n            }\n            else if (currentChar == ')')\
    \ {\n                if (parenGroups(currentIndex).equals(\"()\") || parenGroups(currentIndex).equals(\"\
    ()()\")) separateParenGroups(parenGroups.toList.toString)\n                else\
    \ separateParenGroups(parenGroups.toList.toString + parenGroups(currentIndex))\n\
    \            }\n            else {\n                parenGroups += currentChar\n\
    \            }\n            currentIndex += 1\n        }\n        separateParenGroups(parenGroups.toList.toString)",
  "        def separate_paren_groups(paren_strings: List[String]) : List[String] =\
    \ {\n            // If the input string is empty\n            if (paren_strings.isEmpty)\
    \ {\n                return Nil\n            }\n            // If the input string\
    \ consists of one string (not nested)\n            if (paren_strings.size == 1)\
    \ {\n                return Nil\n            }\n            // If the input string\
    \ consists of multiple strings (nested)\n            if (paren_strings.size >\
    \ 1) {\n                // Create a list of strings from every group\n       \
    \         val list_of_group_strings = paren_strings.map( s => s.substring(1, s.length-2))\n\
    \                // Separate every group into list of strings\n              \
    \  val list_of_separated_group_strings = list_of_group_strings.flatMap(separate_paren_groups)\n\
    \                // Combine every group into one string\n                val final_string\
    \ = list_of_separated_group_strings.reduceLeft(_ + \"(\" + _ + \")\")\n      \
    \          // Return the list of strings (separated by nested strings)\n     \
    \           list_of_separated_group_strings.toList\n            }\n        }\n\
    \        // Separate the input string into list of strings\n        val list_of_strings\
    \ = paren_string.substring(1, paren_string.length-1).split(\"\\\\s+\").map( s\
    \ => s.trim() ).toList\n        // Separate every string into list of strings\n\
    \        val list_of_separated_strings = list_of_strings.flatMap(separate_paren_groups)\n\
    \        // Combine every string into one string\n        val final_string = list_of_separated_strings.reduceLeft(_\
    \ + \"(\" + _ + \")\")\n        // Return the list of strings (separated by nested\
    \ strings)\n        list_of_separated_strings.toList", "        // Create an empty\
    \ list of strings that will be returned\n        val result = mutable.MutableList[String]()\n\
    \        // We will use mutable.MutableList instead of List for easier removal\
    \ from the list\n        val open_braces = mutable.MutableList[String]()\n   \
    \     // We will use mutable.MutableList instead of List for easier removal from\
    \ the list\n        val closed_braces = mutable.MutableList[String]()\n\n    \
    \    for (c <- paren_string) {\n            // Check if the character is a parenthesis\n\
    \            val currentChar = c.toInt\n            if (currentChar == 1) {\n\
    \                // If it is a single parenthesis add it to the open_braces list\n\
    \                open_braces += c\n            } else if (currentChar == 0) {\n\
    \                // If it is an empty brace (which means it's closed) add it to\
    \ the closed_braces list\n                closed_braces += c\n            } else\
    \ if (currentChar < 0) {\n                // If it's not a single brace or the\
    \ character is not a parenthesis throw an error\n                throw new RuntimeException(\"\
    String not properly formatted\")\n            }\n        }\n\n        // Iterate\
    \ over the open braces\n        for (i <- 0 until open_braces.size) {\n      \
    \      // For each brace check whether the brace is closed or not\n          \
    \  val open_brace = open_braces(i)\n            val closed_brace = closed_braces(i)\n\
    \n            // If the brace is not closed, add it to the result list\n     \
    \       if (open_brace != closed_brace) {\n                result += open_brace\n\
    \            }\n        }\n        result.toList", "        // Your code goes\
    \ here.\n        val paren_string = paren_string.replace(\"( \", \"(\").replace(\"\
    )\", \")\")\n        val brace_counts = paren_string.groupCount(\"()\")\n    \
    \    // print out all groups of balanced parentheses.\n        val groups = mutable.Stack.empty[String]\n\
    \        for(i<- 1 to brace_counts.size)\n        {\n            val open_count\
    \ = paren_string.substring(1,i).count(\"(\")\n            val close_count = paren_string.substring(i,\
    \ brace_counts(i)).count(\")\")\n            if(!open_count.equals(close_count))\n\
    \            {\n                val group_string = paren_string.substring(1,i-1)\
    \ + (open_count - close_count) +  paren_string.substring(i, brace_counts(i))\n\
    \                groups.push(group_string)\n            }\n        }\n       \
    \ // print out all groups of unbalanced parentheses.\n        var unbalanced_groups\
    \ = List[String]()\n        for(i <- 1 to brace_counts.size)\n        {\n    \
    \        val open_count = paren_string.substring(1,i).count(\"(\")\n         \
    \   val close_count = paren_string.substring(i, brace_counts(i)).count(\")\")\n\
    \            if(open_count.equals(close_count))\n            {\n             \
    \   val group_string = paren_string.substring(1,i-1) + (open_count - close_count)\
    \ +  paren_string.substring(i, brace_counts(i))\n                groups.push(group_string)\n\
    \            }\n            else\n            {\n                unbalanced_groups\
    \ = unbalanced_groups :+ paren_string.substring(1,i-1)\n            }\n      \
    \  }\n        unbalanced_groups", "        val inputSet = paren_string.trim\n\
    \        val paren_stringArray = inputSet.split(\"\\\\(\")\n        paren_stringArray.map(x\
    \ => x.replace(\")\", \"\"))", "        val pat = Pattern.compile(\"\\\\(|\\\\\
    )\").r\n        paren_string.split(pat)\n            .flatMap(_.grouped(2))\n\
    \            .filter(_.size == 2) //remove groups of length 1\n            .map(_.mkString(\"\
    (\",\",\",\")\") ) //add parens to each pair", "        def isParenthesisNesting(paren_string\
    \ : String) : Boolean = paren_string contains \"(\" || paren_string contains \"\
    [\"\n        def isNestingDepth(paren_string : String) : Int = paren_string.count(\"\
    (\") - paren_string.count(\"[\")\n\n        if (paren_string.length <= 1) List(paren_string)\n\
    \        else for {\n            open_count <- 0 to paren_string.lastIndexOf(\"\
    (\")\n            close_count <- 0 to paren_string.lastIndexOf(\")\")\n\n    \
    \        if (open_count < close_count && open_count != -1) open_count <- close_count\
    \ // If the open parens are nested in each other, ignore it\n            else\
    \ {\n                val depth_check = (open_count - close_count + 1) / 2\n  \
    \              if (depth_check != 0) depth_check else depth_check <- 0 // If the\
    \ open parens are nested in each other, ignore it\n                val nest_count\
    \ = (close_count - open_count + 1) / 2\n                if (nest_count != 0) nest_count\
    \ else nest_count <- 0 // If the open parens are nested in each other, ignore\
    \ it\n                if (((open_count - close_count + 1) % 2) == 0) depth_check\
    \ + nest_count else nest_count + depth_check\n            }\n        } yield {\n\
    \            val open_index = open_count + 1\n            val close_index = close_count\
    \ + 1\n            val nest_index = open_count + close_count + 1\n           \
    \ val groups: List[String] = ListBuffer.empty[String]\n            val current_group:\
    \ String = paren_string.substring(0, open_index)\n            val current_group_nest_level:\
    \ Int = isParenthesisNesting(current_group) ? 0 : isNestingDepth(current_group)\
    \ ? 1 : 2\n            val next_group: String = paren_string.substring(open_index,\
    \ close_index)\n            val next_group_nest_level: Int = isParenthesisNesting(next_group)\
    \ ? 0 : isNestingDepth(next_group) ? 1 : 2\n            if (current_group_nest_level\
    \ == next_group_nest_level) {\n                if (current_group_nest_level ==\
    \ 0) {\n                    val current_group_nest_opens = paren_string.substring(open_index,\
    \ open_count + 1).replace(\"(\", \"\").replace(\")\", \"\")\n                \
    \    val current_group_nest_closes = paren_string.substring(close_count + 1, close_count\
    \ + 2).replace(\"(\", \"\").replace(\")\", \"\")\n                    val group_nest_opens\
    \ = current_group_nest_opens + paren_string.substring(open_index, open_count +\
    \ 1).replace(\"(\", \"\").replace(\")\", \"\")\n                    val group_nest_closes\
    \ = current_group_nest_closes + paren_string.substring(close_count + 1, close_count\
    \ + 2).replace(\"(\", \"\"", "        // Iterate over all groups of parentheses\n\
    \        val allParenGroups = paren_string.split(\"\\\\(\")\n        // Create\
    \ an accumulator\n        var groups: List[String] = Nil\n        var opening_paren_count:\
    \ Int = 0\n        // Iterate over all groups of parentheses.\n        for(paren_string\
    \ <- allParenGroups) {\n            // If the opening brace is closed, then add\
    \ a new group to the list and increase the opening brace counter\n           \
    \ if(paren_string.endsWith(\")\")) {\n                groups = groups ++ List(paren_string.substring(0,\
    \ paren_string.length-1))\n                opening_paren_count = opening_paren_count\
    \ + 1\n            }\n            // If the opening brace is not closed, then\
    \ check if the opening brace is still open. If not, then add a space\n       \
    \     // to the end of the group and increase the opening_paren_count by 1.\n\
    \            else {\n                // If the opening brace is still open, then\
    \ add a comma to the end of the group and increase the opening_paren_count\n \
    \               // by 1.\n                if(opening_paren_count != 0) {\n   \
    \                 groups = groups ++ List(\",\")\n                    opening_paren_count\
    \ = opening_paren_count + 1\n                }\n                // If the opening\
    \ brace is not open, then add the group to the groups and increase the opening_paren_count\n\
    \                // by 1.\n                else {\n                    groups\
    \ = groups ++ List(paren_string)\n                    opening_paren_count = opening_paren_count\
    \ + 1\n                }\n            }\n        }\n        return groups", " \
    \       paren_string.split(\"\\\\(\").map(_.replaceAll(\"\\\\s\", \"\")) match\
    \ {\n            case Array(p1, p2) => List(p1 + p2)\n            case _ => Nil\n\
    \        }", "        var stack : List[String] = Nil\n        paren_string.flatMap(c\
    \ => {\n            c match {\n                case '(' =>\n                 \
    \   stack:::List()\n                case ')' =>\n                    if(stack.length\
    \ > 0) stack:::List()\n                    else Nil\n                case _ =>\n\
    \                    if(stack.length > 0 && stack.last == c) stack:::List()\n\
    \                    else Nil\n            }\n        })", "        var paren_list\
    \ = List[String]()\n        var open_braces = List[Int]()\n        var open_parens\
    \ = List[Int]()\n        var closed_parens = List[Int]()\n        var closing_braces\
    \ = List[Int]()\n        var open_parens_stack = List[Int]()\n        paren_string.split(\"\
    ((\\\\(|\\\\))+\").foreach{\n            par =>\n                val braces =\
    \ par.count(_ == '(')\n                val parens = par.count(_ == '(')\n    \
    \            if (braces > parens) {\n                    paren_list ::= par\n\
    \                    open_parens = par.count(_ == '(')\n                    closed_parens\
    \ = par.count(_ == '(')\n                    closing_braces = par.count(_ == '(')\n\
    \                } else {\n                    open_parens_stack ::= par.count(_\
    \ == '(')\n                    if (parens == closing_braces &&  open_parens ==\
    \ closed_parens) {\n                        paren_list ::= par\n             \
    \           open_parens = open_parens_stack\n                        closed_parens\
    \ = closed_parens.take(open_parens_stack.size)\n                        closing_braces\
    \ = 0\n                    } else if (parens == open_parens &&  open_parens ==\
    \ closed_parens) {\n                        paren_list ::= par\n             \
    \           open_braces = open_braces.take(open_parens_stack.size)\n         \
    \               open_parens = open_parens_stack\n                        closed_parens\
    \ = closed_parens.take(open_parens_stack.size)\n                        closing_braces\
    \ = 0\n                    }\n                }\n        }\n        paren_list",
  "        val parenGroups = paren_string.split(\"(?<=\\\\()|(?=\\\\))\").filter(_.nonEmpty)\n\
    \        parenGroups.map(_.split(\"\\\\s\"+1).map(_.trim))", "        val paren_list\
    \ : List[String] = new mutable.ListBuffer[String]()\n        var open_brace :\
    \ Boolean = true\n        for (i <- 0 until paren_string.length){\n          \
    \  paren_string match {\n                case _ if paren_string(i) == '(' && paren_string(i+1)\
    \ != '(' && paren_string(i+1) != ')' && paren_string(i+1) != ' ' => open_brace\
    \ = false\n                case _ if paren_string(i) == '(' && paren_string(i+1\
    \ == ')' && paren_string(i+3) != '(' && paren_string(i+3) != ')' && paren_string(i+3)\
    \ != ' ' => open_brace = false\n                case _ if paren_string(i) == ')'\
    \ && paren_string(i+1 != ')' && paren_string(i+2 != '(' && paren_string(i+2 !=\
    \ ')' && paren_string(i+2 != ' ')) => open_brace = false\n                case\
    \ _ if paren_string(i) == ')' && paren_string(i+1 == ')' && paren_string(i+2 !=\
    \ '(' && paren_string(i+2 != ')' && paren_string(i+2 != ' ')) => open_brace =\
    \ false\n                case _ if paren_string(i) == ' ' => open_brace = false\n\
    \                case _ if paren_string(i) != ' ' && paren_string(i) != ')' &&\
    \ !open_brace => paren_list += paren_string(i).toString + \"\\n\"\n          \
    \  }\n        }\n        paren_list.filter(!_.isEmpty)", "        // Initialize\
    \ our output list\n        val output = ListBuffer[String]()\n        \n     \
    \   // Iterate over each character in the input string\n        for (i <- 0 to\
    \ paren_string.length - 1) {\n            // If it's a space, add an open brace\
    \ to our output list\n            if (paren_string(i) == \" \") {\n          \
    \      output += (\"(\")\n            }\n            // If it's not a space, add\
    \ it to the output list if it is within parens\n            if (paren_string(i)\
    \ !=  \" \" && paren_string(i) !=  \")\") {\n                output += paren_string(i)\n\
    \            }\n            \n            // If it's a space, add an close brace\
    \ to our output list\n            if (paren_string(i) == \" \") {\n          \
    \      output += (\")\")\n            }\n        }\n        \n        // Return\
    \ the output list\n        output.toList", "        def separate(aString : String)\
    \ : String = {\n            var outString : String = \"\"\n            var open_brace\
    \ : Int = 0\n            var close_brace : Int = 0\n            for(c <- aString)\
    \ {\n                if(c == '(') {\n                    open_brace = open_brace\
    \ + 1\n                } else if(c == ')') {\n                    close_brace\
    \ = close_brace + 1\n                    if(open_brace == close_brace) {\n   \
    \                     outString = outString + c + \" \" \n                   \
    \     open_brace = 0\n                        close_brace = 0\n              \
    \      }\n                }\n            }\n            outString\n        }\n\
    \        val outList = mutable.ListBuffer[String]()\n        var brace_count =\
    \ 0\n        var open_count = 0\n        for(i <- 0 until paren_string.length)\
    \ {\n            val c = paren_string(i)\n            if(c == '(') {\n       \
    \         brace_count = brace_count + 1\n            } else if(c == ')') {\n \
    \               brace_count = brace_count - 1\n                if(open_count ==\
    \ brace_count) {\n                    outList += separate(paren_string.substring(0,i))\n\
    \                    open_count = 0\n                    brace_count = 0\n   \
    \             } else {\n                    open_count = open_count + 1\n    \
    \            }\n            }\n        }\n        return outList.toList", "  \
    \      var groups = List[String]()\n        paren_string.split(\"\\\\(\").foreach(group\
    \ => {\n            val inner = group.split(\"\\\\)\");\n            val lastGroup\
    \ = inner.last;\n            if(groups.length == 0 || lastGroup != groups(groups.length-1))\
    \ {\n                groups += lastGroup;\n            }\n            else {\n\
    \                println(lastGroup);\n                println(groups(groups.length-1));\n\
    \                println(groups);\n                println(groups.length);\n \
    \               println(groups.length-1);\n                println(groups(groups.length-1)+\"\
    *\"+groups(groups.length));\n                println(groups.length);\n       \
    \         println(groups.length-1);\n                println(groups(groups.length-1)+\"\
    *\"+groups(groups.length-1));\n                println(\"last\");\n          \
    \      println(\"*\"+groups(groups.length-1));\n                println(\"*\"\
    +groups(groups.length-1)+\"*\"+groups(groups.length));\n                println(\"\
    *\"+groups(groups.length-1)+\"*\"+groups(groups.length-1));\n                println(\"\
    inner\"+inner.length);\n            }\n        })\n        return groups;", " \
    \       if(paren_string.isEmpty){\n            return []\n        }\n        var\
    \ groups: List[String] = Nil\n        var in_paren_group : Boolean = false\n \
    \       for(i <- 0 until paren_string.length){\n            val c = paren_string(i)\n\
    \            if(in_paren_group){\n                if(c == '('){\n            \
    \        in_paren_group = false\n                } else if(c == ')'){\n      \
    \              if(in_paren_group){\n                        in_paren_group = false\n\
    \                        groups = groups ::: (groups.reverse)\n              \
    \      } else {\n                        groups = groups ::: List(groups.reverse)\n\
    \                    }\n                } else if(c == ' ' || c == '\\n' || c\
    \ == '\\t' || c == '\\r'){\n                    in_paren_group = false\n     \
    \           } else {\n                    groups = groups ::: List(groups.reverse)\n\
    \                }\n            } else {\n                if(c == ' ' || c ==\
    \ '\\n' || c == '\\t' || c == '\\r'){\n                    in_paren_group = true\n\
    \                } else {\n                    in_paren_group = true\n       \
    \         }\n            }\n        }\n        return groups", '        paren_string.split("""(?<=\()(?!\))|(?<=\))(?!\()|(?<=\))(?=\()|(?<=\))(?=\))|(?<=\()(?=\))""".r)',
  "        val paren_str = paren_string.trim\n        if (paren_str.length <= 0) List()\n\
    \        else {\n            var open_paren_level = 0\n            var open_paren_count\
    \ = 0\n            var close_paren_level = 0\n            var close_paren_count\
    \ = 0\n            var paren_list: List[String] = List()\n            for (char\
    \ <- paren_str.toCharArray) {\n                val ch = (char)\n             \
    \   if (open_paren_level == 0) {\n                    if (ch == '(') {\n     \
    \                   open_paren_count += 1\n                    }\n           \
    \         if (ch == ')') {\n                        close_paren_count += 1\n \
    \                   }\n                    else if (ch == '(') {\n           \
    \             open_paren_level += 1\n                    }\n                 \
    \   else if (ch == ')') {\n                        close_paren_level += 1\n  \
    \                  }\n                } else {\n                    if (ch ==\
    \ '(') {\n                        open_paren_count -= 1\n                    }\n\
    \                    if (ch == ')') {\n                        close_paren_count\
    \ -= 1\n                    }\n                    else if (ch == '(') {\n   \
    \                     open_paren_level -= 1\n                    }\n         \
    \           else if (ch == ')') {\n                        close_paren_level -=\
    \ 1\n                    }\n                }\n                if (open_paren_count\
    \ == 0 && close_paren_count == 0) {\n                    paren_list ::= paren_str\n\
    \                    paren_str = ListBuffer()\n                }\n           \
    \ }\n            paren_list.tail\n        }", "      val groups = paren_string.split(\"\
    \\\\(|\\\\)\").toList\n      val separated = groups.foldLeft(List[String]()){\
    \ case (acc, currGroup) => if (acc.isEmpty) List(currGroup) else acc }\n     \
    \ separated", "      paren_string.split(\"[()]\").filter(_ != \" \").map(_.trim).foldLeft(List[String]())((acc,\
    \ cur) => acc match {\n        case Nil => acc :+ cur\n        case x :: xs if\
    \ xs.isEmpty => acc :+ cur\n        case x :: xs if xs.head.isEmpty => acc :+\
    \ cur\n        case x :: xs if !x.contains(\" \") => x :: acc\n        case x\
    \ :: xs if x.contains(\"(\") && x.contains(\")\") && x.contains(\"(\") && !x.contains(\"\
    ()\") =>\n            separateParenGroups(xs.head) ++ List(cur)\n        case\
    \ x :: xs if x.contains(\"(\") && x.contains(\")\") && x.contains(\"()\") =>\n\
    \            separateParenGroups(xs.head) ++ List(cur)\n        case x :: xs if\
    \ x.contains(\"(\") && x.contains(\")\") =>\n            separateParenGroups(xs.head)\
    \ ++ List(cur)\n        case x :: xs if x.contains(\"(\") && !x.contains(\")\"\
    ) => \n            separateParenGroups(xs.head) ++ List(cur)\n        case x ::\
    \ xs if x.contains(\"()\") =>\n            separateParenGroups(xs.head) ++ List(cur)\n\
    \        case x :: xs if x.contains(\"()\") && x.contains(\"(\") =>\n        \
    \    separateParenGroups(xs.head) ++ List(cur)\n        case x :: xs if x.contains(\"\
    ()\") && x.contains(\"()\") =>\n            separateParenGroups(xs.head) ++ List(cur)\n\
    \        case x :: xs if x.contains(\"()()\") =>\n            separateParenGroups(xs.head)\
    \ ++ List(cur)\n        case x :: xs if x.contains(\"()()\") && x.contains(\"\
    (\") =>\n            separateParenGroups(xs.head) ++ List(cur)\n        case x\
    \ :: xs if x.contains(\"()()\") && x.contains(\"()\") =>\n            separateParenGroups(xs.head)\
    \ ++ List(cur)\n        case x :: xs if x.contains(\"()()()\") =>\n          \
    \  separateParenGroups(xs.head) ++ List(cur)\n        case x :: xs if x.contains(\"\
    ()()()\") && x.contains(\"(\") =>\n            separateParenGroups(xs.head) ++\
    \ List(cur)\n        case x :: xs if x.contains(\"()()()\") && x.contains(\"()\"\
    ) =>\n            separateParenGroups(xs.head) ++ List(cur)\n        case x ::\
    \ x", "        val list = mutable.ListBuffer[String]()\n        var in_paren =\
    \ false\n        for(c <- paren_string){\n            if(c == '('){\n        \
    \        in_paren = true\n                list += c\n            }else if(c ==\
    \ ')'){\n                in_paren = false\n                list += c\n       \
    \     }else if(!in_paren){\n                list += c\n            }\n       \
    \ }\n        list.toList", "        var paren_groups: List[List[String]] = Nil\n\
    \        for (i <- 0 until paren_string.length) {\n            if (paren_string(i)\
    \ == '(') {\n                val temp: List[String] = Nil\n                paren_groups\
    \ ::= temp\n            } else if (paren_string(i) == ')') {\n               \
    \ val temp = paren_groups(paren_groups.length - 1)\n                paren_groups\
    \ = temp\n            } else {\n                paren_groups = paren_groups :::\
    \ List(i.toString.toInt)\n            }\n        }\n        paren_groups.reverse.flatMap\
    \ {\n            x => if (x.size < 2) List(x) else x :: (x.tail -1)\n        }.filter(x\
    \ => x.length == x.tail.length)", "        // Write your code here.\n        val\
    \ stack = mutable.Stack[String]()\n        var list = new mutable.ListBuffer[String]()\n\
    \        for (i <- 0 until paren_string.length) {\n            val cur = paren_string(i)\n\
    \            if (cur == '(') {\n                stack += '('\n            } else\
    \ if (cur == ')') {\n                val curr = stack.pop()\n                if\
    \ (curr == '(') {\n                    list += curr\n                } else if\
    \ (curr != '') {\n                    list += curr\n                }\n      \
    \      } else if (cur != ' ') {\n                list += cur\n            }\n\
    \        }\n        list.mkString", "        val stack = mutable.Stack[String]()\n\
    \        paren_string.grouped(4).foreach { x =>\n            val a = x.dropRight(1)\n\
    \            val b = x.dropLeft(1)\n            if (stack.isEmpty || !a.equals(stack.peek))\
    \ {\n                stack.append(a)\n            } else {\n                stack.peek.append(b)\n\
    \            }\n        }\n        stack.toList", "        // Initialize list\n\
    \        val groups: List[String] = Nil\n        // Keep a stack\n        val\
    \ open_braces : mutable.Stack[String] = mutable.Stack[String]()\n        // Process\
    \ each character in the string\n        for (c <- paren_string) {\n          \
    \  // If c == '{', add it to the stack\n            if (c == '{') {\n        \
    \        open_braces.push(c)\n            // If c == '}', remove it\n        \
    \    } else if (c == '}') {\n                open_braces.pop()\n            //\
    \ Else, check if it is ')' or ')()'\n            } else if (c == ')' || c == ')(')\
    \ {\n                // If it is, add it to lists\n                if (c == '(')\
    \ {\n                    groups ::= open_braces.reverse.toList.reverse\n     \
    \           }\n                // Else, check if there is a stack of '()'\n  \
    \              else if (open_braces.isEmpty) {\n                    groups ::=\
    \ List(c)\n                } else {\n                    // If so, reverse it\
    \ and add it to the list\n                    groups ::= open_braces.reverse.toList.reverse\n\
    \                }\n            }\n        }\n        return groups", "      \
    \  // Base case: if paren_string is empty then return the empty list\n       \
    \ if (paren_string.length == 0)\n            Nil\n        // Base case: if there\
    \ is one open paren, then\n        else if (paren_string.length == 1 && paren_string.charAt(0)\
    \ == '(')\n            Nil\n        // Base case: split the string based on first\
    \ non-space char\n        else {\n            val first_non_space_char = paren_string.split(\"\
    \ \").map(_.head).filterNot(_ == ')').head\n            val splits = paren_string.split(first_non_space_char)\n\
    \            val groups = splits.grouped(splits.length)\n            groups.map(group\
    \ => group.mkString(first_non_space_char)).flatMap(group => separateParenGroups(group))\n\
    \        }", "        def isParensOpen (s : String) : Boolean = s.contains(\"\
    (\")\n        def isParensClose (s : String) : Boolean = s.contains(\")\")\n \
    \       def isNesting (s : String) : Boolean = s.contains(\")\")\n        val\
    \ parens = mutable.ListBuffer[String]()\n        val opens = mutable.ListBuffer[String]()\n\
    \        val closes = mutable.ListBuffer[String]()\n        val isOpen = mutable.ListBuffer[String]()\n\
    \        var depth = paren_string.length()\n        var i = paren_string.length()\
    \ - 1\n        while ( i >= 0 ) {\n            val c = paren_string(i)\n     \
    \       val s = paren_string.substring(0,i)\n            if ( isParensOpen(s)\
    \ ) {\n                if ( isOpen.contains(s) ) {\n                    closes\
    \ += c\n                    isOpen -= s\n                    isParensOpen -= s\n\
    \                    parens += c\n                } else {\n                 \
    \   opens += c\n                    isOpen += s\n                    isParensOpen\
    \ += s\n                    parens += c\n                }\n            } else\
    \ if ( isParensClose(s) ) {\n                if ( isClose.contains(s) ) {\n  \
    \                  opens -= c\n                    isClose -= s\n            \
    \        isParensClose -= s\n                    parens -= c\n               \
    \ } else {\n                    closes += c\n                    isClose += s\n\
    \                    isParensClose += s\n                    parens -= c\n   \
    \             }\n            } else if ( isNesting(s) ) {\n                depth--\n\
    \                if ( depth <= 0 ) {\n                    if ( depth == 0 ) {\n\
    \                        parens += c\n                    } else {\n         \
    \               parens -= c\n                    }\n                }\n      \
    \      }\n            i--\n        }\n        parens.toList", "        // Split\
    \ the paren_string into separate groups\n        val parens = paren_string.split(\"\
    \\\\)\")\n        // Keep track of the number of open braces encountered\n   \
    \     var open_braces = 0\n        // Build a queue to hold the groups. Each item\
    \ will be a string, with one \"(\" at the front\n        // and a \")\" at the\
    \ end.\n        var groups = mutable.Queue[String]()\n        // For each paren\n\
    \        for (paren <- parens) {\n            // If we've already encountered\
    \ an open brace\n            if (paren == \"(\") {\n                open_braces\
    \ += 1\n            } else {\n                open_braces -= 1\n             \
    \   // If we've encountered an open brace and there are still open braces\n  \
    \              if (open_braces == 0) {\n                    val new_group = parens.filter(x\
    \ => x != \"(\").mkString(\"(\", \")\")\n                    groups += new_group\n\
    \                }\n            }\n        }\n        // Build the list of groups\
    \ as a List\n        return groups.toList", '        paren_string.stripPrefix("(").stripSuffix(")").split("""\s(?=\()""").map(_.trim)',
  "        val parens = paren_string.split(\"\"\"[\\(\\)]+\"\"\")\n        val parens_with_brackets\
    \ = parens.map( x => if (x.contains(\"(\") || x.contains(\")\")) {\n         \
    \   var result = x\n            while (result.contains(\"(\")) {\n           \
    \     result = result.replace(\"(\",\"\").replace(\")\",\"\")\n            }\n\
    \            result += \")\"\n            result\n        }\n        else\n  \
    \          x)\n        val open_brackets = parens_with_brackets.filter(x => x.contains(\"\
    (\"))\n        val closed_brackets = parens_with_brackets.filter(x => x.contains(\"\
    )\"))\n\n        // Filter out any parenthesis that are already inside the string\n\
    \        val filtered = parens_with_brackets.filter{ x =>\n            if (x.contains(\"\
    (\") || x.contains(\")\")) {\n                var result = x\n               \
    \ while (result.contains(\"(\")) {\n                    result = result.replace(\"\
    (\",\"\").replace(\")\",\"\")\n                }\n                result = result.replace(\"\
    )\",\"\")\n                result = result + \")\"\n                result\n \
    \           }\n            else\n                x\n        }\n\n        val groups\
    \ = filtered.toList.zip(open_brackets, closed_brackets)\n        val final_groups\
    \ = groups.map{ case (group, rest_parens) => group + rest_parens}\n        final_groups",
  "        // Initialize some variables\n        var result_list: List[String] = Nil\n\
    \        var open_brace_count : Int = 0\n        var closed_brace_count : Int\
    \ = 0\n        var open_paren_count = 0\n        var close_paren_count = 0\n\n\
    \        // Create a stack of parentheses\n        val paren_stack = new mutable.Stack[String]()\n\
    \n        // Iterate through each character in the input string\n        for (c\
    \ <- paren_string) {\n\n            // If it is an open parenthesis character\n\
    \            if (c == '(') {\n                // Increase the paren count for\
    \ this opening parenthesis\n                open_paren_count += 1\n\n        \
    \        // If the stack of parenthesis is not empty\n                if (paren_stack.nonEmpty)\
    \ {\n                    // Pop the stack of parenthesis\n                   \
    \ val last_open_brace = paren_stack.pop()\n\n                    // If the last\
    \ opening brace was a close parenthesis\n                    if (last_open_brace\
    \ == '(') {\n                        // Increase the closed brace count for this\
    \ opening parenthesis\n                        close_paren_count += 1\n      \
    \              }\n                }\n            }\n\n            // If it is\
    \ an close parenthesis character\n            else if (c == ')') {\n         \
    \       // Decrease the closing paren count for the opening parenthesis\n    \
    \            close_paren_count -= 1\n\n                // If the stack of parenthesis\
    \ is not empty\n                if (paren_stack.nonEmpty) {\n                \
    \    // Pop the stack of parenthesis\n                    val last_closed_brace\
    \ = paren_stack.pop()\n\n                    // If the last closing brace was\
    \ an open parenthesis\n                    if (last_closed_brace == '(') {\n \
    \                       // Increase the open brace count for this closing parenthesis\n\
    \                        open_brace_count += 1\n                    }\n      \
    \          }\n            }\n\n            // If it is a closing brace character\n\
    \            else if (c == ')') {\n                // If the stack of parenthesis\
    \ is not empty\n                if (paren_stack.nonEmpty) {\n                \
    \    // Pop the stack of parenthesis\n                    val last_closed_brace\
    \ = paren_stack.pop()\n\n                    // If the last closing brace was\
    \ an open parenthesis\n                    if (last_closed_brace == '(') {\n \
    \                       // Decrease the open brace count for this closing parenthesis\n\
    \                        open_brace_count -= 1\n                    }\n      \
    \          }\n            }\n\n            // If it is a opening brace character\n\
    \            else if (c == '(') {\n                // If the stack of parenthesis\
    \ is not empty\n                if (paren_stack.nonEmpty) {\n                \
    \    // Pop the stack of parenthesis\n                    val last_open_brace\
    \ = paren_stack.pop()\n\n                    // If the last opening brace was\
    \ a close parenthesis\n                    if (last_open_brace == '(') {", " \
    \       val paren_groups = mutable.MutableList[String]()\n        paren_string.foreach{char\
    \ =>\n            if (char == \"(\") paren_groups += char\n            if (char\
    \ == \")\") paren_groups -= char\n            if (paren_groups.contains(char))\
    \ paren_groups += char\n        }\n        paren_groups.size\n        paren_groups.toList",
  "        // Create a stack for brackets\n        val stack = mutable.Stack[Int]()\n\
    \        val result = mutable.ListBuffer[String]()\n\n        // For each character\
    \ in the string\n        for (c <- paren_string.toCharArray) {\n            //\
    \ If the character is a left paren, push it to the stack\n            if (c ==\
    \ '(') stack.push(c) //push left paren\n\n            // If the character is a\
    \ right paren, pop the stack and append it to the result list\n            else\
    \ if (c == ')') {\n                if (stack.isEmpty) {\n                    result\
    \ += c.toString\n                } else {\n                    stack.pop() //pop\
    \ left paren\n                    result += c.toString\n                }\n  \
    \          }\n\n            // If the character is a space, ignore it\n      \
    \      else if (c == ' ') {\n            }\n\n            // If the stack is not\
    \ empty, the stack is not closed\n            else if (stack.nonEmpty) {\n   \
    \         }\n\n            // If the stack is empty, unclosed paren, append it\
    \ to the result list\n            else if (stack.empty) {\n                result\
    \ += c.toString\n            }\n\n            // If the stack is open, but we\
    \ see a left paren when it is not closed, throw an error.\n            else if\
    \ (stack.head == '(') {\n                throw new IllegalArgumentException(\"\
    unmatched opening brace\")\n            }\n\n            // If the stack is closed\
    \ but we see a right paren when it is not open, throw an error.\n            else\
    \ {\n                throw new IllegalArgumentException(\"unmatched closing brace\"\
    )\n            }\n        }\n\n        // The last item of the list is the result\
    \ list, append it to the result list\n        result += (paren_string - 1)\n \
    \       result", "        var brackets = mutable.Set[Char]()\n        var paren_stack\
    \ = mutable.Stack[Char]()\n        var groups = mutable.ListBuffer[String]()\n\
    \        var i = 0\n        val len = paren_string.length\n        paren_string.chars.toList\
    \ foreach { c =>\n            val i = paren_string.indexAt(i)\n            paren_stack\
    \ push c\n            if (brackets.contains(c) || c =='(' || c == ')'){\n    \
    \            brackets += c\n            } else if( c == '(') {\n             \
    \   paren_stack push c\n            } else if (c == ')') {\n                brackets\
    \ -= c\n                groups.append (paren_stack.pop())\n            }\n   \
    \         i += 1\n        }\n        return groups.toList", "        val paren_array\
    \ = paren_string.split(\"\\\\(\")\n        val paren_list_string = paren_array.drop(1).map(_\
    \ replaceAll(\"\\\\)\", \"\"))\n        val paren_list_array = new mutable.ArrayList[String]()\n\
    \        paren_list_array.add(paren_list_string)\n        val paren_list_array_string\
    \ = paren_list_array.mkString(\"(\", \")\", \", \")\")\n        val paren_list_array_array\
    \ = paren_list_array_string.split(\"\\\\)\")\n        paren_list_array_array.filter(s\
    \ => s.contains(\"(\")).drop(1).map(s => s replaceAll(\"\\\\(\", \"\")).toList",
  "        if(paren_string.length == 0) List(\"\")\n        else {\n            val\
    \ bracket = paren_string.charAt(0)\n            val group_start = paren_string.indexOf(paren_string\
    \ splitBy bracket)\n            val group_end = group_start + paren_string.indexOf(paren_string\
    \ dropRight group_start)\n            val group_startString = paren_string.subSequence(group_start,\
    \ group_end).toString\n            val group_endString = paren_string.subSequence(group_start\
    \ + paren_string.length, paren_string.length).toString\n            val result:\
    \ List[String] = List(group_startString) +\n                (paren_string.subSequence(group_start+1,\
    \ group_end).takeWhile(c => c != bracket).map( paren_string.subSequence(group_start,\
    \ group_end).toString).toList)\n            result ++ List(group_endString)\n\
    \        }", "        // TODO: Create a stack to hold the list of strings to return\
    \ and push one level of parens\n        val paren_list = mutable.ListBuffer[String]()\n\
    \        paren_string match {\n            case \"\" => paren_list\n         \
    \   case _ => paren_string foreach { char =>\n                if (char == '(')\
    \ paren_list += char\n                if (char == ')') paren_list.last += char\n\
    \            }\n        }\n        paren_list.toList", "        paren_string.split(\"\
    \\\\(\")\n            .filterNot(_.isEmpty)\n            .filter(_.nonEmpty)\n\
    \            .map(x => x.replace(\" \", \"\"))\n            .filter(x => x.length>0)\n\
    \            .flatMap(x => x.split(\"\\\\)\").filter(_.nonEmpty))", "        var\
    \ open_braces : List[Int] = Nil\n        var open_brace_count : Int = 0\n    \
    \    var closed_braces : List[Int] = Nil\n        var closed_brace_count : Int\
    \ = 0\n        var strings : List[String] = Nil\n        var string_count : Int\
    \ = 0\n        var paren_count = 0\n        val paren_groups = paren_string.trim().split(\"\
    \\\\(\")\n        for (paren_group <- paren_groups) {\n            val strings\
    \ = paren_group.trim().split(\"\\\\)\")\n            for (string <- strings) {\n\
    \                if (string.trim().equals(\"\")) continue\n                if\
    \ (string.startsWith(\"(\")) {\n                    string_count += 1\n      \
    \              strings += string\n                } else if (string.startsWith(\"\
    )\")) {\n                    string_count -= 1\n                    paren_count\
    \ += 1\n                    paren_count += (string.startsWith(\"(\") ? 1 : -1)\n\
    \                    if (string.startsWith(\"(\")) {\n                       \
    \ if (paren_count < 0) {\n                            open_braces = List(-paren_count)\n\
    \                            open_brace_count = (open_braces.foldLeft(0) { (acc,\
    \ next) => acc + next })\n                        }\n                    } else\
    \ if (string.startsWith(\")\")) {\n                        if (paren_count ==\
    \ 0) {\n                            closed_braces = List(string_count)\n     \
    \                       closed_brace_count = (closed_braces.foldLeft(0) { (acc,\
    \ next) => acc + next })\n                        }\n                    }\n \
    \               }\n            }\n            if (strings.size > 0) strings +=\
    \ strings\n        }\n        if (string_count == 0 && paren_count == 0) strings\
    \ else strings.head", "        val paren_groups = paren_string.split(\"\"\"[\\\
    (\\)]+\"\"\").toList\n        var brace_open = 0\n        var brace_close = 0\n\
    \        var string_list : List[String] = Nil\n        \n        for (paren_group\
    \ <- paren_groups) {\n            if(paren_group.length == 1) {\n            \
    \    string_list = string_list :+ paren_group\n                continue\n    \
    \        }\n\n            if(paren_group == paren_group.substring(1)) {\n    \
    \            brace_open += 1\n            }\n            else {\n            \
    \    brace_close += 1\n            }\n\n            if(brace_open > 0 && brace_close\
    \ > 0) {\n                string_list = string_list :+ paren_group\n         \
    \   }\n\n            if(paren_group == paren_group.substring(0, 1)) {\n      \
    \          brace_open -= 1\n            }\n            else {\n              \
    \  brace_close -= 1\n            }\n        }\n        \n        string_list.toList",
  "        var result : List[String] = Nil\n        val paren_groups = paren_string.substring(1,paren_string.length).split(\"\
    \"\"\\s(?=\\s)\"\"\")\n        for (i <- 0 until paren_groups.length) {\n    \
    \        val cur_paren_group = paren_groups(i)\n            var j = 0\n      \
    \      var paren_balance = 0\n            var open_parens = 0\n            var\
    \ prev_closed_parens = 0\n            while (j < cur_paren_group.length) {\n \
    \               val cur_char = cur_paren_group(j)\n                val next_char\
    \ = paren_groups(j + 1)\n                cur_char.equals(next_char) match {\n\
    \                    case true => {\n                        j += 1\n        \
    \            }\n                    case false => {\n                        if\
    \ (cur_char == '(') {\n                            open_parens += 1\n        \
    \                } else if (cur_char == ')') {\n                            paren_balance\
    \ -= 1\n                        }\n                    }\n                }\n\
    \                j += 1\n            }\n            if (open_parens == paren_balance)\
    \ {\n                result += paren_groups(i).split(\"\"\"\\s(?=\\s)\"\"\").toList\n\
    \            }\n        }\n        return result", "        // Step 1: Split input\
    \ string into list of nested strings\n        val nestedString = paren_string.flatMap(x\
    \ => x.toString.split(\"\\\\s+\")).toList\n        nestedString.foldLeft(List[String]())((x,\
    \ y) => {\n            // Step 2: If current item is an open brace, append all\
    \ items until it closes up until the\n            // next open brace or end of\
    \ string. If it's an open brace, check if it can be closed up\n            //\
    \ (meaning it has no unclosed parens) and if so, add it to the list.\n       \
    \     if (x.get(0).equals(\"(\")) {\n                val itemList = x.tail.flatMap(y\
    \ => y.toString.split(\"\\\\s+\"))\n                // If it can be closed up,\
    \ add it\n                if (itemList.forall(y => y.equals(\"(\") || y.equals(\"\
    )\")))\n                    y :: x\n                else\n                   \
    \ x :+ y\n            } else // If current item is a closing bracket, check if\
    \ it can be closed up (meaning it no\n                    // unclosed parens)\
    \ and if so, remove it and add it to result list.\n                if (x.get(0).equals(\"\
    )\")) {\n                    val itemList = x.tail.flatMap(y => y.toString.split(\"\
    \\\\s+\"))\n                    // If it can be closed up, remove it\n       \
    \             if (itemList.forall(y => y.equals(\"(\") || y.equals(\")\")))\n\
    \                        y :: x.tail\n                    else\n             \
    \           x :+ y.tail\n                } else\n                    x :+ x\n\
    \        })", "        // The set of paren group indices we currently have are\
    \ stored here.\n        // Each time we see a paren group, we add it to the list\
    \ of paren group indices.\n        // Each time we see a closing paren group,\
    \ we remove it from the list of paren group indices.\n        // When we see a\
    \ closing paren group, we remove all indices from the set of paren group indices\n\
    \        // that were added since the last time we saw a closing paren group.\n\
    \        val paren_group_indices = Set[Int]()\n        // The list of paren groups\
    \ to return\n        var returned_groups: List[String] = Nil\n\n        // For\
    \ each character in the paren string and each paren group index in the set of\
    \ paren group indices\n        for (c <- paren_string.charAt(0); i <- paren_group_indices)\
    \ {\n            // If the character is a left paren, or the current set of paren\
    \ group indices contain no left paren\n            if (c == '(' || paren_group_indices.isEmpty)\
    \ {\n                // If we're currently adding paren groups to the list\n \
    \               if (paren_group_indices.contains(i)) {\n                    //\
    \ Then we add the character to the current paren group\n                    returned_groups\
    \ = returned_groups :+ (c :: Nil)\n                } else {\n                \
    \    // Otherwise, we're removing the paren group from the set of paren group\
    \ indices\n                    paren_group_indices -= i\n                }\n \
    \           } else {\n                // If the character is a right paren, or\
    \ the current set of paren group indices contain no right paren\n            \
    \    if (c == ')' || paren_group_indices.isEmpty) {\n                    // If\
    \ we're currently removing paren groups from the list\n                    if\
    \ (paren_group_indices.contains(i)) {\n                        // Then we remove\
    \ that character from the current paren group\n                        returned_groups\
    \ = returned_groups :+ (Nil:::(c))\n                    } else {\n           \
    \             // Otherwise, we're removing the paren group from the set of paren\
    \ group indices\n                        paren_group_indices -= i\n          \
    \          }\n                } else {\n                    // If we're currently\
    \ adding paren groups to the list\n                    if (paren_group_indices.contains(i))\
    \ {\n                        // Then we add the character to the current paren\
    \ group\n                        returned_groups = returned_groups :+ (c :: Nil)\n\
    \                    } else {\n                        // Otherwise, we're removing\
    \ the paren group from the set of paren group indices\n                      \
    \  paren_group_indices -= i\n                    }\n                }\n      \
    \      }\n        }\n\n        // Return the list of paren groups\n        returned_groups",
  '        paren_string.split("{").map(s => s.trim).filter(_.nonEmpty).toList', " \
    \       val open_paren_counts = mutable.ArrayBuffer.fill(paren_string.length)(0)\n\
    \        var curr_index = 0\n        while (curr_index < paren_string.length)\
    \ {\n            if (paren_string(curr_index) == '(') {\n                open_paren_counts(curr_index)\
    \ += 1\n            } else {\n                open_paren_counts(curr_index) -=\
    \ 1\n            }\n            curr_index += 1\n        }\n        val open_paren_counts_sum\
    \ = open_paren_counts.sum\n        val result_list = mutable.ListBuffer[String]()\n\
    \        var curr_index = 0\n        while (curr_index < paren_string.length)\
    \ {\n            if (open_paren_counts(curr_index) == 0) {\n                curr_index\
    \ += 1\n                continue\n            }\n            val open_paren_counts_element\
    \ = open_paren_counts(curr_index)\n            if (open_paren_counts_element >\
    \ 0) {\n                result_list += paren_string.substring(curr_index, curr_index\
    \ + open_paren_counts_element)\n                curr_index += open_paren_counts_element\n\
    \            } else {\n                val left_paren_length = paren_string.length\
    \ - curr_index\n                val right_paren_length = open_paren_counts_sum\
    \ - open_paren_counts(curr_index)\n                if (left_paren_length > right_paren_length)\
    \ {\n                    val left_paren_start_index = curr_index\n           \
    \         val right_paren_end_index = curr_index + open_paren_counts_sum\n   \
    \                 result_list += paren_string.substring(left_paren_start_index,\
    \ right_paren_end_index)\n                }\n                curr_index += open_paren_counts(curr_index)\n\
    \            }\n        }\n        result_list.trim", "        val bracket_openers\
    \ : List[(Int, Int)] = paren_string.zipWithIndex\n        val bracket_closers\
    \ : List[(Int, Int)] = paren_string.zipWithIndex.filter( _._2 != paren_string.size\
    \ - 1 )\n        val bracket_pairs : List[(Int, Int)] = paren_string.zipWithIndex.filter(\
    \ _._2 == paren_string.size - 1 )\n        val unbalanced : List[(Int, Int)] =\
    \ paren_string.zipWithIndex.filter( _._2 < paren_string.size - 1 )\n        val\
    \ unbalanced_pairs : List[(Int, Int)] = unbalanced.filter( _._2 == unbalanced.size\
    \ - 1 )\n\n        def matchUnbalanced(start : Int, end : Int) : Option[((Int,\
    \ Int), (Int, Int))] = {\n            if (end < 0 || end >= paren_string.size)\
    \ None\n            else (paren_openers(start), paren_closers(end)).filter( _._1\
    \ != _._2 )\n        }\n\n        def matchPair(start : Int, end : Int) : Option[((Int,\
    \ Int), (Int, Int))] = {\n            if (end < 0 || end >= paren_string.size)\
    \ None\n            else (paren_openers(start), paren_closers(end)).filter( _._1\
    \ == _._2 )\n        }\n\n        // Check for unbalanced pairs\n        val unbalanced_start\
    \ : Option[Int] = unbalanced_pairs.find { case ((_, start), (_, end)) => start\
    \ < end }\n        val unbalanced_end : Option[Int] = unbalanced_pairs.find {\
    \ case ((_, start), (_, end)) => start < end }\n        val unbalanced_pair :\
    \ Option[((Int, Int), (Int, Int))] = matchUnbalanced(unbalanced_start.get._2,\
    \ unbalanced_end.get._2)\n\n        // Check for unbalanced pairs\n        val\
    \ pair_start : Option[Int] = unbalanced_pair.find { case ((_, start), (_, end))\
    \ => start < end }\n        val pair_end : Option[Int] = unbalanced_pair.find\
    \ { case ((_, start), (_, end)) => start < end }\n        val pair_pair : Option[((Int,\
    \ Int), (Int, Int))] = matchPair(pair_start.get._2, pair_end.get._2)\n\n     \
    \   // Check for unbalanced pairs\n        val unbalanced_start : Option[Int]\
    \ = unbalanced_pairs.find { case ((_, start), (_", "        // Split string into\
    \ words\n        val word_list = paren_string.trim().split(' ').filter(_.nonEmpty).toList\n\
    \        var balanced_list: List[String] = Nil\n        var open_list_stack: List[String]\
    \ = Nil\n        \n        // Iterate through words and remove empty ones\n  \
    \      for(word <- word_list) {\n            if (word == \"\") continue\n    \
    \        \n            // If the word is not empty, add it to open_list_stack\n\
    \            if (word != \")\") {\n                open_list_stack ::= word\n\
    \            } else {\n                // If the word is \")\", we remove the\
    \ last element from open_list_stack\n                if (open_list_stack.length\
    \ > 0) open_list_stack = open_list_stack.dropRight(1)\n                \n    \
    \            // If the stack is empty, that means the whole parentheses are balanced\n\
    \                if (open_list_stack.length == 0) balanced_list ::= open_list_stack\n\
    \                \n                // If the stack has at least 1 element in it,\
    \ that means the parentheses are not nested\n                else {\n        \
    \            val open_paren_len = open_list_stack.length\n                   \
    \ if (open_paren_len == 1) {\n                        open_list_stack = open_list_stack.tail\n\
    \                        balanced_list ::= open_list_stack\n                 \
    \   } else {\n                        // Iterate through the open_list_stack\n\
    \                        for(open_paren_word <- open_list_stack) {\n         \
    \                   if (open_paren_word == \"(\") open_list_stack ::= open_list_stack.dropRight(1)\n\
    \                            else if (open_paren_word == \")\") open_list_stack\
    \ ::= open_list_stack.dropRight(1)\n                        }\n              \
    \          balanced_list ::= open_list_stack\n                    }\n        \
    \        }\n            }\n        }\n        \n        // Return balanced_list\n\
    \        balanced_list", "        // The current stack represents the current\
    \ group of parenthesis\n        val stack = new Stack[String]()\n        // The\
    \ current group of parenthesis represent the current string\n        val group\
    \ = \"\"\n        // Iterate through all the characters in the paren_string\n\
    \        for (char <- paren_string.toCharArray) {\n            // If the character\
    \ is a '('\n            if (char == '(') {\n                // Push the current\
    \ group of parenthesis onto the stack\n                stack.push(group)\n   \
    \             group = \"\"\n            }\n            // If the character is\
    \ a ')'\n            if (char == ')') {\n                // If the current stack\
    \ is empty we reached the end of the current group of parenthesis\n          \
    \      if (stack.isEmpty) {\n                    // If this was the last group\
    \ of parenthesis\n                    if (group.length > 0) {\n              \
    \          // We add the group of parenthesis to the list\n                  \
    \      val list = List(group)\n                        // Return the list\n  \
    \                      list\n                    } else {\n                  \
    \      // We return an empty list\n                        Nil\n             \
    \       }\n                } else {\n                    // Pop the current group\
    \ of parenthesis from the stack\n                    val current_group = stack.pop()\n\
    \                    // Update the current group\n                    group =\
    \ current_group + \")\"\n                }\n            }\n            // If the\
    \ character is a space\n            if (char == ' ') {\n                // Do\
    \ nothing\n            }\n            // If the character is not a space\n   \
    \         else {\n                // Add the character to the current group of\
    \ parenthesis\n                group = group + char\n            }\n        }",
  "        val result = mutable.ListBuffer[String]()\n        var paren_count = 1\n\
    \        paren_string.split(\"\"\"\\s*(?:\\(\\)|\\{[^{}]*\\})\\s*\"\"\").foreach(x\
    \ => {\n            if( x.matches(\"\\\\(\\\\)\") ) paren_count = paren_count\
    \ + 1\n            if( x.matches(\"\\\\{[^{}]*\\\\}\") ) paren_count = paren_count\
    \ - 1\n            if( paren_count == 0 ) result += x\n        })\n        result.toList",
  "        // Create a map to store opening paren groups\n        var groups : mutable.Map[String,\
    \ List[String]] = mutable.Map[String, List[String]]()\n        // Keep track of\
    \ last closing paren group\n        var last_closing_paren_group : Option[String]\
    \ = None\n        // Iterate over each char in the string\n        for (c <- paren_string)\
    \ {\n            // If current char is a left paren then create a new list of\
    \ opening paren group\n            if (c == \"(\") {\n                groups.getOrElseUpdate(\"\
    ()\", new ListBuffer[String]()) += c\n            }\n            // If current\
    \ char is a right paren then create a new list of closing paren group\n      \
    \      else if (c == \"(\") {\n                // Add new closing paren group\
    \ to list of closing paren groups\n                val curr_group_str : List[String]\
    \ = groups.get(\"()\")\n                curr_group_str match {\n             \
    \       case Nil => last_closing_paren_group = None\n                    case\
    \ curr_group_str => last_closing_paren_group = curr_group_str\n              \
    \  }\n                groups.update(\"()\", new ListBuffer[String]()) += c\n \
    \           }\n            // If current char is a space then skip it\n      \
    \      else if (c == \" \") {\n                // Do nothing\n            }\n\
    \            // If current char is an opening left paren group then check that\
    \ it closes properly (either by a\n            // closing right paren or by another\
    \ left paren)\n            else if (c == \"(\") {\n                // If last\
    \ closing paren group exists then add this group to the list of groups and ignore\
    \ it\n                if (last_closing_paren_group.isDefined) {\n            \
    \        groups.getOrElseUpdate(last_closing_paren_group.get, new ListBuffer[String]())\
    \ += c\n                }\n            }\n            // If current char is a\
    \ closing left paren group then check that it opens properly (either by a\n  \
    \          // closing right paren or by another left paren)\n            else\
    \ if (c == \")\") {\n                // If last opening paren group exists then\
    \ add this group to the list of groups and ignore it\n                if (groups.containsKey(last_closing_paren_group.get))\
    \ {\n                    groups.getOrElse(last_closing_paren_group.get) match\
    \ {\n                        // If there are open right parens then close them\n\
    \                        case Nil => groups.remove(last_closing_paren_group.get)\n\
    \                        // If there are no open right parens then close the group\n\
    \                        case curr_group_str => curr_group_str match {\n     \
    \                       case Nil => groups.remove(last_closing_paren_group.get)\n\
    \                            case _ => curr_group_str.clear()\n              \
    \          }\n                    }\n                }\n            }\n      \
    \  }\n        // Return list of ", "        var groups = List[String]()\n\n  \
    \      for(chr <- paren_string.toList) {\n            if(chr.equals(\"(\")) {\n\
    \                groups.append(chr)\n            } else if(chr.equals(\")\"))\
    \ {\n                if(groups.nonEmpty) {\n                    val last_group\
    \ = groups.pop\n                    if(last_group.equals(\"(\")) {\n         \
    \               groups.append(last_group)\n                    } else {\n    \
    \                    groups.append(last_group)\n                    }\n      \
    \          }\n            }\n        }\n        return groups", "        if(paren_string.isEmpty)\
    \ List() else {\n            var groups = mutable.ListBuffer[String]()\n     \
    \       var opening_braces : Int = paren_string.count('(')\n            var closing_braces\
    \ : Int = paren_string.count(')')\n            paren_string.grouped(paren_string.length).foreach(c\
    \ => {\n                val index = c.toInt\n                if(c.char == '(')\
    \ {\n                    opening_braces += 1\n                } else if(c.char\
    \ == ')') {\n                    closing_braces -= 1\n                }\n    \
    \            if(!opening_braces && !closing_braces) {\n                    groups\
    \ += c.drop(index)\n                }\n            })\n            groups.toList\n\
    \        }", "        def unbalanced(paren_string : String) : Boolean = {\n  \
    \          paren_string.matches(\".*[^()]+.*\")\n        }\n\n        def balanced(paren_string\
    \ : String) : Boolean = {\n            paren_string.matches(\".*[(].*[)]\")\n\
    \        }\n\n        def isBalanced(paren_string : String) : Boolean = {\n  \
    \          unbalanced(paren_string) && balanced(paren_string)\n        }\n\n \
    \       def balancedParenGroups(paren_string : String) : List[String] = {\n  \
    \          paren_string.substring(1).split(\"\\\\(\").map(x => x.substring(0,1))\n\
    \        }\n\n        val paren_strings = paren_string.split(\"\\\\(\")\n\n  \
    \      var result: List[String] = Nil\n\n        val counter = paren_strings.length\n\
    \n        for(i <- 0 until counter) {\n            var paren_string = paren_strings(i)\n\
    \            val newParens = if (!balancedParenGroups(paren_string)) {\n     \
    \           result :+ paren_string\n            } else {\n                val\
    \ nextParens = paren_string.substring(1).split(\"\\\\)\")\n                paren_string\
    \ = paren_string.substring(0,1)\n                nextParens.map(balancedParenGroups)\n\
    \            }\n\n            if (unbalanced(paren_string) || !isBalanced(paren_string)\
    \ || paren_string == \"\") {\n                result :+ paren_string\n       \
    \     }\n        }\n        result", "        def stack: List[String] = Nil\n\
    \        def popStack: List[String] = Nil\n\n        val parens = paren_string.split(\"\
    \\\\)|\\\\(|)\")\n        val output: List[String] = Nil\n        var paren_stack:\
    \ List[String] = Nil\n        var paren_output = Nil\n        var paren_output_len\
    \ = 0\n        parens.foreach { x =>\n            paren_stack.push(x)\n      \
    \      if (x.equals(\"(\")) {\n                paren_output += x\n           \
    \     paren_output_len += 1\n            } else if ((x.equals(\")\")) || (x.equals(\"\
    ))\"))) {\n                paren_output_len -= 1\n                paren_output\
    \ += paren_stack.pop()\n            }\n            if (paren_stack.isEmpty) {\n\
    \                paren_output += x\n                paren_output_len += 1\n  \
    \          }\n        }\n        if (paren_stack.isEmpty) {\n            paren_output\
    \ += paren_stack.pop()\n        }\n        paren_stack.foreach(x => output +=\
    \ x)\n        output", "        // Create a stack representing the paren_string\
    \ in reverse order.\n        // While the stack is not empty and there is something\
    \ at the top of the stack.\n        // Add whatever is at the top of the stack\
    \ into the new list we return at the end.\n        // The new list will be reverse\
    \ sorted at the end.\n        // When we reach the end of the string, we have\
    \ the final result in the list we return.\n        val paren_stringReverse = paren_string.reverse\n\
    \        var paren_stack = Stack[String]()\n        paren_stringReverse.foreach(x\
    \ => if(x != \")\") paren_stack push x)\n        var new_strings = List[String]()\n\
    \        var paren_stack_size = paren_stack.size\n        var new_strings_size\
    \ = new_strings.size\n        while(paren_stack_size > 0 && new_strings_size <\
    \ paren_stringReverse.size) {\n            if(paren_stack.peek() == \"(\") {\n\
    \                paren_stack = paren_stack.pop()\n                paren_stack_size\
    \ -= 1\n            } else if(paren_stack.peek() == \")\") {\n               \
    \ paren_stack.push(\")\")\n                paren_stack_size -= 1\n           \
    \     new_strings = new_strings :+ paren_stack.pop()\n            } else {\n \
    \               paren_stack.push(\")\")\n                paren_stack_size -= 1\n\
    \                new_strings = new_strings :+ paren_stack.pop()\n            }\n\
    \            new_strings_size += 1\n        }\n        new_strings.reverse"]
stop_tokens:
- "\n    }\n"
