name: HumanEval_55_fib
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return n-th Fibonacci number.\n    // >>> fib((10l))\n    // (55l)\n   \
  \ // >>> fib((1l))\n    // (1l)\n    // >>> fib((8l))\n    // (21l)\n    def fib(n\
  \ : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(fib((10l)) == (55l));\n\
  \    assert(fib((1l)) == (1l));\n    assert(fib((8l)) == (21l));\n    assert(fib((11l))\
  \ == (89l));\n    assert(fib((12l)) == (144l));\n    }\n\n}\n"
completions: ["        var a = 1l\n        var b = 2l\n        while (n > 2l) {\n\
    \            var tmp = a\n            a = b\n            b = tmp + b\n       \
    \     n -= 1\n        }\n        a", "        val a = mutable.ListBuffer(1l, 2l)\n\
    \        val b = mutable.ListBuffer(1l, 2l)\n        val c = mutable.ListBuffer(1l,\
    \ 2l)\n        val d = mutable.ListBuffer(1l, 2l)\n        a(n-1) += b(n-1)\n\
    \        b(n-1) += c(n-1)\n        c(n-1) += d(n-1)\n        d(n-1) += a(n-1)\
    \ + b(n-1) + c(n-1) + d(n-1)\n        a(n-1)", "        if (n == 0 || n == 1)\
    \ \n            1\n        else if (n == 2) \n            1\n        else\n  \
    \          fib(n - 1) + fib(n - 2)", "        val fibs = mutable.ArrayBuffer(1L,\
    \ 2L)\n        for (i in 0 to n) {\n            fibs += fibs.head\n        }\n\
    \        fibs.last", "        // To save memory, keep an array that stores the\
    \ current two Fibonacci numbers.\n        var a = mutable.ArrayBuffer(0L, 1L)\n\
    \        var b = mutable.ArrayBuffer(0L, 1L)\n        val len = a.length\n   \
    \     val len2 = b.length\n        for(i <- 0 until len) {\n            a(i) =\
    \ a(i) + b(i) // Add two fibonacci numbers.\n            b(i) = a(i) - b(i) //\
    \ Subtract two fibonacci numbers.\n        }\n        val ret = nth // Return\
    \ the n-th Fibonacci number if n is valid; else return 0L.\n        if(ret !=\
    \ len2) { // (If n is invalid, we have returned n times the same number.)\n  \
    \          return 0L\n        } else {\n            a.init.toList // Convert to\
    \ a list.\n        }\n        return a(0)", "        val fibSeq = mutable.Stack[Long]()\n\
    \        fibSeq push 1l\n        fibSeq push 0l\n        fibSeq push 0l\n    \
    \    while(fibSeq.length <= n) {\n            val top = fibSeq.peek\n        \
    \    val newTop = top + fibSeq.pop\n            fibSeq push newTop\n        }\n\
    \        fibSeq.last", "        var a : Long = 0\n        var b : Long = 1\n \
    \       var c : Long = 1\n\n        for {\n            i <- 0 until n\n      \
    \  } yield {\n            c = a + b\n            a = b\n            b = c\n  \
    \          c\n        }", "        val nums = mutable.ArrayBuffer[(Long, Long)]()\n\
    \        nums += ((1l, 1l))\n        nums += ((2l, 1l))\n        var i = 0\n \
    \       while (i <= n) {\n            nums += nums.head._1 -> nums.head._1 + nums.head._2\n\
    \            i += 1\n        }\n        nums.head._2", "        if (n<2l) return\
    \ 1l\n        if (n>2l) return fib(2l) + fib(1l-1)", "        if (n<=0) throw\
    \ new Exception(\"fib function argument 'n' must be positive.\")\n        if (n==1)\
    \ return 1\n        if (n==2) return 1l\n        val nums = Vector(fib(n-1) +\
    \ fib(n-2))\n        nums(n)", "        // Base cases for n <= 0 and n >= 2 are\
    \ handled separately.\n        if (n <= 0) 1\n        else if (n >= 2) 2\n   \
    \     else fib(n-1) + fib(n-2)", "        if (n==0) 1\n        else if (n==1)\
    \ 1\n        else fib(n-2) + fib(n-1)", "      if (n == 0 || n == 1) {\n     \
    \   n\n      }\n      else {\n        fib(n - 1) + fib(n - 2)\n      }", "   \
    \     val fibs: Seq[Long] = Seq(1l,2l,3l,5l,8l,13l,21l)\n        if (fibs.size\
    \ <= n) fibs(n)\n        else fib(fibs.tail).+(fib(fibs.init))", "        if (n\
    \ == 0)\n            return 1\n        else if (n == 1)\n            return 1\n\
    \        else\n            return fib(n-1) + fib(n-2)", "        val a = scala.math.BigInt(0)\n\
    \        val b = scala.math.BigInt(1)\n        var tmp = 0\n\n        if (n <\
    \ 2) return n\n        while (tmp < n) {\n            tmp = a\n            a =\
    \ a + b\n            b = tmp + b\n        }\n\n        return a", "        //\
    \ base case\n        if (n == 0 || n == 1)\n            return n\n        else\n\
    \            // recursive case\n            return fib(n-1) + fib(n-2)", "   \
    \     if (n <= 1l) {\n            return n\n        }\n        return fib(n -\
    \ 1) + fib(n - 2)", "        if (n==0) 0\n        else if (n==1) 1\n        else\
    \ fib(n-1) + fib(n-2)", "        val cache = mutable.LinkedHashMap[Int, Long]()\n\
    \        cache.put(0, 1l)\n        if (cache.containsKey(n)) {\n            return\
    \ cache.get(n)\n        }\n        val fib0 = (fib(n-1) + fib(n-2))\n        cache.put(n,\
    \ fib0)\n        fib0", "        val fib_nums = mutable.MutableList[Long](1l,1l)\n\
    \        var i = 0\n        var j = 1\n        while(i < n) {\n            j +=\
    \ fib_nums(i)\n            fib_nums(i) = j\n            i += 1\n        }\n  \
    \      fib_nums(n-1)", "        val n2 = n+n\n        val n3 = n2+n2\n       \
    \ val n4 = n3+n3\n        val n5 = n4+n4\n        n5", "        var a : Long =\
    \ 0l\n        var b : Long = 1l\n        for(i <- 0 to n-1){\n          val temp\
    \ = a\n          a = b\n          b = temp + a\n        }\n        b\n      }\n\
    \n    def main(args: Array[String]) {\n        val l = fib(10l)\n        println(l)",
  '        if(n<=1) n else fib(n-1)+fib(n-2)', "        // Initialize Fib(n).\n  \
    \      // Note that Fib(0) = 0 and Fib(1) = 1.\n        val Fib : mutable.Long\
    \ = mutable.Long(0);\n        val Fib1 : int = Fib + 1;\n\n        // Update Fib(n).\n\
    \        // Fib(n) = Fib(n-1) + Fib(n-2) + 1.\n        while (Fib > n)\n     \
    \   {\n            Fib.update(Fib1 - 1);\n            Fib1.update(0);\n      \
    \      Fib1.update(1);\n        }\n        Fib", "        val a = 1;\n       \
    \ val b = 1;\n        var i = 1;\n        var x = a\n        while ( i <= n )\
    \ {\n            x =  ( a + b )\n            i += 1\n            b = a\n     \
    \       a = x\n        }\n        return x", "        if (n <= 0) 0\n        else\
    \ if (n == 1) 1\n        else fib(n-1) + fib(n-2)", "      def fib_seq(n : Long)\
    \ =\n        if (n <= 1) 1\n        else fib_seq(n - 1) + fib_seq(n - 2)\n   \
    \   fib_seq(n)", "        val fibs: mutable.Set[Long] = mutable.Set()\n      \
    \  // Set fibs to contain all Fibonacci numbers up to n.\n        fibs.add(0l)\n\
    \        fibs.add(1l)\n        for (i <- 2 to n) {\n            fibs.add(i + fibs.head)\n\
    \        }\n        fibs.head", "        val rec : Long => Long = { rec : Long\
    \ =>\n            if (n <= 1) rec(n)\n            else rec(n-1) + rec(n-2)\n \
    \       }\n        rec(0l)", "        if (n <= 1L)\n            1L\n        else\n\
    \            fib(n - 1) + fib(n - 2L)", "        val l = n.toInt\n        var\
    \ prev = 0\n        var current = 1\n        for(i <- 1 until l)\n        {\n\
    \            prev = current\n            current = current + prev\n        }\n\
    \        current", "        var fib0 = 1L\n        var fib1 = 1L\n        var\
    \ fib2 = 1L\n        var fib3 = 1L\n        var fib4 = fib0\n        fib0 += (fib1\
    \ + fib2)\n        fib1 = fib0\n        fib0 += fib3\n        fib1 = fib0\n  \
    \      fib0 += fib4\n        fib3 = fib0\n        fib0 += fib4\n        fib3 =\
    \ fib0\n        fib4 = fib0\n        fib0 += fib3\n        fib3 = fib0\n     \
    \   fib0 += fib4\n        fib4 = fib0\n        fib0 += fib4\n        fib4 = fib0\n\
    \        fib0 += fib3\n        fib3 = fib0\n        fib0 += fib4\n        fib4\
    \ = fib0\n        fib0 += fib4\n        fib4 = fib0\n        fib0 += fib3\n  \
    \      fib3 = fib0\n        fib0 += fib4\n        fib4 = fib0\n        fib0 +=\
    \ fib4\n        fib4 = fib0\n        fib0 += fib3\n        fib3 = fib0\n     \
    \   fib0 += fib4\n        fib4 = fib0\n        fib0 += fib4\n        fib4 = fib0\n\
    \        fib0 += fib3\n        fib3 = fib0\n        fib0 += fib4\n        fib4\
    \ = fib0\n        fib0 += fib4\n        fib4 = fib0\n        fib0 += fib3\n  \
    \      fib3 = fib0\n        fib0 += fib4\n        fib4 = fib0\n        fib0 +=\
    \ fib4\n        fib4 = fib0\n        fib0 += fib3\n        fib3 = fib0\n     \
    \   fib0 += fib4\n        fib4 = fib0\n        fib0 += fib4\n        fib4 = fib0\n\
    \        fib0 += fib3\n        fib3 = fib0\n        fib0 += fib4\n        fib4\
    \ = fib0\n        fib0 += fib4\n        fib4 = fib0\n        fib0 += fib3\n  \
    \      fib3 = fib0\n        fib0 += fib4\n        fib4 = fib0\n        fib0 +=\
    \ fib4\n        fib4 = fib0\n        fib0 += fib3\n        fib3 = fib0\n     \
    \   fib0 += fib4\n        fib4 = fib0\n        fib0 += fib4\n        fib4 = fib0\n\
    \        fib0 += fib3\n        fib3 = fib0\n        fib0 += fib4\n        fib4\
    \ = fib0\n        fib0 += fib4", "        require(n > 1, \"fib: n is invalid\"\
    )\n        if (n <= 1) 1\n        else fib(n-1) + fib(n-2)", "        if (n <\
    \ 0) throw new IllegalArgumentException(s\"Negative number $n\")\n        if (n\
    \ <= 2) n\n        else\n            {val f1 = fib(n - 1l) ; val f2 = fib(n -\
    \ 2l) ; f1 + f2}", "        if (n == 0) 0\n        else if (n == 1) 1\n      \
    \  else fib(n-1) + fib(n-2)", "        val memo = new Array[Long](2l)\n      \
    \  (memo(0)), (memo(1))\n        val x = memo.indexOf((memo(1) + memo(2))) % memo.length\n\
    \        memo(x)", "        if (n <= 0L) {\n            return 0L\n        }\n\
    \        val a = mutable.ArrayBuffer(2L); a.append(1L); a.append(0L)\n       \
    \ val b = mutable.ArrayBuffer(2L); b.append(0L); b.append(1L)\n        while (a(1)\
    \ < n ) {\n            val a : mutable.ArrayBuffer[Long] = a\n            val\
    \ b : mutable.ArrayBuffer[Long] = b\n            val sum : Long = (a(1) + (b(1))).toInt\n\
    \            val index : Int = (sum - a(1)) + 1\n            val value : Long\
    \ = a.slice(index, index+1).sum\n            val i : Long = value.toLong\n   \
    \         if (sum > n) {\n                val t : mutable.ArrayBuffer[Long] =\
    \ b\n                val u : mutable.ArrayBuffer[Long] = a\n                u.concat(t.slice(1,\
    \ t.size))\n                return value\n            }\n            a.append(value)\n\
    \            b.append(value)\n        }\n        a", "        val n = if(n < 2)\
    \ 1 else n\n        val fib_matrix = mutable.ArrayBuffer(\n            mutable.ArrayBuffer(0,\
    \ 1),\n            mutable.ArrayBuffer(0, 1)\n        )\n        for (i <- 0 until\
    \ n) {\n            fib_matrix += i to 0\n        }\n        fib_matrix += 1 to\
    \ 1\n        fib_matrix += 2 to 2\n        fib_matrix += 3 to 3\n        fib_matrix\
    \ += 4 to 5\n        fib_matrix += 5 to 8\n        fib_matrix += 6 to 13\n   \
    \     fib_matrix += 7 to 21\n        fib_matrix += 8 to 34\n        fib_matrix\
    \ += 9 to 55\n        fib_matrix += 10 to 89\n        fib_matrix += 11 to 144\n\
    \        fib_matrix += 12 to 233\n        fib_matrix += 13 to 377\n        fib_matrix\
    \ += 14 to 610\n        fib_matrix += 15 to 987\n        fib_matrix += 16 to 1597\n\
    \        fib_matrix += 17 to 2584\n        fib_matrix += 18 to 4181\n        fib_matrix\
    \ += 19 to 6765\n        fib_matrix += 20 to 10946\n        fib_matrix += 21 to\
    \ 17711\n        fib_matrix += 22 to 28657\n        fib_matrix += 23 to 46368\n\
    \        fib_matrix += 24 to 75025\n        fib_matrix += 25 to 121393\n     \
    \   fib_matrix += 26 to 196418\n        fib_matrix += 27 to 317811\n        fib_matrix\
    \ += 28 to 514229\n        fib_matrix += 29 to 832040\n        fib_matrix += 30\
    \ to 1346269\n        fib_matrix += 31 to 2036501\n        fib_matrix += 32 to\
    \ 2971215\n        fib_matrix += 33 to 4150783\n        fib_matrix += 34 to 6755103\n\
    \        fib_matrix += 35 to 10946301\n        fib_matrix += 36 to 17711773\n\
    \        fib_matrix += 37 to 28657143\n        fib_matrix += 38 to 41810671\n\
    \        fib_matrix += 39 to 67650071\n        fib_matrix += 40 to 109466301\n\
    \        fib_matrix += 41 to 177086663\n        fib_matrix += 42 to 286572237\n\
    \        fib_matrix += 43 to 418110767\n        fib_matrix += 44 to 675501093",
  "        var a = 2L\n        var b = 3L\n        var tmp = b\n        while(tmp\
    \ <= n) {\n            tmp = a\n            a = a + b\n            b = tmp\n \
    \       }\n        return a", "        val memo: mutable.HashMap[Long, Long] =\
    \ mutable.HashMap(0 -> 0, 1 -> 1)\n        val fib_cache: mutable.HashMap[Long,\
    \ Long] = mutable.HashMap(0 -> 0)\n        def fib_aux(n : Long, cache: mutable.HashMap[Long,\
    \ Long]) : Long = {\n            val fib : Long = cache.get(n)\n            if\
    \ (fib == null) {\n                val result = fib_aux(n + (n % 2), cache) +\
    \ fib_aux(n - (n % 2), cache)\n                cache.put(fib_aux(n + (n % 2),\
    \ cache), result)\n                result\n            } else {\n            \
    \    fib\n            }\n        }\n        fib_aux(n, memo)", "        var a\
    \ = 2l;\n        var b = 1l;\n        var sum = 0L;\n        while (true) {\n\
    \            sum += b\n            if (sum > n) break;\n            b = a;\n \
    \           a = a + b;\n        }\n        return sum", "        if (n <= 2) 1\n\
    \        else fib(n-1) + fib(n-2)", "        var result = 1L\n        var temp2\
    \ = 0L\n        while (temp2 < n) {\n            result = result + temp2\n   \
    \         temp2 = temp2 + 1L\n        }\n        result", "        val x = 0\n\
    \        val y = 0\n        while( x < n ){\n            val temp = x\n      \
    \      x = y + x\n            y = temp\n        }\n        y", "        var fibs\
    \ = [1l,2l,3l,5l,8l] \n        while(fibs.size < n) fibs = fibs.++:(fibs.drop(1)\
    \ + fibs.drop(2))\n        fibs(n)", "        val fib: mutable.MutableList[Long]\
    \ = mutable.MutableList.empty[Long]\n        fib(0) = 0\n        fib(1) = 1\n\
    \        fib.add(2)\n        fib.add( fib(0)+fib(1)) \n        while (fib.size\
    \ < n) { fib.add(fib(0) + fib(1))}\n        fib(n) ", "        if(n<0L || n>20)\
    \ -1L\n        else (n>0L) ? fib(n-1L) + fib(n-2L) : n", "        var a = 0l\n\
    \        var b = 5l\n        var i = 0l\n        while (i < n) {\n           \
    \ val temp = a\n            a = b\n            b = temp + b\n            i +=\
    \ 1\n        }\n        a", "        def fib_aux (n1 : Long, n2 : Long) : Long\
    \ = {\n            if (n1 < n2) \n                fib_aux(n1+n2, n1)\n       \
    \     else \n                n2\n        }\n        return fib_aux(n, 1l)", " \
    \       val a = mutable.ArrayBuffer.empty[Long]\n        val b = mutable.ArrayBuffer.empty[Long]\n\
    \        a(0) = 0\n        a(1) = 1\n        b(0) = 1\n        var n = 0\n   \
    \     while (n < n){\n            n += 1\n            a += b(0)\n            b\
    \ += b(1)\n        }\n        a(0)", "        def fib_iter(n: Long, n1: Long,\
    \ n2: Long): Long = {\n            if (n == 0) n1\n            else {\n      \
    \          val newN = n1 + n2\n                fib_iter(n + 1, n1, newN)\n   \
    \         }\n        }\n        fib_iter(n, n, n).asInstanceOf[Long]", "     \
    \   def fib1(n: Long, x: Long, y: Long): Long = {\n            if(n == 0) x\n\
    \            else fib1(n-1, x+1, y+x)\n        }\n        fib1(n.toInt, 1l, 1l)",
  "        var last = 1\n        var next = 2\n        var sum = 0\n        while\
    \ (n > 2) {\n            sum += next\n            next += last\n            last\
    \ = next\n            n -= 1\n        }\n        sum", "        if (n < 2) 1\n\
    \        else fib(n-1) + fib(n-2)", "        var fibonacci : Long = 0l\n     \
    \   var fibonacciTail = 0l\n        if (n <= 2l)\n            fibonacciTail =\
    \ 0l\n        else if (n == 2l)\n            fibonacciTail = 1l\n        else\n\
    \            fibonacciTail = fibonacciTail + fibonacciTail\n            fibonacci\
    \ = fibonacciTail + fibonacci\n            fibonacciTail = fibonacciTail + fibonacciTail\n\
    \            fibonacciTail = fibonacciTail + fibonacciTail\n            fibonacciTail\
    \ = fibonacciTail + fibonacciTail\n            fibonacciTail = fibonacciTail +\
    \ fibonacciTail\n            fibonacciTail = fibonacciTail + fibonacciTail\n \
    \           fibonacciTail = fibonacciTail + fibonacciTail\n            fibonacciTail\
    \ = fibonacciTail + fibonacciTail\n            fibonacciTail = fibonacciTail +\
    \ fibonacciTail\n            fibonacciTail = fibonacciTail + fibonacciTail\n \
    \           fibonacciTail = fibonacciTail + fibonacciTail\n            fibonacciTail\
    \ = fibonacciTail + fibonacciTail\n            fibonacciTail = fibonacciTail +\
    \ fibonacciTail\n            fibonacciTail = fibonacciTail + fibonacciTail\n \
    \           fibonacciTail = fibonacciTail + fibonacciTail\n            fibonacciTail\
    \ = fibonacciTail + fibonacciTail\n            fibonacciTail = fibonacciTail +\
    \ fibonacciTail\n            fibonacciTail = fibonacciTail + fibonacciTail\n \
    \           fibonacciTail = fibonacciTail + fibonacciTail\n            fibonacciTail\
    \ = fibonacciTail + fibonacciTail\n            fibonacciTail = fibonacciTail +\
    \ fibonacciTail\n            fibonacciTail = fibonacciTail + fibonacciTail\n \
    \           fibonacciTail = fibonacciTail + fibonacciTail\n            fibonacciTail\
    \ = fi", "        if (n <= 0) 1\n        else if (n <= 1) 1\n        else fib(n\
    \ - 1) + fib(n - 2)", "        // Factor not found.\n        if (n < 2) 1\n  \
    \      // Factor not found.\n        else if (n <= 3) return n\n        // Factor\
    \ not found.\n        else if (n % 2 == 0) fib(n - 1) + fib(n - 2)\n        //\
    \ Factor not found.\n        else fib(n / 2) + fib(3 * n / 2)", "        var fib1\
    \ : Long = 1\n        var fib2 : Long = 1\n        var fib_list : mutable.ListBuffer[Long]\
    \ = new mutable.ListBuffer[Long]()\n        fib_list += fib2\n        fib_list\
    \ += fib1\n        var sum : Long = 1\n        while (fib2 <= n){\n          \
    \  fib2 = fib1 + fib2\n            fib_list += fib2\n            sum += fib2\n\
    \        }\n        fib_list.sum", "        if (n <= 1) 1\n        else fib(n-1)\
    \ + fib(n-2)", "        if (n<2)\n            return n\n        else\n       \
    \     return fib(n-1) + fib(n-2)", "        val fib = new mutable.ArrayBuffer[Long](2l,\
    \ (3l - 2l), 1l)\n        for (x <- 1 to n-1)\n            fib += fib(fib(fib.last))\n\
    \        fib.last", "        var a: Long = 1\n        var b: Long = 1\n      \
    \  var c: Long = 1\n        var i: Long = 1\n        while (i <= n) {\n      \
    \      c = a + b\n            a = b\n            b = c\n            i = i + 1\n\
    \        }\n        c", "        if (n < 2l)\n            1l\n        else\n \
    \           fib(n - 1) + fib(n - 2l)", "        if (n <= 0) 0\n        else if\
    \ (n == 1) 1\n        else fib(n-1) + fib(n-2)", "        if (n <= 1) 1\n    \
    \    else fib(n - 1) + fib(n - 2)", "        var n1 = 1l\n        var n2 = 1l\n\
    \        var n3 = 1l\n        var n4 = 1l\n        var ret = 0l\n        if(n\
    \ < 2l) ret = 1l\n        else {\n            var k = 0l\n            while(n<4l)\
    \ {\n                n3 = n1+n2\n                n2 = n1\n                n1 =\
    \ n3\n                k = k+1\n                if((k%5l) == 0) ret = (n3).toLong\n\
    \            }\n            n4 = ret\n        }\n        n4", "        val nums\
    \ = scala.collection.mutable.ListBuffer(1, 1, 2)\n        val result = nums.takeWhile(_\
    \ < n)\n        if (result ne nums) {\n            fib(n, result)\n        } else\
    \ {\n            result\n        }", "        val cache = mutable.LinkedHashMap[Long,\
    \ Int]()\n        def lookup(x: Long) : Int = cache.get(x)\n        if (cache.size\
    \ < n)\n            lookup(0)\n        else\n            cache.updated(n, lookup(n\
    \ + 1) + lookup(n))", "        if (n == 0) 0\n        else fib(n - 1) + fib(n\
    \ - 2)", "        var a = 2\n        var b = 1\n        var c = 1\n        var\
    \ ret: Long = 1\n        while (n < 2l) {\n            var tmp = c\n         \
    \   c = a + b\n            a = b\n            b = tmp\n            n += 1\n  \
    \      }\n        ret", "        def fib2(n: Long, acc: Long): Long = \n     \
    \       if (n == 0) acc\n            else fib2(n - 1, acc + n)\n        fib2(n,\
    \ 0)", "        // The first two numbers in the Fibonacci sequence are 0 and 1.\n\
    \        var i = 0\n        var j = 1\n        while (i <= n) {\n            //\
    \ We want the second number in the sequence.\n            j += 1\n           \
    \ i += j\n        }\n        // Now we want the nth number. Remember that the\
    \ number in the Fibonacci\n        // sequence is also the sum of the previous\
    \ two numbers. So if we\n        // want to know the nth number in the Fibonacci\
    \ sequence, we need\n        // to add the previous two numbers.\n        val\
    \ fib: Long = j + i\n        return fib", "       val fibs = mutable.ArrayBuffer(0,1)\n\
    \       for {\n         i <- 0 to n\n         j <- 1 to i\n         fibs(j) <-\
    \ fibs(j) + fibs(j-1)\n       } yield fibs(n)", "        // Initializing with\
    \ 0 is required since we are using recursion here.\n        // Also using 'if'\
    \ instead of 'case' will make code more readable\n        // and avoid writing\
    \ a lot of 'breaks' in the code.\n        if( n == 0l ) return 0\n        if(\
    \ n == 1l ) return 1\n        if( n < 2l ) return fib(n - 2l) + fib(n - 1l)\n\n\
    \        // Return n-th Fibonacci number using recursion.\n        // Each time\
    \ the function is called, \n        // the previously returned value should be\
    \ returned again.\n        // For example, fib(2) -> fib(1) + fib(0) \n      \
    \  //                  -> fib(1) + fib(1) \n        //                  -> fib(1)\
    \ + fib(2) + fib(1) \n        //                  -> ...\n        fib(n - 1l)\
    \ + fib(n - 2l) // Recursive call", "        val fibs = new mutable.HashSet[Long]\n\
    \        var fibs2 = new mutable.HashSet[Long]\n        var a = fibs.head\n  \
    \      var b = fibs.tail.head\n        fibs.clear()\n        while (fibs.size()\
    \ < n){\n            fibs2 += b\n            b = a\n            a = fibs2.head\n\
    \            fibs2.clear()\n        }\n        a", "        var fibVal : Long\
    \ = 0\n        var fibSeq : mutable.Seq[Long] = null\n        if(n==0) fibSeq\
    \ = Seq(fibVal)\n        else {\n            fibSeq = fibSeq.::(fib(n - 1))\n\
    \            fibVal = fibSeq.last\n        }\n        fibVal", "        val n1:\
    \ Long = n - 1l\n        val n2: Long = n - 2l\n        if (n2 == 0l) n1\n   \
    \     else fib(n1) + fib(n2)", "        def fibs(n: Long, acc: Long): Long = n\
    \ match {\n            case 0 => acc\n            case 1 => acc\n            case\
    \ 2 => acc\n            case x => fibs(n - 1, acc + x)\n        }\n        fibs(n,\
    \ 0l)", "        val fibArray = mutable.ArrayBuffer.fill(n+1){0 }\n        fibArray(1)\
    \ = 1\n        fibArray(2) = 1\n        fibArray.drop(1).dropRight(1){\n     \
    \       i =>\n            val nextFib = fibArray(i-1)+fibArray(i-2)\n        \
    \    fibArray(i) = nextFib\n            nextFib\n        }.get", "        def\
    \ getFib(n: Long, a: Long, b: Long) = {\n            if (n == 0) a\n         \
    \   else getFib(n-1, b, a+b)\n        }\n        getFib(n,0,1)", "        val\
    \ fib0 = fibonacci(0)\n        val fib1 = fibonacci(1)\n        val fib2 = fibonacci(2)\n\
    \        val fib3 = fibonacci(3)\n        val fib4 = fibonacci(4)\n        val\
    \ fib5 = fibonacci(5)\n        val fib6 = fibonacci(6)\n        val fib7 = fibonacci(7)\n\
    \        val fib8 = fibonacci(8)\n        val fib9 = fibonacci(9)\n        val\
    \ fib10 = fibonacci(10)\n        if (n == 0) fib0\n        else fibonacci(fib0.get(n).get(n\
    \ + 1).get(n + 2).get(n + 3).get(n + 4))", "        var f : Long = 0\n       \
    \ var s : Long = 1\n        var i : Long = 1\n        while (i <= n) {\n     \
    \       f = f + s\n            s = s + f\n            i = i + 1\n        }\n \
    \       f", "        var a = 2\n        var b = 1\n        var ret = n\n     \
    \   while (n > 1) {\n            ret = a + b\n            b = a\n            a\
    \ = ret\n            n -= 1\n        }\n        ret", "        val fibs = mutable.ArrayBuffer(0)\n\
    \        fibs += 0\n        fibs += 1\n        n match {\n            case 0 |\
    \ 1 => fibs(0)\n            case x => fibs(x) match {\n                case 0\
    \ | 1 => fibs(0)\n                case x => fibs(x - 1) + fibs(x - 2)\n      \
    \      }\n        }", '        if (n == 1l) 1l else fib(n-2) + fib(n-1)', "  \
    \    if (n <= 2L) 1L\n      else fib(n-2) + fib(n-1)", "        val first = 0\n\
    \        val second = 1\n        val fibs = new mutable.ListBuffer[Long]()\n \
    \       fibs.update(0, first)\n        fibs.update(1, second)\n        fibs foreach\
    \ { _ =>\n            if (n < 0) {\n                fibs(0) += fibs(1)\n     \
    \           fibs(1) = 0\n            } else {\n                val f = fibs(0)\
    \ - fibs(1)\n                fibs(0) = fibs(1)\n                fibs(1) = f\n\
    \            }\n        }\n        fibs.apply(n)", "        val nfib = mutable.Stack[Long]()\n\
    \        nfib.push(0l)\n        nfib.push(1l)\n        while (n > 0) {\n     \
    \       val current = nfib.last()\n            nfib.push(current + nfib.last())\n\
    \            n -= 1\n        }\n        nfib.last()", "        var fib : BigInt\
    \ = BigInt(1)\n        var fib1 = BigInt(2)\n        for(i <- 2 to n-1){\n   \
    \         fib = fib1 + fib\n            fib1 = fib\n        }\n        return\
    \ fib", "        if (n == 1l) 1l\n        else fib((n - 1l) + fib((n - 2l)))",
  "        val fibonacci = new collection.mutable.TreeMap[Long, Long]()\n        fibonacci.put(0l,\
    \ 1l)\n        fibonacci.put(1l, 1l)\n        n -= 2\n        n match {\n    \
    \        case 0 => fibonacci.get(0l)\n            case 1 => fibonacci.get((1l))\n\
    \            case 2 => fibonacci.get(fibonacci.get((1l)))\n            case _\
    \ => fibonacci.get(fibonacci.get((fibonacci.get((1l))) + fibonacci.get((0l))))\n\
    \        }", "        if (n == 0) 1\n        else if (n == 1) 1\n        else\
    \ fib(n-1) + fib(n-2)", "        if (n < 2)\n            n\n        else\n   \
    \         fib(n-1) + fib(n-2)", "        // We use a mutable.ArrayBuffer to keep\
    \ track of the previous two numbers.\n        val buffer = new mutable.ArrayBuffer[Long]()\n\
    \        buffer.append(0L)\n        buffer.append(1L)\n        var next = 1L\n\
    \        while (buffer.length < n) {\n            next = buffer.last + next\n\
    \            buffer += next\n        }\n        buffer.dropRight(n).toList //\
    \ List the required number of elements", '        if (n < 2l) 1l else fib(n -
    2l) + fib(n - 1l)', "        var prev = 0\n        var current = 1\n        var\
    \ next = 1\n\n        for (i <- 1 to n) {\n            val next = prev + current\n\
    \            prev = current\n            current = next\n        }\n\n       \
    \ next", "        var a : Long = 1l\n        var b : Long = 1l\n        var tmp\
    \ : Long = 1l\n\n        if (n <= 1l) {\n            return n\n        } else\
    \ {\n            while (n != 0l) {\n                tmp = a ;\n              \
    \  a = b ;\n                b = tmp + b ;\n                n -= 1l\n         \
    \   }\n            return b\n        }", "        // Your code goes here\n   \
    \     // You will need to use the fibonacci function from earlier\n        val\
    \ fibs = new Array[Long](n)\n        fibs(0) = 1\n        fibs(1) = 1\n      \
    \  for (i<-2 until fibs.length-1){\n            fibs(i) = fibs(i-1)+fibs(i-2)\n\
    \        }\n        fibs(fibs.length-1)", "        if (n <= 0) throw new IllegalArgumentException\n\
    \        val fibs = mutable.ListBuffer(1,0)\n        while(fibs.size < n) {\n\
    \            fibs = fibs +: fibs\n        }\n        fibs.last", "        val\
    \ fibs = mutable.ListBuffer(1)\n        (fibs ::: fibs).find(_._2 == fibs.length\
    \ + 1).map(_._1).getOrElse(n)", "        val fib = Stream.iterate(1L)(_ + _).takeWhile(_\
    \ <= n).head\n        println(n + \": \" + fib)\n        fib", "        // The\
    \ Fibonacci numbers are 0, 1, 1, 2, 3, 5, 8, 13, \u2026\n        val fibTable\
    \ = new mutable.LinkedHashMap[Int, Int]()\n        fibTable.put(0, 0); // 0th\
    \ Fibonacci is 0\n        fibTable.put(1, 1); // 1st Fibonacci is 1\n        fibTable.put(2,\
    \ 1); // 2nd Fibonacci is 1\n        var fibNum = 0\n        while (fibTable.size\
    \ < n){\n            // fibTable.put(n,fibTable.getOrElse(n-1,fibTable.getOrElse(n-2,0)\
    \ + fibTable.getOrElse(n-3,fibTable.getOrElse(n-4,0))))\n            fibNum =\
    \ fibTable.getOrElse(n-1,fibNum)\n            fibTable.put(n, fibNum)\n      \
    \  }\n        return fibNum", "        val x = scala.math.BigInt(n)\n        if\
    \ ((x == 0l) || (x == 1l)) {\n            return x\n        }\n        val y =\
    \ scala.math.BigInt(x) + 1\n        x := y\n        val z = scala.math.BigInt(x)\
    \ + 2\n        x := z\n        y", "      require(n > 0, \"Fibonacci number should\
    \ > 0!\")\n      var first = 0l\n      var second = 0l\n      loop {\n       \
    \ val sum = first + second\n        first = second\n        second = sum\n   \
    \     if (sum >= n)\n          return sum\n      }", "        val fibList = mutable.LinkedList[Long]()\n\
    \        fibList += 0\n        fibList += 1\n        while(fibList.size > n) {\n\
    \            fibList -= fibList(1)\n        }\n        fibList(n)", "        //\
    \ Base cases.\n        n match {\n            case 0 | 1 | 2 => 1\n          \
    \  case n => fib(n-1) + fib(n-2)\n        }", "        var f = 0l\n        var\
    \ s1 = 1l\n        var s2 = 1l\n        while (n > 0) {\n            f = (s1 +\
    \ s2) % n\n            s1 = s2\n            s2 = f\n            n -= 1\n     \
    \   }\n        f", "        var a : Long = 0l\n        var b : Long = 1l\n   \
    \     while (a < n) (a,b) = (a+b, b);\n        a", "        val cache = new Array[Long](n)\n\
    \        cache(0) = 0\n        cache(1) = 1\n        var i = 2\n        while\
    \ (i < n) {\n            cache(i % 2) = cache((i - 1) % 2) + cache((i + 1) % 2)\n\
    \            i = i + 1\n        }\n        cache(n % 2)", "        val fib = (0\
    \ until n).foldLeft((0l,0l))((t,x) => t._1 + t._2)\n        if (n <= 1) fib._1\n\
    \        else fib", "        if (n == 0) 0\n        else if (n == 1) 1\n     \
    \   else fib(n-1) + fib(n-2)", "        def fibRec(a : Long, b : Long, count :\
    \ Long) : Long = {\n            if (count == n) {\n                return b\n\
    \            }\n            else\n            {\n                return fibRec(b,\n\
    \                    a\n                    + b\n                    , count +\
    \ 1\n                )\n            }\n        }\n        fibRec(0, 0, 0)", " \
    \       if(n > 0) fib(n - 1) + fib(n - 2)\n        else 1", "        var sum =\
    \ 0l\n        var num = 1l\n        val fibSeq = Iterator.continually(num += 1).takeWhile(_\
    \ < n)\n        var fibSeq2 = fibSeq.map(i => if (i == 0) 0 else 1)\n        var\
    \ lastFib = fibSeq2.last\n        while (fibSeq2.nonEmpty) {\n            sum\
    \ += lastFib\n            fibSeq2.last = 0\n            lastFib = fibSeq2.last\n\
    \        }\n        sum", "        var i = 2\n        var f = 0\n        while\
    \ (i <= n) {\n            f += i\n            i += 1\n        }\n        f", " \
    \       if (n <= 1L) 1L\n        else fib(n-1L) + fib(n-2L)", "        var a =\
    \ 0l\n        var b = 1l\n        for (i <- 0 until n) {\n            val x =\
    \ a + b\n            a = b\n            b = x\n        }\n        x", '        if
    (n == 0) 1 else fib(n-1) + fib(n-2)', "        if (n <= 2) 1\n        else fib(n-1)\
    \ + fib(n-2)", "        // return if (n == 0 || n == 1) n else fib(n-1) + fib(n-2)\n\
    \        def fib(n: Int) : Int = {\n            if (n == 0 || n == 1) n else fib(n-1)\
    \ + fib(n-2)\n        }\n\n        // return if (n <= 2) n else fib(n-1) + fib(n-2)\n\
    \        def fib(n: Int) : Int = {\n            if (n <= 2) n else fib(n-1) +\
    \ fib(n-2)\n        }\n\n        // return if (n <= 2) n else fib(n-1) + fib(n-2)\n\
    \        def fib(n: Int) : Int = {\n            if (n <= 2) n else fib(n-1) +\
    \ fib(n-2)\n        }\n        val fibs = mutable.ListBuffer[Int]()\n        val\
    \ a = fib(0)\n        val b = fib(1)\n        fibs += a\n        fibs += b\n \
    \       fibs.drop(1).foreach(n => {\n            fibs += fib(n-1) + fib(n-2)\n\
    \        })\n        fibs.take(n).toList", "        val fib = mutable.MutableList[Long]()\n\
    \        var i = 0\n        fib.push(i)\n        while (i<n) fib.push(fib.last()\
    \ + fib.last())\n        fib.last", "        // Declare a variable named fibonacci\
    \ which has type scala.collection.mutable.ListBuffer.\n        var fibonacci =\
    \ new ListBuffer[Long]()\n        var current = 1\n        var next = 1\n\n  \
    \      // For each number smaller than n, call fibonacci function again with (current\
    \ + 1) until you reach n.\n        while (current < n) {\n            fibonacci\
    \ += next\n            current += next\n            next = current + current\n\
    \        }\n\n        // Return the last element of fibonacci.\n        fibonacci.last",
  "        val l = new mutable.LinkedList[Long]\n        l.headOption\n          \
    \  .foreach(n => {\n                if (n <= 2) l.addLast(n)\n               \
    \ else l.removeLast\n            })\n        l.headOption\n            .foreach(n\
    \ => {\n                l.addLast(l.headOption.getOrElse(1) + l.headOption.getOrElse(2))\n\
    \            })\n        l.headOption\n            .foreach(n => {\n         \
    \       if (n <= n) l.addLast(n)\n            })\n        l.headOption\n     \
    \       .foreach(n => {\n                l.addLast(l.headOption.getOrElse(1) +\
    \ l.headOption.getOrElse(2))\n            })\n        l.headOption\n         \
    \   .foreach(n => {\n                if (n <= n) l.addLast(n)\n            })\n\
    \        l.headOption\n            .foreach(n => {\n                l.addLast(l.headOption.getOrElse(1)\
    \ + l.headOption.getOrElse(2))\n            })\n        l.headOption\n       \
    \     .foreach(n => {\n                if (n <= n) l.addLast(n)\n            })\n\
    \        l.headOption\n            .foreach(n => {\n                l.addLast(l.headOption.getOrElse(1)\
    \ + l.headOption.getOrElse(2))\n            })\n        l.headOption\n       \
    \     .foreach(n => {\n                if (n <= n) l.addLast(n)\n            })\n\
    \        l.headOption\n            .foreach(n => {\n                l.addLast(l.headOption.getOrElse(1)\
    \ + l.headOption.getOrElse(2))\n            })\n        l.headOption\n       \
    \     .foreach(n => {\n                if (n <= n) l.addLast(n)\n            })\n\
    \        l.headOption\n            .foreach(n => {\n                l.addLast(l.headOption.getOrElse(1)\
    \ + l.headOption.getOrElse(2))\n            })\n        l.headOption\n       \
    \     .foreach(n => {\n                if (n <= n) l.addLast(n)\n            })\n\
    \        l.headOption\n            .foreach(n => {\n                l.addLast(l.headOption.getOrElse(1)\
    \ + l.headOption.getOrElse(2))\n            })\n        l.headOption\n       \
    \     .foreach(n => {\n                if (n <= n) l.addLast(n)\n            })\n\
    \        l.headOption\n            .foreach(n => {\n                l.addLast(l.headOption.getOrElse(1)\
    \ + l.headOption.getOrElse(2))\n            })\n        l.headOption\n       \
    \     .foreach(n => {\n                if (n <= n) l.addLast(n)\n            })\n\
    \        l.headOption\n            .foreach(n ", "        val a = 0l\n       \
    \ val b = 1l\n        for (x <- 0 until n) {\n            val c = b\n        \
    \    b <- a + c\n            a <- c\n        }\n        b", "        if (n <=\
    \ 2) {\n            return n\n        } else {\n            return fib(n - 1)\
    \ + fib(n - 2)\n        }", "        def fib1(n:Long, f:mutable.Queue[Long], s:mutable.Queue[Long],\
    \ n:Long) : Unit = {\n            if (n == 0)\n                f += 0\n      \
    \      else if (n == 1)\n                s += 0\n            else {\n        \
    \        fib1(n-1, f, s, n-2)\n                f += f(n-2) + f(n-1)\n        \
    \        s += s(n-2)+s(n-1)\n            }\n        }\n        var f = mutable.Queue[Long]()\n\
    \        var s = mutable.Queue[Long]()\n        fib1(n, f, s, n)\n        if (f.size\
    \ < n)\n            throw new Exception(\"Not found\")\n        f.dequeue", " \
    \       // Still to do\n        val fib = new mutable.HashSet[Long]()\n      \
    \  fib += (1 -> 1L)\n        fib += (0 -> 0L)\n        fib.foreach(x => fib +=\
    \ (x -> fib.get(x - 1) + fib.get(x - 2)))\n        fib.get(n)", "        if (n\
    \ < 0) throw new IllegalArgumentException(\"n is negative\")\n        if (n <\
    \ 2) n\n        else fib(n-1) + fib(n-2)", "        // We know that the Fibonacci\
    \ sequence converges to its first fibonacci number.\n        // So we can calculate\
    \ its first two numbers in O(1).\n        // The first two numbers are:\n    \
    \    // a = (a + b) / 2, b = b - a.\n        // If a = 0 then b = 1 and the first\
    \ fibonacci number is b.\n        val a = n\n        val b = n + 1\n        //\
    \ If a = 0 then b = 1 and the first fibonacci number is b.\n        if (a == 0)\
    \ 1\n        // else calculate a fibonacci number.\n        else (a + b) / 2",
  "        val numbers = Vector.fill(n+2)(0) ++ Vector.fill(n+2)(1)\n        numbers.last",
  "        if (n == 0l || n == 1l) return n\n        else fib(n-1l) + fib(n-2l)",
  "        val arr = new Array[Long](100l)(0)\n        val fibs = arr.zipWithIndex.map({\
    \ x =>\n            if(x._2 < n) x._1 + x._2 else x._1 }).takeWhile(_ < n).drop(1)\n\
    \        fibs.last", "        if (n <= 0L) 0L\n        else if (n <= 1L) 1L\n\
    \        else fib(n-1) + fib(n-2)", '        if (n < 2) 1 else fib(n - 1) + fib(n
    - 2)', "        var a = b = 0\n        while (n > 2) {\n            val x = a\n\
    \            a = b\n            b = x + a\n            n -= 2\n        }\n   \
    \     b", "        val fibList = new mutable.ListBuffer[Long]()\n        fibList\
    \ += 1\n        fibList += 2\n        fibList += 3\n        if (n > 0) {\n   \
    \         fibList += fib(n-1) + fib(n-2)\n        }\n        fibList(0)", "  \
    \      def fib1(n1 : Long, n2 : Long) : Long = n2 match {\n            case 0\
    \ => n1\n            case 1 => n2\n            case _ => fib1(n1, n2 - 1)\n  \
    \      }\n        fib1(0, n)", "        if (n <= 2) 1\n        else fib(n-1) +\
    \ fib(n-2)", "        if (n == 0) 0\n        else if (n == 1) 1\n        else\
    \ fib(n - 1) + fib(n - 2)", "        val fibs = scala.collection.mutable.ArrayBuffer(0)\n\
    \        fibs += 0\n        fibs += 1\n        n match {\n            case 0 =>\
    \ fibs\n            case 1 => fibs(0)\n            case _ => {\n             \
    \   val temp = fibs(0)\n                fibs(0) = fibs(1)\n                fibs(1)\
    \ = temp\n                fibs\n            }\n        }", "        // Create\
    \ a list from 0 to n inclusive.\n        val list = mutable.MutableList[Long](1l)(2l)(3l)\n\
    \        val n = list.length\n        if (n > 1) {\n            list.remove(n-1)\
    \ // Remove the last element.\n        }\n        if (n > 2) {\n            list.add(list.get(0)\
    \ - list.get(1)) // Subtract the first two elements.\n        }\n        list",
  "        // If n < 2 return n.\n        if( n < 2){\n            return n\n    \
    \    }\n        // Create fibonacci numbers.\n        var fib1 : mutable.Map[Long,\
    \ Long] = mutable.Map(0 -> 1,\n        1 -> 1)\n        var fib2 : mutable.Map[Long,\
    \ Long] = mutable.Map(0 -> 1,\n        1 -> 1)\n        // Loop over fibonacci\
    \ numbers.\n        for(fibNum <- 0 until n){\n            fib1 += (fibNum ->\
    \ fib2.getOrElse(fibNum, fibNum + fib1.getOrElse(fibNum, 0)))\n            fib2\
    \ += (fibNum -> fib1.getOrElse(fibNum, fibNum + fib2.getOrElse(fibNum, 0)))\n\
    \        }\n        // Return n-th fibonacci number.\n        fib1.get(n) match\
    \ {\n            case Some(x) => x\n            case None => n\n        }", " \
    \       if(n == 0) 0\n        if(n == 1) 1\n        fib(n - 1) + fib(n - 2)",
  "        if (n<=0) throw new IndexOutOfBoundsException(\"Fibonacci number does not\
    \ exist for negative or zero inputs\")\n        if (n==1) 1\n        if (n==2)\
    \ 1\n        if (n==3) 2\n        if (n==4) return 3\n        var a = fib(n -\
    \ 2)\n        var b = fib(n - 1)\n        return a + b", "        val fibs = (0\
    \ until n)\n            .toVector\n            .map(e => e + e)\n            .toArray\n\
    \            .sort\n            .zipWithIndex\n            .toSeq\n          \
    \  .map {\n                case (n, i) => n\n            }\n            .toArray\n\
    \            .reverse\n            .toVector", "        val fibs : mutable.ListBuffer[Long]\
    \ = mutable.ListBuffer.empty\n        fibs.clear()\n        fibs += 0l\n     \
    \   fibs += 1l\n        var fibsTail : List[Long] = List()\n        while(fibs.size\
    \ < n) {\n            fibsTail ::= fibs.head :: fibsTail\n            fibs +=\
    \ fibsTail.last\n        }\n        fibs.last", "        val cache = mutable.HashMap[Long,\
    \ Long]()\n        def fibHelper(n : Long) : Long = {\n            if (cache(n)\
    \ == null) {\n                cache(n) = if (n < 2) 1 else fibHelper(n - 1) +\
    \ fibHelper(n - 2)\n            }\n            cache(n)\n        }\n        fibHelper(n)",
  "        if (n == 0) 0\n        else if (n == 1) 1\n        else fib(n - 1) + fib(n\
    \ - 2)", "        if (n <= 0)\n            return 0\n        else if (n <= 2)\n\
    \            return 1\n        else\n            return fib(n - 2) + fib(n - 1)",
  "        var a = 0l\n        var b = 1l\n        while (b <= n) {\n            var\
    \ c = a + b\n            a = b\n            b = c\n        }\n        return b",
  "      val F = new mutable.LinkedList[Long]\n      F.add(0l)\n      F.add(1l)\n\
    \      F.foreach(_ += _)\n      F.tail.drop(2).takeRight(n).reverse.foldLeft(F.head)(_\
    \ + _)", "        var a = 2L\n        var b = 2L\n        while (n > 0) \n   \
    \         { a = b; b = a + b; n -= 1L }\n        return b", "        if (n ==\
    \ 0 || n == 1) 1\n        else fib(n-1) + fib(n-2)", "        if(n == 0) 1l\n\
    \        else fib(n-1)+fib(n-2)", "        if (n <= 1)\n            n\n      \
    \  else\n            fib(n-1) + fib(n-2)", "       val fibs = mutable.ListBuffer[Long](1l)\n\
    \       fibs += fibs(0l)\n       fibs += fibs(1l)\n       fibs.take(n).last",
  "        val fibSeq = mutable.ArrayBuffer(1l, 2l)\n        fibSeq.update((1l) ->\
    \ (1l))\n        fibSeq.update((2l) -> (fibSeq.get(2l) + fibSeq.get(1l)))\n  \
    \      fibSeq.update((n) -> (fibSeq.get(n) - fibSeq.get(n-1)))\n        fibSeq.get(n)",
  "        var first = 0l\n        var second = 1l\n        var fib = 2l\n       \
    \ var counter = 1l\n        while(counter < n) {\n            first = second\n\
    \            second = fib\n            fib = first + second\n            counter\
    \ += 1\n        }\n        fib", "      if (n <= 2) 1\n      else if (n == 3)\
    \ return 3\n      else fib(n-2) + fib(n-1)", "        var prev = 0\n        var\
    \ curr = 1\n        for(i <- 0 until n){\n            prev = curr\n          \
    \  curr = prev + curr\n        }\n        curr", "      var result : Long = 0\n\
    \      var a : Long = 1l\n      var b : Long = 1l\n      var c = 0\n      for(c\
    \ <- 1 to n){\n          result = a + b\n          a = b\n          b = result\n\
    \      }\n      b", "        if (n <= 0) 0\n        else fib(n-1) + fib(n-2)",
  "        if (n <= 2l) 1\n        else fib(n-1l) + fib(n-2l)", "        if (n < 2)\
    \ 1\n        else fib(n-1) + fib(n-2)", "        var f1 = 1\n        var f2 =\
    \ 1\n        var result = 0\n\n        // Write your solution here", "       \
    \ val fibs = Vector.fill(5)(1L)\n        fibs(0) += fibs(1)\n        for(i <-\
    \ 1 to 5){\n            fibs(i) += fibs(i - 1) + fibs(i - 2)\n        }\n    \
    \    fibs(5)", "        var a = 1\n        var b = 1\n        var next = 1\n \
    \       if (n < 2)\n            next\n        else {\n            while (n > 0)\
    \ {\n                var c = a + b\n                a = b\n                b =\
    \ c\n                n -= 1\n            }\n            next\n        }", "  \
    \      var a = 0l\n        var b = 1l\n        var c = a + b\n        while (c\
    \ < n){\n            b = c\n            c = a + b\n            a = c\n       \
    \ }\n        c", "        val a = fibs(n)\n        if (a > 0) a else -a - 1",
  "        if (n <= 1l)\n            1l\n        else\n            fib((n - 1l) +\
    \ 1l) + fib((n - 2l))", "        val s = scala.math.BigInt(\"1\");\n        val\
    \ t = scala.math.BigInt(\"1\");\n        for (i <- 0 to n-1) {\n            t\
    \ += s\n            s = t\n        }\n        s", "      val fibs = mutable.Stack[Int]()\n\
    \      fibs.push(1) \n      fibs.push(1) \n      while(fibs.size < n)\n      \
    \  fibs.push(fibs.last+fibs.last)\n      fibs.last", "        var sum = 0\n  \
    \      var sum2 = 1\n        var i = 1\n        while(i < n){\n            sum\
    \ = sum + sum2\n            sum2 = sum2 - sum\n            i = i + 1\n       \
    \ }\n        return sum", "        val nums = mutable.ListBuffer(1, 2)\n     \
    \   while(nums.size < n){\n            val tmp = nums.head + nums.last\n     \
    \       nums.clear()\n            nums += tmp\n        }\n        nums.last",
  "        var f1 = 1\n        var f2 = 1\n        f1 += f2\n        f2 += f1\n  \
    \      f1", "        def fib0(n : Long) : Long = {\n            if (n == 0 ||\
    \ n == 1) {\n                return n\n            } else {\n                return\
    \ fib0(n - 1) + fib0(n - 2)\n            }\n        }\n        fib0(n)", "   \
    \     var i : Long = 0\n        var prev : Long = 1\n        var ans : Long =\
    \ 1\n        while (i<n) {\n            ans = prev + ans\n            prev = ans\n\
    \            i += 1\n        }\n        ans", "        if (n==0L || n==1L)\n \
    \           1L\n        else if (n==2L)\n            1L\n        else\n      \
    \      fib(n-1L) + fib(n-2L)", "        val x0 = 1l\n        val x1 = 1l\n   \
    \     var i = 2\n        val fib = 0l\n        fib += x0\n        while(i <n)\
    \ {\n            x1 += x0\n            x0 = x1\n            fib += x0\n      \
    \      i += 1\n        }\n        fib", "        val fibs = mutable.ArrayBuffer.empty[(Long,\
    \ Long)]\n        fibs += (0, 1)\n        fibs += (1, 1)\n        fibs match {\n\
    \            case Nil => n\n            case a :: b => fib(a - b) match {\n  \
    \              case x if x == n => fibs(x)\n                case x => fibs(x)\
    \ + fibs(x + 1)\n            }\n        }", "        if (n == 0l) 0\n        else\
    \ if (n == 1l) 1\n        else fib((n - 1l) + fib((n - 2l))) }\n}\n\n\"\"\"\n\n\
    val fib_code = s\"\"\"\nimport scala.collection.mutable.ListBuffer\nimport scala.collection.immutable.List\n\
    import scala.collection.immutable._\nimport scala.math.Ordering.Implicits._\n\
    object Problem {\n    // Return n-th Fibonacci number.\n    // >>> fib((10l))\n\
    \    // (55l)\n    // >>> fib((1l))\n    // (1l)\n    // >>> fib((8l))\n    //\
    \ (21l)\n    def fib(n : Long) : Long = {\n        def fib2(n: Long): Long = {\n\
    \            if (n == 0l) 0\n            else if (n == 1l) 1\n            else\
    \ fib2(n - 1l) + fib2(n - 2l) }\n        val xs = List.range(1, n+1)\n       \
    \ xs.sortWith(_ < _)\n        .tail match {\n            case 0 => 0\n       \
    \     case 1 => 1\n            case _ => fib2(xs.last) } }\n}\n\"\"\"\nval fib_code\
    \ = \"\"\"\nimport scala.collection.mutable.ListBuffer\nimport scala.collection.immutable.List\n\
    import scala.collection.immutable._\nimport scala.math.Ordering.Implicits._\n\
    object Problem {\n    // Return n-th Fibonacci number.\n    // >>> fib((10l))\n\
    \    // (55l)\n    // >>> fib((1l))\n    // (1l)\n    // >>> fib((8l))\n    //\
    \ (21l)\n    def fib(n : Long) : Long = {\n        def fib2(n: Long): Long = {\n\
    \            if (n == 0l) 0\n            else if (n == 1l) 1\n            else\
    \ fib2(n - 1l) + fib2(n - 2l) }\n        val xs = List.range(1, n+1)\n       \
    \ xs.sortWith(_ < _)\n        .tail match {\n            case 0 => 0\n       \
    \     case 1 => 1\n            case _ => fib2(xs.last) } }\n}\"\"\"\nval fib_code\
    \ = \"\"\"\nimport scala.collection.mutable.ListBuffer\nimport scala.collection.immutable.List\n\
    import scala.collection.immutable._\nimport scala.math.Ordering.Implicits._\n\
    object Problem {\n    // Return n-th Fibonacci number.\n    // >>> fib((10l))\n\
    \    // (55l)\n    // >>> fib((1l))\n    // (1l)\n    // >>> fib((8l))\n    //",
  "        val fibo = (1l) :: (1l) :: Nil\n        if (n > fibo.size - 1) 0\n    \
    \    else {\n            fibo(n)\n        }", "        if (n <= 1l) {\n      \
    \      n\n        } else {\n            fib(n-1) + fib(n-2)\n        }", "   \
    \     val memo = mutable.ListBuffer.empty[Long]\n        def fib(x: Long) = {\n\
    \            memo += x\n            if (x < (2l*n - 2l)) fib(x+1l) else\n    \
    \        memo.remove(0)\n        }\n        fib(n)", "        var a : Long = 1\n\
    \        var b : Long = 1\n        for (i <- 0 until n) {\n            val temp\
    \ = a\n            a = b\n            b = temp\n        }\n        a", "     \
    \   val fibs = mutable.Stack[Long]()\n        fibs.push(1)\n        fibs.push(2)\n\
    \        for (i <- 3 until n) {\n            fibs.push((fibs.head + fibs.last))\n\
    \        }\n        fibs.last", "        if (n <= 1l) {\n            n\n     \
    \   } else {\n            fib(n-1l) + fib(n-2l)\n        }", "        if (n <=\
    \ 1L) n\n        else fib(n-1) + fib(n-2)", "        val a = 0\n        val b\
    \ = 1\n        var fib = 0\n        if (n < 2)\n            fib\n        else\n\
    \            fib += fib((n - 1l)) * (n - 1l)\n        fib +=  a * b\n        fib\
    \ +=  a", "        def fib(n : Long, acc1 : Long, acc2 : Long) : Long = {\n  \
    \          if(n < 1) acc1\n            else if(n < 3) acc2\n            else fib(n-1,\
    \ acc2, acc1 + acc2)\n        }\n        fib(n.toInt, 1, 1)", "        var fib\
    \ : scala.math.BigInt = BigInt(0)\n        var fib1 : scala.math.BigInt = BigInt(1)\n\
    \        for (i <- 1 to n)\n            fib2 = fib.add(fib1)\n            fib\
    \ = fib2\n        fib1", "        if (n < 0) throw new Exception(\"Negative fib\
    \ number\");\n        if (n <= 1) return n;\n        val first: Long = fib(n-1)\
    \ + fib(n-2);\n        fib(n) = first;\n        first;", "        if (n < 2) 1\n\
    \        else fib(n-1) + fib(n-2)", "        val nums = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        while(n > 0) {\n            nums.append(n); n -= 1\n        }\n     \
    \   nums.reverse.head", "        def fib2(n: Long): Long = {\n            def\
    \ fib3(n: Long): Long = {\n                if (n == 0) 1\n                else\
    \ if (n == 1) 1\n                else {\n                    val m = fib2(n -\
    \ 1)\n                    fib3(n - 1) + m\n                }\n            }\n\
    \            fib3(n)\n        }\n        fib2(n)", "        var a = 0\n      \
    \  var b = 1\n        var result = 1\n        for(i <- 0 until n) {\n        \
    \    result = a + b\n            a = b\n            b = result\n        }\n  \
    \      result", "        // Use recursive function to return Fibonacci numbers\
    \ in tail recursion\n        def fib1(n : Long, sum : Long) : Long = {\n     \
    \       if (n == 0) sum\n            else fib1(n - 1, sum + sum)\n        }\n\
    \        fib1(n.toInt, 0L)", "        if (n <= 1) {\n            return 1L\n \
    \       }\n        else {\n            return fib(n - 1) + fib(n - 2)\n      \
    \  }", "        if (n == 0 || n == 1) n\n        else fib(n - 1) + fib(n - 2)"]
stop_tokens:
- "\n    }\n"
