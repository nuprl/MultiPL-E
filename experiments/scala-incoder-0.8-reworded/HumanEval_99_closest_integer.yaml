name: HumanEval_99_closest_integer
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that takes a value (string) representing a number\n  \
  \  // and returns the closest integer to it. If the number is equidistant\n    //\
  \ from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"\
  10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    //\
  \ Note:\n    // Rounding away from zero means that if the given number is equidistant\n\
  \    // from two integers, the one you should return is the one that is the\n  \
  \  // farthest from zero. For example closest_integer(\"14.5\") should\n    // return\
  \ 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value\
  \ : String) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
  10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
  -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
  0\")) == (0l));\n    }\n\n}\n"
completions: ["        //  Your code here\n        val number = value.asInstanceOf[String]\n\
    \        if(number != \"\"){\n            val digits = number.toString.split(\"\
    \\\\.\")\n            val numStr: String = digits(0).dropRight(1)\n          \
    \  val num = numStr.toLong\n            val remainder = num % 10\n           \
    \ var result = num\n            val diff = Math.abs(num - remainder)\n       \
    \     val sign = if (num == remainder) -1 else 1\n            if(diff < 3){\n\
    \                result = remainder + (numStr.length - 1) * sign\n           \
    \ }\n            result\n        }\n        else {\n            0\n        }",
  "        // Create a map of characters and their corresponding decimal values\n\
    \        // This map will be used to lookup the closest integer to the\n     \
    \   // given number using a binary search method\n        var charValMap : Map[Char,\
    \ Double] = Map[Char, Double]()\n        charValMap('0') -> 0\n        charValMap('1')\
    \ -> 1\n        charValMap('2') -> 2\n        charValMap('3') -> 3\n        charValMap('4')\
    \ -> 4\n        charValMap('5') -> 5\n        charValMap('6') -> 6\n        charValMap('7')\
    \ -> 7\n        charValMap('8') -> 8\n        charValMap('9') -> 9\n        charValMap('a')\
    \ -> 10\n        charValMap('b') -> 11\n        charValMap('c') -> 12\n      \
    \  charValMap('d') -> 13\n        charValMap('e') -> 14\n        charValMap('f')\
    \ -> 15\n        charValMap('g') -> 16\n        charValMap('h') -> 17\n      \
    \  charValMap('i') -> 18\n        charValMap('j') -> 19\n        charValMap('k')\
    \ -> 20\n        charValMap('l') -> 21\n        charValMap('m') -> 22\n      \
    \  charValMap('n') -> 23\n        charValMap('o') -> 24\n        charValMap('p')\
    \ -> 25\n        charValMap('q') -> 26\n        charValMap('r') -> 27\n      \
    \  charValMap('s') -> 28\n        charValMap('t') -> 29\n        charValMap('u')\
    \ -> 30\n        charValMap('v') -> 31\n        charValMap('w') -> 32\n      \
    \  charValMap('x') -> 33\n        charValMap('y') -> 34\n        charValMap('z')\
    \ -> 35\n\n        val nums = value.split('')\n        val numLength = nums.map(_.toInt).sum\n\
    \        val numArray = nums.map(_.toInt)\n\n        // Find the closest integer\n\
    \        // If there are two integers that have the same\n        // difference\
    \ between the two numbers, return the\n        // one that is closer to zero.\n\
    \        // For example if closest_integer(\"43.5\") and\n        // closest_integer(\"\
    14.4\") return 14 and closest_integer(\"43.5\")\n        // and closest_integer(\"\
    15.6\") return 15.\n        // If there is only one integer that is closer", " \
    \       val parts = value.split(\".\".toCharArray).map(_.toLong)\n        if (parts.isEmpty)\
    \ parts += 0\n        if (parts.size == 1) parts += 0\n\n        val closestPart\
    \ = parts(parts(1) - parts(0) > 0)\n        val closestPart2 = parts(parts(2)\
    \ - parts(1) > 0)\n        val closestPart3 = parts(parts(3) - parts(2) > 0)\n\
    \n        val part1 = closestPart.toLong\n        val part2 = closestPart2.toLong\n\
    \        val part3 = closestPart3.toLong\n\n        if (closestPart.toLong < closestPart2.toLong\
    \ \n        && closestPart.toLong < closestPart3.toLong)\n            part1 +=\
    \ 1\n        else if (closestPart2.toLong < closestPart3.toLong)\n           \
    \ part2 += 1\n        else\n            part3 += 1\n\n        (part1 + part2 +\
    \ part3).toLong", "        val n = math.pow(10, value.length)\n        if (value.toString.length\
    \ == 0)\n            return 0\n        val numbers = value.split(\"\\\\.\").map(_.toLong).map(_.toInt)\n\
    \        val d = math.abs(numbers(0) - numbers(1))\n        if (d == 0)\n    \
    \        return numbers(0)\n        val n = d / Math.abs(numbers(1) - numbers(0))\n\
    \        val m = numbers(0) - n * Math.abs(numbers(1) - numbers(0))\n        m\
    \ + n", "        // Your code here\n        val array: Array[Double] = value.split(\"\
    \\\\.\").map(_.toDouble)\n        val array2: Array[Double] = array.filter(_ !=\
    \ 0).sortWith(_ < _).map(_ + 0.5).toArray\n        var min = 0\n        var max\
    \ = array.length-1\n        var min2 = array2.length-1\n        while(min < max){\n\
    \            val mid = math.abs(array.length-array2.length)/2\n            val\
    \ mid2 = math.abs(array.length - array2.length)/2\n            if(array[mid] <\
    \ array2[mid2]){\n                val min = mid\n                val max = mid2\n\
    \            } else {\n                val min = mid2\n                val max\
    \ = mid\n            }\n        }\n        return math.abs(array.length - array2[min])",
  "        if (value == null || value.isEmpty || value.size == 1) {\n            0\n\
    \        }\n        val parts = value.split(\"\\\\.\") // split on decimal points\n\
    \        val x = parts(0).toLong // get the first number\n        val closest\
    \ = closest(x) // get the closest number\n        if (closest == x) {\n      \
    \      closest\n        } else {\n            closest + 1\n        }", "     \
    \   // Convert value to a number and find the closest integer\n        val number:\
    \ Long = value.toLong\n        val closestInteger: Long = (math.abs(number - math.min(math.max(number\
    \ - 0.2, 0), 10.2))).toInt\n        closestInteger", "        val parsed = value.split('.')\n\
    \        if (parsed.isEmpty) 0\n        else {\n            val digits = parsed.map(_.toLong)\n\
    \            val closest = math.min(digits)\n            val diff = Math.abs(closest\
    \ - digits.max)\n            diff == digits.max ? closest + 1 : closest\n    \
    \    }", "        val parts = value.split(\"\\\\.\") // Separate the decimals\
    \ into their parts\n        // First, round each number individually\n       \
    \ val integerParts = parts.map(v => math.round(math.pow(10, v.toInt)))\n     \
    \   // Then round each part individually\n        val decimalParts = parts.map(v\
    \ => math.round(math.pow(10, v.toInt)).toDouble / math.pow(10, v))\n        //\
    \ Now find the closest number\n        val closestInteger = integerParts.map(i\
    \ => math.min(i).round)\n        // Now find the closest decimal\n        val\
    \ closestDecimal = decimalParts.map(dv => math.min(dv).round)\n        // Now\
    \ sum the closest parts\n        val total = closestInteger.zip(closestDecimal).map{\
    \ case (integer, decimal) => (integer + decimal) }\n        // The first element\
    \ will be the closest integer, the second element the closest decimal\n      \
    \  (total min total(0)) match {\n            case (integer, decimal) => integer\
    \ + decimal\n        }", "        val s = value.toLong\n        val d = s.length\n\
    \        val m = Math.ceil(d/2)\n        if(d == 0 || s.length == 0) 0\n     \
    \   else if(s.length == 1) s\n        else {\n            val a = s - 1l\n   \
    \         val b = s\n            if(b < 0) b + 1l\n            else if(a < 0)\n\
    \                a\n            else\n                a\n        }", "       \
    \ val intValue = scala.math.BigDecimal(value)\n        val intValueAbs = intValue.abs()\n\
    \n        val closestIntValues = for {\n            i <- intValueAbs\n       \
    \     intVal = intValue.round(i).toBigDecimal\n        } yield intVal\n\n    \
    \    val smallestIntValue = closestIntValues.min(i => i)\n\n        smallestIntValue.toLong",
  "        val intValue = value.toDouble;\n        val closestInteger = math.round(intValue);\n\
    \        return closestInteger;", "        val parts = value.split(\".\")\n  \
    \      if (parts.size == 1) parts :+ 0\n        else {\n            val mid =\
    \ parts(parts.size / 2).toLong\n            val remainder = parts(parts.size -\
    \ 1).toLong\n            val result = mid + ((mid - remainder).toDouble / parts.size)\n\
    \            if (result < Integer.MIN_VALUE || result > Integer.MAX_VALUE) closestInteger(value)\n\
    \            else\n            result\n        }", "        var closest = 0l\n\
    \        var closestDiff = 0l\n        var lastDiff = 0l\n\n        for( n <-\
    \ value.split(\",\").map(_.toInt) ) {\n            if(n > 0 && n < Integer.MAX_VALUE)\
    \ {\n                diff = abs(n - closest)\n                if (diff < closestDiff)\
    \ {\n                    lastDiff = closestDiff\n                    closest =\
    \ n\n                    closestDiff = diff\n                }\n            }\n\
    \        }\n        lastDiff", "        // Your code here\n        val values\
    \ = value.split(\"\\\\.\").toList\n        val digits = values.map(_.toInt)\n\
    \        val max = (0 until digits.size)\n        val min = (0 until digits.size)\n\
    \n        var maxDistance = 9999\n        var minDistance = 9999\n        for\
    \ (i <- 0 until max) {\n            for (j <- 0 until min) {\n               \
    \ val distance = ((digits(i) - digits(j)) * Math.pow(10, i))\n               \
    \ if (distance > maxDistance) {\n                    maxDistance = distance\n\
    \                    val newValue = values + j\n                }\n          \
    \      if (distance < minDistance) {\n                    minDistance = distance\n\
    \                    val newValue = values + i\n                }\n          \
    \  }\n        }\n        val roundedValue = if (maxDistance < minDistance) value.toInt\
    \ else value.toInt - maxDistance + minDistance\n        val stringValue = roundedValue.toString\n\
    \        return Long.parseLong(stringValue)", "        var nearest: Long = (0l)\n\
    \        var closest: Long = (0l)\n        var next: Long = 0l\n\n        value.split(\"\
    ,\").foreach(x => {\n            val num: Long = x.toLong\n            if (nearest\
    \ == 0) nearest = num\n            else next = Math.abs(num - nearest)\n     \
    \       if (next > closest) closest = next\n        })\n\n        if (nearest\
    \ != (0l)) {\n            nearest + closest\n        } else {\n            //\
    \ No integers could be found in the string\n            0l\n        }", "    \
    \    // Split the value into an integer and the fractional part.\n        var\
    \ value = value.split(\"\\\\.\").map(_.toInt).getOrElse(1)\n        var fractionalPart\
    \ = value.floor.toDouble\n        var integerPart = fractionalPart - (fractionalPart\
    \ * 0.5)\n        // If the fractional part is zero, we return 0\n        if (fractionalPart\
    \ == 0.0) return 0\n        // Return the integer part\n        return integerPart",
  "        // Your code here\n        val numberArray = value.split(\".\").map(_.toInt).toList\n\
    \        var min = numberArray(0)\n        var max = numberArray(0)\n        val\
    \ resultArray = numberArray.zipWithIndex.filter { \n            case (x,index)\
    \ => index==0\n        }.map { \n            case (x,index) => (max/min - x) /\
    \ min\n        }\n        resultArray(0)", "        var num : Long = 0\n     \
    \   var digits : List[String] = value.split('.').toList\n        var fraction\
    \ : Double = 0\n        for(i <- 0 until digits.size) {\n            num +=  digits(i).toLong\
    \ * (10 until 10).map(_.toLong).sum\n            fraction += digits(i)\n     \
    \   }\n        fraction = fraction / digits.size\n        var closest = num\n\
    \        val diff = (fraction - Math.abs(num)) / Math.pow(10, digits.size).toDouble\n\
    \        val diff2 = diff * diff\n        for(i <- 0 until digits.size) {\n  \
    \          val a = Math.pow(10, digits.size-i)\n            val b = Math.pow(10,\
    \ i)\n            val c = fraction - a * diff2\n            val d = num - a *\
    \ b\n            val f = b * c\n            if(d > f || c == 0 || d == 0) {\n\
    \                return closest = num - b\n            }\n            if(c < 0\
    \ || d < 0) {\n                closest = num - a\n                return closest\
    \ = num - a\n            }\n        }\n        return closest", '        // Your
    code here', "        var closest = 0L;\n        var closest = value.toLong;\n\
    \        var diff = 0L;\n        var diffValue = value.toDouble;\n        var\
    \ diffValue1 = diffValue * diffValue;\n        val array1 = Array(diffValue1);\n\
    \        val array2 = Array(diffValue1);\n        var index = 0L;\n        var\
    \ index1 = 0L;\n        var index2 = 0L;\n        var index3 = 0L;\n        var\
    \ index4 = 0L;\n        var index5 = 0L;\n        var index6 = 0L;\n        for(i\
    \ <- 0 until array1.size) {\n            val temp = abs((array1(i) - closest).toDouble)\n\
    \            if(temp > diff) {\n                diff = temp;\n               \
    \ closest = array1(i);\n            }\n        }\n        for(i <- 0 until array2.size)\
    \ {\n            val temp = abs((array2(i) - closest).toDouble)\n            if(temp\
    \ > diff) {\n                diff = temp;\n                closest = array2(i);\n\
    \            }\n        }\n        for(i <- 0 until array1.size) {\n         \
    \   val temp = abs((array1(i) - closest).toDouble)\n            if(temp > diff)\
    \ {\n                diff = temp;\n                closest = array1(i);\n    \
    \        }\n        }\n        for(i <- 0 until array2.size) {\n            val\
    \ temp = abs((array2(i) - closest).toDouble)\n            if(temp > diff) {\n\
    \                diff = temp;\n                closest = array2(i);\n        \
    \    }\n        }\n        for(i <- 0 until array1.size) {\n            val temp\
    \ = abs((array1(i) - closest).toDouble)\n            if(temp > diff) {\n     \
    \           diff = temp;\n                closest = array1(i);\n            }\n\
    \        }\n        for(i <- 0 until array2.size) {\n            val temp = abs((array2(i)\
    \ - closest).toDouble)\n            if(temp > diff) {\n                diff =\
    \ temp;\n                closest = array2(i);\n            }\n        }\n    \
    \    for(i <- 0 until array1.size) {\n            val temp = abs((array1(i) -\
    \ closest).toDouble)\n            if(temp > diff) {\n                diff = temp;\n\
    \                closest = array1(i);\n            }\n        }\n        for(i\
    \ <- 0 until array2.size) {\n            val temp = abs((array2(i) - closest).toDouble)\n\
    \            if(temp > diff) {\n                diff = temp;\n               \
    \ closest = array2(i);\n            }\n        }\n        for(i <- 0 until array1.size)\
    \ {\n            val temp = abs((array1(i) - closest).toDouble)\n            if(temp\
    \ > diff) {\n                diff = temp;\n                closest = array1",
  "        val digits = value.split('.').toList\n        val maxDigit = digits(digits.length\
    \ - 1).toLong\n        val minDigit = digits(0).toLong\n\n        if(digits.length\
    \ < 2)\n            0\n        else\n            if(digits(digits.length - 1).toLong\
    \ < maxDigit)\n                digits(digits.length - 1).toLong\n            else\n\
    \                maxDigit", "        val parts = value.split(\".\")\n        val\
    \ d = parts.mkDouble\n        val i1 = d.toInt\n        val i2 = d.toInt\n\n \
    \       if (Math.abs(d-1) < Math.abs(d+1)){\n            return i1\n        }\n\
    \        else {\n            return i2\n        }", "      val value = value.trim()\n\
    \      val nums = value.split(\"\\\\.\").map(_.toDouble).map(n => math.abs(n)).max\n\
    \      (Math.abs(nums) > Integer.MIN_VALUE ? nums.toInt : nums)", "        val\
    \ vals = value.split(\",\").toList.map(_.trim).toSet\n        val closestInts\
    \ = vals.map(val => math.abs(math.round(math.abs(val.toLong)))).sortBy(_ -_)\n\
    \        closestInts.last", "        // Extract the integer from the value\n \
    \       val (num, den) = value.split(\".\").map(_.toInt).toList\n        \n  \
    \      // Find the closest integer to the number\n        val closest_integer\
    \ = num match {\n            case x if x >= 0 && x <= 2147483647 => x // No rounding\
    \ required\n            case x if x >= -2147483648 && x <= -1 => x + 1\n     \
    \       case x if x >= 0 && x <= 2147483647 => x - 1\n            case x if x\
    \ >= -2147483648 && x <= -1 => x - 1\n            case _ => 0\n        }\n   \
    \     \n        // Convert the result back to a string\n        val result = if(closest_integer\
    \ > 0) \"(\" + closest_integer.toString + \")\" else \"(-\" + closest_integer.toString\
    \ + \")\"\n        \n        // Return the result with the correct sign\n    \
    \    val correct = if (den == 1) result else result.replace(\")\", \"\").replace(\"\
    (\", \"-\")\n        correct + if (val sign = value.contains(\"-\"))\n       \
    \     val sign = if (value.contains(\"-\")) \"+\" else \"\"\n            \".\"\
    \ + sign + den.toString\n        else \"\"", "        val split = value.split(\"\
    \\\\.\") // Split value by decimal point\n        val integer = split(0).toLong\
    \ // Convert first part to long \n        var previous = integer - 1\n       \
    \ for (s <- split.tail) {\n            val newInteger = previous + s.toLong //\
    \ Add value to previous\n            if (Math.abs(newInteger) < Math.abs(previous))\
    \ {\n                previous = newInteger // Check if value has moved\n     \
    \       } else {\n                // If the difference between two integers is\
    \ less than one\n                // then round away from zero and return the integer\
    \ value\n                return newInteger\n            }\n        }\n       \
    \ return integer", "        // Complete the implementation of the function here.\n\
    \        val floatvalue = java.lang.Float.parseFloat(value)\n        val intvalue\
    \   = java.lang.Integer.parseInt(value)\n        val intdiff    = intvalue - intvalue%1\n\
    \        val difference = java.lang.Math.abs(intdiff)\n        if (difference\
    \ < 0.5) {\n            return intvalue + 1\n        } else {\n            return\
    \ intvalue - difference\n        }", "        val arr = value.split(\"\\\\.\"\
    ).toList.map(_.toInt)\n        val sum = arr.sum\n        val mid = sum / 2\n\
    \        val arr1 = arr.map(_ - mid)\n        val arr2 = arr1.map(math.min)\n\
    \        val closestLong = arr2.sum\n        return closestLong", "        //\
    \ The function returns the closest integer, but rounds\n        // it away from\
    \ zero if the number if equidistant from two\n        // integers.\n        var\
    \ closestInt : Long = math.abs(value.toDouble).toInt\n        var closestFromTwo\
    \ : Long = 0\n        \n        // If the value is negative, add it to closestFromTwo.\n\
    \        // If the value is positive, subtract it from closestFromTwo.\n     \
    \   if(value < 0){\n            closestFromTwo += value\n        }else{\n    \
    \        closestFromTwo -= value\n        }\n        \n        // If closestFromTwo\
    \ is equal to closestInt, then the\n        // numbers are equidistant. In this\
    \ case, add the\n        // integer to the closestInt.\n        if(closestFromTwo\
    \ == closestInt){\n            closestInt += value.toInt\n        }\n        \n\
    \        // Return the closest integer.\n        closestInt.toLong", "       \
    \ val nums = value.split(\"\\\\.\") // split value into ints and decimals\n  \
    \      val ns = nums.tail // take last int from list to compare\n        val ds\
    \ = nums.tail.tail // take last decimal from list to compare\n        val ins\
    \ = nums.head // take first int from list to compare\n        val dec = nums.head.tail\
    \ // take last decimal from list to compare\n        var closestVal = math.MaxValue\n\
    \        var closestDiff = math.MaxValue\n        var closestDiffInc = 0\n   \
    \     var closestDiffDec = 0\n        var closestDiffInt = 0\n        var closestDiffIntInc\
    \ = 0\n        var closestDiffDecimal = 0\n        var closestDiffDecimalInc =\
    \ 0\n        for (i<-ns.indices; i-->0)\n        {\n            val ni = ns.toDouble(i)\
    \ // convert to double\n            val dd = ds.toDouble(i) // convert to double\n\
    \            val ini = ins.toDouble(i) // convert to double\n            val dec\
    \ = dec.toDouble(i) // convert to double\n            val diffInc = Math.abs(ni\
    \ - ins) // absolute difference between input int and current input\n        \
    \    val diffDec = Math.abs(dd - dec) // absolute difference between input decimal\
    \ and current input\n            val diffInt = Math.abs(ni - ini) // absolute\
    \ difference between input int and current input\n            val diffDecimal\
    \ = Math.abs(dd - dec) // absolute difference between input decimal and current\
    \ input\n            if (diffInt < closestDiffInt)\n            {\n          \
    \      closestDiffInc = diffInt\n                closestDiffInt = diffInt\n  \
    \              closestVal = ni\n            }\n            if (diffDec < closestDiffDecimal)\n\
    \            {\n                closestDiffDec = diffDec\n                closestDiffDecimal\
    \ = diffDec\n                closestVal = dd\n            }\n            if (diffInc\
    \ < closestDiffInc)\n            {\n                closestDiffInc = diffInc\n\
    \                closestDiffInt = diffInc\n                closestVal = ni\n \
    \           }\n            if (diffDec < closestDiffDecimal)\n            {\n\
    \                closestDiffDec = diffDec\n                closestDiffDecimal\
    \ = diffDec\n                closestVal = dd\n            }\n            if (diffInc\
    \ < closestDiffInc)\n            {\n                closestDiffInc = diffInc\n\
    \                closestDiffInt = diffInc\n                closestVal = ni\n \
    \           }\n            if (diffDec < closestDiffDecimal)\n            {\n\
    \                closestDiffDec = diffDec\n                closestDiffDecimal\
    \ = diffDec\n                closestVal = dd\n            }\n        }\n     \
    \   for (i<-ds.indices; i-->0)", "        // Your code goes here\n        val\
    \ values = value.split(\"\\\\.\")\n        val firstPart = values.get(0)\n   \
    \     val secondPart = values.get(1)\n        if(firstPart.isEmpty){\n       \
    \     if(secondPart.isEmpty){\n                return 0\n            }\n     \
    \       return secondPart*1\n        }\n        if(secondPart.isEmpty){\n    \
    \        return firstPart*1\n        }\n        val firstPartValue = firstPart.toInt\n\
    \        val secondPartValue = secondPart.toInt\n        if(firstPartValue > secondPartValue){\n\
    \            return firstPartValue - secondPartValue\n        }\n        return\
    \ firstPartValue + secondPartValue", "        val intValue = value.trim().toInt;\n\
    \        val nums = intValue.grouped(2).map{x => x.toLong}.toSeq;\n        val\
    \ differences = nums.map(x => Math.abs(x - intValue));\n        if(nums.isEmpty){\n\
    \            0\n        }else{\n            val closestIndex = differences.min;\n\
    \            val diffs = differences.toList;\n            diffs(closestIndex)\n\
    \        }", "        val digits = value.split(\"\\\\.\").map(_.toInt).toList\n\
    \        val digitValues = digits.map(x => math.pow(10, x))\n        val closestToZero\
    \ = digitValues.min\n        digits.maxBy(x => math.abs(x - closestToZero))",
  "        val number: Double = parseDouble(value)\n        val result: Long = Math.ceil(number)\n\
    \        // Return result if it is equidistant from 2 other integers\n       \
    \ if(Math.abs(number-result) == 0.5l) result else number", '        // TODO: Your
    code here', "        if (value contains \".\") {\n            val doubleValue\
    \ = value.toDouble\n            // The Math.round() method rounds the value towards\
    \ zero.\n            return math.round(doubleValue).toLong\n        } else {\n\
    \            val intValue = value.toInt\n            // The Math.round() method\
    \ rounds the value towards zero.\n            return math.round(intValue).toLong\n\
    \        }", "        // Extract the integer and decimal parts of the number using\
    \ the\n        // unapplySeq method\n        val numParts = value.unapplySeq()\n\
    \        // Check if the number is negative and if it is, return the\n       \
    \ // integer part only\n        if (numParts._2 < 0) numParts._1\n        // If\
    \ it is not negative and the value is positive, add the integer\n        // and\
    \ the decimal parts and convert the resulting strings to Longs\n        else {\n\
    \            val intPart = numParts._1 + numParts._2\n            val decimalPart\
    \ = numParts._3\n            intPart.toLong + decimalPart.toLong\n        }",
  "        val intValue = scala.math.BigDecimal(value).intValue\n        val closestInteger\
    \ = Math.abs(intValue) - 1\n        closestInteger.toLong", "        val number\
    \ = value.toLong\n        val smallestDiff = math.min(math.abs(number), number\
    \ / 2)\n        val maxDiff = math.max(math.abs(number), number / 2)\n       \
    \ if (smallestDiff < maxDiff)\n        {\n            math.round(number);\n  \
    \      }\n        else\n        {\n            math.floor(number);\n        }",
  "        val stringArray = value.split(\"\\\\.\").toArray\n        val firstInteger\
    \ = stringArray(1).toLong\n        val secondInteger = stringArray(2).toLong\n\
    \        if (firstInteger < secondInteger) secondInteger else firstInteger", " \
    \       val intVal = Try(value.toInt) match {\n            case Success(num) =>\
    \ num\n            case Failure(_) => null\n        }\n        if(intVal == null)\
    \ {\n            null\n        }\n        val intDiff = abs((intVal-intVal.toDouble)/intVal.toDouble).toInt\n\
    \        (intVal + (intDiff < 1l) ? intDiff : 1l)", "        val valueAsLong =\
    \ value.asInstanceOf[String].toLong\n        val difference = differenceBetweenValues(valueAsLong)\n\
    \        // If difference is negative, then it is closer than zero. \n       \
    \ // If difference is positive, then it is closer than positive.\n        // If\
    \ difference is zero, then it is equidistant from two integers\n        // The\
    \ one you should return is the one which is closer to zero.\n        if (difference\
    \ > 0) return valueAsLong\n        if (difference < 0) return -valueAsLong\n \
    \       else return 0", "        val list = value.split(\".\") // Split into array\
    \ of ints\n        val listOfInts = list.map(_.toInt).toList // convert string\
    \ array\n        val list = listOfInts.sortWith(_ < _) // sort array\n       \
    \ if (list.size == 1) list.head // if only one item return it\n        else list.last\
    \ - listOfInts.last // otherwise, return the last int that isn't the closest",
  "        val str = new StringBuffer(value)\n        val num = str.slice(1).toInt\n\
    \        if (num == 0 || num == 1) return num\n        val diff = abs(num - closest(num,\
    \ 0, num.toDouble))\n        if (diff < 1) {\n            closest(num, 0, diff)\n\
    \        } else {\n            closest(num, 1, diff)\n        }", "        val\
    \ tokens = value.split(\"\").toList\n        val totalLength = tokens.size\n \
    \       var index = totalLength - 1\n        val distances = {\n            var\
    \ totalDistance = 0\n            var currentDistance = 0\n            var previousIndex\
    \ = 0\n            while (index >= 0) {\n                val currentToken = tokens(index)\n\
    \                val previousToken = tokens(previousIndex)\n                if\
    \ (currentToken != previousToken) {\n                    currentDistance = math.abs(Integer.parseInt(currentToken)\
    \ - Integer.parseInt(previousToken))\n                    totalDistance += currentDistance\n\
    \                }\n                previousIndex -= 1\n                index\
    \ -= 1\n            }\n            totalDistance / totalLength\n        }\n  \
    \      val closestIndex = math.round(distances)\n        val closestToken = tokens(closestIndex)\n\
    \        Integer.parseInt(closestToken).toLong", "        val input = value.split(\"\
    ,\")\n        val n = input(0).toLong\n        val x0 = input(1)\n        val\
    \ x1 = input(2)\n        var closest = 0\n        var closest = n\n        val\
    \ minDiff = math.abs(n-x0) + math.abs(n-x1)\n        var x = 0\n        if(n >=\
    \ x0) {\n            if(n < x1)\n                x = n\n            else {\n \
    \               x = x1\n            }\n        } else if(n < x1) {\n         \
    \   x = x0\n        } else {\n            x = x1\n        }\n        while(x !=\
    \ n) {\n            val diff = Math.abs(n-x)\n            if(diff < minDiff) {\n\
    \                minDiff = diff\n                closest = x\n            }\n\
    \            x = x + 1\n        }\n        return closest.toLong", "        value\
    \ match {\n            case \"+inf\" => Long.MaxValue\n            case \"-inf\"\
    \ => Long.MinValue\n            case x => x\n        }", "        var diff : Double\
    \ = 0.0\n        val digits = value.dropWhile(_ < '0').dropWhile(_ < '9')\n  \
    \      for (i <- digits){\n            diff = math.pow(i.toLong, 2).toDouble -\
    \ diff\n        }\n        diff * math.pow(10, digits.length)", "        val stringToLong\
    \ = Long.parseLong(value)\n        val difference = stringToLong - Integer.parseInt(stringToLong.toString)\n\
    \        return if (difference < 0) 0l else if (difference > 0) difference else\
    \ stringToLong", "        def nearestFactorial(n:Int) : Int = {\n            val\
    \ i = 2\n            while (i <= n) {\n                if (n % i == 0) {\n   \
    \                 return i\n                }\n                i += 1\n      \
    \      }\n            1\n        }\n        val factors = value.split(\"\\\\.\"\
    ).map(x => x.toInt).toList\n        def sum(xs: List[Int]) : Long = { sum(xs,\
    \ 0l) }\n        def sum(xs: List[Int], sum: Long) : Long = { xs.foldLeft(sum)\
    \ { \n            (acc, x) => acc + x * nearestFactorial(x) \n        }}\n   \
    \     val a = sum.asInstanceOf[Long]\n        val b = factors.foldRight(a) { \n\
    \            (acc, x) => acc + nearestFactorial(x) \n        }\n        (a + b)\
    \ % 1L", "        // Write your logic here\n        var result : Long = 0\n  \
    \      var diff : Long = 0\n        var temp : Long = 0\n        val parts = value.split(\"\
    \\\\.\") \n        for(p <- parts) {\n            if (p.length > 1) {\n      \
    \          temp = p.toLong\n                val temp1 =  p.toLong * 10\n     \
    \           result = temp\n                diff = Math.abs(result - temp1)\n \
    \               if (diff > 0) {\n                    result = result / 10\n  \
    \              }\n            }\n        }\n        result", "        // If value\
    \ is equal to an integer, return it.\n        if (value.endsWith(\"l\")) value\
    \ + 0l\n        else if (value.endsWith(\"d\")) value + 0d\n        else if (value.endsWith(\"\
    m\")) value + 0m\n        else if (value.endsWith(\"s\")) value + 0s\n       \
    \ else value + 0", '        // Your code here', "        val numbers = value.split(\"\
    ,\")\n        val min = numbers.toSeq.map(_.toDouble).min\n        val max = numbers.toSeq.map(_.toDouble).max\n\
    \        val diff = max - min\n        diff < 0 match {\n            case true\
    \ => min + diff\n            case false => max - diff\n        }", "        //\
    \ Declare variables to store the closest and second closest values\n        //\
    \ and initialize them to the number 0 and the number Integer.MAX_VALUE\n     \
    \   // respectively.\n        var closest = 0l\n        var secondClosest = Integer.MAX_VALUE\n\
    \        // Split the given string into an array of strings of the form\n    \
    \    // \"[<number>, <number>, ..., <number>]\" where each <number> is a\n   \
    \     // single integer between 0 and Integer.MAX_VALUE.\n        var integerArray\
    \ = value.split(\"\\\\.\")\n        // Loop over the array of integers\n     \
    \   for(integer <- integerArray) {\n            // Convert the given number string\
    \ to an integer and store it\n            // in an integerVariable.\n        \
    \    val integerVariable = integer.toInt\n            // If the numberVariable\
    \ is closer to 0 than to the closest number,\n            // then update to the\
    \ closer number as the closest number.\n            if(integerVariable < closest)\
    \ {\n                closest = 0l\n            }\n            // If the numberVariable\
    \ is closer to Integer.MAX_VALUE than to\n            // the second closest number,\
    \ then update to the closer number as\n            // the second closest number.\n\
    \            if(integerVariable > secondClosest) {\n                secondClosest\
    \ = Integer.MAX_VALUE\n            }\n            // Update the closest and second\
    \ closest numbers to whichever one\n            // is closest to 0.\n        \
    \    if(integerVariable < closest) {\n                closest = integerVariable\n\
    \            }\n            if(integerVariable > secondClosest) {\n          \
    \      secondClosest = integerVariable\n            }\n        }\n        // Return\
    \ either the closest or second closest number\n        closest + secondClosest",
  "        // Your code here\n        val nums = value.split(\"\\\\.\").map(_.toDouble).toList\n\
    \        var closestDiff = Double.PositiveInfinity\n        var closestNumber\
    \ = 0\n        for(i <- 0 until nums.size){\n            var num = nums(i)\n \
    \           if(Math.abs(num - closestNumber) < closestDiff){\n               \
    \ closestDiff = Math.abs(num - closestNumber)\n                closestNumber =\
    \ num\n            }\n        }\n        closestNumber", "        var closest\
    \ = Long.MaxValue - 1L\n        val numbers = value.split(\"\\\\.\").toList\n\
    \        val numList = new mutable.ListBuffer[Long]\n        for (i <- 0 to (numbers.size\
    \ - 1)) {\n            val num = numbers(i).toLong\n            numList.append(num)\n\
    \        }\n        val difference = (numList.last.abs() - numList(0)).abs\n \
    \       if (difference < closest) {\n            closest = difference\n      \
    \  }\n        closest", "        val n = value.toLong\n        if (n < 0) return\
    \ Long.MaxValue\n        if (n > Long.MaxValue) return Long.MinValue\n       \
    \ val dl = n % 1\n        if (dl == 0) return n\n        if (dl < 0.5) {\n   \
    \         val r = n - 1\n            val d = (r - 1) % 1\n            if (Math.abs(d)\
    \ < 0.5) r\n            else if (d == 0) r\n            else r + 1\n        }\
    \ else (n - 1) % 1", "        val numValue = Try(value.toLong).toOption\n    \
    \    if(numValue.isFailure) throw new IllegalArgumentException(\"Invalid value\
    \ provided for argument: \" + value)\n        val diff = Math.abs(numValue.get.toLong\
    \ - numValue.get.toLong)\n        if(diff < Math.abs(numValue.get.toLong - numValue.get.toLong))\
    \ numValue.get.toLong\n        else numValue.get.toLong - diff", "        val\
    \ numbers = value.split(\"\\\\.\").toList.map(_.toInt)\n        var minDist :\
    \ Long = 100000\n        var minVal : Long = 100000\n        var curVal : Long\
    \ = 0\n        var diff : Long = 0\n        for ( n <- numbers ) {\n         \
    \   curVal = n\n            diff = abs(curVal - minVal)\n            if ( diff\
    \ < minDist ) {\n                minDist = diff\n                minVal = curVal\n\
    \            } else if ( diff == minDist ) {\n                // If the difference\
    \ between the current value and the previous\n                // value is less\
    \ than the smallest distance, then the current\n                // value should\
    \ be updated as the smallest distance has been\n                // updated.\n\
    \                minVal = curVal\n            }\n        }\n        minVal", " \
    \       var closestValue = Long.MaxValue\n        var closestIndex = 0\n     \
    \   for (i <- 0 until value.length)\n        {\n            val testValue = value.toDouble(i)\n\
    \            val absDiff = testValue - closestValue\n            val diffAbs =\
    \ Math.abs(absDiff)\n            if (diffAbs < closestDiff)\n            {\n \
    \               closestValue = testValue\n                closestIndex = i\n \
    \               closestDiff = diffAbs\n            }\n        }\n        closestValue",
  "        val intValue = value.asInstanceOf[String]\n        val split = intValue.split('.')\n\
    \        val integers = split(0).map(_.toLong)\n        val remainder = split(1).map(_.toLong)\n\
    \n        val diffs = remainder zip integers\n        val smallest = diffs.filter(_._1\
    \ < 0).max\n        val largest = diffs.filter(_._1 > 0).min\n        smallest.max",
  "        val values = value.split(\",\")\n        var closestVal = -1L\n       \
    \ var closestDiff = Long.MaxValue\n        val array = new mutable.ArrayBuilder[String](values.length)\n\
    \        for (i <- 0 until values.length) {\n            val stringValue = value(i)\n\
    \            val value = stringValue.trim\n            val intValue = try {\n\
    \                val parsedValue = new BigDecimal(value)\n                parsedValue.toLong\n\
    \            } catch { case _ : Exception => 0 }\n            if (intValue < closestDiff)\
    \ {\n                closestVal = intValue\n                closestDiff = intValue\n\
    \            }\n            array.add(value)\n        }\n        val diff = closestDiff\n\
    \        if (diff == 0) {\n            // If difference is zero we can just return\
    \ closestVal since it is the\n            // closest integer\n            return\
    \ closestVal\n        } else {\n            // If difference is not zero then\
    \ we want the closest integer\n            // that is closest to zero. Since we\
    \ only care about the closest\n            // integer we get the absolute value\
    \ of the difference. If the difference\n            // is greater than or equal\
    \ to 0 we return the closestVal value. Otherwise\n            // we return the\
    \ closestVal plus diff, which in this case is positive.\n            if (diff\
    \ >= 0) {\n                return closestVal\n            } else {\n         \
    \       return closestVal + diff\n            }\n        }", "        val tokens\
    \ = value.split(\"\\\\.\")\n        val l = tokens.length\n        var i = 0\n\
    \        var closest = 0\n        var difference = 0\n        val minDiff = math.pow(10,\
    \ l)\n        while (i < l) {\n            val currentNum = tokens(i).toLong\n\
    \            val currentDiff = abs(currentNum - closest)\n            if (currentDiff\
    \ < difference) {\n                difference = currentDiff\n                closest\
    \ = currentNum\n            }\n            i += 1\n        }\n        if (difference\
    \ < minDiff) {\n            closest\n        } else {\n            closest - (difference\
    \ - minDiff)\n        }", "        val parsedValue = value.asInstanceOf[Number].longValue\n\
    \        val difference = math.abs(parsedValue - java.lang.Double.valueOf(parsedValue))\n\
    \        if (parsedValue > java.lang.Double.valueOf(\"0.0\") || parsedValue <\
    \ java.lang.Double.valueOf(\"-0.001\"))\n            return parsedValue\n    \
    \    val integerPartOfNumber: Long = parsedValue - java.lang.Double.valueOf(\"\
    1\").longValue\n        if (difference < java.lang.Double.valueOf(\"0.0001\"))\n\
    \            return integerPartOfNumber\n        if (difference < java.lang.Double.valueOf(\"\
    0.00000\"))\n            return java.lang.Double.valueOf(\"0\").longValue + integerPartOfNumber\n\
    \        return java.lang.Double.valueOf(\"0.999999\").longValue + integerPartOfNumber",
  "        // Convert value to a number, ignoring non-numeric values\n        value\
    \ = value.replaceAll(\"[^0-9]+\", \"\")\n        val n = value.toLong\n      \
    \  // Find two numbers, closest to zero and furthest from zero\n        val closestOne\
    \ = math.min(n, math.max(-n, 0))\n        val furthestOne = math.max(math.min(n,\
    \ math.max(-n, 0)), 0)\n        // Return the integer closer to zero or the integer\
    \ furthest from zero\n        (closestOne - furthestOne).toLong", "        val\
    \ vals = value.split(\".\");\n        val number = vals.toInt;\n        val positiveValues\
    \ = numbers.filter(n => n > 0).map(n => Math.abs(n)).max\n        val negativeValues\
    \ = numbers.filter(n => n < 0).map(n => Math.abs(n)).min\n        val value =\
    \ if(positiveValues.isDefined && negativeValues.isDefined) positiveValues.get.max\
    \ else negativeValues.get.min\n        val closest = (number + value).toLong\n\
    \        return closest;", "        val num = value.trim\n        val numList\
    \ = num.split(\"\\\\.\").map( _.toLong )\n        var closestVal = (numList.min\
    \ max 0)\n        val numList2 = numList.filter( i => i > closestVal)\n      \
    \  val numList3 = numList2.map( i => closestVal = i).filter( i => i == 0)\n  \
    \      if(numList3.nonEmpty) {\n            val closestInt = numList3.max\n  \
    \          if(closestInt == (numList.max max 0)) {\n                closestVal\
    \ = closestInt + 1\n            }\n        }\n        closestVal", "        val\
    \ numbers = value.split(\",\").map(_.toInt)\n        // Find distance between\
    \ two points\n        val distance = numbers.zip(numbers).map(x => math.sqrt(x._1\
    \ - x._2)).max\n        distance.round", "        val parts = value.split(\"\\\
    \\.\").map(_.toInt)\n        val minDiff = math.max(parts(0)-parts(1), parts(0)-parts(2))\n\
    \        val minDiffAbs = math.abs(minDiff)\n        val minDiffSign = math.signum(minDiffAbs)\n\
    \        val minDiffFloor = math.floor(minDiffAbs)\n        val minDiffCeil =\
    \ math.ceil(minDiffAbs)\n        val minDiffFloorCeil = math.floorCeil(minDiffAbs)\n\
    \        val minDiffCeilCeil = math.ceilCeil(minDiffAbs)\n\n        if (minDiffCeil==0){\n\
    \            return math.min(parts(0), parts(1))\n        }\n\n        if (minDiff==0){\n\
    \            return math.min(parts(0), parts(1))\n        }\n\n        if (minDiffFloor\
    \ == 0) {\n            var newDiff = math.max(parts(0)-parts(1), parts(0)-parts(2))\n\
    \            if (newDiff==0) {\n                return math.min(parts(0), parts(1))\n\
    \            }\n            var newDiffAbs = math.abs(newDiff)\n            var\
    \ newDiffSign = math.signum(newDiffAbs)\n            var newDiffFloor = math.floor(newDiffAbs)\n\
    \            var newDiffCeil = math.ceil(newDiffAbs)\n            var newDiffFloorCeil\
    \ = math.floorCeil(newDiffAbs)\n            var newDiffCeilCeil = math.ceilCeil(newDiffAbs)\n\
    \            if (newDiffCeil==0){\n                return math.min(parts(0), parts(1))\n\
    \            }\n            if (newDiff==0){\n                return math.min(parts(0),\
    \ parts(1))\n            }\n            if (newDiffFloor == 0) {\n           \
    \     var newDiff = math.max(parts(0)-parts(1), parts(0)-parts(2))\n         \
    \       if (newDiff==0) {\n                    return math.min(parts(0), parts(1))\n\
    \                }\n                var newDiffAbs = math.abs(newDiff)\n     \
    \           var newDiffSign = math.signum(newDiffAbs)\n                var newDiffFloor\
    \ = math.floor(newDiffAbs)\n                var newDiffCeil = math.ceil(newDiffAbs)\n\
    \                var newDiffFloorCeil = math.floorCeil(newDiffAbs)\n         \
    \       var newDiffCeilCeil = math.ceilCeil(newDiffAbs)\n                if (newDiffCeil==0){\n\
    \                    return math.min(parts(0), parts(1))\n                }\n\
    \                if (newDiff==0){\n                    return math.min(parts(0),\
    \ parts(1))\n                }\n                if (newDiffFloor == 0) {\n   \
    \                 var newDiff = math.max(parts(0)-parts(", "        // Your code\
    \ goes here\n        val input = value.split(\"\\\\.\").map{\n            _.toLong\n\
    \        }.toList\n        val difference = (input - input(0));\n        val differences\
    \ = difference.collect{\n            (diff : Double, idx : Long) => (diff < 0,\
    \ idx)\n        }.toList;\n        val toRemove = differences.find(_._1==true).get._2;\n\
    \        val toAdd = differences.find(_._1 == false).get._2;\n        input(toRemove)\
    \ = input(toAdd)\n        (input(0) + input(1)).toLong", "        val valueAsLong\
    \ = parseLong(value)\n        val min = valueAsLong - Math.abs(valueAsLong % 1)\n\
    \        val max = valueAsLong + Math.abs(valueAsLong % 1)\n        val isClosestToZero\
    \ = min % 1 == 0 && max % 1 == 0\n        if (isClosestToZero) {\n           \
    \ return valueAsLong\n        }\n        else {\n            return Math.min(min,\
    \ max)\n        }", "        val digits = value.map(_.toInt).toArray\n       \
    \ // Find the closest integer\n        if (digits.sum == 0) return 0\n       \
    \ var closestDigit : Int = -1\n        var sum : Long = 0\n        digits.foreach\
    \ {\n            digit => {\n                sum += digit\n                closestDigit\
    \ = digit\n            }\n        }\n        // Return the closest integer\n \
    \       if (sum < 0) return 0\n        else return closestDigit", "        val\
    \ intValue : Long = value match {\n            case \"0\" => 0\n            case\
    \ \"1\" => 1\n            case \"2\" => 2\n            case \"3\" => 3\n     \
    \       case \"4\" => 4\n            case \"5\" => 5\n            case \"6\" =>\
    \ 6\n            case \"7\" => 7\n            case \"8\" => 8\n            case\
    \ \"9\" => 9\n            case _ => Integer.parseInt(value)\n        }\n     \
    \   var closest : Long = intValue\n        var diff : Long = 0\n        while\
    \ (closest != intValue) {\n            if (diff < Math.abs(closest - intValue))\
    \ {\n                diff = Math.abs(closest - intValue)\n                closest\
    \ = intValue\n            } else {\n                closest = closest + diff\n\
    \            }\n        }\n        return closest", "        val xs = value.split(\"\
    \\\\.\").map(_.toLong)\n        xs.foldLeft((-99999999,99999999)){\n         \
    \   case((diff,best) ,x) => if (x > best) (x, diff) else (best,diff)\n       \
    \ }", "        val nums = value.split(\"\\\\.\").map(_.toInt)\n        val (min,\
    \ max) = nums.foldLeft((0, Long.MaxValue))((a, b) => {\n            val l = abs(b\
    \ - a).toInt\n            if (l < min.asInstanceOf[Int]) (a, b) else (l, a)\n\
    \        })\n        val mid = (min + max) / 2\n        val nums2 = nums.map(x\
    \ => Math.round(x * 10) / 10)\n        nums2.map(_ + mid)", "        if (value.length\
    \ == 1)\n            value + \"0\"\n        val numString = value\n        val\
    \ n = numString.toDouble\n        val numbers = List.range(1, numString.length).map(x\
    \ => numString.substring(0, x)).toList\n        val dists = numbers.map(n => Math.pow(10.0,\
    \ (n - numString.toDouble)))\n        val min = math.min(dists.map(d => Math.pow(n,\
    \ 1.0 / d)))\n        val closestVal = numbers.map(n => Math.pow(n, 1.0 / min))\n\
    \        val index = closestVal.indexOf(min)\n        val rounding = closestVal(index).toString.substring(2)\n\
    \        (n - numString.toDouble).toLong * 1 + rounding", "        val stringToInt\
    \ = value.trim.toInt\n        if (stringToInt == 0)\n            return 0\n  \
    \      val closestInt = (stringToInt - math.abs(stringToInt - math.abs(stringToInt)))\n\
    \        closestInt > 0L ? closestInt.toLong : -closestInt.toLong", "        val\
    \ ints = value.split('.').toList\n        if (ints.size>1) {\n            val\
    \ int1 = ints.head.toLong\n            val int2 = ints.last.toLong\n         \
    \   if (Math.abs(int1 - int2) == Math.abs(int1 - int2))\n                return\
    \ int1\n            else\n                return int2\n        }\n        else\n\
    \            ints.head.toLong", "        // Extract the numbers\n        val (intValue,\
    \ decimal) = value.split(\".\") match {\n            case Array(a, b) => a.toLong\
    \ * 10 + b.toLong\n            case a => a.toLong\n        }\n        // Find\
    \ the closest integer value\n        val closestIntegerValue = (intValue - decimal.abs()).toInt\n\
    \        // Return the closest integer value\n        closestIntegerValue", " \
    \       // Get a list of integers that represent the value.\n        val ints\
    \ = value.splitAt(value.length - 1).map(_.toInt)\n        // If all the integers\
    \ in the list are the same length, return the list index\n        // of the first\
    \ one\n        if(ints.forall(_.size == ints.head.size)) {\n            return\
    \ ints.indexWhere(_.size == ints.head.size)\n        } else {\n            //\
    \ Otherwise, find the closest integer to the first integer\n            // that\
    \ has a length of at least one\n            val minIndex = ints.indexWhere(x =>\
    \ x.size == ints.head.size)\n            val minValue = ints(minIndex)\n     \
    \       val diffs = minValue - ints\n            // If the list is equidistant\
    \ from two integers then return the\n            // smallest one\n           \
    \ if(diffs.forall(_.toDouble < 0)) {\n                return minIndex\n      \
    \      } else { \n                // Otherwise, return the index of the smallest\
    \ number greater than \n                // the integer represented by the first\
    \ integer in the list\n                val greaterIndex = ints.indexWhere(_.size\
    \ > minValue)\n                ints(greaterIndex)\n            }\n        }",
  "        val intValue  = Integer.parseInt(value)\n        val diff      = intValue\
    \ - intValue%100\n        val diff2     = diff - diff%10\n        val diff3  \
    \   = diff2 - diff2%10\n        val diff4     = diff3 - diff3%10\n        val\
    \ diff5     = diff4 - diff4%10\n        val diff6     = diff5 - diff5%10\n   \
    \     val diff7     = diff6 - diff6%10\n        val diff8     = diff7 - diff7%10\n\
    \        val diff9     = diff8 - diff8%10\n        val diff10    = diff9 - diff9%10\n\
    \        val diff11    = diff10 - diff10%10\n        val diff12    = diff11 -\
    \ diff11%10\n        val diff13    = diff12 - diff12%10\n        val diff14  \
    \  = diff13 - diff13%10\n        val diff15    = diff14 - diff14%10\n        val\
    \ diff16    = diff15 - diff15%10\n        val diff17    = diff16 - diff16%10\n\
    \        val diff18    = diff17 - diff17%10\n        val diff19    = diff18 -\
    \ diff18%10\n        val diff20    = diff19 - diff19%10\n        val diff21  \
    \  = diff20 - diff20%10\n        val diff22    = diff21 - diff21%10\n        val\
    \ diff23    = diff22 - diff22%10\n        val diff24    = diff23 - diff23%10\n\
    \        val diff25    = diff24 - diff24%10\n        val diff26    = diff25 -\
    \ diff25%10\n        val diff27    = diff26 - diff26%10\n        val diff28  \
    \  = diff27 - diff27%10\n        val diff29    = diff28 - diff28%10\n        val\
    \ diff30    = diff29 - diff29%10\n        val diff31    = diff30 - diff30%10\n\
    \        val diff32    = diff31 - diff31%10\n        val diff33    = diff32 -\
    \ diff32%10\n        val diff34    = diff33 - diff33%10\n        val diff35  \
    \  = diff34 - diff34%10\n        val diff36    = diff35 - diff35%10\n        val\
    \ diff37    = diff36 - diff36%10\n        val diff38    = diff37 - diff37%10\n\
    \        val diff39    = diff38 - diff38%10\n        val ", "        val parsedInt\
    \ : Long = Try(BigDecimal(value.toDouble)).orElse(0L)\n        val min = parsedInt\
    \ - parsedInt%min\n        val max = parsedInt + parsedInt%max\n        if (min\
    \ < max){\n            min\n        }else{\n            max\n        }", '        //  write
    your code', "        val values = value.split(\"\\\\.\") // Split on \".\"\n \
    \       var smallest = Integer.MIN_VALUE\n        var largest = Integer.MAX_VALUE\n\
    \        values.foreach { value =>\n            val newValue = value.trim.toInt\n\
    \            if (smallest > newValue) {\n                smallest = newValue\n\
    \            }\n            if (largest < newValue) {\n                largest\
    \ = newValue\n            }\n        }\n        if (largest < smallest) {\n  \
    \          // If largest is smaller than smallest then largest is larger\n   \
    \         // than smallest and smallest is smaller than largest.\n           \
    \ largest += 1\n        }\n        largest - 1", "        val intValue = value.toDouble\n\
    \        val listOfNumbers = List(intValue, 0)\n        val indexOfZero = listOfNumbers.indexOf(listOfNumbers.max)\n\
    \        val numberOfIntegers = listOfNumbers.length\n        val differenceFromZero\
    \ = indexOfZero * numberOfIntegers\n        val differenceBetweenNumbers = Math.abs(intValue\
    \ - listOfNumbers(indexOfZero))\n        val roundAwayFromZero = differenceFromZero\
    \ + differenceBetweenNumbers\n        roundAwayFromZero.toLong", "        val\
    \ numbers = value.split(\",\")\n        val smallestInteger = numbers(0).trim.toInt\n\
    \        val largestInteger = numbers(numbers.length-1).trim.toInt\n        var\
    \ smallestDiff = smallestInteger - smallestInteger\n        var largestDiff =\
    \ largestInteger - largestInteger\n        numbers(0).trim.toInt match {\n   \
    \         case x if (x == \"\") =>\n                0\n            case x =>\n\
    \                val newValue = smallestInteger + smallestDiff\n             \
    \   if (newValue > largestInteger) {\n                    largestDiff = smallestDiff\
    \ - smallestInteger\n                    smallestDiff = largestInteger - newValue\n\
    \                    largestInteger = newValue\n                    smallestInteger\
    \ = newValue\n                }\n                newValue\n        }", "     \
    \   val num = value.toLong\n        var result = num\n        val smallestDiff\
    \ = math.abs(num - math.floor(num))\n        val largestDiff = math.abs(num -\
    \ math.ceil(num))\n        if (smallestDiff < largestDiff) {\n            if (num\
    \ < math.floor(num)) {\n                result = math.floor(num)\n           \
    \ } else if (num > math.ceil(num)) {\n                result = math.ceil(num)\n\
    \            }\n        }\n        result", "        // Convert value to Long\
    \ type\n        val value = value.asInstanceOf[String]\n        val values = value.split('.').toList\n\
    \        val integer = values.map(_.toLong).sum\n        val difference = abs(integer\
    \ - value.toLong)\n        if (difference <= 10){\n            return integer\n\
    \        }\n        return integer - (difference / 10)", "        // Use a mutable\
    \ set to hold a list of numbers. When we see a\n        // number that is equidistant\
    \ from two others, remove them\n        // from the set and return the new set.\
    \ Otherwise, return the\n        // original set\n        val mySet = mutable.HashSet[String]()\n\
    \        mySet += value\n        while (mySet.nonEmpty && mySet.toList.groupBy(_\
    \ - mySet.head).keys.toList.size > 1) {\n            mySet -= mySet.head\n   \
    \     }\n        mySet.toList.headOption.getOrElse(0)", "        val num = new\
    \ BigDecimal(value)\n        // Return the closest integer less than or equal\
    \ to the number\n        num.intValue", "        var closestInteger = value.indexOf(\"\
    .\") == -1 ? value.toLong : int.parseInt(\"0\"+ value)\n        var closestDouble\
    \ = closestInteger.toDouble\n        var closestInt = closestInteger.toInt\n \
    \       // Keep dividing closestDouble by 10 until the fraction is 0.\n      \
    \  // Then subtract that from the closestInt until it's 0.\n        // This way\
    \ closestDouble will be closest to closestInt.\n        while(closestDouble >\
    \ 0.0 && closestDouble < 1.0) {\n            closestDouble /= 10.0;\n        \
    \    closestInt -= closestDouble * closestInt;\n        }\n        closestInt",
  "        //Use a for loop to iterate through the String and convert each char\n\
    \        //into a numeric value\n        //The value variable is of type String\n\
    \        for(i <- 0 until value.length){\n            //If this char represents\
    \ a number greater than zero change it\n            //to an integer\n        \
    \    //The charAt() method takes a char and returns a char\n            if(i.value\
    \ >= '0' && i.value <= '9'){\n                //Convert the char to an int\n \
    \               val i = i.toInt\n                //Return the closest int\n  \
    \              return i\n            }\n        }\n        //Return 0 if the loop\
    \ did not find a number\n        return 0", "      val stringArray = value.split(\"\
    .\")\n      val lastNumber = stringArray(0)\n      val difference = stringArray(0)\
    \ - stringArray(1).reverse\n      val maxDiff = Math.abs(difference)\n      val\
    \ closestDiff = Math.abs(difference - maxDiff)\n      val closestDiffIndex = (difference\
    \ - maxDiff).abs.toInt\n      val closestDiff = stringArray(0..closestDiffIndex).reverse\n\
    \      val roundingDiff = Math.abs(lastNumber - closestDiff(0))\n      val roundingDiffIndex\
    \ = lastNumber - closestDiff(0).abs.toInt\n      val roundingDiff = stringArray(0..roundingDiffIndex).reverse\n\
    \      val roundingDiffIndex = roundingDiffIndex + roundingDiff\n      val roundingDiff2\
    \ = Math.abs(roundingDiffIndex - difference)\n      val roundingDiffIndex = Math.max(roundingDiffIndex,\
    \ roundingDiffIndex)\n      val roundingDiff2 = Math.max(roundingDiff2, roundingDiff2)\n\
    \      val roundingDiffIndex = roundingDiffIndex + roundingDiff\n      val roundingDiffIndex2\
    \ = Math.max(roundingDiffIndex2, roundingDiffIndex)\n      val roundingDiffIndex2\
    \ = Math.max(roundingDiffIndex2, roundingDiff2)\n      val roundingDiffIndex2\
    \ = roundingDiffIndex + roundingDiff\n      val roundingDiffIndex3 = Math.max(roundingDiffIndex2,\
    \ roundingDiffIndex)\n      val roundingDiffIndex4 = Math.max(roundingDiffIndex3,\
    \ roundingDiffIndex)\n      val roundingDiffIndex5 = Math.max(roundingDiffIndex4,\
    \ roundingDiffIndex)\n      val roundingDiffIndex6 = Math.max(roundingDiffIndex5,\
    \ roundingDiffIndex)\n      val roundingDiffIndex7 = Math.max(roundingDiffIndex6,\
    \ roundingDiffIndex)\n      val roundingDiffIndex8 = roundingDiffIndex + roundingDiff\n\
    \      val roundingDiffIndex9 = roundingDiffIndex + roundingDiff\n      val roundingDiffIndex10\
    \ = roundingDiffIndex + roundingDiff\n      val roundingDiffIndex11 = roundingDiffIndex\
    \ + roundingDiff\n      val roundingDiffIndex12 = roundingDiffIndex + roundingDiff\n\
    \      val roundingDiffIndex13 = roundingDiffIndex + roundingDiff\n      val roundingDiffIndex14\
    \ = roundingDiffIndex + roundingDiff\n      val roundingDiffIndex15 = roundingDiffIndex\
    \ + roundingDiff\n      val roundingDiffIndex16 = roundingDiffIndex + roundingDiff\n\
    \      val roundingDiffIndex", "        var closestInt : Long = Long.MinValue\n\
    \        var closestDiff = Long.MinValue\n        val parts = value.split(\".\"\
    )\n        val firstPart = parts.get(0)\n        val secondPart = parts.get(1)\
    \ match {\n            case s if s.isEmpty() => \"0\"\n            case s2 =>\
    \ s2\n        }\n        var num : Long = secondPart.toLong * 10\n        var\
    \ num2 : Long = firstPart.toLong * 10\n        var diff : Long = Math.abs(num\
    \ - num2)\n        while (num != num2){\n            num2 += diff\n          \
    \  if (num2 == num){\n                diff -= 1\n            }\n            num\
    \ += 1\n        }\n        closestInt = num\n        closestDiff = diff\n    \
    \    return closestInt", "        val digits = value.substring(1, value.length-1).toInt\n\
    \        if(digits < 2) digits\n        else {\n            val lastDigit = value.substring(0,value.length-1).toInt\n\
    \            if(abs(digits-lastDigit) == 1) digits+lastDigit\n            else\
    \ lastDigit\n        }", "        // Your code goes here\n        val nums = value.split(\"\
    ,\")\n        val l = new mutable.LinkedList[Long](nums.map(_.toLong))\n     \
    \   val maxDist = l.max\n        val numDist = l.map(x => Math.abs(x - maxDist)).toList.sorted.last\n\
    \        return maxDist + numDist", "        val splits = value.split(\"\\\\.\"\
    );\n        var num : Long = 0\n        val diff : Double = splits.map{_.toInt}.reduce(_\
    \ + _) - Double.valueOf(splits.head.toInt)\n        if(diff < 0){\n          \
    \  num = -diff\n        }else{\n            num = diff\n        }\n        return\
    \ num.toLong", "        val value = value.trim\n        if (value.length==1) value.toLong\n\
    \        else {\n            val digits = value.dropRight(value.length/2).split(\"\
    \"\"\\.\"\"\").map(_.toDouble)\n            val diffs = digits.map(_.minus(digits(0)))\n\
    \            val closestDiff = diffs.foldLeft((0,0)){case ((diff,idx),d) => if\
    \ (diff.isLessThan(d)) (diff,idx) else (d.abs,idx) }._1\n            if (closestDiff\
    \ < digits(0)) digits(0).toLong else digits(0).abs + 1\n        }", "        val\
    \ list = value.split(\" \").toList\n        var count = 0\n        var newVal\
    \ = 0\n        var closestVal = 0\n        list.foreach(num => {\n           \
    \ newVal = java.lang.Long.parseLong(num).toDouble\n            if (Math.abs(newVal-closestVal)\
    \ < Math.abs(newVal-closestVal)) {\n                closestVal = newVal\n    \
    \        }\n            count += 1\n        })\n        closestVal.toLong", " \
    \       val intValue = value.toLong\n        if (intValue == intValue.toLong)\
    \ {\n            return intValue\n        }\n        if (intValue == (intValue\
    \ - 1)) {\n            return intValue\n        }\n        if (intValue == (intValue\
    \ + 1)) {\n            return intValue\n        }\n        return intValue - 1",
  "        val doubled = value.toDouble\n        // Find any two numbers that are\
    \ equidistant from doubled\n        val equidistant = findEquidistant(doubled)\n\
    \        // If the number is equidistant from two numbers, return the\n      \
    \  // number furthest from zero.\n        if (equidistant.length == 2) {\n   \
    \         val f0 = equidistant.head\n            val f1 = equidistant.last\n \
    \           val difference = (f1 - f0).abs\n            if (difference > 0.001)\
    \ {\n                (f0 + difference - 0.001).toLong\n            } else {\n\
    \                (f0 - difference + 0.001).toLong\n            }\n        } else\
    \ {\n            // If the number is equidistant to only one number, return\n\
    \            // that number.\n            equidistant.head.toLong\n        }",
  "        val splits = value.split(\".\")\n        val lval = splits(0)\n       \
    \ val lvalInts = lval.split(\"\\\\.\").toArray.map(_.toInt)\n        val rval\
    \ = splits(1)\n        val rvalInts = rval.split(\"\\\\.\").toArray.map(_.toInt)\n\
    \        var closestIndex = -1\n        var minDistance = Long.MaxValue\n    \
    \    for (i <- 0 until lvalInts.length - 1) {\n            var lvalIntDistance\
    \ = abs(lvalInts(i) - lvalInts(i + 1))\n            var rvalIntDistance = abs(rvalInts(i)\
    \ - rvalInts(i + 1))\n            if (lvalIntDistance < rvalIntDistance) {\n \
    \               closestIndex = i\n                minDistance = min(minDistance,\
    \ lvalIntDistance)\n            }\n            if (lvalIntDistance == rvalIntDistance)\
    \ {\n                if (abs(lvalInts(i) - lvalInts(i + 1)) < abs(rvalInts(i)\
    \ - rvalInts(i + 1))) {\n                    closestIndex = i\n              \
    \      minDistance = min(minDistance, abs(lvalInts(i) - lvalInts(i + 1)))\n  \
    \              }\n            }\n        }\n        if (minDistance == Long.MaxValue)\
    \ {\n            -1\n        } else {\n            minDistance\n        }", " \
    \       value match {\n            case n if n.startsWith(\"0\") => 0\n      \
    \      case n => n.toLong\n        }", "        val num = value.trim.toDouble\n\
    \        val remainder = num % 1\n        if (remainder > 0)\n            return\
    \ math.ceil(remainder).asInstanceOf[Long]\n        else\n            return math.floor(remainder).asInstanceOf[Long]",
  "        val num = value.asInstanceOf[String]\n        val numAsInt = num.asInstanceOf[Int]\n\
    \        val intToUse = if (numAsInt < 0) -numAsInt else numAsInt\n\n        val\
    \ intDistant = numAsInt - intToUse\n        val intDiff = abs(intDistant)\n  \
    \      val intDiffToZero = if (intDist < 0) 1 else -1\n\n        val diffInt =\
    \ intDiffToZero.min(numAsInt - intToUse)\n        if (diffInt == 0) intDistant\
    \ else diffInt", "        val input = value.trim.toDouble\n        var closest\
    \ = (input - 0.5).toInt\n        while(closest != closest){\n            if(closest\
    \ < 0){\n                closest = -closest\n            }\n            else {\n\
    \                closest += 1\n            }\n        }\n        closest", " \
    \       val parts = value.split(\".\".toList)\n        val first = parts.head.toInt\n\
    \        val last = parts.tail.last.toInt\n        val diff = last - first\n \
    \       val mod = diff % 1\n        if (mod > 0) {\n            return last -\
    \ (diff - mod)\n        } else {\n            return first + diff\n        }",
  "        val arr = value.split(\".\").map(_.toInt)\n        val xs = arr.takeWhile(_\
    \ > 0)\n        val ys = arr.dropWhile(_ > 0)\n        val xs_min = xs.min\n \
    \       val ys_min = ys.min\n        val x_min = math.min(xs_min, ys_min)\n  \
    \      val x_max = math.max(xs_min, ys_min)\n        val y_max = math.max(x_min,\
    \ xs_min)\n        val x_diff = x_max - x_min\n        val y_diff = y_max - y_min\n\
    \        (x_diff + y_diff) / 2", "        val tokens = value.split(\".\") // Split\
    \ on \".\" to get the two integers\n        val x = tokens(0).toLong // Get the\
    \ first integer\n        val y = tokens(1).toLong // Get the second integer\n\
    \        // Calculate the difference\n        val difference = Math.abs(x - y)\n\
    \        // Now check to see if difference is closer than a certain value (eg\
    \ 1)\n        if (difference < 1) {\n            difference\n        } else {\n\
    \            // If it's closer than a certain value (eg 1), then return the\n\
    \            // difference between the two integers\n            val diff = x\
    \ - y\n            // If it's equidistant, then return one integer that is closer\n\
    \            if (diff == 0) x - y else x - y + 1\n        }", "        val intPart\
    \   = value.substring(0,1)\n        val decimals = value.substring(1).toDouble\n\
    \        if (decimals == 0.0) intPart.toLong\n        else intPart.toLong + math.ceil(decimals)",
  "        value match {\n            case str if str.length == 0 => throw new IllegalArgumentException(s\"\
    The value passed in must be non-empty. Given $value\")\n            case _ =>\
    \ {\n                val splitStr = value.split(\"\"\"\\.\"\"\")\n           \
    \     val int1 = splitStr(0)\n                val int2 = splitStr(1)\n\n     \
    \           if (int1 == \"\") {\n                    if(int2 == \"\") (intToInt(splitStr(0)).abs)\n\
    \                    else (intToInt(splitStr(0)).abs + intToInt(splitStr(1)).abs)\n\
    \                } else if (int2 == \"\") {\n                    (intToInt(int1).abs\
    \ + intToInt(splitStr(1)).abs)\n                } else {\n                   \
    \ (intToInt(int1).abs + intToInt(int2).abs)\n                }\n            }\n\
    \        }", "        val parts = value.split(\"\\\\.\") //split into number and\
    \ fraction parts i.e. \"10.5\" would be [\"10\",\"5\"]\n        val fractionPart\
    \ = parts(1) //grab the fraction part i.e. \"5\"\n        var closest = java.lang.Long.MAX_VALUE\
    \ //set initial max value to avoid infinite loop\n        val distanceMap = mutable.TreeMap[Long,Long]()\
    \ //create a map to hold pairs of distance from current number to each other number\n\
    \        for (i <- parts(0).asDigits.reverse to parts.last by -1){ //reverse the\
    \ digits because we want largest number first\n            val difference = java.lang.Math.abs(java.lang.Long.valueOf(i).asDigits\
    \ - java.lang.Long.valueOf(fractionPart).asDigits) //calculate the difference\
    \ between current number and its closest integer part i.e. \"5\" minus \"10\"\
    \ = -5\n            if (distanceMap.contains(difference)) //if map contains a\
    \ pair with that difference add the number\n                distanceMap += (difference\
    \ -> distanceMap(difference) + java.lang.Long.valueOf(i).asDigits) //add the number\
    \ to the map\n            else if (distance > difference) //if the difference\
    \ between the current number and closest integer part is greater than the number\
    \ being asked for, keep track of the closest integer and the distance\n      \
    \          distanceMap += (difference -> java.lang.Long.valueOf(i).asDigits) //add\
    \ the closest integer and the number to the map\n            else if (distanceMap.contains(difference))\
    \ //if the number being asked for is closer to the number already in the map then\
    \ keep track of the closest integer and the distance\n                distanceMap\
    \ += (difference -> distanceMap(difference) + java.lang.Long.valueOf(i).asDigits)\
    \ //add the number to the map\n            else //else keep track of the closest\
    \ integer and the distance\n                distanceMap += (difference -> java.lang.Long.valueOf(i).asDigits)\
    \ //add the closest integer and the number to the map\n        }\n        val\
    \ closestInteger = distanceMap.max._2 //get the value with the maximum distance\n\
    \        if (closestInteger > closest) //if the number being asked for is closer\
    \ to the number already in the map then return that number\n            closest\n\
    \        else\n            closestInteger", '        // Implement here', "   \
    \     val numbers = value.split(\",\")\n        val convertedNumber = (numbers(0).toLong).asInstanceOf[Long]\n\
    \        val difference = numbers.map((x) => convertedNumber - x.toLong).toArray\n\
    \        val indexOfClosestElement = Math.abs(difference).indexOf(Math.max(Math.abs(difference(0)),\
    \ Math.abs(difference(1)))) + 1 \n        convertedNumber.asInstanceOf[Long] -\
    \ convertedNumber.asInstanceOf[Long](indexOfClosestElement)", "        def closestInt2(n:\
    \ String, d: Long) : Long = n.toDouble.toInt match {\n            case 1 => d\n\
    \            case x =>\n                val a = n.toDouble - d\n             \
    \   val b = n.toDouble + d\n                if (Math.abs(a) < Math.abs(b)) {\n\
    \                    a\n                } else {\n                    b\n    \
    \            }\n        }\n\n        value match {\n            case s =>\n  \
    \              val arr = s.split('.')\n                val num = arr(0).toLong\n\
    \                val dec = arr(1).toLong\n                val inc = dec * -1\n\
    \                val dec2 = closestInt2(dec, num)\n                val inc2 =\
    \ closestInt2(inc, num)\n                if (Math.abs(num - dec2) > Math.abs(num\
    \ - inc2)) {\n                    num\n                } else {\n            \
    \        dec2\n                }\n            case _ => 0\n        }", "     \
    \   val xs = value.split(\"\\\\.\").map(_.toLong).toArray\n        if(xs.length\
    \ == 1) {\n            val ys = xs.map((x:Long) => { (x - floor(x)) * (x - floor(x))\
    \ })\n            val minIndex = ys.indexOf(min(ys).toDouble)\n            minIndex\
    \ < 0 ? xs(0) : xs(minIndex)\n        }\n        else {\n            val ys =\
    \ xs.map((x:Long) => { (x - floor(x)) * (x - floor(x)) })\n            val minIndex\
    \ = ys.indexOf(min(ys).toDouble)\n            if(minIndex < 0) xs(0)\n       \
    \     else xs(minIndex)\n        }", "        val value = value.trim.toDouble\n\
    \        var diff = Math.abs(value - closestInteger(value).toDouble)\n       \
    \ var minDiff = diff\n        var minValue: Double = 0.0\n        for(i <- 0 until\
    \ 10){\n            val nextValue = closestInteger(i+1).toDouble\n           \
    \ val nextDiff = Math.abs(nextValue - value)\n            if(nextDiff < minDiff){\n\
    \                minValue = nextValue\n                minDiff = nextDiff\n  \
    \          }\n        }\n        math.round(minValue)", "        // Use a regular\
    \ expression to search for the decimal point\n        val p = \".*[\\\\d.]+\"\
    .r\n        // Parse the string into an array of integers, ignoring the decimal\
    \ point\n        val intArray = p findAll { s => s !=\"\" }.toArray.map( _.toInt\
    \ )\n        // Convert the array of integers into an array of doubles\n     \
    \   val doubleArray = intArray.map(_.toDouble)\n        // Find the closest integer\
    \ to the double value of the given number\n        val closestDouble = doubleArray.min(Math.abs)\n\
    \        // Return the value as a long\n        closestDouble.toLong", "     \
    \   //Using a HashMap to store all the original ints\n        // To store the\
    \ original ints\n        val originalNums = new HashMap[String, Long]()\n    \
    \    //To store the new ints\n        val nums = new HashMap[String, Long]()\n\
    \        //To store the original ints after the change\n        val numsWithChanges\
    \ = new HashMap[String, Long]()\n        //To store the original ints before the\
    \ change\n        val numsWithoutChanges = new HashMap[String, Long]()\n\n   \
    \     //Using a loop over the given value and adding the integer to a map\n  \
    \      for (i <- value.split(\"\\\\.\") ) originalNums(i) = originalNums.getOrElse(i,\
    \ 0) + 1\n\n        //Looping over all the keys in originalNums map\n        for\
    \ (i <- originalNums.keys) nums(i) = nums.getOrElse(i, 0) + 1\n\n        //Looping\
    \ over all the keys in nums map and updating value if needed\n        for (i <-\
    \ nums.keys) if (originalNums.get(i) < nums.get(i)) numsWithChanges(i) = numsWithChanges.getOrElse(i,\
    \ 0) + nums(i) - originalNums.get(i)\n        else numsWithoutChanges(i) = numsWithoutChanges.getOrElse(i,\
    \ 0) + nums(i) - originalNums.get(i)\n\n        //Returning the highest of all\
    \ the values with changes\n        val highestWithChanges = numsWithChanges.values.max\n\
    \        //Returning the lowest of all the values with changes\n        val lowestWithChanges\
    \ = numsWithChanges.values.min\n\n        //Returning the highest of all the values\
    \ with no changes\n        val highestWithoutChanges = numsWithoutChanges.values.max\n\
    \        //Returning the lowest of all the values with no changes\n        val\
    \ lowestWithoutChanges = numsWithoutChanges.values.min\n\n        //Returning\
    \ the highest of all the values\n        val highest = nums.values.max\n     \
    \   //Returning the lowest of all the values\n        val lowest = nums.values.min\n\
    \n        //Returning the highest of all the values\n        val highestTotal\
    \ = originalNums.values.max\n        //Returning the lowest of all the values\n\
    \        val lowestTotal = originalNums.values.min\n\n        //Returning the\
    \ highest of all the values\n        val highestTotalWithChanges = numsWithChanges.values.max\n\
    \        //Returning the lowest of all the values\n        val lowestTotalWithChanges\
    \ = numsWithChanges.values.min\n\n        //Returning the highest of all the values\n\
    \        val highestTotalWithoutChanges = numsWithoutChanges.values.max\n    \
    \    //Returning the lowest of all the values\n        val lowestTotalWithoutChanges\
    \ = numsWithoutChanges.values.min\n\n        val ", "        val number = value.toDouble\n\
    \        if(number < 0.0 || number > 1.0) {\n            throw new IllegalArgumentException(\"\
    Number must be in range [0.0, 1.0]\")\n        }\n        val remainder = math.floor(number)\n\
    \        val closest = math.abs(remainder - number)\n        if(closest > remainder)\
    \ {\n            return math.floor(remainder)\n        } else {\n            return\
    \ math.ceil(remainder)\n        }", "        val numbers = value.dropWhile(_!='.').dropWhile(_!='e').dropWhile(_!='E').dropWhile(_!='-')\n\
    \        val integer = numbers.toInt\n        val result = (number - integer).abs.toInt\n\
    \        result", "        def gcd(a : Long, b : Long) : Long = {\n          \
    \  if (b > 0) {\n                val c = a % b\n                gcd(b, c)\n  \
    \          } else {\n                a\n            }\n        }\n        def\
    \ lcm(a: Long, b: Long) : Long = {\n            if (b > 0) {\n               \
    \ val c = a % b\n                val r = a / b\n                val k = a / c\n\
    \                r * lcm(c, r) + k * lcm(b, k)\n            } else {\n       \
    \         a\n            }\n        }\n\n        def euclid(a : Long, b : Long)\
    \ : Long = {\n            if (b > 0) {\n                val c = a % b\n      \
    \          euclid(b, c)\n            } else {\n                a\n           \
    \ }\n        }\n\n        // Compute the factors of the number\n        val factors\
    \ = value.map(_.toInt).map(x => x * x).filter(x => x != 1).map(x => x / gcd(x,\
    \ 10))\n            .map(x => x * euclid(x, 10))\n            .map(x => x / euclid(x,\
    \ 10).ceil)\n            .map(x => x * lcm(100, x))\n            .map(x => x /\
    \ lcm(100, x).ceil)\n\n        // If the number is a multiple of one and the remainder\
    \ is zero, return it.\n        // Otherwise, return the minimum value between\
    \ the two numbers\n        if (factors.contains(1) && factors.contains(0)) return\
    \ value.toLong\n        else if (factors.contains(0)) return factors.min\n   \
    \     else return (factors.min - value.toLong).toLong", "        def distance(x:\
    \ String, y: String) : Double = {\n            val firstNumber = 0l\n        \
    \    val secondNumber = 0l\n            val firstNumberString = x\n          \
    \  val secondNumberString = y\n            val firstNumberSplit = firstNumberString.split('.')\n\
    \            val secondNumberSplit = secondNumberString.split('.')\n         \
    \   val firstNumberInt = firstNumberSplit.length\n            val secondNumberInt\
    \ = secondNumberSplit.length\n            if (firstNumberInt == 1 && secondNumberInt\
    \ == 1) {\n                val firstValue = firstNumberSplit\n               \
    \ val secondValue = secondNumberSplit\n                val firstValue = firstValue(0).toLong\n\
    \                val secondValue = secondValue(0).toLong\n                Math.sqrt(Math.pow(firstValue\
    \ - secondValue, 2) + Math.pow(secondValue, 2))\n            }\n            else\
    \ if (firstNumberInt == 2 && secondNumberInt == 2) {\n                val firstValue\
    \ = firstNumberSplit\n                val secondValue = secondNumberSplit\n  \
    \              val firstValue = firstValue(1).toLong\n                val secondValue\
    \ = secondValue(1).toLong\n                Math.sqrt(Math.pow(firstValue - secondValue,\
    \ 2) + Math.pow(secondValue, 2))\n            }\n            else if (firstNumberInt\
    \ == 3 && secondNumberInt == 3) {\n                val firstValue = firstNumberSplit\n\
    \                val secondValue = secondNumberSplit\n                val firstValue\
    \ = firstValue(2).toLong\n                val secondValue = secondValue(2).toLong\n\
    \                Math.sqrt(Math.pow(firstValue - secondValue, 2) + Math.pow(secondValue,\
    \ 2))\n            }\n            else {\n                val firstValue = firstNumberString.toDouble\n\
    \                val secondValue = secondNumberString.toDouble\n             \
    \   val difference = firstValue - secondValue\n                val distance =\
    \ Math.pow(difference, 2)\n                distance\n            }\n        }\n\
    \        val numbers = value.split(\",\")\n        val sortedNumbers = numbers.sortWith(_.toDouble\
    \ < _.toDouble)\n        val firstNumberString = sortedNumbers(0)\n        val\
    \ secondNumberString = sortedNumbers(1)\n        val firstNumberSplit = firstNumberString.split('.')\n\
    \        val secondNumberSplit = secondNumberString.split('.')\n        val firstNumberInt\
    \ = firstNumberSplit.length\n        val secondNumberInt = secondNumberSplit.length\n\
    \        if (firstNumberInt == 1 && secondNumberInt == 1) {\n            val firstValue\
    \ = firstNumberSplit\n            val secondValue = secondNumberSplit\n      \
    \      val firstValue = firstValue(0).toLong\n            val secondValue = secondValue(0).toLong\n\
    \            Math.sqrt(Math.pow(firstValue - secondValue, 2) + Math.pow(secondValue,\
    \ 2))\n        }\n        else if (firstNumberInt == 2 && secondNumberInt == 2)\
    \ {\n            val firstValue = firstNumberSplit", "        val numbers = value.toDouble.split('.').map(_.toLong)\n\
    \        val low = math.min(numbers(0), numbers(1))\n        val high = math.max(numbers(0),\
    \ numbers(1))\n        if (numbers(0) == low && numbers(1) == high) low + 10\n\
    \        else if (numbers(0) == high) high - 10\n        else low + ((high - low)\
    \ / 10).floor", "        val parts = value.split(\".\")\n        var smallest\
    \ = (parts(0) split \".\").map(_.toInt).min.toLong\n        var largest = (parts(0)\
    \ split \".\").map(_.toInt).max\n        for (i <- 1 to parts.size - 1) {\n  \
    \          val n = (parts(i-1) split \".\").map(_.toInt).max\n            val\
    \ m = (parts(i-1) split \".\").map(_.toInt).min\n            val diff = (m - n)\
    \ / (2.0 * abs(smallest))\n            smallest = smallest+diff\n            largest\
    \ = largest+diff\n        }\n        val maxLargest = if (largest > 0) largest\
    \ else -largest \n        val minSmallest = if (smallest < 0) smallest else -smallest\
    \ \n        val diff = abs(maxLargest - minSmallest)\n        val closestResult\
    \ = math.round(diff)\n        if (closestResult < smallest) smallest else closestResult",
  "        val xs = value.split(\" \")\n        val a = xs(0)\n        val b = xs(1)\n\
    \        val ab = a.toLong * b\n        val x = a.toLong + b.toLong - ab\n   \
    \     val x = x % a.toLong\n        return x", "        val floatNumber = value.asInstanceOf[String].replaceAll(\"\
    [^0-9.]\", \"\").toFloat\n        val intNumber = value.replaceAll(\"[^0-9.]\"\
    , \"\").toInt\n        if (floatNumber.isNaN || intNumber.isNaN) {\n         \
    \   throw new Exception(\"Cannot parse number \" + value)\n        }\n       \
    \ val diff = (intNumber - floatNumber).abs.toInt\n        math.max(diff / 2, 0)",
  "      val numParts = value.split(\"\\\\.\").map(_.toInt)\n      val difference\
    \ = numParts(1) - numParts(0)\n      if(difference <= 0) numParts(0) - difference\
    \ else numParts(1) - difference", "        val parsedValue = Try(parse(value)).toOption\n\
    \        parsedValue.flatMap { value =>\n            // TODO: Add more tests\n\
    \            val twoDecimals = value.dropRight(2).takeRight(2)\n            val\
    \ isEvenOrOdd = twoDecimals.last % 2 == 0\n            val isEven = twoDecimals.head\
    \ % 2 == 0\n            val isOdd = twoDecimals.head % 2 != 0\n            if(isEvenOrOdd\
    \ && isEven){\n                twoDecimals.last + 1 \n            }\n        \
    \    else if(isEvenOrOdd && isOdd){\n                twoDecimals.last - 1\n  \
    \          }\n            else if(isEvenOrOdd && !isEven && !isOdd){\n       \
    \         twoDecimals.last + 0.5\n            }\n            else if(isEvenOrOdd\
    \ && !isEven && isOdd){\n                twoDecimals.last - 0.5\n            }\n\
    \            else if(!isEvenOrOdd && !isEven && !isOdd && twoDecimals.last < 0){\n\
    \                twoDecimals.last + 1\n            }\n            else if(!isEvenOrOdd\
    \ && !isEven && !isOdd && twoDecimals.last > 0){\n                twoDecimals.last\
    \ - 1\n            }\n            else if(!isEvenOrOdd && !isEven && !isOdd &&\
    \ twoDecimals.last == 0){\n                twoDecimals.last + 1\n            }\n\
    \            else if(!isEvenOrOdd && !isEven && !isOdd && twoDecimals.last !=\
    \ 0){\n                twoDecimals.last - 1\n            }\n            else if(!isEvenOrOdd\
    \ && !isEven && isOdd && twoDecimals.last < 0){\n                twoDecimals.last\
    \ + 0.5\n            }\n            else if(!isEvenOrOdd && !isEven && isOdd &&\
    \ twoDecimals.last > 0){\n                twoDecimals.last - 0.5\n           \
    \ }\n            else if(!isEvenOrOdd && !isEven && isOdd && twoDecimals.last\
    \ == 0){\n                twoDecimals.last + 0.5\n            }\n            else\
    \ if(!isEvenOrOdd && !isEven && isOdd && twoDecimals.last != 0){\n           \
    \     twoDecimals.last - 0.5\n            }\n            else if(!isEvenOrOdd\
    \ && !isEven && !isOdd && twoDecimals.last < 0){\n                twoDecimals.last\
    \ + 1\n            }\n            else if(!isEvenOrOdd && !isEven && !isOdd &&\
    \ twoDecimals.last > 0){\n                twoDecimals.last - 1\n            }\n\
    \            else if(!isEvenOrOdd && !", "        val split = value.toString.split(\"\
    .\").map(_.toLong).toArray\n        val splitLen = split.length\n        var closest\
    \ = (splitLen - 1)\n        for ((a, b) <- split.zipWithIndex) {\n           \
    \ if (a == 0 && b == 0)\n                closest = 0\n            else if (abs(a\
    \ - b) < abs(closest - a)) {\n                closest = b\n            }\n   \
    \     }\n        val result = split.map(x => if (x == closest) 0 else x).sum\n\
    \        closest", "        // Convert String to Double\n        var num : Double\
    \ = value.toDouble\n        // Return closest integer\n        if(num > 0) {\n\
    \            return math.floor(num)\n        } else {\n            return math.ceil(num)\n\
    \        }", "        var max = 0\n        var closest = 0\n\n        val array\
    \ = value.split(\",\")\n\n        for (i <- 0 to (array.length-1)) {\n       \
    \     if (array(i).contains(\".\")) {\n                val nums = array(i).split(\"\
    \\\\.\").toList\n                val num = nums(0).toLong\n                val\
    \ num2 = nums(1).toLong\n                val d = Math.abs(num - num2)\n      \
    \          if (d > max) {\n                    max = d\n                    closest\
    \ = num\n                }\n            } else {\n                val num = array(i).toLong\n\
    \                val d = Math.abs(num - max)\n                if (d > max) {\n\
    \                    max = d\n                    closest = num\n            \
    \    }\n            }\n        }\n        closest", "        def isClosed(num:\
    \ Long, target: Long) : Boolean = {\n            var diff = abs(num - target)\n\
    \            if (diff <= 1)\n                return true\n            else if\
    \ (diff < 2)\n                return false\n            else { \n            \
    \    val diff2 = abs(num - target / 2)\n                val diff3 = abs(num -\
    \ target / 3)\n                val diff4 = abs(num - target / 4)\n           \
    \     val diff5 = abs(num - target / 5)\n                val diff6 = abs(num -\
    \ target / 6)\n                val diff7 = abs(num - target / 7)\n           \
    \     val diff8 = abs(num - target / 8)\n                val diff9 = abs(num -\
    \ target / 9)\n                val diff10 = abs(num - target / 10)\n         \
    \       val diff11 = abs(num - target / 11)\n                val diff12 = abs(num\
    \ - target / 12)\n                val diff13 = abs(num - target / 13)\n      \
    \          val diff14 = abs(num - target / 14)\n                val diff15 = abs(num\
    \ - target / 15)\n                val diff16 = abs(num - target / 16)\n      \
    \          val diff17 = abs(num - target / 17)\n                val diff18 = abs(num\
    \ - target / 18)\n                val diff19 = abs(num - target / 19)\n      \
    \          val diff20 = abs(num - target / 20)\n                val diff21 = abs(num\
    \ - target / 21)\n                val diff22 = abs(num - target / 22)\n      \
    \          val diff23 = abs(num - target / 23)\n                val diff24 = abs(num\
    \ - target / 24)\n                val diff25 = abs(num - target / 25)\n      \
    \          val diff26 = abs(num - target / 26)\n                val diff27 = abs(num\
    \ - target / 27)\n                val diff28 = abs(num - target / 28)\n      \
    \          val diff29 = abs(num - target / 29)\n                val diff30 = abs(num\
    \ - target / 30)\n                val diff31 = abs(num - target / 31)\n      \
    \          val diff32 = abs(num - target / 32)\n                val diff33 = abs(num\
    \ - target / 33)\n                val diff34 = abs(num - target / 34)\n      \
    \          val diff35 = abs(num - target / 35)\n                val diff36 = abs(num\
    \ - target / 36)\n                val diff37 = abs(num - target / 37)\n      \
    \          val diff38 = abs(num - target / 38)\n                val diff39 = abs(num\
    \ - target / 39)\n                val diff40 = abs(num - target / 40)", "    \
    \    // Create an empty list to store the values found\n        var found = new\
    \ mutable.ListBuffer[Long]()\n        // Create the counter for the minimum distance\
    \ from zero\n        var minDistance = Long.MaxValue\n        // Search all numbers\
    \ in the string\n        for(i <- 1 to value.toInt){\n            // Create a\
    \ counter for the current distance\n            var currentDistance = abs(value.toDouble\
    \ - i)\n            // If the distance is smaller than the minimum distance\n\
    \            // update it\n            if(currentDistance < minDistance){\n  \
    \              minDistance = currentDistance\n                found.clear()\n\
    \            }\n            // If the current distance is smaller than the minimum\
    \ distance\n            // add it to the found list\n            if(currentDistance\
    \ < minDistance){\n                found += i\n            }\n        }\n    \
    \    // Return the minimum distance\n        minDistance", "        var closest\
    \ = value.toLong - Math.abs(value.toLong.toDouble)\n        var closestInt = 0\n\
    \        var minDistance = 0\n        var minIndex = -1\n        var difference\
    \ = value.charAt(value.length - 1).toDouble\n        // TODO: Optimize this code\n\
    \        for (i <- 0 until value.length) {\n            val current = value(i).toDouble\n\
    \            if (current < closest.abs && current > difference) {\n          \
    \      closest = current\n                closestInt = i\n                difference\
    \ = current - difference\n            }\n            if (minDistance == 0) {\n\
    \                minDistance = current - closest\n                minIndex = i\n\
    \            } else if (current - closest < minDistance * minDistance * 1.0) {\n\
    \                minDistance = current - closest\n                minIndex = i\n\
    \            }\n        }\n        if (closest < Math.abs(closestInt) * 1.0) {\n\
    \            closest = Math.abs(closestInt) * 1.0\n            closestInt = Math.abs(closestInt)\n\
    \        }\n        return closestInt", "        val number = value.toLong\n \
    \       val range = scala.collection.immutable.Range(-Int, Int.MaxValue)\n   \
    \     var closestToZero = Int.MaxValue\n        var closestToOne = Int.MaxValue\n\
    \n        for(i <- range) {\n            val diff = (number - i).abs\n\n     \
    \       if (diff < closestToZero) {\n                closestToZero = diff\n  \
    \          }\n\n            if (diff < closestToOne) {\n                closestToOne\
    \ = diff\n            }\n        }\n\n        if(closestToZero < closestToOne)\
    \ {\n            return number\n        }\n\n        val minDistance = closestToZero\n\
    \        val closestToZeroIndex = range.indexWhere(n => n >= minDistance)\n\n\
    \        val closestToOneIndex = range.indexWhere(n => n <= minDistance)\n\n \
    \       return range.apply(closestToZeroIndex - 1)", "        var closest = 0\n\
    \        val valueSplit = value.split('.')\n        val intSplit = valueSplit(0).split('')\n\
    \        val longSplit = valueSplit(1).split('')\n        val newLong = longSplit.map(_.toLong).toList\n\
    \        val newInt = intSplit.map(_.toInt).toList\n        for (i <- newInt.size\
    \ - 1 downTo 0 by -1){\n            if (Math.abs(newInt(i)-newInt[i-1]) < Math.abs(newInt(i)-newInt[i])){\n\
    \                closest += newInt(i)\n            }\n        }\n        closest.toLong",
  "        val floatValue : Double = value.drop(1).takeWhile(_ >= '0').toDouble\n\
    \        val lowerInt : Long = Math.ceil(floatValue)\n        val higherInt :\
    \ Long = Math.floor(floatValue)\n        if (floatValue == lowerInt || floatValue\
    \ == higherInt) {\n            lowerInt\n        } else {\n            higherInt\n\
    \        }", "        val splitString = value.split(\"\\\\.\");\n        if (splitString.length\
    \ == 2) {\n            val firstNum = splitString(0).toInt;\n            val secondNum\
    \ = splitString(1).toInt;\n            return Math.round((secondNum + firstNum)\
    \ / 2);\n        }\n        if (splitString.length == 1) {\n            val num\
    \ = splitString(0).toInt;\n            return Math.round((num + num) / 2);\n \
    \       }", "        val numAsLong = BigDecimal(value)\n        val difference\
    \ = BigDecimal.ZERO\n        var closestNum: BigDecimal = BigDecimal.ZERO\n  \
    \      var closestNumVal: Long = 0\n        for {\n            numAsLong <- numAsLong.divide(BigDecimal.ONE,\
    \ 2, RoundingMode.SYNC)\n            difference <- numAsLong.subtract(BigDecimal.ZERO)\n\
    \        } yield {\n            if (difference.signum == -1) {\n             \
    \   closestNumVal = numAsLong.doubleValue\n                closestNum = BigDecimal.valueOf(closestNumVal)\n\
    \            } else {\n                closestNumVal = closestNum.doubleValue\n\
    \                closestNum = BigDecimal.valueOf(closestNumVal)\n            }\n\
    \        }\n        closestNumVal", "        val numbers = value.split(\"\\\\\
    .\").toList\n        var result : Long = 0\n        for(i <- 0 until numbers.size)\
    \ {\n            result += toLong(numbers(i))\n        }\n        if(result >\
    \ 0 && result % 1 == 0) {\n            result += 1\n        }\n        result",
  "        val integer = value.toLong\n        val closestInteger = if (integer -\
    \ math.abs(integer) < 0) {\n            math.abs(integer) + 1;\n        } else\
    \ {\n            math.abs(integer);\n        }\n        closestInteger", "   \
    \     // Create a list of possible integers that could be the closest\n      \
    \  val possibleInt = mutable.ArrayBuffer[Long](\n            10l, 15l, 20l, 25l,\
    \ 30l, 35l, 40l, 45l, 50l, 55l, 60l, 65l,\n            70l, 75l, 80l, 85l, 90l,\
    \ 95l, 100l, 105l, 110l, 115l, 120l,\n            125l, 130l, 135l, 140l, 145l,\
    \ 150l, 155l, 160l, 165l, 170l,\n            175l, 180l, 185l, 190l, 195l, 200l,\
    \ 205l, 210l, 215l, 220l,\n            225l, 230l, 235l, 240l, 245l, 250l, 255l,\
    \ 260l, 265l, 270l,\n            275l, 280l, 285l, 290l, 295l, 300l, 305l, 310l,\
    \ 315l, 320l,\n            325l, 330l, 335l, 340l, 345l, 350l, 355l, 360l, 365l,\
    \ 370l,\n            375l, 380l, 385l, 390l, 395l, 400l, 405l, 410l, 415l, 420l,\n\
    \            425l, 430l, 435l, 440l, 445l, 450l, 455l, 460l, 465l, 470l,\n   \
    \         475l, 480l, 485l, 490l, 495l, 500l, 505l, 510l, 515l, 520l,\n      \
    \      525l, 530l, 535l, 540l, 545l, 550l, 555l, 560l, 565l, 570l,\n         \
    \   575l, 580l, 585l, 590l, 595l, 600l, 605l, 610l, 615l, 620l,\n            625l,\
    \ 630l, 635l, 640l, 645l, 650l, 655l, 660l, 665l, 670l,\n            675l, 680l,\
    \ 685l, 690l, 695l, 700l, 705l, 710l, 715l, 720l,\n            725l, 730l, 735l,\
    \ 740l, 745l, 750l, 755l, 760l, 765l, 770l,\n            775l, 780l, 785l, 790l,\
    \ 795l, 800l, 805l, 810l, 815l, 820l,\n            825l, 830l, 835l, 840l, 845l,\
    \ 850l, 855l, 860l, 865l, 870l,\n            875l, 880l, 885l, 890l, 895l, 900l,\
    \ 905l, 910l, 915l, 920l,\n            925l, 930l, 935l, 940l, 945l, 950l, 955l,\
    \ 960l, 9", "        // Write your solution here\n        val array = (value split\
    \ '\\.').toArray\n        val int1 = array.head.toInt\n        val int2 = array.last.toInt\n\
    \        var intDiff = abs(int1 - int2)\n        if (intDiff == int1.toString.toInt)\
    \ {\n            if (int1 == 0) {\n                intDiff = abs(int2.toString.toInt\
    \ - 0)\n                if (intDiff == int2.toString.toInt) {\n              \
    \      intDiff = abs(int1.toString.toInt - 0)\n                }\n           \
    \ } else {\n                intDiff = abs(int1.toString.toInt - 0)\n         \
    \   }\n        } else if (intDiff == int2.toString.toInt) {\n            intDiff\
    \ = abs(int2.toString.toInt - 0)\n        }\n        val diff = abs(int1.toLong\
    \ - int2.toLong)\n        if (diff == int1.toString.toInt) {\n            val\
    \ diff = abs(int1.toString.toInt - 0)\n        } else if (diff == int2.toString.toInt)\
    \ {\n            val diff = abs(int2.toString.toInt - 0)\n        }\n        if\
    \ (intDiff > int2.toString.toInt && (intDiff - int1.toString.toInt) <= diff) {\n\
    \            int1.toLong\n        } else {\n            int2.toLong\n        }",
  "        // Your code here\n        val intArray = value.split(\",\")\n        val\
    \ resultArray = for (a <- intArray) yield {\n            if (a.startsWith(\"-\"\
    )) {\n                a.toLong * -1\n            } else {\n                a.toLong\n\
    \            }\n        }\n        val result = resultArray.toArray\n        if\
    \ (resultArray.length == 0) throw new Exception(\"value can not be parsed\")\n\
    \        val minimum = result(0)\n        val maximum = result(resultArray.length\
    \ - 1).abs\n        val minimumIndex = result.indexWhere(_ == minimum)\n     \
    \   val maximumIndex = result.indexWhere(_ == maximum)\n        val result = if\
    \ (minimumIndex < maximumIndex) maximum(minimumIndex) else minimum(maximumIndex)\n\
    \        result", "        val intValue = value.toInt\n        if(intValue ==\
    \ intValue) intValue\n        else intValue.toLong - intValue + (intValue.toLong/intValue.toInt).toLong",
  "        // Extract the numeric value from the input string\n        val num = value.trim().toDouble\n\
    \        // Return it if it is equidistant from two integers\n        if (num.isEqual\
    \ && num.isInfinite || num.isNaN ) {\n            return num\n        }\n    \
    \    // Get the integer closest to zero\n        val result = (-num).abs + math.min(math.max(num,0),Integer.MAX_VALUE).toInt\n\
    \        // Return the result\n        result", "        // Convert to numeric\
    \ value\n        val floatVal = value.asInstanceOf[String].replaceAll(\"[^0-9]\"\
    , \"\").toDouble\n        val low = math.floor(floatVal)\n        val high = math.ceil(floatVal)\n\
    \        val diff = high - low\n        // Return closest integer\n        if\
    \ (diff == 0) {\n            return low\n        }\n        else {\n         \
    \   return low + math.min(math.abs(diff), 1)\n        }", "        val num = scala.math.BigDecimal(value).toLong\n\
    \        val diff = scala.math.BigDecimal.signum(num - java.lang.Double.doubleToLongBits(java.lang.Double.doubleToLongBits(num)))\n\
    \        val closestToZero = java.lang.Double.doubleToLongBits(java.lang.Double.doubleToLongBits(num)\
    \ - diff)\n        val rounded = java.lang.Double.doubleToLongBits(java.lang.Double.doubleToLongBits(num)\
    \ + diff)\n        if (java.lang.Double.doubleToLongBits(rounded) == closestToZero)\
    \ {\n            val toDecimal = java.lang.Double.doubleToLongBits(num)\n    \
    \        val decimal = java.math.BigDecimal(toDecimal)\n            val round\
    \ = Math.round(decimal)\n            if (value == s\"${round}.0\")\n         \
    \       toDecimal\n            else round\n        } else {\n            val toDecimal\
    \ = java.lang.Double.doubleToLongBits(java.lang.Double.doubleToLongBits(num))\n\
    \            val decimal = java.math.BigDecimal(toDecimal)\n            val round\
    \ = Math.round(decimal)\n            if (value == s\"${round}.0\")\n         \
    \       toDecimal\n            else round\n        }", '        // Your code here',
  "        val parts : (String, Int) = (value, value.toString.toInt)\n        val\
    \ diffInDecimals = parts._2 - parts._1\n        if(diffInDecimals > 0) {\n   \
    \         parts._1 - (diffInDecimals)\n        } else {\n            parts._1\
    \ + (diffInDecimals)\n        }", "        val arr = value.split(\".\").map(_.toLong)\n\
    \        val diff = arr.toSeq.map(_.toLong).takeRight(2).foldLeft(0d){ (acc, i)\
    \ => acc + Math.abs(i - arr(0)) }\n        arr(0) + diff", "        var closestInteger\
    \ = 0\n        val values = value.split(\"\\\\.\")\n        val inputValue = values.last.toLong\n\
    \        for (number <- values) {\n            val testValue = inputValue + number.toLong\n\
    \            if (Math.abs(testValue - inputValue) < Math.abs(closestInteger -\
    \ inputValue)) {\n                closestInteger = testValue\n            }\n\
    \        }\n        closestInteger", "      val digits = value.split(\",\").toList.map(_.toInt)\n\
    \      // Create a mutable set of all existing numbers that are equidistant from\n\
    \      // the numbers currently in the set\n      val existingSet = mutable.Set[Long]()\n\
    \      digits foreach { n =>\n        existingSet += n\n      }\n      val closest\
    \ = math.abs(digits.max -digits.min) // Find the closest integer\n      // Add\
    \ the number that is closest to the original set to the set\n      // of numbers\
    \ to try and find the next closest integer\n      existingSet += (closest +- 0.5).toLong\n\
    \      digits.min.max(closest)", "        val arr = value.split(\"\\\\.\").map(_.toInt)\n\
    \        val smallestAbs = arr.minAbsolute\n        val largestAbs = arr.maxAbsolute\n\
    \        val diff = largestAbs - smallestAbs\n        val closestIndex = arr.zip(arr.zipWithIndex).find(_._1\
    \ != _._1).map(x => abs(x._1 - x._2)).sortBy(x => x).lastOption.getOrElse(0)\n\
    \        (arr(closestIndex + smallestAbs) % diff) + smallestAbs", "        val\
    \ parts = value.split(\"\\\\.\", -1);\n        val num = parts.head.asInstanceOf[Number].longValue\n\
    \        val fraction = parts.last.asInstanceOf[Number].longValue\n        var\
    \ d = fraction / 10\n        var r = fraction % 10\n        if(num == 0 && fraction\
    \ == 0) {\n            return 0\n        }\n        if(fraction == 0) {\n    \
    \        return num\n        }\n        if(fraction == 1 && num != 0) {\n    \
    \        return num\n        }\n        while(num > 0) {\n            d = math.min(d,\
    \ 10 - r)\n            num = num / 10\n            r = num % 10\n        }\n \
    \       return num", "        val numbers = value.split(\"\\\\.\").toList\n  \
    \      val result = numbers.foldLeft((0,0)){\n            case ((cur, prev), number)\
    \ => {\n                var prevNum = prev\n                prevNum = if(prevNum\
    \ < 0) prevNum + 1 else prevNum - 1\n                (prevNum + number.toLong,\
    \ prevNum)\n            }\n        }\n        result._1.toLong", "        val\
    \ value = value.trim\n        val value = value.toDouble\n        val maxDistance\
    \ = Math.abs(value - (value % 1));\n        val closestInteger = Math.round(value)\
    \ + 1;\n        val distances = List(0, maxDistance);\n        if (distances.last\
    \ < distances.head) {\n            distances.reverse;\n        }\n        closestInteger;",
  "        val intValues = value.split('.').toList.toDouble.map { _.toInt }\n    \
    \    val index = intValues.indexOf(Math.min.apply(0, intValues))\n        Math.min.apply(0,\
    \ intValues)", "        // Implement your code here\n        val x = parseLong(value)\n\
    \        val closest = (x - Math.round(x) == x)\n        if (closest) x else (x\
    \ - 1)", "        val numbers = value.split(\"\\\\.\").map(_.toInt)\n        val\
    \ first = numbers.head\n        val second = numbers.tail.head\n\n        val\
    \ difference = second - first\n\n        if (difference < 0) difference *= -1\n\
    \n        if (Math.abs(difference) > 1) {\n            if (Math.abs(difference)\
    \ > Integer.MAX_VALUE) throw new RuntimeException(\"Can't handle number too big\"\
    )\n            else Math.round(difference)\n        } else {\n            Math.abs(difference)\n\
    \        }", "        val parts : Array[String] = value.toString.split(\"\\\\\
    .\".toString)\n        val numbers = parts.tail.map { part =>\n            val\
    \ result = part.toLong\n            if( result >= 0 && result < Number.MIN_INT\
    \ ) {\n                result + Number.MIN_INT\n            }\n            else\
    \ {\n                result - Number.MIN_INT\n            }\n        }\n     \
    \   val closest = (numbers diff 0)(Ordering[Long](Ordering[Int]()))\n        return\
    \ closest(0)", "        // Use a set to collect all of the integers\n        val\
    \ set = Set[Long]()\n\n        // Iterate over the characters in the string, one\
    \ at a time\n        for (i <- value.iterator.toList)\n            // Add the\
    \ integer represented by the character to the set\n            if (i.isDigit)\
    \ set.add(i.asInstanceOf[Int].toLong)\n\n        // Return the smallest integer\
    \ that's not in the set\n        set.min.filter(_ != value.toLong).head", "  \
    \      if (value.contains(\".\")) {\n            val parts = value.split(\".\"\
    )\n            if (parts.length != 2) {\n                throw new IllegalArgumentException\n\
    \                    (s\"Bad number of parts $parts\")\n            }\n      \
    \      val number = parts.head.toLong * 10000000 + parts.last.toLong\n       \
    \     if (number == 0) throw new IllegalArgumentException\n                (s\"\
    Bad number $number for value $value\")\n            number\n        } else {\n\
    \            value.toLong\n        }", "        val parts = value.split(\".\"\
    ).map(_.toLong)\n        val minParts = parts.sorted.take(2)\n        val maxParts\
    \ = parts.sorted.takeRight(2)\n\n        (minParts zip maxParts).\n          \
    \      filter{ case (first, second) => first <= second }.\n                map{\
    \ case (first, second) => second }.toArray.\n                min.\n          \
    \      toLong", "        val str = value.toInt\n        if (str == 0) 0\n    \
    \    else if(str == Integer.MIN_VALUE) Integer.MAX_VALUE\n        else if (str\
    \ < 0) Integer.MIN_VALUE\n        else { val diff = str - Integer.MIN_VALUE\n\
    \        val diff2 = diff - diff\n        if (diff2 < 0) Integer.MIN_VALUE\n \
    \       else if (diff2 > 0) Integer.MAX_VALUE\n        else diff\n        }",
  "        val stringNumber = value.toDouble\n        val difference = abs(stringNumber\
    \ - stringNumber.roundToInt)\n        stringNumber.roundToInt", "        val stringNumber\
    \ = value\n        val integers = stringNumber.toIntArray()\n        val closestOne\
    \ = if (integers.length == 1) integers(0) else integers(0)\n        val closestTwo\
    \ = if (integers.length == 2) integers(0) else integers(1)\n        val closestThree\
    \ = if (integers.length == 3) integers(0) else integers(2)\n        val closestFour\
    \ = if (integers.length == 4) integers(0) else integers(3)\n        val closestFive\
    \ = if (integers.length == 5) integers(0) else integers(4)\n        val closestSix\
    \ = if (integers.length == 6) integers(0) else integers(5)\n        val closestSeven\
    \ = if (integers.length == 7) integers(0) else integers(6)\n        val closestEight\
    \ = if (integers.length == 8) integers(0) else integers(7)\n        val closestNine\
    \ = if (integers.length == 9) integers(0) else integers(8)\n        val closestTen\
    \ = if (integers.length == 10) integers(0) else integers(9)\n        val closestEleven\
    \ = if (integers.length == 11) integers(0) else integers(10)\n        val closestTwelve\
    \ = if (integers.length == 12) integers(0) else integers(11)\n        val closestThirteen\
    \ = if (integers.length == 13) integers(0) else integers(12)\n        val closestFourteen\
    \ = if (integers.length == 14) integers(0) else integers(13)\n        val closestFifteen\
    \ = if (integers.length == 15) integers(0) else integers(14)\n        val closestSixteen\
    \ = if (integers.length == 16) integers(0) else integers(15)\n        val closestSeventeen\
    \ = if (integers.length == 17) integers(0) else integers(16)\n        val closestEighteen\
    \ = if (integers.length == 18) integers(0) else integers(17)\n        val closestNineteen\
    \ = if (integers.length == 19) integers(0) else integers(18)\n        val closestTwenty\
    \ = if (integers.length == 20) integers(0) else integers(19)\n        val closestTwentyOne\
    \ = if (integers.length == 20) integers(1) else integers(20)\n        val closestTwentyTwo\
    \ = if (integers.length == 20) integers(2) else integers(20)\n        val closestTwentyThree\
    \ = if (integers.length == 20) integers(3) else integers(20)\n        val closestTwentyFour\
    \ = if (integers.length == 20) integers(4) else integers(20)\n        val closestTwentyFive\
    \ = if (integers.length == 20) integers(5) ", "        val numbers = value.split(\"\
    \\\\.\").toList\n        var integers = mutable.LinkedHashSet[Long]()\n      \
    \  val firstValue = numbers(0)\n        for (i <- 0 until numbers.length - 1)\
    \ {\n            val nextValue = numbers(i+1)\n            if (nextValue.toLong\
    \ <= firstValue.toLong) {\n                integers.add(nextValue.toLong)\n  \
    \          }\n        }\n        val closestIntegers = integers.toSeq.sortWith(_\
    \ < _)\n        if (closestIntegers.size == 1) {\n            closestIntegers.head\n\
    \        } else {\n            val closestInteger = closestIntegers.head\n   \
    \         val closestValues = integers.filter(_ != closestInteger)\n         \
    \   val diffs = closestValues.map(n => math.abs(closestInteger - n))\n       \
    \     if (diffs.min() < diffs.max) {\n                closestInteger\n       \
    \     } else {\n                closestIntegers\n            }\n        }", " \
    \       def closestIntegerHelper(n : String, result : Long) : Long = {\n     \
    \       if(n.equals(\"-Infinity\")){\n                result = 0\n           \
    \ }\n            if(n.equals(\"Infinity\")){\n                result = Long.MaxValue\n\
    \            }\n            if(n.equals(\"0\")){\n                result = 0\n\
    \            }\n            if(n.equals(\"NaN\")){\n                result = Long.MaxValue\n\
    \            }\n            else if(n.startsWith(\"-\")){\n                val\
    \ x = n.toLong\n                val y = result * -1\n                if(x.toLong\
    \ < y){\n                    result = x - 1\n                }\n             \
    \   else if(x.toLong > y){\n                    result = x + 1\n             \
    \   }\n                else if(x.toLong == y){\n                    result = x\n\
    \                }\n            }\n            else{\n                val x =\
    \ n.toLong\n                val y = result + 1\n                if(x.toLong >\
    \ y){\n                    result = x + 1\n                }\n               \
    \ else if(x.toLong < y){\n                    result = x - 1\n               \
    \ }\n                else if(x.toLong == y){\n                    result = x\n\
    \                }\n            }\n            result\n        }\n        val\
    \ num = value.toDouble\n        val intNum : Int = num.toInt\n        if(intNum\
    \ == num){\n            intNum\n        }\n        else{\n            val result\
    \ = closestIntegerHelper(value, intNum)\n            if(result == 0){\n      \
    \          intNum\n            }\n            else{\n                result\n\
    \            }\n        }", '        // TODO: Code goes here', "        var closestValue\
    \ : Long = 0\n        val numbers = value.split(\"\"\"\\.|,|:|\\s/).map(_.toDouble)\n\
    \        var closestIndex = 0\n        for (i <- 0 until numbers.size) {\n   \
    \         val x = numbers(i)\n            val y = numbers(i + 1)\n           \
    \ val distance = (x - y).abs()\n            if (distance < closestValue) {\n \
    \               closestValue = distance\n                closestIndex = i\n  \
    \          }\n        }\n        numbers(closestIndex)", "        val values =\
    \ value.split(\"\\\\.\") map (_.toDouble)\n        val closestToZero = values.sorted.min\n\
    \        // round towards zero, i.e. closest to (but not below) zero\n       \
    \ math.round(closestToZero)", "        // Use a mutable map to track the numbers\
    \ that we've encountered\n        // and their distances to the target number\n\
    \        val numMap = new mutable.HashMap[Long, Double]()\n        // Use a mutable\
    \ set to keep track of the numbers that we've checked\n        val seen = new\
    \ mutable.HashSet[Long]()\n        // Use a mutable set to keep track of the numbers\
    \ we've already considered\n        // so that we don't repeat the same number\n\
    \        val checked = new mutable.HashSet[Long]()\n        // Remember the target\
    \ number in the map\n        val num = (value.toDouble).longValue\n        //\
    \ Keep a set containing the integers in the number range we care about\n     \
    \   // We'll add 1 to this number later, so adding 1 is equivalent to subtracting\
    \ one\n        val range = (num.toInt - 1) * 1000\n        // Add the target number\
    \ to the map and then loop through all the numbers in the\n        // range to\
    \ see if we've seen them before\n        for (i <- range until (num.toInt + 1))\
    \ {\n            val newNum = (i.toDouble).longValue\n            val currentDistance\
    \ = abs(num - newNum)\n            // Add the current distance to the map\n  \
    \          val newEntry = (currentDistance, newNum)\n            numMap.put(newNum,\
    \ currentDistance)\n            // If the number has not been seen before, check\
    \ if we've reached the target\n            // number yet. If we have, we'll return\
    \ it\n            if (!seen.contains(newNum)) {\n                // Check if the\
    \ target number is in the map yet\n                if (!numMap.contains(num))\
    \ {\n                    seen.add(newNum)\n                    return newNum\n\
    \                } else {\n                    // If the number has already been\
    \ seen before, then update the distance\n                    // and add it to\
    \ the set of checked numbers\n                    numMap.put(num, currentDistance)\n\
    \                    checked.add(num)\n                }\n            }\n    \
    \    }\n        -1", "        def distance(x: Long, y: Long): Long = {\n     \
    \       val dx = x - y\n            if (dx == 0) 1\n            else abs(dx) /\
    \ x\n        }\n        if (value.contains(\".\")){\n            val floatValue\
    \ = value.split('.').toArray.head\n            val integerValue = floatValue %\
    \ 1\n            val integerDivisor = math.ceil(floatValue * 100) / 100\n    \
    \        val x = integerValue * integerDivisor\n            val y = integerDivisor\n\
    \            var closestDiff: Long = distance(x, y)\n            if (closestDiff\
    \ < distance(x+1.0, y)) {\n                closestDiff = distance(x+1.0, y)\n\
    \            }\n            if (closestDiff < distance(x, y-1.0)) {\n        \
    \        closestDiff = distance(x, y-1.0)\n            }\n            closestDiff\n\
    \        } else {\n            val integerValue = value.toInt\n            val\
    \ integerDivisor = math.ceil(integerValue * 100) / 100\n            val x = integerValue\
    \ * integerDivisor\n            val y = integerDivisor\n            var closestDiff:\
    \ Long = distance(x, y)\n            if (closestDiff < distance(x+1.0, y)) {\n\
    \                closestDiff = distance(x+1.0, y)\n            }\n           \
    \ if (closestDiff < distance(x, y-1.0)) {\n                closestDiff = distance(x,\
    \ y-1.0)\n            }\n            closestDiff\n        }", "        var sum\
    \ : Double = Double.PositiveInfinity\n        var numStr : String = value\n  \
    \      var num : Long = 0\n        var isNegative : Boolean = false\n        while(numStr\
    \ != \"\"){\n            val nextNumStr : String = numStr.substring(0,numStr.indexOf(\"\
    .\")+1)\n            val nextNum = nextNumStr.asInstanceOf[String].toLong\n  \
    \          val lastNumStr : String = numStr.substring(numStr.indexOf(\".\")+2)\n\
    \            val lastNum = lastNumStr.asInstanceOf[String].toLong\n          \
    \  if (nextNum > lastNum){\n                numStr = numStr.substring(0,numStr.indexOf(\"\
    .\")+1)\n                sum = Math.abs(nextNum - lastNum)\n                num\
    \ = nextNum\n            }\n            else if (nextNum < lastNum){\n       \
    \         numStr = numStr.substring(0,numStr.indexOf(\".\")+1)\n             \
    \   sum = Math.abs(lastNum - nextNum)\n                num = lastNum\n       \
    \     }\n            else{\n                sum = Math.abs(nextNum - lastNum)\n\
    \                num = nextNum\n            }\n            numStr = \"\"\n   \
    \     }\n        if (isNegative){\n            num = -num\n        }\n       \
    \ return num", "        value match {\n            case x if x.toString.length\
    \ == 2 => x.toString.toDouble.round()\n            case x if x.toString.length\
    \ == 1 => x.toString.toDouble.round()\n            case _ => 0\n        }", " \
    \       var closest = Long.MaxValue\n        var closestIndex : Long = Long.MinValue\n\
    \        var valueInt = value.toLong\n        var valueString = value.toString\n\
    \n        for ( i <- 1 to valueString.length-1) {\n            if (valueString.charAt(i)\
    \ == '-') {\n                valueInt = -valueInt\n            }\n           \
    \ val closestToI = valueInt.abs / (i+1)\n            if (closestToI < closest)\
    \ {\n                closest = closestToI\n                closestIndex = i\n\
    \            }\n        }\n        closest", "        // If the value is blank\n\
    \        if (value == null || value == \"\") {\n            return 0\n       \
    \ }\n        // If the value is less than 1\n        else if (value.length() <\
    \ 1) {\n            return 0\n        }\n        // If it isn't an integer value\n\
    \        else if (value.toInt == 0) {\n            return 0\n        }\n     \
    \   // If the value is a single character string\n        else if (value.length()\
    \ == 1) {\n            if (value.charAt(0) == '-') {\n                return 0\n\
    \            }\n            else {\n                return value.charAt(0).toInt\n\
    \            }\n        }\n        // Split the value on the \".\" character\n\
    \        else if (value.contains(\".\") || value.contains(\",\")) {\n        \
    \    // If the value is a decimal value\n            if (value.contains(\".\"\
    )) {\n                // Split the value on the \".\" character\n            \
    \    val tokens = value.split(\".\")\n                // Get the left and right\
    \ parts of the value\n                val left = tokens(0).trim\n            \
    \    val right = tokens(1).trim\n                // If there is only one part,\
    \ make sure that the right part\n                // is less than 10\n        \
    \        if (left.length() == 1) {\n                    if (right.startsWith(\"\
    0\")) {\n                        return 0\n                    }\n           \
    \     }\n                // Calculate the difference between the left and right\
    \ parts\n                val diff = left.toInt - right.toInt\n               \
    \ // If the diff is greater than 10, round away from zero\n                if\
    \ (diff > 10) {\n                    return 0\n                }\n           \
    \     else if (diff > 0) {\n                    return diff\n                }\n\
    \                // If the diff is less than -10, round away from zero\n     \
    \           else if (diff < 0) {\n                    return 10 + diff\n     \
    \           }\n                // If the diff is equal to 0, return 0\n      \
    \          else {\n                    return 0\n                }\n         \
    \   }\n            // If the value is a comma separated value\n            if\
    \ (value.contains(\",\")) {\n                // Split the value on the \",\" character\n\
    \                val tokens = value.split(\",\")\n                // Get the left\
    \ and right parts of the value\n                val left = tokens(0).trim\n  \
    \              val right = tokens(1).trim\n                // If there is only\
    \ one part, make sure that the right part\n                // is less than 10\n\
    \                if (left.length() == 1) {\n                    if (right.startsWith(\"\
    0\")) {\n                        return 0\n                    }\n           \
    \     }\n                // Calculate the difference between the left and right\
    \ parts\n                val diff = left.toInt - right.toInt\n               \
    \ // If the diff is greater than 10, round away from zero\n                if\
    \ (diff > 10) {\n                    return 0\n                }\n           \
    \     else if (diff > 0) {\n                    return diff\n                }\n\
    \                // If the diff is less than -10, round away from zero\n     \
    \           else if (diff < 0) {\n                    return 10 + diff\n     \
    \           }\n                // If the diff is equal to 0, return 0\n      \
    \          else {\n                    return 0\n                }\n         \
    \   }\n            else {\n                // If the value is a zero padded string\n\
    \                if (value.startsWith(\"0\")) {\n                    // Split\
    \ the value on the \"0\" character\n                    val tokens = value.split(\"\
    0\")", "        val numbers = value.split(\"\\\\.\")\n        val num = numbers(0)\n\
    \        val dec = numbers(1)\n        val digits = dec.toLong * 10\n        val\
    \ num = num.toLong * 10\n        val dec = dec.toLong * 10\n        val digitsToAdd\
    \ = digits - dec\n        var closestToZero = num\n        while (closestToZero\
    \ > 0 && closestToZero < digits) {\n            closestToZero += 1\n        }\n\
    \        val numToAdd = num - closestToZero\n        return closestToZero + numToAdd",
  "        val digits = value.split('.').map(_.toInt).toList\n        val length =\
    \ digits.length\n        if (length == 0)\n            return 0L\n        var\
    \ closestToZero = 0.0\n        var closestToZeroDigit = 0\n        digits.zipWithIndex.foreach\
    \ { case (digit, digitIndex) =>\n            val square = math.pow(10.0d, digitIndex)\n\
    \            if (digit < closestToZero)\n                closestToZero = digit\n\
    \            if (digit < closestToZero + square) {\n                closestToZeroDigit\
    \ = digitIndex\n            }\n        }\n        digits.zipWithIndex.foreach\
    \ { case (digit, digitIndex) =>\n            if (digitIndex == closestToZeroDigit\
    \ && digit < 0.0d)\n                digit = -digit\n        }\n        val closestInt\
    \ = digits.head * math.pow(10.0d, digits.tail.size - 1) + digits.last\n      \
    \  return closestInt", "        // Your code goes here\n        val arr = value.split(\"\
    \\\\.\") //((\"15\"))\n        val narr=arr.tail\n        var ans=0\n        var\
    \ dis=0\n        for(i <- 0 until arr.length-1){\n            var f=arr(i)\n \
    \           var s=arr(i+1)\n            if(f<s){\n                val c=f.toInt\n\
    \                val d=s.toInt\n                f=c-d\n                s=c+d\n\
    \            }\n            val c=f.toInt\n            val d=s.toInt\n       \
    \     f-=d\n            s-=c\n            val diff=math.abs(f-d);\n          \
    \  val sum=math.abs(f+s);\n            if(diff>sum)\n                continue;\n\
    \            if(diff<ans){\n                ans=diff\n            }\n        }\n\
    \        ans*math.pow(10,arr.length)", "        val numberAsString = value.toDouble\n\
    \        var roundingConditions = true\n        var smallestDiff = math.min(Math.abs(numberAsString),\
    \ Math.abs(numberAsString))\n        var largestDiff = math.max(Math.abs(numberAsString),\
    \ Math.abs(numberAsString))\n        var smallerOne = math.abs(numberAsString)\
    \ / smallestDiff\n        var largerOne = math.abs(numberAsString) / largestDiff\n\
    \        while (roundingConditions) {\n            // If it is the same number\
    \ we already have, return it\n            if (numberAsString == smallestDiff)\
    \ {\n                return smallestDiff\n            }\n            if (numberAsString\
    \ == largestDiff) {\n                return largestDiff\n            }\n     \
    \       // We need to see if it is closer than our smallest or largest difference\n\
    \            if (Math.abs(numberAsString) < smallestDiff) {\n                //\
    \ If it is closer to our smallest difference, we can round up\n              \
    \  if (numberAsString - smallestDiff > largestDiff) {\n                    numberAsString\
    \ = math.ceil(numberAsString)\n                    // If it has been rounded to\
    \ an integer more than twice and is closer than our smallest difference\n    \
    \                //    we can just return that\n                    if (numberAsString\
    \ == smallestDiff) {\n                        return smallestDiff\n          \
    \          }\n                    // Otherwise, we need to see if it is closer\
    \ than our smallest difference\n                    // and round down\n      \
    \          } else {\n                    numberAsString = math.floor(numberAsString)\n\
    \                    // If it has been rounded to an integer less than twice and\
    \ is closer than our smallest difference\n                    //    we can just\
    \ return that\n                    if (numberAsString == smallestDiff) {\n   \
    \                     return smallestDiff\n                    }\n           \
    \         // Otherwise, we need to see if it is closer than our smallest difference\n\
    \                    // and round down\n                }\n            }\n   \
    \         if (Math.abs(numberAsString) > largestDiff) {\n                // If\
    \ it is closer to our largest difference, we can round down\n                if\
    \ (numberAsString - largestDiff < smallestDiff) {\n                    numberAsString\
    \ = math.floor(numberAsString)\n                    // If it has been rounded\
    \ to an integer more than twice and is closer than our smallest difference\n \
    \                   //    we can just return that\n                    if (numberAsString\
    \ == largestDiff) {\n                        return largestDiff\n            \
    \        }\n                    // Otherwise, we need to see if it is closer than\
    \ our smallest difference\n                    // and round down\n           \
    \     } else {\n                    numberAsString = math.ceil(numberAsString)\n\
    \                    // If it has been rounded to an integer less than twice and\
    \ is closer than our smallest difference\n                    //    we can just\
    \ return that\n                    if (numberAsString == largestDiff) {\n    \
    \                    return largestDiff\n                    }\n             \
    \       // Otherwise, we need to see if it is closer than our smallest difference\n",
  "        val parts = value.split(\",\").toList.map(_.toLong)\n        val sum =\
    \ parts.reduceLeftOption { (x, y) => x + y }\n        val sum = sum.getOrElse(0)\n\
    \        val difference = parts zip parts.tail.zipWithIndex\n        val difference\
    \ = difference.toSeq.sortWith((x, y) => x._1 > y._1).map{case (y,index) => (y._1\
    \ - x._1,index)}\n        val minDiff = difference._2\n        val nearestDiff\
    \ = minDiff - 1\n        val nearestParts = parts.take(nearestDiff)\n        val\
    \ nearestSum = parts.sum\n        (nearestSum - sum, nearestParts)", "       \
    \ var current = 0L\n        var next = value.toLong\n        var currentSum =\
    \ 0L\n        var nextSum = 0L\n        while(current < next){\n            currentSum\
    \ += current\n            next = math.abs(next)\n            currentSum -= next\n\
    \            next += current\n        }\n        if(current < next){\n       \
    \     currentSum += next\n        }\n        return currentSum", "        val\
    \ list = value.split('.').toList\n        val num = list(0)\n        if (list.length\
    \ > 1) {\n            val dist = list.zip(list.tail)\n                .map(x =>\
    \ (Math.abs(num.toDouble - x._1.toDouble), x._2))\n                .reduce(_._1).getOrElse((0L,\
    \ 0L))\n            val closest = dist.filter(_._1 > dist)\n                .map(_._2)\n\
    \                .getOrElse(num)\n            val diff = ((closest.toDouble -\
    \ num.toDouble) / num.toDouble) * 100\n            diff < 0 ? closest.toLong :\
    \ closest.toLong - diff\n        } else {\n            val n = num.toLong\n  \
    \          if (n < 0) -n else n\n        }", "        val fractions = value.split('.')\n\
    \        var total = 0L\n        var i = 0\n        var pow = 1L\n        val\
    \ length = fractions.length\n        for(frac <- fractions) {\n            val\
    \ value = frac.toLong\n            total += value * pow\n            i ++\n  \
    \          pow *= 10L\n        }\n        val fractionLength = fractions.length\n\
    \        if (fractionLength == 0) {\n            total\n        } else if (fractionLength\
    \ == 1) {\n            total + fractions(0).toLong\n        } else if (fractionLength\
    \ == 2) {\n            total + fractions(0).toLong + fractions(1).toLong\n   \
    \     } else if (fractionLength >= 3) {\n            val min = (fractions(0).toLong\
    \ + fractions(1).toLong)\n            val max = (fractions(fractionLength - 1).toLong\
    \ + fractions(fractionLength).toLong)\n            val delta = max - min\n   \
    \         val closestNum = min + delta/2\n            val distance = pow * (fractionLength\
    \ - 1)\n            val result = closest + distance\n            closestNum.toLong\n\
    \        }", "        val input = value.asInstanceOf[String]\n        val splitInput\
    \ = input.split(\"\")\n        val inputAsList = splitInput.map(_.toLong).toList\n\
    \        val min = inputAsList.min()\n        val max = inputAsList.max()\n  \
    \      if(Math.abs(max - min) < .00001){\n            return inputAsList\n   \
    \     }\n        val diff = max - min\n        val diffAbs = Math.abs(diff)\n\
    \        val splitDiff = diff.split(\"\")\n        val diffAsList = splitDiff.map(_.toLong).toList\n\
    \        val index = diffAbs.indexOf(0)\n        val roundedDiff = diffAsList(index).toInt\n\
    \        val roundedDiffAbs = Math.abs(roundedDiff)\n        val roundDiff = roundedDiff\
    \ / Math.pow(10, diffAbs.length)\n        val roundDiffAbs = Math.abs(roundDiff)\n\
    \        if(diffAbs == roundedDiffAbs && diffAbs == roundDiffAbs){\n         \
    \   return inputAsList\n        }\n        val newInput = inputAsList.length -\
    \ 1\n        val splitNewInput = newInput.split(\"\")\n        val newInputAsList\
    \ = splitNewInput.map(_.toLong).toList\n        val minNewInput = newInputAsList.min()\n\
    \        val maxNewInput = newInputAsList.max()\n        if(Math.abs(maxNewInput\
    \ - minNewInput) < .00001){\n            return inputAsList\n        }\n     \
    \   val diff = maxNewInput - minNewInput\n        val diffAbs = Math.abs(diff)\n\
    \        val splitDiff = diff.split(\"\")\n        val diffAsList = splitDiff.map(_.toLong).toList\n\
    \        val index = diffAbs.indexOf(0)\n        val roundedDiff = diffAsList(index).toInt\n\
    \        val roundedDiffAbs = Math.abs(roundedDiff)\n        val roundDiff = roundedDiff\
    \ / Math.pow(10, diffAbs.length)\n        val roundDiffAbs = Math.abs(roundDiff)\n\
    \        if(diffAbs == roundedDiffAbs && diffAbs == roundDiffAbs){\n         \
    \   return inputAsList\n        }\n        val newInput2 = inputAsList.length\
    \ - 1\n        val splitNewInput2 = newInput2.split(\"\")\n        val newInputAsList2\
    \ = splitNewInput2.map(_.toLong).toList\n        val minNewInput2 = newInputAsList2.min()\n\
    \        val maxNewInput2 = newInputAsList2.max()\n        if(Math.abs(maxNewInput2\
    \ - minNewInput2) < .00001){\n            return inputAsList\n        }\n    \
    \    val diff = maxNewInput2 - minNewInput2", "        val splitString = value.split(\"\
    \\\\.\");\n        val stringValue = splitString(0);\n        val numberValue\
    \ = splitString(1);\n        val numberAsLong = tryParse(numberValue);\n     \
    \   val stringAsLong = tryParse(stringValue);\n        var numberToReturn: Long\
    \ = numberAsLong\n        if(stringValue == \"-\" && (numberAsLong + numberAsLong\
    \ == numberAsLong))\n            numberToReturn = numberAsLong * -1\n        if(numberAsLong\
    \ < numberToReturn && stringAsLong < numberToReturn)\n            numberToReturn\
    \ = numberAsLong\n        if(numberToReturn < numberAsLong && stringToReturn <\
    \ numberToReturn)\n            numberToReturn = numberToReturn\n        if(stringToReturn\
    \ < numberToReturn && stringAsLong < numberToReturn)\n            numberToReturn\
    \ = numberToReturn\n        if(stringToReturn < numberToReturn && stringToReturn\
    \ < stringAsLong)\n            numberToReturn = numberToReturn\n        if(stringToReturn\
    \ < stringAsLong)\n            numberToReturn = numberToReturn\n        numberToReturn",
  "        // Define a function that will find the closest integer\n        def closestInt(num\
    \ : Double) : Double = {\n            val abs = math.abs(num)\n            if(abs\
    \ < .1) {\n                if(abs < 1.0) {\n                    if(abs < 1.5)\
    \ {\n                        if(abs < 2.0) {\n                            if(abs\
    \ < 2.5) {\n                                if(abs < 3.0) {\n                \
    \                    if(abs < 3.5)\n                                        0\n\
    \                                }\n                            }\n          \
    \              }\n                    }\n                }\n            }\n  \
    \          else {\n                if(abs < 2.0) {\n                    if(abs\
    \ < 3.0) {\n                        if(abs < 3.5) {\n                        \
    \    if(abs < 4.0) {\n                                if(abs < 4.5)\n        \
    \                            0\n                            }\n              \
    \          }\n                    }\n                }\n            }\n      \
    \  }\n        // Convert the value to a double, make sure to convert it to double\n\
    \        // and not a string.\n        val x = value.asInstanceOf[Double]\n  \
    \      // Find the closest integer\n        val closestInt = (Math.round(x)).asInstanceOf[Double]\n\
    \        // Find the difference between closest integer and original value\n \
    \       val diffInt = x - closestInt\n        // Find the number of places after\
    \ the decimal to round to\n        val numPlaces = java.lang.Math.floor(java.lang.Math.abs(java.lang.Math.abs(diffInt)/0.1)).asInstanceOf[Double]\n\
    \        // Now get the nearest integer\n        val nearestInt = closestInt *\
    \ java.lang.pow(10,numPlaces)\n        // Find the absolute difference\n     \
    \   val diff = Math.abs(nearestInt - x)\n        // Return the closest integer\n\
    \        return closestInt.asInstanceOf[Long]", "        // Convert string to\
    \ a number\n        var value = value.toLong\n        var last = 0\n        //\
    \ Loop through all possible integers\n        for (i <- 1 until value) {\n   \
    \         // Check if a multiple of i\n            if (value % i == 0) {\n   \
    \             // If so, check if it is closer to last or not\n               \
    \ if (Math.abs(value - i) < Math.abs(value - last)) {\n                    //\
    \ If so, use i\n                    last = i\n                }\n            }\n\
    \        }\n        // Return final answer\n        value", "        val valueAsDouble\
    \ = value.asInstanceOf[String].toDouble\n        val closestInteger = math.ceil(valueAsDouble)\n\
    \        val closestIntegerAsString = closestInteger.toString.asInstanceOf[String]\n\
    \        (closestIntegerAsString -> closestInteger)", "        val num = value.toLong\n\
    \        // If there is no integer after the decimal\n        if (num < 10.0)\n\
    \            num\n        // If there is an integer, get rid of everything after\
    \ the decimal\n        else {\n            // If there is more than one integer\
    \ after the decimal\n            if (num > 99)\n                num / 10.0\n \
    \           // If there is only one integer after the decimal\n            else\
    \ {\n                // Return the integer if it is closer to zero\n         \
    \       val pow10 = math.pow(10.0, math.ceil(math.log10(num)))\n             \
    \   val intVal = num / pow10\n                if (intVal < num)\n            \
    \        intVal\n                else\n                    num\n            }\n\
    \        }", "        val result = value.trim.toDouble.abs + 1\n        val fraction\
    \ = value.substring(0,value.length-1)\n        val decimal = fraction.substring(fraction.length-1,fraction.length)\n\
    \        val fractionalInt = decimal.toInt\n        if(fractionalInt > result)\n\
    \            fractionalInt\n        else if(fractionalInt == result)\n       \
    \     fractionalInt + 1\n        else\n            result", "        if (value.isEmpty)\
    \ throw new Exception(\"Empty value\")\n        val parts = value.split('.')\n\
    \        if (parts.size > 3) throw new Exception(\"Invalid value\")\n        val\
    \ digits = parts(0) to parts(parts.size-1)\n        val smallestDistance = digits.size-1\n\
    \        for {\n            d <- digits\n        } yield {\n            val x\
    \ = d.toInt\n            if (x < 0)\n                smallestDistance = digits\n\
    \            else smallestDistance = digits.size-1\n        }\n        smallestDistance",
  "       if (value.contains(\".\")){\n           val splits = value.split('.')\n\
    \           val integer1 = splits(0).toLong\n           val integer2 = splits(1).toLong\n\
    \           val difference = integer2 - integer1\n           val quotient = difference\
    \ / integer1\n           return integer1 + quotient\n       } else {\n       \
    \    val splits = value.split('.')\n           val integer = splits(0).toLong\n\
    \           val remainder = integer % 1\n           return integer + remainder\n\
    \       }", "        val valueAsLong = value.trim.toLong\n        // Find the\
    \ distance between the current value and the target value\n        val distance:\
    \ Double = closestDistance(valueAsLong)\n\n        // Return the value that is\
    \ closest to the given value that is less than\n        // or equal to zero\n\
    \        math.round(distance)", "        // Create a list of (index, integer)\
    \ pairs\n        val (indice, integer) =\n            value match {\n        \
    \        // match on two integers, return an index that maps to an integer from\
    \ 0\n                case x if x.toInt == x =>\n                    (0L, x.toLong)\n\
    \                // match on two integers, return a pair of integers\n       \
    \         case x if x.toInt == x.toInt =>\n                    (0L, x.toInt)\n\
    \                // match on a float, return a pair of integers\n            \
    \    case x if x.toFloat == x.toFloat =>\n                    (0L, x.toDouble)\n\
    \                // otherwise, match on any string representation of a number\n\
    \                case x if x.toString.toInt == x.toString.toInt =>\n         \
    \           (0L, x.toString.toLong)\n            }\n        // Iterate through\
    \ the list to find the nearest integer\n        val newIndice = indice.zip(integer)\n\
    \        newIndice.foreach{ case (index, integer) =>\n            // If the index\
    \ is the same as the previous, don't do anything\n            if (index == indice.head\
    \ - 1) {\n                index\n            } else {\n                // If we\
    \ are not equidistant, round it away\n                if (Math.abs(integer - indice.tail.head)\
    \ > integer) {\n                    index - indice.head - 1\n                }\
    \ else {\n                    index\n                }\n            }\n      \
    \  }"]
stop_tokens:
- "\n    }\n"
