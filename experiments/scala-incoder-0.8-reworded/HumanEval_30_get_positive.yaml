name: HumanEval_30_get_positive
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return only positive numbers in the list.\n    // >>> getPositive((List[Long](-1l.toLong,\
  \ 2l.toLong, -4l.toLong, 5l.toLong, 6l.toLong)))\n    // (List[Long](2l.toLong,\
  \ 5l.toLong, 6l.toLong))\n    // >>> getPositive((List[Long](5l.toLong, 3l.toLong,\
  \ -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong,\
  \ 1l.toLong, -10l.toLong)))\n    // (List[Long](5l.toLong, 3l.toLong, 2l.toLong,\
  \ 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))\n    def getPositive(l : List[Long])\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(getPositive((List[Long](-1l.toLong,\
  \ -2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))).equals((List[Long](4l.toLong, 5l.toLong,\
  \ 6l.toLong))));\n    assert(getPositive((List[Long](5l.toLong, 3l.toLong, -5l.toLong,\
  \ 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong, 1l.toLong,\
  \ -10l.toLong))).equals((List[Long](5l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
  \ 3l.toLong, 9l.toLong, 123l.toLong, 1l.toLong))));\n    assert(getPositive((List[Long](-1l.toLong,\
  \ -2l.toLong))).equals((List[Long]())));\n    assert(getPositive((List[Long]())).equals((List[Long]())));\n\
  \    }\n\n}\n"
completions: ["        val result = new mutable.ListBuffer[Long]()\n        for (x\
    \ <- l) {\n            if (x >= 0l) result.append(x)\n        }\n        return\
    \ result.toList", '        l filter (_ > 0)', "        val positivesOnly = l.filter(v\
    \ => v > 0)\n        val positiveOnly = positivesOnly.distinct\n        positiveOnly.reverse",
  '        l.toList filter { _ > 0 }', "        val positive = l.filter(l => l > 0)\n\
    \        if (positive.isEmpty) l else positive", "        val negative = l.filter(_\
    \ <= 0l)\n        val positive = l.filter(_ > 0l)\n        positive.filter(_ <\
    \ 0l).foldLeft(List[Long]())((acc, x) => acc ++ List(x.toLong))", "        val\
    \ neg = -(l filter { x => x < 0})\n        if(neg isEmpty) l.filter(_ > 0)\n \
    \       else neg ++ l.filter(_ > 0)", "        val res = mutable.ListBuffer[Long]()\n\
    \        l.foreach(_ < 0 match {\n            case true => res ++= 0\n       \
    \     case false => res ++= _\n        })\n        res", '        l.filter(x =>
    x > 0).distinct', '        l filter (_ > 0)', "        var newL  = l.filter(_\
    \ < 0)\n        var isPos = 0\n        for(i <- 0 to (l.length-1)) {\n       \
    \     if(newL(i) < 0) {\n                newL(i) = newL(i) + 1\n             \
    \   isPos = 1\n            } else {\n                newL(i) = newL(i) - 1\n \
    \               isPos = 0\n            }\n        }\n        if(isPos == 0) return\
    \ l\n        else return newL", "        val positive = new mutable.HashSet[Long]()\n\
    \        l.foreach(x => if (x >= 0) positive.add(x))\n        positive filter\
    \ { x => x >= 0} map { x => x }", "        val positive = new mutable.LinkedHashSet[Long]()\n\
    \        for (i <- 0 until l.length) {\n            if((l(i) >= 0) && (!positive.contains(l(i))))\
    \ {\n                positive.add(l(i))\n            }\n        }\n        (List[Long](positive.toList))",
  "        val pos = new mutable.HashSet[Long]()\n        l.foreach{x => pos.add(x)}\n\
    \        pos.filter(x => x > 0)", "        var n = 0\n        var positive = List[Long]()\n\
    \        l.foreach(_ => {\n            n += 1\n            if(n > 0) positive\
    \ = positive :+ _\n        })\n        return positive", '        l filter (_
    > 0)', "        if(!l.isEmpty) l.filter(_.toLong >= 0).map(_.toLong).sort\n  \
    \      else List[Long]()", '        l filter (_ > 0) filter (_ < Long.MaxValue)',
  "        val p = mutable.Stack.empty[Long]\n        l foreach {x => if (x >= 0)\
    \ p += x}\n        p toList", '        l filter (_ > 0) filter (_ < Long.MaxValue)',
  "        val positive = mutable.ListBuffer[Long]()\n        l.foreach { n =>\n \
    \           if (n > 0) positive.add(n)\n        }\n        positive.toList", " \
    \       // use mutable.HashMap to track duplicate number\n        var numMap =\
    \ mutable.HashMap[Long, Int]()\n        l foreach { x =>\n            // if not\
    \ exist in the map, add it\n            if (numMap.contains(x)) numMap(x) += 1\n\
    \            else numMap(x) = 1\n        }\n        numMap.filter { case (k, v)\
    \ => v > 0 }.map { case (k, v) => k }.toList", "      l match {\n        case\
    \ Nil => Nil\n        case h :: t => t filter (_ > 0)\n      }", "        val\
    \ positiveList = mutable.MutableList[Long]()\n        l.foreach(n => {\n     \
    \       if (n > 0)\n                positiveList += n\n        })\n        return\
    \ positiveList.toList", '        l filter (_.isPositive)', "        val r = new\
    \ mutable.ArrayBuffer[Long]()\n        for (x <- l) {\n            if (x > 0)\
    \ {\n                r.+= x\n            }\n        }\n        r.reverse", '        l
    filter (i => i >= 0l)', "        // return a new list with only positive numbers\n\
    \        l.filter(_ > 0).toList", '        l.filter(a => a > 0)', '        l.filter(x
    => x >= 0l)', '        l.filter(i => i >= 0).toList', "        l match {\n   \
    \         case Nil => Nil\n            case Nil::Nil => Nil\n            case\
    \ _::xs => if (xs.nonEmpty) xs.head :: getPositive(xs.tail) else Nil\n       \
    \ }", "        val set = mutable.HashSet[Long]()\n        for(x <- l)\n      \
    \      if(x >= 0)\n                set.add(x)\n        l", '        l filter {
    i => i > 0 }', "        val newList = l.filter(_ > 0)\n        newList", '        l.filter(_
    >= 0).toList', '        l.filterNot(_ < 0).toList', "        val n = l.length\n\
    \        l.filter(_ > 0).toList", "        val positives = mutable.ListBuffer[Long]()\n\
    \        l.foreach { x =>\n            if (x > 0)\n                positives +=\
    \ x\n        }\n        positives.toList", '        l.filter(l => l > 0)', " \
    \       val l2 = l.filter(_ > 0).toList\n        if (l2.isEmpty) l else l2", " \
    \       val posLongs = l filter (_ > 0)\n        if (posLongs.isEmpty) {\n   \
    \         List[Long](1l)\n        } else {\n            posLongs\n        }",
  "        val positives = l filter { x => x >= 0l}\n        positives", '        l.filter(x
    => x > 0)', '        l.filter(l => l > 0)', "        val posNums : mutable.Set[Long]\
    \ = mutable.Set()\n        val negNums : mutable.Set[Long] = mutable.Set()\n\n\
    \        l.foreach { n => if (n > 0l) posNums += n else if (n < 0l) negNums +=\
    \ n }\n        (posNums ++ negNums).toList", '        l.filter( x => x >= 0 ).filter(
    x => x % 2 == 0 )', "        var ans = List[Long]()\n        var i = 0\n     \
    \   while (i < l.length) {\n            if (l(i) > 0) {\n                ans =\
    \ ans :+ l(i)\n                i += 1 \n            }\n        }\n        return\
    \ ans ", "        val positives = mutable.ListBuffer[Long]()\n        l.foreach\
    \ { number =>\n            if (number > 0) positives += number\n        }\n  \
    \      positives", '        l filter (_ >0) filter (_ > 0l)', '        l.filter(_
    > 0).toList', "        l match {\n            case Nil => Nil\n            case\
    \ x :: xs =>\n                if (x < 0) throw new Exception(\"Negative numbers\
    \ are not allowed\")\n                x :: getPositive(xs)\n        }", '        l.filter(_
    > 0).toList', "        for (i <- 0 until l.length)\n            if (l(i) <= 0l)\n\
    \                l(i) = -l(l(i))\n        l", "        // Convert list to sorted\
    \ list.\n        l.sortWith(_.toLong <= _)\n        // Filter out all negative\
    \ numbers.\n        // >>> getPositive((List[Long](-1l.toLong, 2l.toLong, -4l.toLong,\
    \ 5l.toLong, 6l.toLong)))\n        // (List[Long](2l.toLong, 5l.toLong, 6l.toLong))\n\
    \        l filter (_.toLong > 0)", '        l filter { t => t > 0 } :: Nil', " \
    \       def filterOut(l : List[Long], x : Long) : List[Long] = {\n           \
    \ if(l(x) < 0l){\n                l.filterNot(x => x == x)\n            } else\
    \ {\n                l\n            }\n        }\n        l.map(x => x + 0l).foldLeft(List[Long]())((acc,\
    \ x) => filterOut(acc, x)).sort", '        l.filter { x => x < 0l }', '        l.filter(x
    => x > 0)', "        if (l.isEmpty) List(1l)\n        else getPositive(l.tail)\
    \ flatMap (l => if (l > 0) List(l) else List(0))", '        l filter (x => x >
    0)', '      l.filter(i => i>0).distinct', "        var res = l\n        var i\
    \ = 0\n        while (i < res.length)\n            if (res(i) < 0l)\n        \
    \        res.length = i\n            else\n                i += 1\n        return\
    \ res", "        val positiveNumbers = l.filter(_ > 0).toList\n        val positiveList\
    \ = l.filter(_ > 0).toList\n        val result = positiveNumbers.filter(_ > 0).toList\n\
    \        result.copy(positiveNumbers)", "        val p = new mutable.PriorityQueue[Long]()\n\
    \        for( n <- l ) if(n > 0) p.enqueue(n)\n        val r = new mutable.ArrayBuffer[Long]()\n\
    \        while (!p.isEmpty) {\n            val n = p.dequeue()\n            if\
    \ (n > 0) {\n                r.add(n)\n            }\n        }\n        r", " \
    \       val pos = new mutable.ListBuffer[Long]\n        for (x <- l) {\n     \
    \       if (x >= 0l) pos += x\n        }\n        pos.toList", '        l.filter(_
    > 0)', "        var result : List[Long] = Nil\n        for (i<- 0 to l.length-1){\n\
    \            if (l(i) > 0){\n                result += l(i)\n            }\n \
    \       }\n        return result", "        l filter { a => \n            a >\
    \ 0 \n        }", "        val res = scala.collection.mutable.List[Long]()\n \
    \       l.foreach(x => if (x >= 0l.toLong) res += x)\n        res", "        val\
    \ positiveNumbers = l\n        val negativeNumbers = l.filter { _ > 0}\n     \
    \   positiveNumbers.toList.filter(_.isPositive)", '        l.filter(x => x > 0).toList',
  "        val positives = mutable.Buffer[Long]()\n        l.foreach(x => if (x >=\
    \ 0) positives += x)\n        positives.toList", "        val positive = new scala.collection.mutable.ArrayBuffer[Long]()\n\
    \        for (i <- 0 until l.length) {\n            if (l(i) > 0)\n          \
    \      positive.append(l(i))\n        }\n        positive.toList", "        l\
    \ match {\n            case x :: y :: xs if x > 0  => y :: getPositive(xs)\n \
    \           case x :: ys => x :: getPositive(ys)\n            case Nil => Nil\n\
    \        }", "        var positive = new mutable.ListBuffer[Long]()\n        for\
    \ (i <- 0 until l.length) {\n            if (l(i) >= 0) positive+=l(i)\n     \
    \   }\n        return positive.toList", '        l filter (i => i >= 0).toList',
  '        l filter (_ > 0)', '        l.filter{x => x > 0}', '        l.filter(x
    => x > 0).distinct', "        val positiveList = mutable.ArrayBuffer(l(0));\n\
    \        for (i<-l.size-1 to 1 by -1){\n            if(l(i)>0){\n            \
    \    positiveList += l(i)\n            }\n        }\n        return positiveList.iterator",
  "        var n = 0\n        var res = new collection.mutable.ArrayBuffer[Long]()\n\
    \        for (x <- l) {\n            if (x > 0) n += 1\n            res = res\
    \ + x\n        }\n        if (n > 0) res = res +: (-1*res).toList\n        res",
  '        l.filter(x => x >= 0).toList', "        val positives = mutable.HashSet[Long]()\n\
    \        for (i <- l if i >= 0) positives += i\n        positives.toList", " \
    \       var result = mutable.ListBuffer.empty[Long]\n        for(i <- l)\n   \
    \         if(!i.equals(0l))\n                result += i\n        return result.toList",
  '        l filter {_.toInt >= 0} ', "        val positives = mutable.Set[Long]()\n\
    \        l.foreach(x=> if (x > 0) positives += x)\n        positives.toList",
  '        l.filter(x => x > 0)', "        val l2 = l.filter(_ > 0)\n        l2",
  "        if (l.isEmpty)\n            Nil\n        else if (l.head <= 0l)\n     \
    \       Nil\n        else\n            l.head :: getPositive(l.tail)", "     \
    \   l match {\n            case Nil => Nil\n            case Long(lx) => if (lx\
    \ > 0) lx :: getPositive(l.tail) else getPositive(l.tail)\n            case x\
    \ :: xs => getPositive(xs)\n        }", '        l.filter(n => n < 0).toList',
  '        l.filterNot(_ < 0).toList', "        val pos =\n        l.filter(_ > 0).toList\
    \ ::\n        l.filter(_ <= 0).toList ::\n        l.filter(_ <= 0).toList.reverse\n\
    \        pos.reverse", "        l match {\n            case Nil => Nil\n     \
    \       case h :: t => if(h > 0) h :: getPositive(t) else getPositive(t)\n   \
    \     }", "        var ret : List[Long] = Nil\n        for(i <- l.iterator)\n\
    \            if(i.intValue > 0)\n                ret ::= i\n        ret", "  \
    \      if (l.isEmpty) Nil\n        else if (l.head < 0l) Nil\n        else l.takeWhile(x\
    \ => x < 0l) ++ l.dropWhile(x => x < 0l).reverse", "        var positives = mutable.ListBuffer[Long]()\n\
    \        for (i <- l) {\n            if (i >= 0l) {\n                positives\
    \ += i\n            }\n        }\n        positives.toList", '        l filter
    (_ > 0) map (_ + l.min) toList', '      l.filter(i => i >= 0).toList', '        l.filter(
    _ > 0l)', "        val positive = l.filter(e => e >= 0).toSet\n        l filterNot\
    \ (e => positive(e))", "        // Get all the positive numbers into a List. \n\
    \        val positive = l.filter(p => p > 0)\n        // Return the List\n   \
    \     positive", '        l.filter(x => x > 0).distinct', "        if (l.isEmpty)\
    \ List();\n        val positiveList = l filterNot (x => x < 0).toList;\n     \
    \   positiveList.filter(x => x >= 0).toList", "        var result : List[Long]\
    \ = Nil\n        for(x<-l) {\n            if (x < 0) result = x :: result\n  \
    \      }\n        result", "        val newList : mutable.List[Long] = mutable.ListBuffer[Long]()\n\
    \        var i : Long = 1\n        while (i < l.length) {\n            if (l(i)\
    \ > 0) {\n                newList += l(i)\n            }\n            i += 1\n\
    \        }\n        newList.list", "        if (l.isEmpty) Nil\n        else if\
    \ (l.head.isPositive) l.tail\n        else getPositive(l.tail)", "        val\
    \ posNums = l.filter(_ > 0)\n        if (posNums.isEmpty) l.toList\n        else\
    \ posNums.toList", '        l.filter(_ > 0)', '        l.filter(x => x > 0)',
  "        def helper(l: List[Long], acc : List[Long]) : List[Long] = {\n        \
    \    if (l.isEmpty) acc\n            else helper(l.tail, acc ::: l.head :: acc)\n\
    \        }\n        helper(l, List.empty)", "        val n = l.toSet\n       \
    \ val p = new mutable.ListBuffer[Long]\n        for (x <- l) {\n            if\
    \ (n.contains(x)) {\n                p += x\n            }\n        }\n      \
    \  p.toList", "        val positive = mutable.Set[Long]()\n        val iter =\
    \ l.iterator\n        while (iter.hasNext) {\n            val v = iter.next\n\
    \            if (v >= 0l)\n                positive.add(v)\n        }\n      \
    \  positive.toList", "        val n = l.length\n        if (n < 1) {\n       \
    \     Nil\n        } else {\n            var i : Long = 0\n            while (i\
    \ < n) {\n                if (l(abs(i)) > 0)\n                    i += 1\n   \
    \             else\n                    break\n            }\n            l take\
    \ i drop 1\n        }", "        l match {\n            case head :: tail if head\
    \ > 0 => head :: getPositive(tail)\n            case _ => l\n        }", "   \
    \     // If list was empty return it unchanged\n        if (l.isEmpty) l\n\n \
    \       // Create mutable empty list\n        var res = new scala.collection.mutable.ListBuffer[Long]\n\
    \n        // Iterate through each element and add it to the result list if it\n\
    \        // is positive or zero\n        l.foreach { x =>\n            if (x >=\
    \ 0l) res += x\n        }\n\n        // Return the resulting list\n        res.toList",
  '        l.filter(x => x >= 0).toList', "        val positive = new mutable.ListBuffer[Long]()\n\
    \        val negative = new mutable.ListBuffer[Long]()\n        for(i <- 0 until\
    \ l.length){\n            if(l(i) > 0){\n                positive.+=l(i)\n   \
    \         }\n            else{\n                negative.+=l(i)\n            }\n\
    \        }\n        positive.distinct", "        val positive = new mutable.HashSet[Long]()\n\
    \        l.foreach {\n            x => positive.add(x)\n        }\n        positive.takeWhile(x\
    \ => x >= 0).toList", '        l.filter(_ > 0l)', "       val n = l.filter(i =>\
    \ i >= 0).toList\n       if (n.isEmpty) l.filter(_ >= 0).toList\n       else n.filter(_\
    \ >= 0).toList", "        val positives = mutable.ArrayBuffer[Long]()\n      \
    \  var current = null\n        var sum = 0\n        for (x<- l) {\n          \
    \  if (x > 0) {\n                sum += x\n                current = x\n     \
    \       }\n            positives += current\n        }\n        positives.toList",
  '        l.filter(i => i > 0).toList', "        val nums = l.filter(_ > 0l)\n  \
    \      nums.filter(_ < 0l).filterNot(_ % 2l).filterNot(_ % 3l).filterNot(_ % 5l).filterNot(_\
    \ % 7l).filterNot(_ % 11l).filterNot(_ % 13l).filterNot(_ % 17l).filterNot(_ %\
    \ 19l).filterNot(_ % 23l).filterNot(_ % 29l).filterNot(_ % 31l)", "        val\
    \ negatives = l.filter(_ < 0)\n        if (negatives.nonEmpty) {\n           \
    \ negatives.map(_ + 2l.toLong).toList\n        } else {\n            l.filter(_\
    \ >= 0).toList\n        }", "        val positives = mutable.HashSet[Long]()\n\
    \        l.foreach(num => if(num > 0) positives.add(num))\n        positives.toList",
  "        var positive = l.filter(v => v > 0).toList;\n        positive.sortWith((a,\
    \ b) => a < b)\n        positive.reverse", "        var r = new ListBuffer[Long]()\n\
    \        var i = 0\n        for (x <- l)\n            if (x >= 0L)\n         \
    \       r += x\n            else\n                i += 1\n        r.reverse\n\
    \        if (i < l.length)\n            r ++= l(l.length - i - 1)\n        r.toList",
  "        val l2 = l.filter(x => x >= 0l)\n        if (l2.isEmpty) l else l2", " \
    \       l match {\n            case List() => List()\n            case x :: xs\
    \ => if (x > 0) x :: getPositive(xs) else getPositive(xs)\n        }", '        l.filter(_
    > 0)', "        var result = ListBuffer[Long]()\n        for (i <- l) if (i >\
    \ 0) result += i\n        return result.toList", '        l.filter(_ >= 0).toList',
  '        l filter (_ > 0)', "        var result = List[Long]()\n        l foreach\
    \ (elem => {\n            if (elem > 0) result ::= elem\n        })\n        result",
  '        l.filter(_ > 0)', "        var negate = false\n        var ans = new mutable.ListBuffer[Long]()\n\
    \        for (i <- l) {\n            if (i >= 0) {\n                ans ::= i\n\
    \            } else {\n                negate = true\n            }\n        }\n\
    \        if (negate) {\n            ans.reverse ::: (0 :: ans)\n        } else\
    \ {\n            ans\n        }", '        l.filter(x => x > 0).toList', "   \
    \     val positives = mutable.Set[Long]()\n        for (i <- l) {\n          \
    \  if (i >= 0l) {\n                positives.add(i)\n            }\n        }\n\
    \        positives.toList", "        l match {\n            case Nil => Nil\n\
    \            case x :: xs =>\n                val l = List(x)\n              \
    \  val newL = xs.filter(_ > 0)\n                if (newL.size != l.size) l\n \
    \               else newL\n        }", "        val positives = mutable.ListBuffer[Long]()\n\
    \        val negatives = mutable.ListBuffer[Long]()\n        l.foreach{number\
    \ => \n            if (number > 0) positives += number\n            else negatives\
    \ += number\n        }\n        positives ++ negatives", "        val l2 = l.toList\n\
    \        l2.filter(x => x >= 0).toList", "        var list : List[Long] = Nil\n\
    \        for (x <- l)\n            if (x > 0)\n                list = list :+\
    \ x\n        list", '        l.filter(n => n > 0)', "        val result = new\
    \ mutable.ListBuffer[Long]()\n        for(i <- 0 until l.length) if(l(i) >= 0)\
    \ result += l(i)\n        result", '        l.toList.filterNot(_ < 0).toList',
  "        val positive = l.filter(x => x >= 0).toList\n        positive :: getPositive(l.filter(x\
    \ => x < 0).toList)", '        l.filter(_.isPositive)', "        var l : List[Long]\
    \ = l\n        if (l.isEmpty) \n            return (l)\n        l.foreach{\n \
    \           num => if (num > 0) \n                l = List(num)\n        }\n \
    \       return (l)", "        val ns = l.toSet\n        ns.filter { n => n > 0\
    \ }", '        l.filter(_ > 0)', '        l.filterNot(_ < 0l).toList', '        l.filter(n
    => n > 0).distinct', "        // We use mutable.Set to avoid counting duplicate\
    \ elements\n        val positives = mutable.Set[Long]()\n        for (i <- l)\
    \ {\n            i match {\n                case i if i >= 0l => positives.add(i)\n\
    \                case i => positives.add(-i)\n            }\n        }\n     \
    \   // Sort and remove duplicates\n        positives.sortWith(_ < _).distinct",
  "        val l = l.filterNot(_ < 0L)\n        l.filter(x => x >= 0L)", '        l
    filter (_ > 0)', "        if (l.isEmpty)\n            Nil\n        else\n    \
    \        if (l.head < 0)\n                l.filter( x => x < 0).toList\n     \
    \       else\n                l.filter( x => x >= 0).toList", "        if (l.isEmpty)\
    \ Nil\n        else {\n            var res :List[Long] = Nil\n            val\
    \ l1 :List[Long] = l.toList\n            l1.foreach { x =>\n                if\
    \ (x < 0) res :+= x\n            }\n            res\n        }", "        val\
    \ positives: List[Long] = l.filter(_ > 0).toList\n        if (positives.isEmpty)\
    \ l.filter(_ > 0).toList\n        else positives", '        l.filter(i => i >=
    0).toList', '        l.filter(x => x >= 0l.toLong)', "        l match {\n    \
    \        case List() => List() // empty list\n            case x::xs => {\n  \
    \              var y = xs.filter(_ > 0)\n                if (y.isEmpty) y = xs.filter(_\
    \ > 0)\n                if (y.isEmpty) y = xs.filter(_ > 0)\n                if\
    \ (y.isEmpty) y = xs.filter(_ > 0)\n                if (y.isEmpty) y = xs.filter(_\
    \ > 0)\n                if (y.isEmpty) y = xs.filter(_ > 0)\n                if\
    \ (y.isEmpty) y = xs.filter(_ > 0)\n                if (y.isEmpty) y = xs.filter(_\
    \ > 0)\n                if (y.isEmpty) y = xs.filter(_ > 0)\n                if\
    \ (y.isEmpty) y = xs.filter(_ > 0)\n                if (y.isEmpty) y = xs.filter(_\
    \ > 0)\n                if (y.isEmpty) y = xs.filter(_ > 0)\n                if\
    \ (y.isEmpty) y = xs.filter(_ > 0)\n                if (y.isEmpty) y = xs.filter(_\
    \ > 0)\n                if (y.isEmpty) y = xs.filter(_ > 0)\n                if\
    \ (y.isEmpty) y = xs.filter(_ > 0)\n                if (y.isEmpty) y = xs.filter(_\
    \ > 0)\n                if (y.isEmpty) y = xs.filter(_ > 0)\n                if\
    \ (y.isEmpty) y = xs.filter(_ > 0)\n                if (y.isEmpty) y = xs.filter(_\
    \ > 0)\n                if (y.isEmpty) y = xs.filter(_ > 0)\n                if\
    \ (y.isEmpty) y = xs.filter(_ > 0)\n                if (y.isEmpty) y = xs.filter(_\
    \ > 0)\n                if (y.isEmpty) y = xs.filter(_ > 0)\n                if\
    \ (y.isEmpty) y = xs.filter(_ > 0)\n                if (y.isEmpty) y = xs.filter(_\
    \ > 0)\n                if (y.isEmpty) y = xs.filter(_ > 0)\n                if\
    \ (y.isEmpty) y = xs.filter(_ > 0)\n                if (y.isEmpty) y = xs.filter(_\
    \ > 0)\n                if (y.isEmpty) y = xs.filter(_ > 0)\n                if\
    \ (y.isEmpty) y = xs.filter(_ > 0)\n                if (y.isEmpty) y = xs.filter(_\
    \ > 0)\n                if (y.isEmpty) y = xs.filter(_ > 0)\n                if\
    \ (y.isEmpty) y = xs.filter(_ > 0)\n                if (y.isEmpty) y = xs.filter(_\
    \ > 0)\n                if (y.isEmpty) y = xs.filter(_ > 0)\n                if\
    \ (y.isEmpty) y = xs.filter(_ > 0)\n                if (y.isEmpty) y = xs.filter(_\
    \ > 0)\n                if (y.isEmpty) y = xs.filter(_ > 0)\n                if\
    \ (y.isEmpty) y = xs.filter(_ > 0)\n                if (y.isEmpty) y = xs.filter(_\
    \ > 0)\n                if (y.", "        if (l.length < 2) \n            l.toList\n\
    \        else \n            l.map{ a =>\n                if(a<0) \n          \
    \          -a\n                else \n                    a\n            }.filter{x\
    \ =>\n                if (x > 0) {\n                    x\n                }\n\
    \            }.toList", "        // Sort by ascending order and take only positive\
    \ values.\n        l.sortBy(l => l).takeWhile(l => l > 0).toList", "        val\
    \ positive = l.filter{x => x >= 0} ::: List(0)\n        positive", "        //\
    \ Your code here\n        return l.filter( x=> x > 0)", "        val newList =\
    \ mutable.MutableList[Long]()\n        for(i <- l) {\n            if(i>0) newList\
    \ += i\n        }\n        newList.toList", '        l.filter(_ > 0).toList',
  "        var toReturn = l\n        var foundPositive = false\n        while(toReturn.nonEmpty\
    \ && !foundPositive) {\n            if (toReturn.head > 0) {\n               \
    \ foundPositive = true\n            } else {\n                toReturn = removePositive(toReturn)\n\
    \            }\n        }\n        toReturn", '        l.filterNot(_ < 0)', " \
    \       val x = l.map{_ > 0l}\n        val y = l.filter{_ > 0l}\n        val z\
    \ = x union y\n        return z.toList", "        // Add list with 0 to ensure\
    \ list has at least one positive number.\n        val n = new mutable.WrappedArray[Long](l,\
    \ 0L)\n        val n = n.sortBy(x => x)\n        return if (n.last < 0L) List()\
    \ else n.dropRight(1).reverse", "        var positives = new mutable.ListBuffer[Long]()\n\
    \        for (item <- l) {\n            if (item > 0 ) positives += item\n   \
    \     }\n        return positives", "        val positive = new collection.mutable.ListBuffer[Long]\n\
    \        l.foreach { x => if (x >= 0) positive.append(x) }\n        positive.toList",
  "        if (l == Nil)\n            Nil\n        else\n            l\n         \
    \       .filter(x => x > 0)\n                .toList", "        val positive =\
    \ l.filter(l => l.toLong > 0l.toLong)\n        positive", '        l filterNot
    (_ < 0)', '        l.filter(e => e > 0l.toLong).toList', '        l.filter(x =>
    x >= 0).toList', "       val newList = l.filter(x => x >= 0).toList\n       if\
    \ (newList.isEmpty) List(l.head) \n       else newList", '        l filterNot
    (_ > 0l) filterNot (_ < 0l)', '        l.filter(a => a > 0).filterNot(a => a ==
    0).toList', '        l.filter(n => n > 0).toList', "        val newList = mutable.ArrayBuffer.empty[Long]\n\
    \        for (l1 <- l) if (l1.toLong > 0) newList += l1\n        newList.toList",
  '        l.filter(_ > 0l)', '        l.filterNot(_.isNeg)', "        val list =\
    \ l.toArray\n        list.filter(l => l > 0).toList", "        var n = 0\n   \
    \     val rList = l.filter( n => n.toInt == n.toInt )\n        rList", "     \
    \   if (l.isEmpty || l.head <= 0l)\n            return Nil\n        val l2 = l.tail\n\
    \        var i = 0\n        var res = Nil\n        for (x <- l2) {\n         \
    \   if (x > 0l) {\n                i += 1\n                if (i == 1l)\n    \
    \                res = x :: res\n                else\n                    res\
    \ ::: Nil\n            }\n        }\n        return res", "        val positives\
    \ = new mutable.ListBuffer[Long]()\n        l foreach {\n            x => if(x\
    \ >= 0) positives += x\n        }\n        positives.toList", "        for (x\
    \ <- l)\n            if (x > 0l)\n                yield x", "        var new_l\
    \ = new scala.collection.mutable.ArrayBuffer[Long]()\n        for (i <- 0 until\
    \ l.size) {\n            if (l(i) >= 0l) {\n                new_l += l(i)\n  \
    \          }\n        }\n        return new_l.toList", "        val positive =\
    \ l.filter(_ > 0l)\n        if (positive.isEmpty) List(-1l.toLong)\n        else\
    \ positive", "        val positive = l.filter(_ > 0)\n        val negative = l.filter(_\
    \ < 0)\n        positive.union(negative)", "        val positive = l.filter(_\
    \ > 0l)\n        positive.reverse", "        val r = new collection.mutable.LinkedList[Long]()\n\
    \        l.foreach{ x => if (x >= 0) r.add(x) }\n        return r.toList", " \
    \       val newList = l.filter( n => n >= 0 )\n        if (newList.length > 0)\
    \ newList else List[Long]()", "        var res = []\n        l.foreach(n => \n\
    \            if(!(res.length >= 0 || n <= 0)) res.append(n)) \n        return\
    \ res", "        var positive = new mutable.ListBuffer[Long]()\n        var currentPositive\
    \ = false\n        for(x <- l) {\n            if(x > 0) {\n                positive.add(x)\n\
    \                currentPositive = true\n            }\n            else if(x\
    \ != 0) {\n                positive.add(0)\n                currentPositive =\
    \ false\n            }\n        }\n        if(!currentPositive) {\n          \
    \  positive.add(0)\n        }\n        positive.toList"]
stop_tokens:
- "\n    }\n"
