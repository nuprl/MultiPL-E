{
  "language": "scala",
  "name": "HumanEval_119_match_parens",
  "results": [
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 1) {\n            \"No\"\n        } else if (lst.length == 2) {\n            \"Yes\"\n        } else {\n            val rec : Boolean = lst.sliding(2).forall(x => x.contains(\"(\") && x.contains(\")\"))\n            if (rec) {\n                \"Yes\"\n            } else {\n                \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2l9aj2po.scala:33)\n\tat Problem.main(tmp2l9aj2po.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659979956
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val (good, bad) = lst.partition(i => i.contains(\"(\"))\n        if (good.isEmpty) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpilx035d5.scala:24)\n\tat Problem.main(tmpilx035d5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659979956
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val count = new mutable.HashMap[String, Int]()\n      val pair = new mutable.HashMap[String, Int]()\n      pair += (\"(\" -> 1)\n      pair += (\")\" -> 1)\n      lst.foreach {\n        case str =>\n          val n = count(str)\n          if(n == 0) \"No\" else \"Yes\"\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzp9z1crg.scala:18:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mcount\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mString\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzp9z1crg.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mpair\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mString\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzp9z1crg.scala:22:18 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m      lst.foreach {\n\u001b[31m\u001b[31m   |\u001b[0m      ^\u001b[0m\n\u001b[31m   |\u001b[0m      Found:    Unit\n\u001b[31m   |\u001b[0m      Required: String\n\u001b[31m23 |\u001b[0m        \u001b[33mcase\u001b[0m str =>\n\u001b[31m24 |\u001b[0m          \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = count(str)\n\u001b[31m25 |\u001b[0m          \u001b[33mif\u001b[0m(n == \u001b[31m0\u001b[0m) \u001b[31m\"No\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m26 |\u001b[0m      }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979954
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val list = lst.filter(_.toString.contains(\"(\")).toSet\n        val set = lst.filter(_.toString.contains(\")\")).toSet\n        val len = list.size\n        if (len == 0) \"No\"\n        else {\n            val setLen = set.size\n            if (setLen < len) {\n                val newSet = set.map(i => i.replace(\"(\", \"()\"))\n                val newList = list.map(i => i.replace(\")\", \"()\"))\n                if (newSet.toSet.size == newList.size) \"Yes\"\n                else \"No\"\n            }\n            else if (setLen > len) {\n                if (lst.head == list) \"Yes\"\n                else \"No\"\n            }\n            else {\n                if (list.toSet.size == set.size) \"Yes\"\n                else \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp732dz1y7.scala:31:20 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                \u001b[33mif\u001b[0m (lst.head == list) \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m Values of types String and Set[String] cannot be compared with == or !=\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979954
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[List[String]]()\n        val stackString = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        for (i <- 0 until lst.length-1) {\n            if (lst(i) == '(') {\n                stack push (lst(i))\n                queue enqueue (lst(i))\n            }\n            if (lst(i) == ')') {\n                while (!stack.isEmpty && !(stackString.isEmpty) && stackString(stackString.length-1) == '(') {\n                    stackString push (stack.pop())\n                }\n                if (!stack.isEmpty) {\n                    stack pop\n                }\n            }\n        }\n        if (stackString.isEmpty) {\n            \"No\"\n        } else {\n            \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpp7t26nw2.scala:31:29 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    stack pop\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp7t26nw2.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m]]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp7t26nw2.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackString\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp7t26nw2.scala:20:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpp7t26nw2.scala:22:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (lst(i) == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpp7t26nw2.scala:26:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (lst(i) == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1659979955
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val p = lst.size\n        if(p < 2) {\n            \"No\"\n        }\n        if(p > 2) {\n            \"Yes\"\n        }\n        val s = lst.head\n        def incl(s: String, l: Seq[String]): Seq[String] = {\n            l match {\n                case Nil => Seq(s)\n                case x :: xs => x :: incl(s, xs)\n            }\n        }\n        val lst2 = incl(s, lst)\n        val l2 = lst2.size\n        if(l2 < p) {\n            \"Yes\"\n        }\n        else {\n            if(lst2.contains(s.reverse.head)) {\n                val newS = s.reverse.head +: lst2.tail\n                val lst3 = incl(newS, lst2)\n                if(lst3.size == p) {\n                    \"Yes\"\n                }\n                else {\n                    \"No\"\n                }\n            }\n            else {\n                \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjy0v8ga_.scala:28:21 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33mcase\u001b[0m Nil => Seq(s)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (Nil : => collection.immutable.Nil\u00b2.type)\n\u001b[31m   |\u001b[0m        Required: collection.mutable.Seq[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m        where:    Nil  is a getter in \u001b[33mpackage object\u001b[0m \u001b[35mscala\u001b[0m\n\u001b[31m   |\u001b[0m                  Nil\u00b2 is a object in \u001b[33mpackage\u001b[0m \u001b[35mscala.collection.immutable\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m        pattern type is incompatible with expected type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjy0v8ga_.scala:29:45 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                \u001b[33mcase\u001b[0m x :: xs => x :: incl(s, xs)\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (xs : List[Any])\n\u001b[31m   |\u001b[0m                                Required: collection.mutable.Seq[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjy0v8ga_.scala:32:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlst2\u001b[0m = incl(s, lst)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (lst : List[String])\n\u001b[31m   |\u001b[0m                           Required: collection.mutable.Seq[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjy0v8ga_.scala:40:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mlst3\u001b[0m = incl(newS, lst2)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (newS : scala.collection.mutable.Seq[Matchable])\n\u001b[31m   |\u001b[0m              Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m",
      "stdout": "",
      "timestamp": 1659979955
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        lst.foldLeft(List[String](\"No\")){\n            (acc, s) =>\n                acc.foldLeft(List[String](\"Yes\")){\n                    (acc, s) =>\n                        acc.foldLeft(List[String](\"No\")){\n                            (acc, s) =>\n                                acc.foldLeft(List[String](\"Yes\")){\n                                    (acc, s) =>\n                                        acc.foldLeft(List[String](\"No\")){\n                                            (acc, s) =>\n                                                acc.foldLeft(List[String](\"Yes\")){\n                                                    (acc, s) =>\n                                                        acc.foldLeft(List[String](\"No\")){\n                                                            (acc, s) =>\n                                                                acc.foldLeft(List[String](\"Yes\")){\n                                                                    (acc, s) =>\n                                                                        acc.foldLeft(List[String](\"No\")){\n                                                                            (acc, s) =>\n                                                                                acc.foldLeft(List[String](\"Yes\")){\n                                                                                    (acc, s) =>\n                                                                                        acc.foldLeft(List[String](\"No\")){\n                                                                                            (acc, s) =>\n                                                                                                acc.foldLeft(List[String](\"Yes\")){\n                                                                                                    (acc, s) =>\n                                                                                                        acc.foldLeft(List[String](\"No\")){\n                                                                                                            (acc, s) =>\n                                                                                                                acc.foldLeft(List[String](\"Yes\")){\n                                                                                                                    (acc, s) =>\n                                                                                                                        acc.foldLeft(List[String](\"No\")){\n                                                                                                                            (acc, s) =>\n                                                                                                                                acc.foldLeft(List[String](\"Yes\")){\n                                                                                                                                    (acc, s) =>\n                                                                                                                                        acc.foldLeft(List[String](\"No\")){\n                                                                                                                                            (acc, s) =>\n                                                                                                                                                acc.foldLeft(List[String](\"Yes\")){\n                                                                                                                                                    (acc, s) =>\n                                                                                                                                                        acc.foldLeft(List[String](\"No\")){\n                                                                                                                                                            (acc, s) =>\n                                                                                                                                                                acc.foldLeft(List[String](\"Yes\")){\n                                                                                                                                                                    (acc, s) =>\n                                                                                                                                                                        acc.foldLeft(List[String](\"No\")){\n                                                                                                                                                                            (acc, s) =>\n                                                                                                                                                                                acc.foldLeft(List[String](\"Yes\")){\n                                                                                                                                                                                    (acc, s) =>\n                                                                                                                                                                                        acc.foldLeft(List[String](\"No\")){\n                                                                                                                                                                                            (acc, s) =>\n                                                                                                                                                                                                acc.foldLeft(List[String](\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp0kqawlrm.scala:64:218 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m                                                                                                                                                                                                acc.foldLeft(List[\u001b[35mString\u001b[0m](\"\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                                                                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 unclosed string literal\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0kqawlrm.scala:82:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0kqawlrm.scala:79:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp0kqawlrm.scala:66:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m66 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979955
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val stack = mutable.Stack[String]()\n      var isGood = lst.forall(s => s == \"(\") || s == \"(\") // if any string in lst = \"(\"\n      if(!isGood) return \"No\" // if no string in lst is good, return \"No\"\n      for(s <- lst) stack push s // stack is a stack of string\n      while(stack.size > 0) yield {\n        val s = stack.pop\n        if(s == \"(\") stack.push s\n        else if(s == \"(\") stack.push s\n        else stack.pop\n      }.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9b2p1bw9.scala:19:56 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m      \u001b[33mvar\u001b[0m \u001b[36misGood\u001b[0m = lst.forall(\u001b[36ms\u001b[0m => s == \u001b[31m\"(\"\u001b[0m) || s == \u001b[31m\"(\"\u001b[0m) \u001b[34m// if any string in lst = \"(\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             '}' expected, but ')' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9b2p1bw9.scala:22:28 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m      \u001b[33mwhile\u001b[0m(stack.size > \u001b[31m0\u001b[0m) \u001b[33myield\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            'do' expected, but 'yield' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9b2p1bw9.scala:44:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9b2p1bw9.scala:18:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9b2p1bw9.scala:19:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m      \u001b[33mvar\u001b[0m \u001b[36misGood\u001b[0m = lst.forall(\u001b[36ms\u001b[0m => s == \u001b[31m\"(\"\u001b[0m) || s == \u001b[31m\"(\"\u001b[0m) \u001b[34m// if any string in lst = \"(\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Not found: s\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9b2p1bw9.scala:19:57 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m      \u001b[33mvar\u001b[0m \u001b[36misGood\u001b[0m = lst.forall(\u001b[36ms\u001b[0m => s == \u001b[31m\"(\"\u001b[0m) || s == \u001b[31m\"(\"\u001b[0m) \u001b[34m// if any string in lst = \"(\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ",
      "stdout": "",
      "timestamp": 1659979954
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if(lst.size < 2) \"No\" else lst.foldLeft(List[String]())((acc, item) =>\n            if(acc.isEmpty) acc.prepend(item)\n            if(acc.head.endsWith(item.head)) acc :+ item\n            else if(acc.head.startsWith(item.head)) acc :+ item\n            else \"No\"\n        )\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptbc69blj.scala:19:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mif\u001b[0m(acc.isEmpty) acc.prepend(item)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue prepend is not a member of List[String] - did you mean acc.prepended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptbc69blj.scala:20:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mif\u001b[0m(acc.head.endsWith(item.head)) acc :+ item\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    Char\n\u001b[31m   |\u001b[0m                                 Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptbc69blj.scala:21:45 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(acc.head.startsWith(item.head)) acc :+ item\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Found:    Char\n\u001b[31m   |\u001b[0m                                        Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptbc69blj.scala:22:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    (\u001b[32m\"No\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                 Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979955
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val len = lst.size\n        if (len == 0) \"No\"\n        else {\n            val first = lst(0)\n            val last = lst(len - 1)\n            val first1 = first.count('(')\n            val last1 = last.count(')')\n            if (first1 == last1) \"Yes\"\n            else matchParens(lst.drop(1).head :: lst)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfbv0j2dc.scala:23:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfirst1\u001b[0m = first.count(\u001b[31m'('\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (\u001b[31m'('\u001b[0m : Char)\n\u001b[31m   |\u001b[0m                                     Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfbv0j2dc.scala:24:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mlast1\u001b[0m = last.count(\u001b[31m')'\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    (\u001b[31m')'\u001b[0m : Char)\n\u001b[31m   |\u001b[0m                                   Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979954
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def hasOpen(lst: Seq[String]): Boolean = lst.exists { x => x == \"(\" }\n        def hasClose(lst: Seq[String]): Boolean = lst.exists { x => x == \")\" }\n        def makeGood(lst: Seq[String], index : Int) : Seq[String] = {\n            val subList = lst.drop(index).reverse.mkString(\"(\", \"|\", \")\")\n            if (hasOpen(lst) && hasClose(lst) && lst.size == index + 1) {\n                val newList = lst.reverse.mkString(\"(\", \"|\", \")\")\n                val nextList = lst(index + 1)\n                if (newList == nextList) {\n                    List(subList)\n                }\n                else {\n                    List()\n                }\n            }\n            else {\n                List()\n            }\n        }\n        val list = lst.sortBy(x => x).reverse.mkString(\"(\", \"|\", \")\")\n        if (list.contains(\"|\")) {\n            val newList = list.split(\"\\\\|\").map(_.trim)\n            if (hasOpen(newList) && hasClose(newList) && newList.size == 2) {\n                if (newList(1) == newList(2)) {\n                    makeGood(newList, 2)\n                }\n                else {\n                    makeGood(newList, 1)\n                }\n            }\n            else {\n                List()\n            }\n        }\n        else {\n            List()\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4jdegbzt.scala:26:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    List(subList)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    List[String]\n\u001b[31m   |\u001b[0m                    Required: collection.mutable.Seq[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4jdegbzt.scala:29:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    List()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    List[Nothing]\n\u001b[31m   |\u001b[0m                    Required: collection.mutable.Seq[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4jdegbzt.scala:33:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                List()\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    List[Nothing]\n\u001b[31m   |\u001b[0m                Required: collection.mutable.Seq[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4jdegbzt.scala:41:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                    makeGood(newList, \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    collection.mutable.Seq[String]\n\u001b[31m   |\u001b[0m                    Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4jdegbzt.scala:44:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m                    makeGood(newList, \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    collection.mutable.Seq[String]\n\u001b[31m   |\u001b[0m                    Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanati",
      "stdout": "",
      "timestamp": 1659979956
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Create an empty stack data structure.\n        val stack = mutable.Stack[List[String]]()\n        var index = 0\n        var isGoodString = true\n        val result: String = \"\"\n\n        while(index <= lst.size - 1){\n            val currParen = lst(index)\n            index += 1\n            val nextParen = lst(index)\n\n            if(currParen.equals(\"(\") && nextParen.equals(\")\")){\n                result += \"(\"\n                isGoodString = false\n                stack.push(List(currParen))\n                index += 1\n            }\n            else if(currParen.equals(\")\") && nextParen.equals(\"(\")){\n                result += \")\"\n                isGoodString = false\n                val pop = stack.pop()\n                if(pop.size == 1 && pop(0) == \")\"){\n                    result += \"(\"\n                }\n                else{\n                    isGoodString = true\n                }\n                index += 1\n            }\n            else if(currParen.equals(\"(\")){\n                stack.push(List(currParen))\n                index += 1\n            }\n            else if(currParen.equals(\")\")){\n                val pop = stack.pop()\n                if(pop.size == 1 && pop(0) == \"(\"){\n                    result += \"(\"\n                }\n                else{\n                    isGoodString = true\n                }\n                index += 1\n            }\n        }\n        if(isGoodString){\n            result\n        }\n        else{\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyi1lt557.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m]]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi1lt557.scala:30:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                result += \u001b[31m\"(\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean result.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi1lt557.scala:36:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                result += \u001b[31m\")\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean result.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi1lt557.scala:40:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                    result += \u001b[31m\"(\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean result.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi1lt557.scala:54:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m                    result += \u001b[31m\"(\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean result.!=?\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659979955
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val counts = lst.foldLeft(Map(\"()\" -> 1, \"(\" -> 1, \"[\" -> 1))((x, y) =>\n          x + (y.toDouble -> (y._1 + y._2))).toMap\n        (if (counts.get(\"()\") > counts.get(\"(\") && counts.get(\"(\") < counts.get(\"[\")) \n            \"Yes\" else \"No\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdlktwu5z.scala:19:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m          x + (y.toDouble -> (y._1 + y._2))).toMap\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value _1 is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdlktwu5z.scala:20:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        (\u001b[33mif\u001b[0m (counts.get(\u001b[31m\"()\"\u001b[0m) > counts.get(\u001b[31m\"(\"\u001b[0m) && counts.get(\u001b[31m\"(\"\u001b[0m) < counts.get(\u001b[31m\"[\"\u001b[0m)) \n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Option[Int], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Ordered.orderingToOrdered\n\u001b[31m   |\u001b[0m  import math.Ordering.Implicits.infixOrderingOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979955
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val result = new mutable.ListBuffer[String]()\n        val counts = lst.foldLeft(Map[String, Int]())((counts, s) => {\n            val chars = s.toCharArray\n            if (chars.size == 1) counts.put(s, chars.size)\n            else if (chars(0) != '(') counts.put(s, chars.size)\n            else counts + (s + (chars(0) - '(') + (if (chars(1) == '(') 1 else 0)))\n        })\n        counts.get(\"()\").toString.length == lst.length.toString match {\n            case true => \"Yes\"\n            case false => \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpr9kkk_kb.scala:23:82 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33melse\u001b[0m counts + (s + (chars(\u001b[31m0\u001b[0m) - \u001b[31m'('\u001b[0m) + (\u001b[33mif\u001b[0m (chars(\u001b[31m1\u001b[0m) == \u001b[31m'('\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             '}' expected, but ')' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpr9kkk_kb.scala:24:9 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        })\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0m         '}' expected, but ')' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpr9kkk_kb.scala:18:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr9kkk_kb.scala:21:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m (chars.size == \u001b[31m1\u001b[0m) counts.put(s, chars.size)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    Option[Int]\n\u001b[31m   |\u001b[0m                     Required: scala.collection.mutable.Map[String, Int]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr9kkk_kb.scala:22:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (chars(\u001b[31m0\u001b[0m) != \u001b[31m'('\u001b[0m) counts.put(s, chars.size)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    Option[Int]\n\u001b[31m   |\u001b[0m                     Required: scala.collection.mutable.Map[String, Int]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m lon",
      "stdout": "",
      "timestamp": 1659979955
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var list1 = lst.head\n        var list2 = lst.tail.head\n        var cnt = 0\n        var str = \"\"\n        while (list1 != null) {\n            if (list1.equals(\"(\")) {\n                cnt += 1\n            }\n            else {\n                cnt -= 1\n            }\n            list1 = list1(0)\n        }\n        cnt += 1\n        while (list2 != null) {\n            if (list2.equals(\"(\")) {\n                cnt += 1\n            }\n            else {\n                cnt -= 1\n            }\n            list2 = list2(0)\n        }\n        // If all parentheses are balanced return \"Yes\" else \"No\"\n        if (cnt == 0) {\n            return \"Yes\"\n        }\n        str = lst.head.head + \"(\" + lst.tail.head + \")\"\n        return str\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu9aj1hzj.scala:29:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            list1 = list1(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    Char\n\u001b[31m   |\u001b[0m                    Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu9aj1hzj.scala:39:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            list2 = list2(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    Char\n\u001b[31m   |\u001b[0m                    Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979955
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val res = \"\"\n        val stack = Stack(lst)\n        while(!stack.empty) {\n            val str = stack.pop()\n            if(!str.startsWith(\"(\"))\n                res += str\n            else if(!str.endsWith(\")\"))\n                res += str\n            else if(str.endsWith(\")\")) {\n                val str = str.substring(0, str.length - 1)\n                if(!stack.contains(str))\n                    res += str\n            }\n            else if(str.startsWith(\"(\")) {\n                val str = str.substring(1,str.length - 1)\n                if(!stack.contains(str))\n                    res += str\n            }\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwed8g1qg.scala:20:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mwhile\u001b[0m(!stack.empty) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue unary_! is not a member of scala.collection.mutable.Stack[List[String] @uncheckedVariance]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwed8g1qg.scala:23:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                res += str\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value += is not a member of String - did you mean res.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwed8g1qg.scala:25:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                res += str\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value += is not a member of String - did you mean res.!=?\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpwed8g1qg.scala:27:26 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mstr\u001b[0m = str.substring(\u001b[31m0\u001b[0m, str.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Recursive \u001b[33mvalue\u001b[0m \u001b[35mstr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwed8g1qg.scala:29:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    res += str\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value += is not a member of String - did you mean res.!=?\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpwed8g1qg.scala:32:26 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mstr\u001b[0m = str.substring(\u001b[31m1\u001b[0m,str.length - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Recursive \u001b[33mvalue\u001b[0m \u001b[35mstr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwed8g1qg.s",
      "stdout": "",
      "timestamp": 1659979955
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var res: String = \"No\"\n        var cnt = 0\n        var firstParens = 0\n        var lastParens = 0\n        for (str <- lst) {\n            val len = str.length\n            if (str == \")\")\n                lastParens = 0\n            else if (str == \"(\")\n                firstParens += 1\n            else if (str == \")(\")\n                lastParens += 1\n            else if (str == \"()\")\n                cnt += 1\n        }\n        val isGood = firstParens == lastParens && cnt == len\n        res = if (isGood) \"Yes\" else \"No\"\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg0aojfwd.scala:33:57 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misGood\u001b[0m = firstParens == lastParens && cnt == len\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                         Not found: len\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979949
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Convert string to List\n        // Remove parentheses\n        // Sort list\n        // If two elements are same, return \"Yes\"\n        // Else, return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0mgj9gw6.scala:17:51 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmatchParens\u001b[0m(\u001b[36mlst\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m]) : \u001b[35mString\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Found:    Unit\n\u001b[31m   |\u001b[0m                                                   Required: String\n\u001b[31m18 |\u001b[0m        \u001b[34m// Convert string to List\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[34m// Remove parentheses\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[34m// Sort list\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[34m// If two elements are same, return \"Yes\"\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[34m// Else, return \"No\"\u001b[0m\n\u001b[31m23 |\u001b[0m    }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979953
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val str = lst.head.head\n        val lst1 = lst.head.tail\n        val lst2 = lst.tail.head\n        val lst3 = lst.tail.tail\n        val len = lst.length\n        val goodStr = lst1.length == lst2.length && lst2.length == lst3.length\n        val goodLen = lst1.length == lst2.length && lst1.length == lst3.length\n        var i = 0\n        var j = 0\n        var res = \"\"\n        while (i < len && j < len) {\n            if (str == lst1(i)) {\n                i += 1\n                j += 1\n                val j = lst2.length\n                while (i < len && j < len) {\n                    if (str == lst2(i)) {\n                        i += 1\n                        j += 1\n                    } else if (str == lst3(i)) {\n                        i += 1\n                        j += 1\n                    } else {\n                        res = res + \"(\"\n                        i += 1\n                        j += 1\n                    }\n                }\n            } else {\n                res = res + \"(\"\n                i += 1\n            }\n        }\n        res + \"(\"\n        if (!goodStr) {\n            res = \"No\"\n        }\n        if (!goodLen) {\n            res = \"No\"\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz7klo882.scala:31:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                j += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean j.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz7klo882.scala:36:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                        j += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value += is not a member of Int - did you mean j.!=?\n\u001b[31m\u001b[31m-- Error: /tmp/tmpz7klo882.scala:37:31 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (str == lst3(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz7klo882.scala:39:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                        j += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value += is not a member of Int - did you mean j.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz7klo882.scala:43:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                        j += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value += is not a member of Int - did you mean j.!=?\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659979955
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // We need to keep track of the current and previous chars, since there are\n        // two types of opening character ( or ')\n        val current = \"(\"\n        var prev = \"\"\n        var string = \"\"\n        for (item <- lst) {\n            if(item == current) {\n                prev += current\n                string += current\n            } else if(item == prev) {\n                prev += item\n            } else {\n                string += prev + item\n            }\n            prev = \"\"\n        }\n        string += prev\n        return string\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_5xr2f_6.scala:38)\n\tat Problem.main(tmp_5xr2f_6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659979956
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val list1 = lst(0)\n        val list2 = lst(1)\n        val list3 = list1 ::: list2\n        val list4 = list3 ++ list2\n        if (list4.nonEmpty) {\n            val list5 = list4 ::: list1\n            val list6 = list1 ::: list5\n            if (list6.nonEmpty) {\n                val list7 = list6 ::: list3\n                val list8 = list3 ::: list7\n                if (list8.nonEmpty) {\n                    val list9 = list8 ::: list2\n                    if (list9.nonEmpty) {\n                        if (list1.nonEmpty && list2.nonEmpty) {\n                            val list10 = list9 ::: list1\n                            val list11 = list9 ::: list10\n                            if (list11.nonEmpty) {\n                                return \"Yes\"\n                            } else {\n                                return \"No\"\n                            }\n                        } else {\n                            return \"No\"\n                        }\n                    } else {\n                        return \"No\"\n                    }\n                } else {\n                    return \"No\"\n                }\n            } else {\n                return \"No\"\n            }\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppbmrv14k.scala:20:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist3\u001b[0m = list1 ::: list2\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value ::: is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppbmrv14k.scala:23:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mlist5\u001b[0m = list4 ::: list1\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value ::: is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppbmrv14k.scala:29:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    \u001b[33mval\u001b[0m \u001b[36mlist9\u001b[0m = list8 ::: list2\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value ::: is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppbmrv14k.scala:32:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                            \u001b[33mval\u001b[0m \u001b[36mlist10\u001b[0m = list9 ::: list1\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value ::: is not a member of String\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979955
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = new mutable.Stack[Int](2)\n        val lst2 = lst.map { x => { x -> 1 }; x -> 0 }.toMap\n        val lst3 = lst.map { x => { x -> -1 }; x -> 0 }.toMap\n        for (x <- 0 until lst.size) {\n            if (lst(x) == -1) stack += x\n            else if (!lst2.contains(x) || !lst3.contains(x)) stack += x\n        }\n        if (stack.size > 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4pwfvtyr.scala:18:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = \u001b[33mnew\u001b[0m mutable.Stack[\u001b[35mInt\u001b[0m](\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4pwfvtyr.scala:22:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (lst(x) == -\u001b[31m1\u001b[0m) stack += x\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         Values of types String and Int cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4pwfvtyr.scala:23:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (!lst2.contains(x) || !lst3.contains(x)) stack += x\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    (x : Int)\n\u001b[31m   |\u001b[0m                                    Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4pwfvtyr.scala:23:57 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (!lst2.contains(x) || !lst3.contains(x)) stack += x\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                     Found:    (x : Int)\n\u001b[31m   |\u001b[0m                                                     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979956
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var stack = lst.head\n        var isTrue = true\n        var i = 0\n        while (i < lst.length) {\n            if (lst(i).startsWith(\"(\")) {\n                if (lst(i).startsWith(\"(\"))\n                    stack += \"(\"\n                else\n                    stack += \")\"\n            } else {\n                if (lst(i).startsWith(\")\"))\n                    stack += \")\"\n                else {\n                    if (!stack.startsWith(\"(\"))\n                        isTrue = false\n                    else\n                        stack = \"\"\n                }\n            }\n            i += 1\n        }\n        if (isTrue)\n            \"Yes\"\n        else\n            \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpki7bwn0n.scala:46)\n\tat Problem.main(tmpki7bwn0n.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659979956
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val rem = lst\n        var stack = new Stack[String]\n        var count = 0\n        val good = mutable.ListBuffer.empty[String]\n        rem.foreach(s => if (s.startsWith(\"(\") || s.startsWith(\")\")) stack += s)\n        while (stack.nonEmpty) {\n            val s = stack.pop\n            if (s.endsWith(\"(\")) count += 1\n            if (s.endsWith(\")\")) count -= 1\n            if (count < 0) good.append(\"No\")\n            else if (count == 0) good.append(\"Yes\")\n            else good.append(s)\n        }\n        good.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8ge8l66b.scala:21:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979959
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // TODO\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpziz7h0mx.scala:17:51 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmatchParens\u001b[0m(\u001b[36mlst\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m]) : \u001b[35mString\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Found:    Unit\n\u001b[31m   |\u001b[0m                                                   Required: String\n\u001b[31m18 |\u001b[0m        \u001b[34m// TODO\u001b[0m\n\u001b[31m19 |\u001b[0m    }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979964
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        //your code\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcdunqmg7.scala:17:51 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmatchParens\u001b[0m(\u001b[36mlst\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m]) : \u001b[35mString\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Found:    Unit\n\u001b[31m   |\u001b[0m                                                   Required: String\n\u001b[31m18 |\u001b[0m        \u001b[34m//your code\u001b[0m\n\u001b[31m19 |\u001b[0m    }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979965
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        //  TODO\n        var res: String = \"No\"\n        val lst1: mutable.List[String] = lst._1.asInstanceOf[mutable.List[String]]\n        val lst2: mutable.List[String] = lst._2.asInstanceOf[mutable.List[String]]\n        if (lst1.size != lst2.size) {\n            res = \"No\"\n        }\n        else {\n            for (i <- 0 until lst1.size) {\n                if ((lst1(i).charAt(0) == '(') && (lst2(i).charAt(0) == ')')) {\n                    if (lst1(i).charAt(lst1(i).length - 1) == ')') {\n                        val tempStr: String = \"()\" + lst1(i).substring(1)\n                        val resStr: String = \"Yes\"\n                        val resArr: List[String] = resStr.split(\"\\\\W+\").toList.filter(s => s.nonEmpty)\n                        if (resArr.size == 2) {\n                            val tempArr: List[String] = tempStr.split(\"\\\\W+\").toList.filter(s => s.nonEmpty)\n                            val list: List[String] = lst2.asInstanceOf[List[String]]\n                            val lst: mutable.List[String] = lst2.asInstanceOf[mutable.List[String]]\n                            for (b <- 0 until list.size) {\n                                if (lst(b).charAt(0) == '(' && tempArr(b).charAt(0) == ')') {\n                                    if (lst(b).charAt(lst(b).length - 1) == ')' && lst(b).substring(1) == list(b)) {\n                                        resStr = \"Yes\"\n                                        resArr(0) = tempStr\n                                    }\n                                }\n                            }\n                            res = resStr\n                        }\n                    }\n                }\n            }\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg3t8qc3i.scala:20:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlst1\u001b[0m: mutable.List[\u001b[35mString\u001b[0m] = lst._1.asInstanceOf[mutable.List[\u001b[35mString\u001b[0m]]\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg3t8qc3i.scala:20:61 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlst1\u001b[0m: mutable.List[\u001b[35mString\u001b[0m] = lst._1.asInstanceOf[mutable.List[\u001b[35mString\u001b[0m]]\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg3t8qc3i.scala:20:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlst1\u001b[0m: mutable.List[\u001b[35mString\u001b[0m] = lst._1.asInstanceOf[mutable.List[\u001b[35mString\u001b[0m]]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value _1 is not a member of List[String]\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg3t8qc3i.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlst2\u001b[0m: mutable.List[\u001b[35mString\u001b[0m] = lst._2.asInstanceOf[mutable.List[\u001b[35mString\u001b[0m]]\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg3t8qc3i.scala:21:61 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlst2\u001b[0m: mutable.List[\u001b[35mString\u001b[0m] = lst._2.asInstanceOf[mutable.List[\u001b[35mString\u001b[0m]]\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^^^^^^^\u001b[0m\n\u001b[31m   |",
      "stdout": "",
      "timestamp": 1659979967
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Write your code here\n        val stack = Stack[String]()\n        val str = lst(0) \n        for(x <- str){\n            if(x ==\"(\") stack += \"(\"\n            else if(x==\")\") stack += \")\"\n            else\n            if(!stack.isEmpty){\n                val check = stack.pop()\n                if(check != \"(\") \n                if(check != \")\"){\n                    return \"No\"\n                }\n            }\n        }\n        if(stack.isEmpty) \n            return \"Yes\"\n        else \n            return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpq48a_n_m.scala:22:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m(x ==\u001b[31m\"(\"\u001b[0m) stack += \u001b[31m\"(\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpq48a_n_m.scala:23:20 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(x==\u001b[31m\")\"\u001b[0m) stack += \u001b[31m\")\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979967
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        //Using Regular expressions\n        val open = \"\\\\(|\\\\)|\\\\|\"\n        val close = \"\\\\(|\\\\)\"\n        val balance = \"[\" + open + close.r.replaceAllIn(open, \"\") + \"]\"\n        val regexp = s\"\"\"^$balance+$balance+$balance+$balance$\"\"\"\n        val str = lst(0) + lst(1)\n        if (!str.matches(regexp)) {\n            \"No\"\n        }\n        else if (!lst.size == 2) {\n            \"No\"\n        }\n        else {\n            \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp0tqfh9ph.scala:22:61 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mregexp\u001b[0m = \u001b[31ms\"\"\"^\u001b[0m$balance\u001b[31m+\u001b[0m$balance\u001b[31m+\u001b[0m$balance\u001b[31m+\u001b[0m$balance$\"\"\"\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      unclosed multi-line string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmp0tqfh9ph.scala:50:0 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0munclosed multi-line string literal\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979962
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val parensStack = new Stack[Int]()\n        var result = \"No\"\n        lst.foreach(x => {\n            if (x.toString.contains(\"(\")) {\n                parensStack.push(1)\n            }\n            else if (x.toString.contains(\")\")) {\n                val poppedCount = parensStack.pop()\n                if (poppedCount > 1) {\n                    result == \"Yes\"\n                }\n                else {\n                    result == \"No\"\n                }\n            }\n        })\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp3_znmp4c.scala:37)\n\tat Problem.main(tmp3_znmp4c.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659979967
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if(lst.size > 2) false\n        else if(lst.size == 2) true\n        else lst.foldLeft(true) { (res, elem) =>\n            if(elem == \"(\")\n            res = res && matchParens(lst.take(2) ++ lst.takeRight(2).reverse)\n            else\n            res = res && matchParens(lst.drop(1) ++ lst.takeRight(2).reverse)\n            res\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpaucafpwx.scala:18:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m(lst.size > \u001b[31m2\u001b[0m) \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (\u001b[31mfalse\u001b[0m : Boolean)\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpaucafpwx.scala:19:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(lst.size == \u001b[31m2\u001b[0m) \u001b[31mtrue\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (\u001b[31mtrue\u001b[0m : Boolean)\n\u001b[31m   |\u001b[0m                               Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpaucafpwx.scala:22:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            res = res && matchParens(lst.take(\u001b[31m2\u001b[0m) ++ lst.takeRight(\u001b[31m2\u001b[0m).reverse)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    String\n\u001b[31m   |\u001b[0m                         Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpaucafpwx.scala:24:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            res = res && matchParens(lst.drop(\u001b[31m1\u001b[0m) ++ lst.takeRight(\u001b[31m2\u001b[0m).reverse)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    String\n\u001b[31m   |\u001b[0m                         Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979967
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val countParens = lst.count(_.matches(\"\\\\(.*\\\\)\")) / lst.count\n        val string = \"Yes\"\n        val string2 = \"No\"\n        \n        if(countParens == 1)\n        {\n            if(lst(0)(0) == \"(\" || lst(0)(lst(0).length-1) == \"(\")\n                string2 = \"Yes\"\n            else\n                string = \"Yes\"\n        }\n        else if(countParens == 0)\n            string = \"No\"\n        else\n            string = \"Yes\"\n            \n        return string\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpnxp97h1f.scala:18:59 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcountParens\u001b[0m = lst.count(_.matches(\u001b[31m\"\\\\(.*\\\\)\"\u001b[0m)) / lst.count\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m/\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Double\n\u001b[31m   |\u001b[0m  (x: Float): Float\n\u001b[31m   |\u001b[0m  (x: Long): Long\n\u001b[31m   |\u001b[0m  (x: Int): Int\n\u001b[31m   |\u001b[0m  (x: Char): Int\n\u001b[31m   |\u001b[0m  (x: Short): Int\n\u001b[31m   |\u001b[0m  (x: Byte): Int\n\u001b[31m   |\u001b[0m match arguments ((String => Boolean) => Int)\n\u001b[31m\u001b[31m-- Error: /tmp/tmpnxp97h1f.scala:24:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m(lst(\u001b[31m0\u001b[0m)(\u001b[31m0\u001b[0m) == \u001b[31m\"(\"\u001b[0m || lst(\u001b[31m0\u001b[0m)(lst(\u001b[31m0\u001b[0m).length-\u001b[31m1\u001b[0m) == \u001b[31m\"(\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpnxp97h1f.scala:24:35 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m(lst(\u001b[31m0\u001b[0m)(\u001b[31m0\u001b[0m) == \u001b[31m\"(\"\u001b[0m || lst(\u001b[31m0\u001b[0m)(lst(\u001b[31m0\u001b[0m).length-\u001b[31m1\u001b[0m) == \u001b[31m\"(\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpnxp97h1f.scala:25:24 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                string2 = \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val string2\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpnxp97h1f.scala:27:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                string = \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^",
      "stdout": "",
      "timestamp": 1659979966
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val stack = mutable.Stack[String]()\n      val str = lst.head\n      if (str == \"()\") {\n        stack += \"(\"\n      } else if (str == \")\") {\n        val current = stack.pop()\n        if (current == \"\") {\n          return \"No\"\n        } else {\n          stack += \")\"\n        }\n      } else if (str.startsWith(\"(\")) {\n        stack += str\n      } else if (str.endsWith(\")\")) {\n        val current = stack.pop()\n        if (current == \"\") {\n          return \"No\"\n        } else {\n          stack += str\n        }\n      }\n      return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7tg62_za.scala:18:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979962
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val set = new mutable.HashSet[String]()\n        lst.foreach(x => x.split(\"\\\\(\").foreach(x => set.add(x)))\n        if(set.size == 2) {\n            val lst1 = lst(0).get.split(\"\\\\)\")\n            val lst2 = lst(1).get.split(\"\\\\)\")\n            if(lst1.length == lst2.length) {\n                if(lst1(0) == \"(\" && lst1(1) == \"(\" && lst2(0) == \")\" && lst2(1) == \")\") {\n                    return \"Yes\"\n                }\n            }\n        }\n        \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpce_5y_zd.scala:18:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mset\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashSet[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpce_5y_zd.scala:21:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mlst1\u001b[0m = lst(\u001b[31m0\u001b[0m).get.split(\u001b[31m\"\\\\)\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value get is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpce_5y_zd.scala:22:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mlst2\u001b[0m = lst(\u001b[31m1\u001b[0m).get.split(\u001b[31m\"\\\\)\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value get is not a member of String\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979967
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        lst.foreach(x => {\n            if (x == \"(\") stack += x\n            else if (!stack.isEmpty && stack.head == x) stack.pop()\n            else if (!stack.isEmpty && stack.head == \"(\") stack.pop()\n            else stack\n        })\n        val str = stack.mkString\n        val newStack = if (str.startsWith(\"()\") && !stack.isEmpty && stack.head == \"(\") stack.pop else stack\n        val newStr = stack.mkString\n        if (newStr.length < str.length && newStr.isEmpty || newStr.length == str.length && !newStack.isEmpty && newStack.head == \"(\") newStack.pop()\n        else if (!newStr.isEmpty && newStr.head != \"(\") newStack\n        else newStr\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxvgplbon.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979962
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if(lst.size == 0) \"No\"\n        else if(lst.head.length == 1 && !lst.head.contains(\"(\") && !lst.head.contains(\")\")) lst.head + lst.head\n        else lst.head + matchParens(lst.tail)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpevdrxm5y.scala:23)\n\tat Problem.main(tmpevdrxm5y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659979967
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val res = (lst.foldLeft(false)((acc, x) => acc || balance(acc, x)) && acc )\n        res  match {\n            case true => \"Yes\"\n            case false => \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9_sx_g8s.scala:18:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = (lst.foldLeft(\u001b[31mfalse\u001b[0m)((\u001b[36macc\u001b[0m, \u001b[36mx\u001b[0m) => acc || balance(acc, x)) && acc )\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                      Not found: balance\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9_sx_g8s.scala:18:78 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = (lst.foldLeft(\u001b[31mfalse\u001b[0m)((\u001b[36macc\u001b[0m, \u001b[36mx\u001b[0m) => acc || balance(acc, x)) && acc )\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Not found: acc\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979963
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Use Stack to store the state of the current parentheses\n        var stack = Stack.empty[List[String]]\n        var result = \"\"\n        lst.foreach(x => {\n            if (x == \"(\") {\n                if (stack.isEmpty) {\n                    stack.push Nil\n                } else {\n                    stack.head::stack.last\n                }\n            } else if (x == \")\") {\n                if (stack.isEmpty) {\n                    result += x\n                } else {\n                    stack.pop\n                }\n            } else {\n                stack += x\n            }\n        })\n        if (stack.isEmpty) {\n            result\n        } else {\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpb98b3w1g.scala:24:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                    stack.push Nil\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpb98b3w1g.scala:24:26 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                    stack.push Nil\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mpush\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mStack\u001b[0m with types\n\u001b[31m   |\u001b[0m (elem1: List[String], elem2: List[String], elems: List[String]*): \n\u001b[31m   |\u001b[0m  scala.collection.mutable.Stack[List[String]]\n\u001b[31m   |\u001b[0m (elem: List[String]): scala.collection.mutable.Stack[List[String]]\n\u001b[31m   |\u001b[0mmatch expected type ?{ Nil: ? }\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb98b3w1g.scala:35:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                stack += x\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (x : String)\n\u001b[31m   |\u001b[0m                         Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979967
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var index = 0\n        while (index < lst.length) {\n            val stringStart = lst(index).length\n            var stringEnd = stringStart + 1\n            var leftCount = 0\n            var rightCount = 0\n            var nextLeft = 0\n            var nextRight = 0\n            var nextStringStart = 0\n            while (nextRight < stringEnd) {\n                nextRight = nextRight + 1\n                rightCount = rightCount + 1\n                if (nextRight < stringEnd) {\n                    nextRight = nextRight + 1\n                }\n            }\n            while (nextLeft < stringEnd) {\n                nextLeft = nextLeft + 1\n                leftCount = leftCount + 1\n                if (nextLeft < stringEnd) {\n                    nextLeft = nextLeft + 1\n                }\n            }\n            if (leftCount == rightCount) {\n                var nextStringEnd = 0\n                while (nextStringStart < stringEnd) {\n                    nextStringEnd = nextStringEnd + 1\n                    nextStringStart = nextStringStart + 1\n                }\n                nextStringEnd = nextStringEnd + 1\n                if (nextStringStart < stringEnd) {\n                    if (nextStringStart < nextRight) {\n                        if ((nextLeft < stringEnd) && (nextRight < stringEnd)) {\n                            if (lst(index).charAt(nextStringStart) == '(') {\n                                nextLeft = nextLeft + 1\n                            } else {\n                                nextRight = nextRight + 1\n                            }\n                        } else {\n                            if (nextLeft < stringEnd) {\n                                nextRight = nextRight + 1\n                            }\n                        }\n                    }\n                } else {\n                    if (nextRight < stringEnd) {\n                        nextLeft = nextLeft + 1\n                    }\n                }\n                if (nextLeft < stringEnd) {\n                    return \"Yes\"\n                } else {\n                    return \"No\"\n                }\n            }\n            index = index + 1\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp4s8orybn.scala:78)\n\tat Problem.main(tmp4s8orybn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659979967
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val l = new mutable.HashSet[String](lst.head)\n        val r = new mutable.HashSet[String](lst.tail.head)\n        l.foreach { x => r.add (x) }\n        if (l.size == r.size) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps3zbasv5.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashSet[\u001b[35mString\u001b[0m](lst.head)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps3zbasv5.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mr\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashSet[\u001b[35mString\u001b[0m](lst.tail.head)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979962
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = new mutable.Stack[String]()\n        val res = \"Yes\"\n        for (str <- lst) {\n            if (str.contains(\"(\") && stack.nonEmpty) {\n                stack.push(str)\n            } else if (str.contains(\")\") && stack.nonEmpty) {\n                if (!stack.isEmpty) {\n                    stack.peek match {\n                        case \"(\" =>\n                            stack.push(str)\n                        case \")\" =>\n                            if (stack.pop() == \"(\") {\n                                res = \"No\"\n                            } else {\n                                res = \"Yes\"\n                            }\n                    }\n                }\n            }\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptpu7m2bp.scala:18:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = \u001b[33mnew\u001b[0m mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmptpu7m2bp.scala:30:36 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                                res = \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Reassignment to val res\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmptpu7m2bp.scala:32:36 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                                res = \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Reassignment to val res\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979963
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty) List(\"No\")\n        else {\n            val first = lst(0)\n            val rest = lst.drop(1)\n            var stack = new Stack[(Int, List[String])]\n            stack.push((0, List()))\n            while (stack.size > 0 && !stack.isEmpty) {\n                val index = stack.pop()\n                val sub = sublist(index, first, rest)\n                if (sub.size() > 0) {\n                    val newIndex = index + 1\n                    val subSub = sublist(newIndex, first, rest)\n                    val newStack = stack.map{\n                        case (index, _) => if (index == newIndex) sub.head else (_, _) }\n                    val newSub = subSub ++ sub.tail\n                    stack.push((newIndex, newSub))\n                } else {\n                    if (index == newIndex) sub.head else \"No\"\n                }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8ngzesot.scala:18:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty) List(\u001b[31m\"No\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mString\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8ngzesot.scala:26:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36msub\u001b[0m = sublist(index, first, rest)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: sublist\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8ngzesot.scala:28:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    \u001b[33mval\u001b[0m \u001b[36mnewIndex\u001b[0m = index + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of (Int, List[String]), but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8ngzesot.scala:29:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    \u001b[33mval\u001b[0m \u001b[36msubSub\u001b[0m = sublist(newIndex, first, rest)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: sublist\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp8ngzesot.scala:31:81 -----------------------------\u001b[0m\u001b[0m\n\u001b",
      "stdout": "",
      "timestamp": 1659979968
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val strList = lst.flatten.toList\n        var open = 0\n        var close = 0\n        var sum = 0\n        for (str <- strList) {\n            if (str == \")\")\n                close += 1\n            if (str == \"(\")\n                open += 1\n            sum += open\n            sum += close\n        }\n        if (sum == strList.size)\n            return \"Yes\"\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpyla707o5.scala:23:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (str == \u001b[31m\")\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpyla707o5.scala:25:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (str == \u001b[31m\"(\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979968
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = new mutable.Stack[String]()\n        var curr : String = \"\"\n        for (aString <- lst) {\n            if (aString.contains(\"(\")) {\n                stack.push(aString)\n            }\n            if (aString.contains(\")\")) {\n                curr = stack.pop()\n                if (curr.length != (aString.length + 1))\n                    return \"No\"\n            }\n        }\n        if (stack.isEmpty)\n            return \"Yes\"\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd8nwfvmm.scala:18:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = \u001b[33mnew\u001b[0m mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979963
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        lst.foldLeft(\"\"){(str, s) =>\n            val (count, i) = str.length match {\n                case 0 => (0, s)\n                case count => count + (s.charAt(i) == ')')\n            }\n            if (count > 0) str + s.subList(0, i) + \"Yes\"\n            else \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1lw6180g.scala:19:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m (count, i) = str.length \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35m$1$\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp1lw6180g.scala:21:36 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                \u001b[33mcase\u001b[0m count => count + (s.charAt(i) == \u001b[31m')'\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m+\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Double\n\u001b[31m   |\u001b[0m  (x: Float): Float\n\u001b[31m   |\u001b[0m  (x: Long): Long\n\u001b[31m   |\u001b[0m  (x: Int): Int\n\u001b[31m   |\u001b[0m  (x: Char): Int\n\u001b[31m   |\u001b[0m  (x: Short): Int\n\u001b[31m   |\u001b[0m  (x: Byte): Int\n\u001b[31m   |\u001b[0m  (x: String): String\n\u001b[31m   |\u001b[0m match arguments (Boolean)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1lw6180g.scala:23:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (count > \u001b[31m0\u001b[0m) str + s.subList(\u001b[31m0\u001b[0m, i) + \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value subList is not a member of String\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979967
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // (1) create two empty lists to store open and close parens\n        var openParens = ListBuffer.empty[String]\n        var closeParens = ListBuffer.empty[String]\n        for (elem <- lst) {\n            // (2) append opening parens to the open list\n            openParens append elem\n            // (3) append closing parens to the close list\n            closeParens append elem\n        }\n        // (4) check the parentheses match\n        var flag = true\n        for (elem <- closeParens) {\n            if ((closeParens contains elem)) {\n                flag = flag && ((openParens contains elem))\n            }\n        }\n        if (closeParens.length != openParens.length) {\n            flag = false\n        }\n        if (closeParens.size != openParens.size) {\n            flag = false\n        }\n        if (flag) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpu56uuyhh.scala:48)\n\tat Problem.main(tmpu56uuyhh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659979968
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val s = lst.foldLeft(\"(\", \"(\") {\n            (acc, curr) =>\n                curr.head == \"(\" ? acc + \" \" + curr : curr\n        }\n        (s.endsWith(\" \")) ? s\"${s}.\" : s\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzkvr4ree.scala:20:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                curr.head == \u001b[31m\"(\"\u001b[0m ? acc + \u001b[31m\" \"\u001b[0m + curr : \u001b[35mcurr\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Not found: type curr\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzkvr4ree.scala:20:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                curr.head == \u001b[31m\"(\"\u001b[0m ? acc + \u001b[31m\" \"\u001b[0m + curr : \u001b[35mcurr\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value ? is not a member of String\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzkvr4ree.scala:22:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        (s.endsWith(\u001b[31m\" \"\u001b[0m)) ? \u001b[31ms\"\u001b[0m${s}\u001b[31m.\"\u001b[0m : \u001b[35ms\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type s\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzkvr4ree.scala:22:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        (s.endsWith(\u001b[31m\" \"\u001b[0m)) ? \u001b[31ms\"\u001b[0m${s}\u001b[31m.\"\u001b[0m : \u001b[35ms\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m         ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         value endsWith is not a member of (String, String)\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979971
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty) \"\"\n        val newList = new mutable.Stack[String]\n        newList.toList foreach { x =>\n            if (lst(0) != x) (newList.push(x): Unit)\n        }\n        if (newList.isEmpty) \"\"\n        else {\n            val lst2 = newList.toList mkString \"(\"\n            val lst3 = lst.filterNot(x => x == lst2).mkString(\"(\", \"(\", \")\", \")\")\n            val lst4 = lst2.reverse.mkString(\"(\", \")\")\n            lst4 match{\n                case x if x != \"\" => lst3\n                case x => \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnzn2j4si.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = \u001b[33mnew\u001b[0m mutable.Stack[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnzn2j4si.scala:26:62 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mlst3\u001b[0m = lst.filterNot(\u001b[36mx\u001b[0m => x == lst2).mkString(\u001b[31m\"(\"\u001b[0m, \u001b[31m\"(\"\u001b[0m, \u001b[31m\")\"\u001b[0m, \u001b[31m\")\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                              ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (String, String, String, String)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnzn2j4si.scala:29:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                \u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m x != \u001b[31m\"\"\u001b[0m => lst3\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (lst3 : Char)\n\u001b[31m   |\u001b[0m                                     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmpnzn2j4si.scala:18:25 ----------------\u001b[0m\u001b[0m\n\u001b[33m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty) \u001b[31m\"\"\u001b[0m\n\u001b[33m\u001b[33m   |\u001b[0m                         ^^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression does nothing in statement position; you may be omitting necessary parentheses\n\u001b[33m   |\u001b[0m\n\u001b[33m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 warning found\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979975
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Convert '()' into '(', and convert '()()' into '(())'\n        val ls = lst.map( s => if(s == '(') '(' else '(' else ')'))\n        // Find the '(()' pair\n        val pair = ls.find( s => s == '(()')\n        // If there's no pair, return No\n        if(pair == None) return \"No\"\n        // If there's a pair, find the matching ')' by index\n        val p = pair.index match {\n            case 0 => \"(()\"\n            case 1 => \")\"\n            case _ => ls(pair.length - 1) // or ls(pair.length - 2)\n        }\n        // If there's no matching ')', return No\n        if(p != \"(\") return \"No\"\n        // If there's a matching ')', find matching '(()' by index\n        val pair1 = ls.find( s => s == \")\")\n        val p1 = pair1.index match {\n            case 0 => \"(())\"\n            case 1 => \")\"\n            case _ => ls(pair1.length - 1)\n        }\n        // If there's no '(())', return 'No'\n        if(p1 != p) return \"No\"\n        // Otherwise, return 'Yes'\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp509u5qj4.scala:19:57 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mls\u001b[0m = lst.map( \u001b[36ms\u001b[0m => \u001b[33mif\u001b[0m(s == \u001b[31m'('\u001b[0m) \u001b[31m'('\u001b[0m \u001b[33melse\u001b[0m \u001b[31m'('\u001b[0m \u001b[33melse\u001b[0m \u001b[31m')'\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                          ')' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp509u5qj4.scala:19:66 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mls\u001b[0m = lst.map( \u001b[36ms\u001b[0m => \u001b[33mif\u001b[0m(s == \u001b[31m'('\u001b[0m) \u001b[31m'('\u001b[0m \u001b[33melse\u001b[0m \u001b[31m'('\u001b[0m \u001b[33melse\u001b[0m \u001b[31m')'\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             '}' expected, but ')' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp509u5qj4.scala:21:38 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpair\u001b[0m = ls.find( \u001b[36ms\u001b[0m => s == '(()')\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      unclosed character literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmp509u5qj4.scala:21:42 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpair\u001b[0m = ls.find( \u001b[36ms\u001b[0m => s == '(()')\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          unclosed character literal\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp509u5qj4.scala:59:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp509u5qj4.scala:19:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mls\u001b[0m = lst.map( \u001b[36ms\u001b[0m => \u001b[33mif\u001b[0m(s == \u001b[31m'('\u001b[0m) \u001b[31m'('\u001b[0m \u001b[33melse\u001b[0m \u001b[31m'('\u001b[0m \u001b[33melse\u001b[0m \u001b[31m')'\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^",
      "stdout": "",
      "timestamp": 1659979973
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = new mutable.Stack[String]\n        val result = \"No\"\n        lst.foreach {\n            case x => (x match {\n                case \")\" => stack.push(x)\n                case \"))\" => stack.push(x)\n                case \")(\" => stack.push(x)\n                case \")()\" => stack.pop()\n                case \")(\" => stack.pop()\n                case \"))\" => stack.pop()\n                case _ => stack.pop()\n            })\n        }\n        if (stack.size == 0) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb76q4an8.scala:18:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = \u001b[33mnew\u001b[0m mutable.Stack[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979970
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val map = mutable.Map[String, Boolean]()\n        lst.foreach(x => {\n            if (x.startsWith(\"(\") || x.startsWith(\")\")){\n                if (!map.contains(x)){\n                    map.put(x.substring(1), true)\n                }\n                if (!map.contains(x.substring(1))){\n                    stack.push(x)\n                }\n            }\n        })\n        stack.foreach(x => {\n            map.put(x, false)\n        })\n        val answer = stack.foldRight(true){ (x, y) =>\n            if (y && !x)\n                y\n            else\n                x\n        }\n        if (answer){\n            \"Yes\"\n        }\n        else{\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp43flffsc.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp43flffsc.scala:19:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmap\u001b[0m = mutable.Map[\u001b[35mString\u001b[0m, \u001b[35mBoolean\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979970
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      def infixToPostfix(infixList : List[String]) =\n        infixList.foldLeft(\"\") { (result, x) => result + x.reverse.mkString(\"(\") + \")\" }.trim\n\n      def matching(curr : String, nextList : List[String], result : String) : String = {\n        if (next == \"\") {\n          result\n        } else if (next == curr) {\n          matching(infixToPostfix(nextList), nextList.tail, result + curr)\n        } else {\n          matching(infixToPostfix(nextList), nextList.tail, result)\n        }\n      }\n\n      def matching(infixList : List[String], result : String) : String = {\n        if (infixList.isEmpty) {\n          result\n        } else {\n          matching(infixList.head, infixList.tail, result)\n        }\n      }\n\n      infixToPostfix(lst.head)\n      matching(\"\", lst.tail, \"Yes\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpyh592u7h.scala:31:10 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m      \u001b[33mdef\u001b[0m \u001b[36mmatching\u001b[0m(\u001b[36minfixList\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m], \u001b[36mresult\u001b[0m : \u001b[35mString\u001b[0m) : \u001b[35mString\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m      ^\u001b[0m\n\u001b[31m   |\u001b[0mmatching is already defined as \u001b[33mmethod\u001b[0m \u001b[35mmatching\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m32 |\u001b[0m        \u001b[33mif\u001b[0m (infixList.isEmpty) {\n\u001b[31m33 |\u001b[0m          result\n\u001b[31m34 |\u001b[0m        } \u001b[33melse\u001b[0m {\n\u001b[31m35 |\u001b[0m          matching(infixList.head, infixList.tail, result)\n\u001b[31m36 |\u001b[0m        }\n\u001b[31m37 |\u001b[0m      }\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyh592u7h.scala:22:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mif\u001b[0m (next == \u001b[31m\"\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Not found: next\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyh592u7h.scala:24:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (next == curr) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: next\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyh592u7h.scala:39:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m      infixToPostfix(lst.head)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    String\n\u001b[31m   |\u001b[0m                     Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mString\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979975
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val newlst = lst.map(x => if (x == \"(\") 1 else 0)\n      val n = newlst.head\n      val m = newlst.last\n      if (n != m)\n        \"No\"\n      else if (n == 0)\n        \"Yes\"\n      else if (n == 1)\n        \"Yes\"\n      else\n        matchParens(newlst.tail)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcmgghq2_.scala:28:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        matchParens(newlst.tail)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    List[Int @uncheckedVariance]\n\u001b[31m   |\u001b[0m                    Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979975
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val arr = lst.map(x => x.toChar)\n        val lefts = arr.takeWhile(x => x == '(').length\n        val rights = arr.dropWhile(x => x == '(').length\n        val balanced = (lefts == rights)\n        if(balanced){\n            val arr = lst.map(x => x.toChar)\n            val lefts = arr.takeWhile(x => x == '(').length\n            val rights = arr.dropWhile(x => x == '(').length\n            if(lefts == rights){\n                val str = \"()\" + lst(0) + \"()\"\n                if( arr.map(_.toInt).toSet.subsetOf(str.toSet) ){\n                    \"Yes\"\n                }else{\n                    \"No\"\n                }\n            }else{\n                \"No\"\n            }\n        }else{\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbb3ry3z8.scala:18:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = lst.map(\u001b[36mx\u001b[0m => x.toChar)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value toChar is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbb3ry3z8.scala:23:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = lst.map(\u001b[36mx\u001b[0m => x.toChar)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value toChar is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbb3ry3z8.scala:28:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33mif\u001b[0m( arr.map(_.toInt).toSet.subsetOf(str.toSet) ){\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toInt is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979978
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Iterate over the list\n        val set = mutable.Set[String]()\n        for(i <- lst.indices) {\n            val str = lst(i + 1)\n            if(!set.isEmpty) {\n                // We can't concatenate if it's not empty\n                return \"No\"\n            }\n            if(!str.contains(\"(\")) {\n                // String doesn't contain open\n                return \"No\"\n            }\n            if(!str.contains(\")\")) {\n                // String doesn't contain close\n                return \"No\"\n            }\n            if(str == \"()\") {\n                // String contains open and close\n                set.add(lst(i))\n            }\n        }\n\n        // If we reach here, then string concatenation can be done.\n        val result = \"Yes\"\n        for(i <- 0 until set.size) {\n            result += \"(\" + set.apply(i) + \")\"\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpji3si0wt.scala:19:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mset\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpji3si0wt.scala:43:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            result += \u001b[31m\"(\"\u001b[0m + set.apply(i) + \u001b[31m\")\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean result.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979975
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        stack.push(\"(\")\n        val result = \"\"\n        for(i <- 0 until lst.length) {\n            if(lst(i) == \"(\") {\n                stack.push(\"(\")\n            }\n            else if(lst(i) == \")\") {\n                if(stack.nonEmpty) {\n                    val tmp = \"\"\n                    for(j <- 0 until stack.size) {\n                        tmp += stack.pop(j)\n                    }\n                    result += tmp\n                }\n                stack.pop()\n            }\n            else if(stack.nonEmpty) {\n                stack.push(lst(i))\n            }\n            else if(lst(i) != \")\") {\n                return \"No\"\n            }\n        }\n        stack.clear\n        result == \"(\" + result + \")\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp45vo79xz.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp45vo79xz.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                        tmp += stack.pop(j)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value += is not a member of String - did you mean tmp.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp45vo79xz.scala:31:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    result += tmp\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean result.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp45vo79xz.scala:43:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        result == \u001b[31m\"(\"\u001b[0m + result + \u001b[31m\")\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Boolean\n\u001b[31m   |\u001b[0m        Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979977
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // get all parentheses in lst\n        val (opens, closes) = lst.map(_ match {\n            case '('  => 1\n            case ')'  => 1\n            case _    => 0\n        }).toList\n\n        // get the left side of every paranthesis, if the list is balanced\n        val lefts = lst.map {\n            case s if opens > closes => \"()\"\n            case s => \"()\" + s\n        }\n\n        // check the right side of every paranthesis, if the list is balanced\n        val rights = lst.map {\n            case s if closes > opens => \"()\"\n            case s => \"(\" + s\n        }\n\n        // if the left and right side of the list are balanced, return \"Yes\"\n        if(lefts.toSet.size == rights.toSet.size) \"Yes\"\n        else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpapjp5epx.scala:20:17 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m'('\u001b[0m  => \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpapjp5epx.scala:21:17 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m')'\u001b[0m  => \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpapjp5epx.scala:27:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mcase\u001b[0m s \u001b[33mif\u001b[0m opens > closes => \u001b[31m\"()\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Any, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Ordered.orderingToOrdered\n\u001b[31m   |\u001b[0m  import math.Ordering.Implicits.infixOrderingOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpapjp5epx.scala:33:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mcase\u001b[0m s \u001b[33mif\u001b[0m closes > opens => \u001b[31m\"()\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Any, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Ordered.orderingToOrdered\n\u001b[31m   |\u001b[0m  import math.Ordering.Implicits.infixOrderingOps\n\u001b[31m   |\u001b[0m\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979979
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // find all openings and closings\n        var openings : List[String] = Nil\n        var closings : List[String] = Nil\n        var opening_count : Int = 0\n        var closing_count : Int = 0\n        for (l<-lst) {\n            val chars : List[Char] = l.toList\n            for (c<-chars) {\n                if (c == '(') openings = openings :+ c\n                else if (c == ')') closings = closings :+ c\n            }\n            opening_count = openings.size\n            closing_count = closings.size\n        }\n        // get all combination\n        var com = for (l<-0 to openings.size-1) yield {\n            for (c<-0 to closings.size-1) yield {\n                for (o<-0 to openings.size()-1) yield {\n                    for (c<-0 to closings.size()-1) yield {\n                        // check if it is possible to make all openings and closings\n                        val opening_pos = openings(o) + c\n                        val closing_pos = closings(c)+o\n                        val pos1 = o*closings.size+c*openings.size+l*openings.size\n                        val pos2 = o*closings.size+c*openings.size+l*openings.size+openings.size()\n                        val pos3 = o*closings.size+c*openings.size+openings.size()*openings.size+closing_pos\n                        val pos4 = o*closings.size+openings.size()*openings.size+closing_pos+closings.size\n                        if ((pos1 == pos2) || (pos1 == pos3) || (pos1 == pos4) || (pos2 == pos3) || (pos2 == pos4) || (pos3 == pos4) || (pos1 == pos2) && (pos2 == pos3) && (pos3 == pos4))\n                        yield (o,c,l)\n                    }\n                }\n            }\n        }\n        // check if all combinations are valid\n        for (x <- com) if (x._2 == opening_count+closing_count)\n            yield \"Yes\"\n        else\n            yield \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqr79m95j.scala:45:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                        \u001b[33myield\u001b[0m (o,c,l)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        'then' expected, but 'yield' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqr79m95j.scala:52:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m            \u001b[33myield\u001b[0m \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            'then' expected, but 'yield' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqr79m95j.scala:26:53 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (c == \u001b[31m'('\u001b[0m) openings = openings :+ c\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (c : Char)\n\u001b[31m   |\u001b[0m                                                    Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqr79m95j.scala:27:58 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (c == \u001b[31m')'\u001b[0m) closings = closings :+ c\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (c : Char)\n\u001b[31m   |\u001b[0m                                                    Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpqr79m95j.scala:35:38 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mfor\u001b[0m (o<-\u001b[31m0\u001b[0m to openings.size()-\u001b[31m1\u001b[0m) \u001b[33myield\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when com",
      "stdout": "",
      "timestamp": 1659979979
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val leftParens = lst.count(lst contains \"(\")\n        val rightParens = lst.count(lst contains \")\")\n\n        if (leftParens == 0 || rightParens == 0)\n            \"No\"\n        else {\n            val s = lst.mkString(\"\")\n            val start = s.lastIndexOf(\"(\")\n            val end = s.lastIndexOf(\")\")\n            if (start < end) {\n                val str = s.substring(start + 1, end).replaceAll(\"\\\\\", \"\").toInt\n                if (str % 2 == 0)\n                    \"Yes\"\n                else\n                    \"No\"\n            }\n            else {\n                \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbw4ooo8v.scala:18:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mleftParens\u001b[0m = lst.count(lst contains \u001b[31m\"(\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    Boolean\n\u001b[31m   |\u001b[0m                                   Required: \u001b[1m\u001b[32mString\u001b[0m\u001b[1m\u001b[32m \u001b[0m\u001b[1m\u001b[32m=\u001b[0m\u001b[1m\u001b[32m>\u001b[0m\u001b[1m\u001b[32m \u001b[0mBoolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbw4ooo8v.scala:19:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrightParens\u001b[0m = lst.count(lst contains \u001b[31m\")\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    Boolean\n\u001b[31m   |\u001b[0m                                    Required: \u001b[1m\u001b[32mString\u001b[0m\u001b[1m\u001b[32m \u001b[0m\u001b[1m\u001b[32m=\u001b[0m\u001b[1m\u001b[32m>\u001b[0m\u001b[1m\u001b[32m \u001b[0mBoolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979977
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val len = lst.size\n        if(len == 0) \"No\"\n        else {\n            val stack = mutable.Stack[String]()\n            val isgood = lst.foldLeft(true)((x,y) => x && matchParens_helper(stack,0,x,y))\n            val result = if (isgood) \"Yes\" else \"No\"\n            stack.toList.reverse.mkString(\"\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp67vafkcu.scala:21:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp67vafkcu.scala:22:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36misgood\u001b[0m = lst.foldLeft(\u001b[31mtrue\u001b[0m)((\u001b[36mx\u001b[0m,\u001b[36my\u001b[0m) => x && matchParens_helper(stack,\u001b[31m0\u001b[0m,x,y))\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Not found: matchParens_helper\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979975
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val arr = lst.map(x => x.indexOf(\"(\") + 1, x.indexOf(\")\")).toArray\n        val l = arr.foldLeft(0)((x, y) =>\n            if (x > y) 1 else 0)\n        if (l == 0) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjqx_gl7f.scala:18:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = lst.map(\u001b[36mx\u001b[0m => x.indexOf(\u001b[31m\"(\"\u001b[0m) + \u001b[31m1\u001b[0m, x.indexOf(\u001b[31m\")\"\u001b[0m)).toArray\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpjqx_gl7f.scala:18:26 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = lst.map(\u001b[36mx\u001b[0m => x.indexOf(\u001b[31m\"(\"\u001b[0m) + \u001b[31m1\u001b[0m, x.indexOf(\u001b[31m\")\"\u001b[0m)).toArray\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                          I could not infer the type of the parameter x.\n\u001b[31m\u001b[31m-- Error: /tmp/tmpjqx_gl7f.scala:18:74 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = lst.map(\u001b[36mx\u001b[0m => x.indexOf(\u001b[31m\"(\"\u001b[0m) + \u001b[31m1\u001b[0m, x.indexOf(\u001b[31m\")\"\u001b[0m)).toArray\n\u001b[31m\u001b[31m   |\u001b[0m                                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979978
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val strings = mutable.ListBuffer[String]()\n        val lst_stack = mutable.Stack[List[String]]()\n        for (a <- lst){\n            strings += a\n            lst_stack += a :: stack\n            stack.push(a)\n        }\n        val lst_stack2 = lst_stack.toList\n        val stack_size = lst_stack2.size\n        val strings2= strings.toList\n        val stack_size2 = strings2.size\n        val count = stack_size2 - stack_size\n        for (i <- 0 until count){\n            val a = lst_stack2.pop()\n            val b = strings2.pop()\n            val stack_size_new=stack.size\n            val strings_new=strings.toList\n            val stack_size_new2 = strings_new.size\n            if (stack_size_new2<stack_size_new){\n                return \"No\"\n            }\n            stack+=b\n            strings+=a\n            lst_stack2+=stack\n            strings2+=b\n        }\n        val stack_size_final=stack.size\n        val strings_final=strings.toList\n        if (stack_size_final<stack_size){\n            return \"No\"\n        }\n        val stack_string = stack.toList\n        val stack_string_final = stack_string.mkString\n        val strings_final2 = strings_final.mkString\n        if (stack_string_final!=strings_final2){\n            return \"No\"\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl8yjvtnt.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl8yjvtnt.scala:19:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstrings\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl8yjvtnt.scala:20:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlst_stack\u001b[0m = mutable.Stack[\u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m]]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979975
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val l2 = lst.size\n        val set1 = new HashSet[Int]()\n        val set2 = new HashSet[Int]()\n        for (str <- lst) {\n            val index = str.indexOf(\"(\")\n            if (index < 0)\n                throw new IllegalArgumentException(\"String \" + str + \" has no opening \")\n            for (x <- 0 until str.lastIndexOf(\")\", index)) {\n                val count = str.length - (x + 1)\n                if (set1(count) && set2(count) && set1(count) == set2(count)) {\n                    return \"No\"\n                }\n                set1(count)\n                set2(count)\n            }\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.IllegalArgumentException: String ) has no opening \n\tat Problem$.matchParens$$anonfun$1(tmpeojal45w.scala:24)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat Problem$.matchParens(tmpeojal45w.scala:33)\n\tat Problem$.main(tmpeojal45w.scala:37)\n\tat Problem.main(tmpeojal45w.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659979981
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Write your code here\n        var l: Option[String] = None\n        var r: Option[String] = None\n        for(str <- lst.head :: lst.tail){\n            if(str == \"(\"){\n                l =  Some(str + lst.head)\n            }\n            if(str == \")\"){\n                r = Some(str + lst.tail)\n            }\n        }\n        if(l.isEmpty || r.isEmpty){\n            return \"No\"\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptp_gs36a.scala:35)\n\tat Problem.main(tmptp_gs36a.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659979980
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val pList = lst.map(lst => (lst, lst.length)).toMap\n        def validParens(lst: List[String]): Boolean = {\n            if (lst.length < 2) false\n            else {\n                val l1 = lst.head\n                val l2 = lst.last\n                val l1 = l1.toChar\n                val l2 = l2.toChar\n                (pList.get(l1)(l2)) match {\n                    case Some(x) => x._1\n                    case None => false\n                }\n            }\n        }\n        validParens(lst) match {\n            case true => \"Yes\"\n            case false => \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_qpv48t6.scala:24:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36ml1\u001b[0m = l1.toChar\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0ml1 is already defined as \u001b[33mvalue\u001b[0m \u001b[35ml1\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_qpv48t6.scala:25:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36ml2\u001b[0m = l2.toChar\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0ml2 is already defined as \u001b[33mvalue\u001b[0m \u001b[35ml2\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp_qpv48t6.scala:26:26 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                (pList.get(l1)(l2)) \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                \u001b[33mmethod\u001b[0m \u001b[35mget\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mMapOps\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_qpv48t6.scala:27:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                    \u001b[33mcase\u001b[0m Some(x) => x._1\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979976
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def isValid(lst: List[String], i : Int): String = {\n            if (lst(i).charAt(lst(i).length - 1) != '(') List(\"No\")\n            else {\n                val cur = lst(i).charAt(0)\n                val left = isValid(lst, (i - 1))\n                val right = isValid(lst, (i - 2))\n                if (left != right) left\n                else {\n                    if (cur == '(') right\n                    else left\n                }\n            }\n        }\n        val len = lst.size\n        if (len == 1) lst(0)\n        else if (len == 2) lst(1)\n        else isValid(lst, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdkriz5h1.scala:19:61 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mif\u001b[0m (lst(i).charAt(lst(i).length - \u001b[31m1\u001b[0m) != \u001b[31m'('\u001b[0m) List(\u001b[31m\"No\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mString\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979979
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Use recursion to solve the problem\n        val lst2= lst.map(x => if (x == \"(\") 1 else 0).reverse\n        val lst3= lst2.foldLeft(0)(_ + _)\n        if (lst3 < lst) s\"Yes\" else s\"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpa2789cq1.scala:21:17 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst3 < lst) \u001b[31ms\"Yes\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31ms\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m<\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Boolean\n\u001b[31m   |\u001b[0m  (x: Float): Boolean\n\u001b[31m   |\u001b[0m  (x: Long): Boolean\n\u001b[31m   |\u001b[0m  (x: Int): Boolean\n\u001b[31m   |\u001b[0m  (x: Char): Boolean\n\u001b[31m   |\u001b[0m  (x: Short): Boolean\n\u001b[31m   |\u001b[0m  (x: Byte): Boolean\n\u001b[31m   |\u001b[0m match arguments ((lst : List[String]))\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979977
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      var res = \"No\"\n      val open = lst(0)\n      val close = lst(1)\n      var stack = List[String]()\n      stack :+= open\n      while (open.length > 0 || close.length > 0) {\n        if (open.length == 0) {\n          res = \"Yes\"\n          break\n        }\n        if (close.length == 0) {\n          res = \"No\"\n          break\n        }\n        val x = open(0)\n        val y = close(0)\n        val newOpen = open.drop(1)\n        val newClose = close.drop(1)\n        if (y == \"(\") {\n          if (stack.isEmpty) {\n            res = \"No\"\n            break\n          }\n          if (stack == newOpen) {\n            stack :+= y\n          }\n          if (stack == newClose) {\n            stack :+= y\n          }\n          if (stack == newOpen || stack == newClose) {\n            res = \"No\"\n            break\n          }\n        } else {\n          if (stack.isEmpty) {\n            res = \"No\"\n            break\n          }\n          if (stack == newClose) {\n            stack :+= y\n          }\n          if (stack == newOpen || stack == newClose) {\n            res = \"No\"\n            break\n          }\n        }\n        open += x\n        close += y\n      }\n      res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpubtqumce.scala:26:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m          break\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpubtqumce.scala:30:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m          break\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpubtqumce.scala:36:12 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mif\u001b[0m (y == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpubtqumce.scala:39:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            break\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpubtqumce.scala:41:14 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m          \u001b[33mif\u001b[0m (stack == newOpen) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types List[String] and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpubtqumce.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            stack :+= y\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue :+= is not a member of List[String] - did you mean List[String].:+?\n\u001b[31m\u001b[31m-- Error: /tmp/tmpubtqumce.scala:44:14 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m          \u001b[33mif\u001b[0m (stack == newClose) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types List[String] and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E008] ",
      "stdout": "",
      "timestamp": 1659979983
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val openings = lst.map( _.length )\n        val closings = lst.map( _.length )\n        val openingMap = mutable.Map.empty[Int, Int]\n        val closingMap = mutable.Map.empty[Int, Int]\n        lst.foreach( x => {\n            if( (openings(x) != 0) || (closings(x) != 0) ) {\n                openingMap += (openings(x) -> (x + 1))\n                closingMap += (closings(x) -> (x + 1))\n            }\n        })\n        if( (openingMap == closingMap) && (openings == closings) ) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkg5u0bde.scala:20:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopeningMap\u001b[0m = mutable.Map.empty[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkg5u0bde.scala:21:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclosingMap\u001b[0m = mutable.Map.empty[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkg5u0bde.scala:23:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m( (openings(x) != \u001b[31m0\u001b[0m) || (closings(x) != \u001b[31m0\u001b[0m) ) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (x : String)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkg5u0bde.scala:23:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m( (openings(x) != \u001b[31m0\u001b[0m) || (closings(x) != \u001b[31m0\u001b[0m) ) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Found:    (x : String)\n\u001b[31m   |\u001b[0m                                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979980
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n       val stack = new mutable.Stack[Int]()\n       lst.foreach(x => stack += x.length)\n       if(stack.last < 0)\n         return \"No\"\n       while(stack.last > 0) {\n          if(stack.last > 1) {\n             stack -= 2\n             stack += 2\n          }\n          val len = stack.pop()\n          if(len < 0)\n             return \"No\"\n          else if(len > 0)\n             stack.push(stack.last - len)\n       }\n       if(stack.last == 0)\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq3si8lvt.scala:18:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m       \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = \u001b[33mnew\u001b[0m mutable.Stack[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq3si8lvt.scala:33:7 ---------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m       \u001b[33mif\u001b[0m(stack.last == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m       ^\u001b[0m\n\u001b[31m   |\u001b[0m       Found:    Unit\n\u001b[31m   |\u001b[0m       Required: String\n\u001b[31m   |\u001b[0m       Maybe you are missing an else part for the conditional?\n\u001b[31m34 |\u001b[0m        \u001b[33mreturn\u001b[0m \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979979
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def stackCounts(s : List[String], r : List[String], i : Int) : Int = {\n            val stk = ArrayBuffer(s.head).init\n\n            var count : Int = 0\n            var stack : List[String] = stk\n\n            while(i < l.length){\n                if(l(i) == \"(\"){\n                    count += stackCounts(stack.pop, l(i + 1), 1)\n                    stack += l(i + 1)\n                }\n                i += 1\n            }\n\n            count\n        }\n\n        val l = lst.head\n        val stk = ArrayBuffer(l).init\n\n        var count : Int = 0\n        var stack : List[String] = stk\n\n        while(stack.length > 0){\n            count += stackCounts(stack.pop, lst.last, 1)\n        }\n\n        if(count == l.length)\n            return \"Yes\"\n        else\n            return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0ufotzmc.scala:22:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mstack\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m] = stk\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Found:    (stk : scala.collection.mutable.ArrayBuffer[String])\n\u001b[31m   |\u001b[0m          Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp0ufotzmc.scala:25:19 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                \u001b[33mif\u001b[0m(l(i) == \u001b[31m\"(\"\u001b[0m){\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0ufotzmc.scala:26:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    count += stackCounts(stack.pop, l(i + \u001b[31m1\u001b[0m), \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0ufotzmc.scala:26:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    count += stackCounts(stack.pop, l(i + \u001b[31m1\u001b[0m), \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue pop is not a member of List[String] - did you mean List[String].drop?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0ufotzmc.scala:26:53 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    count += stackCounts(stack.pop, l(i + \u001b[31m1\u001b[0m), \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    Char\n\u001b[31m   |\u001b[0m                                                  Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0ufotz",
      "stdout": "",
      "timestamp": 1659979985
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def matchParen(st: List[String], acc : List[String], acc2: (List[String], List[String], Int)): (List[String], List[String], Int) = {\n            if (st.head == \"()\") {\n                matchParen(st.tail, acc.reverse, acc2)\n            } else if (st.head == \"[]\") {\n                matchParen(st.tail, acc, acc2)\n            } else if (st.head == \"{}\") {\n                matchParen(st.tail, acc.reverse, acc2)\n            } else if (st.head == \")\") {\n                if (acc.head == \"()\") {\n                    if (acc.last == \"()\") {\n                        acc\n                    } else {\n                        matchParen(st.tail, acc, acc2)\n                    }\n                } else if (acc.head == \"[]\") {\n                    if (acc.last == \"[]\") {\n                        acc\n                    } else {\n                        matchParen(st.tail, acc, acc2)\n                    }\n                } else if (acc.head == \"{}\") {\n                    if (acc.last == \"{}\") {\n                        acc\n                    } else {\n                        matchParen(st.tail, acc, acc2)\n                    }\n                } else if (acc.head == \"]\") {\n                    if (acc.last == \"[]\") {\n                        acc\n                    } else {\n                        matchParen(st.tail, acc, acc2)\n                    }\n                } else if (acc.head == \"}\") {\n                    if (acc.last == \"{}\") {\n                        acc\n                    } else {\n                        matchParen(st.tail, acc, acc2)\n                    }\n                } else {\n                    if (acc.last == st.head) {\n                        matchParen(st.tail, acc, acc2)\n                    } else {\n                        matchParen(st.tail, acc.reverse ++ List(\"()\"), acc2)\n                    }\n                }\n            } else if (st.head == \"[\") {\n                if (acc.head == \"()\") {\n                    if (acc.last == \"()\") {\n                        acc\n                    } else {\n                        matchParen(st.tail, acc, acc2)\n                    }\n                } else if (acc.head == \"[]\") {\n                    if (acc.last == \"[]\") {\n                        acc\n                    } else {\n                        matchParen(st.tail, acc, acc2)\n                    }\n                } else if (acc.head == \"{}\") {\n                    if (acc.last == \"{}\") {\n                        acc\n                    } else {\n                        matchParen(st.tail, acc, acc2)\n                    }\n                } else if (acc.head == \"]\") {\n                    if (acc.last == \"[]\") {\n                        acc\n                    } else {\n                        matchParen(st.tail, acc, acc2)\n                    }\n                } else if (acc.head == \"}\") {\n                    if (acc.last == \"{}\") {\n                        acc\n                    } else {\n                        matchParen(st.tail, acc, acc2)\n                    }\n                } else {\n                    if (acc.last == st.head) {\n                        matchParen(st.tail, acc, acc2)\n                    } else {\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwv70rl6e.scala:115:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m115 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwv70rl6e.scala:28:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                        acc\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    (\u001b[1m\u001b[31macc\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m List[String])\n\u001b[31m   |\u001b[0m                        Required: (\u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0m\u001b[1m\u001b[32mString\u001b[0m\u001b[1m\u001b[32m]\u001b[0m\u001b[1m\u001b[32m,\u001b[0m List[String]\u001b[1m\u001b[32m,\u001b[0m\u001b[1m\u001b[32m \u001b[0m\u001b[1m\u001b[32mInt\u001b[0m)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwv70rl6e.scala:34:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                        acc\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    (\u001b[1m\u001b[31macc\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m List[String])\n\u001b[31m   |\u001b[0m                        Required: (\u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0m\u001b[1m\u001b[32mString\u001b[0m\u001b[1m\u001b[32m]\u001b[0m\u001b[1m\u001b[32m,\u001b[0m List[String]\u001b[1m\u001b[32m,\u001b[0m\u001b[1m\u001b[32m \u001b[0m\u001b[1m\u001b[32mInt\u001b[0m)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwv70rl6e.scala:40:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                        acc\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    (\u001b[1m\u001b[31macc\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m List[String])\n\u001b[31m   |\u001b[0m                        Required: (\u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0m\u001b[1m\u001b[32mString\u001b[0m\u001b[1m\u001b[32m]\u001b[0m\u001b[1m\u001b[32m,\u001b[0m List[String]\u001b[1m\u001b[32m,\u001b[0m\u001b[1m\u001b[32m \u001b[0m\u001b[1m\u001b[32mInt\u001b[0m)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwv70rl6e.scala:46:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m                        acc\n\u001b[31m\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1659979983
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stackList = mutable.ListBuffer[String]()\n\n        for(x<-lst){\n            if(x==\"(\")\n            stack += x\n            if(x==\")\"){\n                stackList += stack.toList\n                stack.clear()\n            }\n        }\n        stackList match {\n            case x if(x == stack.toList) => \"Yes\"\n            case x if(x!=stack.toList) => \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8h07wplb.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8h07wplb.scala:19:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackList\u001b[0m = mutable.ListBuffer[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979982
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val (_, _, s1) = lst\n      val (_, _, s2) = lst.reverse\n      val p1 = s1.map(c => if (c == '(') '!' else '!').toChar\n      val p2 = s2.map(c => if (c == '(') '!' else '!').toChar\n      val a = p1 ++ p2\n      val b = a.zipWithIndex.map { case (l, i) => if (l == '!') i.toString else l}\n      val index = b.indexOf(0)\n      (index != -1) && (\"Yes\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa48pl2c5.scala:20:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mp1\u001b[0m = s1.map(\u001b[36mc\u001b[0m => \u001b[33mif\u001b[0m (c == \u001b[31m'('\u001b[0m) \u001b[31m'!'\u001b[0m \u001b[33melse\u001b[0m \u001b[31m'!'\u001b[0m).toChar\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value map is not a member of Any\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa48pl2c5.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mp2\u001b[0m = s2.map(\u001b[36mc\u001b[0m => \u001b[33mif\u001b[0m (c == \u001b[31m'('\u001b[0m) \u001b[31m'!'\u001b[0m \u001b[33melse\u001b[0m \u001b[31m'!'\u001b[0m).toChar\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value map is not a member of Any\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979989
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val str = lst.mkString(\"(\", \"\", \")\")\n        val set = sc.parallelize(str.split(\"\\\\(\")).distinct\n        val map = set.map(r => (r, 1)).reduceByKey(_ + _).map{ case (r, (i, j)) => (i, j, r) }.toMap\n        val len = lst.size\n        def checker(i : Int) : Boolean = {\n            if (i > len - 1) false else if (map(i) > (map.size - len)) false else if (map(i) < map(len - 1)) checker(i + 1)\n            else check(i, map.size - 1) || checker(i + 1)\n        }\n        val res = checker(0)\n        if (res) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmzj66p3e.scala:19:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mset\u001b[0m = sc.parallelize(str.split(\u001b[31m\"\\\\(\"\u001b[0m)).distinct\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: sc\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmzj66p3e.scala:24:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33melse\u001b[0m check(i, map.size - \u001b[31m1\u001b[0m) || checker(i + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Not found: check\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979983
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var lst1 = lst.tail\n        val lst2 = lst.head\n        if (lst1 == lst2) {\n            \"Yes\"\n        } else {\n            val lst3 = lst1 -- lst2\n            val lst4 = lst2 -- lst3\n            lst4.foldLeft(\"\"){ (s, x) => s ++ x }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp9r_2fa27.scala:20:12 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (lst1 == lst2) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types List[String] and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9r_2fa27.scala:23:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mlst3\u001b[0m = lst1 -- lst2\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value -- is not a member of List[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9r_2fa27.scala:24:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mlst4\u001b[0m = lst2 -- lst3\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value -- is not a member of String\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979987
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def isValidParenthesis(s  : String) : Boolean = {\n            val l = s.toList\n            l.size < 2 || l.last != \"(\" && l.first != \")\"\n        }\n        val map = new scala.collection.mutable.HashMap[String,String]()\n        for(x <- lst ) map(x) += \"*\"\n        val ls = map.toSeq\n        ls.sortBy(_._1).reverse // sort by key then reverse\n        val result = ls.find(_._2 == \"*\").map(_._1)\n        if(!result.get.isEmpty) result else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp0wxu3ltj.scala:20:26 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            l.size < \u001b[31m2\u001b[0m || l.last != \u001b[31m\"(\"\u001b[0m && l.first != \u001b[31m\")\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0wxu3ltj.scala:20:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            l.size < \u001b[31m2\u001b[0m || l.last != \u001b[31m\"(\"\u001b[0m && l.first != \u001b[31m\")\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value first is not a member of List[Char] - did you mean l.find?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0wxu3ltj.scala:27:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m(!result.get.isEmpty) result \u001b[33melse\u001b[0m \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (result : Option[String])\n\u001b[31m   |\u001b[0m                                Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979989
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var final = lst(0)\n        val stack = new mutable.Stack[String]()\n        for(a <- lst) {\n            if(!stack.isEmpty) {\n                if(stack.toList.last == (a)) {\n                    stack.poll()\n                } else {\n                    return \"No\"\n                }\n            }\n            stack += a\n        }\n        if(stack.size == 0) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpyidp055t.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[33mfinal\u001b[0m = lst(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyidp055t.scala:19:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = \u001b[33mnew\u001b[0m mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979983
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var flag = 0\n        val stack = new mutable.Stack[String]()\n        val stack2 = new mutable.Stack[String]()\n        val stack3 = new mutable.Stack[String]()\n\n        for(i <- 0 until lst.size) {\n            if((lst(i) == \"(\" && stack.nonEmpty) || (lst(i) == \")\" && stack.nonEmpty)) {\n                stack3 += lst(i).substring(stack3.size, stack3.size + 1)\n                flag += 1 // stack flag\n            }\n            else if(lst(i) == \"(\" && stack.isEmpty) {\n                stack += lst(i)\n                flag += 1 // stack flag\n            }\n            else if(lst(i) == \")\" && stack.isEmpty) {\n                stack2 += lst(i)\n                flag += 1 // stack flag\n            }\n            else if(lst(i) == \")\" && stack2.nonEmpty && stack3.nonEmpty) {\n                val s = stack2.pop + stack3.pop\n                stack2 += s\n                stack3 += s\n                flag += 2 // stack flag\n            }\n            else if(lst(i) == \"(\" && stack2.nonEmpty) {\n                val s = stack2.pop + lst(i)\n                stack2 += s\n                flag += 2 // stack flag\n            }\n            else if(lst(i) == \")\" && stack2.nonEmpty && stack.nonEmpty) {\n                val s = stack2.pop + stack.pop\n                stack2 += s\n                flag += 2 // stack flag\n            }\n            else if(lst(i) == \"(\" && stack.nonEmpty && stack3.nonEmpty) {\n                val s = stack.pop + stack3.pop\n                stack += s\n                flag += 2 // stack flag\n            }\n            else if(lst(i) == \")\" && stack.nonEmpty && stack3.nonEmpty) {\n                val s = stack.pop + stack3.pop\n                stack += s\n                flag += 2 // stack flag\n            }\n            else if(lst(i) == \"(\" && stack2.nonEmpty && stack.nonEmpty) {\n                val s = stack2.pop + stack.pop\n                stack2 += s\n                flag += 2 // stack flag\n            }\n            else if(lst(i) == \")\" && stack2.nonEmpty && stack.nonEmpty) {\n                val s = stack2.pop + stack.pop\n                stack2 += s\n                flag += 2 // stack flag\n            }\n            else if(lst(i) == \")\" && stack.nonEmpty && stack2.nonEmpty) {\n                val s = stack.pop + stack2.pop\n                stack += s\n                flag += 2 // stack flag\n            }\n            else if(lst(i) == \"(\" && stack2.non\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpppylnm9g.scala:78:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpppylnm9g.scala:95:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m95 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpppylnm9g.scala:19:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = \u001b[33mnew\u001b[0m mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpppylnm9g.scala:20:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack2\u001b[0m = \u001b[33mnew\u001b[0m mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpppylnm9g.scala:21:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack3\u001b[0m = \u001b[33mnew\u001b[0m mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpppylnm9g.scala:94:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m94 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpppylnm9g.scala:79:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m79 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33",
      "stdout": "",
      "timestamp": 1659979988
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var a: List[String] = lst\n        var temp: List[String] = Nil\n        while(!a.isEmpty) {\n            if(a.head == \")\") {\n                temp = a :: temp\n                a = a.tail\n                if(!a.isEmpty) {\n                    a.remove(0)\n                }\n            }\n            else {\n                temp = a :: temp\n                a = a.tail\n                if(!a.isEmpty) {\n                    a.remove(0)\n                }\n            }\n        }\n        if(temp.isEmpty) {\n            return \"Yes\"\n        }\n        else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp382gfcgi.scala:22:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                temp = a :: temp\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (a : List[String])\n\u001b[31m   |\u001b[0m                       Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp382gfcgi.scala:25:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                    a.remove(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue remove is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp382gfcgi.scala:29:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                temp = a :: temp\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (a : List[String])\n\u001b[31m   |\u001b[0m                       Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp382gfcgi.scala:32:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    a.remove(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue remove is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import co",
      "stdout": "",
      "timestamp": 1659979990
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n        for (i <- 0 until lst.length) {\n            if (lst(i) == \"(\" && stack.nonEmpty) {\n                val top = stack.pop()\n                if (top != \"(\") {\n                    queue += top\n                }\n            } else if (lst(i) == \")\" && stack.nonEmpty && queue.isEmpty) {\n                stack += \")\"\n            } else if (lst(i) == \")\") {\n                stack += \")\"\n            } else if (lst(i) == \"(\") {\n                queue += \"(\"\n            }\n        }\n        if (stack.nonEmpty && stack.last.equals(\"(\")) {\n            return \"Yes\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptuz8_o3x.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptuz8_o3x.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979986
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val openParens = Set(\"(\")\n        val closeParens = Set(\")\") \n        val lst = lst.sorted\n        if (lst.head != lst.tail.head) (\"No\") \n        else if (openParens.isEmpty || closeParens.isEmpty) { (\"No\") }\n        else (findMatch(lst.head)) match {\n            case (Some(findMatch(lst.head)) if findMatch(lst.head) == lst.head && lst.head.head == lst.head.tail ) => \"Yes\"\n            case _ => \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcoypj25m.scala:24:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mcase\u001b[0m (Some(findMatch(lst.head)) \u001b[33mif\u001b[0m findMatch(lst.head) == lst.head && lst.head.head == lst.head.tail ) => \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            ')' expected, but 'if' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcoypj25m.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlst\u001b[0m = lst.sorted\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mlst\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcoypj25m.scala:23:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33melse\u001b[0m (findMatch(lst.head)) \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Not found: findMatch\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcoypj25m.scala:24:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mcase\u001b[0m (Some(findMatch(lst.head)) \u001b[33mif\u001b[0m findMatch(lst.head) == lst.head && lst.head.head == lst.head.tail ) => \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: findMatch\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979985
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val p = lst.filter(_.toList.length == 1).head\n        val q = lst.filter(_.toList.length == 0).head\n        if(lst.contains(p) && lst.contains(q)){\n            val n = new Stack[String]()\n            for(i <- 0 until lst.size){\n                if(i == p.toString.length){\n                    n.push(\"(\")\n                }else if(lst.contains(p.toString.substring(0,i))){\n                    n.push(p.toString.substring(0,i))\n                }else{\n                    n.push(p.toString.substring(0,i) + n.pop())\n                }\n            }\n            if(n.toString.equals(\"(\")){\n                \"Yes\"\n            }else{\n                \"No\"\n            }\n        }else{\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.matchParens(tmp8vhlinbr.scala:19)\n\tat Problem$.main(tmp8vhlinbr.scala:41)\n\tat Problem.main(tmp8vhlinbr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659979992
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def rec(stack: List[String], currStack: List[String], i : Int) : List[String] = {\n            if (i == lst.size) {\n                if (currStack == lst.head) {\n                    return stack\n                }\n            }\n            if (i == 0) {\n                if (currStack.size != lst.head.size) {\n                    return \"No\"\n                }\n                else {\n                    val stackCopy = stack.clone()\n                    val currStackCopy = currStack.clone()\n                    while (stackCopy.nonEmpty && currStackCopy.nonEmpty && stackCopy.head == currStackCopy.head) {\n                        stackCopy = stackCopy.tail\n                        currStackCopy = currStackCopy.tail\n                    }\n                    if (stackCopy.nonEmpty || currStackCopy.nonEmpty) {\n                        val stackCopyStr = stackCopy.mkString(\"\")\n                        val currStackCopyStr = currStackCopy.mkString(\"\")\n                        if (currStackCopyStr == stackCopyStr) {\n                            return \"Yes\"\n                        }\n                    }\n                }\n            }\n            val nextOpen = lst.head(i) match {\n                case '(' => true\n                case ')' => true\n                case _ => false\n            }\n            if (nextOpen && stack.size < lst.head.size) {\n                currStack.push(lst.head(i))\n                val newStack = stack.tail +: currStack.tail\n                rec(newStack, lst, i + 1)\n                currStack = currStack.tail\n            }\n            else {\n                rec(stack, currStack, i + 1)\n            }\n        }\n        rec(new ListBuffer[String](), new ListBuffer[String](), 0)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpaivos_sv.scala:20:20 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                \u001b[33mif\u001b[0m (currStack == lst.head) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types List[String] and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpaivos_sv.scala:26:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    \u001b[33mreturn\u001b[0m \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (\u001b[32m\"No\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                           Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpaivos_sv.scala:29:42 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    \u001b[33mval\u001b[0m \u001b[36mstackCopy\u001b[0m = stack.clone()\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m\u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mObject\u001b[0m cannot be accessed as a member of (stack : List[String]) from module class Problem$.\n\u001b[31m   |\u001b[0m Access to protected \u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m not permitted because prefix type List[String]\n\u001b[31m   |\u001b[0m does not conform to \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m where the access takes place\n\u001b[31m\u001b[31m-- Error: /tmp/tmpaivos_sv.scala:30:50 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                    \u001b[33mval\u001b[0m \u001b[36mcurrStackCopy\u001b[0m = currStack.clone()\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m\u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mObject\u001b[0m cannot be accessed as a member of (currStack : List[String]) from module class Problem$.\n\u001b[31m   |\u001b[0m Access to protected \u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m not permitted because prefix type List[String]\n\u001b[31m   |\u001b[0m does not conform to \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m where the access takes place\n\u001b[31m\u001b[31m-- [E052] Type Err",
      "stdout": "",
      "timestamp": 1659979992
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var good = True\n        val left  = lst.head\n        val right = lst(1 until lst.size)\n        val leftList = lst.take(left.length)\n        val rightList = lst.drop(right.length)\n        var i = leftList.size\n        while (i < leftList.size) {\n            if (right(i) != left(i)) {\n                good = False\n                break\n            }\n            i += 1\n        }\n        if (good)\n            \"Yes\"\n        else\n            \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptftiyv98.scala:18:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mgood\u001b[0m = True\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: True\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptftiyv98.scala:20:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mright\u001b[0m = lst(\u001b[31m1\u001b[0m until lst.size)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    Range\n\u001b[31m   |\u001b[0m                        Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptftiyv98.scala:26:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                good = False\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: False\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptftiyv98.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979990
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // TODO:\n        // Write your code here\n        var str = lst(0).mkString(\"\")\n        var flag = true\n        for(i <- 1L to lst.size) {\n            str += lst(i)\n            if(str.charAt(str.length-1) != '(' || str.charAt(0) == '(') {\n                flag = false\n            }\n            str += lst(i)\n        }\n        if(flag) return \"Yes\"\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpofwnia5_.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            str += lst(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpofwnia5_.scala:23:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            str += lst(i)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (i : Long)\n\u001b[31m   |\u001b[0m                       Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpofwnia5_.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            str += lst(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpofwnia5_.scala:27:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            str += lst(i)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (i : Long)\n\u001b[31m   |\u001b[0m                       Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979992
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val n = lst.size\n        if (n == 0) {\n          \"No\"\n        } else if (n == 1) {\n          val p1 = lst(0) match {\n            case \"(\" : true\n            case \")\" : true\n            case _ : false\n          }\n          if (p1) {\n            \"Yes\"\n          } else {\n            \"No\"\n          }\n        } else {\n          val m = lst.foldLeft(0)((m, n) => if (n <= m) n + 1 else n)\n          val goodStrings = (1 to m).map { x =>\n            (1 to n).map { y =>\n              if (x != y && lst.exists(y => lst(y) == \"(\" && lst(y - 1) == \"(\" && lst(y - 2) == \")\")) return true\n              else false\n            }\n          }.flatten.filter(x => x).mkString(\",\")\n          if (goodStrings == \"false\") \"No\" else \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzj1m89md.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m\")\"\u001b[0m : \u001b[31mtrue\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            '=>' expected, but 'case' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzj1m89md.scala:26:10 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m          }\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzj1m89md.scala:23:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m\"(\"\u001b[0m : \u001b[31mtrue\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    (\u001b[32m\"(\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                 Required: (\u001b[31mtrue\u001b[0m : Boolean)\n\u001b[31m   |\u001b[0m                 pattern type is incompatible with expected type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzj1m89md.scala:27:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m          \u001b[33mif\u001b[0m (p1) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^\u001b[0m\n\u001b[31m   |\u001b[0m              Found:    (p1 : Unit)\n\u001b[31m   |\u001b[0m              Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzj1m89md.scala:33:53 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m          \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = lst.foldLeft(\u001b[31m0\u001b[0m)((\u001b[36mm\u001b[0m, \u001b[36mn\u001b[0m) => \u001b[33mif\u001b[0m (n <= m) n + \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m n)\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                     Found:    (m : Int)\n\u001b[31m   |\u001b[0m                                                     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzj1m89md.scala:33:56 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m       ",
      "stdout": "",
      "timestamp": 1659979993
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val str = lst.last\n        val lst1 = lst.init drop 1\n        var isGood = True\n        val stack = new Stack[String]\n        val lst2 = lst1.map(x => x.toChar).map(x => x.toInt)\n        val lst3 = lst.map(x => x.toChar).map(x => x.toInt)\n        for(i <- lst3) stack.push(\"\" + i)\n        for(i <- lst2) stack.push(i.toString + stack.pop())\n        val goodStr = stack.pop()\n        if(goodStr == str) isGood\n        else isGood.toString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp41e18xu0.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36misGood\u001b[0m = True\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: True\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp41e18xu0.scala:22:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlst2\u001b[0m = lst1.map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value toChar is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp41e18xu0.scala:22:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlst2\u001b[0m = lst1.map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toInt is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp41e18xu0.scala:23:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlst3\u001b[0m = lst.map(\u001b[36mx\u001b[0m => x.toChar).map(\u001b[36mx\u001b[0m => x.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value toChar is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp41e18xu0.scala:23:53 ----------------------",
      "stdout": "",
      "timestamp": 1659979993
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val set1 = lst.map(x => if (x == \"(\") 1 else 0)\n        val set2 = lst.map(x => if (x == \"()\") 0 else 1)\n        val set3 = set1 ++ set2\n        val set4 = lst.map(x => if (x == \"(()\") 0 else 1)\n        val set5 = set4 ++ set3\n        val set6 = lst.map(x => if (x == \")\") 0 else 1)\n        val set7 = set5 ++ set6\n        if (set7.distinct.size == lst.size && set7.distinct.size == set1.size + set2.size && set7.distinct.size == set4.size + set3.size + set6.size && set7.distinct.size == set5.size + set6.size) {\n            val result = set7.distinct\n            val str = result.mkString(\"(\", \", \", \")\")\n            if (str.length == lst.size && str.size == set1.size + set2.size + set4.size + set3.size + set5.size + set6.size) {\n                return \"Yes\"\n            }\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpgbm5wm2v.scala:35)\n\tat Problem.main(tmpgbm5wm2v.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659979994
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = Stack[String]()\n        val leftmost = Stack[String]()\n        lst.foreach(elem => {\n            val open = elem.substring(0, elem.indexOf(\"(\"))\n            val close = elem.substring(elem.indexOf(\"(\"))\n            if (stack.isEmpty && (elem.indexOf(\"(\") <= elem.indexOf(\")\"))) stack.append(open)\n            if (stack.isEmpty && (elem.indexOf(\"(\") < elem.indexOf(\")\")) && (close.length == 0)) stack.append(close)\n            if (open != \"\") leftmost.append(open)\n            if (close != \"\") leftmost.append(close)\n        })\n        if (leftmost.size == 2) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin 0, end -1, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat Problem$.matchParens$$anonfun$1(tmplunju7ml.scala:21)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat Problem$.matchParens(tmplunju7ml.scala:27)\n\tat Problem$.main(tmplunju7ml.scala:31)\n\tat Problem.main(tmplunju7ml.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659979994
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val res = new collection.mutable.StringBuilder\n        for (x <- lst) {\n            if (x match {\n                \"(\" =>\n                    stack.push(x)\n                case \")\" =>\n                    while (!stack.isEmpty) {\n                        if (stack.peek() match {\n                            \"(\" =>\n                                stack.pop()\n                            case \")\" =>\n                                res.append(\"(\")\n                                res.append(\")\")\n                            case _ =>\n                                res.append(stack.pop())\n                        }) else\n                            res.append(stack.pop())\n                    }\n                case \"(\" =>\n                    stack.push(x)\n                case \")\" =>\n                    res.append(\"(\")\n                }) else\n                    res.append(x)\n        }\n        res.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzhv23rq1.scala:22:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                \u001b[31m\"(\"\u001b[0m =>\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                'case' expected, but string literal found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzhv23rq1.scala:41:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                }) \u001b[33melse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzhv23rq1.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzhv23rq1.scala:41:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                }) \u001b[33melse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    Unit\n\u001b[31m   |\u001b[0m                Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmpzhv23rq1.scala:43:8 -----------------\u001b[0m\u001b[0m\n\u001b[33m42 |\u001b[0m                    res.append(x)\n\u001b[33m43 |\u001b[0m        }\n\u001b[33m\u001b[33m   |\u001b[0m                                 ^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression does nothing in statement position; you may be omitting necessary parentheses\n\u001b[33m   |\u001b[0m\n\u001b[33m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 warning found\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979993
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size < 2)\n            throw new RuntimeException(\"Error! The list must contain two elements.\");\n        val opening = lst.head;\n        val closing = lst.last;\n        var counter = 0;\n        var result = \"\";\n        for(i <- 0 until opening.length()) {\n            if (opening(i) == '(') {\n                if (closing != '(') {\n                    result += closing(i);\n                    counter++;\n                }\n            } else { // closing != '('\n                if (opening != '(' && counter == 0) // if opening == '('\n                    result += \"()\"\n                else if (opening != '(' && counter == 1) // if opening != (')\n                    result += \"()\"\n            }\n        }\n        if (counter != 0)\n            result = \"No\"\n        else\n            result = \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpjqzcr_yn.scala:28:29 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    counter++;\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             expression expected but \u001b[31m';'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpjqzcr_yn.scala:26:20 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (closing != \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpjqzcr_yn.scala:31:20 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                \u001b[33mif\u001b[0m (opening != \u001b[31m'('\u001b[0m && counter == \u001b[31m0\u001b[0m) \u001b[34m// if opening == '('\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpjqzcr_yn.scala:33:25 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (opening != \u001b[31m'('\u001b[0m && counter == \u001b[31m1\u001b[0m) \u001b[34m// if opening != (')\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjqzcr_yn.scala:38:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            result = \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    Unit\n\u001b[31m   |\u001b[0m            Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjqzcr_yn.scala:40:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            result = \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    Unit\n\u001b[31m   |\u001b[0m      ",
      "stdout": "",
      "timestamp": 1659979994
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var result = \"No\"\n        var stack = Nil\n        var openStack = Nil\n        lst.foreach(x => {\n            stack :+ x\n            if (x.equals(\")\")) {\n                openStack = stack.filter(_ != x)\n                result +=  (openStack == stack && openStack.length == 1)\n            }\n            if (x.equals(\"(\")) {\n                openStack = stack.filter(_ != x)\n                result +=  (openStack.length == 0 && stack.forall(_.equals(\")\")))\n            }\n        })\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkvcmflng.scala:24:40 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                openStack = stack.filter(_ != x)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    List[Nothing]\n\u001b[31m   |\u001b[0m                           Required: scala.collection.immutable.Nil.type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkvcmflng.scala:28:40 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                openStack = stack.filter(_ != x)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    List[Nothing]\n\u001b[31m   |\u001b[0m                           Required: scala.collection.immutable.Nil.type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979995
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val parenStack = mutable.Stack[Boolean]()\n        val res = \"Yes\"\n\n        // TODO: Complete this function\n        for (str <- lst) {\n            // if open and close matches push true to parenStack\n            if (str.contains(\"(\") && str.contains(\")\")) {\n                parenStack.push(true)\n            }\n            // if closing and open matches pop false to parenStack\n            if (str.contains(\")\") && str.contains(\"(\")) {\n                parenStack.pop()\n            }\n            // if closing and open doesn't match push false to parenStack\n            else if (!str.contains(\")\") && !str.contains(\"(\")) {\n                parenStack.push(false)\n            }\n            // if open and close doesn't match push true to parenStack\n            else {\n                parenStack.push(true)\n            }\n        }\n\n        // if all parenthesis are balanced return Yes\n        if (parenStack.size == lst.length) {\n            res = s\"Yes\"\n        }\n        // if parenthesis are not balanced return No\n        else {\n            res = s\"No\"\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmcycu_qa.scala:18:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparenStack\u001b[0m = mutable.Stack[\u001b[35mBoolean\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpmcycu_qa.scala:43:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            res = \u001b[31ms\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val res\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpmcycu_qa.scala:47:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            res = \u001b[31ms\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val res\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979993
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def isGood(s: String) : Boolean = {\n            val opened = Set(('(',')'))\n            val closed = Set((')',')'))\n            val re = opened.union(closed).union(closed.toSet)\n            val closeParen = if (s == '(') ')' else ')'\n            val openParen = if (s == '(' '(') '(' else ')'\n            re(lst) contains closeParen\n        }\n        if (isGood(lst(0))) {\n            if (isGood(lst(1))) {\n                \"Yes\"\n            } else {\n                \"No\"\n            }\n        } else {\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzac3hp_o.scala:23:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mopenParen\u001b[0m = \u001b[33mif\u001b[0m (s == \u001b[31m'('\u001b[0m \u001b[31m'('\u001b[0m) \u001b[31m'('\u001b[0m \u001b[33melse\u001b[0m \u001b[31m')'\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                               ')' expected, but character literal found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpzac3hp_o.scala:22:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcloseParen\u001b[0m = \u001b[33mif\u001b[0m (s == \u001b[31m'('\u001b[0m) \u001b[31m')'\u001b[0m \u001b[33melse\u001b[0m \u001b[31m')'\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpzac3hp_o.scala:23:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mopenParen\u001b[0m = \u001b[33mif\u001b[0m (s == \u001b[31m'('\u001b[0m \u001b[31m'('\u001b[0m) \u001b[31m'('\u001b[0m \u001b[33melse\u001b[0m \u001b[31m')'\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzac3hp_o.scala:24:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            re(lst) contains closeParen\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (lst : List[String])\n\u001b[31m   |\u001b[0m               Required: (Char, Char)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979996
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val newlst = lst.filter(_ != \"\")\n        var newlstStr = String.join(\"\", newlst)\n        var open = 0\n        var close = 0\n        val newlstStr = newlstStr.grouped(2).map { list =>\n            if(list.length == 0)\n                list\n            else\n                if(list(0) == '(')\n                    open += 1\n                else\n                    close += 1\n        }\n\n        while(open > 0 && close > 0) {\n            if(newlstStr.take(newlstStr.length - open).length <= newlstStr.length - close + 1) {\n                newlstStr = newlstStr.drop(newlstStr.length - open)\n                open -= 1\n                close -= 1\n            }\n            else {\n                open -= 1\n                close -= 1\n            }\n        }\n        val newlstStr2 = newlstStr.grouped(2).map { list =>\n            if(list.length == 0)\n                list\n            else\n                if(list(0) == '(')\n                    list\n                else\n                    list.reverse\n        }\n        if(newlstStr2.toSeq.isEmpty)\n            \"No\"\n        else\n            \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpyv2gh9hy.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewlstStr\u001b[0m = newlstStr.grouped(\u001b[31m2\u001b[0m).map { \u001b[36mlist\u001b[0m =>\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mnewlstStr is already defined as \u001b[33mvariable\u001b[0m \u001b[35mnewlstStr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m(list.length == \u001b[31m0\u001b[0m)\n\u001b[31m24 |\u001b[0m                list\n\u001b[31m25 |\u001b[0m            \u001b[33melse\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m(list(\u001b[31m0\u001b[0m) == \u001b[31m'('\u001b[0m)\n\u001b[31m27 |\u001b[0m                    open += \u001b[31m1\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33melse\u001b[0m\n\u001b[31m29 |\u001b[0m                    close += \u001b[31m1\u001b[0m\n\u001b[31m30 |\u001b[0m        }\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpyv2gh9hy.scala:19:31 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnewlstStr\u001b[0m = String.join(\u001b[31m\"\"\u001b[0m, newlst)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mjoin\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mString\u001b[0m with types\n\u001b[31m   |\u001b[0m (x$0: CharSequence, x$1: Iterable[? <: CharSequence]): String\n\u001b[31m   |\u001b[0m (x$0: CharSequence, x$1: CharSequence*): String\n\u001b[31m   |\u001b[0mmatch arguments ((\u001b[32m\"\"\u001b[0m : String), (newlst : List[String]))\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979993
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        stack.push(\"(\")\n        stack.push(\")\")\n\n        while(!stack.isEmpty) {\n            val s = stack.pop()\n            val len = lst(0).length\n            val idx = s.length - len\n            if(idx <= 0) return \"No\"\n            if(s.equals(lst(idx))) return \"Yes\"\n            stack.push(s)\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprhk9olly.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979991
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val open = Set.empty[String]\n        val close = Set.empty[String]\n        lst.foreach(x => open += x.toLowerCase)\n        lst.foreach(x => close += x.toLowerCase)\n        open.size == close.size\n        val stack = ListBuffer.empty[String]\n        val result = \"Yes\"\n        val stackSize = lst.size + 1\n        for (i <- 0 until stackSize) {\n            val currentChar = lst(i).toLowerCase\n            if (currentChar == '(') stack += currentChar\n            if (currentChar == ')') stack -= currentChar\n            if (stack.size == 0) result += \"Yes\"\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp9i8rwelw.scala:28:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mif\u001b[0m (currentChar == \u001b[31m'('\u001b[0m) stack += currentChar\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmp9i8rwelw.scala:29:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mif\u001b[0m (currentChar == \u001b[31m')'\u001b[0m) stack -= currentChar\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9i8rwelw.scala:30:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mif\u001b[0m (stack.size == \u001b[31m0\u001b[0m) result += \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean result.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979998
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def isValidParens(st: String): Boolean = st.contains(\"(\") && st.contains(\")\")\n        val stack = mutable.Stack[String]()\n        for (i <- 0 to lst.size - 1) {\n            if (isValidParens(lst(i))) {\n                stack += lst(i)\n                while (isValidParens(stack.last)) {\n                    stack += stack.last\n                }\n            }\n        }\n        if (stack.toList.size > 0) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq82vm799.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979995
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val output = mutable.ListBuffer.empty[String]\n        val bracketCounts = mutable.Map[(String, Int), Int]()\n\n        lst.foreach {\n            str =>\n                if(str == \"(\") stack.push str\n                else if(str == \")\") if(stack.isEmpty) output.append(str) else bracketCounts.getOrElse((stack.last, stack.last.length - 1), 1).foreach {\n                    count =>\n                        stack.pop\n                        output.append(stack.last + str)\n                }\n                else if(stack.last.length > 0 && bracketCounts.getOrElse((stack.last, stack.last.length - 1), 1) <= 0) stack.pop\n                else stack.push(str)\n        }\n        if(stack.nonEmpty) output.toString\n        else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpqvo6bs13.scala:24:45 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mif\u001b[0m(str == \u001b[31m\"(\"\u001b[0m) stack.push str\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      expression expected but \u001b[31melse\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvo6bs13.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvo6bs13.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36moutput\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqvo6bs13.scala:20:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbracketCounts\u001b[0m = mutable.Map[(\u001b[35mString\u001b[0m, \u001b[35mInt\u001b[0m), \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659979994
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def go(i : Int, acc : List[String]) : List[String] = \n            if(i <= 0) acc else go(i - 1, acc + lst(i))\n        go(lst.size, lst(0))\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz4quz0m_.scala:19:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mif\u001b[0m(i <= \u001b[31m0\u001b[0m) acc \u001b[33melse\u001b[0m go(i - \u001b[31m1\u001b[0m, acc + lst(i))\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz4quz0m_.scala:20:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        go(lst.size, lst(\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    String\n\u001b[31m   |\u001b[0m                     Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mString\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979999
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        for (item <- lst) {\n            item match {\n                case \"(\" =>\n                    stack.push(item)\n                case \"(\" =>\n                    stack.push(item)\n                case \")\" =>\n                    val temp = stack.pop()\n                    if (stack.empty) {\n                        //print(\"stack: \" + stack + \", item: \" + item)\n                        if (temp == item) {\n                            return \"Yes\"\n                        }\n                    }\n            }\n        }\n        \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp89io4k9w.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659979997
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Your code here\n        val stack = mutable.Stack[String]()\n        val queue = new mutable.Queue[String]()\n        val res = mutable.ListBuffer.empty[String]\n        for(i <- 0 until lst.size){\n            if(lst(i).contains(\"(\")){\n                stack push lst(i)\n            }\n            if(lst(i).contains(\")\")){\n                queue.append(lst(i))\n            }\n        }\n        if(stack.size == 0){\n            res.append(\"No\")\n        }\n        else if(queue.size == 0){\n            res.append(\"Yes\")\n        }\n        else if(stack.size == 1){\n            if(queue.peek().contains(\")\")){\n                res.append(\"Yes\")\n            }\n            else{\n                res.append(\"No\")\n            }\n        }\n        else{\n            while(!stack.empty){\n                val temp = stack.pop()\n                val temp2 = queue.dequeue()\n                if(temp.contains(\"(\") && temp.contains(\")\") && temp2.contains(\"(\") && temp2.contains(\")\")){\n                    res.append(\"Yes\")\n                }\n                else{\n                    res.append(\"No\")\n                }\n            }\n        }\n        res.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdy7wna1h.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdy7wna1h.scala:20:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mqueue\u001b[0m = \u001b[33mnew\u001b[0m mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdy7wna1h.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659979998
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val good = mutable.Set[String]()\n        val goodString = ListBuffer[String]()\n        val badString = ListBuffer[String]()\n\n        def matchParens(st: List[String], st1 : String) : List[String] = {\n            st match {\n                case Nil => st1\n                case h :: t => {\n                    st match {\n                        case Nil => List(h)\n                        case h :: t1 =>\n                            if (st1 == h) {\n                                if (stack.isEmpty)\n                                    List(stack.toList :+ st1)\n                                else {\n                                    val st2 = stack.toList\n                                    if (st2.head == h) {\n                                        stack.toList = st2 :: st1\n                                        st1\n                                    } else {\n                                        st2 :+ st1\n                                    }\n                                }\n                            } else {\n                                if (stack.isEmpty) {\n                                    List(h)\n                                } else if (stack.head == h) {\n                                    stack.toList :+ st1\n                                    stack.toList\n                                } else {\n                                    stack.head :: stack.toList :+ st1\n                                    stack.toList\n                                }\n                            }\n                    }\n                }\n            }\n        }\n\n        for ((a, b) <- lst, c <- stack) {\n            matchParens(b :: a, b)\n        }\n\n        good ++= goodString\n        bad ++= badString\n        goodString.forall(s => good contains s)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E041] Syntax Error: /tmp/tmpm8td35k7.scala:49:50 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m                                    stack.head :: stack.toList :+ st1\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m:: (which is right-associative) and :+ (which is left-associative) have same precedence and may not be mixed\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm8td35k7.scala:58:26 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m        \u001b[33mfor\u001b[0m ((a, b) <- lst, c <- stack) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          ')' expected, but ',' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm8td35k7.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm8td35k7.scala:19:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgood\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpm8td35k7.scala:25:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                \u001b[33mcase\u001b[0m Nil => st1\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (st1 : String)\n\u001b[31m   |\u001b[0m                            Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpm8td35k7.scala:37:40 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                        ",
      "stdout": "",
      "timestamp": 1659980003
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var flag = mutable.HashMap[String, Boolean]()\n        for(elem <- lst.head) {\n            flag(elem) <- false\n        }\n        for((i, j <- 0 until lst.size) <- 0 until lst.size by -1) {\n            flag(lst.head(i)) <- false\n            for(k <- 1 until lst.size) {\n                if(flag(lst.head(i).drop(lst.head(i).length() + 1))) {\n                    flag(lst.head(k)) <- false\n                }\n            }\n        }\n        if(flag(\"(\")) {\n            \"Yes\"\n        } else {\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmps2o96gxp.scala:20:23 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            flag(elem) <- \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^\u001b[0m\n\u001b[31m   |\u001b[0m                       end of statement expected but '<-' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps2o96gxp.scala:22:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m((i, j <- \u001b[31m0\u001b[0m until lst.size) <- \u001b[31m0\u001b[0m until lst.size by -\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^\u001b[0m\n\u001b[31m   |\u001b[0m                  ')' expected, but '<-' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmps2o96gxp.scala:23:30 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            flag(lst.head(i)) <- \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^\u001b[0m\n\u001b[31m   |\u001b[0m                              end of statement expected but '<-' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmps2o96gxp.scala:26:38 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    flag(lst.head(k)) <- \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                end of statement expected but '<-' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps2o96gxp.scala:18:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mflag\u001b[0m = mutable.HashMap[\u001b[35mString\u001b[0m, \u001b[35mBoolean\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659979999
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var s  : List[String] = lst\n        val rev = s.reverse\n        val stack = mutable.Stack[String]()\n        var temp = \"\"\n        for( a <- 0 until s.size) {\n            if( (s(a).equals('(')) )\n                stack += '('\n            else if( (s(a).equals(')')) )\n                stack += ')'\n            else if( (s(a).equals('(')) && (stack.isEmpty) ) {\n                temp = s(a)\n                s += temp\n                stack += '('\n            }\n            else if( (s(a).equals(')')) && (stack.nonEmpty) ) {\n                temp = s(a)\n                s += temp\n                stack += ')'\n            }\n            else {\n                if(stack.nonEmpty)\n                    s += temp\n                s += temp\n                stack += (s(a))\n            }\n        }\n        if(stack.nonEmpty)\n            s += temp\n        s += temp\n        s = s.reverse\n        if(s.indexOf('(') == s.lastIndexOf(')') && s.indexOf(')') < s.size) {\n            if(s.indexOf('(') > s.lastIndexOf(')'))\n                return \"Yes\"\n            else\n                return \"No\"\n        }\n        else\n            return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppuk5i2vt.scala:20:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppuk5i2vt.scala:29:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                s += temp\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppuk5i2vt.scala:34:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                s += temp\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppuk5i2vt.scala:39:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                    s += temp\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppuk5i2vt.scala:40:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                s += temp\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppuk5i2vt.scala:45:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m            s += temp\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppuk5i2vt.scala:46:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        s += temp\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n7 errors found\n",
      "stdout": "",
      "timestamp": 1659980003
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val l = lst.map(x => if (x == \"(\") 1 else 0).sum\n        val r = lst.map(x => if (x == \")\") 1 else 0).sum\n        if (l+r == 0)\n            \"Yes\"\n        else\n            \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpav_2801p.scala:26)\n\tat Problem.main(tmpav_2801p.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980005
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val result = mutable.Set[String]()\n\n        lst.foreach { e => \n            if (e==\"(\") stack.push(\"(\")\n            else if (e==\")\") stack.push(\")\")\n            else stack += e\n        }\n\n        if (stack.size!=1){\n            return(\"No\")\n        }\n\n        val topElement = stack.pop()\n        if (topElement==\")\"){\n            result.add(topElement)\n        }\n\n        if (stack.size==1){\n            if (result.size == lst.size){\n                return(\"Yes\")\n            }\n            return(\"No\")\n        }\n\n        while (stack.size!=0){\n            val nextElement = stack.pop()\n            val nextResult = result.pop()\n\n            if (nextElement==\"(\"){\n                stack.push(nextElement)\n            }\n\n            if (nextElement==\")\"){\n                if (nextResult!=topElement){\n                    return(\"No\")\n                }\n            }\n            else if (nextResult!=topElement){\n                return(\"No\")\n            }\n\n            if (nextResult==topElement){\n                if (result.size == lst.size){\n                    return(\"Yes\")\n                }\n            }\n        }\n\n        return(\"No\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1t0w6hjb.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1t0w6hjb.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659979999
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val allParens = lst._2.flatMap { x =>\n            if (x.contains(\")\")) Some(x.dropRight(1))\n            else Some(x.takeRight(1))\n        }\n        if (allParens.size % 2 != 0) \"No\"\n        else if (allParens.head == allParens.tail) \"Yes\"\n        else matchParens(allParens.init)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmfppwz0d.scala:18:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mallParens\u001b[0m = lst._2.flatMap { \u001b[36mx\u001b[0m =>\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value _2 is not a member of List[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980003
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        //var stack = List[List[String]]()\n        var stack = mutable.Stack[List[String]]()\n        var flag = false\n\n        for(i <- 0 until lst.length){\n            var next = lst(i)\n\n            while(!stack.contains(next)){\n                stack.push(next)\n                next = lst(i+1)\n            }\n\n            if(!flag){\n                if(next.equals(\"(\")){\n                    stack.push(next)\n                    next = lst(i+1)\n                }\n                else{\n                    flag = true\n                }\n            }\n            if(next.equals(\"(\")){\n                stack.push(\"(\")\n                next = lst(i+1)\n            }\n            else if(stack.contains(next)){\n                stack.pop\n                next = stack.last\n            }\n            if(stack.last.equals(\")\") && !stack.last.equals(\"(\")){\n                stack.last = \"(\"\n                stack.pop()\n            }\n            if(stack.last.equals(\"(\") && !stack.last.equals(\")\")){\n                stack.last = \"(\"\n                stack.pop()\n            }\n            if(!stack.last.equals(\"(\") && !stack.last.equals(\")\")){\n                stack.last += \")\"\n            }\n        }\n\n        if(stack.last == \"(\")\n            return \"Yes\"\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppy5z644_.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m]]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980001
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      lst.foldLeft(\"No\") {\n        case (acc, x) => if (x contains \"(\") acc.append(\"Yes\") else acc\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0w3zk03_.scala:19:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mcase\u001b[0m (acc, x) => \u001b[33mif\u001b[0m (x contains \u001b[31m\"(\"\u001b[0m) acc.append(\u001b[31m\"Yes\"\u001b[0m) \u001b[33melse\u001b[0m acc\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value append is not a member of String\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980003
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Use a stack to keep track of the number of '(' and ')'\n        // to see if we can concatenate without making any mistakes.\n        // The base case: if list is empty, return 'No'\n        // The base case: if there are zero '(', return 'No'\n        // The base case: if there are zero ')', return 'Yes'\n        // The general case:\n        // Create a stack\n        // While there are elements left in list 'lst'\n        //   Pop the top element from the stack\n        //   Push the element '(element)'\n        //   If '(element)' is the top element of the stack, add one\n        //   If ')' is top element of the stack, remove one\n        //   If '(element)' is now empty, repeat from start\n        //   If ')' is now empty, repeat from start\n        //   If '(element)' has the same number of '(' and ')' as ')', add one\n        //   If ')' has the same number of '(' and ')' as '(', remove one\n        //   If '(element)' has the same number of ')' and '(' as '(', remove one\n        //   If '(element)' has the same number of ')' and '(', add one\n        //   If '(element)' has the same number of ')' and '(', remove one\n        // If no element left\n        // return 'No'\n        val stack = new Stack[String]\n        var retVal = \"No\"\n        lst.foreach { elem =>\n            val isOpen = elem.head() == '('\n            val isClose = elem.head() == ')'\n            val count = if (isOpen) 1 else -1\n            if (stack.size == 0 || (isOpen && count == 1))\n                stack.push(elem)\n            else if (isClose && stack.size == 1)\n                stack.pop()\n            else if (stack.size == 1 && (count == -1 || count == 1))\n                stack.append(elem)\n            else if (stack.size == 1 && (count == -1 || count == -1))\n                stack.pop()\n            else if (stack.size == 1 && (count < 0 || count == 0))\n                stack.append(elem)\n            else if (stack.size == 1 && (count > 0 || count == 0))\n                stack.prepend(elem)\n        }\n        if (stack.size == 0)\n            retVal = \"No\"\n        else if (stack.size == 1)\n            retVal = \"Yes\"\n        else if (stack.size == 2 && (stack.head == stack.last) && stack.pop() == stack.head)\n            retVal = \"Yes\"\n        else if (stack.size == 2 && (stack.head == stack.last) && stack.pop() == stack.last)\n            retVal = \"Yes\"\n        else\n            retVal = \"No\"\n        return retVal\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6q011ic8.scala:42:30 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36misOpen\u001b[0m = elem.head() == \u001b[31m'('\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 \u001b[33mmethod\u001b[0m \u001b[35mhead\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mStringOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6q011ic8.scala:43:31 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36misClose\u001b[0m = elem.head() == \u001b[31m')'\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 \u001b[33mmethod\u001b[0m \u001b[35mhead\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mStringOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980003
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        var res   = List[String]()\n        var isOpen = false\n        lst.foreach(l => stack += l)\n        while(stack.nonEmpty) {\n            val s = stack.pop()\n            if(!isOpen) {\n                if(s.equals(\"(\")) {\n                    isOpen = true\n                } else if(s.equals(\")\")) {\n                    if(!isOpen) {\n                        res += \"No\"\n                    } else {\n                        res += \"Yes\"\n                    }\n                    isOpen = false\n                } else if(!s.isEmpty) {\n                    res += \"Yes\"\n                }\n            }\n        }\n        if(res.nonEmpty) {\n            res.head\n        } else {\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_ptcd40w.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_ptcd40w.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                        res += \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_ptcd40w.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                        res += \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_ptcd40w.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                    res += \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659980005
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Use stack to check if there is any balance in lst\n        val stack = new Stack[String]\n        for(i <- 0 until lst.size) {\n            stack += lst(i)\n            while (stack.size > 0 ) {\n                val current = stack.pop\n                val next = lst(i + 1)\n                val nextIsParen = next.headOption.map(c => c == ')')\n                val currentIsParen = current.headOption.map(c => c == ')')\n                if ((!nextIsParen && currentIsParen) || nextIsParen && currentIsParen) {\n                    stack += current\n                }\n            }\n        }\n        if (stack.size == lst.size) {\n            return \"Yes\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyy1_af_i.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                \u001b[33mif\u001b[0m ((!nextIsParen && currentIsParen) || nextIsParen && currentIsParen) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value unary_! is not a member of Option[Boolean]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980004
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Your code goes here\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl2sadi6x.scala:17:51 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmatchParens\u001b[0m(\u001b[36mlst\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m]) : \u001b[35mString\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Found:    Unit\n\u001b[31m   |\u001b[0m                                                   Required: String\n\u001b[31m18 |\u001b[0m        \u001b[34m// Your code goes here\u001b[0m\n\u001b[31m19 |\u001b[0m    }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980004
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val m = lst.map(_.contains(\"(\")).toList.foldLeft(false)(_ && _)\n        if (m) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnnlth_sx.scala:22)\n\tat Problem.main(tmpnnlth_sx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980007
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def findParen(s  : String) : List[Int] = {\n            def openParen(r : String) : List[Int] = {\n                val re = r.split(\"\\\\(\")\n                val cnt = 0\n                re.map { x =>\n                    if (x.equals(\"()\")) {\n                        cnt+=1\n                    }\n                    else if (x.equals(\")\")) {\n                        cnt+=-1\n                    }\n                    cnt\n                }\n            }\n            def closeParen(r : String) : List[Int] = {\n                val re = r.split(\"\\\\)\")\n                val cnt = 0\n                re.map { x =>\n                    if (x.equals(\"(\")) {\n                        cnt+=1\n                    }\n                    else if (x.equals(\")\")) {\n                        cnt+=-1\n                    }\n                    cnt\n                }\n            }\n\n            val ops = openParen(s) + closeParen(s)\n            val total = ops.sum\n            val pos = ops.min\n            val flag = ops.foldLeft[List[Int]](0)(_+_)\n            if ((flag == total) || (flag == total-1)) {\n                println(s\"flag==total=$flag,total=$total,pos=$pos,flag=$(flag<0)\")\n                if (flag < 0){\n                    return \"No\"\n                }\n                else {\n                    return \"Yes\"\n                }\n            }\n            else{\n                println(s\"flag!=total=$flag,total=$total,pos=$pos,flag=$(flag<0)\")\n                if (flag < 0) {\n                    return \"No\"\n                }\n                else {\n                    return \"Yes\"\n                }\n            }\n        }\n        var flag = 0\n        val result = lst\n            .map {\n                s => findParen(s)\n            }\n            .fold(\"\") { (a, b) => a + b.toString}\n        if (result.equals(\"Yes\")){\n            return \"Yes\"\n        }\n        else{\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpy_l67sbs.scala:51:71 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m                println(\u001b[31ms\"flag==total=\u001b[0m$flag\u001b[31m,total=\u001b[0m$total\u001b[31m,pos=\u001b[0m$pos\u001b[31m,flag=$(flag<0)\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0minvalid string interpolation: `$$`, `$\"`, `$`ident or `$`BlockExpr expected\n\u001b[31m\u001b[31m-- Error: /tmp/tmpy_l67sbs.scala:60:71 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m                println(\u001b[31ms\"flag!=total=\u001b[0m$flag\u001b[31m,total=\u001b[0m$total\u001b[31m,pos=\u001b[0m$pos\u001b[31m,flag=$(flag<0)\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0minvalid string interpolation: `$$`, `$\"`, `$`ident or `$`BlockExpr expected\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy_l67sbs.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                        cnt+=\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean cnt.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy_l67sbs.scala:27:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                        cnt+=-\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value +=- is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy_l67sbs.scala:37:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                        cnt+=\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean cnt.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy_l67sbs.scala:40:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                        cnt+=-\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value +=- is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy_l67sbs.scala:46:35 --------------------",
      "stdout": "",
      "timestamp": 1659980009
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var good = lst.head match {\n            case \"\" => \"\"\n            case s => s\n        }\n        val stack = mutable.Stack[Int]()\n        val pos = 0\n        for (ele <- lst) {\n            ele match {\n                case \"\" => stack.append(-1)\n                case c =>\n                    val index = if (pos == 0) -1 else stack.pop\n                    if (c == '(') {\n                        stack.append(index)\n                    } else if (c == ')') {\n                        if (index == -1) {\n                            bad += \"(\" + c + \")\"\n                        } else {\n                            good += c + \")\"\n                        }\n                        pos += 1\n                    }\n            }\n        }\n        if (good != \"\") good else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7l_8vbre.scala:22:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp7l_8vbre.scala:29:24 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    \u001b[33mif\u001b[0m (c == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmp7l_8vbre.scala:31:31 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (c == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7l_8vbre.scala:33:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                            bad += \u001b[31m\"(\"\u001b[0m + c + \u001b[31m\")\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: bad\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l_8vbre.scala:37:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                        pos += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean pos.!=?\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659980006
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // use stack to check if brackets are balanced\n        var stack = new Stack[List[String]]()\n        for ( a <- lst ) {\n            if ( !a.contains(\"(\") && !a.contains(\")\") ) {\n                return \"No\"\n            }\n            else if ( a == \"(\" ) {\n                stack.append( List(a) )\n            }\n            else if ( a == \")\" ) {\n                val temp = stack.pop()\n                if ( temp.size == 0 ) {\n                    return \"No\"\n                }\n                val temp = stack.pop()\n                stack.append( List( temp(1), a ) )\n            }\n        }\n        if ( stack.size == 0 ) {\n            return \"No\"\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp10jl9y43.scala:32:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mtemp\u001b[0m = stack.pop()\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mtemp is already defined as \u001b[33mvalue\u001b[0m \u001b[35mtemp\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980003
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stg = lst.map(x => if (x.contains(\")\")) x else x + \")\")\n        val arr = stg.toArray\n        val stack = mutable.Stack[String]()\n        val stackP = mutable.Stack[Boolean]()\n\n        var count = 0\n        for (i <- 0 until arr.length) {\n            count += arr.length\n            if (arr.isDefinedAt(i)) {\n                if (stackP.contains(arr(i))) {\n                    stackP -= 1\n                    if (stackP.size == 0) {\n                        stackP += true\n                    }\n                } else {\n                    stackP += 1\n                    if (stackP.size == 0) {\n                        stackP += false\n                    }\n                }\n            }\n            if (stack.size == count) {\n                if (stackP == 1) {\n                    if (stack.pop() == \"No\") {\n                        return \"No\"\n                    }\n                } else {\n                    if (stack.pop() == \"No\") {\n                        return \"No\"\n                    }\n                }\n            }\n            stack += arr(i)\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq7_llvpz.scala:20:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq7_llvpz.scala:21:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackP\u001b[0m = mutable.Stack[\u001b[35mBoolean\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980004
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def good(lst1: List[String], lst2: List[String]) : Boolean = {\n            var flag = false\n            var idx1 : Int = 0\n            var idx2 : Int = 0\n            while(idx1 < lst1.length && idx2 < lst2.length) {\n                if (lst1(idx1) != lst2(idx2)) {\n                    return false\n                }\n                if (lst1(idx1) == '(') {\n                    if (lst2(idx2) == ')') {\n                        flag = true\n                    } else {\n                        idx2 += 1\n                    }\n                } else {\n                    if (lst2(idx2) == ')') {\n                        idx2 += 1\n                    } else {\n                        flag = false\n                        return false\n                    }\n                }\n                idx1 += 1\n                idx2 += 1\n            }\n            return flag\n        }\n        val flag = lst.length <= 1\n        if (flag) {\n            \"Yes\"\n        } else {\n            val len = lst.length\n            val first = lst(0)\n            val rest = lst.drop(1)\n            if (good(first, rest)) {\n                val newlist = first :: rest\n                if (good(first, newlist)) {\n                    matchParens(newlist)\n                } else if (newlist.length == len) {\n                    matchParens(newlist)\n                } else {\n                    \"No\"\n                }\n            } else {\n                \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpn8yech12.scala:26:20 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (lst1(idx1) == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpn8yech12.scala:27:24 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                    \u001b[33mif\u001b[0m (lst2(idx2) == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpn8yech12.scala:33:24 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                    \u001b[33mif\u001b[0m (lst2(idx2) == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn8yech12.scala:52:21 --------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m            \u001b[33mif\u001b[0m (good(first, rest)) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    (first : String)\n\u001b[31m   |\u001b[0m                     Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn8yech12.scala:54:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m                \u001b[33mif\u001b[0m (good(first, newlist)) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (first : String)\n\u001b[31m   |\u001b[0m                         Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659980008
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val isBalanced = {\n            def check(pst: Int): Boolean = {\n                val left = lst.head\n                val right = lst.last\n                if(pst > left) false else left == right || (check(pst+1) && check(pst-1))\n            }\n            check(0);\n        }\n        if(lst.isEmpty)\n            \"No\"\n        else if(isBalanced) \"Yes\"\n        else matchParens(lst.tail);\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpsqduskh6.scala:22:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                \u001b[33mif\u001b[0m(pst > left) \u001b[31mfalse\u001b[0m \u001b[33melse\u001b[0m left == right || (check(pst+\u001b[31m1\u001b[0m) && check(pst-\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m>\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Boolean\n\u001b[31m   |\u001b[0m  (x: Float): Boolean\n\u001b[31m   |\u001b[0m  (x: Long): Boolean\n\u001b[31m   |\u001b[0m  (x: Int): Boolean\n\u001b[31m   |\u001b[0m  (x: Char): Boolean\n\u001b[31m   |\u001b[0m  (x: Short): Boolean\n\u001b[31m   |\u001b[0m  (x: Byte): Boolean\n\u001b[31m   |\u001b[0m match arguments ((left : String))\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980006
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val ls = lst.map{\n            case s => if (s.contains(\"(\")) 1 else 0\n        }\n        ls.sum == ls.sum * ls.sum\n            ? \"Yes\"\n            : \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptdgijlu1.scala:22:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        ls.sum == ls.sum * ls.sum\n\u001b[31m22 |\u001b[0m            ? \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m            value ? is not a member of Int.\n\u001b[31m   |\u001b[0m            Note that `?` is treated as an infix operator in Scala 3.\n\u001b[31m   |\u001b[0m            If you do not want that, insert a `;` or empty line in front\n\u001b[31m   |\u001b[0m            or drop any spaces behind the operator.\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980006
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) \"No\"\n        else {\n            var str = \"\"\n            val stack = new Stack[String]\n            stack.push(\"(\")\n            while (!stack.empty) {\n                str = str + stack.pop\n                val lst2 = lst.map(_ + str).toList\n                if (lst2.size == 2) \"Yes\"\n                else {\n                    stack.push(lst2(1))\n                    stack.push(lst2(0))\n                }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf2f055ed.scala:23:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mwhile\u001b[0m (!stack.empty) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue unary_! is not a member of scala.collection.mutable.Stack[String @uncheckedVariance]\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmpf2f055ed.scala:26:36 ----------------\u001b[0m\u001b[0m\n\u001b[33m26 |\u001b[0m                \u001b[33mif\u001b[0m (lst2.size == \u001b[31m2\u001b[0m) \u001b[31m\"Yes\"\u001b[0m\n\u001b[33m\u001b[33m   |\u001b[0m                                    ^^^^^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression does nothing in statement position; you may be omitting necessary parentheses\n\u001b[33m   |\u001b[0m\n\u001b[33m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 warning found\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980010
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val inParens = lst.foldLeft(false) { (acc,s) =>\n            if (s.isEmpty) acc\n            else acc && s.head == '('\n        }\n        val lc = lst.foldLeft(\"()\") { (acc,s) =>\n            if (acc && s.head == ')') acc // already have a valid one after this\n            else (acc + \"()\") + s\n        }\n        if (inParens && !inParens.reverse.contains(\")\")) // if we are left with ')' at begining, return 'No'\n            \"No\"\n        else if (lc.length != lst.length)\n            \"No\" // if we have extra chars ('), return 'No'\n        else if (lc == \"()\") \"Yes\"\n        else \"No\" // if we are left with nothing at begining, return 'No'\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp84cz21_w.scala:23:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (acc && s.head == \u001b[31m')'\u001b[0m) acc \u001b[34m// already have a valid one after this\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value && is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp84cz21_w.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mif\u001b[0m (inParens && !inParens.reverse.contains(\u001b[31m\")\"\u001b[0m)) \u001b[34m// if we are left with ')' at begining, return 'No'\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value reverse is not a member of Boolean\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980011
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Initialization\n        var goodStrings = ListBuffer[String]()\n        var goodStringsSize = lst.size\n        var openStrings = 0\n        var closeStrings = 0\n        // Part 1 check and count\n        for (s <- lst) {\n            if (s == \"()\") {\n                openStrings += 1\n            } else if ((s != \"()\") && (s != \")\")) {\n                return \"No\"\n            }\n            closeStrings += 1\n        }\n        // Part 2 check and count\n        for (i<- 0 to lst.size - 1) {\n            if (lst(i) == \"(\") {\n                val stringCount = lst(i + 1)\n                val openCount = closeStrings - openStrings\n                if (stringCount < openCount) {\n                    return \"No\"\n                }\n                if (stringCount == openCount) {\n                    val stringSum = lst(i) + lst(i + 1)\n                    goodStrings += stringSum\n                    goodStringsSize += 1\n                    openStrings = 0\n                    closeStrings = 0\n                }\n            } else if (lst(i) == \")\") {\n                val stringCount = lst(i + 1)\n                val openCount = openStrings - closeStrings\n                if (stringCount < openCount) {\n                    return \"No\"\n                }\n                if (stringCount == openCount) {\n                    val stringSum = lst(i) + lst(i + 1)\n                    goodStrings += stringSum\n                    goodStringsSize += 1\n                    openStrings = 0\n                    closeStrings = 0\n                }\n            }\n        }\n        // Part 3 check\n        if (goodStringsSize != goodStrings.size) {\n            return \"No\"\n        }\n        for (i<- 0 to goodStringsSize - 1) {\n            if (goodStrings(i) != goodStrings(i + 1)) {\n                return \"No\"\n            }\n        }\n        // Part 4 check\n        val stringCount = goodStrings.last\n        val openCount = closeStrings - openStrings\n        if (stringCount < openCount) {\n            return \"No\"\n        }\n        if (stringCount == openCount) {\n            val stringSum = goodStrings.head + goodStrings.last\n            goodStrings += stringSum\n            goodStringsSize += 1\n            openStrings = 0\n            closeStrings = 0\n        }\n        // Part 5 check\n        goodStringsSize += 1\n        for (i<- 0 to goodStringsSize - 1) {\n            if (goodStrings(i) != goodStrings(i + 1)) {\n                return \"No\"\n            }\n        }\n        // Part 6 check\n        val stringCount = goodStrings.last\n        val openCount = openStrings - closeStrings\n        if (stringCount < openCount) {\n            return \"No\"\n        }\n        if (stringCoun\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpb734xitj.scala:98:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m98 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpb734xitj.scala:92:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstringCount\u001b[0m = goodStrings.last\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mstringCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mstringCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpb734xitj.scala:93:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m93 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopenCount\u001b[0m = openStrings - closeStrings\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mopenCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mopenCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb734xitj.scala:37:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                \u001b[33mif\u001b[0m (stringCount < openCount) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (openCount : Int)\n\u001b[31m   |\u001b[0m                                  Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpb734xitj.scala:40:20 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                \u001b[33mif\u001b[0m (stringCount == openCount) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         Values of types String and Int cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb734xitj.scala:50:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m                \u001b[33mif\u001b[0m (stringCount < openCount) {\n\u001b[31m\u001b[31m   |\u001b[",
      "stdout": "",
      "timestamp": 1659980013
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var lst1 = lst.tail\n        var lst2 = lst.head\n        var isMatching = false\n        var isTrue = false\n        var i = -1\n        while (!isMatching) {\n            i +=1\n            if (lst1(i) != lst2(i)) {\n                isMatching = true\n            } else {\n                if (lst2(i) == \"(\") {\n                    lst1 = lst1.tail\n                    lst2 = lst2.head\n                } else if (lst2(i) == \")\") {\n                    lst1 = lst1.head\n                    lst2 = lst2.tail\n                } else {\n                    isMatching = false\n                }\n            }\n        }\n        if (isTrue) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp616nuxul.scala:25:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (lst1(i) != lst2(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmp616nuxul.scala:28:20 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33mif\u001b[0m (lst2(i) == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp616nuxul.scala:30:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                    lst2 = lst2.head\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    Char\n\u001b[31m   |\u001b[0m                           Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp616nuxul.scala:31:27 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst2(i) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp616nuxul.scala:32:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    lst1 = lst1.head\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    String\n\u001b[31m   |\u001b[0m                           Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mString\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659980013
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = new Stack[String]()\n        for (x <- lst) {\n            if (x.equals(\"(\")) {\n                stack.push(x)\n            } else if (x.equals(\")\")) {\n                val lastStacked = stack.pop()\n                if (lastStacked == x) {\n                    if (stack.isEmpty) {\n                        \"No\"\n                    } else {\n                        \"Yes\"\n                    }\n                } else {\n                    \"No\"\n                }\n            } else {\n                \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv642d1t3.scala:19:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mfor\u001b[0m (x <- lst) {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Unit\n\u001b[31m   |\u001b[0m        Required: String\n\u001b[31m20 |\u001b[0m            \u001b[33mif\u001b[0m (x.equals(\u001b[31m\"(\"\u001b[0m)) {\n\u001b[31m21 |\u001b[0m                stack.push(x)\n\u001b[31m22 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x.equals(\u001b[31m\")\"\u001b[0m)) {\n\u001b[31m23 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mlastStacked\u001b[0m = stack.pop()\n\u001b[31m24 |\u001b[0m                \u001b[33mif\u001b[0m (lastStacked == x) {\n\u001b[31m25 |\u001b[0m                    \u001b[33mif\u001b[0m (stack.isEmpty) {\n\u001b[31m26 |\u001b[0m                        \u001b[31m\"No\"\u001b[0m\n\u001b[31m27 |\u001b[0m                    } \u001b[33melse\u001b[0m {\n\u001b[31m28 |\u001b[0m                        \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m29 |\u001b[0m                    }\n\u001b[31m30 |\u001b[0m                } \u001b[33melse\u001b[0m {\n\u001b[31m31 |\u001b[0m                    \u001b[31m\"No\"\u001b[0m\n\u001b[31m32 |\u001b[0m                }\n\u001b[31m33 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m34 |\u001b[0m                \u001b[31m\"No\"\u001b[0m\n\u001b[31m35 |\u001b[0m            }\n\u001b[31m36 |\u001b[0m        }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980011
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Use dynamic programming\n        // A solution in O(n^2) would be: O(n^2*M), M is the maximum length\n        var maxLength = 0\n        val arr1 = lst(0)\n        var count = 0\n        var cur = 0\n        var arr2 = lst(1)\n        while (cur < arr2.length) {\n            if (arr2(cur) == '(') {\n                count += 1\n            }\n            if (arr2(cur) == ')') {\n                count -= 1\n            }\n            if (arr1(cur) == arr2(cur) && count <= 0) {\n                maxLength += 1\n            }\n            cur += 1\n        }\n        var ans = \"\"\n        var count1 = 0\n        var count2 = 0\n        while (count > 0) {\n            if (count1 == maxLength) {\n                ans += arr1(count1) + arr2(count2)\n                count1 += 1\n                count2 += 1\n            } else {\n                ans += arr1(count1)\n                count1 += 1\n            }\n            if (count2 == maxLength) {\n                ans += arr2(count2)\n                count2 += 1\n            } else {\n                ans += arr2(count2)\n                count2 += 1\n            }\n            count -= 1\n        }\n        if (maxLength == 0) {\n            ans = \"Yes\"\n        } else {\n            ans = \"No\"\n        }\n        return ans\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: String index out of range: 4\n\tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\tat scala.collection.StringOps$.apply$extension(StringOps.scala:185)\n\tat Problem$.matchParens(tmptl3t7is1.scala:32)\n\tat Problem$.main(tmptl3t7is1.scala:69)\n\tat Problem.main(tmptl3t7is1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980016
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var stack = List[String]()\n        for (i <- 0 until lst.size) {\n            if (lst(i).contains(\"(\") && lst(i).contains(\")\")) {\n                if (stack.contains(lst(i) + lst(i+1))) {\n                    return \"No\"\n                } else {\n                    stack += lst(i) + lst(i+1)\n                }\n            }\n        }\n        \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcl7658q6.scala:24:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                    stack += lst(i) + lst(i+\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980014
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val st = new scala.collection.mutable.HashMap[Int, List[String]]()\n        for (s <- lst) if (st.contains(s.length)) {\n            if (st.apply(s.length).nonEmpty) st += s.length -> List(s)\n            else st += s.length -> List()\n        }\n        if (st.size != lst.length) \"No\" else if (st.size == 1) st.apply(0) else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwts280cy.scala:23:71 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (st.size != lst.length) \u001b[31m\"No\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (st.size == \u001b[31m1\u001b[0m) st.apply(\u001b[31m0\u001b[0m) \u001b[33melse\u001b[0m \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mString\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980015
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Scan the first string and find the balance of open and close\n        // parentheses, if they have balance then return 'Yes', otherwise return 'No'\n        val s = lst(0)\n        def isBalance(s1: String, s2: String): Boolean = {\n            if (s1.isEmpty)\n                true\n            else if (s2.isEmpty)\n                false\n            else (s1 startsWith s2) || (s2 startsWith s1)\n        }\n\n        var balance = 0\n        var open = 0\n        var close = 0\n        for (str <- lst) {\n            if (str == \"(\")\n                open += 1\n            if (str == \")\")\n                close += 1\n            if (open == close)\n                balance += close\n        }\n        if (balance == 0 || balance == 2)\n            return \"Yes\"\n        else\n            return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpxs3yp1e8.scala:47)\n\tat Problem.main(tmpxs3yp1e8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980017
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val lst2 = lst.map(s => List(s)).toList\n        val stack = mutable.Stack[List[String]]()\n        lst2.foreach(x => stack.push(List(x)))\n        val lastElement = stack.last.last\n        if(stack.last.isEmpty) lastElement.foldLeft(\"No\") { (a, e) => a + e }\n        else {\n            var temp = \"\"\n            var goodString = \"\"\n            val len = lst2.length\n            for(i <- 0 until len) {\n                val nextElement = stack.last.dropRight(1).head\n                val nextElementStack = stack.last.dropRight(1).tail\n                val nextElementStackLast = nextElementStack.last\n                val nextElementStackLen = nextElementStack.length\n                val elementToCheck = lst2.apply(i)\n                if(nextElementStackLast.contains(elementToCheck)) {\n                    val temp1 = nextElementStackLast.take(nextElementStackLen - 1).mkString\n                    val temp2 = nextElementStackLast.drop(nextElementStackLen - 1).mkString\n                    if(temp1 == temp2) {\n                        goodString = temp\n                        stack.last.takeRight(nextElementStackLen - 1).foreach(stack.last.add)\n                        break\n                    } else {\n                        temp = temp1 + elementToCheck + temp2\n                        stack.last.dropRight(1).foreach(stack.last.add)\n                        break\n                    }\n                } else {\n                    temp = temp + elementToCheck\n                }\n            }\n            goodString\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7vosfve1.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m]]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7vosfve1.scala:39:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                        break\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7vosfve1.scala:43:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                        break\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980012
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Convert list to map by removing duplicate values\n        // If all values in the map are same then return \"Yes\"\n        // Else return \"No\"\n        val map: Map[String, Int] = lst.toMap.toList.reverse.groupBy(x => x).mapValues(_.size)\n        val keys = map.keys.toList\n        val values = map.values.toList\n        val yes = keys.size == values.size && keys.forall(x => x == values.head)\n        if(yes) {\n            \"Yes\"\n        } else {\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpl5wv0jin.scala:21:45 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmap\u001b[0m: \u001b[35mMap\u001b[0m[\u001b[35mString\u001b[0m, \u001b[35mInt\u001b[0m] = lst.toMap.toList.reverse.groupBy(\u001b[36mx\u001b[0m => x).mapValues(_.size)\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Cannot prove that String <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                     where:    K is a type variable\n\u001b[31m   |\u001b[0m                                               V is a type variable\n\u001b[31m   |\u001b[0m                                     .\n\u001b[31m\u001b[31m-- Error: /tmp/tmpl5wv0jin.scala:24:63 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36myes\u001b[0m = keys.size == values.size && keys.forall(\u001b[36mx\u001b[0m => x == values.head)\n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         Values of types String and Int cannot be compared with == or !=\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980016
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var result = ListBuffer[String]()\n        def matchParens(lst : List[String], acc : List[String], stack : List[String]) : String = {\n            if(!lst.isEmpty) {\n                acc :+ lst(0)\n                lst :- lst(0)\n                if(!stack.contains(lst(0)) && acc.isEmpty && lst(0).equals(\"(\") && lst(1).equals(\")\")) {\n                    result :+= \"Yes\"\n                } else {\n                    matchParens(lst, acc, acc :+ lst(0))\n                }\n            } else {\n                result :+= \"No\"\n            }\n        }\n        matchParens(lst,ListBuffer[String](),List[String]())\n        result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcenpkfon.scala:22:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                lst :- lst(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         value :- is not a member of List[String] - did you mean lst.:+?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcenpkfon.scala:24:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                    result :+= \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    Unit\n\u001b[31m   |\u001b[0m                    Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcenpkfon.scala:29:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                result :+= \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    Unit\n\u001b[31m   |\u001b[0m                Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcenpkfon.scala:32:42 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        matchParens(lst,ListBuffer[\u001b[35mString\u001b[0m](),List[\u001b[35mString\u001b[0m]())\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    scala.collection.mutable.ListBuffer[String]\n\u001b[31m   |\u001b[0m                   Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659980016
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val m = lst.map(x => (x match {\n            case \"(\" => 1\n            case \")\" => -1\n            case _ => 0\n        })).foldLeft(0)(_ + _)\n        lst.map(x => {\n            if (x < \"(\" || x > \")\") {\n                return \"No\"\n            }\n            if (x < m) x else \"Yes\"\n        }).foldLeft(\"Yes\")(\n            (acc, x) => {\n                val f = acc\n                if (f==\"Yes\" && x == \"Yes\") \"Yes\" else \"No\"\n            }\n        )\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpod9_rmb5.scala:27:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (x < m) x \u001b[33melse\u001b[0m \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    (m : Int)\n\u001b[31m   |\u001b[0m                    Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980016
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = Stack[String]()\n        val good = \"Yes\"\n        lst.foreach( x =>\n            if(x.startsWith(\"(\") && x.endsWith(\")\")){\n                stack.push(x)\n            }\n            if(stack.nonEmpty){\n                var i = 0\n                var last = 0\n                while (i < stack.size) {\n                    val n = stack.length - i\n                    var j = 0\n                    var last_n = 0\n                    while(j < stack.size) {\n                        val m = stack.length - j\n                        val p0 = stack(i).length\n                        val p1 = stack(m).length\n                        if(n > 0 && m > 0) {\n                            last_n = math.min(p0, p1)\n                            if(last_n == 0){\n                                if(stack(n).startsWith(\"(\") && stack(m).endsWith(\")\") && stack(i + 1).startsWith(\"(\") && stack(m).endsWith(\")\")){\n                                    good += \"Yes\"\n                                    return good\n                                }\n                            }\n                            if(last_n == 1) {\n                                if(stack(n).endsWith(\"(\") && stack(m).endsWith(\")\") && stack(i + 1).startsWith(\"(\") && stack(m).endsWith(\")\")){\n                                    good += \"Yes\"\n                                    return good\n                                }\n                            }\n                            if(last_n == 2) {\n                                if(stack(n).endsWith(\"(\") && stack(m).endsWith(\")\") && stack(i + 1).endsWith(\"(\") && stack(m).endsWith(\")\")){\n                                    good += \"Yes\"\n                                    return good\n                                }\n                            }\n                        }\n                        j += 1\n                    }\n                    i +=1\n                }\n            }\n        )\n        good\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0l63rwr8.scala:39:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                                    good += \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              value += is not a member of String - did you mean good.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0l63rwr8.scala:45:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                                    good += \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              value += is not a member of String - did you mean good.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0l63rwr8.scala:51:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m                                    good += \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              value += is not a member of String - did you mean good.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980016
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // The first and last elements of lst are empty.\n        val lst_1 = lst.take(1).reverse\n        val lst_2 = lst.drop(1).reverse\n        val lst_3 = lst_2.take(lst_2.size - 1).reverse\n        val lst_4 = lst_3.take(lst_3.size - 1).reverse\n        if (lst_4.size < lst_2.size) return \"No\"\n        if (lst_3.size < lst_1.size) return \"No\"\n        if (lst_4.size == lst_2.size && lst_4.size == lst_1.size) lst_4.head\n        else {\n            val lst_5 = lst_4.takeWhile(_ != \"(\")\n            val lst_6 = lst_5.takeWhile(_ != \")\")\n            val lst_7 = lst_5.dropWhile(_ != \"(\")\n            val lst_8 = lst_7.takeWhile(_ != \")\")\n            val lst_9 = lst_5.takeWhile(_ != \")\").dropWhile(_ != \"(\")\n            val lst_10 = lst_9.takeWhile(_ != \")\").dropWhile(_ != \"(\")\n            val lst_11 = lst_10.reverse\n            val lst_12 = lst_11.reverse\n            val lst_13 = lst_12.reverse\n            val lst_14 = lst_13.reverse\n            val lst_15 = lst_14.reverse\n            val lst_16 = lst_15.reverse\n            val lst_17 = lst_16.reverse\n            val lst_18 = lst_17.reverse\n            val lst_19 = lst_18.reverse\n            val lst_20 = lst_19.reverse\n            val lst_21 = lst_20.reverse\n            val lst_22 = lst_21.reverse\n            val lst_23 = lst_22.reverse\n            if (lst_14.size != 0) \"Yes\"\n            else {\n                if (lst_13.size != 0) \"Yes\"\n                else {\n                    if (lst_12.size != 0) \"Yes\"\n                    else {\n                        if (lst_11.size != 0) \"Yes\"\n                        else {\n                            if (lst_10.size != 0) \"Yes\"\n                            else {\n                                if (lst_9.size != 0) \"Yes\"\n                                else {\n                                    if (lst_8.size != 0) \"Yes\"\n                                    else {\n                                        if (lst_7.size != 0) \"Yes\"\n                                        else {\n                                            if (lst_6.size != 0) \"Yes\"\n                                            else {\n                                                if (lst_5.size != 0) \"Yes\"\n                                                else {\n                                \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp4_2qqeq.scala:84:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpp4_2qqeq.scala:83:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpp4_2qqeq.scala:68:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m68 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980016
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val map = mutable.Map.empty[String, String]\n        var lst = lst.sorted\n        lst(0) = (lst(0)(0)) + (lst(0)(1))\n        lst(1) = lst(1).subList(1, lst.size)\n        for (i <- lst.indices) {\n            val subst = lst.update(i)\n            var temp = subst.apply(i-1)\n            var next = (i-1) + subst.apply(i+1)\n            while (next < lst.size && temp != lst(next)){\n                temp = (temp) + (lst(next))\n                next += 1\n            }\n            val key = temp.toString\n            val value = lst(next)\n            if (map.contains(key)) {\n                map = (map.updated(key,value))\n            } else {\n                map = map + (key -> value)\n            }\n        }\n        if (!map.isEmpty) {\n            val keys = map.keys.toSeq.sorted\n            val values = (map.values - keys) ++ keys\n            val rev = values.reverse\n            val newMap = Map(key -> value)\n            for (i <- rev) {\n                val value = newMap(key)\n                val key = newMap(value)\n                map = (map - key) + (key -> value)\n            }\n        }\n        if (map.isEmpty) {\n            \"No\"\n        } else {\n            \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps0fcda9b.scala:18:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmap\u001b[0m = mutable.Map.empty[\u001b[35mString\u001b[0m, \u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmps0fcda9b.scala:19:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mlst\u001b[0m = lst.sorted\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvariable\u001b[0m \u001b[35mlst\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps0fcda9b.scala:42:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnewMap\u001b[0m = Map(key -> value)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: key\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980014
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val str = lst(0)\n        val lst2 = lst(1)\n        val index = str.indexOf(\"(\")\n        val counts = str.substring(index+1, str.length).toInt\n        val sum = 0\n        for(i <- 0 to counts) {\n            sum = sum + i\n        }\n        if(sum == (counts*counts)) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpj1gqbab0.scala:24:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            sum = sum + i\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980014
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size != 2) \"No\"\n        else if (!checkParens(lst)) \"No\"\n        else checkParens(lst)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6_k4h43b.scala:19:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (!checkParens(lst)) \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: checkParens\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6_k4h43b.scala:20:13 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m checkParens(lst)\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Not found: checkParens\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980014
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Create a list of stacks, one for each string\n        val stacks: List[Stack[String]] = lst.map(_ => Stack.empty[String])\n        // If the top of the stack is empty, return 'No' as the answer\n        if (stacks.filter(_.isEmpty).head.isEmpty) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_64u5n58.scala:24)\n\tat Problem.main(tmp_64u5n58.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980019
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val l = lst.size\n        val stack = mutable.Stack[String]()\n        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n        for (i <- 0 until l) {\n            val p = lst.apply(i)\n            if (p == \"(\")\n                open.add(p)\n            else if (p == \")\")\n                close.add(p)\n            else if (open.isEmpty && close.isEmpty && !stack.isEmpty) {\n                val str = stack.pop()\n                if (!open.contains(str))\n                    return \"No\"\n            }\n            else {\n                stack += p\n            }\n        }\n        if (!open.isEmpty && !close.isEmpty)\n            return \"No\"\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqkzooihb.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqkzooihb.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopen\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqkzooihb.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mclose\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980015
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val lst1 = lst.sortBy(_.length)\n        var str = \"\"\n        val isMatch = lst1.map(x => {\n            val y = (x.split(\"(\")[1]).split(\")\")[0]\n            str += \"Yes\"\n            if(y != \"\") \n                str+y\n            else\n                str+x\n        })\n        if(isMatch.forall(x => x.contains(\"Yes\"))) \n            str\n        else \n            \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp7wa1peop.scala:21:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36my\u001b[0m = (x.split(\u001b[31m\"(\"\u001b[0m)[\u001b[31m1\u001b[0m]).split(\u001b[31m\")\"\u001b[0m)[\u001b[31m0\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mArray\u001b[0m does not take type parameters\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980017
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val balanced = \"()\".grouped(2).toList.map(x => if (x.size == 1) x(0)\n            else (x.tail, x.head))\n        val unbalanced = \"()\".grouped(1).toList.map(x => if (x.size == 1) x(0)\n            else x.head)\n        val good = balanced.foldLeft(List(\"\"))((list, str) =>\n            list match {\n                case x::xs if (x == str) => x\n                case x::xs if x != str => x :: list\n                case _ => list\n            })\n        if (balanced.contains(good)) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp98ap48me.scala:24:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mcase\u001b[0m x::xs \u001b[33mif\u001b[0m (x == str) => x\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (x : String)\n\u001b[31m   |\u001b[0m                                            Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980020
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Use a stack to store the position of opening parentheses\n        val openStack : Stack[Int] = new Stack[Int]()\n        val closedStack : Stack[Int] = new Stack[Int]()\n        // Use a stack to store the position of closing parentheses.\n        val closedStackPos : Stack[Int] = new Stack[Int]()\n\n        val goodStrings : mutable.Queue[String] = new mutable.Queue[String]()\n        val goodStringsPos : mutable.Queue[Int] = new mutable.Queue[Int]()\n\n        // A stack to store whether a opening parentheses is closed, if yes,\n        // push it into closedStack, otherwise push it into openStack.\n        for (i <- 0 until lst.size) {\n            val opening = lst(i)\n            if (opening == \"(\") openStack.push(i)\n            else if (opening == \")\") {\n                if (closedStack.size == 0) openStack.push(i + 1)\n                else {\n                    val closed = closedStack.pop()\n                    if (closed == i) closedStackPos.push(i)\n                }\n            }\n        }\n\n        // Use a while loop to check all opening parentheses and push them into goodStrings\n        // If an opening parentheses is closed, push it into closedStackPos, otherwise,\n        // push it into openStack\n        while (openStack.nonEmpty) {\n            val i = openStack.pop()\n            val open = lst(i)\n            if (opening == \"(\") {\n                if (closedStack.nonEmpty && closedStackPos.nonEmpty && goodStrings.nonEmpty &&\n                    open == \")\" && closedStackPos.head == i) {\n                    val closed = closedStack.pop()\n                    if (closed == i) closedStackPos.push(i)\n                    else {\n                        val pos = closedStackPos.pop()\n                        val goodString = goodStrings.dequeue()\n                        val newClosedStack = closedStack.dequeue()\n                        if (newClosedStack == pos) {\n                            goodStringsPos.push(pos)\n                            goodStrings += goodString\n                        }\n                    }\n                }\n                else {\n                    val goodString = goodStrings.dequeue()\n                    if (goodString == goodStrings.peek())\n                        goodStrings += goodString\n                }\n            } else {\n                if (closedStack.nonEmpty && closedStackPos.nonEmpty && goodStrings.nonEmpty &&\n                    open == \")\" && closedStackPos.head == i + 1) {\n                    val closed = closedStack.pop()\n                    if (closed == i + 1) closedStackPos.push(i)\n                    else {\n                        val pos = closedStackPos.pop()\n                        val good\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2kj5ot0m.scala:75:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2kj5ot0m.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2kj5ot0m.scala:24:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodStrings\u001b[0m : mutable.Queue[\u001b[35mString\u001b[0m] = \u001b[33mnew\u001b[0m mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2kj5ot0m.scala:24:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodStrings\u001b[0m : mutable.Queue[\u001b[35mString\u001b[0m] = \u001b[33mnew\u001b[0m mutable.Queue[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2kj5ot0m.scala:25:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodStringsPos\u001b[0m : mutable.Queue[\u001b[35mInt\u001b[0m] = \u001b[33mnew\u001b[0m mutable.Queue[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2kj5ot0m.scala:25:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgoodStringsPos\u001b[0m : mutable.Queue[\u001b[35mInt\u001b[0m] = \u001b[33mnew\u001b[0m mutable.Queue[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^^^^^",
      "stdout": "",
      "timestamp": 1659980022
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var lst1 = lst.map(_.replaceAll(\"^\\\\)\",\"\"))\n        var lst2 = lst.map(_.replaceAll(\"\\\\)\",\"\"))\n        var i = 0\n        var count = 0\n        var str = \"\"\n        while(lst1.nonEmpty){\n            str += \"(\"\n            while(i < lst1.length){\n                str += lst1(lst1(i))\n                i += 1 \n                if(lst1(i) == \"(\"){\n                    count += 1\n                }\n                if(lst1(i) == \")\"){\n                    count -= 1\n                }\n                if((count == 0) && (lst1(i) == \"(\")){\n                    lst1.remove(lst1(i))\n                    lst2.remove(lst2(i))\n                    count += 1\n                    i = lst1.length\n                    count += 1\n                }\n            }\n            str += \")\"\n        }\n        if(lst2.nonEmpty){\n            str += \"(\"\n            while(i < lst2.length){\n                str += lst2(lst2(i))\n                i += 1 \n                if(lst2(i) == \"(\"){\n                    count += 1\n                }\n                if(lst2(i) == \")\"){\n                    count -= 1\n                }\n                if((count == 0) && (lst2(i) == \"(\")){\n                    lst2.remove(lst2(i))\n                    lst1.remove(lst1(i))\n                    count += 1\n                    i = lst2.length\n                    count += 1\n                }\n            }\n            str += \")\"\n        }\n        if(str != \"\"){\n            return \"Yes\"\n        }else{\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvmcu96rs.scala:26:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                str += lst1(lst1(i))\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvmcu96rs.scala:26:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                str += lst1(lst1(i))\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    String\n\u001b[31m   |\u001b[0m                            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvmcu96rs.scala:35:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                    lst1.remove(lst1(i))\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue remove is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvmcu96rs.scala:36:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    lst2.remove(lst2(i))\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue remove is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.Imp",
      "stdout": "",
      "timestamp": 1659980025
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val stack = mutable.Stack[Boolean]()\n      val isBalanced = lst.forall(x => x contains '(' && x contains ')')\n      if (!isBalanced) return \"No\"\n      var ret = \"\"\n      var index = -1\n      val lstr = lst.reverse\n      while(stack.nonEmpty && index < lstr.length) {\n        val item = stack.last\n        stack.pop()\n        if (item == false) {\n          ret = (lstr.drop(index) mkString \"\")\n          break\n        }\n        index += 1\n      }\n      if (stack.nonEmpty || index < lstr.length) return \"No\"\n      ret\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz3vs1835.scala:18:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mBoolean\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz3vs1835.scala:19:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36misBalanced\u001b[0m = lst.forall(\u001b[36mx\u001b[0m => x contains \u001b[31m'('\u001b[0m && x contains \u001b[31m')'\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value && is not a member of Char\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz3vs1835.scala:29:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m          break\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980022
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val inv = lst.foldLeft(new mutable.HashMap[String, List[String]]()){ (m, s) =>\n            if (m.containsKey(s)) {\n                m.get(s).push(s)\n            } else {\n                var ns: List[String] = Nil\n                if (s.contains('(')) {\n                    ns = s filterNot (x => x == '(')\n                } else {\n                    ns = s filterNot (x => x == ')')\n                }\n                m.put(s, ns)\n            }\n            m\n        }\n        if (inv.keys.size == 0) {\n            return \"No\"\n        } else {\n            var result: String = \"No\"\n            var cur = 0\n            var next = 1\n            var isGood = false\n            while (cur < lst.length) {\n                val leftParen = lst.apply(cur)\n                val rightParen = lst.apply(next)\n                val curRight = inv.apply(leftParen).indexOf(rightParen)\n                val curLeft = inv.apply(leftParen).lastIndexOf(rightParen)\n                if (curRight != -1) {\n                    isGood = true\n                } else {\n                    isGood = false\n                }\n                if (curLeft == -1) result += \"Yes\"\n                if (isGood) result += \"Yes\"\n                cur += next\n                next += 1\n            }\n            result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6o0tnlpd.scala:18:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36minv\u001b[0m = lst.foldLeft(\u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mString\u001b[0m, \u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m]]()){ (\u001b[36mm\u001b[0m, \u001b[36ms\u001b[0m) =>\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6o0tnlpd.scala:19:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mif\u001b[0m (m.containsKey(s)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value containsKey is not a member of Any\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6o0tnlpd.scala:20:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                m.get(s).push(s)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value get is not a member of Any\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6o0tnlpd.scala:24:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                    ns = s filterNot (\u001b[36mx\u001b[0m => x == \u001b[31m'('\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    String\n\u001b[31m   |\u001b[0m                         Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mString\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6o0tnlpd.scala:26:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    ns = s filterNot (\u001b[36mx\u001b[0m => x == \u001b[31m')'\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    String\n\u001b[31m   |\u001b[0m                         Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mString\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Fou",
      "stdout": "",
      "timestamp": 1659980025
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var result = \"No\"\n        val stack = mutable.Stack[String]()\n        val parens = lst.map(x => if (x == \"(\") stack.toList else stack += x)\n        val isGood = parens.forall(x => x != \"()\")\n        if (isGood) {\n            val goodStrings = parens.filter(x => x != \"()\").takeWhile(x => x != \"()\").tail\n            if (goodStrings.length != 1) {\n                result = \"No\"\n            } else {\n                result = goodStrings.head\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4cxyfrr2.scala:19:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980020
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val list1 = lst.head\n        val list2 = lst.tail\n        val n = list2.length\n        val list1 = list1.replaceAll(\"[()]\", \"\").replaceAll(\"[()]+\", \"\")\n        var count = 0\n        var left = 0\n        var right = 0\n        var output = \"Yes\"\n        for (i <- list1.indices) {\n            if (list1(i) == '(') {\n                left+=1\n            } else if (list1(i) == ')') {\n                right-=1\n            }\n            if (left < right) {\n                count += 1\n            }\n        }\n        if (count == n) {\n            output = \"Yes\"\n        } else {\n            output = \"No\"\n        }\n        output\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvzyjaiu_.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist1\u001b[0m = list1.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m).replaceAll(\u001b[31m\"[()]+\"\u001b[0m, \u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mlist1 is already defined as \u001b[33mvalue\u001b[0m \u001b[35mlist1\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980022
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val ind = lst.map(_.length).max\n        val s = lst.reverse.filter(_(ind).isDefined).map(_.substring(0,ind))\n        val p = lst.map(_.charAt(ind-1))\n        if (p.forall(_.isClosed))\n            s\"No\"\n        else\n            s\"Yes${s.reverse.mkString}\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpaoz9pbdn.scala:19:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ms\u001b[0m = lst.reverse.filter(_(ind).isDefined).map(_.substring(\u001b[31m0\u001b[0m,ind))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isDefined is not a member of Char\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpaoz9pbdn.scala:21:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (p.forall(_.isClosed))\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value isClosed is not a member of Char\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980026
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val map = new mutable.HashMap[String,Int]()\n        val stack = new mutable.Stack[String]()\n        for(i <- 0 until lst.size){\n            if(i==lst.size -1){\n                if(lst(i).contains(\"(\") && lst(i).contains(\")\"))\n                    return \"Yes\"\n                else {\n                    if(lst(i).contains(\"(\"))\n                        return \"Yes\"\n                    else\n                        return \"No\"\n                }\n            }\n            val value = lst(i)\n            val isOpen = value.contains(\"(\")\n            val isClose = value.contains(\")\")\n            if(!map.contains(value)){\n                map.put(value,0)\n                stack += value\n            }\n            map.get(value) += 1\n            if(isOpen == !isClose){\n                stack.pop\n                stack += value\n            }\n        }\n        \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv0ohjz6p.scala:18:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mString\u001b[0m,\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv0ohjz6p.scala:19:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = \u001b[33mnew\u001b[0m mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980023
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // 1. Write a method to find the balance of parentheses.\n        def balance(s: String): Int = {\n            val l = s.length\n            var left = 0, right = l\n            while (left < right) {\n                if (s(left) <:< '(') left += 1\n                if (s(right) <:< ')') right -= 1\n            }\n            left - right\n        }\n\n        // 2. Write a method to compare the two strings by concatenating them\n        //    and see if they are good.\n        def check(l: List[String], s: String): Boolean = {\n            val l = l.filter(x => !x.contains(s))\n            if (l.length < 2) false\n            else if (balance(s.replaceAll(\"\\\\)\", \"))\") < balance(s.replaceAll(\"\\\\(\", \"(\"))) true\n            else check(l.tail, s.replaceAll(\"\\\\(\", \"(\"))\n        }\n\n        // 3. Write a recursive method to solve the problem.\n        if (lst.length == 1) lst(0)\n        else check(lst, lst(0))\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmppv4t_2gr.scala:21:24 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mleft\u001b[0m = \u001b[31m0\u001b[0m, right = l\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        end of statement expected but ',' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppv4t_2gr.scala:34:92 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (balance(s.replaceAll(\u001b[31m\"\\\\)\"\u001b[0m, \u001b[31m\"))\"\u001b[0m) < balance(s.replaceAll(\u001b[31m\"\\\\(\"\u001b[0m, \u001b[31m\"(\"\u001b[0m))) \u001b[31mtrue\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                          ')' expected, but 'true' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppv4t_2gr.scala:22:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mwhile\u001b[0m (left < right) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: right\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppv4t_2gr.scala:23:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                \u001b[33mif\u001b[0m (s(left) <:< \u001b[31m'('\u001b[0m) left += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value <:< is not a member of Char - did you mean Char.<<?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppv4t_2gr.scala:24:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mif\u001b[0m (s(right) <:< \u001b[31m')'\u001b[0m) right -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: right\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppv4t_2gr.scala:24:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mif\u001b[0m (s(right) <:< \u001b[31m')'\u001b[0m) right -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m       ",
      "stdout": "",
      "timestamp": 1659980028
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val lst1 = lst.map(x=>x.substring(1, x.length-1))\n        val lst2 = lst.map(x=>x.substring(1, x.length-1)).filter(x=>x.equals(\"\"))\n        val lst3 = lst.filter(x=>x.contains(\"(\")).toList\n        val lst4 = lst.filter(x=>x.contains(\")\")).toList\n        if(lst1.size==lst2.size+lst3.size+lst4.size){\n            if(lst1.size==lst3.size+lst4.size){\n                if(lst2.size==lst3.size+lst4.size){\n                    if(lst3.isEmpty){\n                        \"Yes\"\n                    }else{\n                        \"No\"\n                    }\n                }else{\n                    \"No\"\n                }\n            }else{\n                \"Yes\"\n            }\n        }else{\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: begin 1, end 0, length 1\n\tat java.base/java.lang.String.checkBoundsBeginEnd(String.java:4604)\n\tat java.base/java.lang.String.substring(String.java:2707)\n\tat Problem$.$anonfun$1(tmpy59ainze.scala:18)\n\tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.matchParens(tmpy59ainze.scala:18)\n\tat Problem$.main(tmpy59ainze.scala:41)\n\tat Problem.main(tmpy59ainze.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980028
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Solution\n        var ans = lst.foldLeft(\"No\"){ (acc,curr) => {\n            if(curr == \"()\") \"Yes\"\n            else acc match {\n                case acc if acc.indexOf(\"(\") < acc.indexOf(\")\") => acc\n                case acc if acc.indexOf(\"(\") > acc.indexOf(\")\") => acc.substring(0, acc.indexOf(\"(\")) + curr + acc.substring(acc.indexOf(\")\") + 1)\n                case acc if acc.indexOf(\"(\") == acc.indexOf(\")\") => acc + curr\n            }\n        }}\n        ans.toUpperCase()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpe3_fnrbc.scala:30)\n\tat Problem.main(tmpe3_fnrbc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980027
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val l = lst.head // get the first element\n        var count = 0\n        for(i <- 0 to l.length){\n            if(l.charAt(i)=='(' && count<l.length){\n                count = count + 1\n            }\n            if(l.charAt(i)==')' && count>0){\n                count = count - 1\n            }\n            if(count==0 && count==l.length){\n                return \"Yes\"\n            }\n        }\n        \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.StringIndexOutOfBoundsException: String index out of range: 3\n\tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\tat Problem$.matchParens$$anonfun$1(tmpcif4rwyl.scala:21)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.matchParens(tmpcif4rwyl.scala:30)\n\tat Problem$.main(tmpcif4rwyl.scala:34)\n\tat Problem.main(tmpcif4rwyl.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980028
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def loop(remainingParanthesis: List[String], result: List[String], i: Int) : String = {\n            if (i == remainingParanthesis.length - 1) result.reverse.mkString(\"(\", \")\")\n            else loop(remainingParanthesis, result :: result.take(i+1), i + 1)\n        }\n        if (lst.length == 0) \"No\"\n        else loop(lst, Nil, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2ufc4xt8.scala:19:78 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mif\u001b[0m (i == remainingParanthesis.length - \u001b[31m1\u001b[0m) result.reverse.mkString(\u001b[31m\"(\"\u001b[0m, \u001b[31m\")\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Found:    (String, String)\n\u001b[31m   |\u001b[0m                                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2ufc4xt8.scala:20:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33melse\u001b[0m loop(remainingParanthesis, result :: result.take(i+\u001b[31m1\u001b[0m), i + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Found:    (result : List[String])\n\u001b[31m   |\u001b[0m                                       Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980028
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val str: List[String] = lst.takeWhile(x => x != \"\").reverse\n        // If there are zero parentheses, return \"Yes\"\n        if (str.length == 0) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpagwmd0_s.scala:23)\n\tat Problem.main(tmpagwmd0_s.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980029
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val countMap = lst.length.toList.foldLeft(Map[Int, Int]()){\n            case (acc, elem) =>\n                if (elem==\"(\") {\n                    acc + (elem->1)\n                } else {\n                    acc + (elem->-1)\n                }\n        }\n        val countMap = countMap.map{\n            case (_,v) => v\n        }\n        val list2 = lst.length.toList.foldLeft(List[String]()){\n            case (acc, i) => acc :+ lst(i)\n        }\n        val list3 = list2.length.toList.foldLeft(List[String]()){\n            case (acc, i) => acc :+ list2(i)\n        }\n        val countMap = countMap.toList.reverse.foldLeft(List[Int]()){\n            case (acc, elem) =>\n                if (elem > 0) {\n                    acc :+ (elem-1)\n                } else if (elem < 0) {\n                    acc :+ (elem+1)\n                } else {\n                    acc\n                }\n        }\n        list3.map{\n            x => countMap.reverse.foldLeft(List(false)){ case (acc, elem) =>\n                if (elem==0) {\n                    acc :+ (true)\n                } else {\n                    acc :+ (x contains elem) }\n            }\n        }.foldLeft(\"\"){ case (acc, res) => acc :+ (res :+ \"Yes\")}\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjjhrglte.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcountMap\u001b[0m = countMap.map{\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mcountMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcountMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m27 |\u001b[0m            \u001b[33mcase\u001b[0m (_,v) => v\n\u001b[31m28 |\u001b[0m        }\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjjhrglte.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcountMap\u001b[0m = countMap.toList.reverse.foldLeft(List[\u001b[35mInt\u001b[0m]()){\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mcountMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mcountMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m36 |\u001b[0m            \u001b[33mcase\u001b[0m (acc, elem) =>\n\u001b[31m37 |\u001b[0m                \u001b[33mif\u001b[0m (elem > \u001b[31m0\u001b[0m) {\n\u001b[31m38 |\u001b[0m                    acc :+ (elem-\u001b[31m1\u001b[0m)\n\u001b[31m39 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (elem < \u001b[31m0\u001b[0m) {\n\u001b[31m40 |\u001b[0m                    acc :+ (elem+\u001b[31m1\u001b[0m)\n\u001b[31m41 |\u001b[0m                } \u001b[33melse\u001b[0m {\n\u001b[31m42 |\u001b[0m                    acc\n\u001b[31m43 |\u001b[0m                }\n\u001b[31m44 |\u001b[0m        }\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjjhrglte.scala:18:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcountMap\u001b[0m = lst.length.toList.foldLeft(Map[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()){\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value toList is not a member of Int - did you mean Int.toInt?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjjhrglte.scala:29:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist2\u001b[0m = lst.length.toList.foldLeft(List[\u001b[35mString\u001b[0m]()){\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value toList is not a member of Int - did y",
      "stdout": "",
      "timestamp": 1659980028
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def matching(str:List[String], open:List[String], close:List[String]) : List[String] = {\n            if(str.isEmpty) close\n            else if(str == open || str == close) matching(str.tail, open, close)\n            else if(str.length == 1) open\n            else matching(str.tail, open ::: str.head, close ::: str.tail)\n        }\n        val open = (lst(0) match {\n            case \")\" => Nil\n            case \")(\"   => Nil\n            case \")((\"  => Nil\n            case \")((\" => Nil\n            case \")((((\" => Nil\n            case \")(((\"  => Nil\n            case \")((((\" => Nil\n            case \")(((((\"  => Nil\n            case \")((((((\" => Nil\n            case \")((((((\" => Nil\n            case \")(((((((\"  => Nil\n            case \")((((((((\" => Nil\n            case \")(((((((((\"  => Nil\n            case \")(((((((((\" => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \")((((((((((\"  => Nil\n            case \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpano3qb_k.scala:66:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m66 |\u001b[0m            \u001b[33mcase\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpano3qb_k.scala:68:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but 'def' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpano3qb_k.scala:84:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpano3qb_k.scala:22:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33melse\u001b[0m matching(str.tail, open ::: str.head, close ::: str.tail)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value ::: is not a member of String\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpano3qb_k.scala:83:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659980028
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val ind = lst.indexWhere(_ startsWith \"(\")\n        val vals = lst.drop(ind)\n        val ind2 = lst.indexWhere(_ startsWith \"(\")\n        val vals2 = lst.drop(ind2)\n        var flag = true\n        var i = 0\n        while(i < vals2.length) {\n            val temp = vals(i).dropRight(1)\n            val j = i + 1\n            while (j < vals2.length) {\n                val next = vals2(i).dropRight(1)\n                if((temp+next)==\"\") flag = false\n                else j+=1\n            }\n            i+=1\n        }\n        if(flag) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa8558v1_.scala:30:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                \u001b[33melse\u001b[0m j+=\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value += is not a member of Int - did you mean j.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980028
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var res = 0\n        var stack = new mutable.Stack[String]()\n        for (ele <- lst) {\n            var opens = 0\n            for (c <- ele) {\n                if (c == '(')\n                    opens += 1\n                else if (c == ')')\n                    opens -= 1\n                if (opens == 0)\n                    res += 1\n                stack.push(c)\n            }\n        }\n        if (res == 0)\n            return \"No\"\n        else\n            return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnxdkk_x0.scala:19:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mstack\u001b[0m = \u001b[33mnew\u001b[0m mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980025
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val ps = new Stack[String]\n        val newlst : List[String] = lst.filter(_ != \"\")\n        if (newlst.size != 1) {\n            return \"No\"\n        }\n        newlst.head match {\n            case \"(\" => ps.push(\"(\")\n            case \")\" => ps.push(\")\")\n            case x => ps.push(x)\n        }\n        if (ps.size != newlst.size) {\n            return \"No\"\n        }\n        // loop through all open parentheses\n        while (true) {\n            val p = ps.pop\n            if (!ps.isEmpty) {\n                ps.head match {\n                    case x if x == \"(\" => ps.push(x)\n                    case x if x == \")\" => ps.push(x)\n                    case _ => println(\"bad string\")\n                }\n            }\n            if (ps.isEmpty) break\n        }\n        // loop through all close parentheses\n        val flag = true\n        while (true) {\n            val p = ps.pop\n            if (!ps.isEmpty) {\n                ps.head match {\n                    case x if x == \"(\" => ps.push(x)\n                    case x if x == \")\" => ps.push(x)\n                    case _ => flag = false\n                }\n            }\n            if (ps.isEmpty) break\n        }\n        if (newlst.head == \"()\") {\n            if (flag) \"Yes\" else \"No\"\n        } else {\n            if (flag) \"No\" else \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpchghtnn_.scala:41:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            \u001b[33mif\u001b[0m (ps.isEmpty) break\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpchghtnn_.scala:51:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m                    \u001b[33mcase\u001b[0m _ => flag = \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Reassignment to val flag\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpchghtnn_.scala:54:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m            \u001b[33mif\u001b[0m (ps.isEmpty) break\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980026
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val leftParentheses = lst(0).filter(c => c == '(')\n        val rightParentheses = lst(1).filter(c => c == ')')\n        if(leftParentheses.length < 0 || rightParentheses.length < 0 || leftParentheses.length != rightParentheses.length) {\n            return \"No\"\n        } else {\n            return \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp9x0hshcn.scala:27)\n\tat Problem.main(tmp9x0hshcn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980030
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val left = lst(0)\n        val right = lst(1)\n        var openParen = false // flag to check open paren count\n        var closeParen = false\n        var stack = []\n        var result = \"No\"\n        for(c <- left){\n            c match {\n                case \"(\" => {\n                    stack push c\n                    openParen += 1\n                }\n                case \")\" => {\n                    openParen -= 1\n                    if(openParen == 0){\n                        closeParen = true\n                    }\n                }\n                case _ =>\n            }\n        }\n        if(closeParen){\n            result = \"Yes\"\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplmz1jku3.scala:22:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mstack\u001b[0m = []\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplmz1jku3.scala:23:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^^^\u001b[0m\n\u001b[31m   |\u001b[0m'=>' expected, but 'end of statement' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmplmz1jku3.scala:26:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m\"(\"\u001b[0m => {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplmz1jku3.scala:27:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                    stack push c\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value push is not a member of Null\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplmz1jku3.scala:28:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    openParen += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Boolean - did you mean Boolean.!=?\n\u001b[31m\u001b[31m-- Error: /tmp/tmplmz1jku3.scala:30:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m\")\"\u001b[0m => {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplmz1jku3.scala:31:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    openParen -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value -= is not a member of Boolean - did you mean Boolean.!=?\n\u001b[31m\u001b[31m-- Error: /tmp/tmplmz1jku3.scala:32:23 -----------------------------------",
      "stdout": "",
      "timestamp": 1659980030
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if(lst.isEmpty) \"\"\n        else {\n            var l1 = lst.head :: lst.tail\n            var l2 = lst.tail :: lst.head :: Nil\n            if((l1.isEmpty && l2.isEmpty) || (l1.nonEmpty && l2.isEmpty)) \"No\"\n            else if(l1.nonEmpty && l2.nonEmpty) matchParens(l1) ++ matchParens(l2)\n            else \"\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppld30_42.scala:23:79 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(l1.nonEmpty && l2.nonEmpty) matchParens(l1) ++ matchParens(l2)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                               ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    (l2 : List[Object])\n\u001b[31m   |\u001b[0m                                           Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980031
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def rec(left: String, right: List[String], index: Int, res: String): String = {\n            if (index >= right.length) return res\n            rec(left + \"(\" + right(index) + \")\", right, index + 1, res + left+\"(\"+right(index)+\"))\")\n        }\n        rec(\"(\", lst, 0, \"\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpda5nd9fb.scala:25)\n\tat Problem.main(tmpda5nd9fb.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980034
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val openStack = mutable.Stack[String]()\n        val closeStack = mutable.Stack[String]()\n        for(i <- 0 until lst.size){\n            if(i == lst.length - 1 || lst(i) == \")\"){\n                closeStack.push(lst(i))\n            }\n            else if(i == lst.length - 1 && lst(i) == \"(\"){\n                openStack.push(lst(i))\n            }\n            else{\n                val openParen = openStack.mkString\n                val closeParen = closeStack.mkString\n                if(i == 0 || (openStack.head.toString.equals(openParen) && closeStack.head.toString.equals(closeParen))){\n                    if(openStack.size != closeStack.size) throw new Exception(\"not enough parentheses match\")\n                    openStack.pop\n                    closeStack.pop\n                }\n            }\n        }\n        if(openStack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkbbcfmgg.scala:18:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mopenStack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkbbcfmgg.scala:19:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcloseStack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980030
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val good = lst.filter( s => s.charAt(0) == '(' && s.charAt(s.length - 1) == ')' )\n        println( good )\n        good.map(_.substring(1,s.length-1)).mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_k1shak0.scala:20:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        good.map(_.substring(\u001b[31m1\u001b[0m,s.length-\u001b[31m1\u001b[0m)).mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: s\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980030
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val p = lst.map(c => (c.charAt(0), c.charAt(1))).toSet\n        val n = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toSet\n        val l = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.toSet\n        val n = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c => (c).productIterator).toSet\n        val l = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c => (c).productIterator).toList.toSet\n        val ns = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c => (c).productIterator).toList.toSet\n        val nl = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c => (c).productIterator).toList.toSet\n        val nls = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c => (c).productIterator).toList.toSet\n        val nlnl = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c => (c).productIterator).toList.toList.toSet\n        val nlnls = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c => (c).productIterator).toList.toList.toSet\n        val nlnlnl = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c => (c).productIterator).toList.toList.toList.toSet\n        val nlnlnls = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c => (c).productIterator).toList.toList.toList.toSet\n        val nlnlnlnl = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.distinct.map(c => (c).productIterator).toList.toList.toList.toList.toSet\n        val nlnlnlnls = lst.map(c => (c.charAt(0), c.charAt(1))).map(c => (c).productIterator).toList.\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphrltnfws.scala:32:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmphrltnfws.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = lst.map(\u001b[36mc\u001b[0m => (c.charAt(\u001b[31m0\u001b[0m), c.charAt(\u001b[31m1\u001b[0m))).map(\u001b[36mc\u001b[0m => (c).productIterator).toList.distinct.map(\u001b[36mc\u001b[0m => (c).productIterator).toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mn is already defined as \u001b[33mvalue\u001b[0m \u001b[35mn\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmphrltnfws.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = lst.map(\u001b[36mc\u001b[0m => (c.charAt(\u001b[31m0\u001b[0m), c.charAt(\u001b[31m1\u001b[0m))).map(\u001b[36mc\u001b[0m => (c).productIterator).toList.distinct.map(\u001b[36mc\u001b[0m => (c).productIterator).toList.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0ml is already defined as \u001b[33mvalue\u001b[0m \u001b[35ml\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphrltnfws.scala:23:117 -----------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mns\u001b[0m = lst.map(\u001b[36mc\u001b[0m => (c.charAt(\u001b[31m0\u001b[0m), c.charAt(\u001b[31m1\u001b[0m))).map(\u001b[36mc\u001b[0m => (c).productIterator).toList.distinct.map(\u001b[36mc\u001b[0m => (c).productIterator).toList.toSet\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                 ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value product",
      "stdout": "",
      "timestamp": 1659980036
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var goodString = \"\"\n        var goodStringCount = 1\n        val paren = mutable.HashSet[String]()\n\n        // Add open parentesi to stack\n        for (i <- 0 until lst.size) {\n            val temp = lst(i)\n            if (paren.contains(temp)) {\n                paren -= temp\n                goodStringCount += 1\n            } else {\n                paren += temp\n            }\n        }\n\n        // Add close parentesi to stack\n        for (i <- lst.size until 0 ) {\n            val temp = lst(i)\n            if (paren.contains(temp)) {\n                paren -= temp\n                goodStringCount += 1\n            } else {\n                paren += temp\n            }\n        }\n\n        // Add close parentesi to stack\n        for (i <- 0 until lst.size) {\n            val temp = lst(i)\n            if (paren.contains(temp)) {\n                paren -= temp\n                goodStringCount += 1\n            } else {\n                paren += temp\n            }\n        }\n\n        if (goodStringCount >= lst.size) {\n            goodString = \"Yes\"\n        } else {\n            goodString = \"No\"\n        }\n\n        goodString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpze5spsxi.scala:20:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen\u001b[0m = mutable.HashSet[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980032
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val str = lst.head\n        val rest = lst.tail\n        var cur = 0\n        var found = false\n        var stack = 0\n        var strStack = List[String]()\n\n        while (!found) {\n            if (strStack.contains(str)) {\n                stack = strStack.lastIndexOf(str) match {\n                    case Some(i) => (strStack.length - i) -1\n                    case None => 0\n                }\n                found = true\n            }\n            else if (cur + 1 == stack) {\n                strStack = strStack.filterNot(_ == str)\n                stack = 0\n                cur = 0\n                if (rest.isEmpty || strStack.isEmpty)\n                    return \"No\"\n                found = true\n            }\n            else {\n                stack = strStack.lastIndexOf(str) match {\n                    case Some(i) => (strStack.length - i) -1\n                    case None => 0\n                }\n                cur += 1\n                if (stack == 0)\n                    found = true\n            }\n        }\n\n        val reverseStr = str.reverse\n        var curStr = \"\"\n        while (!found) {\n            if (curStr == reverseStr) {\n                found = true\n            }\n            else if (curStr == reverseStr.substring(reverseStr.length - 1, 1)) {\n                curStr += reverseStr.substring(0, reverseStr.length - 1)\n            }\n            else if (curStr == reverseStr.substring(reverseStr.length - 2, reverseStr.length - 1)) {\n                curStr += reverseStr.substring(0, reverseStr.length - 2)\n            }\n            else {\n                curStr += reverseStr.substring(0, reverseStr.length - 1)\n            }\n        }\n\n        reverseStr\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp454yquu9.scala:28:53 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    \u001b[33mcase\u001b[0m Some(i) => (strStack.length - i) -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m-\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Double\n\u001b[31m   |\u001b[0m  (x: Float): Float\n\u001b[31m   |\u001b[0m  (x: Long): Long\n\u001b[31m   |\u001b[0m  (x: Int): Int\n\u001b[31m   |\u001b[0m  (x: Char): Int\n\u001b[31m   |\u001b[0m  (x: Short): Int\n\u001b[31m   |\u001b[0m  (x: Byte): Int\n\u001b[31m   |\u001b[0m match arguments ((i : Any))\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp454yquu9.scala:29:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    \u001b[33mcase\u001b[0m None => \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    None.type\n\u001b[31m   |\u001b[0m                         Required: Int\n\u001b[31m   |\u001b[0m                         pattern type is incompatible with expected type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp454yquu9.scala:43:53 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                    \u001b[33mcase\u001b[0m Some(i) => (strStack.length - i) -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m-\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Double\n\u001b[31m   |\u001b[0m  (x: Float): Float\n\u001b[31m   |\u001b[0m  (x: Long): Long\n\u001b[31m   |\u001b[0m  (x: Int): Int\n\u001b[31m   |\u001b[0m  (x: Char): Int\n\u001b[31m   |\u001b[0m  (x: Short): Int\n\u001b[31m   |\u001b[0m  (x: Byte): Int\n\u001b[31m   |\u001b[0m match arguments ((i : Any))\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp454yquu9.scala:44:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m                    \u001b[33mcase\u001b[0m None => \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               ",
      "stdout": "",
      "timestamp": 1659980032
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val list = lst.map(x => (x match {\n            case xs if xs.matches(\"\\\\(.*\\\\)\")=> xs.replaceAll(\"\\\\(.*\\\\)\", \"\\\\*\")\n            case xs if xs.matches(\"\\\\(.*\") => xs.replaceAll(\"\\\\(.*\", \"\\\\(\")\n            case xs if xs.matches(\"\\\\*.*\") => xs.replaceAll(\"\\\\*.*\", \"\\\\*\")\n            case xs if xs.matches(\"\\\\*\") => xs.replaceAll(\"\\\\*\", \"\\\\*\")\n            case xs if xs.matches(\"\") => xs.replaceAll(\"\\\\*\", \"\")\n            case xs => xs\n        }))\n        val list2 = list.zipWithIndex.sortBy(x => (x(0), x(1)))\n        var str = \"\"\n        var i = 0\n        for (i <- 1 to list2.length) {\n            str = str + list2(i)._1\n        }\n        val newStr = str.substring(0, str.length - 1)\n        newStr match {\n            case xs if xs.matches(\"\\\\*(.*)\\\\*\") => newStr + \"*\"\n            case xs if xs.matches(\"\\\\*\\\\*(.*)\\\\*\\\\*\") => newStr + \"***\"\n            case _ => newStr\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.IndexOutOfBoundsException: 2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\tat Problem$.matchParens$$anonfun$1(tmpkrsc0xeo.scala:30)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.matchParens(tmpkrsc0xeo.scala:31)\n\tat Problem$.main(tmpkrsc0xeo.scala:40)\n\tat Problem.main(tmpkrsc0xeo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980039
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = Stack[List[String]]()\n        val list = new collection.mutable.ArrayBuffer[String]()\n        for(l <- lst){\n            l match {\n                case \")\" :: tail => list.add(l)\n                case \")\" => stack.poll()\n                case _ => {\n                    l match {\n                        case \")(\"  :: tail => stack.push(tail.reverse:_*)\n                        case \")(\"  => stack.append(tail.reverse:_*)\n                        case _ => stack.append(l:_*)\n                    }\n                }\n            }\n        }\n        if(list.size != 2) \"No\"\n        else {\n            val stack2 = stack.toList\n            val list2 = list.filter( x => stack2.contains(x) )\n            val list3 = list2.reverse\n            val stack3 = stack2.filter( x => !list2.contains(x) )\n            val list4 = list3.reverse\n            if(stack3.isEmpty) list4\n            else list4.mkString(\"(\",\")\",\")\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1yca03_3.scala:22:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m\")\"\u001b[0m :: tail => list.add(l)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue add is not a member of scala.collection.mutable.ArrayBuffer[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1yca03_3.scala:23:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m\")\"\u001b[0m => stack.poll()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue poll is not a member of scala.collection.mutable.Stack[List[String]] - did you mean stack.coll?\n\u001b[31m\u001b[31m-- Error: /tmp/tmp1yca03_3.scala:26:57 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                        \u001b[33mcase\u001b[0m \u001b[31m\")(\"\u001b[0m  :: tail => stack.push(tail.reverse:_*)\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mSequence argument type annotation `*` cannot be used here:\n\u001b[31m   |\u001b[0mthe corresponding parameter has type List[String] which is not a repeated parameter type\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1yca03_3.scala:27:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                        \u001b[33mcase\u001b[0m \u001b[31m\")(\"\u001b[0m  => stack.append(tail.reverse:_*)\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Not found: tail\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp1yca03_3.scala:28:40 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                        \u001b[33mcase\u001b[0m _ => stack.append(l:_*)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mappend\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mBuffer\u001b[0m with types\n\u001b[31m   |\u001b[0m (elems: List[String]*): (stack : scala.collection.mutable.Stack[Li",
      "stdout": "",
      "timestamp": 1659980038
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Your code here\n        val parenthCounter = lst.filter(_ => _ == \"(\" || _ == \")\").size\n        if (parenthCounter == 0) \"No\"\n        else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpa3f3lrn4.scala:19:45 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparenthCounter\u001b[0m = lst.filter(_ => _ == \u001b[31m\"(\"\u001b[0m || _ == \u001b[31m\")\"\u001b[0m).size\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$2 of expanded function:\n\u001b[31m   |\u001b[0m   (_$2, _$3) => _$2 == \u001b[32m\"(\"\u001b[0m || _$3 == \u001b[32m\")\"\u001b[0m.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpa3f3lrn4.scala:19:57 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparenthCounter\u001b[0m = lst.filter(_ => _ == \u001b[31m\"(\"\u001b[0m || _ == \u001b[31m\")\"\u001b[0m).size\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$3 of expanded function:\n\u001b[31m   |\u001b[0m   (_$2, _$3) => _$2 == \u001b[32m\"(\"\u001b[0m || _$3 == \u001b[32m\")\"\u001b[0m.\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980032
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // This checks if all items in the list are open or closed\n        // if any item isn't closed, it's an invalid string\n        if(lst.forall(_.contains('('))){\n            val opens = lst.filter(_.contains('('))\n            val closes = lst.filter(_.contains(')'))\n            if(opens.size != closes.size){\n                return \"No\"\n            }\n            val openChars = opens.map(_.toString.toInt)\n            val closeChars = closes.map(_.toString.toInt)\n            // This counts the number of open parentheses\n            // and checks if the number of open and closed parentheses\n            // are equal\n            if(opens.size == closes.size){\n                if(openChars.toSet == closeChars.toSet){\n                    return \"Yes\"\n                }\n            }\n            return \"No\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqyes8pv8.scala:41)\n\tat Problem.main(tmpqyes8pv8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980038
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        // Code goes here\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_g363cqb.scala:17:51 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmatchParens\u001b[0m(\u001b[36mlst\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m]) : \u001b[35mString\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Found:    Unit\n\u001b[31m   |\u001b[0m                                                   Required: String\n\u001b[31m18 |\u001b[0m        \u001b[34m// Code goes here\u001b[0m\n\u001b[31m19 |\u001b[0m    }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980037
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[Int](1 , 0)\n        val result = mutable.ListBuffer.empty[String]\n        for(i <- 0 until lst.size){\n            val str = lst(i)\n            val openParen = str.indexOf(\"(\")\n            val closeParen = str.indexOf(\")\")\n            val openParenIndex = str.indexOf(\"(\", openParen+1)\n            val closeParenIndex = str.indexOf(\")\", closeParen+1)\n            stack.push(openParenIndex+1)\n            stack.push(closeParenIndex+1)\n            while(stack.length > 0){\n                val openParenIndex = stack.pop()\n                val closeParenIndex = stack.pop()\n                if(openParenIndex < closeParenIndex){\n                    result.push(str)\n                    break\n                }\n                result.push(str.substring(openParenIndex+1, closeParenIndex+1))\n            }\n        }\n        if(result.size == lst.size){\n            \"Yes\"\n        } else {\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxm5l3p6y.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mInt\u001b[0m](\u001b[31m1\u001b[0m , \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxm5l3p6y.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxm5l3p6y.scala:33:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980035
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def dfs(lst : List[String], res: String, i: Int): String = {\n            if (i == lst.length)\n                if (res == \"\")\n                    res\n                else\n                    \"No\"\n            else\n                dfs(lst, res+lst(i), i+1)\n        }\n\n        var res = \"\"\n        var i = lst.size - 1\n        while (i>0) {\n            if (lst(i) == \"(\") {\n                val tmp = dfs(lst.reverse, \"\", i)\n                if (tmp == \"Yes\")\n                    res += lst(i)\n                i = i - 1\n            } else if (lst(i) == \")\") {\n                val tmp = dfs(lst, \"\", i)\n                if (tmp == \"Yes\")\n                    res += lst(i)\n                i = i - 1\n            } else {\n                val tmp = dfs(lst, \"\", i)\n                if (tmp == \"Yes\")\n                    res += lst(i)\n                i = i - 1\n            }\n        }\n\n        res + dfs(lst.reverse, \"\", i)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwgr715p1.scala:52)\n\tat Problem.main(tmpwgr715p1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980040
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty) \"\"\n        else {\n            var str = lst(0)\n            var stack = Stack[Int](1,0)\n            var index = 0\n            var good = true // = false // flag to indicate whether there's any way to make good string\n            while (index<str.length) {\n                if (str.charAt(index)=='(') stack.push(index)\n                else if (str.charAt(index)==')') {\n                    val top = stack.pop()\n                    if (stack.empty) good = false // = false // flag to indicate whether there's any way to make good string\n                    else if (stack.top() < top-1) good = false\n                    else if (stack.top()==top+1 && stack.contains(top-1)) good = false\n                    else stack.push(top)\n                }\n                index++\n            }\n            if (stack.empty) \"\"\n            else good ? \"Yes\" : \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp9_tm7_o7.scala:33:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                index++\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9_tm7_o7.scala:28:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    \u001b[33mif\u001b[0m (stack.empty) good = \u001b[31mfalse\u001b[0m \u001b[34m// = false // flag to indicate whether there's any way to make good string\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    scala.collection.mutable.Stack[Int @uncheckedVariance]\n\u001b[31m   |\u001b[0m        Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp9_tm7_o7.scala:29:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (stack.top() < top-\u001b[31m1\u001b[0m) good = \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mmethod\u001b[0m \u001b[35mtop\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mStack\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp9_tm7_o7.scala:30:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                    \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (stack.top()==top+\u001b[31m1\u001b[0m && stack.contains(top-\u001b[31m1\u001b[0m)) good = \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mmethod\u001b[0m \u001b[35mtop\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mStack\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9_tm7_o7.scala:35:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mif\u001b[0m (stack.empty) \u001b[31m\"\"\u001b[0m\n\u001b[31",
      "stdout": "",
      "timestamp": 1659980040
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        //If we have two string and they have no parenthesis\n        if(lst.size == 2){\n            val p1 = lst.head\n            val p2 = lst.last\n            p1 match {\n                case s\"${p2}$\" => s\"Yes\"\n                case _ => s\"No\"\n            }\n        }\n        //If there is one string with parenthesis\n        else if(lst.size == 1){\n            val p1 = lst.head\n            p1 match {\n                case s\"${p1}$\" => s\"Yes\"\n                case _ => s\"No\"\n            }\n        }\n        //If there is no parenthesis\n        else {\n            val p1 = lst.head\n            p1 match {\n                case s\"${p1}$\" => s\"Yes\"\n                case _ => s\"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp3mgsltuv.scala:23:39 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31ms\"\u001b[0m${p2}\u001b[31m$\" => s\"Yes\u001b[0m\"\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmp3mgsltuv.scala:31:39 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31ms\"\u001b[0m${p1}\u001b[31m$\" => s\"Yes\u001b[0m\"\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       unclosed string literal\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3mgsltuv.scala:39:36 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31ms\"\u001b[0m${p1}\u001b[31m$\" => s\"Yes\u001b[0m\"\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            '=>' expected, but string interpolator found\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980037
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var ret = \"No\"\n        if (lst.size != 2) return ret\n        val head = (lst.head)\n        val tail = (lst.tail)\n        var open = 0\n        var close = 0\n        if (head.charAt(0) == '(') open = 1\n        if (head.charAt(0) == ')') close = 1\n        if (head.charAt(1) == '(') open += 1\n        if (head.charAt(1) == ')') close += 1\n        if (close != open) return \"No\"\n        var res = 0\n        tail.foreach(x => {\n            if (x == '(') open += 1\n            if (x == '[' || x == '{' || x == '(') open -= 1\n            if (x == ')' || x == ']' || x == ')') close -= 1\n            if (x == '}' || x == '}') close -= 1\n            if (open == 0 && close == 0) res +=1\n        })\n        if (res == 0) ret = \"Yes\"\n        return ret\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpvskw4m05.scala:31:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mif\u001b[0m (x == \u001b[31m'('\u001b[0m) open += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpvskw4m05.scala:32:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mif\u001b[0m (x == \u001b[31m'['\u001b[0m || x == \u001b[31m'{'\u001b[0m || x == \u001b[31m'('\u001b[0m) open -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpvskw4m05.scala:32:28 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mif\u001b[0m (x == \u001b[31m'['\u001b[0m || x == \u001b[31m'{'\u001b[0m || x == \u001b[31m'('\u001b[0m) open -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpvskw4m05.scala:32:40 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mif\u001b[0m (x == \u001b[31m'['\u001b[0m || x == \u001b[31m'{'\u001b[0m || x == \u001b[31m'('\u001b[0m) open -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpvskw4m05.scala:33:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mif\u001b[0m (x == \u001b[31m')'\u001b[0m || x == \u001b[31m']'\u001b[0m || x == \u001b[31m')'\u001b[0m) close -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpvskw4m05.scala:33:28 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mif\u001b[0m (x == \u001b[31m')'\u001b[0m || x == \u001b[31m']'\u001b[0m || x == \u001b[31m')'\u001b[0m) close -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Value",
      "stdout": "",
      "timestamp": 1659980040
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val (left, right) = (lst.head match {\n        case '(' => Some(lst.tail.head),\n        case ')' => Some(lst.tail.head),\n        case _ => None\n      }) match {\n        case Some(x) => Some((x.mkString))\n        case None => \"No\"\n      }\n      if(left.isEmpty && right.isEmpty)\n        \"Yes\"\n      else\n        matchParens(lst.tail) match {\n          case \"\" => \"Yes\"\n          case _ => left.get + right.get + matchParens(lst.tail)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpikzcoll9.scala:19:39 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mcase\u001b[0m \u001b[31m'('\u001b[0m => Some(lst.tail.head),\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but ',' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpikzcoll9.scala:19:13 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mcase\u001b[0m \u001b[31m'('\u001b[0m => Some(lst.tail.head),\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpikzcoll9.scala:24:13 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mcase\u001b[0m None => \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    None.type\n\u001b[31m   |\u001b[0m             Required: Some[String]\n\u001b[31m   |\u001b[0m             pattern type is incompatible with expected type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpikzcoll9.scala:26:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m      \u001b[33mif\u001b[0m(left.isEmpty && right.isEmpty)\n\u001b[31m\u001b[31m   |\u001b[0m         ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         value isEmpty is not a member of Any\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpikzcoll9.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m          \u001b[33mcase\u001b[0m _ => left.get + right.get + matchParens(lst.tail)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value get is not a member of Any\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659980039
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      lst.foldLeft(\"Yes\") { (result, e) =>\n        val parens = e.split(\"\\\\(\").length\n        if (parens == lst.filter(s => s.startsWith(e)).size) {\n          result + \"Yes\"\n        } else {\n          result + \"No\"\n        }\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp02t25e1j.scala:28)\n\tat Problem.main(tmp02t25e1j.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980041
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      val stack = mutable.Stack[String]()\n      var ret = \"No\"\n      for(x <- lst) {\n        if(x contains '(') {\n          stack.push(x)\n        }\n        if(x contains ')') {\n          if(stack.size > 0) {\n            stack.pop\n            if(stack.size == 0) {\n              ret +=\"Yes\"\n            }\n          }\n        }\n      }\n      ret\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5la_gaor.scala:18:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980038
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val str1 = lst(0) // first string in lst\n        val str2 = lst(1) // second string in lst\n        val stack = ListBuffer[String]() // stack for checking\n        val stackSize = lst.size - 2 // number of open parentheses in lst\n        val index = 0\n        while (index < stackSize) {\n            if (str1 == \"(\") {\n                stack.push(str1)\n                index += 1\n            }\n            if (str1 == \")\") {\n                val lastStr = stack.pop\n                if (lastStr != \"(\") {\n                    return \"No\"\n                }\n                index += 1\n            }\n        }\n        if (index == stackSize) {\n            return \"Yes\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl7gg2gkq.scala:25:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                stack.push(str1)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue push is not a member of scala.collection.mutable.ListBuffer[String] - did you mean stack.last?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl7gg2gkq.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                index += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean index.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl7gg2gkq.scala:29:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mlastStr\u001b[0m = stack.pop\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue pop is not a member of scala.collection.mutable.ListBuffer[String] - did you mean stack.drop?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl7gg2gkq.scala:33:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                index += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean index.!=?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659980041
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        def matchParens(lst : List[String], s : String) : String = {\n            if (lst.isEmpty)\n                \"No\"\n            else if (lst.head == \"(\")\n                matchParens(lst.tail, \"Yes\") + matchParens(lst.tail, s.dropRight(1))\n            else if (lst.head == \")\")\n                matchParens(lst.tail, s.dropRight(1) + matchParens(lst.tail, \"Yes\"))\n            else if (lst.head == \"Yes\" && lst.tail.head == \"Yes\")\n                matchParens(lst.tail.tail, lst.head + s)\n            else\n                matchParens(lst.tail, \"No\")\n        }\n\n        matchParens(lst, \"\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpml6zwhzz.scala:34)\n\tat Problem.main(tmpml6zwhzz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980042
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val bList: List[Boolean] = lst.map( x => (x == \"(\") ? true : false)\n        val aList: List[Boolean] = lst.map( x => (x == \"(\") ? false : true)\n        if (bList.reduce(_ && _) && aList.reduce(_ && _)) {\n            if (bList.reduce(_ * _) && aList.reduce(_ * _)) {\n                if (bList.reduce(_ * _ * aList.reduce(_ * _))) \n                    \"Yes\" else \"No\"\n                \n                else {\n                    val newList: List[String] = lst.map(x => x + \"()\")\n                    if (newList.reduce(_ + _)) \"Yes\" else \"No\"\n                }\n            } else {\n                if (bList.reduce(_ * _)) \"Yes\" else \"No\"\n                else \n                    val newList: List[String] = lst.map(x => x + \"()\")\n                    if (newList.reduce(_ + _)) \"Yes\" else \"No\"\n            }\n        }\n        else \n            if (bList.reduce(_ * _)) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpcrbxw2wk.scala:25:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                end of statement expected but 'else' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpcrbxw2wk.scala:31:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                \u001b[33melse\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                end of statement expected but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcrbxw2wk.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            }\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0m            '}' expected, but unindent found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcrbxw2wk.scala:18:60 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbList\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mBoolean\u001b[0m] = lst.map( \u001b[36mx\u001b[0m => (x == \u001b[31m\"(\"\u001b[0m) ? \u001b[31mtrue\u001b[0m : \u001b[31mfalse\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      value ? is not a member of Boolean\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcrbxw2wk.scala:19:60 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maList\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mBoolean\u001b[0m] = lst.map( \u001b[36mx\u001b[0m => (x == \u001b[31m\"(\"\u001b[0m) ? \u001b[31mfalse\u001b[0m : \u001b[31mtrue\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      value ? is not a member of Boolean\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcrbxw2wk.scala:21:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m (bList.reduce(_ * _) && aList.reduce(_ * _)) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue * is not a member of Boolean, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   ",
      "stdout": "",
      "timestamp": 1659980042
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[List[String]]()\n        for(x <- lst)\n            if(x.toList.size == 0)\n                stack += x\n            else if(x.toList(0).toString == \"(\")\n                stack += x.drop(1)\n            else if(!stack.isEmpty){\n                if(x.toList(0).toString == \")\" && stack.last.toList(0).toString == \"(\")\n                    stack.pop()\n                else\n                    stack += x\n            }\n        if(stack.size <= 0)\n            \"No\"\n        else\n            \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp755alnk9.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mList\u001b[0m[\u001b[35mString\u001b[0m]]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980039
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if(lst.length == 0) \"Yes\"\n        else if(lst.length == 1) \"No\"\n        else if(lst.length == 2) \"Yes\"\n        else matchParens(lst.tail) + matchParens(lst.init)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp447lpzni.scala:25)\n\tat Problem.main(tmp447lpzni.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980042
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var good = \"Yes\"\n        for (a <- lst if a.contains(\"(\")) {\n            for (b <- lst if b.contains(\")\")) {\n                val newA = a.substring(a.indexOf(\"(\"), a.lastIndexOf(\")\"))\n                val newB = b.substring(b.indexOf(\"(\"), b.lastIndexOf(\")\"))\n                if ((newA + newB) == a) {\n                    good = \"No\"\n                    break\n                }\n            }\n        }\n        good\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8t6d7660.scala:25:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980039
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = Stack.empty[String]\n        val result = Stack.empty[String]\n        lst.reverse.foreach(x => {\n            if(x == \"(\") {\n                stack.push(x)\n            } else if(x == \")\") {\n                if(!stack.peek().equals(\"(\")) {\n                    result += \"No\"\n                } else {\n                    if(!stack.peek().equals(\"(\")) {\n                        result += \"Yes\"\n                    }\n                }\n                stack.pop()\n            }\n        })\n        result.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5c8y28_k.scala:24:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mif\u001b[0m(!stack.peek().equals(\u001b[31m\"(\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue peek is not a member of scala.collection.mutable.Stack[String] - did you mean stack.head?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5c8y28_k.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                    \u001b[33mif\u001b[0m(!stack.peek().equals(\u001b[31m\"(\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue peek is not a member of scala.collection.mutable.Stack[String] - did you mean stack.head?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980042
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val stack = mutable.Stack[String]()\n        val stackWithParen = mutable.Stack[Boolean]()\n\n        def addParen(s: String) : Unit = {\n            if (s.contains(\"(\") || s.contains(\")\")) stackWithParen.push(true)\n            else stackWithParen.push(false)\n            stack += s\n        }\n\n        lst.foreach { s =>\n            if (s.contains(\"(\")) {\n                addParen(s)\n            }\n            if (s.contains(\")\")) {\n                if (stack.size == 1 && stackWithParen.head) {\n                    return \"Yes\"\n                } else {\n                    return \"No\"\n                }\n            }\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg_24b678.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg_24b678.scala:19:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstackWithParen\u001b[0m = mutable.Stack[\u001b[35mBoolean\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980040
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        //Write your code here\n        if(lst.size < 2) \n            return \"No\"\n        else\n           var open = 1\n           var close = 0\n           var str = \"\"\n           var curStr = lst(0)\n           var result = \"No\"\n           while(curStr != \"\") {\n                if(curStr == \"(\") \n                    open += 1\n                else if(curStr == \")\")\n                    close += 1\n                else\n                    return \"No\"\n\n                if(open > close)\n                    result = \"Yes\"\n                curStr = lst(open)\n                open -= 1\n                close += 1\n           }\n           return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmprr5nc9g6.scala:44)\n\tat Problem.main(tmprr5nc9g6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980043
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if(lst.isEmpty) \n            \"No\" \n        else if(lst.head == lst.last.head) {\n            val s = lst.tail\n            (lst.head == s.head) match {\n                case true => matchParens(s.tail)\n                case _ => \"No\"\n            }\n        } else {\n            val s = lst.tail\n            matchParens(s.tail) match {\n                case true => \"Yes\"\n                case _ => matchParens(s.tail)\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp3mcs8i4v.scala:20:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(lst.head == lst.last.head) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3mcs8i4v.scala:29:21 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31mtrue\u001b[0m => \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    (\u001b[31mtrue\u001b[0m : Boolean)\n\u001b[31m   |\u001b[0m                     Required: String\n\u001b[31m   |\u001b[0m                     pattern type is incompatible with expected type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980043
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var flag = 1\n        var res : String = \"\"\n        for (x <- lst) {\n            val s = x.replaceAll(\"\\\\(\", \"\").replaceAll(\"\\\\)\", \"\")\n            val l = s.length\n            var cur = 0\n            var sum = 0\n            var flag = 0\n            for(i <- 0 until s.length){\n                if(s.charAt(i) == '('){\n                    sum += 1\n                } else if(s.charAt(i) == ')'){\n                    if(sum > 0){\n                        sum -= 1\n                    } else {\n                        flag = 1\n                    }\n                }\n                cur += 1\n            }\n            if(flag == 0){\n                res = \"No\"\n                break\n            }\n            res = res + \"(\" + s.substring(cur, cur + l) + \")\"\n        }\n        if (res.equals(\"\")) {\n            res = \"Yes\"\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqb9nj7r4.scala:40:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980042
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n      require(!lst.isEmpty)\n      var stack = Stack(lst.head)\n      var result = true\n      for (a <- lst.tail) {\n        if (stack.hasLeft) {\n          stack.peek.right\n          stack.pop()\n        } else {\n          if (stack.hasRight) {\n            stack.peek.left\n            stack.pop()\n          } else {\n            stack.pop()\n          }\n          stack.pop()\n        }\n      }\n      if (stack.hasLeft) {\n        result = \"No\"\n      } else if (stack.hasRight) {\n        result = \"Yes\"\n      }\n      result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg4fajul7.scala:22:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mif\u001b[0m (stack.hasLeft) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue hasLeft is not a member of scala.collection.mutable.Stack[String] - did you mean scala.collection.mutable.Stack[String].scanLeft?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg4fajul7.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m          stack.peek.right\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue peek is not a member of scala.collection.mutable.Stack[String] - did you mean scala.collection.mutable.Stack[String].head?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg4fajul7.scala:26:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m          \u001b[33mif\u001b[0m (stack.hasRight) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue hasRight is not a member of scala.collection.mutable.Stack[String] - did you mean scala.collection.mutable.Stack[String].scanRight?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg4fajul7.scala:27:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            stack.peek.left\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue peek is not a member of scala.collection.mutable.Stack[String] - did you mean scala.collection.mutable.Stack[String].head?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg4fajul7.scala:35:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m      \u001b[33mif\u001b[0m (stack.hasLeft) {\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue hasLeft is not a member of scala.collection.mutable.Stack[String] - did you mean scala.collection.mutable.Stack[String].scanLeft?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpg4fajul7.scala:36:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        result = \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    (\u001b[32m\"No\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                 Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation avail",
      "stdout": "",
      "timestamp": 1659980044
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val p = lst.foldLeft(List[List[String]]()) {\n            (acc, x) =>\n                if (acc.isEmpty) x :: acc.head\n                else if (x.charAt(0) == '(' && acc.last.last.charAt(0) == ')') acc.last.last + x else acc :+ x\n        }\n        p.filter(_.length == 2).foldLeft(List[String]()) {\n            (acc, x) =>\n                if (x.charAt(0) == '(' && acc.last.last.charAt(0) == ')') acc.last.last + x\n                else if (acc.isEmpty) x :: acc.head\n                else {\n                    if (acc.last.last != x.charAt(0)) acc :+ x else acc :+ acc.last.last + x\n                }\n        }.head\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp06mx41g0.scala:20:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                \u001b[33mif\u001b[0m (acc.isEmpty) x :: acc.head\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    List[String]\n\u001b[31m   |\u001b[0m                                 Required: List[\u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mString\u001b[1m\u001b[32m]\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp06mx41g0.scala:21:79 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'('\u001b[0m && acc.last.last.charAt(\u001b[31m0\u001b[0m) == \u001b[31m')'\u001b[0m) acc.last.last + x \u001b[33melse\u001b[0m acc :+ x\n\u001b[31m\u001b[31m   |\u001b[0m                                                                               ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    String\n\u001b[31m   |\u001b[0m                                            Required: List[List[String]]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp06mx41g0.scala:21:109 -------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'('\u001b[0m && acc.last.last.charAt(\u001b[31m0\u001b[0m) == \u001b[31m')'\u001b[0m) acc.last.last + x \u001b[33melse\u001b[0m acc :+ x\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    (x : String)\n\u001b[31m   |\u001b[0m                                                  Required: List[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp06mx41g0.scala:25:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                \u001b[33mif\u001b[0m (x.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'('\u001b[0m && acc.last.last.charAt(\u001b[31m0",
      "stdout": "",
      "timestamp": 1659980044
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val lst1 = lst.map( x => x.split(\"(\").size)\n        val lst2 = lst.map( x => x.split(\")\").size)\n        val len = lst1.zipWithIndex.max( x => x._2 - x._1)\n        val l1 = lst1.filter( x => x._2 < len)\n        val l2 = lst2.filter( x => x._2 < len)\n        val l3 = lst1.filter( x => x._2 > len && x._2 < len)\n        val l4 = lst2.filter( x => x._2 > len && x._2 < len)\n        val s1 = l1.map( x => x._2).mkString(\"\")\n        val s2 = l2.map( x => x._2).mkString(\"\")\n        val s3 = l3.map( x => x._2).mkString(\"\")\n        val s4 = l4.map( x => x._2).mkString(\"\")\n        val n = l1.size + l2.size + l3.size + l4.size + 1\n        if (s1.isEmpty) {\n            if (s2.isEmpty) {\n                if (s3.isEmpty) {\n                    if (s4.isEmpty) {\n                        \"Yes\"\n                    } else {\n                        \"No\"\n                    }\n                } else {\n                    \"No\"\n                }\n            } else {\n                \"No\"\n            }\n        } else {\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp4jtuhe3r.scala:20:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlen\u001b[0m = lst1.zipWithIndex.max( \u001b[36mx\u001b[0m => x._2 - x._1)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4jtuhe3r.scala:21:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ml1\u001b[0m = lst1.filter( \u001b[36mx\u001b[0m => x._2 < len)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value _2 is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4jtuhe3r.scala:22:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ml2\u001b[0m = lst2.filter( \u001b[36mx\u001b[0m => x._2 < len)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value _2 is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4jtuhe3r.scala:23:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ml3\u001b[0m = lst1.filter( \u001b[36mx\u001b[0m => x._2 > len && x._2 < len)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value _2 is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4jtuhe3r.scala:24:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ml4\u001b[0m = lst2.filter( \u001b[36mx\u001b[0m => x._2 > len && x._2 < len)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value _2 is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4jtuhe3r.scala:25:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ms1\u001b[0m = l1.map( \u001b[36mx\u001b[0m => x._2).mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value _2 is not a member of Int\n\u001b[31m\u001b[31m-- [E",
      "stdout": "",
      "timestamp": 1659980044
    }
  ]
}