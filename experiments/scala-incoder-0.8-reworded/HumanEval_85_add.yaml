name: HumanEval_85_add
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a non-empty list of integers lst. add the even elements that are at\
  \ odd indices..\n    // Examples:\n    // >>> add((List[Long](4l.toLong, 2l.toLong,\
  \ 6l.toLong, 7l.toLong)))\n    // (2l)\n    def add(lst : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(add((List[Long](4l.toLong,\
  \ 88l.toLong))) == (88l));\n    assert(add((List[Long](4l.toLong, 5l.toLong, 6l.toLong,\
  \ 7l.toLong, 2l.toLong, 122l.toLong))) == (122l));\n    assert(add((List[Long](4l.toLong,\
  \ 0l.toLong, 6l.toLong, 7l.toLong))) == (0l));\n    assert(add((List[Long](4l.toLong,\
  \ 4l.toLong, 6l.toLong, 8l.toLong))) == (12l));\n    }\n\n}\n"
completions: ["        var sum = 0l\n        for (x <- lst) {\n            sum ++=\
    \ x % 2 == 0 ? x : 0\n        }\n        return sum", "        val map = mutable.Map[Long,\
    \ Long]()\n        lst.zipWithIndex.foreach{ case (x, y) => {\n            if\
    \ (y % 2 != 0) map.put(x, x + y) \n            else map.put(x, x) \n        }}\n\
    \        map.foldLeft(0l)((a, b) => a + b) ", "       lst.foldLeft(0l)((acc, x)\
    \ => {\n            if (x % 2 == 0) acc + x else acc\n       })", "        def\
    \ isEven(i: Long) =\n            if (i % 2 == 0) true else false\n        var\
    \ even = 0\n        for (i<- 0 until lst.size) {\n            if (isEven(lst(i)))\
    \ {\n                even = even + lst(i)\n            }\n        }\n        return\
    \ even", "        def sum(lst: List[Long]) : Long = lst.foldLeft(0L) { (sum, n)\
    \ => sum + n }\n        def even(lst : List[Long]) : Long = lst.filter(x => x\
    \ % 2 == 0).toList.sum\n        even(lst filter (_ % 2 == 0)).zip(lst filter (_\
    \ % 2 == 1)).map { case (x, y) => x + y }.reduce(_ + _)", "        val res = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        while (i < lst.size)\n            if (lst(i).isEven)\
    \ {\n                res += lst(i)\n                i += 1\n            }\n  \
    \          else i += 1\n        res.toList.sum", "        val evenIndex = lst.indices.filter\
    \ { _ % 2 == 0 }\n        lst.map { x =>\n            if (evenIndex.contains(x))\
    \ {\n                x + lst(x)\n            } else {\n                x\n   \
    \         }\n        }.sum", "        val even_elements = lst.filter(x => (x %\
    \ 2) == 0)\n        val odd_elements = lst.filter(x => (x % 2) == 1)\n       \
    \ val result = even_elements.zipWithIndex.map(x => x._1 + x._2).sum\n        result",
  "        var evenOddVal = lst.map(x => (x%2 == 0l)).sum\n        evenOddVal = evenOddVal.toLong\n\
    \        evenOddVal", "        // TODO: Write your code here\n        val even\
    \ = lst.filter(_ % 2 == 0).toList\n        val odd = lst.filter(_ % 2 == 1).toList\n\
    \        val sumEvenOdd = even.zip(odd).map(x => x._1 + x._2)\n        sumEvenOdd.sum",
  "        val evenIndices = lst.indices.filter(x => x % 2 != 0).map(x => (lst.apply(x).toLong))\n\
    \        val oddIndices = lst.indices.filter(x => x % 2 == 0).map(x => (lst.apply(x).toLong))\n\
    \        val sum = 0\n        evenIndices.foreach(x => sum += x)\n        oddIndices.foreach(x\
    \ => sum += x)\n        sum.toLong", "        var total = 0L\n        for (x <-\
    \ lst) {\n            if(x % 2 == 0) {\n                total = total + x\n  \
    \          }\n        }\n        return total", '        lst.filter(_ % 2 == 0).sum',
  "        if (lst.size <= 1)\n            1\n        else {\n            var sum\
    \ = 0\n            for (i <- lst.indices) {\n                if (i % 2 == 0)\n\
    \                    sum += lst(i)\n            }\n            sum\n        }",
  "        // Write your code here.\n        var evenLst =  mutable.ListBuffer[Long]()\n\
    \        for(i <- 0 until (lst.size - 1)) {\n            if(lst(i) % 2 == 0) {\n\
    \                evenLst += lst(i).toLong\n            }\n        }\n        evenLst.sum",
  "        val even = lst.takeWhile(x => x % 2 != 0).toList\n        val odd = lst.drop(even.length).toList\n\
    \        odd.zip(even).map(x => x._1 + x._2).sum", '      lst.zipWithIndex.filter(_._1
    % 2 == 0).map(_._2).sum', "        // Write your code here\n\n        val even_lst\
    \ = lst.filter(_ % 2 == 0)\n\n        if (even_lst.size > 0) {\n            val\
    \ odd_lst = lst.filter(_ % 2 != 0)\n            (even_lst ++ odd_lst).reduce((a,\
    \ b) => a + b)\n        } else {\n            0l\n        }", "        // O(n)\n\
    \        val l = lst.size\n        var sum = 0L\n        for (i <- 0 until l)\
    \ {\n            val idx = i / 2\n            sum += lst(i) match {\n        \
    \        case 0 => lst(i) // even at index i\n                case _ => lst(idx\
    \ + 1) // odd at index idx\n            }\n        }\n        sum", "        lst.length\
    \ % 2 != 0 => lst.sum\n        else lst.filter { x => x % 2 == 0 }.sum", "   \
    \      //val evensIndexes = lst.zipWithIndex.filter(x => x._2 % 2==0)\n      \
    \   //val oddsIndexes = lst.zipWithIndex.filter(x => x._2 % 2 != 0)\n        \
    \ //val indexes = evensIndexes ++ oddsIndexes\n         val indexes = lst.zipWithIndex.filter(x\
    \ => x._2 % 2 != 0)\n         lst.zipWithIndex.filter(x => x._2 % 2 == 0).map(_._1).sum",
  "        var result : Long = 0\n        for ((index, elem) <- lst.view.zipWithIndex\
    \ if elem % 2 == 0) result += elem\n        result", "        if (lst.size < 2)\
    \ 0l\n        else lst.takeWhile(n => n % 2l).sum", "        val even = lst.filter(_\
    \ % 2 == 0)\n        val odd = lst.filter(_ % 2 == 1)\n        even ++= odd.zipWithIndex.filter(_._1\
    \ == 0).map { case (_, idx) =>\n            idx + _._2\n        }", "        val\
    \ newList = mutable.LinkedHashSet.empty[Long]\n        lst.foreach(x => if (x\
    \ % 2 == 1) newList += x)\n        newList.size", "        var sum = 0\n     \
    \   for(i <- 0 until lst.length) {\n            if(lst.apply[i%2l].toDouble >\
    \ 0) {\n                sum = sum + lst.apply[i%2l]\n            }\n        }\n\
    \        return sum", "        val evenIndexes = lst.indices.filter(n => n % 2\
    \ == 0).map(i => i + 1)\n        val oddIndexes = lst.indices.filter(n => n %\
    \ 2 != 0).map(i => i + 1)\n        lst.zipWithIndex.flatMap(t => if (t._1 == t._2)\
    \ List((t._1, t._2 + 2)) else List((t._1, t._2))).reduceLeft(_ + _)", "      \
    \  if (lst.size < 2)\n            throw new ArithmeticException(\"Incorrect list:\
    \ size < 2\")\n        val even_element_list = lst.filter(_ % 2 == 0)\n      \
    \  val even_element_list_size = even_element_list.size\n        if (even_element_list_size\
    \ == 0)\n            throw new ArithmeticException(\"Incorrect list: list size\
    \ 0\")\n        if (even_element_list_size == 1)\n            return even_element_list.head\n\
    \        val odd_element_list = lst.filter(_ % 2 == 1)\n        val odd_element_list_size\
    \ = odd_element_list.size\n        if (odd_element_list_size == 0)\n         \
    \   throw new ArithmeticException(\"Incorrect list: list size 0\")\n        if\
    \ (odd_element_list_size == 1)\n            return odd_element_list.head\n   \
    \     val lst_with_all_even = even_element_list ++ odd_element_list\n        val\
    \ lst_with_all_even_and_odd = even_element_list ++ odd_element_list ++ lst.filter(_\
    \ % 2 == 1)\n        val even_idx = lst_with_all_even_and_odd.indexOf(even_element_list.head)\n\
    \        val odd_idx = lst_with_all_even_and_odd.indexOf(odd_element_list.head)\n\
    \        even_element_list ++ lst.filter(_ % 2 == 0)", "        for (i <- 0 until\
    \ lst.size) {\n            val j = lst.size / 2\n            if (i % 2 == 0)\n\
    \                lst.add(i * j)\n            else\n                lst.add(i *\
    \ j)\n        }\n        lst.last", "        val result = new mutable.ArrayBuffer[Long]()\n\
    \        for (i <- 0 until lst.size) {\n            if (i % 2 == 0) {\n      \
    \          result += lst(i)\n            }\n        }\n        result.sum", " \
    \       // O(n) solution\n        val evenList = mutable.ListBuffer[Long]()\n\
    \        for (i <- 0 until lst.size) {\n            if(i %% 2 == 0) {\n      \
    \          evenList += lst(i)\n            }\n        }\n\n        // O(n) solution\n\
    \        evenList.sum", "        var sum = 0\n        // use for loop to iterate\
    \ through list\n        lst.foreach {\n            case i if i % 2 == 0 => sum\
    \ = sum + i\n            case i => sum = sum + i\n        }\n        sum", " \
    \       val result: mutable.MutableList[Long] = mutable.MutableList[Long]()\n\
    \        lst.foreach( l => { \n            if(l % 2 == 0) result += l \n     \
    \   })\n        val even: Long = result.filter(_.isEven).sum\n        result.take(result.length).filter(\
    \ _.isEven).sum", "        var evenIndex = 0\n        var evenSum = 0\n      \
    \  var oddSum = 0\n        var oddIndex = 0\n        for (i <- lst.indices) {\n\
    \            if (i % 2 == 0) {\n                evenSum += lst(i)\n          \
    \      evenIndex = i\n            } else {\n                oddSum += lst(i)\n\
    \                oddIndex = i\n            }\n        }\n        return evenSum\
    \ + oddSum", "        var ans = 0l\n        lst.foreach(x => {\n            if\
    \ (x % 2 == 0)\n                ans = ans + x\n        })\n        ans", "   \
    \   val result = mutable.ArrayBuffer.empty[Long]\n      lst.foldLeft(result) {\
    \ case (res, i) => if (i%2 == 0) res.add(i.toLong) }\n      result.remove(0)",
  "        var result : Long = 0\n        for(i <- 0 to lst.size-1) {\n          \
    \  if (i % 2 == 0) result += lst(i); \n        }\n        return result;", '        lst',
  "        val evenList = lst\n        evenList.zipWithIndex.filter(x => x._2.toDouble\
    \ % 2 == 0).map(_._1).sum", "        val evenList = lst.filter(x => x.toInt %\
    \ 2 == 0)\n        val oddList = lst.filter(x => x.toInt % 2 != 0)\n        val\
    \ oddSum = oddList.foldLeft(0l)(_ + _)\n        evenList zip oddList map { case\
    \ (e, od) => e + od } reduceLeft { (x, y) => x + y }", "        var even = 0\n\
    \        var odd = 0\n        var evenIdx = 0\n        var oddIdx = 0\n      \
    \  for(i <- 0 until lst.length){\n            if(i%2==1){\n                odd\
    \ += lst(i).toLong\n            }\n            else{\n                even +=\
    \ lst(i).toLong\n            }\n        }\n        val res = if (even == odd)\
    \ even else odd + (even%2==0 ? even : even)\n        evenIdx = evenIdx+even\n\
    \        oddIdx = oddIdx+odd\n        if (evenIdx == lst.length) res+even\n  \
    \      else if (oddIdx == lst.length) res+odd\n        else res+even", "     \
    \   val evenIndices = lst.zipWithIndex.filter{ case (elem, index) => index % 2\
    \ == 0}\n        val oddIndices = lst.zipWithIndex.filter{ case (elem, index)\
    \ => index % 2 != 0}\n\n        val result = evenIndices.map(_._1)\n         \
    \       .zip(oddIndices.map(_._1))\n                .foldLeft(0L) { (acc, elem)\
    \ => acc + elem._2}\n\n        result + (if(lst.exists(_ % 2 == 0)) 1 else 0)",
  "        // return 0L\n        if (lst.exists(x => x % 2 != 0) || lst.count(x =>\
    \ x % 2 != 0) <= 1L) return 0L\n        val evenEven = lst.filterNot(x => x %\
    \ 2 != 0)\n        val oddEven = lst.filterNot(x => x % 2 != 0).filterNot(x =>\
    \ x % 2 != 0)\n        val evenOdd = lst.filterNot(x => x % 2 != 0).filterNot(x\
    \ => x % 2 != 0)\n        val result = evenEven.reduce(_ + _)\n        result\
    \ += oddEven.reduce(_ + _)\n        result += evenOdd.reduce(_ + _)\n        result",
  "        val a = lst.foldLeft((0l,0l))((x,y) => x._1 + y._2) // use sum for even\
    \ elements\n        val b = lst.foldLeft((0l,0l))((x,y) => x._2 + y._2) // use\
    \ sum for odd elements\n        (a._1 + b._1, a._2 + b._2)", "        var lstEven:\
    \ List[Long] = Nil\n        for(i <- 0 until lst.size ) {\n            if(lst(i)\
    \ % 2 == 0) lstEven += lst(i).toLong\n        }\n        lst.size + lstEven.length",
  "        val res = new mutable.ListBuffer[Long]\n        lst.reverse.foreach{x =>\
    \ if (x.mod(2l).toInt != 0) res += x }\n        res.toList.reverse.sum", "   \
    \     val evenEles = lst.filter( _ % 2 == 0)\n        val oddEles = lst.filter(\
    \ _ % 2 == 1)\n        val newList = oddEles ::: evenEles\n        lst.sum", " \
    \       // write your code in Scala here\n        lst.zip(lst.drop(1)).filter(_._2.toLong\
    \ % 2l.toLong != 0l).map(_._1).sum", "       \n        //val result = lst.map\
    \ {\n           // case x: Long if x % 2 == 1 => x\n        //}\n        val result\
    \ = lst.foldLeft(0l) {\n        case (x, i) if i % 2 != 0 => x + (2l.toLong)\n\
    \        case (x, i) if i % 2 == 1 => x + (1l.toLong)\n        }\n        result",
  '        lst.foldRight(0)(_ + _)', "        val evens = lst.filter(x => (x % 2)\
    \ == 0)\n        val odds = lst.filter(x => (x % 2) != 0)\n        val res = evens\
    \ ++ odds\n        res", "        // write your logic here\n        // ...\n \
    \       val m = lst.size.toLong\n        if(m == 0) 0L\n        else if(m % 2\
    \ == 0) lst.foldLeft(0L)(_ + _)\n        else add(lst.tail :+ lst.head) ", " \
    \      // Solution for odd:\n       var sum = 0L\n       var count = 0L\n    \
    \   lst.foreach { n =>\n          if (n % 2 == 0) {\n              sum += n\n\
    \              count += 1\n          }\n       }\n       // Solution for even:\n\
    \       if (count % 2 == 0) {\n          sum -= lst(count / 2)\n          count\
    \ -= 1\n       }\n       sum", "        val lst1 = lst.filter(x => (x % 2) ===\
    \ 1)\n        val lst2 = lst.filter(x => (x % 2) === 0)\n        val lst3 = lst1\
    \ ++ lst2\n        return lst3.sum", "        if (lst.isEmpty) 0\n        else\
    \ {\n            var even_count = 0\n            var even_sum = 0\n          \
    \  var odd_count = 0\n            var odd_sum = 0\n            for(i <- 0 until\
    \ lst.size) {\n                if(i % 2 == 0) {\n                    even_sum\
    \ += lst(i)\n                    even_count += 1\n                }else {\n  \
    \                  odd_sum += lst(i)\n                    odd_count += 1\n   \
    \             }\n            }\n            return even_sum + odd_sum\n      \
    \  }", "        // Find the odd indices first\n        var odd_indices = lst.indices\n\
    \            .filter(i => lst.tail.exists(j => j %2 != 0))\n            .toList\n\
    \n        // Find the even indices\n        var even_indices = lst.indices\n \
    \           .filter(i => lst.tail.exists(j => j %2 == 0))\n            .toList\n\
    \n        // Calculate the result\n        var sum = 0\n        odd_indices.foreach(i\
    \ => sum += lst.apply(i))\n        even_indices.foreach(i => sum += lst.apply(i))\n\
    \        sum", "        val (even, odd) = lst.span(_ % 2 == 0)\n        val indexed\
    \ = odd.zipWithIndex\n        indexed.filter(_._1.isDefined).map { case (odd,\
    \ idx) =>\n            if(even.contains(odd.toLong)) odd.toLong + idx\n      \
    \      else odd.toLong\n        }.sum", "        val ls = mutable.ListBuffer.empty[Long]\n\
    \        lst.foreach{\n          case x if(x % 2 == 0) => ls +=x\n          case\
    \ x =>\n        }\n        ls.sum", "      var res=lst.foldLeft(0)((x,y) => x+y)\n\
    \      res.zip(lst).filter(_._1%2==0).map(_._2)", "        lst.foldLeft[Long](0l)\
    \ { (sum, elem) =>\n            if(elem % 2==1)\n                sum + elem\n\
    \            else sum\n        }", '      lst.filter(_ % 2 == 0).sum', "     \
    \   if(lst.isEmpty) {\n            throw new Exception(\"Empty list\")\n     \
    \   }\n\n        def rec(lst : List[Long], idx : Long) : List[Long] = {\n    \
    \        if(!lst(idx).toString.toInt/2 == 1) {\n                lst ::: List(lst(idx).toString.toInt/2)\n\
    \            } else {\n                rec(lst, idx+1)\n            }\n      \
    \  }\n\n        rec(lst, 0)", '        lst.zip(lst.tail).filter{ case (a: Long,
    b: Long) => b%2==0 && a%2!=0 }.foldLeft(0l) { (acc, elem) => acc+elem }', "  \
    \      val even_lst = lst.filter(_ % 2 == 0)\n        val odd_lst = lst.filter(_\
    \ % 2 != 0)\n        val even_sum = 0\n        val odd_sum = 0\n        lst.foreach{\n\
    \            e => {\n                if(e % 2 == 0) {\n                    even_sum\
    \ += e\n                } else {\n                    odd_sum += e\n         \
    \       }\n            }\n        }\n        if(even_lst.size == even_sum) {\n\
    \            return even_sum\n        } else {\n            return odd_sum\n \
    \       }", "        if (lst.isEmpty) 0\n        else {\n            val lst_n\
    \ = lst.size // lst.length\n            val even_sum = lst.filter(_ % 2 == 0l).sum\n\
    \            val odd_sum = lst_n - even_sum\n            lst_n - even_sum + even_sum\
    \ + odd_sum\n        }", "      var evens =  mutable.ListBuffer[Long]()\n    \
    \  var odds = mutable.ListBuffer[Long]()\n\n      lst.foreach(i => if (i % 2==0)\
    \ evens += i)\n      lst.foreach(i => if (i % 2 !=0) odds += i)\n      evens.toList.sum\
    \ + odds.toList.sum", "        var evens = lst.drop(lst.size /2);\n        var\
    \ odds = lst.take(lst.size /2);\n        val odd_even_pairs = odds.zip(evens);\n\
    \        odd_even_pairs.filter(x => x._2 == x._1).map(x => x._1).sum", '        if(lst.size
    < 2) lst.head else (lst(0) + lst(1))', '        lst.map(v => (v % 2 != 0) ? (v
    + 2) : v).toList', "        if(lst.length < 2) lst.head\n        else lst.head\
    \ + lst.tail.map(_ % 2 == 0).sum", "      lst.foldLeft((0,0l)) {\n        case\
    \ ((sum, even), x) => if(x % 2 == 0) sum + even else (sum, even)\n      }._2",
  "        var evenSum = 0\n        var oddSum = 0\n        for(i <- 0 until lst.size)\
    \ {\n            val n = lst(i)\n            if (i % 2 == 0) {\n             \
    \   evenSum += n\n            } else {\n                oddSum += n\n        \
    \    }\n        }\n        return evenSum + oddSum", "        val even = lst.filter(_%2==0).toList\n\
    \        val odd = lst.filter(_%2!=0).toList\n        odd.zip(even).map {\n  \
    \          case (x, y) => x+y\n        }.sum", "        var sum = 0\n        lst.foreach{\
    \ e =>\n            if (e % 2 == 0) {\n                sum += e\n            }\n\
    \        }\n        return sum", "        if (lst.isEmpty)\n            return\
    \ 0\n        val evenElems = lst.filter { x => x % 2 == 0 }\n        val oddElems\
    \ = lst.filter { x => x % 2 != 0 }\n        var sum = 0\n        for (i<-0 until\
    \ evenElems.length)\n            sum += evenElems(i) * 2\n        for (i<-0 until\
    \ oddElems.length)\n            sum += oddElems(i) * 2\n        sum", '        lst.filter(elem
    => elem.toLong % 2 != 0L).sum', "         var sum = 0\n         var evenIdx =\
    \ 0\n         var oddIdx = 0\n         for(i <- lst.zipWithIndex){\n         \
    \    if(even(lst(i)) && oddIdx < lst.size){\n                 sum += lst(oddIdx)\n\
    \                 oddIdx += 1\n             }\n             evenIdx += 1\n   \
    \      }\n         sum", "        var result = List[Long]()\n        lst.foreach{x\
    \ => if (x % 2 == 0) result = result :+ x}\n        result.reduce(_ + _)", " \
    \       val evens = lst.filter( i => (i % 2 == 0))\n        val odds = lst.filter(\
    \ i => (i % 2 == 1))\n        val evensOdds = evens ++ odds\n        evensOdds.sum",
  "        var sum = 0\n        var evenSum = 0\n        var oddSum = 0\n        lst.foreach{\n\
    \            i =>{\n                if(i%2 == 0){\n                    evenSum\
    \ += i\n                } else {\n                    oddSum += i\n          \
    \      }\n            }\n        }\n        sum = evenSum + oddSum\n        return\
    \ sum", '        lst.map(_+2).sum', '        // Add code here', "        val map\
    \ = new mutable.LinkedHashMap[Long,Long]()\n        var sum = 0L\n        var\
    \ i = 0\n        while(i < lst.size) {\n            if(map(i) == null) {\n   \
    \             map(i) = lst(i)\n            }\n            else {\n           \
    \     sum += map(i)\n            }\n            i += 1\n        }\n        sum",
  "        val map = new mutable.HashMap[Long, Long]()\n        for (e <- lst) {\n\
    \            map.put(e, e % 2l)\n        }\n        map.values.sum", "       \
    \ var evenSum = 0\n        lst.foreach(x => if (x % 2 == 0) evenSum += x)\n  \
    \      evenSum", "        require(lst.nonEmpty)\n        val summed = lst.foldLeft(0l)((a,\
    \ v) => if (v % 2 == 0) a + v else a)\n        lst.foreach((v) => v - summed)",
  "        val lc = new ListBuffer(0)\n        lst.zipWithIndex.foreach { case (v,\
    \ i) =>\n            if (i%2 == 0) lc.append(v)\n        }\n        lc.sum", '        lst.foldLeft(0l){(a,b)
    => if (b % 2 == 0) a + b else a}', '        lst.foldLeft(1l) { (sum, i) => sum
    + i }', "        val evens = new mutable.ListBuffer[Long]()\n        val odds\
    \ = new mutable.ListBuffer[Long]()\n        for (i<-lst.size) {\n            if\
    \ (i % 2 == 0) {\n                evens += lst(i)\n            } else {\n    \
    \            odds += lst(i)\n            }\n        }\n        if (evens.size\
    \ == 0) 1l else evens.head + add(evens.tail)", "        val indexedLst = lst.zipWithIndex.filter(_._2\
    \ % 2 == 0)\n        val even = indexedLst.filter(_._2 % 2 == 0)\n        val\
    \ odd = indexedLst.filter(_._2 % 2 != 0)\n        val evenEvenSum = even.foldLeft(0l)((sum,\
    \ e) => sum + e)\n        val oddEvenSum = odd.foldLeft(0l)((sum, e) => sum +\
    \ e)\n        return evenEvenSum + oddEvenSum", "        val odds = lst.filter(x\
    \ => x % 2l.toLong != 0)\n        val evens = lst.filter(x => x % 2l.toLong ==\
    \ 0)\n        evens.zipWithIndex.map(x => odds(x._2).toLong).sum", "        def\
    \ go(lst : List[Long], acc : mutable.Long) : mutable.Long = {\n            if(lst.nonEmpty)\
    \ {\n                val head = lst(0)\n                val tail = lst.tail\n\
    \                val result = acc\n                val even = result % 2 == 0\n\
    \                val odd = result % 2 != 0\n                if(even) {\n     \
    \               if(odd) {\n                        result += head\n          \
    \              go(tail, result)\n                    } else {\n              \
    \          result += head + head\n                        go(tail, result)\n \
    \                   }\n                } else {\n                    result +=\
    \ head + head\n                    go(tail, result)\n                }\n     \
    \       }\n            acc\n        }\n        go(lst, new mutable.Long(0))",
  "        val (evens, odds) = (lst.reverse map {_ % 2 == 0}, lst map {_ % 2 == 0})\n\
    \        evens.flatten.foldLeft(0l) {_ + _ * 2} + odds.flatten.foldLeft(0l) {_\
    \ + _ * 2}", "        val even = lst.filter(_ % 2 != 0)\n        val odd = lst.filter(_\
    \ % 2 == 0)\n        even.head + odd.head", "        val even_even = lst.filter(x\
    \ => x.toInt % 2 == 0)\n        val even_odd = lst.filter(x => x.toInt % 2 !=\
    \ 0)\n        even_odd.foldLeft(0l) { (l, x) =>\n            l + x.toLong\n  \
    \      }", "        val numEvenIndexes = lst.filter(_ % 2 == 0).toList\n     \
    \   numEvenIndexes.foldLeft(1L)((x, y) => x + y)", "        lst\n            .zipWithIndex\n\
    \            .flatMap{ case (elem, idx) => if(idx % 2 == 0) Some(elem) else None}\n\
    \            .foldLeft(0l){ (total, l) => (total + l)}", "        var evenNums\
    \ = lst.filter(x => x % 2 == 0).toList\n        var oddNums = lst.filter(x =>\
    \ x % 2 != 0).toList\n\n        val newList = oddNums.filterNot(evenNums)\n  \
    \      val sum = evenNums.sum\n\n        return sum + newList", "        if (lst.isEmpty)\
    \ 0\n        else if (lst.tail.isEmpty) lst.head + lst(0)\n        else {\n  \
    \          val x = lst(0)\n            val y = lst(1)\n            val res = y\
    \ + add( lst.tail )._2\n            x + (res%2==0)*res\n        }", "        val\
    \ evenIndexList = lst.filter(i => i%2 == 0)\n        val oddIndexList = lst.filter(i\
    \ => i%2 != 0)\n        val result = evenIndexList.foldLeft(0l) {\n          \
    \  case (sum, v) => sum + v\n        }\n        result += oddIndexList.foldLeft((0l,\
    \ 0l)) {\n            case (sum, (e, _)) => sum + e -> sum + e\n        }._1._2",
  "        val res = new mutable.HashSet[Long]()\n        // for each pair of even\
    \ number and its odd number\n        for (i <- 0 until lst.size) {\n         \
    \   if (lst.lift(i) % 2 == 0) {\n                res += lst.lift(i)\n        \
    \    }\n        }\n        res.foldLeft(0l) {\n            (acc, elem) => acc\
    \ + elem\n        }", "        if (lst.isEmpty) return 0\n        var sum = 0\n\
    \        for ( n <- lst) if (n % 2 == 0) sum += n\n        return sum", "    \
    \    val even_odd = lst.zipWithIndex.\n                filter(_._2 % 2 == 0).\n\
    \                map(_._1).\n                toList\n        lst.zipWithIndex.\n\
    \                filter(_._2 % 2 == 1).\n                map(_._1).\n        \
    \        toList\n        even_odd.sum + even_odd.sum", "        val n = lst.size\n\
    \        if(n<2) 0l\n        else n match {\n            case 0 => 0l\n      \
    \      case 1 => lst(0l)\n            case _ => {\n                val odd = lst.indexWhere(x\
    \ => x%2 != 0l)\n                var sum = 0l\n                for(i <- 0 until\
    \ n / 2){\n                    sum += lst(i) * lst(odd)\n                }\n \
    \               sum\n            }\n        }", "        // add code here\n  \
    \      var sum = 0\n        for( l <- lst){\n            if(l %2==0){\n      \
    \          sum+=l\n            }\n        }\n        return sum", "        val\
    \ result = lst.foldLeft(0l) { (sum, item) =>\n            if (item % 2 == 1) sum\
    \ + item\n            else sum\n        }\n        result", "        var sum =\
    \ 0L\n        // for (elem <- lst) sum += elem % 2 == 0 ? elem : 0)\n        for\
    \ (elem <- lst) sum += elem % 2 == 0 ? elem : 0\n        sum", "        val evens\
    \ = lst.filter( x => x % 2 ==0 )\n        val odds = lst.filter( x => x % 2 !=\
    \ 0 )\n        evens.sum", "        var sum = 0L\n        var evenSum = 0L\n \
    \       var oddSum = 0L\n        for (i<-lst; i>= 0) {\n            if(i % 2 ==\
    \ 0) {\n                evenSum += i\n            } else {\n                oddSum\
    \ += i\n            }\n        }\n        sum = (evenSum + oddSum)\n        return\
    \ sum", "        if (lst.isEmpty)\n            return 0\n        else if (lst.length\
    \ == 1)\n            lst(0)\n        else\n            add(lst(0).toLong, addTwo(lst(1),\
    \ lst(2).toLong))", "        val even_count = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        lst.foreach { \n            x =>\n            if (x % 2 == 0)\n     \
    \           even_count += x\n        }\n\n        even_count.toList.reduce(_ +\
    \ _)", "        var result = List[Long]()\n        for (x<- lst) {\n         \
    \   if (x % 2 == 0) result += x\n        }\n        if (result.isEmpty) 0\n  \
    \      else result.last", "        var sum = 0\n        for (i <- 0 until lst.size)\
    \ {\n            if (i % 2 == 0) {\n                sum += lst(i)\n          \
    \  }\n        }\n        return sum", "        require(lst.length % 2 == 0, \"\
    Invalid list length\")\n        val lst = lst.grouped(2).map { \n            (a,\
    \ b) => if (b%2 == 0) a+b else a-b \n        }\n        if (lst.length == 1) lst(0)\n\
    \        else lst(0)", "        if (lst.size == 0) return 0l\n        val m =\
    \ lst.head % 2\n        var c = 0\n        var result = 0l\n        for (i<- lst.indices.toIterator.until(lst.size)\
    \ {\n            if (i % 2 == 0) {\n                result += lst(i)\n       \
    \     }\n        }\n        result", "        def evenAtOdd(i : Int) : Long =\
    \ i match { \n            case 0 => 0\n            case _ => lst.filter(_ % 2\
    \ == 0).sum\n        }\n        lst.foldLeft(0l){\n            case (sum, e) =>\
    \ sum + evenAtOdd(e) \n        }", "        val oddIndices = lst.zipWithIndex.filter(_._2\
    \ % 2 == 1).map(_._1)\n        val evenIndices = lst.zipWithIndex.filter(_._2\
    \ % 2 == 0).map(_._1)\n\n        val oddEven = (oddIndices ++ evenIndices).toSet\n\
    \        oddEven.foldLeft(0)(_ + _)", "        val even_odds = lst.filter( (_,\
    \ i) => i % 2 == 0 )\n        val ans = even_odds.foldLeft(0L)( (acc,x) => (acc\
    \ + x) )\n        ans", "        val even = lst.takeWhile(_ % 2 == 0).tail\n \
    \       val odd = lst.drop(even.length)\n        even.foldLeft(odd.head)(_ + _)",
  "        lst.zipWithIndex.map{case (x, y) =>\n            if (y % 2 == 0) {\n  \
    \              x\n            } else {\n                0\n            }\n   \
    \     }.sum", "        var even = 0\n        var odd = 0\n        var total =\
    \ 0\n        for (i<- lst.indices) {\n            if (i%2==1)\n              \
    \  total += lst(i)\n            if (i%2==0)\n                odd += lst(i)\n \
    \       }\n        odd = odd/2\n        total = total + even\n        even = total\
    \ - odd\n        odd = (odd-even)/2\n        odd = odd + even\n        return\
    \ odd.toLong", "        val odd = lst.filter(_ % 2 == 0).map(_ / 2)\n        val\
    \ even = lst.filter(_ % 2 == 1).map(_ / 2)\n        odd.zip(even).map(x => x._1\
    \ + x._2)", "        var even = 0\n        var odd = 0\n        var sum = 0\n\
    \        lst.foreach(x => {\n            if (x % 2 == 0) {\n                even\
    \ += x;\n            }\n            else {\n                odd += x;\n      \
    \      }\n        })\n        even = even * 2\n        odd = odd * 2\n       \
    \ sum = even + odd\n        return sum", "        val sum = 0 \n        lst.foreach(x\
    \ => if (x % 2l.toLong == 0) sum += xl.toLong)\n        sum.toLong", "      val\
    \ even = lst.filter(_ % 2 == 0).toList\n      val odd = lst.filter(_ % 2 != 0).toList\n\
    \      (even.size + odd.size) * even(0)", "        var evensCounter = 0\n    \
    \    var evensSum = 0\n        lst.foreach{ x => if (x % 2 == 0) evensCounter\
    \ += 1 }\n        lst.foreach{ x => if (x % 2 != 0) evensSum += x }\n        evensCounter\
    \ * evensSum", "        if (lst.isEmpty)\n            return 0\n        var result\
    \ = lst(0)\n        for (x <- lst) {\n            if (x % 2 == 0)\n          \
    \      result += x\n        }\n        result", "        var res = 0.0\n     \
    \   for (x <- lst) {\n            if (x % 2 == 0) {\n                res += x\n\
    \            }\n        }\n        res", "      lst.length % 2 == 1 match {\n\
    \        case false => 0\n        case true =>\n          lst.take(lst.length/2).toSet.intersect(lst.drop(lst.length/2)).sum\n\
    \      }", "        var result : Long = 0\n        for(i <- 0 until lst.size )\
    \ {\n            if( lst.apply(i) % 2 != 0 ) {\n                result = result\
    \ + lst.apply(i).toLong\n            }\n        }\n        result", "        var\
    \ evenEven = 0\n        for(i <- 0 until lst.length) if (i%2 == 0) evenEven +=\
    \ lst(i)\n        evenEven", "        var result : Long = 0\n        lst.foreach{i\
    \ =>\n            if (i % 2 == 1) {\n                result += i\n           \
    \ }\n        }\n        return result", "        val even = lst\n        // even.drop(1)\
    \ is O(n)\n        // even.take(even.length / 2) is O(n)\n        even.take(even.length\
    \ / 2) reduceLeft { (x, y) => x + y } ", "        require(!lst.isEmpty)\n    \
    \    val evenEle = lst.takeWhile(_ % 2 == 0)\n        val oddEle = lst.drop(evenEle.size)\n\
    \        (evenEle.head + oddEle.head) ", '       lst.zip(lst.drop(1)).map(x =>
    x.get._1+x.get._2).sum', "        var evenIndex = lst.indexWhere(x => x % 2 ==\
    \ 0).toList\n        var oddIndex = lst.indexWhere(x => x % 2 == 1).toList\n \
    \       var finalList = mutable.List.empty\n        evenIndex.foreach { x =>\n\
    \            val y = lst.indexWhere(x => x == x + 1)\n            finalList +=\
    \ if (y == -1) x else lst.take(y) + x\n        }\n        oddIndex.foreach { x\
    \ =>\n            val y = lst.indexWhere(x => x == x)\n            finalList +=\
    \ if (y == -1) x else lst.take(y) + x\n        }\n        finalList.sum", "  \
    \      val m = lst.length\n        val p = mutable.ArrayBuffer(lst.size)\n   \
    \     var i = 0\n        while(i < m) {\n            p.+=lst(i)\n            i\
    \ += 2\n        }\n        lst.filter(_ % 2 == 0).foreach(_ += p.pop)\n      \
    \  p.last", "        // O(n^2) solution\n        val evenList: List[Long] = lst.filter(i\
    \ => i % 2 == 0).toList\n        val oddList: List[Long] = lst.filter(i => i %\
    \ 2 != 0).toList\n        val evenSum = evenList.foldLeft(0l) { (sum, elem) =>\
    \ sum + elem}\n        val oddSum = oddList.foldLeft(0l) { (sum, elem) => sum\
    \ + elem}\n        evenSum + oddSum", "        lst.map{\n            case i if\
    \ i % 2 == 0L => i.toLong\n            case i => 0L\n        }", "        val\
    \ newList = mutable.ListBuffer[Long]()\n        lst.foreach{x =>\n           \
    \ if(x % 2 == 0) newList += x\n        }\n        val even = lst.filter{x => x\
    \ % 2 == 0}\n        val odd = lst.filter{x => x % 2 != 0}\n        val total\
    \ = even.sum + odd.sum\n        total", "        val res = mutable.ListBuffer[Long]()\n\
    \        for(i <- 0 until lst.size) {\n            if((i%2)==0) res += lst(i)\n\
    \        }\n        res.sum", "        val even_odd  = lst.zip(lst.tail).filter\
    \ {case (x,y) => x._2 % 2 == 0}.map{case (x,y) => (x+y).toLong}\n        even_odd.fold(0)((x,y)\
    \ => x + y)", "        lst.foldLeft(0l) {\n        case (acc, el) => acc + el\n\
    \        }", "        var sum = 0\n        for (i <- 0 until lst.size) {\n   \
    \         if (i%2 == 0)\n                sum = sum + lst(i)\n        }\n     \
    \   sum", "        val even = lst.filter { _ % 2 == 0 }\n        val odd = lst.filter\
    \ { _ % 2 == 1 }\n        odd.reduceLeft((x: Long, y: Long) => x + y).toLong",
  "        var oddEvenList: List[Long] = Nil\n        for ( i <- lst ) {\n       \
    \     if ( i % 2 == 1 ) {\n                oddEvenList += i\n            }\n \
    \       }\n        return oddEvenList.reduceLeft(_ + _)", "        lst.zipWithIndex.map\
    \ {\n            case ((x: Long, y: Int) , i) =>\n                if (i % 2 ==\
    \ 0)\n                    x + y\n                else\n                    x +\
    \ y\n        }.last", "        var evenSum : Long = 0\n        var oddSum : Long\
    \ = 0\n        lst.foreach( elem => {\n            if( elem % 2 == 0 ){\n    \
    \            evenSum += elem\n            }else{\n                oddSum += elem\n\
    \            }\n        })\n        oddSum += evenSum\n        oddSum", "    \
    \    val l = lst.filter(x => x % 2 != 0)\n        val r = lst.filter(x => x %\
    \ 2 == 0)\n        val sum = 0\n        l foreach {\n            x =>\n      \
    \          if (x == r.head) sum += r.head\n                else\n            \
    \        sum += x\n        }\n        sum", "        val even_lst = lst.filter(l\
    \ => l.toInt % 2 == 0)\n        val odd_lst = lst.filter(l => l.toInt % 2 != 0)\n\
    \        var evenSum = 0L\n        var oddSum = 0L\n        lst.foreach(l => if\
    \ (l.toInt % 2 == 0) evenSum += l)\n        lst.foreach(l => if (l.toInt % 2 !=\
    \ 0) oddSum += l)\n        return (evenSum + oddSum)", "        if (lst.size <\
    \ 2) 0\n        else lst.tail.foldLeft(lst.head)((acc, _) => acc + _)", "    \
    \    def evenIndexes(l : List[Long], index : Int) : List[Long] = {\n         \
    \   (1 to l.length) filter (_ % 2 == 0) map (_ / 2) filter (l == _) filter (_\
    \ == index)\n        }\n        val evenIndexes = evenIndexes(lst, 0)\n      \
    \  val oddIndexes = evenIndexes(lst, 1)\n        evenIndexes match {\n       \
    \     case Nil => -1\n            case evenIndexes => evenIndexes match {\n  \
    \                  case Nil => -1\n                    case evenIndex => evenIndex\
    \ + sum(evenIndex)\n                }\n            case oddIndexes => oddIndexes\
    \ match {\n                    case Nil => -1\n                    case oddIndex\
    \ => oddIndex + sum(oddIndex)\n                }\n        }", "        val res\
    \ = mutable.ListBuffer.empty[Long]\n        var index = 0\n        for (x <- lst.toSet)\
    \ {\n            if (index % 2 == 0) {\n                res += x\n           \
    \ }\n            index += 1\n        }\n        if (res.isEmpty) 0 \n        else\
    \ res.toList.head ", "        var even = 0\n        var odd = 0\n        for(i\
    \ <- 0 until lst.length){\n            if(i%2 == 0) even += lst(i)\n         \
    \   else odd += lst(i)\n        }\n        return even+odd", "        if(lst.isEmpty)\
    \ 0\n        else {\n            lst.foldRight(0 )(_ + _ % 2 == 0).foldLeft(lst.head)(_\
    \ + _)\n        }", "      lst.foldLeft(0L){\n          case (acc, x) =>\n   \
    \         acc + (if (x % 2 == 0) x else 0L)\n        }", "        val result =\
    \ mutable.Buffer.empty[Long]\n        for (i <- 0 until lst.length) \n       \
    \     if (lst(i) % 2 == 0) result += lst(i)\n        result.last", "      lst.zipWithIndex.collect\
    \ {\n        case (l, i) if i%2 == 0 => l\n      }.sum", "        val res = lst.filter(x\
    \ => x % 2 == 0).toList\n        for (i <- lst.indices) if (i % 2 == 1) res +=\
    \ lst(i)\n        res.reduceLeft(_ + _)", "        var sum : Long = 0\n      \
    \  for(x <- lst) {\n            val y = x % 2\n            if(y != 0) sum += x\n\
    \        }\n        sum", "        val even_atOdd_indices = lst.zipWithIndex.filter(_._2\
    \ % 2 == 0).map(_._1)\n        val even_elements = lst.filter(_ % 2 == 0)\n  \
    \      even_atOdd_indices.zip(even_elements).foldLeft(0l) { (acc, x) => acc +\
    \ x._2 }", "        // Write your code here\n        lst.zipWithIndex.filter(_._2%2\
    \ != 0)", "       val m = lst.zipWithIndex.toMap\n       lst.map(elem => elem.toLong\
    \ * if (elem.toDouble % 2 == 0) m.get(elem.toLong) match {\n           case None\
    \    => 0\n           case Some(_) => 1\n         }).sum", "        var even =\
    \ 0L\n        var odd = 0L\n        for(i <- 0 to lst.size-1) {\n            if(i%2==1)\
    \ odd+=lst(i) \n            else even+=lst(i)\n        }\n        return even+odd",
  "        if (lst.isEmpty) 0\n        else\n            lst.zipWithIndex.collect\
    \ {\n                case (_, i) if i % 2 == 0 => lst(i)\n            }.sum",
  "        var sum = 0\n        lst.foreach(x => if(x % 2 == 0) sum += x)\n      \
    \  return sum", "        var evens: Long = lst.sum\n        var odds: Long = lst.foldLeft(0l)\
    \ { (acc, e) =>\n            if (acc % 2 == 0) {\n                acc + 1\n  \
    \          } else acc\n        }\n        return evens + odds", "        val even\
    \ = lst.filter(x => x % 2 == 0).toList\n        val odd = lst.filter(x => x %\
    \ 2 != 0).toList\n        var result = 0\n        for ( e <- even ; d <- odd )\
    \ result += e\n        result", "        if(lst.size == 0)\n            return\
    \ 0\n        var even = 0L\n        var odd = 0L\n        lst.foreach{v =>\n \
    \           if( v % 2 == 0)\n                even += v\n            else\n   \
    \             odd += v\n        }\n        return (even+odd)", "        if (lst.size\
    \ <= 1) lst(0)\n        else {\n            var sum = 0\n            for (i <-\
    \ 0 until lst.size ) {\n                if (i % 2 != 0)\n                    sum\
    \ = sum + lst(i)\n            }\n            sum\n        }", "        if (lst.isEmpty)\
    \ return 0L\n        var total = 0L\n        for (i <- 0 until lst.size) {\n \
    \           total += lst(i) * 2\n        }\n        return total", "        val\
    \ list = lst.toSet\n        val even = list.filter(((x) => x.toInt == 2))\n  \
    \      val odd = list.filter(((x) => x.toInt == 1))\n        val sum = even.sum\
    \ + odd.sum\n        return sum.toLong", "        var sum = 0\n        for (v\
    \ <- lst.view.zipWithIndex) {\n            sum += v._2._1 * 2 % v._2._1.toLong\n\
    \        }\n        sum", "        val even = lst.filter(_ % 2 != 0)\n       \
    \ val odd = lst.filter(_ % 2 == 0)\n        val newOdd = mutable.ArrayBuffer.empty[Long]\n\
    \        odd.zipWithIndex.foreach { case (k, v) =>\n            if (v % 2 == 0)\n\
    \                newOdd += v\n        }\n        even(even.size + newOdd.size)",
  "        val oddIndices = lst.zipWithIndex.filter(_._2 % 2 == 0).map(x => x._1)\n\
    \        val evenIndices = lst.zipWithIndex.filter(_._2 % 2 != 0).map(x => x._1)\n\
    \        oddIndices.reduce(_.addTo(x.toLong)) + (evenIndices.reduce(_.addTo(x.toLong)))",
  "        lst.foldLeft(0)((sum, elem) => {\n            sum + if(elem % 2 == 0) elem\
    \ else 0\n        })", "        val odd = mutable.ListBuffer.empty[Long]\n   \
    \     lst.foreach(x => { if (x % 2 != 0) odd += x})\n        val even = mutable.ListBuffer.empty[Long]\n\
    \        lst.foreach(x => { if (x % 2 == 0) even += x})\n        even.sum + odd.sum",
  "        val l = new mutable.ListBuffer[Long]()\n        val even = lst.filter(x\
    \ => x % 2 == 0).toList\n        val odd = lst.filter(x => x % 2 != 0).toList\n\
    \n        even foreach(l.+=)\n        odd foreach(l.+=)\n\n        l.takeWhile(_\
    \ <= lst.last).toList.reverse", "        val odd = lst.indices.filter(_ % 2 !=\
    \ 0)\n        val even = lst.indices.filter(_ % 2 == 0)\n        even.map(lst\
    \ + _)", "        var sum = 0L\n        for (i <- 0 until lst.size) {\n      \
    \      if (i %% 2 != 0)\n                sum += lst(i)\n        }\n        sum",
  "        var result = ListBuffer[Long]()\n        for(i <- 0 until lst.size)\n \
    \           if(i % 2 == 0)\n                result.append(lst(i))\n        new\
    \ scala.collection.immutable.::[Long](result.toList)", "        var i = 0\n  \
    \      while (i < lst.length) {\n            if (lst(i) % 2 == 0) {\n        \
    \        lst.update(i, lst(i) + lst(i - 1))\n                i -= 1\n        \
    \    }\n            i += 1\n        }\n        lst(0)", "        val newList =\
    \ mutable.ListBuffer[Long]()\n        for(i <- 0 until lst.size) {\n         \
    \   if(i % 2 == 0)\n                newList += lst(i)\n        }\n        newList.sum",
  "        var evenIndices : List[Long] = Nil\n        var oddIndices : List[Long]\
    \ = Nil\n        for (i<-lst.indices){\n            if (i%2 == 0){\n         \
    \       evenIndices = evenIndices :+ i\n            }\n            else {\n  \
    \              oddIndices = oddIndices :+ i\n            }\n        }\n      \
    \  //println(evenIndices.mkString(\"[\",\",\",\"]\")) --> 2,3\n        //println(oddIndices.mkString(\"\
    [\",\",\",\"]\")) --> 1,4\n        //println(evenIndices.flatten.mkString(\"[\"\
    ,\",\",\"]\")) --> 2,3,1,4\n        //println(oddIndices.flatten.mkString(\"[\"\
    ,\",\",\"]\")) --> 1,4,1,3\n        var result = 0\n        for (index <- evenIndices.indices){\
    \ result = result + lst(index) }\n        for (index <- oddIndices.indices){ result\
    \ = result - lst(index) }\n        return result", "        lst.foldLeft(0l) {\n\
    \            (f,i) => if (i % 2 == 0) f.toLong + i else f\n        }", "     \
    \   var sum = 0\n        lst.foreach{ x=>\n            if(x % 2 == 0){\n     \
    \           sum+=x\n            }\n        }\n        sum", "        if (lst.isEmpty)\
    \ {\n            0\n        } else {\n            val oddIndices : List[Int] =\
    \ lst.indexWhere(x => x % 2 == 1)\n            val evenIndices : List[Int] = lst.indexWhere(x\
    \ => x % 2 != 1)\n            (evenIndices ++ oddIndices).foldLeft[Long](0)((acc,\
    \ i) => (lst.apply(i) + acc))\n        }", "        var result = 0\n        for(i\
    \ <- lst if i % 2 == 0)\n            result += i\n        result", "      val\
    \ listEvenOdd = lst.map(x => (x % 2) == 0).zip(lst.map(x => (x % 2) == 1)).toList\n\
    \      val evens = listEvenOdd.filter(f => f._1).map(_._2)\n      val odds = listEvenOdd.filter(f\
    \ => f._2).map(_._1)\n      val evensEvens = evens ++ evens\n      (odds union\
    \ evensEvens).toSet.sum", "        var evenLst : mutable.Stack[Long] = mutable.Stack.empty\n\
    \        var oddLst : mutable.Stack[Long] = mutable.Stack.empty\n        lst.foreach{x\
    \ =>\n            if (x % 2 == 0) {\n                evenLst += x\n          \
    \  } else {\n                oddLst += x\n            }\n        }\n        val\
    \ evenResult = evenLst.foldLeft[Long](0l){ case (acc,x) =>\n            acc +\
    \ (x * 2)\n        }\n        val oddResult = oddLst.foldLeft[Long](0l){ case\
    \ (acc,x) =>\n            acc + (x * 2)\n        }\n        oddResult + evenResult",
  "        var res = 0l\n        lst.foreach{\n            x => if(x%2==0) res +=\
    \ x\n        }\n        res", "        var even = lst(0)\n        for( i <- 1l\
    \ to lst.size ) {\n            if( (i%2l) == 0 ) {\n                even += lst(i)\n\
    \            }\n        }\n        even", "        val even = lst.filter(_ % 2\
    \ == 0)\n        val odd = lst.filter(_ % 2 != 0)\n        val newList = even.foldLeft(odd.head)(_\
    \ + _)\n        newList", "         def oddElement(l : List[Long]): Long = if\
    \ (l.length % 2 != 0) l.length else l.length/2\n         val evenElems = lst.filter(x\
    \ => x % 2 == 0).map(x => x).toList\n         val oddElems = lst.filter(x => x\
    \ % 2 == 1).map(x => x).toList\n         val evenElemsInEven = evenElems.filter(x\
    \ => oddElems.indexOf(x) < oddElems.length)\n         evenElemsInEven.sum", " \
    \       val n = lst.length\n        var sum = 0\n        (0 to n-1).foreach {\n\
    \            if (lst(i) mod 2 == 0)\n                sum += lst(i)\n        }\n\
    \        sum", "        var evenSum = 0\n        lst.foreach(l => {\n        \
    \    if (l % 2 != 0) {\n                evenSum = evenSum + l\n            }\n\
    \        })\n        evenSum", "        var result = 0\n        var even = 0\n\
    \        var i = 0\n        while(i < lst.size) {\n          if(i % 2 == 0) {\n\
    \            even = even + lst(i)\n          } else {\n            result = result\
    \ + even\n            even = 0\n          }\n          i += 1\n        }\n   \
    \     return result + even", "        val even_odd = lst.filter(_ % 2l.toLong\
    \ >= 1l.toLong).distinct\n        even_odd.reduceLeft(_ + _)", "        lst match\
    \ {\n            case List() =>\n            case List(x) => x\n            case\
    \ _        => lst.foldLeft(0l) { (sum,x) => sum + if (x % 2 == 0) x else sum }\n\
    \        }"]
stop_tokens:
- "\n    }\n"
