{
  "language": "scala",
  "name": "HumanEval_42_incr_list",
  "results": [
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val r : List[Long] = l.copy\n        for(i <- r.indices) {\n            r(i+1) += 1\n        }\n        return r\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpahc8x59o.scala:10:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mr\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = l.copy\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         value copy is not a member of List[Long] - did you mean l.coll?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpahc8x59o.scala:12:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            r(i+\u001b[31m1\u001b[0m) += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean Long.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980024
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val r = new mutable.ArrayList\n        for (i <- 0 until l.length) {\n            r.add(l(i) + 1)\n        }\n        r\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbzrw9tn8.scala:10:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mr\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayList\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980019
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val r = l.map(x => x + (1l to 0l)).zipWithIndex.map(\n            x => if (x._2 % 2 == 0) x._1 else x._1 + 1\n        )\n        l.clear()\n        l.zip(r).flatMap(x => x).distinct\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpl707pf3b.scala:10:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mr\u001b[0m = l.map(\u001b[36mx\u001b[0m => x + (\u001b[31m1l\u001b[0m to \u001b[31m0l\u001b[0m)).zipWithIndex.map(\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m+\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0m (x: String): String\n\u001b[31m   |\u001b[0mmatch arguments (scala.collection.immutable.NumericRange.Inclusive[Long])\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl707pf3b.scala:11:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x._2 % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) x._1 \u001b[33melse\u001b[0m x._1 + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl707pf3b.scala:13:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        l.clear()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue clear is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import co",
      "stdout": "",
      "timestamp": 1659980025
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.flatMap { x => x :: List.fill(x){x+1}}\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpidis93kt.scala:10:40 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        l.flatMap { \u001b[36mx\u001b[0m => x :: List.fill(x){x+\u001b[31m1\u001b[0m}}\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                        Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980023
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var newList = l\n        var prev = 0\n        var current = 0\n        var counter = 0\n        for (i <- 0 until newList.length) {\n            current = newList(i)\n            prev = newList(i - 1)\n            if (prev >= current) {\n                counter = counter + 1\n            } else {\n                counter = 1\n                newList(i - counter) = prev\n            }\n        }\n        newList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8c61t8f8.scala:15:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            current = newList(i)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8c61t8f8.scala:16:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            prev = newList(i - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    Long\n\u001b[31m   |\u001b[0m                   Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8c61t8f8.scala:21:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                newList(i - counter) = prev\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean List[Long].updated?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980024
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList = mutable.ListBuffer.empty[Long]\n        for (ix <- 0 until l.length){\n          newList += (ix + 1)\n        }\n        newList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvu2e4heg.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980019
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newL = l.toList\n        newL :+ newL.lastOption.getOrElse(0) + 1l\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7js_4ou2.scala:11:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        newL :+ newL.lastOption.getOrElse(\u001b[31m0\u001b[0m) + \u001b[31m1l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of AnyVal, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980024
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var tmpList = l\n        for((i, e) <- tmpList.zipWithIndex) {\n            tmpList(i, e+1) = e+1\n        }\n        tmpList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbznv14q4.scala:12:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            tmpList(i, e+\u001b[31m1\u001b[0m) = e+\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean List[Long].updated?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980023
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var result : List[Long] = l\n        result ++= result.map { _ + 1}\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpsbwthd9b.scala:16)\n\tat Problem.main(tmpsbwthd9b.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980025
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val result = l.iterator\n        while (result.hasNext) {\n            val cur = result.next\n            result.append(cur + 1)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdmn3m71z.scala:13:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result.append(cur + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value append is not a member of Iterator[Long]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdmn3m71z.scala:15:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mreturn\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (result : Iterator[Long])\n\u001b[31m   |\u001b[0m               Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980023
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var res = l.foldLeft(List.empty[Long])((acc,n) => acc + n.toLong)\n        acc = res.toList.sortWith((x,y) => x - y).toList.head + res.last + 1\n        acc.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo8c0aaqx.scala:10:62 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mres\u001b[0m = l.foldLeft(List.empty[\u001b[35mLong\u001b[0m])((\u001b[36macc\u001b[0m,\u001b[36mn\u001b[0m) => acc + n.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo8c0aaqx.scala:11:8 -------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        acc = res.toList.sortWith((\u001b[36mx\u001b[0m,\u001b[36my\u001b[0m) => x - y).toList.head + res.last + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Not found: acc\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpo8c0aaqx.scala:11:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        acc = res.toList.sortWith((\u001b[36mx\u001b[0m,\u001b[36my\u001b[0m) => x - y).toList.head + res.last + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    Long\n\u001b[31m   |\u001b[0m                                           Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo8c0aaqx.scala:12:8 -------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        acc.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Not found: acc\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659980024
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val ls = l.toList\n        var res = List.empty[Long]\n        for( i <- 0 until ls.size )\n            res :+= i ++ 1\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvd3mbqfx.scala:13:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            res :+= i ++ \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value :+= is not a member of List[Long] - did you mean List[Long].:+?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvd3mbqfx.scala:13:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            res :+= i ++ \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value ++ is not a member of Int\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980023
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        def incr(l1 : List[Long]) : List[Long] = {\n            def incr2(l1 : List[Long]) : List[Long] = {\n                if (l1.isEmpty) {\n                    l1.toList\n                }\n                else {\n                    val c = l1(0)\n                    val t = l1.tail\n                    val r: List[Long] = List(c, c + 1.toLong, c + 2.toLong, c + 3.toLong)\n                    if (t.isEmpty) {\n                        r\n                    }\n                    else {\n                        incr2(t.tail)\n                    }\n                }\n            }\n            incr2(l)\n        }\n        incr(l)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpyp1fbh8f.scala:33)\n\tat Problem.main(tmpyp1fbh8f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980024
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var new_l = new ListBuffer[Long]\n        for (i <- 0 until l.length) {\n            new_l += l(i)\n        }\n        new_l.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpd5j_sdt3.scala:18)\n\tat Problem.main(tmpd5j_sdt3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980025
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val ll = mutable.ListBuffer[Long]()\n        l.foreach(x => {\n           ll += x + 1\n        })\n        ll.clear()\n        ll.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0hvrsish.scala:10:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mll\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980018
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val l = l.sorted\n        val newList = new collection.mutable.ListBuffer[Long]()\n        var curVal: Long = l.head\n        newList.append(curVal)\n        while(l.tail != l.tail) {\n            curVal = curVal + 1\n            newList.append(curVal)\n        }\n        newList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp6ok0m8px.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = l.sorted\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35ml\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980019
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        def incr(l : List[Long]) : List[Long] = {\n            l match {\n                case Nil => Nil\n                case x :: xs => {\n                    x += 1\n                    xs.foldRight(x) { case (acc, x) => acc :: x }\n                }\n            }\n        }\n        incr(l)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7v435ckd.scala:14:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                    x += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value += is not a member of Long - did you mean x.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7v435ckd.scala:15:59 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                    xs.foldRight(x) { \u001b[33mcase\u001b[0m (acc, x) => acc :: x }\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value :: is not a member of Long\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980024
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList = mutable.Buffer.empty[Long]\n        l foreach { elem =>\n            newList += elem.toLong\n        }\n        newList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq5nkyw1z.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = mutable.Buffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980019
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val l1 = l.size\n        val l2 = l.size\n        var list = new ListBuffer[Long]()\n        list ++= l\n        while(l1 > 0) {\n            list += (l(l1 - 1).toLong + 1)\n            l1 -= 1\n        }\n        list += (l(l2 - 1).toLong + 1)\n        list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4891thdf.scala:16:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            l1 -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value -= is not a member of Int - did you mean l1.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980022
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var ret = 0\n        var x = 1\n        val a = l\n        a.foreach {\n            a => ret += a\n        }\n        val n = (l + ret).length\n        for (i <- 1 to n) {\n            val rm = a.take(i)\n            a.drop(i).foreach {\n                a => ret += a\n            }\n            a.insert(i, rm)\n        }\n        if (ret == l.length) a\n        else (incrList(a) + ret)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnlwpd3x4.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[36ma\u001b[0m => ret += a\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnlwpd3x4.scala:16:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = (l + ret).length\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnlwpd3x4.scala:20:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                \u001b[36ma\u001b[0m => ret += a\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnlwpd3x4.scala:22:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            a.insert(i, rm)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value insert is not a member of List[Long] - did you mean a.init?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnlwpd3x4.scala:25:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33melse\u001b[0m (incrList(a) + ret)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import mat",
      "stdout": "",
      "timestamp": 1659980025
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val res = (0 until l.length).foldLeft(l)((xs, x) => {\n            val r = xs.drop(1).head\n            xs.updated(0,r+x.toLong)\n        })\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6i_909h6.scala:18)\n\tat Problem.main(tmp6i_909h6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980025
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val lst = l.toList\n        val newList = mutable.ListBuffer.empty[Long]\n        lst.foreach { x =>\n            newList += x + 1\n        }\n        newList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpucd7duf2.scala:11:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980018
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList = new ListBuffer[Long]()\n        var current = 0l\n        for (elem <- l)\n            newList += elem\n            current += 1l\n            while (current < newList.last)\n                newList += (current)\n            newList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkwmen7ix.scala:12:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (elem <- l)\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Unit\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m13 |\u001b[0m            newList += elem\n\u001b[31m14 |\u001b[0m            current += \u001b[31m1l\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mwhile\u001b[0m (current < newList.last)\n\u001b[31m16 |\u001b[0m                newList += (current)\n\u001b[31m17 |\u001b[0m            newList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980023
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val l2 = l.filterNot(x => x == 0)\n        val l3 = l2.filterNot(x => x == 0)\n        val l4 = l3.filterNot(x => x == 0)\n        val l5 = l4.filterNot(x => x == 0)\n        val l6 = l5.filterNot(x => x == 0)\n        val l7 = l6.filterNot(x => x == 0)\n        val l8 = l7.filterNot(x => x == 0)\n        val l9 = l8.filterNot(x => x == 0)\n        val l10 = l9.filterNot(x => x == 0)\n        val l11 = l10.filterNot(x => x == 0)\n        val l12 = l11.filterNot(x => x == 0)\n        val l13 = l12.filterNot(x => x == 0)\n        val l14 = l13.filterNot(x => x == 0)\n        val l15 = l14.filterNot(x => x == 0)\n        val l16 = l15.filterNot(x => x == 0)\n        val l17 = l16.filterNot(x => x == 0)\n        val l18 = l17.filterNot(x => x == 0)\n        val l19 = l18.filterNot(x => x == 0)\n        val l20 = l19.filterNot(x => x == 0)\n        val l21 = l20.filterNot(x => x == 0)\n        val l22 = l21.filterNot(x => x == 0)\n        val l23 = l22.filterNot(x => x == 0)\n        val l24 = l23.filterNot(x => x == 0)\n        val l25 = l24.filterNot(x => x == 0)\n        val l26 = l25.filterNot(x => x == 0)\n        val l27 = l26.filterNot(x => x == 0)\n        val l28 = l27.filterNot(x => x == 0)\n        val l29 = l28.filterNot(x => x == 0)\n        val l30 = l29.filterNot(x => x == 0)\n        val l31 = l30.filterNot(x => x == 0)\n        val l32 = l31.filterNot(x => x == 0)\n        val l33 = l32.filterNot(x => x == 0)\n        val l34 = l33.filterNot(x => x == 0)\n        val l35 = l34.filterNot(x => x == 0)\n        val l36 = l35.filterNot(x => x == 0)\n\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4tzs0_rv.scala:46:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980031
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newL = new mutable.ListBuffer[Long]()\n        for(i <- l.iterator) {\n            newL += i + 1\n        }\n        newL.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_mmur4ml.scala:10:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewL\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980026
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n      var i = l.length\n      while (i > 0) {\n        i -= 1\n        l(i) = l(i) + 1\n      }\n      l\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvj1h5n6f.scala:13:8 -------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        l(i) = l(i) + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m    value update is not a member of List[Long] - did you mean l.updated?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980030
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val len = l.length\n        for(i <- 0 until len - 1) yield {\n            if (l(i) == l(i + 1)) l(i + 1) :: l(i + 2) else l(i + 1) + 1 :: l(i + 2)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpygg29ave.scala:12:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mif\u001b[0m (l(i) == l(i + \u001b[31m1\u001b[0m)) l(i + \u001b[31m1\u001b[0m) :: l(i + \u001b[31m2\u001b[0m) \u001b[33melse\u001b[0m l(i + \u001b[31m1\u001b[0m) + \u001b[31m1\u001b[0m :: l(i + \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value :: is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpygg29ave.scala:12:73 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mif\u001b[0m (l(i) == l(i + \u001b[31m1\u001b[0m)) l(i + \u001b[31m1\u001b[0m) :: l(i + \u001b[31m2\u001b[0m) \u001b[33melse\u001b[0m l(i + \u001b[31m1\u001b[0m) + \u001b[31m1\u001b[0m :: l(i + \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                         ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value :: is not a member of Long\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980030
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        if (l.isEmpty)\n            l\n        else {\n            var list = l.headOption.toList\n            var next = list.headOption\n            list :=  list.tail\n            l := l :+ next.toLong\n            incrList(l)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5r3u2bi2.scala:15:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            list :=  list.tail\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value := is not a member of List[Long] - did you mean List[Long].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5r3u2bi2.scala:16:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            l := l :+ next.toLong\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value := is not a member of List[Long] - did you mean l.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5r3u2bi2.scala:16:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            l := l :+ next.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toLong is not a member of Option[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980032
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var res = l.toList\n        var i = l.length\n        while (i > 0) {\n            i = i - 1\n            res = res.head + 1 :: res\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqhs0qg_.scala:20)\n\tat Problem.main(tmppqhs0qg_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980031
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList: mutable.Buffer[Long] = mutable.Buffer()\n        l.foreach { elem =>\n            newList += elem.toLong + 1\n        }\n        newList.clear()\n        newList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpss_u2mem.scala:10:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m: mutable.Buffer[\u001b[35mLong\u001b[0m] = mutable.Buffer()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpss_u2mem.scala:10:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m: mutable.Buffer[\u001b[35mLong\u001b[0m] = mutable.Buffer()\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980029
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList = mutable.ListBuffer.empty[Long]\n        l.foreach { x =>\n            newList += x+1\n        }\n        newList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiet6la9g.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980030
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList = l.toSet\n        val newSet = new HashSet[Long](newList)\n        newSet ++= newSet ++= newSet ++= newSet\n        newSet.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpkgcnmu9q.scala:11:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewSet\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mHashSet\u001b[0m[\u001b[35mLong\u001b[0m](newList)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mconstructor\u001b[0m \u001b[35mHashSet\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mHashSet\u001b[0m with types\n\u001b[31m   |\u001b[0m [A](): scala.collection.mutable.HashSet[A]\n\u001b[31m   |\u001b[0m [A]\n\u001b[31m   |\u001b[0m  (initialCapacity: Int, loadFactor: Double): \n\u001b[31m   |\u001b[0m    scala.collection.mutable.HashSet[A]\n\u001b[31m   |\u001b[0mmatch arguments ((newList : Set[Long]))\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980030
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.tails.reverse.foldLeft(l.head)(_ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxzdb8aon.scala:10:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        l.tails.reverse.foldLeft(l.head)(_ + _)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue reverse is not a member of Iterator[List[Long]] - did you mean Iterator[List[Long]].reversed?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980033
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var r: List[Long] = ListBuffer[Long]()\n        var x: Long = l.head\n        var y = l.last\n        r ++= List(x, y, x + 1, y + 1)\n        l ++= List(x, y, x + 1, y + 1)\n        l ++= List(x, y, x + 1, y + 1)\n        l\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxhzkvf23.scala:10:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mr\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    scala.collection.mutable.ListBuffer[Long]\n\u001b[31m   |\u001b[0m                     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxhzkvf23.scala:14:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        l ++= List(x, y, x + \u001b[31m1\u001b[0m, y + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value ++= is not a member of List[Long] - did you mean l.++?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxhzkvf23.scala:15:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        l ++= List(x, y, x + \u001b[31m1\u001b[0m, y + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value ++= is not a member of List[Long] - did you mean l.++?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980035
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val m = new mutable.LinkedHashMap[Long, Long]()\n        for (v <- l)\n            m.put(v + 1, v)\n        m.values().toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfkkcqxuh.scala:10:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = \u001b[33mnew\u001b[0m mutable.LinkedHashMap[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980030
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        def incrIter(li : List[Long]) : List[Long] = {\n            li match {\n                case Nil => Nil\n                case x :: xs => x :: incrIter(xs)\n            }\n        }\n        incrIter(l).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpjp_6cdw0.scala:20)\n\tat Problem.main(tmpjp_6cdw0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980035
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var n = 0\n        l.foreach(x => {\n            n += x\n        })\n        val r = n until l.length\n        var m = n until r.length\n        while (m.size != 1) {\n            if (m[m.size - 1] >= r[r.size - 1]) {\n                m.remove(m.size - 1)\n                r.remove(r.size - 1)\n            } else {\n                m.remove(0)\n                r.add(0)\n            }\n        }\n        r.tail.foreach(x => l.add(x+1))\n        l\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxbve9f90.scala:12:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            n += x\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxbve9f90.scala:17:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mif\u001b[0m (m[m.size \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m] >= r[r.size \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxbve9f90.scala:18:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                m.remove(m.size - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue remove is not a member of Range, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxbve9f90.scala:19:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                r.remove(r.size - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue remove is not a member of Range, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import",
      "stdout": "",
      "timestamp": 1659980037
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var l1 = l\n        while(l.head < l1.last){\n            l1.last += 1\n        }\n        l1\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppr6wucnp.scala:12:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            l1.last += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean Long.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980035
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val len = l.length\n        var result : List[Long] = null\n        var lastVal = 0\n        // create mutable list\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n        var mutable : mutable.MutableList[Long] = mutable.MutableList()\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbrvo9dla.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmutable\u001b[0m : mutable.MutableList[\u001b[35mLong\u001b[0m] = mutable.MutableList()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmutable is already defined as \u001b[33mvariable\u001b[0m \u001b[35mmutable\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbrvo9dla.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmutable\u001b[0m : mutable.MutableList[\u001b[35mLong\u001b[0m] = mutable.MutableList()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmutable is already defined as \u001b[33mvariable\u001b[0m \u001b[35mmutable\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbrvo9dla.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmutable\u001b[0m : mutable.MutableList[\u001b[35mLong\u001b[0m] = mutable.MutableList()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmutable is already defined as \u001b[33mvariable\u001b[0m \u001b[35mmutable\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbrvo9dla.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmutable\u001b[0m : mutable.MutableList[\u001b[35mLong\u001b[0m] = mutable.MutableList()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmutable is already defined as \u001b[33mvariable\u001b[0m \u001b[35mmutable\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbr",
      "stdout": "",
      "timestamp": 1659980035
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var sum = 0L\n        var out = new mutable.Buffer[Long]()\n        for (i <- l) {\n            sum += i\n            if (sum > 2L)\n                out.append(sum.toLong)\n            sum = 1\n        }\n        if (sum > 0L)\n            out.append(sum.toLong)\n        out\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm9z4p3_z.scala:11:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mout\u001b[0m = \u001b[33mnew\u001b[0m mutable.Buffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980033
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val l1 = l.toArray\n        for (i <- 0 until l1.length) {\n            val curr = l1(i)\n            val next = curr + 1\n            l1(i) = next\n        }\n        l.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5d5cn5x5.scala:20)\n\tat Problem.main(tmp5d5cn5x5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980037
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var result: List[Long] = Nil\n        var i = 0\n        l foreach (x => { result += List(x, i + 1); i += 1; })\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbaucs0ik.scala:12:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        l foreach (\u001b[36mx\u001b[0m => { result += List(x, i + \u001b[31m1\u001b[0m); i += \u001b[31m1\u001b[0m; })\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980035
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val l = l.toList\n        var i = 0\n        var sum = 0L\n        for (i <- 0 until l.length) {\n            sum = sum + l(i)\n        }\n        for (i <- 0 until l.length) {\n            l(i) = sum\n            sum = sum + l(i)\n        }\n        l\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0cutspol.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = l.toList\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35ml\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980033
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        if (l.isEmpty) l\n        else l.head :: incrList(l.tail)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp1vpvraaz.scala:15)\n\tat Problem.main(tmp1vpvraaz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980036
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val l2 = l.map(_ + 1)\n        l2.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980037
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.foldLeft(List[Long](l.head.toLong)) {\n            case (acc: List[Long], next: Long) => acc + List(next)\n            case _ => acc\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp130zjlz0.scala:11:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mcase\u001b[0m (acc: List[Long], next: Long) => acc + List(next)\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp130zjlz0.scala:12:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mcase\u001b[0m _ => acc\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: acc\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980037
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l match {\n            case Nil => l\n            case x :: xs => {\n                val r = new ListBuffer[Long]()\n                var c = x\n                for (i <- 0 until xs.length-1) {\n                    r.add(x+c(i))\n                    c = c + xs(i)\n                }\n                r.toList\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuvefuedb.scala:16:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                    r.add(x+c(i))\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m  value add is not a member of scala.collection.mutable.ListBuffer[Long]\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpuvefuedb.scala:16:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                    r.add(x+c(i))\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            \u001b[33mvariable\u001b[0m \u001b[35mc\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980038
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var n = 0\n        var r = l(0)\n        for (i <- 1 until l.length) {\n            n += 1\n            r = (r * i) + l(n)\n        }\n        r\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfy_gv9o5.scala:16:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        r\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (r : Long)\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980040
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList = mutable.ListBuffer[Long]()\n        l.foldLeft(newList){ (res, l) =>\n            res :+ l + 1 }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp87y_4jbq.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980038
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.map(_ + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659979866
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val nums = l.toList\n        val ans = List[Long]()\n        for (i<-nums.indices) {\n            ans ::= nums(i) + nums(i+1)\n        }\n        return ans\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi5z7pcj9.scala:13:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            ans ::= nums(i) + nums(i+\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value ::= is not a member of List[Long] - did you mean ans.::?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980040
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList = mutable.Buffer.empty[Long]\n        var k = 0\n        l.foreach { \n            x => newList += (x+1l.toLong)\n        }\n        newList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpotted9ep.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = mutable.Buffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980038
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList = mutable.MutableList[Long]()\n        l.foreach{ x => newList.add(x+1l.toLong) }\n        newList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbxuw5njb.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = mutable.MutableList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980038
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l match {\n            case Nil => Nil\n            case x::xs => (x.toLong + xs.reduceLeft(_ + _)).toList\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcye4xbhb.scala:12:60 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mcase\u001b[0m x::xs => (x.toLong + xs.reduceLeft(_ + _)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         value toList is not a member of Long - did you mean Long.toInt?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980040
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val m = Map(\"list\" -> l, \"i\" -> 0)\n        def inc(i: Int, v: Long) =\n            m.get(\"list\")(i) = m.get(\"list\")(i) + v\n\n        def get(i: Int) =\n            m.get(\"list\")(i)\n        def next(i: Int) =\n            val r = m.get(\"list\")(i + 1)\n            if (r > m.get(\"i\")) r\n            else 0\n        val iter = (1 to l.size).iterator\n        m.set(\"i\", 0)\n        while (iter.hasNext) {\n            val i = iter.next\n            val nextVal = if (iter.hasNext) get(i) + next(i) else 0\n            val newVal = if (nextVal > m.get(\"i\")) nextVal else 0\n            inc(i + 1, newVal)\n        }\n        m.get(\"list\")\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp03on9vlg.scala:12:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            m.get(\u001b[31m\"list\"\u001b[0m)(i) = m.get(\u001b[31m\"list\"\u001b[0m)(i) + v\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value update is not a member of Option[Matchable]\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp03on9vlg.scala:12:36 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            m.get(\u001b[31m\"list\"\u001b[0m)(i) = m.get(\u001b[31m\"list\"\u001b[0m)(i) + v\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                \u001b[33mmethod\u001b[0m \u001b[35mget\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mMapOps\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp03on9vlg.scala:15:17 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            m.get(\u001b[31m\"list\"\u001b[0m)(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35mget\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mMapOps\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp03on9vlg.scala:17:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mr\u001b[0m = m.get(\u001b[31m\"list\"\u001b[0m)(i + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                \u001b[33mmethod\u001b[0m \u001b[35mget\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mMapOps\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp03on9vlg.scala:21:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        m.set(\u001b[31m\"i\"\u001b[0m, \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue set is not a member of scala.collection.mutable.Map[String, Matchable] - did you mean m.get?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp03on9vlg.scala:28:13 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        m.get",
      "stdout": "",
      "timestamp": 1659980042
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val result = mutable.ListBuffer[Long]()\n        l.foreach { a => result = result :+ a + 1L }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8tctzg5z.scala:10:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp8tctzg5z.scala:11:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        l.foreach { \u001b[36ma\u001b[0m => result = result :+ a + \u001b[31m1L\u001b[0m }\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980038
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        // Make copy to avoid modifying original list.\n        val listCopy = l.toList\n        // Add 1 to all elements.\n        listCopy foreach (x => x = x + 1l)\n        // Return new list.\n        listCopy\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp68eepyzk.scala:13:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        listCopy foreach (\u001b[36mx\u001b[0m => x = x + \u001b[31m1l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Reassignment to val x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980040
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.map(i => i + 1).toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980045
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val m = l.size\n        var result : List[Long] = Nil\n        var count : Int = 1\n        var x = 0\n        while(count <= m){\n            x += l(x)\n            result = (x :: result) \n            count += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpd2m_0fw1.scala:15:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            x += l(x)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980043
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        def recurse(n : List[Long], acc : List[Long]) : List[Long] = {\n            n match {\n                case x :: xs => (x :: acc) :: (recurse(xs, acc :: List(x)))\n                case _ => acc\n            }\n        }\n        recurse(l, List[Long]())\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprxp8umq0.scala:12:59 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                \u001b[33mcase\u001b[0m x :: xs => (x :: acc) :: (recurse(xs, acc :: List(x)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (acc : List[Long])\n\u001b[31m   |\u001b[0m                                            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprxp8umq0.scala:12:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                \u001b[33mcase\u001b[0m x :: xs => (x :: acc) :: (recurse(xs, acc :: List(x)))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mLong\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980045
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val l1 = l.toIndexedSeq\n        var i = l.length\n        while (i > 0) l(i) = l(i-1) + 1 \n        l1 \n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpijpa5jdi.scala:12:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mwhile\u001b[0m (i > \u001b[31m0\u001b[0m) l(i) = l(i-\u001b[31m1\u001b[0m) + \u001b[31m1\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m    value update is not a member of List[Long] - did you mean l.updated?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpijpa5jdi.scala:13:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        l1 \n\u001b[31m\u001b[31m   |\u001b[0m        ^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (l1 : IndexedSeq[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980046
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var result : List[Long] = l\n        result.foreach(x => result = (x += 1))\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpircoofzd.scala:11:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        result.foreach(\u001b[36mx\u001b[0m => result = (x += \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value += is not a member of Long - did you mean x.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980045
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.foldLeft(List(1l.toLong)) { \n          case (hl, x) => x+1l.toLong :: hl }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5lrwlba6.scala:14)\n\tat Problem.main(tmp5lrwlba6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980047
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList = new mutable.ListBuffer[Long]\n        l.foreach { l =>\n            val l = l\n            newList += l + l.toLong + 1\n        }\n        newList.distinct\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvgsaprr5.scala:10:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980042
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var i = l.head\n        var j = i + 1\n        val l = List(l.tail)\n        val s = l.foldLeft(1l.toLong)( (acc, cur) => acc.+(cur*(j/acc)) )\n        val ret = List(l.head + s)\n        while ( i < l.last ) {\n            i = i + 1 \n            j = i + 1\n            ret = ret + List(i.toLong + s)\n        }\n        return ret\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpwe0iq1gq.scala:12:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = List(l.tail)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Recursive \u001b[33mvalue\u001b[0m \u001b[35ml\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwe0iq1gq.scala:11:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mj\u001b[0m = i + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value + is not a member of Nothing\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwe0iq1gq.scala:13:62 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ms\u001b[0m = l.foldLeft(\u001b[31m1l\u001b[0m.toLong)( (\u001b[36macc\u001b[0m, \u001b[36mcur\u001b[0m) => acc.+(cur*(j/acc)) )\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue * is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwe0iq1gq.scala:14:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mret\u001b[0m = List(l.head + s)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value + is not a member of Nothing\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwe0iq1gq.scala:15:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mwhile\u001b[0m ( i < l.last ) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[",
      "stdout": "",
      "timestamp": 1659980048
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newL = new mutable.ArrayBuffer[Long]()\n        var cur = l.head\n        newL += cur\n        for(i <- 1 to l.tail.length-1){\n            val next = (cur + i).toLong\n            newL += next\n            cur = next\n        }\n        newL += cur\n        newL.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpappgs_q0.scala:10:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewL\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980045
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.foldLeft[List[Long]](mutable.List.empty[Long]) {\n            (l2,e) => e :: l2.last + 1 }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxlkpun9m.scala:10:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        l.foldLeft[\u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m]](mutable.List.empty[\u001b[35mLong\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxlkpun9m.scala:11:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            (\u001b[36ml2\u001b[0m,\u001b[36me\u001b[0m) => e :: l2.last + \u001b[31m1\u001b[0m }\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of Long\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980046
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var list = l\n        list = list.map{ _ + 1l }\n        list\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980049
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var res = List(1l.toLong)\n        var l = l\n        var l = l\n        for (i <- 0 until l.length-1){\n            l.updated(i, l(i+1))\n            res = res + l\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpb35ktqo4.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ml\u001b[0m = l\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0ml is already defined as \u001b[33mvariable\u001b[0m \u001b[35ml\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpb35ktqo4.scala:11:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ml\u001b[0m = l\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvariable\u001b[0m \u001b[35ml\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb35ktqo4.scala:15:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            res = res + l\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980049
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        if (l.isEmpty) Nil\n        else {\n            val m = l.head\n            val n = m.toLong + 1\n            l.init(n::l)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt7cjqtre.scala:14:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            l.init(n::l)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    List[Long]\n\u001b[31m   |\u001b[0m                   Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980048
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val l1 = l.map { x =>\n            x + 1\n        }\n        l1\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980049
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var result = new Array[Long](l.size)\n        var i = 0\n        for (elem <- l) {\n            result(i) = elem + 1\n            i = i + 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnel0x60a.scala:16:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980048
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val ls = mutable.MutableList[Long]()\n        ls ++= l\n        ls.map( x => x+1 )\n        ls.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9_ae8fwu.scala:10:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mls\u001b[0m = mutable.MutableList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980045
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val m = l.head\n        val r : List[Long] = l tail\n        m.toLong :: r.foldLeft(m :: List(0l.toLong))( (l, acc) => l.head + acc.last )\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjwtzgdiy.scala:12:79 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        m.toLong :: r.foldLeft(m :: List(\u001b[31m0l\u001b[0m.toLong))( (\u001b[36ml\u001b[0m, \u001b[36macc\u001b[0m) => l.head + acc.last )\n\u001b[31m\u001b[31m   |\u001b[0m                                                                           ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      value last is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjwtzgdiy.scala:13:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980049
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.map(x => x + 1l.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980050
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.zipWithIndex.map { case (n, i) => i + n.toLong }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpq713x3d8.scala:14)\n\tat Problem.main(tmpq713x3d8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980051
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList = new collection.mutable.ListBuffer[Long]()\n        var i = 0\n        var sum = 0\n\n        for(i <- 0 until l.size){\n            sum += l(i)\n            newList.+=(i)\n        }\n\n        for(i <- 0 until newList.size){\n            sum += 1l\n            newList += sum\n        }\n\n        newList.drop(l.size)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp7n1hux7.scala:15:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            sum += l(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp7n1hux7.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            sum += \u001b[31m1l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpp7n1hux7.scala:24:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        newList.drop(l.size)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    scala.collection.mutable.ListBuffer[Long]\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980052
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val l1 = l.map(i => i + 1).toList\n        l1.reverse.foldLeft(List((0l.toLong, 0l.toLong))) { \n          case (acc, v) => \n            acc :+ ((v._1 + 1l.toLong) * v._2)\n          }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppsytw0ck.scala:13:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            acc :+ ((v._1 + \u001b[31m1l\u001b[0m.toLong) * v._2)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value _1 is not a member of Long\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980052
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.map((_ + 1, _ + 1, _ + 1)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpdlhfo86p.scala:10:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        l.map((_ + \u001b[31m1\u001b[0m, _ + \u001b[31m1\u001b[0m, _ + \u001b[31m1\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$1 of expanded function:\n\u001b[31m   |\u001b[0m   _$1 => _$1 + 1.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpdlhfo86p.scala:10:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        l.map((_ + \u001b[31m1\u001b[0m, _ + \u001b[31m1\u001b[0m, _ + \u001b[31m1\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$2 of expanded function:\n\u001b[31m   |\u001b[0m   _$2 => _$2 + 1.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpdlhfo86p.scala:10:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        l.map((_ + \u001b[31m1\u001b[0m, _ + \u001b[31m1\u001b[0m, _ + \u001b[31m1\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$3 of expanded function:\n\u001b[31m   |\u001b[0m   _$3 => _$3 + 1.\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980049
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val r = mutable.Buffer.empty[Long]\n        for (l1 <- l) {\n            l match {\n                case l::l1 => {\n                    r.append(l1)\n                    l match {\n                        case l1 :: l2 => r.append((l1 + l2))\n                        case _ => r\n                    }\n                }\n                case _ => r\n            }\n        }\n        r \n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsgr8jqyh.scala:10:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mr\u001b[0m = mutable.Buffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980050
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.tails match {\n            case Nil => l // return list with elements incremented by 1\n            case x :: xs => incrList(xs) // recurse\n            case x1 :: x2 :: x3 :: x4 :: x5 :: x6 :: xs => x1 :: x2 :: x3 :: x4 :: x5 :: x6 :: xs // tail recurse\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmnkfbtav.scala:11:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mcase\u001b[0m Nil => l \u001b[34m// return list with elements incremented by 1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (Nil : => collection.immutable.Nil\u00b2.type)\n\u001b[31m   |\u001b[0m        Required: Iterator[List[Long]]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m        where:    Nil  is a getter in \u001b[33mpackage object\u001b[0m \u001b[35mscala\u001b[0m\n\u001b[31m   |\u001b[0m                  Nil\u00b2 is a object in \u001b[33mpackage\u001b[0m \u001b[35mscala.collection.immutable\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m        pattern type is incompatible with expected type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmnkfbtav.scala:12:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mcase\u001b[0m x :: xs => incrList(xs) \u001b[34m// recurse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (xs : List[Any])\n\u001b[31m   |\u001b[0m                                     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmnkfbtav.scala:13:59 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mcase\u001b[0m x1 :: x2 :: x3 :: x4 :: x5 :: x6 :: xs => x1 :: x2 :: x3 :: x4 :: x5 :: x6 :: xs \u001b[34m// tail recurse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    List[\u001b[1m\u001b[31mAny\u001b[0m]\n\u001b[31m   |\u001b[0m                                                    Required: List[\u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980054
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val res = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n        for (elem <- l) elem match {\n            case 0 => res += 0\n            case 1 => res += 1\n            case n => res += n\n        }\n        res.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxf5gns1a.scala:10:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980049
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val counter = collection.mutable.Map()\n        for(i <- l) {\n            if(counter.getOrElse(i, 0l) <= 1l)\n                counter(i) = 1l\n            else\n                counter(i) = counter(i) + 1l\n        }\n        val res = (for {\n            k <- counter\n        } yield k).map(_ + 1l).toList\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplbfi_vay.scala:12:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mif\u001b[0m(counter.getOrElse(i, \u001b[31m0l\u001b[0m) <= \u001b[31m1l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                 Required: Nothing\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplbfi_vay.scala:13:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                counter(i) = \u001b[31m1l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    (i : Long)\n\u001b[31m   |\u001b[0m                        Required: Nothing\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplbfi_vay.scala:13:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                counter(i) = \u001b[31m1l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (\u001b[31m1L\u001b[0m : Long)\n\u001b[31m   |\u001b[0m                             Required: Nothing\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplbfi_vay.scala:15:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                counter(i) = counter(i) + \u001b[31m1l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    (i : Long)\n\u001b[31m   |\u001b[0m                        Required: Nothing\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplbfi_vay.scala:15:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                counter(i) = counter(i) + \u001b[31m1l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (i : Long)\n\u001b[31m   |\u001b[0m                              ",
      "stdout": "",
      "timestamp": 1659980058
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var sum = 0L\n        var i = 0\n        for(elem <- l) sum = sum + elem\n        if(sum < 2L) l.toList\n        else {\n            var sum1 = 0L\n            var j = 0\n            for(elem <- l) sum1 = sum1 + elem\n            if(sum1 < 2L) l.toList\n            else {\n                var sum2 = 0L\n                var k = 0\n                for(elem <- l) sum2 = sum2 + elem\n                if(sum2 < 2L) l.toList\n                else {\n                    while(i < l.length) l.append(l(i).toLong + 1)\n                    i\n                }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuydhhg_8.scala:25:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                    \u001b[33mwhile\u001b[0m(i < l.length) l.append(l(i).toLong + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value append is not a member of List[Long] - did you mean l.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuydhhg_8.scala:26:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    i\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    (i : Int)\n\u001b[31m   |\u001b[0m                    Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980057
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList = mutable.ListBuffer.empty[Long]\n        val startValue = l.head\n        newList += startValue\n        for (i <- l.tail) {\n            newList += i + 1\n        }\n        newList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpg19eftmf.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980052
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        if (l.isEmpty) l\n        else {\n            var x = 0L\n            var y = l.head\n            var list = new List[Long]()\n            var newList = new List[Long]()\n            while (y > 1l) {\n                x += 1l\n                y = y / 2l\n                newList += x * y\n            }\n            list += x + newList.head\n            list += newList\n            list.tail\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj2pdu7hh.scala:19:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                newList += x * y\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj2pdu7hh.scala:21:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            list += x + newList.head\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj2pdu7hh.scala:22:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            list += newList\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980058
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var sum = 0\n        for (i <- 0 until l.length) {\n            sum = sum + i\n            l(i) = sum\n        }\n        l\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbsnn_ux0.scala:13:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            l(i) = sum\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0m    value update is not a member of List[Long] - did you mean l.updated?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980056
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val nums = l\n        nums.foldLeft(0l){ (sum, i) =>\n            sum + i\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpg3v9e9w0.scala:11:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        nums.foldLeft(\u001b[31m0l\u001b[0m){ (\u001b[36msum\u001b[0m, \u001b[36mi\u001b[0m) =>\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Long\n\u001b[31m   |\u001b[0m        Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m12 |\u001b[0m            sum + i\n\u001b[31m13 |\u001b[0m        }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980057
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var i = l.head + 1\n        var j = 0\n        var k = l.length\n        while(j < k) {\n            i = i + 1\n            i = i.toLong + k.toLong\n            k = k - 1\n            j = j + 1\n        }\n        return i.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmps_9g484u.scala:19:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mreturn\u001b[0m i.toList\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         value toList is not a member of Long - did you mean Long.toInt?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980057
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n      val newList = mutable.Buffer[Long]()\n      var prevVal = -1L\n      l.foreach { elem =>\n        if (elem == prevVal) {\n          newList += elem + 1L\n        } else {\n          newList += elem\n          prevVal = elem\n        }\n      }\n      newList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp363tne58.scala:10:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = mutable.Buffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980055
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val result = new ListBuffer[Long]()\n        var count = 0\n        l.foreach { x => count = x + 1; result += count}\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphhc32cd6.scala:12:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        l.foreach { \u001b[36mx\u001b[0m => count = x + \u001b[31m1\u001b[0m; result += count}\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    Long\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980059
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val i = l.iterator.zipWithIndex.map { case (item, index) => index + 1 }.dropWhile(item => item > l.size).sum\n        l.slice(0, i) ++ l.slice(i).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp_blj67wj.scala:11:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        l.slice(\u001b[31m0\u001b[0m, i) ++ l.slice(i).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter until of \u001b[33mmethod\u001b[0m \u001b[35mslice\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m: (from: Int, until: Int): List[Long]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980058
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val rec =  l match {\n            case Nil => Nil\n            case (x::xs) => incrList(xs) :: x\n        }\n        rec\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoqo2s07u.scala:12:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mcase\u001b[0m (x::xs) => incrList(xs) :: x\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value :: is not a member of Long\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980059
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var newList: List[Long] = l.toList\n        newList.foreach{\n            x => if (x % 2 == 0) x = x + 1\n        }\n        newList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpr0itwtxy.scala:12:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) x = x + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Reassignment to val x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980056
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var new_list : List[Long] = l.clone()\n        new_list.zipWithIndex.foreach { \n          case (elem,i) => if (elem == l(i)) new_list(i) = (l(i)+1).toLong else new_list(i) = elem\n        }\n        new_list\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmptfjch2y8.scala:10:38 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnew_list\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = l.clone()\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m\u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mObject\u001b[0m cannot be accessed as a member of (l : List[Long]) from module class Problem$.\n\u001b[31m   |\u001b[0m Access to protected \u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m not permitted because prefix type List[Long]\n\u001b[31m   |\u001b[0m does not conform to \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m where the access takes place\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptfjch2y8.scala:12:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m          \u001b[33mcase\u001b[0m (elem,i) => \u001b[33mif\u001b[0m (elem == l(i)) new_list(i) = (l(i)+\u001b[31m1\u001b[0m).toLong \u001b[33melse\u001b[0m new_list(i) = elem\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean List[Long].updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptfjch2y8.scala:12:80 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m          \u001b[33mcase\u001b[0m (elem,i) => \u001b[33mif\u001b[0m (elem == l(i)) new_list(i) = (l(i)+\u001b[31m1\u001b[0m).toLong \u001b[33melse\u001b[0m new_list(i) = elem\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean List[Long].updated?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980060
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val retList = mutable.Buffer.empty[Long]\n        for(i <- l) {\n            val ni = i + 1\n            if(ni < 0) ni = 0\n            if(ni > 100) ni = 100\n            retList.append(ni)\n        }\n        retList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp19vk3eu1.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mretList\u001b[0m = mutable.Buffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp19vk3eu1.scala:13:26 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mif\u001b[0m(ni < \u001b[31m0\u001b[0m) ni = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Reassignment to val ni\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp19vk3eu1.scala:14:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mif\u001b[0m(ni > \u001b[31m100\u001b[0m) ni = \u001b[31m100\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Reassignment to val ni\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980057
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var i = l.head\n        var r = l.tail\n        var r = r.tail\n        val m = r.head\n        while(i + 1 < r.head) {\n            i = i + 1\n            r = r.tail\n            r = r.tail\n            val j = r.head\n            r.head = j\n            r.tail = List(i)\n            val f = r.head\n            r.head = f(m)\n            r.tail = List(f)\n            val k = r.head\n            r.head = f(k)\n            r.tail = List(f)\n        }\n        if (i != m) {\n            r.head = r.reverse.head\n            r.tail = r.reverse.tail\n            r.head = f(m)\n            r.tail = List(f)\n            r.head = r.tail.head\n            r.tail = r.tail.tail\n        }\n        val x = r.head\n        val y = r.tail\n        r.reverse.head = x\n        r.reverse.tail = y\n        r.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_j3mywij.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mr\u001b[0m = r.tail\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mr is already defined as \u001b[33mvariable\u001b[0m \u001b[35mr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp_j3mywij.scala:19:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            r.head = j\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val head\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp_j3mywij.scala:20:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            r.tail = List(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val tail\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp_j3mywij.scala:22:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            r.head = f(m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvalue\u001b[0m \u001b[35mf\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp_j3mywij.scala:23:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            r.tail = List(f)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val tail\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp_j3mywij.scala:25:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            r.head = f(k)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvalue\u001b[0m \u001b[35mf\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when co",
      "stdout": "",
      "timestamp": 1659980058
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val r = new ListBuffer[Long]()\n        var i = l.head\n        var j = l.tail.head\n        for(x <- l.tail.tail) r = r :+ i + x\n        r.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmph_di525o.scala:13:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m(x <- l.tail.tail) r = r :+ i + x\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Reassignment to val r\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980057
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n      val listCopy = l.map(_ + 1)\n      l.zip(listCopy)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0kntzr4x.scala:11:11 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m      l.zip(listCopy)\n\u001b[31m\u001b[31m   |\u001b[0m      ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      Found:    List[\u001b[1m\u001b[31m(\u001b[0mLong\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m\u001b[1m\u001b[31m)\u001b[0m]\n\u001b[31m   |\u001b[0m      Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980060
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val n = l.size\n        val result = new scala.collection.mutable.ListBuffer[Long](n)\n        (0 until n).foreach(i => result(i) = l(i)+1l)\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpoqtsshp3.scala:11:67 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m scala.collection.mutable.ListBuffer[\u001b[35mLong\u001b[0m](n)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0mtoo many arguments for \u001b[33mconstructor\u001b[0m \u001b[35mListBuffer\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mListBuffer\u001b[0m: (): scala.collection.mutable.ListBuffer[Long]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980058
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        if (l.isEmpty) l\n        else {\n            def incr (l1 : List[Long], l2 : List[Long]) : List[Long] = {\n                if (l1.isEmpty) l2\n                else {\n                    def incr1 (l1 : List[Long], acc : List[Long]) : List[Long] =\n                        if (l1.isEmpty) acc\n                        else incr1(l1.tail, l2 :: acc)\n                    incr1(l1, Nil)\n                }\n            }\n            incr(l, l)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpaqs1evjr.scala:17:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                        \u001b[33melse\u001b[0m incr1(l1.tail, l2 :: acc)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (l2 : List[Long])\n\u001b[31m   |\u001b[0m                                            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980061
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var newList = List()\n        val size = l.length\n        var i = 1\n        while (i < size) {\n            newList :+= l(i) + i\n            i += 1\n        }\n        newList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgtmjl3dm.scala:14:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            newList :+= l(i) + i\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue :+= is not a member of List[Nothing] - did you mean List[Nothing].:+?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980062
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val result = mutable.ArrayBuffer.empty[Long]\n        l.foreach(x => result += x.toLong)\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3gjox332.scala:10:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980059
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val ans = List(l.head)\n        l match {\n            case Nil => ans\n            case head :: tail => ans ++ incrList(tail)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.incrList(tmpkij9ff51.scala:10)\n\tat Problem$.main(tmpkij9ff51.scala:17)\n\tat Problem.main(tmpkij9ff51.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980064
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val l = l.toSeq\n        val ns = l.map(_+1).toSeq\n        l.inits\n                .filter(_ != 0)\n                .foldRight(ns)( (l2, l2i) => l2.updated(l2i, l2(l2i) + 1) )\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpls99xp7b.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = l.toSeq\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35ml\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980060
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.map { x => x += 1; x }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7hrd2996.scala:10:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        l.map { \u001b[36mx\u001b[0m => x += \u001b[31m1\u001b[0m; x }\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value += is not a member of Long - did you mean x.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980065
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val r = mutable.Buffer[Long]()\n        for (a <- l) {\n            r += a\n        }\n        r.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpckut06ri.scala:10:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mr\u001b[0m = mutable.Buffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980062
    },
    {
      "exit_code": -1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        // use recursion to increase elements by 1\n        if (l.length < 2)\n            l\n        else\n            incrList(l.tail ::: l.head :: Nil)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Timeout",
      "stderr": "None",
      "stdout": "None",
      "timestamp": 1659980071
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        // Use mutable to avoid return a new object reference.\n        var res = l\n        var i = 0\n        while (i+1 < res.length) {\n            res(i+1) = res(i)+1\n            i = i + 1\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmji6wx_t.scala:14:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            res(i+\u001b[31m1\u001b[0m) = res(i)+\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean List[Long].updated?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980067
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val l = l\n        var res = new ListBuffer[Long]()\n        for (l1 <- l.iterator; l2 <- l.iterator) {\n            val res = l1.toLong + l2.toLong\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += res\n            res += \n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp4u6j6v9e.scala:131:18 --------------------------\u001b[0m\u001b[0m\n\u001b[31m131 |\u001b[0m            res += \n\u001b[31m\u001b[31m    |\u001b[0m                  ^\u001b[0m\n\u001b[31m    |\u001b[0m                  expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4u6j6v9e.scala:140:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m140 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4u6j6v9e.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = l\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35ml\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4u6j6v9e.scala:139:1 --------------------\u001b[0m\u001b[0m\n\u001b[31m139 |\u001b[0m}\n\u001b[31m\u001b[31m    |\u001b[0m ^\u001b[0m\n\u001b[31m    |\u001b[0m Found:    Unit\n\u001b[31m    |\u001b[0m Required: List[Long]\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp4u6j6v9e.scala:133:4 ---------------------------------------\u001b[0m\u001b[0m\n\u001b[33m133 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m    |\u001b[0m    ^\u001b[0m\n\u001b[33m    |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659980067
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val result = new ListBuffer[Long]()\n        for(i <- l.iterator) {\n            result.append(i + 1)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980069
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val ll = l\n        ll map { x=>\n            x+1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980069
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.map(_+1).toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980069
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var i = 0\n        var ret = new ListBuffer[Long]()\n        while(i < l.length) {\n            i = i + 1\n            ret.append(l(i))\n        }\n        return ret\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvvtc5rc4.scala:16:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mreturn\u001b[0m ret\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    (ret : scala.collection.mutable.ListBuffer[Long])\n\u001b[31m   |\u001b[0m             Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980068
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var res : List[Long] = Nil\n        l foreach (x => res = x :: res)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnhie99ss.scala:16)\n\tat Problem.main(tmpnhie99ss.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980070
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l :+ l.last\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: last of empty list\n\tat scala.collection.immutable.Nil$.last(List.scala:665)\n\tat scala.collection.immutable.Nil$.last(List.scala:661)\n\tat Problem$.incrList(tmp6whwroee.scala:10)\n\tat Problem$.main(tmp6whwroee.scala:13)\n\tat Problem.main(tmp6whwroee.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980069
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var result = l.toList\n        result.foreach(e => e+1)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmph3v3r3_7.scala:16)\n\tat Problem.main(tmph3v3r3_7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980070
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val list = l.toList\n        val res = mutable.Buffer.empty[Long]\n        for (i <- 0 until list.length) res = res :+ list(i + 1).asInstanceOf[Long]\n        list.toList.flatMap(_.asInstanceOf[Long])\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnmu8ie29.scala:11:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.Buffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpnmu8ie29.scala:12:43 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until list.length) res = res :+ list(i + \u001b[31m1\u001b[0m).asInstanceOf[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Reassignment to val res\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnmu8ie29.scala:13:42 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        list.toList.flatMap(_.asInstanceOf[\u001b[35mLong\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    Long\n\u001b[31m   |\u001b[0m                            Required: IterableOnce[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980069
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList = l.map { x =>\n            x + 1\n        }\n        newList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980069
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        // Create new list\n        val list = l.toList\n        // Create new counter\n        var cnt = 0\n        // Loop through list\n        for (ele <- list) {\n            // If current element is not the last element\n            if (cnt != list.size -1) {\n                // Increment the counter\n                cnt += 1\n            }\n            // If element is the last element\n            else if (cnt == list.size -1) {\n                // Increment the counter by one\n                cnt += 1\n            }\n            // Else element is not the last element\n            else {\n                // Add 1 to counter\n                cnt += 1\n            }\n            // Append the current element to the list\n            list :+= ele\n        }\n        // Return the list\n        list\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxlszy6gz.scala:32:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            list :+= ele\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         value :+= is not a member of List[Long] - did you mean list.:+?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980069
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.foldLeft((0l, List.empty[Long])) {\n            (sum, element) =>\n            val curSum = sum._1 + 1\n            val newSum = (sum._1, sum._2 ++ List(element))\n            (newSum, curSum)\n        }._2\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpomzjpkxl.scala:14:13 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            (newSum, curSum)\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    (newSum : (Long, List[Long]))\n\u001b[31m   |\u001b[0m             Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpomzjpkxl.scala:14:21 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            (newSum, curSum)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    (curSum : Long)\n\u001b[31m   |\u001b[0m                     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980070
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newL = new ListBuffer[Long]()\n        var i = 1\n        for (el <- l)\n            newL += el * i\n            i += 1\n        newL.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp54gx7juo.scala:19)\n\tat Problem.main(tmp54gx7juo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980071
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var res = l\n        res.foldLeft(List[Long]()){ (res, e) => res + e + 1}\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmps4bhlav6.scala:11:52 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        res.foldLeft(List[\u001b[35mLong\u001b[0m]()){ (\u001b[36mres\u001b[0m, \u001b[36me\u001b[0m) => res + e + \u001b[31m1\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980071
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.map(x => x + 1).toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980072
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val m = l.head\n        val n = l.tail.foldLeft(m)((a, b) => a + b)\n        n :: l\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.incrList(tmpkkahp4xq.scala:10)\n\tat Problem$.main(tmpkkahp4xq.scala:15)\n\tat Problem.main(tmpkkahp4xq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980072
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.tail.zip(l.tail.head +: l.tail).flatMap{ x => x }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvxe4j2_u.scala:10:56 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        l.tail.zip(l.tail.head +: l.tail).flatMap{ \u001b[36mx\u001b[0m => x }\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (x : (Long, Long))\n\u001b[31m   |\u001b[0m                                            Required: IterableOnce[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980071
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        // use mutable.ListBuffer\n        val b = mutable.ListBuffer[Long]()\n        for(x <- l)\n            b.append(b.lastOrElse(0) + 1)\n        return b\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxfqcvs5j.scala:11:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980069
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var tmpList = l\n        tmpList.zipWithIndex.foreach {\n            case (v, i) =>\n                tmpList(i) = v + 1\n        }\n        tmpList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0_0d0ehd.scala:13:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                tmpList(i) = v + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean List[Long].updated?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980073
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.zipWithIndex.map { case (l: Long, i) => l + 1 }.filter(_ <= l.length).map(_ + 1).toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpmjei49jn.scala:14)\n\tat Problem.main(tmpmjei49jn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980075
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var cur = 0\n        var ret: List[Long] = Nil\n        for (x <- l) {\n            x match {\n                case 1 => ret :+= 1\n                case _ => ret :+= x + 1\n            }\n        }\n        return ret\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpjxfgms3s.scala:22)\n\tat Problem.main(tmpjxfgms3s.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980078
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList = ListBuffer.empty[Long]\n        l foreach (x => newList += (x+1))\n        newList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980078
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n      val l = l flatMap (x => List(x+1,x+2))\n      l\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp75kg7ih6.scala:10:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = l flatMap (\u001b[36mx\u001b[0m => List(x+\u001b[31m1\u001b[0m,x+\u001b[31m2\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m              ^\u001b[0m\n\u001b[31m   |\u001b[0m              Recursive \u001b[33mvalue\u001b[0m \u001b[35ml\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980073
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val s = l.toSet\n        val n = l.size\n        val d = s.foldLeft(0L)((acc,e) => (acc + e))\n        (l ++ List.fill(n)(d+1l)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpoxu3hwnh.scala:17)\n\tat Problem.main(tmpoxu3hwnh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980079
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        for (i <- 0 until l.length) {\n            l(i) += 1\n        }\n        l\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4eqarmqr.scala:11:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            l(i) += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean Long.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980079
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        def iterate(l : List[Long], acc : List[Long]) : List[Long] = {\n            if (l.isEmpty) acc\n            else iterate(l.tail, acc.head :: acc)\n        }\n        iterate(l, List())\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.iterate$1(tmpi948he22.scala:12)\n\tat Problem$.incrList(tmpi948he22.scala:14)\n\tat Problem$.main(tmpi948he22.scala:18)\n\tat Problem.main(tmpi948he22.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980080
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n      val li = l map (n => n + 1) //increments the elements\n      li\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980080
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        // Use Scala collections instead of mutable List\n        var newList = ListBuffer[Long]()\n        var total = 0\n        // Use `foreach` instead of `map` to avoid side effects\n        // from side effects in `map` accumulator.\n        l.foreach { elem =>\n            total += elem\n            newList += elem\n        }\n        newList += total\n        // Return list\n        newList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppgg09g4z.scala:16:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            total += elem\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980079
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var result: List[Long] = null\n        for(i <- l)\n            result += List(i)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdqp9nlnv.scala:12:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            result += List(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980078
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val res = mutable.ListBuffer.empty[Long]\n        for (e <- l) {\n            res += e + 1\n        }\n        res.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzad6jpex.scala:10:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980076
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val map = new mutable.HashMap[Long, Long]()\n        for (ele <- l) {\n            if (map.contains(ele)) {\n                map.update(ele, map.get(ele) + 1)\n            } else {\n                map.put(ele, 1)\n            }\n        }\n        val result = new mutable.ListBuffer[Long]()\n        for (ele <- map) {\n            result.add(ele._2)\n        }\n        return result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp334n8gse.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp334n8gse.scala:18:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980077
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val x = l.foldLeft((0l, List())){\n            (y, x) => x ++ List(y._1 + 1l.toLong, y._2)\n        }._2\n        x\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwmwh6wim.scala:11:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            (\u001b[36my\u001b[0m, \u001b[36mx\u001b[0m) => x ++ List(y._1 + \u001b[31m1l\u001b[0m.toLong, y._2)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value ++ is not a member of Long\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980080
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var i : Long = 1\n        var l : List[Long] = l.map(l => i + l.toLong).toList\n        for(l <- l) {\n            i ++\n            l ++\n        }\n        l\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpupsivek8.scala:14:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            l ++\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpupsivek8.scala:13:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            i ++\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value ++ is not a member of Long\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980079
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val result = new ListBuffer[Long]()\n        l foreach { x => result.add((x + 1).toLong) }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx4bties_.scala:11:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        l foreach { \u001b[36mx\u001b[0m => result.add((x + \u001b[31m1\u001b[0m).toLong) }\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m  value add is not a member of scala.collection.mutable.ListBuffer[Long]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980080
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newL = new mutable.ListBuffer[Long]()\n        val list = l.toList\n        for (i <- list) {\n            newL += i + 1\n        }\n        newL.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnyfvba6j.scala:10:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewL\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980077
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val m = l.max\n        val n = m.toLong + 1\n        l.map {\n            case x => x + 1\n        } ++ List(n.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\tat Problem$.incrList(tmp7qk2ygyl.scala:10)\n\tat Problem$.main(tmp7qk2ygyl.scala:17)\n\tat Problem.main(tmp7qk2ygyl.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980083
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n      val res = l.foldLeft((l.head, 1L)) { case ((x, y), i) => if (i == 1L) (x, y + 1L) else (y, x); case (z, i) => (z, 1L) }\n      res._1.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsblivn5y.scala:10:117 -------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = l.foldLeft((l.head, \u001b[31m1L\u001b[0m)) { \u001b[33mcase\u001b[0m ((x, y), i) => \u001b[33mif\u001b[0m (i == \u001b[31m1L\u001b[0m) (x, y + \u001b[31m1L\u001b[0m) \u001b[33melse\u001b[0m (y, x); \u001b[33mcase\u001b[0m (z, i) => (z, \u001b[31m1L\u001b[0m) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (z : (Long, Long))\n\u001b[31m   |\u001b[0m                                            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsblivn5y.scala:11:13 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m      res._1.toList\n\u001b[31m\u001b[31m   |\u001b[0m      ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value toList is not a member of Long - did you mean _1.toInt?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980082
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val l2 = l.map(_ + 1)\n        l2.tail\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: tail of empty list\n\tat scala.collection.immutable.Nil$.tail(List.scala:664)\n\tat scala.collection.immutable.Nil$.tail(List.scala:661)\n\tat Problem$.incrList(tmplu3453xa.scala:11)\n\tat Problem$.main(tmplu3453xa.scala:14)\n\tat Problem.main(tmplu3453xa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980084
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var l1 = List(l.head)\n        var l2 = List(l.last)\n        var l3 = List(l.last)\n        var l4 = List(l.last)\n        while (l2.last < l3.last && l2.last < l4.last) {\n            l1.last:=l1.last + 1\n            l2.last:=l2.last + 1\n            l3.last:=l3.last + 1\n            l4.last:=l4.last + 1\n        }\n        while (l2.last > l3.last && l2.last > l4.last) {\n            l1.last:=l1.last - 1\n            l2.last:=l2.last - 1\n            l3.last:=l3.last - 1\n            l4.last:=l4.last - 1\n        }\n        while (l2.last < l3.last && l2.last > l4.last) {\n            l1.last:=l1.last + 1\n            l2.last:=l2.last - 1\n            l3.last:=l3.last - 1\n            l4.last:=l4.last - 1\n        }\n        while (l2.last > l3.last && l2.last < l4.last) {\n            l1.last:=l1.last - 1\n            l2.last:=l2.last + 1\n            l3.last:=l3.last - 1\n            l4.last:=l4.last + 1\n        }\n        while (l2.last < l3.last && l2.last > l4.last) {\n            l1.last:=l1.last - 1\n            l2.last:=l2.last - 1\n            l3.last:=l3.last + 1\n            l4.last:=l4.last + 1\n        }\n        while (l2.last > l3.last && l2.last < l4.last) {\n            l1.last:=l1.last + 1\n            l2.last:=l2.last - 1\n            l3.last:=l3.last - 1\n            l4.last:=l4.last - 1\n        }\n        while (l2.last < l3.last && l2.last < l4.last) {\n            l1.last:=l1.last + 1\n            l2.last:=l2.last + 1\n            l3.last:=l3.last + 1\n            l4.last:=l4.last - 1\n        }\n        while (l2.last > l3.last && l2.last > l4.last) {\n            l1.last:=l1.last - 1\n            l2.last:=l2.last - 1\n            l3.last:=l3.last - 1\n            l4.last:=l4.last + 1\n        }\n        while (l2.last < l3.last && \n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp0hr2_e44.scala:62:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m        \u001b[33mwhile\u001b[0m (l2.last < l3.last && \n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0hr2_e44.scala:15:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            l1.last:=l1.last + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value := is not a member of Long - did you mean Long.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0hr2_e44.scala:16:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            l2.last:=l2.last + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value := is not a member of Long - did you mean Long.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0hr2_e44.scala:17:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            l3.last:=l3.last + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value := is not a member of Long - did you mean Long.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0hr2_e44.scala:18:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            l4.last:=l4.last + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value := is not a member of Long - did you mean Long.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0hr2_e44.scala:21:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            l1.last:=l1.last - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value := is not a member of Long - did you mean Long.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0hr2_e44.scala:22:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            l2.last:=l2.last - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value := is not a member of L",
      "stdout": "",
      "timestamp": 1659980086
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l match {\n            case Nil => Nil\n            case head :: tail => \n                val newHead = head + 1\n                incrList(tail map { n => n + newHead }) \n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpmpi93n2y.scala:19)\n\tat Problem.main(tmpmpi93n2y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980084
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var result = l.map(_ + 1).distinct\n        var i = 0\n        while (i < l.length) {\n            if (l(i) != l(i + 1))\n                result += (l(i))\n            i += 2\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2t7f6e0r.scala:14:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                result += (l(i))\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980082
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val n = l.length\n        var l1 = l.head\n        var l2 = l.tail\n        val r : List[Long] = new ListBuffer[Long](n)\n        var i : Int = 0\n        while(i < n) {\n            l1 += 1\n            l2 += 1\n            i +=1\n            l.tail.foreach(x => l.head += x)\n            l += l1 +l2\n        }\n        r.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpi_evgqzs.scala:13:50 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mr\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m \u001b[35mListBuffer\u001b[0m[\u001b[35mLong\u001b[0m](n)\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mtoo many arguments for \u001b[33mconstructor\u001b[0m \u001b[35mListBuffer\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mListBuffer\u001b[0m: (): scala.collection.mutable.ListBuffer[Long]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi_evgqzs.scala:17:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            l2 += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi_evgqzs.scala:19:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            l.tail.foreach(\u001b[36mx\u001b[0m => l.head += x)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Long - did you mean Long.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi_evgqzs.scala:20:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            l += l1 +l2\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of List[Long] - did you mean l.!=?\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpi_evgqzs.scala:20:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            l += l1 +l2\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m+\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0m (x: String): String\n\u001b[31m   |\u001b[0mmatch arguments ((l2 : List[Long]))\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659980085
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l match {\n            case Nil => Nil\n            case _ => {\n                val list1 = l.toList\n                val list2 = list1.map(x => x + 1l.toLong).toList\n                list2.reverse\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpswjni94r.scala:21)\n\tat Problem.main(tmpswjni94r.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980085
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var n = 0\n        var l = l.toList\n        for (elem <- l) {\n            n += 1\n            l += n\n        }\n        l\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdno__q8h.scala:11:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ml\u001b[0m = l.toList\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvariable\u001b[0m \u001b[35ml\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980083
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList : mutable.Buffer[Long] = new mutable.Buffer[Long]()\n        for (elem <- l) {\n            newList += elem\n        }\n        for (elem <- newList) {\n            newList -= elem\n        }\n        newList += 1\n        newList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkzpj43p7.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m : mutable.Buffer[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m mutable.Buffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkzpj43p7.scala:10:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m : mutable.Buffer[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m mutable.Buffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980083
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l match {\n            case Nil => Nil\n            case x::xs => (x + 1l) :: incrList(xs)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980089
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val list = mutable.ListBuffer[Long]()\n        var index = 0\n        for (el <- l) {\n            index += 1\n            list += el\n            list += index\n        }\n        list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptw0qrvcx.scala:10:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980084
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var l2 = l.map(_ + 1).toList\n        var l3 = l.map(x => x + 1).toList\n        var l4 = l.map(x => x + (10 * x)).toList\n        var l5 = l.map(x => x + (100 * x)).toList\n        var l6 = l.map(x => x + (1000 * x)).toList\n        var l7 = l.map(x => x + (10000 * x)).toList\n        var l8 = l.map(x => x + (100000 * x)).toList\n        var l9 = l.map(x => x + (1000000 * x)).toList\n        var l10 = l.map(x => x + (10000000 * x)).toList\n        var l11 = l.map(x => x + (100000000 * x)).toList\n        var l12 = l.map(x => x + (1000000000 * x)).toList\n        var l13 = l.map(x => x + (10000000000 * x)).toList\n        var l14 = l.map(x => x + (100000000000 * x)).toList\n        var l15 = l.map(x => x + (1000000000000 * x)).toList\n        var l16 = l.map(x => x + (10000000000000 * x)).toList\n        var l17 = l.map(x => x + (100000000000000 * x)).toList\n        var l18 = l.map(x => x + (1000000000000000 * x)).toList\n        var l19 = l.map(x => x + (10000000000000000 * x)).toList\n        var l20 = l.map(x => x + (100000000000000000 * x)).toList\n        var l21 = l.map(x => x + (1000000000000000000 * x)).toList\n        var l22 = l.map(x => x + (10000000000000000000 * x)).toList\n        var l23 = l.map(x => x + (100000000000000000000 * x)).toList\n        var l24 = l.map(x => x + (1000000000000000000000 * x)).toList\n        var l25 = l.map(x => x + (10000000000000000000000 * x)).toList\n        var l26 = l.map(x => x + (100000000000000000000000 * x)).toList\n        var l27 = l.map(x => x + (1000000000000000000000000 * x)).toList\n        var l28 = l.map(x => x + (10000000000000000000000000 * x)).toList\n        var l29 = l.map(x => x + (100000000000000000000000000 * x)).toList\n        var l30 = l.map(x => x + (1000000000000000000000000000 * x)).toList\n        var l31 = l.map(x => x + (10000000000000000000000000000 * x)).toList\n        var l32 = l.map(x => x + (100\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8zp_x3dg.scala:41:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp8zp_x3dg.scala:21:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ml13\u001b[0m = l.map(\u001b[36mx\u001b[0m => x + (\u001b[31m10000000000\u001b[0m * x)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  number too large\n\u001b[31m\u001b[31m-- Error: /tmp/tmp8zp_x3dg.scala:22:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ml14\u001b[0m = l.map(\u001b[36mx\u001b[0m => x + (\u001b[31m100000000000\u001b[0m * x)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  number too large\n\u001b[31m\u001b[31m-- Error: /tmp/tmp8zp_x3dg.scala:23:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ml15\u001b[0m = l.map(\u001b[36mx\u001b[0m => x + (\u001b[31m1000000000000\u001b[0m * x)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  number too large\n\u001b[31m\u001b[31m-- Error: /tmp/tmp8zp_x3dg.scala:24:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ml16\u001b[0m = l.map(\u001b[36mx\u001b[0m => x + (\u001b[31m10000000000000\u001b[0m * x)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  number too large\n\u001b[31m\u001b[31m-- Error: /tmp/tmp8zp_x3dg.scala:25:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ml17\u001b[0m = l.map(\u001b[36mx\u001b[0m => x + (\u001b[31m100000000000000\u001b[0m * x)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  number too large\n\u001b[31m\u001b[31m-- Error: /tmp/tmp8zp_x3dg.scala:26:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ml18\u001b",
      "stdout": "",
      "timestamp": 1659980089
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val nim  = l.toList\n        val list = n.tail.init\n        val rem = n.tail.last\n        val n   = l.toInt\n        val k   = l.toInt\n        val k1 = n.toInt\n        val k2 = k.toInt\n\n        var i = 0\n        var j = 0\n        var k3 = 1\n        var k4 = k3\n        var k5 = k4\n        var k6 = k5\n        var k7 = k6\n        val k = k1.toInt\n\n        var k9 = k2.toInt\n        var k10 = k9\n        var k11 = k10\n        var k12 = k11\n\n        var k13 = k3.toInt\n        var k14 = k13\n        var k15 = k14\n        var k16 = k15\n\n        val newList = List[Long](k13.toLong)\n        var k17 = k14.toInt\n        var k18 = k17\n        var k19 = k18\n        var k20 = k19\n\n        val nk = k17.toLong\n\n        var k21 = 0\n        var k22 = k21\n        var k23 = k22\n        var k24 = k23\n        val k25 = k22\n\n        var k26 = k25.toInt\n        var k27 = k26\n        var k28 = k27\n        var k29 = k28\n\n        var k30 = k27.toInt\n        var k31 = k30\n        var k32 = k31\n        var k33 = k32\n\n        var k34 = k28.toInt\n        var k35 = k34\n        var k36 = k35\n        var k37 = k36\n\n        var k38 = k37.toInt\n        var k39 = k38\n        var k40 = k39\n        var k41 = k40\n\n        var k42 = k37.toInt\n        var k43 = k42\n        var k44 = k43\n        var k45 = k44\n\n        var k46 = k43.toInt\n        var k47 = k46\n        var k48 = k47\n        var k49 = k48\n\n        var k50 = k47.toInt\n        var k51 = k50\n        var k52 = k51\n        var k53 = k52\n\n        var k54 = k48.toInt\n        var k55 = k54\n        var k56 = k55\n        var k57 = k56\n\n        var k58 = k55.toInt\n        var k59 = k58\n        var k60 = k59\n        var k61 = \n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpue2r6hua.scala:94:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m94 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mk61\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                 expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpue2r6hua.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mk\u001b[0m = k1.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mk is already defined as \u001b[33mvalue\u001b[0m \u001b[35mk\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpue2r6hua.scala:13:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m   = l.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toInt is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpue2r6hua.scala:14:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mk\u001b[0m   = l.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toInt is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tm",
      "stdout": "",
      "timestamp": 1659980090
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        if (l.isEmpty) l\n        else incrList(l.tail) ++ (l.head + 1l.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz740vpgd.scala:11:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33melse\u001b[0m incrList(l.tail) ++ (l.head + \u001b[31m1l\u001b[0m.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    Long\n\u001b[31m   |\u001b[0m                                  Required: IterableOnce[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980089
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val result = mutable.Buffer.empty[Long]\n        l.foreach{\n            i => result += i\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpry1bjn19.scala:10:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.Buffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980086
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        l.foreach{elem => result ::=  elem + 1}\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpf_l7mo7k.scala:16)\n\tat Problem.main(tmpf_l7mo7k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980092
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.zip(l.tail).map { case (e, i) => i + e }.drop(1)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: tail of empty list\n\tat scala.collection.immutable.Nil$.tail(List.scala:664)\n\tat scala.collection.immutable.Nil$.tail(List.scala:661)\n\tat Problem$.incrList(tmp3qq1zm9y.scala:10)\n\tat Problem$.main(tmp3qq1zm9y.scala:13)\n\tat Problem.main(tmp3qq1zm9y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980091
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        def loop(acc : List[Long], acc : List[Long]) : List[Long] = {\n            if(acc.isEmpty) {\n                return acc\n            }\n            else if(acc.headOption.exists(_ > acc.last)) {\n                acc :+ acc.last\n            }\n            else {\n                acc :+ acc.head + 1\n            }\n            loop(acc :+ acc.last, acc)\n        }\n        loop(l, l.headOption)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpm4b4es7s.scala:10:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mdef\u001b[0m \u001b[36mloop\u001b[0m(\u001b[36macc\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m], \u001b[36macc\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m]) : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0macc is already defined as \u001b[33mparameter\u001b[0m \u001b[35macc\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpm4b4es7s.scala:22:18 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        loop(l, l.headOption)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    \u001b[1m\u001b[31mOption\u001b[0m[Long]\n\u001b[31m   |\u001b[0m                Required: \u001b[1m\u001b[32mList\u001b[0m[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980090
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.map{ x =>\n            x + 1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980091
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val listCopy = l.toList\n        listCopy.map(l => (l + l.toLong).toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnk0tt41k.scala:15)\n\tat Problem.main(tmpnk0tt41k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980092
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l match {\n            case Nil => Nil\n            case x :: xs => {\n                var newList = x.toList\n                var newSize = x.toLong + 1.toLong\n                for (y <- xs) {\n                    newSize += y.toLong\n                    newList += y.toLong\n                }\n                newList + newSize\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwowusunh.scala:13:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                \u001b[33mvar\u001b[0m \u001b[36mnewList\u001b[0m = x.toList\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value toList is not a member of Long - did you mean x.toInt?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980091
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var result = l\n        result foreach (l => { result = result :+ l + 1 })\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpe_s1lbvi.scala:16)\n\tat Problem.main(tmpe_s1lbvi.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980092
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val l1 = l.reverse\n        val l2 = l1.zipWithIndex.filter(a => a._2 == l1.indexOf(a._1))\n        val l3 = l2.flatMap(a => a._2.toLong +: List(1l.toLong))\n        l3.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp1xp1_961.scala:17)\n\tat Problem.main(tmp1xp1_961.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980094
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var res = l \n        for( n <- 1 to l.size){\n            val temp: List[Long] = res \n            res = temp + List(l(n).toLong)\n        }\n        res \n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy2_iuq8m.scala:13:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            res = temp + List(l(n).toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980093
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val m = scala.collection.mutable.ListBuffer.empty[Long]\n        l.foldLeft(m) { (buffer, elem) => buffer.+=(elem + 1l) }\n        m.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980095
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.map(x => x + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659979866
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val l2 = l.map(l => l+1)\n        l2.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980095
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val n = l.length\n        val s = l.reduceLeft((l,r) => l + r)\n        val v = s.toLong\n        val rs = List.range(0, n).toList\n        rs.toList match {\n            case 0 :: _ => List(1l.toLong)\n            case 1 :: x => List(1l.toLong + v.toLong)\n            case x :: xs => x :: incrList(xs.tail)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpktxybl9n.scala:17:45 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mcase\u001b[0m x :: xs => x :: incrList(xs.tail)\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    List[Int @uncheckedVariance]\n\u001b[31m   |\u001b[0m                                  Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980095
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val result = l.foldLeft(List.empty[Long])((acc, cur) => {\n            if (acc.isEmpty) {\n                acc.append(cur)\n            } else {\n                val lastElem = acc.last\n                acc.last += 1\n                acc.last :: cur\n            }\n        })\n        result.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxfg_d8yl.scala:12:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                acc.append(cur)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m value append is not a member of List[Long] - did you mean acc.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxfg_d8yl.scala:15:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                acc.last += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Long - did you mean Long.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxfg_d8yl.scala:16:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                acc.last :: cur\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value :: is not a member of Long\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980095
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val n = l.foldLeft(0l, Long.MaxValue) { case (nm, x) => (nm + x).toLong } + 1\n        l.map { x => x + n }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpprgx_724.scala:10:68 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mn\u001b[0m = l.foldLeft(\u001b[31m0l\u001b[0m, Long.MaxValue) { \u001b[33mcase\u001b[0m (nm, x) => (nm + x).toLong } + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of (Long, Long), but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980097
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.foldLeft(List())(_ :+ _ + 1.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpspww7zm8.scala:10:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        l.foldLeft(List())(_ :+ _ + \u001b[31m1\u001b[0m.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    Long\n\u001b[31m   |\u001b[0m                                Required: Nothing\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980094
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList = mutable.List.empty[Long]\n        for(i <- 0 until l.size) {\n            newList += i + 1l\n        }\n        newList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnzxi5ldn.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = mutable.List.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980093
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var res = l\n        for (i<- 0 until l.size) {\n          res += i\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7zm1c0fd.scala:12:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m          res += i\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980096
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.map(v => v.toLong + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980098
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var current = l.head\n        val newList = new mutable.ListBuffer[Long]\n        for(i <- 1 to l.length){\n            current = current + 1\n            newList += current\n        }\n        newList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppd_hm0tl.scala:11:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980095
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l.foldRight(List.empty[Long]) { (l, acc) => acc + l }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmph0r26ssv.scala:10:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        l.foldRight(List.empty[\u001b[35mLong\u001b[0m]) { (\u001b[36ml\u001b[0m, \u001b[36macc\u001b[0m) => acc + l }\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980100
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val m = mutable.ListBuffer.empty[Long]()\n        l foreach { i =>\n            m += i\n        }\n        m sortWith (_ < _) match {\n            case Nil => l map (_.toLong)\n            case _ => (l map (_.toLong) ::: m.toList)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvsh8_g_z.scala:10:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980096
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        if (l == Nil)\n            Nil\n        else {\n            var i : Long = 0\n            val l = scala.util.sorting.Ordering[Long].on[Long](_.toLong).reverse.from(l.head)\n\n            // iterate backwards\n            while (i < l.length) {\n                l(i) += i\n                i += 1\n            }\n            l\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfsh0yb7v.scala:14:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = scala.util.sorting.Ordering[\u001b[35mLong\u001b[0m].on[\u001b[35mLong\u001b[0m](_.toLong).reverse.from(l.head)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value sorting is not a member of util - did you mean util.Sorting?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980100
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        l flatMap { x => List(x + 1l.toLong) }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659980101
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val newList = mutable.ListBuffer[Long]()\n        l foreach { _ => newList += 1l.toLong }\n        newList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv1jja8dn.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewList\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980097
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var new_list = l.clone\n        new_list.reverse.foreach(x => {\n            x += 1\n        })\n        new_list.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpdhj5m26y.scala:10:25 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnew_list\u001b[0m = l.clone\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m\u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mObject\u001b[0m cannot be accessed as a member of (l : List[Long]) from module class Problem$.\n\u001b[31m   |\u001b[0m Access to protected \u001b[33mmethod\u001b[0m \u001b[35mclone\u001b[0m not permitted because prefix type List[Long]\n\u001b[31m   |\u001b[0m does not conform to \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m where the access takes place\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980099
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        if (l.length < 2) return l\n        val n = l.head\n        val m = l.tail.head\n        l.head +: l.tail.tail.zipWithIndex.map { case (v, i) => i + v }.drop(1)\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpzqghhbdh.scala:17)\n\tat Problem.main(tmpzqghhbdh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980103
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val l1 = l filter (_ <= l.last)\n        val l2 = l filter (_ >  l.last)\n        val l3 = l1 ++ l2\n        l3\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpx0ghbw62.scala:17)\n\tat Problem.main(tmpx0ghbw62.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980102
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        // TODO: write your solution here\n        val incr = l.tail\n        val newHead = incr.head\n        val newTail = incr.tail\n        incrList :: newTail\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqo735xpp.scala:14:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        incrList :: newTail\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    List[Long] => List[Long]\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980101
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val i = l.head + 1\n        val r = List(i)\n        l.reverse.zip(l).foreach(x => r += x._2)\n        r\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprg1qz5r6.scala:12:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        l.reverse.zip(l).foreach(\u001b[36mx\u001b[0m => r += x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             value += is not a member of List[Long] - did you mean r.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980101
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val m = (l.length/2 + 1) // number of odd elements\n        var i = 0;\n        for(l <- l) {\n            if(i++ < m) {\n                l+=(l-1)\n            }\n        }\n        l\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpqf1dm5hz.scala:13:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mif\u001b[0m(i++ < m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      expression expected but \u001b[31m')'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqf1dm5hz.scala:13:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mif\u001b[0m(i++ < m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value ++ is not a member of Int\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqf1dm5hz.scala:13:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mif\u001b[0m(i++ < m) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: <\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqf1dm5hz.scala:14:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                l+=(l-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Long - did you mean l.!=?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659980102
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val result = new mutable.MutableList[Long]()\n        for(i <- l)\n            result.add(i+1)\n        l.clear()\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprpg_8iq8.scala:10:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.MutableList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprpg_8iq8.scala:13:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        l.clear()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value clear is not a member of List[Long] - did you mean l.clone?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980102
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val r = l.toBuffer\n        val r2 = r.map(_ + 1).reverse\n        r2 ++ r\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk_vh845l.scala:12:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        r2 ++ r\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    scala.collection.mutable.Buffer[Long]\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980103
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val m = scala.math.max(l.toList.max)\n        var t = l.toList\n        t foreach { i =>\n            t -= 1\n            t += m.toLong\n        }\n        t.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp0x4ekc1b.scala:10:27 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = scala.math.max(l.toList.max)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double, y: Double): Double\n\u001b[31m   |\u001b[0m (x: Float, y: Float): Float\n\u001b[31m   |\u001b[0m (x: Long, y: Long): Long\n\u001b[31m   |\u001b[0m (x: Int, y: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments (Long)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0x4ekc1b.scala:13:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            t -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value -= is not a member of List[Long] - did you mean List[Long].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0x4ekc1b.scala:14:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            t += m.toLong\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659980104
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n       val l = l.toSeq\n       var ret = 0\n       var sum = 0\n       l.foreach{\n            i => \n            sum += i\n            ret = sum + i\n       }\n       val ret2 = List(ret.asInstanceOf[Long])\n       ret\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp10ku_9lv.scala:10:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m       \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = l.toSeq\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               Recursive \u001b[33mvalue\u001b[0m \u001b[35ml\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp10ku_9lv.scala:19:7 ---------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m       ret\n\u001b[31m\u001b[31m   |\u001b[0m       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m       Found:    (ret : Int)\n\u001b[31m   |\u001b[0m       Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659980103
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        val x = l.length\n        var i = 0\n        val rt = scala.collection.mutable.MutableList[Long]()\n        while (i < x) {\n            i += 1\n            rt += l.apply(i)\n        }\n        rt\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp45pw8ro5.scala:12:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrt\u001b[0m = scala.collection.mutable.MutableList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value MutableList is not a member of scala.collection.mutable\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980103
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        if(l.length == 1)\n            List(l.head + 1)\n        else {\n            var res = l\n            var i = l.head + 1\n            var tail = l\n            while (tail.length != 1) {\n                tail = tail.tail\n                i = i + 1\n            }\n            res = res :+ i\n            res\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.incrList(tmp2i3l069d.scala:14)\n\tat Problem$.main(tmp2i3l069d.scala:25)\n\tat Problem.main(tmp2i3l069d.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980104
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        var result = ListBuffer[Long]()\n        val iter = l.iterator\n        while (iter.hasNext) {\n            result += iter.next\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp9mqubfcx.scala:19)\n\tat Problem.main(tmp9mqubfcx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659980104
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        def incrByOne(l: List[Long], acc: List[Long], index: Int) : List[Long] = { \n          if (index > l.length)\n            acc\n          else { \n            incrByOne(l :+ acc.head, acc.tail, index + 1)\n          }\n        }\n        incrByOne(l, List[Long](), 0)\n      }\n}\n</code>\nThe above Scala solution does not require any mutable lists. The function incrByOne builds up a new list by combining the head of the accumulator with the current element from the list, then adds 1 to the index and so on.\n<|/ a |>\n<| a tags=scala dscore=3 |>\nHere's a more functional style solution, based on some functional programming ideas from Daniel Sobral and Christian Hauer\n<code>\ndef incrList(list: List[Long]) = {\n  def getList(l:List[Long]): List[Long] = {\n    if (l.isEmpty || l.head < 1) l\n    else getList(l.tail::List(l.head+1))\n  }\n  getList(List(1).toList)\n}\n</code>\n<|/ a |>\n<| c |>\nYes, this is really nice. But I don't understand the purpose of the `getList` function.\n<|/ c |>\n<| c |>\nWhat happens to `l` after you call `getList(l.tail::List(l.head+1))`?\n<|/ c |>\n<| c |>\n`l` remains a `List[Long]` after `l.head < 1` is false\n<|/ c |>\n<| a dscore=3 |>\nHere is another solution which I think expresses nicely what you want to do:\n<code>\ndef incrList(list: List[Long]) = {\n  val head = list.head\n  val tail = list.tail\n  val i = tail.indexWhere { _ >= head } + 1\n  new Iterator(head +: tail.take(i)) ++ incrList(tail.drop(i))\n}\n</code>\nIt works with all cases, and it may perform better than the solutions posted here (thanks for the tips by the way!).\n<|/ a tags=scala |>\n<| c |>\nI think it would be nice if it was possible to eliminate the `Iterator` in the last line by returning something like `list.take(i).reverse ++ incrList(tail.drop(i))`\n<|/ c |>\n<| a dscore=2 |>\nAnother version using recursion:\n<code>\ndef incrList(list: List[Long]): List[Long] = {\n  def loop(list: List[Long\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmp7i81sjts.scala:20:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m</code>\n\u001b[31m\u001b[31m   |\u001b[0m^^\u001b[0m\n\u001b[31m   |\u001b[0mIllegal start of toplevel definition\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmp7i81sjts.scala:33:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m</code>\n\u001b[31m\u001b[31m   |\u001b[0m^^\u001b[0m\n\u001b[31m   |\u001b[0mIllegal start of toplevel definition\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmp7i81sjts.scala:53:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m</code>\n\u001b[31m\u001b[31m   |\u001b[0m^^\u001b[0m\n\u001b[31m   |\u001b[0mIllegal start of toplevel definition\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7i81sjts.scala:64:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ']' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7i81sjts.scala:71:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7i81sjts.scala:29:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m    \u001b[33melse\u001b[0m getList(l.tail::List(l.head+\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    List[Long @uncheckedVariance]\n\u001b[31m   |\u001b[0m                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7i81sjts.scala:31:18 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m  getList(List(\u001b[31m1\u001b[0m).toList)\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Found:    List[\u001b[1m\u001b[31mInt\u001b[0m]\n\u001b[31m   |\u001b[0m          Required: List[\u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- E",
      "stdout": "",
      "timestamp": 1659980104
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return list with elements incremented by 1.\n    // >>> incrList((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 4l.toLong))\n    // >>> incrList((List[Long](5l.toLong, 3l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong)))\n    // (List[Long](6l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))\n    def incrList(l : List[Long]) : List[Long] = {\n        for (i <- 1 to l.length) {\n            l += i\n        }\n        l\n    }\n    def main(args: Array[String]) = {\n    assert(incrList((List[Long]())).equals((List[Long]())));\n    assert(incrList((List[Long](3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 3l.toLong, 2l.toLong))));\n    assert(incrList((List[Long](5l.toLong, 2l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong, 123l.toLong))).equals((List[Long](6l.toLong, 3l.toLong, 6l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 124l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2ndhet64.scala:11:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            l += i\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of List[Long] - did you mean l.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659980104
    }
  ]
}