name: HumanEval_41_car_race_collision
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Imagine a road that's a perfectly straight infinitely long line.\n    //\
  \ n cars are driving left to right;  simultaneously, a different set of n cars\n\
  \    // are driving right to left.   The two sets of cars start out being very far\
  \ from\n    // each other.  All cars move in the same speed.  Two cars are said\
  \ to collide\n    // when a car that's moving left to right hits a car that's moving\
  \ right to left.\n    // However, the cars are infinitely sturdy and strong; as\
  \ a result, they continue moving\n    // in their trajectory as if they did not\
  \ collide.\n    // This function outputs the number of such collisions.\n    def\
  \ carRaceCollision(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(carRaceCollision((2l))\
  \ == (4l));\n    assert(carRaceCollision((3l)) == (9l));\n    assert(carRaceCollision((4l))\
  \ == (16l));\n    assert(carRaceCollision((8l)) == (64l));\n    assert(carRaceCollision((10l))\
  \ == (100l));\n    }\n\n}\n"
completions: ["        val map = new mutable.HashMap[Long, mutable.ListBuffer[Long]]()\n\
    \        for (i <- 1 to n) {\n            val tempMap = map.getOrElseUpdate(i\
    \ , new mutable.ListBuffer[Long])\n            tempMap.clear()\n            tempMap\
    \ ++= map\n            val set = tempMap.filter(x => x._2 < i).map(x => x._1)\n\
    \            val set2 = tempMap.filter(x => x._2 > i).map(x => x._1)\n       \
    \     if (set.size == n && set2.size == n)\n                map.remove(i )\n \
    \       }\n        map.size", "        var collided : Long = 0\n        var speed1\
    \ : (Long,Long) = (0,0)\n        var speed2 : (Long,Long) = (0,0)\n        var\
    \ car1 : (Long,Long) = null\n        var car2 : (Long,Long) = null\n        var\
    \ car : (Long,Long) = null\n        var collided : Long = 0\n        var collided\
    \ : Long = 0\n        var collided : Long = 0\n        var collided : Long = 0\n\
    \        var collided : Long = 0\n        var collided : Long = 0\n        var\
    \ collided : Long = 0\n        var collided : Long = 0\n        var collided :\
    \ Long = 0\n        var collided : Long = 0\n        var collided : Long = 0\n\
    \        for( i <- 1 to n) {\n            car1 = (i -1,0)\n            car2 =\
    \ (i ,0)\n            speed1 = carRaceStraight( car1, car2)\n            car2\
    \ = carRaceStraight(car2,car1)\n            collided = carRaceStraight(car1,car2)\n\
    \            carRaceStraight(car1,car2)\n            collided = carRaceStraight(car1,car2)\n\
    \            collided = carRaceStraight(car1,car2)\n            collided = carRaceStraight(car1,car2)\n\
    \            collided = carRaceStraight(car1,car2)\n            collided = carRaceStraight(car1,car2)\n\
    \            collided = carRaceStraight(car1,car2)\n            collided = carRaceStraight(car1,car2)\n\
    \            collided = carRaceStraight(car1,car2)\n            collided = carRaceStraight(car1,car2)\n\
    \            collided = carRaceStraight(car1,car2)\n            collided = carRaceStraight(car1,car2)\n\
    \            collided = carRaceStraight(car1,car2)\n            collided = carRaceStraight(car1,car2)\n\
    \            collided = carRaceStraight(car1,car2)\n            collided = carRaceStraight(car1,car2)\n\
    \            collided = carRaceStraight(car1,car2)\n            collided = carRaceStraight(car1,car2)\n\
    \            collided = carRaceStraight(car1,car2)\n            collided = carRaceStraight(car1,car2)\n\
    \            collided = carRaceStraight(car1,car2)\n            collided = carRaceStraight(car1,car2)\n\
    \            collided = ", "        val r = new Random\n        val cars = mutable.Stack.empty[Long]\n\
    \        // Drive left to right\n        var car_1 = r.nextLong()\n        var\
    \ car_2 = r.nextLong()\n        while (true) {\n            cars += car_1 + \"\
    -\" + car_2\n            car_1 = car_2 * 10\n            car_2 = car_1 * 10\n\
    \            if (car_1 == car_2) {\n                // Drive right to left\n \
    \               car_1 = r.nextLong()\n                car_2 = r.nextLong()\n \
    \           }\n        }\n        cars.length", "        val roadLength = n max\
    \ 1\n        var numCollisions = 0\n        val map = mutable.LinkedHashMap()\n\
    \        val cars = List.range(0, roadLength).map(i => mutable.LinkedList())\n\
    \        roadLength times { roadPosition ++ cars }\n        val collisions = 0\
    \ until n flatMap { i => cars zipWithIndex filter { case (l, r) => l.head == r.head\
    \ } map { case (l, r) => r } }\n        collisions.foreach { c =>\n          numCollisions\
    \ += (map get c) filter (_ map c > 0) length\n          map -= c\n        }\n\
    \        numCollisions", "        // Create an array of n distinct positions.\n\
    \        // In each position, we want the car at that position to collide with\
    \ itself\n        // as if it were moving in the same direction.\n        // For\
    \ example, if the position at index i is (10,5), the car at index i will collide\n\
    \        // with itself as if it were moving at speed 10, even though the car\
    \ is moving at a\n        // speed that's infinitely strong.\n        var xPos\
    \ = 0 until n\n        var yPos = 0 until n\n        var speed = 1 until n\n \
    \       var collided = false until n\n        for (ix <- 0 until xPos.length)\n\
    \            for (iy <- 0 until yPos.length)\n                for (ispeed <- 0\
    \ until speed.length)\n                    if (ix == iy && ix == ispeed && iy\
    \ == ispeed) {\n                        // This position is already set up; don't\
    \ bother checking it again\n                        // The cars at this position\
    \ are already colliding, so they will move\n                        // past each\
    \ other and never be detected as colliding.\n                        collided(ix)\
    \ = true\n                        collided(iy) = true\n                      \
    \  collided(ispeed) = true\n                    } else {\n                   \
    \     // This is the first position set up for this combination of positions.\n\
    \                        // Set up the speed and collision flags for this position.\n\
    \                        xPos(ix) += 1\n                        yPos(iy) += 1\n\
    \                        speed(ispeed) += 1\n                        collided(ix)\
    \ = true\n                        collided(iy) = true\n                      \
    \  collided(ispeed) = true\n                    }\n        // Now that we have\
    \ made sure that each position is set up, we just need to count\n        // the\
    \ number of collisions.\n        var i = 0\n        var collisions = 0\n     \
    \   for (x <- xPos) {\n            for (y <- yPos) {\n                for (speed\
    \ <- speed) {\n                    if (collided(x) && collided(y) && collided(speed))\n\
    \                        collisions += 1\n                }\n            }\n \
    \           i += 1\n        }\n        i", "        val collides = mutable.Set[Long]()\n\
    \        val cars = mutable.ArrayBuffer.fill(n)(new Car)\n        for (i <- 0\
    \ until n) {\n            cars(i).x = cars(n - i - 1).x\n            cars(i).y\
    \ = cars(n - i - 1).y\n            cars(i).dx = cars(n - i - 1).dx\n         \
    \   cars(i).dy = cars(n - i - 1).dy\n            cars(i).speed = cars(n - i -\
    \ 1).speed\n            cars(i).direction = cars(n - i - 1).direction\n      \
    \      cars(i).collided = false\n        }\n        for (i <- 0 until n) {\n \
    \           val nextCar = cars(i + 1)\n            val collide = if (nextCar.x\
    \ < cars(i).x + cars(i).dx &&\n                nextCar.x + nextCar.dx >= cars(i).x\
    \ &&\n                nextCar.y < cars(i).y + cars(i).dy &&\n                nextCar.y\
    \ + nextCar.dy >= cars(i).y) {\n                collides += i\n              \
    \  collides += i + 1\n            }\n        }\n        collides.size", "    \
    \    val minSpeed : Double = 4.0\n        val maxSpeed : Double = 10.0\n     \
    \   val carSpeedInterval : Double = (maxSpeed - minSpeed) / (n + 1)\n        val\
    \ carXInterval : Double = (maxSpeed - minSpeed) / n\n        val collidingCarsCounts\
    \ : mutable.HashMap[Int, Int] = mutable.HashMap()\n        for (i <- 0 until n)\
    \ {\n            for (j <- i until n) {\n                if (i != j) {\n     \
    \               var speed : Double = (i + 1.0) * carSpeedInterval + j * carXInterval\n\
    \                    if (speed > maxSpeed || speed < minSpeed) {\n           \
    \             val collisionIndex : Int = math.floor((speed - minSpeed) / carSpeedInterval)\n\
    \                        val collisionIndex2 : int = math.floor((speed - minSpeed)\
    \ / carXInterval)\n                        collidingCarsCounts.put(collisionIndex,\
    \ collisionIndex2)\n                    }\n                }\n            }\n\
    \        }\n        val collidingCarsCountArray : Array[Int] = collidingCarsCounts.toArray.map(x\
    \ => x._1 + x._2)\n        return collidingCarsCountArray.count(_ == 0)", "  \
    \      val speed = 3.0\n        val carLength = n * (speed / 2.0)\n        val\
    \ carsMovingLeft = scala.collection.mutable.ArrayBuffer(1 to n).map(i => carLength\
    \ * i)\n        val carsMovingRight = scala.collection.mutable.ArrayBuffer(1 to\
    \ n).map(i => carLength * (i + 1))\n        val carsMoving = carsMovingLeft.toList\
    \ ++ carsMovingRight\n        val carsCollision = mutable.HashMap.empty[Int, Int]\n\
    \        for (car <- carsMoving) {\n            val nextCarIndex = carsMoving.indexOf(car)\n\
    \            if (carsMovingRight.contains(car)) {\n                val right =\
    \ carsMovingRight.indexOf(car) + 1\n                val left = carsMovingLeft.indexOf(car)\
    \ - 1\n                if (next != -1) {\n                    carsCollision.put(car,\
    \ if (left < right && carsCollision.get(car) != -1 || left > right && carsCollision.get(car)\
    \ != 1) -1 else carsCollision.get(car))\n                }\n            }\n  \
    \          if (carsMovingLeft.contains(car)) {\n                val right = carsMovingRight.indexOf(car)\
    \ - 1\n                val left = carsMovingLeft.indexOf(car) + 1\n          \
    \      if (next != -1) {\n                    carsCollision.put(car, if (left\
    \ < right && carsCollision.get(car) != -1 || left > right && carsCollision.get(car)\
    \ != 1) -1 else carsCollision.get(car))\n                }\n            }\n  \
    \      }\n        carsCollision.size + 1", "        val roadLength = n*n*n\n \
    \       val distances = mutable.ArrayBuffer.fill(n) { 0 }\n        val roadDistances\
    \ = mutable.ArrayBuffer.fill(n) { roadLength }\n        val currentPosition =\
    \ mutable.ArrayBuffer.fill(n) { 0 }\n        val previousPosition = mutable.ArrayBuffer.fill(n)\
    \ { 0 }\n        val collisions = mutable.ArrayBuffer.fill(n) { 0 }\n\n      \
    \  var c = 0\n        while (c < n){\n            distances(c) = (c*c*c*c + 4*c*c\
    \ + 2*c + 1)\n            roadDistances(c) = (c*c*c*c + 4*c*c + 2*c + 1)\n   \
    \         currentPosition(c) = c*c*c*c*c*c*c\n            previousPosition(c)\
    \ = c*c*c*c*c*c*c\n            c += 1\n        }\n\n        // A collision is\
    \ defined as: two cars collide when\n        // 1) one car is moving left to right\
    \ and \n        // 2) the other car is moving right to left.\n        // The cars\
    \ moving left to right collide with the cars moving right to left if\n       \
    \ // 1) their positions are less than one apart AND\n        // 2) if there exists\
    \ an integer m such that 0 <= m <= n such that\n        //    a) there exists\
    \ at least one integer n such that 0 <= n < m AND\n        //    b) the car's\
    \ position at the nth moment in time is at least (m-1)*n^2 + 1\n        c += 1\n\
    \        while (c < n){\n            // Left car is moving left to right\n   \
    \         val leftCollision = currentPosition(c) - previousPosition(c)\n     \
    \       // Right car is moving right to left\n            val rightCollision =\
    \ roadDistances(c) - distances(c)\n            val m = (c + 1) until (c > n)\n\
    \            val nextCollision = roadDistances(c) - distances(c)\n\n         \
    \   // if positions are less than one apart\n            if (leftCollision <=\
    \ 1 &&  rightCollision <= 1 && nextCollision >= 0){\n                // collision\n\
    \                c += 1\n                collisions(c) += 1\n            }\n \
    \           c += 1\n        }\n        collisions(n)", "        val road = List(0)\n\
    \        val xs = Vector.fill(n - 1)(-1L)\n        val ys = Vector.fill(n - 1)(-1L)\n\
    \        var isLeft = true\n        var collisions = 0\n        for (j <- (0 until\
    \ n)) {\n            var x = xs(j) % n\n            var y = ys(j) % n\n      \
    \      var count = 0\n            while (x < j) {\n                if (isLeft)\
    \ {\n                    x = xs(x)\n                    y = (ys(y) + ys(ys(y)\
    \ + ys(y) + ys(y) + ys(y) + ys(y)))\n                    xs = xs.updated(x, (xs(x)\
    \ + 1))\n                } else {\n                    x = xs(x)\n           \
    \         y = (ys(y) - ys(ys(y) - ys(y)))\n                    xs = xs.updated(x,\
    \ (xs(x) - 1))\n                }\n                count += 1\n            }\n\
    \            if (x == j) continue\n            var c = 0\n            while (y\
    \ < j) {\n                if (isLeft) {\n                    y = ys(y)\n     \
    \               x = (xs(x) + xs(xs(x) + xs(x) + xs(x) + xs(x) + xs(x)))\n    \
    \                ys = ys.updated(y, (ys(y) + 1))\n                } else {\n \
    \                   y = ys(y)\n                    x = (xs(x) - xs(xs(x) - xs(x)))\n\
    \                    ys = ys.updated(y, (ys(y) - 1))\n                }\n    \
    \            c += 1\n            }\n            if (y == j) continue\n       \
    \     if (xs(j) != 0) {\n                if (ys(j) != 0) {\n                 \
    \   xs = xs.updated(x, (xs(x) + xs(x) + xs(x) + xs(x) + xs(x)))\n            \
    \        ys = ys.updated(y, (ys(y) - ys(y) + ys(y) - ys(y) + ys(y)))\n       \
    \         } else {\n                    xs = xs.updated(x, (xs(x) - xs(x) - xs(x)\
    \ - xs(x) + xs(x)))\n                    ys = ys.updated(y, (ys(y) + ys(y) + ys(y)\
    \ - ys(y) - ys(y)))\n                }\n            } else {\n               \
    \ if (ys(j) != 0) {\n                    xs = xs.updated(x, (xs(x) - xs(x) - xs(x)\
    \ - xs(x) + xs(x)))\n                    ys = ys.updated(y, (ys(y) + ys(y) + ys(y)\
    \ - ys(y) - ys(y)))\n                } else {\n                    xs = xs.updated(x,\
    \ (xs(x) - xs(x) - ", "        // The set of all possible collisions\n       \
    \ // This set has 2^(n-1) entries, where n = number of cars in the line\n    \
    \    val possibleCollisions = mutable.Set.empty[Long]\n        // The set of collisions\
    \ encountered\n        // This set has 2^(n-1) entries, where n = number of cars\
    \ in the line\n        val collisions = mutable.Set.empty[Long]\n        // The\
    \ set of cars that are colliding with cars at indices 0 to 2^(n-1)-1\n       \
    \ val collidingWith = mutable.Set.empty[Long]\n        // The set of indices where\
    \ a car collides with itself\n        // This set has 2^(n-1) entries, where n\
    \ = number of cars in the line\n        val collidingWithIndex = mutable.Set.empty[Long]\n\
    \        // The total number of collisions encountered\n        val collisionsEncountered\
    \ = 0\n        // The total number of collisions encountered\n        val collisionsEncountered\
    \ = 0\n        // The cars that collided with the cars at indices 0 to 2^(n-1)-1\n\
    \        val collidingWithCars = mutable.Set.empty[Long]\n        // The first\
    \ car that collides with cars at indices 0 to 2^(n-1)-1\n        val collidingWithCarIndex\
    \ = mutable.Set.empty[Long]\n        // The previous car that collides with cars\
    \ at indices 0 to 2^(n-1)-1\n        val collidingWithCarIndex = mutable.Set.empty[Long]\n\
    \        // The distance between the current and previous cars\n        val collidingWithCarIndex\
    \ = mutable.Set.empty[Long]\n        // The previous car that collides with cars\
    \ at indices 0 to 2^(n-1)-1\n        val collidingWithCarIndex = mutable.Set.empty[Long]\n\
    \        // The previous car that collides with cars at indices 0 to 2^(n-1)-1\n\
    \        val collidingWithCarIndex = mutable.Set.empty[Long]\n        // The previous\
    \ car that collides with cars at indices 0 to 2^(n-1)-1\n        val collidingWithCarIndex\
    \ = mutable.Set.empty[Long]\n        // The previous car that collides with cars\
    \ at indices 0 to 2^(n-1)-1\n        val collidingWithCarIndex = mutable.Set.empty[Long]\n\
    \        // The previous car that collides with cars at indices 0 to 2^(n-1)-1\n\
    \        val collidingWithCarIndex = mutable.Set.empty[Long]\n        // The previous\
    \ car that collides with cars at indices 0 to 2^(n-1)-1\n        val collidingWithCarIndex\
    \ = mutable.Set.empty[Long]\n        // The previous car that collides with cars\
    \ at ", "        def isLeftToRight(x1 : (Int, Int), x2 : (Int, Int)) = x1(0) >\
    \ x2(0) || (x1(0) == x2(0) && (x1(1) > x2(1)));\n        def isRightToLeft(x1\
    \ : (Int, Int), x2 : (Int, Int)) = x1(0) > x2(0) || (x1(0) == x2(0) && (x1(1)\
    \ < x2(1)));\n\n        // Now we set up the matrix of distances between the cars\n\
    \        var matrix = new Array[Array[Int]](n){\n            new Array[Int](n)\n\
    \        };\n        for (i <- 0 until n) {\n            for (j <- 0 until n)\
    \ {\n                matrix(i) = new Array[Int](n);\n                matrix(j)\
    \ = new Array[Int](n);\n            }\n        }\n        // Now we populate the\
    \ distance matrix.\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ n) {\n                // Only check collisions where cars are within one straight\
    \ segment\n                if (i == j)\n                    matrix(i)(j) = 0\n\
    \                else if (isLeftToRight(i -> j, j -> i + 1)) {\n             \
    \       matrix(i) = (matrix(i)) + 1;\n                    matrix(j) = (matrix(j))\
    \ + 1;\n                } else if (isRightToLeft(i -> j, j -> i + 1)) {\n    \
    \                matrix(i) = (matrix(i)) + 1;\n                    matrix(j) =\
    \ (matrix(j)) + 1;\n                } else {\n                    matrix(i) =\
    \ (matrix(i)) + 1;\n                    matrix(j) = (matrix(j)) + 1;\n       \
    \         }\n            }\n        }\n        // Now we need to sum the diagonal\
    \ values which is the sum of cars with\n        // the same coordinates.\n   \
    \     var sum = 0L\n        for (i <- 0 until n) {\n            sum = sum + matrix(i)(i)\n\
    \        }\n        // Now we need to find the two cars with the largest sum\n\
    \        var max = 0L\n        var maxSum = 0L\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until n) {\n                if ((matrix(i)(j)) > (maxSum))\
    \ {\n                    maxSum = matrix(i)(i)\n                    max = i\n\
    \                    maxSum = matrix(i)(i)\n                } else if (maxSum\
    \ == matrix(i)(i)) {\n                    maxSum = matrix(i)(i)\n            \
    \        max = i\n                }\n            }\n        }\n        // Finally\
    \ we can check if there are any collisions between the two cars\n        var collisions\
    \ = 0L\n        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n \
    \               if (matrix(i)(i) == matrix(j)(j)) {\n                    collisions\
    \ = collisions + 1\n                }\n            }\n        }\n        return\
    \ collisions", "      var i : Long = 1\n      var collision : Long = 0\n     \
    \ val track = Vector.tabulate(n + 1)(i => i)\n      while (i < track.size) {\n\
    \          val track2 = track.slice(i+1, track.size)\n          val track3 = track.slice(i-1,\
    \ track.size)\n          val track4 = track.slice(0, i)\n          val track5\
    \ = track.slice(i, track.size)\n          val track6 = track.slice(i+1, track.size)\n\
    \          val track7 = track.slice(i-1, track.size)\n          val track8 = track.slice(0,\
    \ i)\n          val track9 = track.slice(i+1, track.size)\n          val track10\
    \ = track.slice(i-1, track.size)\n          val track11 = track.slice(0, i)\n\
    \          val track12 = track.slice(i+1, track.size)\n          val track13 =\
    \ track.slice(i-1, track.size)\n          val track14 = track.slice(0, i)\n  \
    \        val track15 = track.slice(i, track.size)\n          val track16 = track.slice(i+1,\
    \ track.size)\n          val track17 = track.slice(i-1, track.size)\n        \
    \  val track18 = track.slice(0, i)\n          val track19 = track.slice(i, track.size)\n\
    \          val track20 = track.slice(i+1, track.size)\n          val track21 =\
    \ track.slice(i-1, track.size)\n          val track22 = track.slice(0, i)\n  \
    \        val track23 = track.slice(i, track.size)\n          val track24 = track.slice(i+1,\
    \ track.size)\n          val track25 = track.slice(i-1, track.size)\n        \
    \  val track26 = track.slice(0, i)\n          val track27 = track.slice(i, track.size)\n\
    \          val track28 = track.slice(i+1, track.size)\n          val track29 =\
    \ track.slice(i-1, track.size)\n          val track30 = track.slice(0, i)\n  \
    \        val track31 = track.slice(i, track.size)\n          val track32 = track.slice(i+1,\
    \ track.size)\n          val track33 = track.slice(i-1, track.size)\n        \
    \  val track34 = track.slice(0, i)\n          val track35 = track.slice(i, track.size)\n\
    \          val track36 = track.slice(i+1, track.size)\n          val track37 =\
    \ track.slice(i-1, track.size)\n          val track38 = track.slice(0, i)\n  \
    \        val track39 = track.slice(i, track.size)\n          val track40 = track.slice(i+1,\
    \ track.size)\n          val track41 = track.slice(i-1, track.size)\n        \
    \  val track42 = track.slice(0, i)\n          val track43 = track.slice(i, track.size)\n\
    \          val track44 = track.slice(i+1, track.size)\n          val track45 =\
    \ track.slice(i-1, track.size)\n          val track", "      def calcCollisions(n:\
    \ Long) : Int = {\n        if (n==0) 0\n        else if (n==1) 1\n        else\
    \ {\n          val minLeft = min(n/2, n-1)\n          val minRight = min(n/2,\
    \ n-2)\n          if (minLeft > minRight) calcCollisions(minLeft) + calcCollisions(minRight)\n\
    \          else calcCollisions(minRight) + calcCollisions(minLeft)\n        }\n\
    \      }\n\n      calcCollisions(n-1)", "        val collisions = mutable.ArrayBuffer.empty[Long]\n\
    \        val speed = mutable.ArrayBuffer.fill(n.toInt)(0)\n        val speeds\
    \ = mutable.ArrayBuffer.fill(n.toInt)(0)\n        val maxSpeed = scala.math.eulerangles.parabola(0.0,\
    \ 1.0, 0.0)._2\n        val minSpeed = scala.math.eulerangles.parabola(-1.0, 1.0,\
    \ 0.0)._2\n        var collide = 0\n        for (i <- 0 until n) {\n         \
    \   speed(i) = i / 1000\n            speeds(i) = (i - 1) / 1000\n            val\
    \ collisions = mutable.ArrayBuffer.empty[Long]\n            val maxSpeed = scala.math.eulerangles.parabola(0.0,\
    \ 1.0, 0.0)._2\n            val minSpeed = scala.math.eulerangles.parabola(-1.0,\
    \ 1.0, 0.0)._2\n            var collide = 0\n            var speedSum = speedSum\n\
    \            var speedSumOfSqr = speedSumOfSqr\n            var collision = 0\n\
    \            while (collide != 2) {\n                collide = 0\n           \
    \     collision = 0\n                var speedSum = speedSum\n               \
    \ var speedSumOfSqr = speedSumOfSqr\n                for (j <- 0 until n) {\n\
    \                    val speed = i / 1000 + speeds(j)\n                    val\
    \ speedSqr = (j - 1) / 1000 + speeds(j - 1)\n                    var collide =\
    \ 0\n                    var speedSum = speedSum\n                    var speedSumOfSqr\
    \ = speedSumOfSqr\n                    val collision = mutable.ArrayBuffer.empty[Long]\n\
    \                    val maxSpeed = scala.math.eulerangles.parabola(0.0, 1.0,\
    \ 0.0)._2\n                    val minSpeed = scala.math.eulerangles.parabola(-1.0,\
    \ 1.0, 0.0)._2\n                    var collide = 0\n                    var speedSum\
    \ = speedSum\n                    var speedSumOfSqr = (speedSqr + speedSqr) /\
    \ 2\n                    for (k <- 0 until n) {\n                        if (k\
    \ != j) {\n                            val speed = (i + k) / 1000 + speeds(k)\n\
    \                            val speedSqr = (j + k) / 1000 + speeds(j + k)\n \
    \                           if (\n                                    speedSqr\
    \ < (speedSumOfSqr + speedSumOfSqr) / 2\n                                    &&\
    \ speedSqr >= (speedSum + speedSum) / 2\n                            ) {\n   \
    \                             collision +=1\n                            }\n \
    \                       }\n                    }\n                    if (collide\
    \ == 2) {\n                        collisions +=1\n                    }\n   \
    \                 if (\n                            speedSumOfSqr > speedSum\n\
    \                            && speedSum > speedSumOf", "        // Scoring algorithm\
    \ for number of collisions.\n        // Each car has a position vector v, and\
    \ an angle alpha.\n        // Each car gets added to a list; initially empty.\n\
    \        // To detect a collision, for each car in each list.\n        // For\
    \ each other car in the list, if the other car's angle is smaller than\n     \
    \   // the alpha-th angle of the car, then the cars collide.\n        // Add all\
    \ the cars in the list together to detect collisions.\n        var collisions\
    \ = 0\n        var a = 0.0\n        var x = 0.0\n        var y = 0.0\n       \
    \ var v = Vector.zero\n        for(i <- 1 to n) {\n            v = Vector(100.0,\
    \ 100.0)\n            a = i * Math.PI / n\n            for(j <- i to n) {\n  \
    \              if (i != j) {\n                    x = Math.cos(a) * j\n      \
    \              y = Math.sin(a) * j\n                    v += Vector(x, y)\n  \
    \              }\n            }\n            collisions += 1\n        }\n    \
    \    collisions", "        val ls = ListBuffer[Long]()\n        val r = math.min(n,1000)\n\
    \        for (i <- 1 to r) {\n            var isRight = true\n            val\
    \ l = i\n            while (l > 1) {\n                val s = i-l\n          \
    \      if ((s % 2) == 0) {\n                    isRight = !isRight\n         \
    \       }\n                l -= 1\n            }\n            val k = math.min(i,r)\n\
    \            val j = math.min(k,n)\n            while (j > 1) {\n            \
    \    val m = j-k\n                if ((m % 2) == 0) {\n                    isRight\
    \ = !isRight\n                }\n                j -= 1\n            }\n     \
    \       if (isRight) ls += i\n        }\n        ls.sum", "        var sum = 0L;\n\
    \        var distance = 0;\n        for(i <- 0 until n) {\n            for(j <-\
    \ 0 until n) {\n                var x0 = i * 200L;\n                var y0 = j\
    \ * 200L;\n                var x1 = (i + 1) * 200L;\n                var y1 =\
    \ (j + 1) * 200L;\n                var x2 = (i + 1) * 200L;\n                var\
    \ y2 = (j + 1) * 200L;\n                var d0 = Math.sqrt(Math.pow(x0 - x1, 2)\
    \ + Math.pow(y0 - y1, 2));\n                var d1 = Math.sqrt(Math.pow(x2 - x1,\
    \ 2) + Math.pow(y2 - y1, 2));\n                var speed = (d0 / d1) * (x0 - x1)\
    \ * (y0 - y1) * (x0 - x1) * (y0 - y1);\n                distance += speed;\n \
    \               sum += speed;\n            }\n        }\n        sum / distance;",
  "        var coll = n\n        var i = 0\n        while(i < n) {\n            val\
    \ leftCar = i + 1\n            val rightCar = n - 1\n            if(leftCar <\
    \ n && rightCar > i) {\n                val x1 = getDistance(leftCar, rightCar)\n\
    \                val y1 = getY(leftCar, rightCar)\n                val x2 = getDistance(leftCar,\
    \ leftCar)\n                val y2 = getY(leftCar, leftCar)\n                val\
    \ x3 = getDistance(rightCar, rightCar)\n                val y3 = getY(rightCar,\
    \ rightCar)\n                if(abs(x2 - x1) < 1e-6 && abs(y2 - y1) < 1e-6 &&\n\
    \                    abs(x3 - x3) < 1e-6 && abs(y3 - y3) < 1e-6) {\n         \
    \           coll -= 1\n                }\n            }\n            i += 1\n\
    \        }\n        coll", "        def collide(car : Long, otherCar : Long) :\
    \ Long = {\n            var collisionCount : Long = 0\n            var currentCar\
    \ : Long = 0\n            while (currentCar < n) {\n                if (car ==\
    \ otherCar) {\n                    collisionCount += 1\n                }\n  \
    \              else {\n                    currentCar += 1\n                }\n\
    \            }\n            collisionCount\n        }\n        val collisionCount\
    \ : Long = math.ceil(math.sqrt((n * (n + 1))) / 2) * 2\n        var currentCar\
    \ : Long = 0\n        while (currentCar < n) {\n            var leftCar = currentCar\n\
    \            currentCar += 1\n            var rightCar = currentCar\n        \
    \    currentCar += 1\n            var collidedLeft = collide(leftCar, rightCar)\n\
    \            var collidedRight = collide(rightCar, leftCar)\n            if (collidedLeft\
    \ == collidedRight) {\n                collisionCount += 2\n            }\n  \
    \      }\n        collisionCount", "        // Straightforward approach\n    \
    \    val start = scala.util.Random\n        val x = scala.util.Random\n      \
    \  val y0 = start.nextInt(n-x)\n        val y1 = start.nextInt(n-x)\n        var\
    \ collisions = 0\n        while (collisions < n){\n            if (x==0 || y==0\
    \ || x==n-1 || y==n-1) return collisions\n            val y  = y0 + (y1-y0)/2\n\
    \            if (x==y) collisions++ else y0 = y1\n        }\n        collisions",
  "        // The first n numbers are pairs of integers (x,y) that are guaranteed\
    \ to collide.\n        var xs : List[Int] = List(0).take(n).map(_+1).map(i =>\
    \ i * i).toList\n        var ys : List[Int] = List(0).take(n).map(_+1).map(i =>\
    \ i * i).toList\n\n        // At least one pair of (x,y) must collide.\n     \
    \   // It suffices to assume that x is always less than or equal to y.\n     \
    \   // But there are n pairs of (x,y).  We have to test each pair.\n        var\
    \ collide = 0L\n        xs.zipWithIndex.foreach { case (x, i) =>\n           \
    \ // Move the cars x positions apart.\n            ys = ys.drop(1).concat(List(x.toInt)).take(n).toList\n\
    \            // Test all pairs of (x,y).\n            ys.zipWithIndex.foreach\
    \ { case (y, j) =>\n                // If the cars collide, increment the count\
    \ and stop testing the other pairs.\n                if (x == y) {\n         \
    \           collide = collide + 1L\n                    return\n             \
    \   }\n            }\n        }\n        collide", "        // Use an ArrayBuffer\
    \ to store each car's position.\n        val x = ArrayBuffer[Int]()\n        val\
    \ y = ArrayBuffer[Int]()\n        val collisions = ArrayBuffer[Int]()\n      \
    \  // Set initial values\n        for(i <- 1 to n){\n            x.append(i)\n\
    \            y.append(i)\n            collisions.append(0)\n        }\n      \
    \  // Do collision detection\n        for(i <- 1 to n){\n            val j = n\
    \ - i\n            for(k <- 1 to n){\n                val collision = if((x(i)\
    \ == x(j)) && (y(i) == y(k)))\n                    collisions(k) += 1\n      \
    \      }\n        }\n        // Output the number of collisions\n        collisions.sum",
  '        // Write your solution here', "        var count = 0\n        for(i <-\
    \ 0 until n) {\n            for(j <- 0 until n) {\n                if(i != j)\
    \ {\n                    val xDiff = math.abs(carTravel(i,j))\n              \
    \      val yDiff = math.abs(carTravel(i,n) - (carTravel(j,n)))\n             \
    \       val zDiff = math.abs(carTravel(n,j) - (carTravel(n,i)))\n            \
    \        if(xDiff > yDiff && xDiff > zDiff) {\n                        count +=\
    \ 1;\n                    }\n                }\n            }\n        }\n   \
    \     count", "        var collisions : Long = 0\n        var carPos : Array[Int]\
    \ = new Array(n)\n        var speeds : Array[Int] = new Array(n)\n        var\
    \ collisionPos : Array[Int] = new Array(n)\n        carPos(0) = 200\n        speeds(0)\
    \ = 50\n        collisionPos(0) = 0\n        for(i <- 1 to n) {\n            carPos(i)\
    \ = 200\n            speeds(i) = 50\n            collisionPos(i) = 0\n       \
    \ }\n        val h = (100/n)\n        val m = 10\n        var k = 0\n        for(i<-\
    \ 1 to n-1) {\n            for(j <- 1 to i-1) {\n                val h1 = (h +\
    \ h*h + m*h*h)/h\n                val h2 = (h + h*h + m*h*h)/h\n             \
    \   val d = sqrt(h1*(h1+h2*2)) + sqrt(h2*(h1+h2*2))\n                val e = (h1\
    \ + h2)/2\n                val a = e * e\n                val f = e + a\n    \
    \            val g = e - a\n                val x = -a/e\n                val\
    \ y = -f/e\n                val z = -g/e\n                val v1 = x*speeds(i-1)\
    \ + y*speeds(i) + z*speeds(i+1)\n                val v2 = x*speeds(j-1) + y*speeds(j)\
    \ + z*speeds(j+1)\n                val u = (h1 + h2)/2\n                val a\
    \ = u * u\n                val f = u + a\n                val g = u - a\n    \
    \            val x = -a/u\n                val y = -f/u\n                val z\
    \ = -g/u\n                val v3 = x*speeds(i-1) + y*speeds(i) + z*speeds(i+1)\n\
    \                val v4 = x*speeds(j-1) + y*speeds(j) + z*speeds(j+1)\n      \
    \          val w = (h1 + h2)*h*h/6\n                val x1 = v1-w\n          \
    \      val x2 = v2-w\n                val x3 = v3-w\n                val x4 =\
    \ v4-w\n                val y1 = x1\n                val y2 = x2\n           \
    \     val y3 = x3\n                val y4 = x4\n                val d1 = abs(x1\
    \ - x2)\n                val d2 = abs(x3 - x4)\n                val d3 = abs(y1\
    \ - y2)\n                val d4 = abs(y3 - y4)\n                val u1 = (sqrt(x1*x1\
    \ + y1*y1 + z1*z1)+sqrt(x2*x2 + y2*y2 + z2*z2))/2 + sqrt(x3*x3 + ", "        val\
    \ m = scala.math.pow(2, n)\n        val s = scala.math.pow(2,n-1)\n        var\
    \ collided = Long.MinValue\n        for (i <- 0 until m)\n            for (j <-\
    \ 0 until s)\n                if (scala.math.pow(i, j) > scala.math.pow(m, j))\
    \ collided = i + j\n        collided", "        val numCollisions = 0\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until n) {\n              \
    \  val leftDist = i * 4 + j * 4\n                val rightDist = i * 4 + j * 4\
    \ + 4\n                if (i < j) {\n                    val leftSpeed = (i -\
    \ j) * 4\n                    val rightSpeed = (i - j) * 4 + 4\n             \
    \       val xDiff = if (leftSpeed > rightSpeed) leftDist else rightDist\n    \
    \                val yDiff = if (leftSpeed > rightSpeed) leftDist else rightDist\n\
    \                    val xSpeed = if (leftSpeed > rightSpeed) leftSpeed else rightSpeed\n\
    \                    val ySpeed = if (leftSpeed > rightSpeed) leftSpeed else rightSpeed\n\
    \                    val collision = (i * 4 + j * 4) * 4\n                   \
    \ if (ySpeed < rightSpeed) numCollisions += 1\n                }\n           \
    \ }\n        }\n        numCollisions", "        val a = Array[Int]((1,1),(1,-1),(-1,1),(-1,-1))\n\
    \        val x = Array.fill(3*n)(0)\n        val y = Array.fill(3*n)(0)\n    \
    \    val z = Array.fill(3*n)(0)\n        val w = Array.fill(3*n)(0)\n        val\
    \ collides = List.fill(3*n)(false)\n        val start = System.currentTimeMillis()\n\
    \        val end = start + 1000\n        for (i <- 1 to n) {\n            val\
    \ now = System.currentTimeMillis()\n            val car = i % 2 == 0 match {\n\
    \                case true => carRace(0, i, a, b, x, y, z, w, collides, now, start,\
    \ end)\n                case false => carRace(0, i, a, b, x, y, z, w, collides,\
    \ now, start, end)\n            }\n        }\n        val result = collides.sum\n\
    \        result", "        // Initialize a table of which cars collide.\n    \
    \    val cars = mutable.ListBuffer[Car]()\n\n        // Define a Car that does\
    \ not collide.\n        class Car()\n        // Define the rules of the road.\n\
    \        class Rules(cars : Seq[Car], carsRemaining : Seq[Car]) {\n          \
    \  def isColliding(car : Car) : Boolean = cars.contains(car) && carsRemaining.contains(car)\n\
    \        }\n        // Define a function to move one car left or right.\n    \
    \    def moveToNextCar(car : Car, direction : Direction) : Unit = {\n        \
    \    // Move the car to the next position based on the given direction.\n    \
    \        car.move(direction)\n            // If the car collided, add it to the\
    \ cars table.\n            if(isColliding(car)) {\n                cars.append(car)\n\
    \            }\n            // Otherwise move to the next car from the remaining\
    \ cars list.\n            else {\n                carsRemaining.remove(nextCar)\n\
    \            }\n        }\n        // Define a function to move one car forward.\n\
    \        def moveOneCarForward(car : Car, direction : Direction) : Unit = {\n\
    \            // Move the car to the next position based on the given direction.\n\
    \            car.move(direction)\n            // Move to the next car.\n     \
    \       moveToNextCar(car, Direction.forward)\n        }\n        // Define a\
    \ function to move one car backwards.\n        def moveOneCarBackward(car : Car,\
    \ direction : Direction) : Unit = {\n            // Move the car to the next position\
    \ based on the given direction.\n            car.move(direction)\n           \
    \ // Move to the next car.\n            moveToNextCar(car, Direction.backward)\n\
    \        }\n        // Initialize the rules of the road.\n        val rules =\
    \ Rules(cars, cars)\n\n        // Move the first car forward.\n        moveOneCarForward(cars(0),\
    \ Direction.forward)\n\n        // Start the loop to keep moving cars forward\
    \ until the cars collide.\n        val collisionCount = 0\n        while(rules.isColliding(cars(0)))\
    \ {\n            // Move the car forward.\n            moveOneCarForward(cars(0),\
    \ Direction.forward)\n            collisionCount += 1\n        }\n        // Return\
    \ the number of collisions.\n        collisionCount", "        // Initialize a\
    \ two dimensional array containing all possible pairs of integers\n        //\
    \ of length n.  Each cell of this array will contain an array of integers which\n\
    \        // will serve as our collision sets.  If the pair [i,j] contains n elements,\
    \ then\n        // the i-th element of the collision set array will be equal to\
    \ the j-th element\n        // of the collision set array.\n        // Initialize\
    \ all elements to empty lists.\n        val collisionSets = mutable.ArraySeq[mutable.ArrayList[Long]]()\n\
    \        for (i <- 1 to n){\n            val collisionSet = mutable.ArrayList[Long]()\n\
    \            collisionSets += collisionSet\n            for (j <- 1 to n){\n \
    \               if (i != j){\n                    val collision = mutable.ArrayList[Long]()\n\
    \                    collisionSet += collision\n                    collision\
    \ += i\n                    collision += j\n                }\n            }\n\
    \        }\n        \n        // Now we iterate through each row and column of\
    \ the collision sets and \n        // calculate how often there can be collisions\
    \ given the constraints that all\n        // cars must travel in the same direction.\n\
    \        var collisionCount = 0\n        for (i <- 1 to n){\n            for (j\
    \ <- 1 to n){\n                val collisionSet = collisionSets(i-1) + collisionSets(j-1)\n\
    \                if (collisionSet.size == n){\n                    collisionCount\
    \ += 1\n                }\n            }\n        }\n        \n        // Now\
    \ we return the number of collisions\n        collisionCount", "        if (n\
    \ == 1) 1\n        else {\n            var count = 0\n            // Find a pair\
    \ of cars to test\n            val startCar = scala.util.Random\n            \
    \    .nextInt(n) + 1\n            val endCar = scala.util.Random\n           \
    \     .nextInt(n) + 1\n            // Test each pair of cars\n            while\
    \ (startCar != endCar) {\n                // Determine distance from start to\
    \ end cars\n                val startDistance = scala.util.Random\n          \
    \          .nextInt(n) * scala.util.Random.nextDouble()\n                val endDistance\
    \ = scala.util.Random\n                    .nextInt(n) * scala.util.Random.nextDouble()\n\
    \                // Only test for collision if one car has reached its destination\n\
    \                if (startDistance <= startCar && endDistance <= endCar) {\n \
    \                   // If neither car has reached destination, move them a bit\n\
    \                    if (startDistance < endDistance)\n                      \
    \  startCar += scala.util.Random.nextInt(n) + 1\n                    else\n  \
    \                      endCar += scala.util.Random.nextInt(n) + 1\n          \
    \          // And test again\n                    continue\n                }\n\
    \                count += 1\n                // Move both cars so they don't collide\n\
    \                if (startCar < endCar) {\n                    startCar += scala.util.Random.nextInt(n)\
    \ + 1\n                    endCar += scala.util.Random.nextInt(n) + 1\n      \
    \          } else {\n                    startCar += scala.util.Random.nextInt(n)\
    \ + 1\n                    endCar += scala.util.Random.nextInt(n) + 1\n      \
    \          }\n            }\n            // Return number of collisions\n    \
    \        count\n        }", "        val l = n / 2\n        val r = n - l\n  \
    \      val set = mutable.HashSet[Long]()\n        val start = -1\n        val\
    \ end = -1\n        var i : Long = 0\n        while (i < n) {\n            i +=\
    \ 1\n            var j : Long = 0\n            var collision : Long = 0\n    \
    \        while (j < n) {\n                j += 1\n                val dist = (i\
    \ + j) / 2\n                if (dist == 1) continue\n                if (dist\
    \ < 2) continue\n                if (j == l) collision += 1\n                else\
    \ if (j == r) collision += 1\n                else if (i == start) collision +=\
    \ 1\n                else if (i == end) collision += 1\n                else if\
    \ (!set.add(i) && set.add(j)) collision += 1\n                else collision +=\
    \ 1\n            }\n            val temp1 = (start + end) / 2\n            val\
    \ temp2 = set.size\n            while (temp2 < n) {\n                temp2 +=\
    \ 1\n                val temp = (start + end) / 2\n                if (temp ==\
    \ temp1) collision += 1\n                else if (temp == temp2) collision +=\
    \ 1\n                else collision += 1\n            }\n            start = end\n\
    \            end = temp1\n            if (collision == 2) set.add(l)\n       \
    \     else if (collision == 3) set.add(l)\n            else if (collision == l)\
    \ set.add(l)\n            else set.add(l)\n        }\n        set.size", "   \
    \     def f(x: Long, y: Long, nextX: Long, nextY: Long) : Long = {\n         \
    \   val xd = nextX - x\n            val yd = nextY - y\n            return if\
    \ (xd > 0) xd else -yd\n        }\n        val xs = List(-10000L, 10000L)\n  \
    \      val ys = List(-10000L, 10000L)\n        val y0 = 100\n        val y0 =\
    \ 100\n        val y0 = 100\n        val x0 = 200\n        val x0 = 200\n    \
    \    val x0 = 200\n        val x0 = 200\n        val x0 = 200\n        val y0\
    \ = 100\n        val xs = xs.zipWithIndex.map {\n            case ((x, y), index)\
    \ => y + f(x, y, x + xs(index), y + ys(index))\n        }\n        val ys = ys.zipWithIndex.map\
    \ {\n            case ((x, y), index) => x + f(x, y, x + xs(index), y + ys(index))\n\
    \        }\n        var sum = 0L\n        for (i <- 0 until n) {\n           \
    \ val ix = i + x0\n            val iy = i + y0\n            val x = xs(i)\n  \
    \          val y = ys(i)\n            val xx = x + xs(n - 1 - i)\n           \
    \ val yy = y + ys(n - 1 - i)\n            val nextX = if (ix < (n - 1)) xx + xs(ix)\
    \ else xx\n            val nextY = if (iy < (n - 1)) yy + ys(iy) else yy\n   \
    \         val next = nextX + nextY\n            if (next >= 0) {\n           \
    \     sum += (n - 1) * n - 1\n            }\n        }\n        sum", "      \
    \  val road = scala.collection.mutable.ArrayBuffer.fill(Long.MaxValue, n + 1)\n\
    \        road(0) = 0\n        road(n + 1) = 1\n\n        // A function that determines\
    \ whether two cars collide.\n        def collide(left: Long, right: Long) : Boolean\
    \ = {\n            val leftDist = road(left)\n            val rightDist = road(right)\n\
    \            leftDist == rightDist || (leftDist > 0 && rightDist > 0 && leftDist\
    \ < rightDist)\n        }\n\n        val start = road(0)\n        val end = road(n\
    \ + 1)\n        var collided = false\n        for (i <- start until end) {\n \
    \           if (!collided && collide(start, i)) {\n                collided =\
    \ true\n                road(i) = i\n            }\n            if (!collided\
    \ && collide(i, end)) {\n                collided = true\n                road(i)\
    \ = i\n            }\n        }\n        road", "      val start = math.random\n\
    \      val end = math.random\n      val collisions = mutable.ArrayBuffer.empty[Long]\n\
    \      var i = 0\n      var j = n\n      while (i <= n && j <= n) {\n        val\
    \ x = start + math.scalaMath.cos(i * 2 * math.Pi) / 2 + 0.5\n        val y = start\
    \ + math.scalaMath.sin(i * 2 * math.Pi) / 2 + 0.5\n        val x2 = start + math.scalaMath.cos(j\
    \ * 2 * math.Pi) / 2 + 0.5\n        val y2 = start + math.scalaMath.sin(j * 2\
    \ * math.Pi) / 2 + 0.5\n        val dist = math.sqrt(math.pow(x2 - x, 2) + math.pow(y2\
    \ - y, 2))\n        if (dist <= 1.0) {\n          val collision = math.max(x2\
    \ - x, y2 - y)\n          if (collision > 0) {\n            collisions synchronized\
    \ {\n              collisions += collision\n            }\n          }\n     \
    \     i += 1\n        } else if (dist < 1.0) {\n          j += 1\n        } else\
    \ {\n          i += 1\n        }\n      }\n      collisions.size", "      val\
    \ xs = for {\n        x <- 1 to n\n      } yield {\n        math.random\n    \
    \  }\n      val ys = for {\n        y <- 1 to n\n      } yield {\n        math.random\n\
    \      }\n      val speeds = for {\n        x <- xs\n        y <- ys\n      }\
    \ yield {\n        (math.sqrt(x) * math.sqrt(y))\n      }\n      val numCollisions\
    \ = mutable.Set()\n      val collisions = mutable.Set.empty[Long]\n      for (x\
    \ <- xs) {\n        for (y <- ys) {\n          for (speed <- speeds) {\n     \
    \       val collides = if (math.abs(x - (n * y)) < math.abs(y - (n * x))) 1 else\
    \ 0\n            numCollisions += collides\n            if (collides > 0) {\n\
    \              collisions += x * y * speed\n            }\n          }\n     \
    \   }\n      }\n      numCollisions.toSet.size", "        val n = math.max(2,\
    \ n)\n        val numCollisions = 0\n        val nextCarsCollisions = new collection.mutable.HashSet[Int]()\n\
    \        var nextCarsCollisionCount : Int = 1\n        val nextCarsCollisionsHash\
    \ = collection.mutable.HashSet[Int]()\n        var nextCarsCollisionsCount : Int\
    \ = 1\n        var collision : Int = 0\n        var collisionDistance : Double\
    \ = 0.0\n        var currentCar = 0\n        val leftSpeed = 0.3\n        val\
    \ rightSpeed = 0.2\n        val currentDirection = leftSpeed\n        var direction\
    \ : Double = 0.0\n        var speed : Double = 0.3\n        val obstacles = List(List(0,0),\
    \ List(0,0))\n        var obstacleIndex = 0\n        var currentOb = -1\n    \
    \    var currentObRight = 0\n        var currentObLeft = 0\n        while (currentCar\
    \ < n) {\n            if (obstacles.exists(x => x._1 == currentCar)) {\n     \
    \           nextCarsCollisionCount = math.min(currentCar, nextCarsCollisionCount)\
    \ + 2\n                nextCarsCollisionsCount = math.min(currentCar, nextCarsCollisionsCount)\
    \ + 1\n                nextCarsCollisions.add(currentCar)\n                nextCarsCollisionsHash.add(currentCar)\n\
    \            }\n            currentCar += 1\n            if (currentCar < n) {\n\
    \                obstacleIndex(currentObRight)\n                currentOb = obstacleIndex(0)\n\
    \                obstacleIndex(currentObLeft)\n                currentOb = obstacleIndex(1)\n\
    \            }\n            val currentObRightDist = math.sqrt(obstacles(currentObRight)(0)\
    \ - obstacles(currentObRight)(1))\n            val currentObLeftDist = math.sqrt(obstacles(currentObLeft)(0)\
    \ - obstacles(currentObLeft)(1))\n            if (currentObRightDist < currentObLeftDist)\
    \ {\n                currentDirection = rightSpeed\n                direction\
    \ = currentDirection\n                speed = rightSpeed\n            } else {\n\
    \                currentDirection = leftSpeed\n                direction = currentDirection\n\
    \                speed = leftSpeed\n            }\n            currentObLeft +=\
    \ 1\n            if (currentObLeft < n) {\n                obstacleIndex(currentObRight)\n\
    \                currentOb = obstacleIndex(0)\n                obstacleIndex(currentObLeft)\n\
    \                currentOb = obstacleIndex(1)\n            }\n            if (collisionDistance\
    \ > currentObRightDist) {\n                currentObRight += 1\n            }\n\
    \            if (collisionDistance > currentObLeftDist) {\n                currentObLeft\
    \ += 1\n            }\n            collisionDistance = math.min(currentObRightDist,\
    \ currentObLeftDist)\n            collision = ", "        // The \"speed\" of\
    \ a car can be described as a function of distance from the start of the\n   \
    \     // road.\n        def speed(x: Double, y: Double, distance: Double) = math.sqrt(x\
    \ * x + y * y) / distance\n\n        // The minimum distance a car should travel\
    \ in order for two cars to collide.\n        def minDist(set: Set[Car]) = set.foldLeft(Double.PositiveInfinity)((acc,\
    \ car) => acc.max {\n            val speedLeft = speed(car.x, car.y, car.distance)\n\
    \            val speedRight = speed(car.x, car.y, car.distance + car.distance)\n\
    \            math.min(speedLeft, speedRight)\n        })\n\n        val road =\
    \ Set[Car]()\n\n        // Cars start out as far from each other\n        for\
    \ (x <- 1 to 100) {\n            for (y <- 1 to 100) {\n                val car\
    \ = Car(x, y, 1)\n                road.add(car)\n            }\n        }\n\n\
    \        road.foreach { car =>\n            road.remove(car)\n        }\n\n  \
    \      // A car traveling left to right always hits a car traveling right to left\
    \ at exactly the\n        // same speed, no matter where on the road it is.\n\
    \        // An car traveling left to right hits a car traveling right to left\
    \ when it travels\n        // faster than the minimum distance.\n        // The\
    \ collision check is done by checking which cars are inside the other set, and\
    \ then\n        // counting the number of cars inside both sets.\n\n        def\
    \ collide(car: Car, otherCars: Set[Car]): Int = otherCars.count(otherCar =>\n\
    \            car.x > otherCar.x && car.x < otherCar.x + otherCar.width &&\n  \
    \          car.y > otherCar.y && car.y < otherCar.y + otherCar.height)\n\n   \
    \     // The first set of collisions is the number of collisions that occur between\
    \ the first\n        // and second sets.  All collisions inside the second set\
    \ are counted as collisions\n        // inside the first.\n        val firstSetCollisions\
    \ = road.count {\n            car => collide(car, road)\n        }\n\n       \
    \ // The second set of collisions is the number of collisions that occur between\
    \ the second\n        // and third sets.  All collisions inside the third set\
    \ are counted as collisions\n        // inside the second.\n        val secondSetCollisions\
    \ = road.count {\n            car => collide(car, road)\n        }\n\n       \
    \ val collisions = firstSetCollisions + secondSetCollisions\n        collisions",
  "        val startDist = math.sqrt(n*(n+1))/2\n        val endDist = math.sqrt(n*(n-2)+1)/2\n\
    \        var collisions = 0\n        // Use two lists of n elements, one for each\
    \ direction\n        val aList = Array.tabulate(n)(i => startDist*i).toList\n\
    \        val bList = Array.tabulate(n)(i => endDist*i).toList\n        // Use\
    \ mutable objects to hold the x and y position and velocity of each\n        //\
    \ car, and a mutable set to hold a record of which cars have been visited.\n \
    \       val cars = mutable.Set[Car]()\n        val x = mutable.Map[Car,Int]()\n\
    \        val y = mutable.Map[Car,Int]()\n        cars.updateAll(i => Car(i,0,0))\n\
    \        x.updateAll(i => Car(i,0,0))\n        y.updateAll(i => Car(i,0,0))\n\
    \        // While the number of cars remaining to travel doesn't change, keep\
    \ track\n        // of whether there are any collisions, and the number of collisions.\n\
    \        while ( cars.size != n){\n            // The cars are all moving right\
    \ to left, so pick the leftmost one\n            val leftmost = cars.sortBy(_.x)(0)\n\
    \            // For each pair of cars in their respective directions, check if\
    \ they collide.\n            var collide = leftmost.collidesWith(cars.sortBy(_.x)(n))\n\
    \            while(collide){\n                // Two cars collide.  Find out which\
    \ one hits which.\n                val leftCarHits = cars.filter{ c =>\n     \
    \               c.x == leftmost.x &&\n                    c.y == leftmost.y &&\n\
    \                    c.x > leftmost.x &&\n                    c.x < leftmost.x\
    \ + leftmost.width\n                }.toList\n                val rightCarHits\
    \ = cars.filter{ c =>\n                    c.x == rightmost.x &&\n           \
    \         c.y == rightmost.y &&\n                    c.x > rightmost.x &&\n  \
    \                  c.x < rightmost.x + rightmost.width\n                }.toList\n\
    \                // Remove the hits of the two cars from their respective lists\n\
    \                leftCarHits.foreach(x => cars.remove(x))\n                rightCarHits.foreach(x\
    \ => cars.remove(x))\n                collisions += 1\n            }\n       \
    \     // Add the leftmost car to the list of cars moving left to right.\n    \
    \        cars += leftmost\n            // Add the rightmost car to the list of\
    \ cars moving right to left.\n            cars += rightmost\n        }\n     \
    \   collisions", "        // Initialize all velocities (we'll use those to calculate\
    \ the number of collisions)\n        val v1 = Vector.zero\n        val v2 = Vector.zero\n\
    \        val vel = Vector.zero\n\n        for (i <- 0 until n) {\n           \
    \ val car1 = new Car(i -> v1)\n            val car2 = new Car(i -> v2)\n     \
    \       val speed1 = car1.speed\n            val speed2 = car2.speed\n\n     \
    \       // Determine how far they should be from each other to collide\n     \
    \       val x = speed1.x * speed2.x - speed2.x * speed1.x\n            val y =\
    \ speed1.y * speed2.y - speed2.y * speed1.y\n            val distance = sqrt(x\
    \ * x + y * y)\n\n            // Set initial velocities\n            car1.vel\
    \ = speed1\n            car2.vel = speed2\n            // Set final velocities\n\
    \            car1.v1 = x + car1.vel.x\n            car1.v2 = y + car1.vel.y\n\
    \            car2.v1 = x - car2.vel.x\n            car2.v2 = y - car2.vel.y\n\n\
    \            // Determine which one is closest\n            if (car1.v1 < car2.v1)\
    \ {\n                car1.next = car2\n                car2.next = car1\n    \
    \        } else {\n                car1.next = car1\n                car2.next\
    \ = car2\n            }\n        }\n\n        var collisions = 0\n        for\
    \ (i <- 0 until n) {\n            if (car1.next.speed == car2.speed) {\n     \
    \           val temp = car1.next\n                car1.next = car2.next\n    \
    \            car2.next = temp\n                collisions += 1\n            }\n\
    \        }\n\n        collisions", "        // (1) We want to find a set of m\
    \ such that |x_i \u2212 x_j| is less than or equal to\n        // the sum of |x_i\
    \ \u2212 x_k| for all j <= k, and where k <= m.\n        // So we start with a\
    \ vector of n random values between 1 and -1, each of which lies\n        // between\
    \ -1 and 1.  \n        // We then add these vectors together.  We then divide\
    \ by the length of each vector\n        // to get one vector for each car.\n \
    \       // This produces a vector of m cars.\n        // Now we check whether\
    \ there are any cars that don't collide in these vectors.\n        // If there\
    \ are, we add a vector and continue; if there are none, we continue.\n       \
    \ // Since every vector is either 1 or -1, this guarantees that no collisions\
    \ occur at all.\n        // So we run carRaceCollision again n times, and then\
    \ sum the results.\n        // If this doesn't converge, we return 0 as there\
    \ is no collision.\n        val rand = scala.util.Random\n        var sum = 0L\n\
    \        for (i <- 0 until n) {\n            val x1: Double = rand.nextDouble()\
    \ * 2 - 1\n            val y1: Double = rand.nextDouble() * 2 - 1\n          \
    \  val x2: Double = rand.nextDouble() * 2 - 1\n            val y2: Double = rand.nextDouble()\
    \ * 2 - 1\n            val dist: Double = (x1 - x2)\n            val angle: Double\
    \ = Math.atan2(y1, x1) + Math.atan2(y2, x2)\n            if (dist < 0 || angle\
    \ < 0) {\n                sum += 0\n            } else {\n                sum\
    \ += carRaceCollisionHelper(x1, y1, x2, y2, n, rand)\n            }\n        }\n\
    \        sum", "      var collisions = 0 // number of collisions\n      var currentTime\
    \ = 0 // current time for car race\n      var leftSpeed = 100\n      var rightSpeed\
    \ = 100\n      var leftMaxSpeed = (n - 1) * (rightSpeed + leftSpeed) // Max speed\
    \ for left lane\n      var rightMaxSpeed = (n - 1) * (leftSpeed + rightSpeed)\
    \ // Max speed for right lane\n      var left = 0 // number of cars in left lane\n\
    \      var right = 0 // number of cars in right lane\n      var leftSpeed // car\
    \ speed left to right\n      var rightSpeed // car speed right to left\n     \
    \ var car : Car // current car\n      var collisionWithOtherCar = false // flag\
    \ for collision with other car\n      var rightCollisionWithOtherCar = false //\
    \ flag for right collision with other car\n      var leftCollisionWithOtherCar\
    \ = false // flag for left collision with other car\n      while (left < n &&\
    \ right < n){\n          currentTime += 1\n          car = Car(currentTime, 1)\n\
    \          leftSpeed = car.speed\n          rightSpeed = car.speed\n         \
    \ if (currentTime > n) {\n            currentTime = 0\n          }\n         \
    \ val leftSpeedWithOtherCar = leftSpeed + car.otherSpeed\n          val rightSpeedWithOtherCar\
    \ = rightSpeed + car.otherSpeed\n          if (leftSpeedWithOtherCar > leftMaxSpeed\
    \ && currentTime > n){\n              collisions += 1\n              car = Car(currentTime,\
    \ 1)\n              leftSpeed = car.speed\n              leftCollisionWithOtherCar\
    \ = true\n          }\n          if (rightSpeedWithOtherCar > rightMaxSpeed &&\
    \ currentTime > n){\n              collisions += 1\n              car = Car(currentTime,\
    \ 1)\n              rightSpeed = car.speed\n              rightCollisionWithOtherCar\
    \ = true\n          }\n          currentTime += 1\n          if (currentTime >\
    \ n) {\n            currentTime = 0\n          }\n          val leftSpeedWithOtherCar\
    \ = leftSpeed + car.otherSpeed\n          val rightSpeedWithOtherCar = rightSpeed\
    \ + car.otherSpeed\n          if (leftSpeedWithOtherCar > leftMaxSpeed && currentTime\
    \ > n){\n              collisions += 1\n              car = Car(currentTime, 1)\n\
    \              leftSpeed = car.speed\n              leftCollisionWithOtherCar\
    \ = true\n          }\n          if (rightSpeedWithOtherCar > rightMaxSpeed &&\
    \ currentTime > n){\n              collisions += 1\n              car = Car(currentTime,\
    \ 1)\n              rightSpeed = car.speed\n              rightCollisionWithOther",
  "        val cars = Array.fill(26)\n        val x = Array.fill(26)\n        val\
    \ y = Array.fill(26)\n        for (xi <- 0 to n) {\n            cars(xi) = xi\
    \ % 26\n            y(xi) = math.tan(math.pi/2 * math.random) / math.tan(math.pi/2\
    \ * math.random)\n        }\n        val vx = Array.fill(n+n+1) {Double.Positive}\n\
    \        val vy = Array.fill(n+n+1) {Double.Positive}\n        for (xi <- 0 to\
    \ n) {\n            val xx = vx.sum\n            val yy = vy.sum\n           \
    \ for (xi <- 0 to n) { vx(xi) = xx * (26 - xi) / n }\n            for (xi <- 0\
    \ to n) { vy(xi) = yy * (26 - xi) / n }\n        }\n        var collisions = 0\
    \ // number of collisions\n        for (xi <- 0 to n-1) {\n            val xj\
    \ = cars(xi)\n            val yj = y(xi)\n            for (xji <- xi+1 to n) {\n\
    \                if (xj != xji) { continue }\n                val xji = cars(xji)\n\
    \                val yji = y(xji)\n                val vxji = vx(xji)\n      \
    \          val vyji = vy(xji)\n                val vxi = (yj - yji) / math.tan(math.pi/2\
    \ * math.random) / math.tan(math.pi/2 * math.random)\n                val vyi\
    \ = (yj - yji) / math.tan(math.pi/2 * math.random) / math.tan(math.pi/2 * math.random)\n\
    \                val dx = (xji - xi) - vxji * math.tan(math.pi/2 * math.random)\
    \ / math.tan(math.pi/2 * math.random)\n                val dy = (xji - xi) - vyji\
    \ * math.tan(math.pi/2 * math.random) / math.tan(math.pi/2 * math.random)\n  \
    \              val v = (vxji * vxji + vyji * vyji) * (dx * dx + dy * dy)\n   \
    \             if (v > 0) {\n                    collisions += 1\n            \
    \    }\n            }\n        }\n        return collisions", "        var count\
    \ = 0L\n        for (j <- 1 to n) {\n            var last = 0L\n            for\
    \ (i = 1L < j; i+= 1) {\n                if (carsCollide(i)(j - 1, j)) {\n   \
    \                 count = count + 1\n                }\n            }\n      \
    \      last = j\n        }\n        count", "        var numCollisions = 0 //\
    \ counter for number of collisions\n        var minDist = Long.MinValue // smallest\
    \ distance to any colliding cars\n        var car1 : Int = 0 // left car to collide\
    \ with\n        var car2 : Int = 0 // right car to collide with\n        for(\
    \ i <- 1 to n-1 ){\n            val distFromLeft = carRaceCollisionHelper(i, car1,\
    \ car2)\n            if( distFromLeft < minDist ){\n                minDist =\
    \ distFromLeft\n                car1 = i\n                car2 = carRaceCollisionHelper(i,\
    \ car2, car1)\n            }\n        }\n        numCollisions", "        val\
    \ road = List(\n            (0,0) -> (0,1),\n            (1,1) -> (1,2),\n   \
    \         (2,2) -> (1,3),\n            (3,3) -> (2,4),\n            (4,4) -> (2,5),\n\
    \            (5,5) -> (3,6),\n            (6,6) -> (4,7)\n        ).map(x => x._1\
    \ + x._2)\n        val cars = for (i <- 0 until n) yield Car(road(i))\n      \
    \  val carsByDirection = cars.map(c => (c.direction, c.speed)).toMap\n       \
    \ val carsByDirection2 = cars.map(c => (c.direction, c.speed, 2)).toMap\n\n  \
    \      val c1 = cars.take(2)\n        val c2 = cars.drop(2)\n\n        val minX\
    \ = math.min(c1.head.x, c2.head.x)\n        val maxX = math.max(c1.last.x, c2.last.x)\n\
    \        val minY = math.min(c1.head.y, c2.head.y)\n        val maxY = math.max(c1.last.y,\
    \ c2.last.y)\n\n        val collisionCount = 0\n        for (x <- 0 until n if\
    \ (minX < x && x < maxX && minY < y && y < maxY)) {\n            val nextSpeed\
    \ = math.min(math.abs(c1.tail.speed - c2.head.speed), math.abs(c1.head.speed -\
    \ c2.tail.speed))\n            if (carsByDirection2.get((x, y), 0) > nextSpeed)\
    \ collisionCount += 1\n        }\n        collisionCount", "        val n = math.min(math.max(n,\
    \ 1), 100000)\n        val collisions = 0\n        val set1 = mutable.Set[Car]()\n\
    \        val set2 = mutable.Set[Car]()\n        def collide(car : Car) : Boolean\
    \ = {\n            val collide = set1.contains(car) && set2.contains(car)\n  \
    \          if (collide)\n                collisions += n\n            collide\n\
    \        }\n        val minDist = math.pow(math.abs(n), 2)\n        val minDist2\
    \ = math.pow(math.abs(minDist - n), 2)\n        for (x <- 0 until n; y <- 0 until\
    \ n) {\n            val newCar = new Car(x, y)\n            if (collide(newCar))\n\
    \                collide(newCar)\n            set1 += newCar\n        }\n    \
    \    for (x <- 0 until n; y <- n - 1 until -1) {\n            val newCar = new\
    \ Car(x, y)\n            if (collide(newCar))\n                collide(newCar)\n\
    \            set2 += newCar\n        }\n        set2 foreach (collide)\n     \
    \   set1.foreach(collide)\n        collisions", "        val cars = Vector.fill(n\
    \ / 2).map (i => Vector(2 * i * Math.sqrt(2), i * Math.sqrt(2).toDouble))\n  \
    \      val carsByDirection = cars.groupBy(_.x)\n        val collisions = carsByDirection.values\n\
    \            .map(_.length).filter(_ > 1).length\n        collisions", "     \
    \   var leftCollisions = 0\n        var rightCollisions = 0\n        val startingPositions\
    \ = mutable.ArrayBuffer.fill(n)(math.Random)\n        val startingSpeeds = mutable.ArrayBuffer.fill(n)(math.Random)\n\
    \        for (i <- 0 until n) {\n            startingPositions(i) = math.random\n\
    \            startingSpeeds(i) = math.random\n        }\n        val currentPositions\
    \ = mutable.ArrayBuffer.fill(n){math.random}\n        val currentSpeeds = mutable.ArrayBuffer.fill(n){math.random}\n\
    \        for (i <- 0 until n) {\n            val currentSpeed = startingSpeeds(i)\n\
    \            val currentPosition = startingPositions(i)\n            for (j <-\
    \ 0 until n) {\n                val nextSpeed = startingSpeeds(j)\n          \
    \      val nextPosition = startingPositions(j)\n                val nextSpeedDelta\
    \ = nextSpeed - currentSpeed\n                val nextPositionDelta = nextPosition\
    \ - currentPosition\n                if (math.abs(nextSpeedDelta) < math.abs(nextPositionDelta))\
    \ {\n                    currentSpeeds(j) = nextSpeed\n                    currentPositions(j)\
    \ = nextPosition\n                    leftCollisions += 1\n                } else\
    \ if (nextSpeedDelta < 0 && (j != i)) {\n                    currentSpeeds(j)\
    \ = nextSpeed\n                    currentPositions(j) = nextPosition\n      \
    \              rightCollisions += 1\n                }\n            }\n      \
    \  }\n        rightCollisions", "        val map1 = mutable.Map[Long, Long]()\n\
    \        val map2 = mutable.Map[Long, Long]()\n        for (i <- 1 to n) {\n \
    \           map1 += (i -> i)\n            map2 += (i -> i + n)\n        }\n  \
    \      val collisions = mutable.Map[Long, Long]()\n        val intersection =\
    \ mutable.Map[Long, Long]()\n        for (key <- map1) {\n            if (map2.contains(key))\
    \ {\n                val collision = map2(key) - map1(key)\n                val\
    \ difference = collision % n\n                val collisionWithDifference = collision\
    \ - difference\n                collisions += (key -> collisionWithDifference)\n\
    \                intersection ++= collisionWithDifference.toLong -> (collisionWithDifference\
    \ + n).toLong\n            }\n        }\n        intersection.length", "     \
    \   val minSpeed = 10\n        val maxSpeed = 50\n        var collided = 0\n \
    \       for (i <- 0 until n) {\n            val initialSpeed = (minSpeed + (i\
    \ / n)) * maxSpeed\n            var speed = initialSpeed\n            var collide\
    \ = false\n            var left = 1\n            var right = -1\n            var\
    \ i = 0\n            while (collide == false) {\n                if (i % 2 ==\
    \ 0) {\n                    speed = speed + left\n                } else {\n \
    \                   speed = speed - right\n                }\n               \
    \ i = i + 1\n                for (j <- 0 until i) {\n                    val speedDiff\
    \ = abs(speed - initialSpeed)\n                    if (speedDiff < 2) {\n    \
    \                    collide = true\n                        if (speed > 0) {\n\
    \                            speed = speed - right\n                        }\
    \ else {\n                            speed = speed + left\n                 \
    \       }\n                    } else {\n                        break\n     \
    \               }\n                }\n            }\n            if (collide)\
    \ {\n                collided = collided + 1\n            }\n        }\n     \
    \   collided", "        val collisions = mutable.ListBuffer[String]()\n      \
    \  val leftCars = mutable.ListBuffer[Int]()\n        val rightCars = mutable.ListBuffer[Int]()\n\
    \        // create and populate each of the left/right cars\n        for (_ <-\
    \ 1 to n) {\n            val car = new Car()\n            car.velocity = mutable.ListBuffer[Double]()\n\
    \            for (i <- 1 to n) car.velocity += mutable.ListBuffer[Double](1.0)\n\
    \            val carId = car.id\n            leftCars += carId\n            rightCars\
    \ += carId * n\n        }\n        // determine and add the collisions\n     \
    \   var leftIndex = 0\n        var rightIndex = 0\n        while (leftIndex <\
    \ leftCars.size) {\n            var j = leftCars(leftIndex)\n            var k\
    \ = rightCars(rightIndex)\n            if (j == k) collisions += \"No collision\"\
    \n            else {\n                while (j < k) {\n                    val\
    \ cj = j\n                    val ck = k\n                    val vj = car.velocity(cj)\n\
    \                    val vk = car.velocity(ck)\n                    if (vj ==\
    \ vk) collisions += \"No collision\"\n                    else {\n           \
    \             val collision = Math.abs(vk(0) - vj(0)) <= 1.0\n               \
    \         if (collision) collisions += \"Collision at $(cj), $(ck)\"\n       \
    \                 else {\n                            val velDiff = car.velocity(cj).zip(vk).map(x\
    \ => x._1 - x._2).sum\n                            val distanceDiff = vj(0) *\
    \ (k - cj) + vk(0) * (j - ck) + vk(1) * (ck - j)\n                           \
    \ val collisionDistance = distanceDiff <= velDiff && distanceDiff <= 1.5 // 1.5\
    \ is arbitrary\n                            if (collisionDistance) collisions\
    \ += \"Collision at $(cj), $(ck)\"\n                            else {\n     \
    \                           leftIndex += 1\n                                k\
    \ += n\n                            }\n                        }\n           \
    \         }\n                    j += 1\n                    k += 1\n        \
    \        }\n                leftIndex += 1\n            }\n            rightIndex\
    \ += 1\n        }\n        collisions.size", "      var x = 0\n      var y = n\n\
    \      while (x < y) {\n        val c1 = n - x\n        val c2 = y - x\n     \
    \   if ((c1 == 0) && (c2 == 0)) return n\n        val m1 = (c1 % c2).abs.toInt\n\
    \        val m2 = (c2 / c1).abs.toInt\n        val d = (m1*m1).abs\n        if\
    \ (d > 1) return n\n        val t = c2*m1\n        if (t < 1) return n\n     \
    \   x = x + 1\n        y = y  - 1\n      }\n      return n", "        val cars:\
    \ Array[Array[Int]] = new Array[Array[Int]](n)\n        var i = 1\n        while\
    \ (i <= n) {\n            val x = scala.math.random * (i - 1)\n            val\
    \ y = scala.math.random * (n - i)\n            val w = scala.math.random * (i\
    \ - 1) + 1\n            val h = scala.math.random * (n - i) + 2\n            cars(x)\
    \ = Array(x, y, w, h)\n            i += 1\n        }\n        var collisions =\
    \ 0\n        var collisionCount = 0\n        var done = false\n        while (!done)\
    \ {\n            done = true\n            var i = 1\n            while (i <= n)\
    \ {\n                val j = 1\n                while (j <= n) {\n           \
    \         if (cars(i)(0) != cars(j)(0)) {\n                        done = false\n\
    \                        val xi = cars(i)(1)\n                        val xj =\
    \ cars(j)(1)\n                        val yi = cars(i)(2)\n                  \
    \      val yj = cars(j)(2)\n                        val wi = cars(i)(3)\n    \
    \                    val wj = cars(j)(3)\n                        val hi = (xi\
    \ + xj) / 2 + wi\n                        val hj = (yi + yj) / 2 + wj\n      \
    \                  if (hi == hj) {\n                            val xij = xi +\
    \ xj\n                            val yij = yi + yj\n                        \
    \    val xji = (xj - xi) / 2\n                            val yji = (yj - yi)\
    \ / 2\n                            var i = 0\n                            while\
    \ (i <= n) {\n                                if (i == j) {\n                \
    \                    val xij2 = xij + i * xji\n                              \
    \      val yij2 = yij + i * yji\n                                    if (cars(xij2)(0)\
    \ = xij2 && cars(xij2)(1) = yij2 && cars(xij2)(2) = xi + xj && cars(xij2)(3) =\
    \ yi + yj) {\n                                        collisions += 1\n      \
    \                                  collisionCount += 1\n                     \
    \                   done = false\n                                    }\n    \
    \                            } else {\n                                    val\
    \ xij2 = xi + i * xji\n                                    val yij2 = yi + i *\
    \ yji\n                                    if (cars(xij2)(0) = xij2 && cars(xij2)(1)\
    \ = yij2 && cars(xij2)(2) = i + xj && cars(xij2)(3) = j + yj) {\n            \
    \                            collisions += 1\n                               \
    \         collisionCount += 1\n                                        done =\
    \ false\n                                    }\n                             \
    \   }\n                                i += 1\n                            }\n\
    \                        }\n                    }\n                    j += 1\n\
    \                }\n                i += 1\n            }\n        }\n       \
    \ collisionCount", "        var count = 0\n        // use mutable Map to store\
    \ car position and speed\n        // use mutable Map to store car position and\
    \ speed\n        val map1 = mutable.Map[Int, Double]()\n        val map2 = mutable.Map[Int,\
    \ Double]()\n        for (i <- 1 to n) {\n            map1(i % n) = 0.\n     \
    \       map2(i % n) = 0.\n        }\n        for (i <- 0 to n) {\n           \
    \ for (j <- 1 to n) {\n                val distx = Math.abs(i - j)\n         \
    \       val disty = Math.abs((i - j) / Math.max(map1.get(i), map2.get(i)))\n \
    \               if (distx > disty && map1.get(i) > map2.get(j))\n            \
    \        map1.update(i, map1.get(i) + map2.get(j))\n                else if (distx\
    \ > disty && map1.get(i) < map2.get(j))\n                    map2.update(j, map2.get(j)\
    \ + map1.get(i))\n                else if (distx < disty && map1.get(j) > map2.get(i))\n\
    \                    map1.update(j, map1.get(j) + map2.get(i))\n             \
    \   else if (distx < disty && map1.get(j) < map2.get(i))\n                   \
    \ map2.update(i, map2.get(i) + map1.get(j))\n            }\n        }\n      \
    \  for (i <- 0 to n) {\n            for (j <- 1 to n) {\n                if (map1.get(i)\
    \ == map2.get(j)) {\n                    count += 1\n                    break\n\
    \                }\n            }\n        }\n        count", "        val roadLength\
    \ = n / 2 + 1\n        val speed = (n + 1)/2\n\n        // Cars are initially\
    \ moving very far from each other.  Let's find all ways they can\n        // collide\
    \ with each other, and count them.\n        var collisionCount = 0L\n\n      \
    \  for (i <- 1 until roadLength) {\n            var leftEnd: Long = 0\n      \
    \      var rightEnd: Long = 0\n\n            for (j <- 1 until roadLength) {\n\
    \                if (i == j) {\n                    continue\n               \
    \ }\n\n                val leftCar = car(i - ((j - 1) * roadLength))\n       \
    \         val rightCar = car(j - ((i - 1) * roadLength))\n\n                val\
    \ speedDifference = leftCar.speed - rightCar.speed\n                val xDifference\
    \ = leftCar.xPos - rightCar.xPos\n                val yDifference = leftCar.yPos\
    \ - rightCar.yPos\n\n                val speedMagnitude = speedDifference.abs.abs\n\
    \                val xMagnitude = xDifference.abs.abs\n                val yMagnitude\
    \ = yDifference.abs.abs\n\n                if ((speedMagnitude < speed * speed)\
    \ && (xMagnitude < x * (speed/speedMagnitude)) &&\n                        (yMagnitude\
    \ < y * (speed/speedMagnitude))) {\n                    leftEnd += 1\n       \
    \         }\n                if ((speedMagnitude < speed * speed) && (xMagnitude\
    \ < (speed - 1) * x) && (yMagnitude < y * (speed/speedMagnitude))) {\n       \
    \             rightEnd += 1\n                }\n            }\n\n            val\
    \ leftEnd = leftEnd * speed\n            val rightEnd = rightEnd * speed\n\n \
    \           if (leftEnd < rightEnd) {\n                collisionCount += 1\n \
    \           }\n        }\n\n        return collisionCount", "        var i = 0\n\
    \        var sum = 0L\n        while(i < n){\n            var j = 1\n        \
    \    var sum = 0L\n            while(j < n){\n                if(i != j && distance(i\
    \ - 1, j - 1) < distance(i - 1, j)){\n                    sum += distance(i -\
    \ 1, j - 1)\n                    j = n\n                }else{\n             \
    \       j += i + 1\n                }\n            }\n            i += j\n   \
    \         sum += distance(i - 1, 0)\n            sum += distance(0, i - 1)\n \
    \           sum += distance(0, 0)\n            sum += distance(n - 1, n - 1)\n\
    \            sum += distance(n - 1, n)\n            sum += distance(n - 1, n -\
    \ 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - 1, n - 1)\n            sum += distance(n - 1, n - 1)\n            sum += distance(n\
    \ - ", "        var collision = 0L\n        var totalDistance = 0L\n        for\
    \ (i <- 0 until n) {\n            var newDistance = 0L\n            for (j <-\
    \ 0 until n) {\n                newDistance += Math.abs(i - j)\n            }\n\
    \            if (newDistance > totalDistance) {\n                totalDistance\
    \ = newDistance\n                collision++\n            }\n        }\n     \
    \   collision", "        var collision = 0\n        // Represent a car's position\n\
    \        val x = for(i <- 0 until n) yield scala.math.random\n        val y =\
    \ for(i <- 0 until n) yield scala.math.random\n        val car = new Car(x, y,\
    \ scala.math.random)\n        // Represent a colliding car\n        val otherCar\
    \ = new Car(x, (y.map(Math.min(_, x))), scala.math.random)\n        otherCar.speed\
    \ = car.speed\n        // Keep checking the cars against each other for collisions\n\
    \        while(true) {\n            if(car.hits(otherCar)) {\n               \
    \ collision += 1\n            }\n            if(car.x != otherCar.x || car.y !=\
    \ otherCar.y) {\n                break\n            }\n        }\n        collision",
  "        val collisions = 0L\n        var left = 0L\n        var right = 0L\n  \
    \      var cLeft = 0L\n        var cRight = 0L\n        for (i <- 0 until n){\n\
    \            if (i < n){\n                // right car\n                if (cRight\
    \ < n){\n                    right += 2L\n                    cRight += 1\n  \
    \              }\n                else{\n                    right += 1L\n   \
    \                 cRight = 0L\n                }\n            }\n            else{\n\
    \                // left car\n                if (cLeft < n){\n              \
    \      left += 2L\n                    cLeft += 1\n                }\n       \
    \         else{\n                    left += 1L\n                    cLeft = 0L\n\
    \                }\n            }\n            collisions += (left < right) +\
    \ (left > right)\n        }\n        collisions", "        val carList = (0 until\
    \ n).toList\n        val carColList = new mutable.ListBuffer[Int]\n        var\
    \ collisionCount = 0\n\n        for (i <- 0 until n) {\n            for (j <-\
    \ i until n) {\n                val car1 = carList(i)\n                val car2\
    \ = carList(j)\n                val car1Velocity = car1.velocity\n           \
    \     val car2Velocity = car2.velocity\n                val car1Position = car1.position\n\
    \                val car2Position = car2.position\n                val distBetweenCars\
    \ = math.sqrt((car2Position.getX - car1Position.getX)^2 + (car2Position.getY -\
    \ car1Position.getY)^2)\n                if (distBetweenCars < car1Velocity+car2Velocity)\
    \ {\n                    carColList.clear()\n                    carColList +=\
    \ i\n                    carColList += j\n                    collisionCount+=2\n\
    \                }\n            }\n        }\n\n        return collisionCount",
  "        val collisions = mutable.ListBuffer[Long]()\n        val speed = Array.fill(2\
    \ * n)(1.0);\n        val xs = Array.fill(2 * n)(0.0)\n        val ys = Array.fill(2\
    \ * n)(0.0)\n        for (i <- 0 until 2 * n) {\n            xs(i) = (i mod 2\
    \ * n - 1) / (2 * n);\n            ys(i) = i / (2 * n);\n        }\n        speed(0)\
    \ = 1.0;\n        for (i <- 1 until 2 * n) {\n            for (j <- i until 2\
    \ * n) {\n                val speedJ = speed(j)\n                val xJ = xs(j)\n\
    \                val yJ = ys(j)\n                val speedI = speed(i)\n     \
    \           val xI = xs(i)\n                val yI = ys(i)\n                val\
    \ dist = xI - xJ;\n                val distY = yJ - yI;\n                val distToCenter\
    \ = math.sqrt((dist * dist) + (distY * distY));\n                if (dist < 0)\
    \ {\n                    val xCenter = (dist * xI) - (dist * xJ) + xI\n      \
    \              val yCenter = (distY * yI) - (distY * yJ) + yI\n              \
    \      val xDiff = xCenter - xI\n                    val yDiff = yCenter - yI\n\
    \                    if (xDiff > 0 && yDiff > 0) {\n                        val\
    \ collision = collisions.size\n                        collisions += collision\n\
    \                    }\n                }\n            }\n        }\n        collisions.toList.head",
  "        // Initialize the vector of collisions counts\n        var carCollisions\
    \ = 0L\n        var i = 1L\n        while (i <= n) {\n            if (isCarInLeftCollision(i))\
    \ {\n                carCollisions = carCollisions + 1\n            }\n      \
    \      i = i + 1\n        }\n        return carCollisions", "        var coll\
    \ = 0L\n        var lasti = 0L\n        var lastj = 0L\n        var lasti = n\
    \ - 1L\n        var lastj = n - 1L\n        while (coll < n && lasti < n && lastj\
    \ < n) {\n            val i = (lasti + lastj) / 2\n            val j = n - 1\n\
    \            val c = Math.abs(i) + Math.abs(j)\n            if (lasti != n ||\
    \ lastj != n || Math.abs(i) + Math.abs(j) < c || i == 0 || j == 0) {\n       \
    \         coll += 1\n            }\n            else {\n                if (i\
    \ < j) {\n                    lasti += 1\n                    lastj -= 1\n   \
    \             }\n                else {\n                    lastj += 1\n    \
    \                lasti -= 1\n                }\n            }\n        }\n   \
    \     coll", "        var carsLeft = n\n        var carsRight = n\n        var\
    \ totalDistance = 1000000\n        var minDist = 1\n        while (totalDistance\
    \ > minDist) {\n            val tempCarsLeft = carsLeft\n            val tempCarsRight\
    \ = carsRight\n            tempCarsLeft = 0\n            tempCarsRight = 0\n \
    \           totalDistance = 0\n            while (tempCarsLeft != tempCarsRight)\
    \ {\n                val xMin = math.min(tempCarsLeft, tempCarsRight)\n      \
    \          val xMax = math.max(tempCarsLeft, tempCarsRight)\n                val\
    \ yMin = math.min(tempCarsLeft - xMin, tempCarsRight - xMin)\n               \
    \ val yMax = math.max(tempCarsLeft - xMin, tempCarsRight - xMin)\n           \
    \     val collisionDist = math.sqrt(math.pow(yMin, 2) + math.pow(yMax, 2))\n \
    \               totalDistance += collisionDist\n                if (collisionDist\
    \ < minDist) {\n                    minDist = collisionDist\n                }\n\
    \                tempCarsLeft -= yMin\n                tempCarsRight -= yMin\n\
    \            }\n            carsLeft = tempCarsLeft\n            carsRight = tempCarsRight\n\
    \        }\n        carsLeft + carsRight", "        val carsLeft = mutable.Set[Long]()\n\
    \        val carsRight = mutable.Set[Long]()\n        // the left cars are \"\
    n\" to the left and the right cars are \"n\" to the right\n        for(i <- 0\
    \ until n) {\n            carsLeft.add(i)\n            carsRight.add(i)\n    \
    \    }\n        carsLeft.add(n - 1)\n        carsRight.add(0)\n        var collides\
    \ = 0\n        for(left <- carsLeft) {\n            for(right <- carsRight) {\n\
    \                if(left != right && !carsLeft.contains(right) && !carsRight.contains(left))\
    \ {\n                    collides += 1\n                }\n            }\n   \
    \     }\n        collides", "        val car1 = (0 to n).map(i => (0,i)).zipWithIndex.toList.sorted\n\
    \        val car2 = (0 to n).map(i => (n,i)).zipWithIndex.toList.sorted\n    \
    \    val collides = mutable.ListBuffer.empty[Long]\n        for (i <- car1.indices)\
    \ {\n            for (j <- car2.indices) {\n                if (i == j) continue\n\
    \                if (car1(i)(0) < car1(j)(0)) collides += 1 //go right to left\n\
    \                if (car1(i)(0) >= car1(j)(0)) collides += 1 //go left to right\n\
    \            }\n        }\n        collides.toList.length", "        // Initialize\
    \ an n-by-2 matrix of zeroes and ones\n        val matrix = (0 until n).map((_,0))\n\
    \        val ones = Vector.tabulate(n)(i => 1)\n        var collisions = 0L\n\
    \        // Start driving the left car; then drive the right car;\n        //\
    \ then stop.  Each car collides with its neighbour in exactly one\n        //\
    \ place when its next position differs by exactly one.\n        for(i <- 0 until\
    \ n-1) {\n            val left = matrix.updated(i, ones)\n            val right\
    \ = matrix.updated(i, ones.minus(1))\n            val next = left.zip(right).map\
    \ {\n                case (a,b) =>\n                    if(a.sum == 1 && b.sum\
    \ == 1) {\n                        val newLeft = a.map(_+1).reduce(_+_)\n    \
    \                    val newRight = b.map(_+1).reduce(_+_)\n                 \
    \       matrix.updated(i, newLeft)\n                        matrix.updated(i,\
    \ newRight)\n                    }\n                    else\n               \
    \         None\n            }.collect{case Some(next) => next}\n            collisions\
    \ += next.length\n        }\n        collisions", "        var car1 : List[Long]\
    \ = List(1,2,3,4)\n        var car2 : List[Long] = List(5,6,7,8)\n        var\
    \ collisions : List[Long] = List()\n        for (i <- car1 to car2) {\n      \
    \      val collision = car1.zip(car2).find(_.head == i.head && _.head == i.last).getOrElse(List())\n\
    \            collisions ++= collision\n        }\n        return collisions.count(_.head\
    \ == car2.head)", "        val distances = (0 until n).map(i => Int.MaxValue).sorted\n\
    \        val cars = distances.map(i => i -> distances(i))\n        val collisions\
    \ = mutable.Set.empty[Long]\n        cars.foreach(car => car.foreach { case (i,\
    \ d) =>\n            if (i == 0 && distances(i) == Int.MaxValue) {\n         \
    \       collisions += d\n                distances(i) = d\n                cars(i)\
    \ = distances(i)\n            }\n        })\n        collisions.toSet.size", " \
    \       val roadWidth = 10.0\n        val road = for (i <- 1 until n; j = i +\
    \ 1) yield {\n            val a = roadWidth / 2.0\n            val b = roadWidth\
    \ / 2.0 + road\n            (-a to b to a) map (x => (x + i, x))\n        }\n\
    \        val carLength = roadWidth / 2.0\n        val collisions = mutable.Set[Collision]()\n\
    \        road.foreach { case (x, xs) =>\n            val left = collisions findOne\
    \ { case Collision(xs, left, _) => left }\n            if (left == null) {\n \
    \               val right = collisions findOne { case Collision(_, right, _) =>\
    \ right }\n                if (right == null) {\n                    val y = carLength\n\
    \                    val left = Collision(xs, x + 1, y)\n                    val\
    \ right = Collision(xs, x - 1, y)\n                    collisions += Collision(left,\
    \ right)\n                    collisions += Collision(right, left)\n         \
    \       }\n            }\n        }\n        collisions.size * (-1)", "      \
    \  val colliders = mutable.ListBuffer(0)\n        val cars = mutable.ListBuffer[Int]()\n\
    \        val speed = mutable.ListBuffer[Int]()\n        val collisions = mutable.ListBuffer[Int]()\n\
    \        val speeds = mutable.ListBuffer[Int]()\n\n        for (i <- 1 to n) {\n\
    \            cars += i\n            speed += i\n        }\n\n        // Create\
    \ a car race simulation\n        val sim = new Simulation(speed, cars, collisions)\n\
    \        sim.loop()\n\n        collisions(0)", "        var counter : Long = 0\n\
    \        // First, find the point at which the lines cross, using Euclid's formula.\n\
    \        var xCrossing : Double = 0.0\n        var yCrossing : Double = 0.0\n\
    \        var x1Crossing : Double = 0.0\n        var y1Crossing : Double = 0.0\n\
    \        var xDotProduct : Double = 0.0\n        var yDotProduct : Double = 0.0\n\
    \        // Now find the vector from each car of the two race tracks.\n      \
    \  // We need this to know which cars are on opposite sides of the line and to\
    \ know when they cross.\n        // We don't need to know the speed of each car\
    \ - only their distance traveled.\n        // This speed-distance calculation\
    \ will get us the angle of each car.\n        var xSpeeds : Seq[Double] = new\
    \ Array[Double](n)\n        var ySpeeds : Seq[Double] = new Array[Double](n)\n\
    \        for (i <- 0 until n) {\n            xSpeeds(i) = rand.nextDouble() *\
    \ 2 - 1\n            ySpeeds(i) = rand.nextDouble() * 2 - 1\n        }\n     \
    \   var xSpeedsDouble : Seq[Double] = new Array[Double](n)\n        var ySpeedsDouble\
    \ : Seq[Double] = new Array[Double](n)\n        for (i <- 0 until n) {\n     \
    \       xSpeedsDouble(i) = xSpeeds(i).doubleValue()\n            ySpeedsDouble(i)\
    \ = ySpeeds(i).doubleValue()\n        }\n        var angles : Seq[Double] = new\
    \ Array[Double](n)\n        for (i <- 0 until n) {\n            angles(i) = Math.atan2(ySpeeds(i).doubleValue(),\
    \ xSpeeds(i).doubleValue())\n        }\n        // Now iterate through each car,\
    \ and find out if they are on opposite sides.\n        // If they are, they collided.\n\
    \        for (i <- 0 until n) {\n            // If car is on left side, check\
    \ for collision.\n            if (xSpeeds(i).doubleValue() < -1.0) {\n       \
    \         // Calculate vector from car to opposing side.\n                var\
    \ xOppSide = xSpeedsDouble(i).doubleValue() * Math.cos(angles(i)).doubleValue()\
    \ + ySpeedsDouble(i).doubleValue() * Math.sin(angles(i)).doubleValue()\n     \
    \           var yOppSide = xSpeedsDouble(i).doubleValue() * Math.sin(angles(i)).doubleValue()\
    \ - ySpeedsDouble(i).doubleValue() * Math.cos(angles(i)).doubleValue()\n     \
    \           // Calculate vector from car to centre of line.\n                var\
    \ xCentre = xSpeeds(i).doubleValue() + xCrossing\n                var yCent",
  "        val set1 = Set.empty[Long]\n        val set2 = Set.empty[Long]\n      \
    \  val intersection = for (i <- 1 until n) yield {\n            if (i % 2 == 0)\
    \ set1 += i\n            else set2 += i\n        }\n        val set3 = set1 intersect\
    \ set2\n        set3.toSet.length", "        val leftCars = Array.fill(n / 2)(0)\n\
    \        val rightCars = Array.fill(n / 2)(0)\n\n        // All Cars are initially\
    \ at position 0\n        for (i <- 0 until n) {\n            if (i % 2 == 0) {\n\
    \                leftCars(i / 2) = i\n            } else {\n                rightCars(i\
    \ / 2) = i\n            }\n        }\n\n        for (i <- 1 until n) {\n     \
    \       // Find the collision points by computing the distances of left and right\
    \ cars\n            val leftDist = math.abs(leftCars(i) - leftCars(i - 1))\n \
    \           val rightDist = math.abs(rightCars(i) - rightCars(i - 1))\n\n    \
    \        // All the cars are moving at the same speed\n            val speed =\
    \ i\n\n            // If the cars are colliding move them in the opposite direction\n\
    \            if (leftDist < rightDist) {\n                if (leftDist == rightDist)\
    \ {\n                    leftCars(i-1) = leftCars(i)\n                    rightCars(i-1)\
    \ = rightCars(i)\n                } else {\n                    val tempCar =\
    \ if (leftDist > rightDist) rightCars(i-1) else leftCars(i-1)\n              \
    \      leftCars(i-1) = rightCars(i)\n                    rightCars(i-1) = tempCar\n\
    \                }\n            } else {\n                if (rightDist == leftDist)\
    \ {\n                    leftCars(i-1) = leftCars(i)\n                    rightCars(i-1)\
    \ = rightCars(i)\n                } else {\n                    val tempCar =\
    \ if (rightDist > leftDist) leftCars(i-1) else rightCars(i-1)\n              \
    \      leftCars(i-1) = rightCars(i)\n                    rightCars(i-1) = tempCar\n\
    \                }\n            }\n        }\n        return rightCars.length\
    \ * 2", "        val cars = Vector.fill(n.toInt)(0)\n        val distances = Vector.fill(n.toInt)(0)\n\
    \        val carDistances = Vector.fill(n.toInt)(0)\n        val n = n.toInt\n\
    \        val speed = 2.0 / n\n        for(i <- 0 to n-1) {\n            for(j\
    \ <- i to n-1) {\n                cars(i) = 1\n                carDistances(i)\
    \ = Vector.tabulate(n)(i => speed).sum\n                distances(j) = carDistances(j).abs\n\
    \            }\n        }\n        val collisions = 0 // Count the number of collisions\n\
    \        for(i <- 1 to n) {\n            val minDistance = math.min(distances(i),\
    \ distances(n - i))\n            collisions += math.max(0, minDistance - speed)\n\
    \        }\n        collisions", "        val sets = List.fill(n / 2)(Set.empty[Long])\n\
    \        val cars = List.fill(n / 2)(Set.empty[Long])\n        var left = 0\n\
    \        val right = n / 2\n        val collisions = 0\n        val start = new\
    \ Long(Long.MaxValue)\n        val end = new Long(Long.MaxValue)\n        for\
    \ (i <- 0 until n) {\n            if (i % 2 == 0) {\n                sets(left)\
    \ = sets(left) + i\n                cars(left) = cars(left) + i\n            }\
    \ else {\n                sets(right) = sets(right) + i\n                cars(right)\
    \ = cars(right) + i\n            }\n        }\n        val iter = Iterator.continually(new\
    \ Long(Long.MaxValue))\n        while(iter.hasNext) {\n            val x = iter.next()\n\
    \            if (x == start) {\n                start = x\n                end\
    \ = x\n            }\n            if (x == end) {\n                end = x\n \
    \               start = x\n            }\n            val setIndex = x % 2\n \
    \           val leftCarIndex = setIndex * 2 - 1\n            val rightCarIndex\
    \ = setIndex * 2\n            if (cars(leftCarIndex) <= x && cars(rightCarIndex)\
    \ >= x) {\n                if (sets(leftCarIndex).size + sets(rightCarIndex).size\
    \ == 1) {\n                    collisions += 1\n                }\n          \
    \  }\n        }\n        collisions", "        var currentCarIndex = 0\n     \
    \   var collisions = 0\n        var leftCarIndex = 0\n        var rightCarIndex\
    \ = 1\n        while (currentCarIndex < n) {\n            val currentCar = Car(currentCarIndex,\
    \ leftCarIndex, rightCarIndex)\n            val leftCar = Car(leftCarIndex, leftCarIndex,\
    \ rightCarIndex)\n            val rightCar = Car(rightCarIndex, leftCarIndex,\
    \ rightCarIndex)\n            val currentCollision = currentCar.collide(leftCar,\
    \ rightCar)\n            if (currentCollision) {\n                collisions +=\
    \ 1\n            }\n            currentCarIndex += 1\n            if (currentCarIndex\
    \ == n) {\n                currentCarIndex = 0\n                collisions +=\
    \ 1\n            }\n            leftCarIndex += 2\n            if (leftCarIndex\
    \ > n) {\n                leftCarIndex = 0\n                rightCarIndex += 1\n\
    \            }\n        }\n        return collisions", "        val cars = Range(0,\
    \ n).map{ i => (0 to i).map(x => (x to 0).map(y => x + y))}\n        val collisions\
    \ = mutable.Set.empty[Long]\n        val collisionsForCars = mutable.Set.empty[List[Long]]\n\
    \n        (cars zip (0 until n)) foreach { case (car, carPos) =>\n           \
    \ cars.foreach { case (car2, car2Pos) =>\n                if (carPos == car2Pos)\
    \ return\n                val intersection = car.map(_ => car2.indexOf(_))\n \
    \               val intersectingCars = intersection.filter(_ != -1).length\n \
    \               if (intersectingCars == 0) return\n                val collision\
    \ = intersection.filter(x => x == carPos).count(_ == car2Pos)\n              \
    \  if (collision > 0) collisions += collision\n                val collisionsForCar\
    \ = intersection.filter(x => x == carPos)\n                .map(x => (carPos,car2Pos)).toList.distinct\n\
    \                collisionsForCars += collisionsForCar\n            }\n      \
    \  }\n        collisions.filter(x => x == n).length", "        val collisions\
    \ = 0\n        val cars = List.fill(n / 2)(Random.nextLong()).toArray\n      \
    \  val otherCars = List.fill(n / 2)(Random.nextLong()).toArray\n        val speed\
    \ = Random.nextInt()\n        val speedDifference = speed - cars.last\n      \
    \  val otherSpeedDifference = speed - otherCars.last\n\n        def collide(cars\
    \ : Array[Long], otherCars : Array[Long], speedDifference : Int, otherSpeedDifference\
    \ : Int): Boolean = {\n            val collision = speedDifference + otherSpeedDifference\
    \ < 0\n            for (i <- 1 to cars.length - 1) {\n                if (cars(i)\
    \ != cars(i - 1) && cars(i) == cars(i + 1) && cars(i) != otherCars(i) && otherCars(i)\
    \ == otherCars(i - 1)) {\n                    collision = true\n             \
    \   }\n            }\n            collision\n        }\n\n        var i = 0\n\
    \        while(i < otherCars.length) {\n            i += 1\n            if(cars(i)\
    \ != cars(i - 1) && cars(i) == cars(i + 1) && cars(i) != otherCars(i) && otherCars(i)\
    \ == otherCars(i - 1)) {\n                collisions += 1\n            }\n   \
    \     }\n\n        collisions", "        val cars = mutable.ListBuffer(1 to n)\n\
    \        for (i <- 1 to n){\n            cars += n\n            cars += n - i\n\
    \            cars += n + 1\n            cars += n - i - 1\n        }\n       \
    \ val carCount = cars.size\n        for (car <- 1 to n){\n            val left\
    \ = cars.find(i => i == car)\n            val right = cars.find(i => i == car\
    \ + 1)\n            if (left != right && left != car - 1 && right != car + 1)\n\
    \                carCount -= 1\n        }\n        carCount", "        val speed\
    \ = 200\n        val trajectory = new Array[Long](n)\n        var left = 0\n \
    \       var right = 0\n        for (i <- 0 until n) {\n            val pos = 100\
    \ * i / (n + 1)\n            val vel = (speed * math.sin(pos * 2 * math.pi / n))\
    \ / math.pow(math.cos(pos * 2 * math.pi / n), 2)\n            trajectory(i) =\
    \ pos + vel\n            val collision = right - left\n            left = right\n\
    \            right = collision\n        }\n        trajectory.last", "      val\
    \ roadLength = n / 2.0\n      var colliding = 0L\n      for (i <- 0 until n) {\n\
    \        for (j <- 0 until n) {\n          if (i != j) {\n            val speed\
    \ = i * 5.0\n            val otherSpeed = j * 5.0\n            val distance =\
    \ math.sqrt((i - roadLength)*(i - roadLength) + (j - roadLength)*(j - roadLength))\n\
    \            val otherDistance = math.sqrt((roadLength - i)*(roadLength - i) +\
    \ (roadLength - j)*(roadLength - j))\n            if (speed < otherSpeed) {\n\
    \              val newSpeed = speed + distance\n              if (newSpeed > otherSpeed)\
    \ newSpeed = otherSpeed\n              if (newSpeed < speed) newSpeed = speed\n\
    \              if (newSpeed == otherSpeed) colliding += 1\n            }\n   \
    \       }\n        }\n      }\n      colliding", "        def collide(i : Int,\
    \ j : Int) : Boolean = {\n            val left = i * n + i\n            val right\
    \ = j * n + j\n            // Do collision detection here...\n            true\n\
    \        }\n        val collisions = 0\n        var i = 0\n        while (i <\
    \ n) {\n            var j = i\n            while (j < n) {\n                if\
    \ (collide(i, j))\n                    collisions += (i + j) / 2\n           \
    \     j++\n            }\n            i += 1\n        }\n        collisions",
  "        // Assume that there are infinitely many cars moving left to right.\n \
    \       var car1 : Long = 0\n        var car2 : Long = 0\n\n        // Assume\
    \ that the first car starts off colliding.\n        var collide : Boolean = true\n\
    \n        var collisionCount : Long = 0\n        for (car <- 0 until n) {\n  \
    \          // Assume that the first car starts off colliding.\n            collide\
    \ = true\n            car1 += 1\n\n            for (i <- 0 until n) {\n      \
    \          // Assume that the first car starts off colliding.\n              \
    \  collide = true\n\n                // If the cars are colliding, increment the\
    \ collision count; otherwise, increment the collision count.\n               \
    \ if (car1 == car2) {\n                    collisionCount += 1\n             \
    \   } else {\n                    collisionCount += 0\n                }\n\n \
    \               // Update car2 and car1\n                car2 += 1\n         \
    \   }\n        }\n\n        collisionCount", "        var count = 0\n        var\
    \ previousVelocity : Double = 0.0;\n        var colliding : Boolean = false;\n\
    \        val v = (n to 1).toList.map(x => x * 3.14159).toArray\n        val v1\
    \ = Array(v(0), v(1), v(2))\n        val v2 = Array(v.last(), v.last() - 1, v.last()\
    \ - 2)\n        var j = 0\n        for(i <- 0 to n-1)\n        {\n           \
    \ if(!colliding)\n            {\n                for(j <- i to n-1)\n        \
    \        {\n                    if(!colliding && Math.abs(v1(j) - v2(j)) <= 1.0)\n\
    \                    {\n                        colliding = true;\n          \
    \          }\n                }\n            }\n            if(!colliding)\n \
    \           {\n                for(j <- i to n-1)\n                {\n       \
    \             if(!colliding && Math.abs(v1(i) - v2(j)) <= 1.0)\n             \
    \       {\n                        colliding = true;\n                    }\n\
    \                }\n            }\n            if(colliding)\n            {\n\
    \                for(j <- i to n-1)\n                {\n                    if(!colliding\
    \ && Math.abs(v1(j) - v2(j)) <= 1.0)\n                    {\n                \
    \        colliding = false;\n                        count = count + 1\n     \
    \                   break\n                    }\n                }\n        \
    \    }\n        }\n        return count", "        var numCollisions = 0\n   \
    \     var left = 0\n        var right = 0\n        for (_ <- 1 to n) {\n     \
    \       val leftCount = if (left < n) left else 0\n            val rightCount\
    \ = if (right < n) right else 0\n            if (Math.abs(leftCount) > Math.abs(rightCount))\
    \ {\n                numCollisions += 1\n                left += 1\n         \
    \   }\n            else {\n                numCollisions += 1\n              \
    \  right += 1\n            }\n        }\n        numCollisions", "        val\
    \ carDistances = (1 to n).map(i => i + i).toVector\n        val carPositions =\
    \ carDistances.map(i => math.random)\n        val carSpeeds = carDistances.map(i\
    \ => math.random * 10)\n        val collisions = carSpeeds.zipWithIndex.foldLeft(0)(_\
    \ zip _)\n        collisions.last", "        val road = Array.fill( (n+1) )(Array[Boolean](true,\
    \ true))\n        var collisions = 0\n        for(i <- 1 to n){\n            var\
    \ i1 = i-1\n            for(j <- 1 to n){\n                var j1 = j-1\n    \
    \            if(road(i1)(j1) && road(j1)(i1)){\n                    road(i1)(j1)\
    \ = false\n                    road(j1)(i1) = false\n                    collisions\
    \ += 1\n                }\n            }\n        }\n        collisions", "  \
    \      // Initialize to number of collisions found\n        var collisions = 0\n\
    \n        // Initialize the two sets of cars being considered.\n        // The\
    \ first set is the set of cars moving left to right.\n        // The second set\
    \ is the set of cars moving right to left.\n        var left = Set.empty[Car]\n\
    \        var right = Set.empty[Car]\n\n        // Initialize a mutable vector\
    \ to store the cars being considered.\n        var cars = Vector.empty[Car]\n\n\
    \        // Start populating the set of cars being considered.\n        for (i\
    \ <- 0 until n) {\n            cars += new Car(math.random * 10)\n        }\n\n\
    \        // Iterate over the set of cars being considered.\n        while (cars.nonEmpty)\
    \ {\n            // Remove the first car in the set of cars being considered\n\
    \            cars -= cars.head\n            // Add it to the left set of cars\n\
    \            left += cars.head\n            // Add it to the right set of cars\n\
    \            right += cars.last\n            // If there are two cars colliding\
    \ with each other...\n            if (left.exists && (right.exists || (left.size\
    \ == 1 && right.size == 1))) {\n                // Increment the number of collisions\n\
    \                collisions += 1\n            }\n        }\n        collisions",
  "        var i = n\n        var j = n - 1\n        var k = n\n        while (i <\
    \ j) {\n            if (i != k) {\n                val d = sqrt(pow(i-1, 2) +\
    \ pow(j-1, 2))\n                if (d < pow(k-1, 2)) {\n                    i\
    \ = i+1\n                } else {\n                    k = k-1\n             \
    \   }\n            } else {\n                k = k-1\n            }\n        }\n\
    \        i", "        val c = new Array[Long](n)\n        var i = 0\n        while\
    \ (i < n) {\n            val j = i + 1 \n            val x = i - 1\n         \
    \   val y = i + 1\n            c(i) = if(x % 2 == 0) j else i\n            c(j)\
    \ = (x + y) % n\n            i += 1\n        }\n        val count = 0L\n     \
    \   val c2 = c.zipWithIndex\n        for ( ((i1,j1), (i2,j2)) <- c2) {\n     \
    \       val x = c(i2)\n            val y = c2(j2)._2._2._1\n            if(x ==\
    \ y) count += 1\n        }\n        count", "        val startPoint = Vector(0\
    \ , 0)\n        val endPoint = Vector(1 , -1)\n        val points = Vector(startPoint\
    \ , endPoint)\n        val speed = 2 // 1 car moves 1 unit per second\n      \
    \  val collisions: MutableSet[Long] = new mutable.HashSet[Long]()\n        val\
    \ directions = Vector.zeros[Double](n+1)\n        val dirVector = endPoint.minus(startPoint)\n\
    \        val xDist = math.min(startPoint.x, endPoint.x)\n        val yDist = math.min(startPoint.y,\
    \ endPoint.y)\n        for (i <- 0 until n) {\n            val point = points(i)\n\
    \            val xSpeed = speed * math.sin(i * 2 * math.pi / n)\n            val\
    \ ySpeed = speed * math.cos(i * 2 * math.pi / n)\n            directions(i) =\
    \ xSpeed * dirVector.x  + ySpeed * dirVector.y\n        }\n        var collisionCount\
    \ = 0\n        for (i <- 0 until n-1) {\n            val currentPoint = points(i)\n\
    \            val nextPoint = points(i+1)\n            var nextCollision = 0\n\
    \            var nextCollisionDirection = Vector.zeros[Double](n+1)\n        \
    \    var nextCollisionDirectionVector = Vector.zeros[Double](n+1)\n          \
    \  for (j <- i until n) {\n                val dirVector = directions(j)\n   \
    \             val collision = currentPoint.distance(nextPoint) + dirVector.distance(nextCollisionDirection)\n\
    \                nextCollision = math.min(nextCollision, collision)\n        \
    \        nextCollisionDirection = dirVector\n                nextCollisionDirectionVector\
    \ = nextCollisionDirection.minus(currentPoint)\n            }\n            collisionCount\
    \ += math.min(nextCollision, collisionCount) + math.min(nextCollisionDirection.norm(2),\
    \ nextCollisionDirectionVector.norm(2))\n        }\n        collisionCount", " \
    \       val track : mutable.ArraySeq[Int] = new mutable.ArraySeq[Int]\n      \
    \  val track2 : mutable.ArraySeq[Int] = new mutable.ArraySeq[Int]\n        val\
    \ track3 : mutable.ArraySeq[Int] = new mutable.ArraySeq[Int]\n\n        // initialize\
    \ track to 0\n        for (i <- 0 until n){\n            track(i) = i\n      \
    \  }\n\n        // initialize track2 to 0\n        for (i <- 0 until n){\n   \
    \         track2(i) = i\n        }\n\n        // initialize track3 to 0\n    \
    \    for (i <- 0 until n){\n            track3(i) = i\n        }\n\n        val\
    \ collide = 0\n        var i = 0\n        while (i < n) {\n            for (j\
    \ <- i + 1 until n) {\n                if (track(j) == i && track(j + n) == i)\
    \ {\n                    // collision\n                    track3(collide) = track(collide)\n\
    \                    track(collide) = i\n                    track2(collide) =\
    \ j\n                    track(collide+n) = i\n                    track2(collide+n)\
    \ = j\n                    track3(collide+n) = j\n                    collide\
    \ += 1\n                }\n            }\n            i += 1\n        }\n    \
    \    collide", "        val x = new Vector[Long](n)\n        val y = new Vector[Long](n)\n\
    \        for(i <- 1 to n){\n            x(i-1) = rand.nextInt(10000)\n       \
    \     y(i-1) = rand.nextInt(10000)\n        }\n        val xs = x zip y filter\
    \ { case (x1,x2) => x1 > x2 }\n        val ys = y zip x filter { case (x1,x2)\
    \ => x1 > x2 }\n        xs.length + ys.length", "        val n = n % 3\n     \
    \   if (n < 0) {\n            println(\"n must be non-negative\")\n          \
    \  return 0;\n        }\n        val start = scala.util.Random.nextInt(n) + 1\n\
    \        val end = start\n        val list = scala.collection.mutable.ArrayBuffer.empty[Int]\n\
    \        val list = scala.collection.mutable.ArrayBuffer.empty[Int]\n        val\
    \ list = scala.collection.mutable.ArrayBuffer.empty[Int]\n        var collisions\
    \ = 0\n        // The starting point of car1 is at position 'start'.\n       \
    \ val car1 = start + 1\n        // The first car moves left to right to position\
    \ 'car1'.\n        val car2 = 0\n        // At position 0 (the beginning of the\
    \ line), the cars start out being\n        // very close to each other.\n    \
    \    for (i <- car1 until n) {\n            // Every car is only going one position\
    \ in a single step.\n            val nextCar = scala.util.Random.nextInt(n) +\
    \ 1\n            // The 'nextCar' might not actually be part of the line - it\
    \ might\n            // be part of a collision.\n            if (nextCar >= i)\
    \ {\n                continue\n            }\n            // The cars are moving\
    \ left and right at the same rate, so they would\n            // collide only\
    \ at the start and end, so the collision must be at the\n            // end of\
    \ the line.\n            if (car1 == i && nextCar == i) {\n                collisions\
    \ += 1\n            } else if (car1 == i && nextCar == start || car1 == start\
    \ && nextCar == i) {\n                collisions += 1\n            } else if (car2\
    \ == i && nextCar == i) {\n                collisions += 1\n            } else\
    \ if (car2 == i && nextCar == start || car2 == start && nextCar == i) {\n    \
    \            collisions += 1\n            } else if (car1 == i && nextCar == nextCar)\
    \ {\n                collisions += 1\n            } else if (car1 == i && nextCar\
    \ == end || car1 == end && nextCar == i) {\n                collisions += 1\n\
    \            } else if (car2 == i && nextCar == nextCar) {\n                collisions\
    \ += 1\n            } else if (car2 == i && nextCar == end || car2 == end && nextCar\
    \ == i) {\n                collisions += 1\n            }\n            list +=\
    \ i\n            list += nextCar\n        }\n        if (list.size == n) {\n \
    \           collisions += 1\n        }\n        return collisions", "        var\
    \ x = 0\n        var y = 0\n        var xMax = 0\n        var yMax = 0\n     \
    \   val xMin = 0\n        val yMin = 0\n        val xMinNew = 0\n        val yMinNew\
    \ = 0\n        var xMinNew2 = Integer.MAX_VALUE\n        var yMinNew2 = Integer.MAX_VALUE\n\
    \        var xMaxNew = Integer.MIN_VALUE\n        var yMaxNew = Integer.MIN_VALUE\n\
    \        var xMaxNew2 = Integer.MIN_VALUE\n        var yMaxNew2 = Integer.MIN_VALUE\n\
    \        var count = 0\n        val xs = Vector.fill(n + 1)( 0.0 )\n        val\
    \ ys = Vector.fill(n + 1)( 0.0 )\n        for (i <- 0 to n - 1 ) {\n         \
    \   val x1 = (i + 1) * xMax\n            x(x1 + 1) = x1 + 1\n            x(x1)\
    \ = x1 \n            val y1 = (i + 1) * yMax\n            y(y1 + 1) = y1 + 1\n\
    \            y(y1) = y1 \n        }\n        x(xMax) = 0\n        y(yMax) = 0\n\
    \        for (i <- 0 to n) {\n            if (x(i) > xMin) {\n               \
    \ for (j <- 0 to n) {\n                    if (j == i) {\n                   \
    \     continue\n                    }\n                    val x1 = (i + 1) *\
    \ xMax\n                    val y1 = (i + 1) * yMax\n                    if (x(i)\
    \ < x(x(x1 + 1)) && x(j) < x(x(x1 + 1))) {\n                        if ((y(j)\
    \ < y(y(y1 + 1)) && y(i) < y(y(y1 + 1))) || (y(i) < y(y(y1 + 1)) && y(j) < y(y(y1\
    \ + 1))) || (x(i) < x(x(x1 + 1)) && y(i) < y(y(y1 + 1))) || (x(j) < x(x(x1 + 1))\
    \ && y(j) < y(y(y1 + 1))))) {\n                            x(x1 + 1) = x(j + 1)\
    \ + 1\n                            x(x1) = x(j)\n                            y(y1\
    \ + 1) = y(i) + 1 \n                            y(y1) = y(i)\n               \
    \         }\n                    }\n                }\n            }\n       \
    \ }\n        for (i <- 0 to n - 1) {\n            for (j <- 0 to n - 1) {\n  \
    \              if (i == j) {\n                    continue\n                }\n\
    \                val x1 = (i + 1) * xMax\n                val y1 = (i + 1) * yMax\n\
    \                if (x(i) < x(x(x1 + 1)) && x(j) < x(x(x1 + 1))) {\n         \
    \           if (y(i) < y(y(y1 + 1)) && y(j) < y(y(y1 + 1))) {\n              \
    \          if ((x(i) < xMin) || (x(i) > xMax) || (y(i) < yMin) || (y(i) > yMax))\
    \ {\n                            xMinNew = x(i) \n                           \
    \ y", "        val carsLeft = Array(n).map(i => i)\n        val carsRight = Array(n).reverse.map(i\
    \ => i)\n        var collisions = 0\n        for (car <- carsLeft) {\n       \
    \     if (carsRight.exists(car => car.x < car.x + car.width)) {\n            \
    \    collisions = collisions + 1\n            }\n        }\n        return collisions",
  "        val cars = scala.collection.mutable.ArrayBuffer.fill(n)(0)\n        cars(0)\
    \ = 1\n\n        val maxSpeed = 0\n        for (i <- 1 to n) {\n            val\
    \ speed = cars(i-1) * 10\n            if (speed > maxSpeed) maxSpeed = speed\n\
    \        }\n        val startTime = System.nanoTime()\n        var collision =\
    \ 0\n\n        for (i <- 1 to n) {\n            val speed = cars(i-1) * 10\n \
    \           val newSpeed = speed + maxSpeed\n            if (newSpeed > maxSpeed)\
    \ newSpeed = maxSpeed\n            val leftMostCar = i\n            val rightMostCar\
    \ = n\n            val collisionCar = cars(i)\n\n            while (collisionCar\
    \ != 0 && collisionCar != i) {\n                val leftSpeed = (cars(leftMostCar)\
    \ * 10 - collisionCar) * 10\n                val rightSpeed = (cars(rightMostCar)\
    \ * 10 - collisionCar) * 10\n\n                if (leftSpeed > rightSpeed) {\n\
    \                    newSpeed += maxSpeed\n                    leftMostCar -=\
    \ 1\n                    rightMostCar -= 1\n                    collisionCar =\
    \ cars(i)\n                } else {\n                    newSpeed -= maxSpeed\n\
    \                    leftMostCar += 1\n                    rightMostCar += 1\n\
    \                    collisionCar = cars(i)\n                }\n            }\n\
    \            collision = collision + 1\n            cars(i) = newSpeed\n     \
    \   }\n\n        val endTime = System.nanoTime()\n        val timeDiff = endTime\
    \ - startTime\n        val nanoSecs = timeDiff.toLong * 1000000\n        println((collision\
    \ * 10) / timeDiff)\n        collision", "        val distances : MutableSet[Long]\
    \ = mutable.Set()\n        (1 to n).foreach(i => distances += i)\n        (1 to\
    \ n).foreach(i => distances += n - i)\n        distances.filter(distance => distance.product((distance\
    \ + 1)) == distance.product((distance - 1)))", "        var count = 0\n      \
    \  for(i <- 0 until n){\n            for(j <- 0 until n){\n                if\
    \ (i != j){\n                    val startPos = i\n                    val endPos\
    \ = j\n                    val distance = math.abs(endPos - startPos)\n      \
    \              val vel = Math.abs((startPos * endPos))\n                    if\
    \ (distance > vel) {\n                        count += math.abs(distance-vel)\n\
    \                    }\n                }\n            }\n        }\n        count",
  "      val speed = 2.0\n      val numCollisions = 0L\n      val collisionDistance\
    \ = 2.0\n      val minDist = collisionDistance * n\n      val maxDist = collisionDistance\
    \ * n / 2\n      val maxSpeed  = 3.0\n      val cars: Vector[Car] = new Vector[Car](n)\n\
    \      val collisions: mutable.Set[Car] = mutable.Set()\n      for (i <- 1 to\
    \ n) {\n        // Generate n cars.\n        cars += new Car()\n      }\n\n  \
    \    // Find collisions while moving left to right.\n      var x = speed\n   \
    \   val carLeft = cars.head\n      val carRight = cars(n-1)\n      var collide\
    \ = false\n      val maxLoops = n * (n-1)/2\n      val dist = maxLoops * collisionDistance\n\
    \      for (i <- 1 to maxLoops) {\n        val carLeft = cars.head\n        val\
    \ carRight = cars(n-1)\n        val collision = if (carLeft.collidesWith(carRight))\
    \ {\n          // Collision detected.\n          collisions += carLeft\n     \
    \     collisions += carRight\n          numCollisions += 1\n          collide\
    \ = true\n        }\n        x += speed\n        if (x-collisionDistance <= minDist)\
    \ {\n          break\n        }\n      }\n      // Find collisions while moving\
    \ right to left.\n      x = speed\n      val carLeft = cars(0)\n      val carRight\
    \ = cars(n-1)\n      collide = false\n      val maxLoops = n * (n-1)/2\n     \
    \ val dist = maxLoops * collisionDistance\n      for (i <- 1 to maxLoops) {\n\
    \        val carLeft = cars(0)\n        val carRight = cars(n-1)\n        val\
    \ collision = if (carRight.collidesWith(carLeft)) {\n          // Collision detected.\n\
    \          collisions += carLeft\n          collisions += carRight\n         \
    \ numCollisions += 1\n          collide = true\n        }\n        x += speed\n\
    \        if (x-collisionDistance <= minDist) {\n          break\n        }\n \
    \     }\n      // Make sure a car has collided.\n      if (collide) {\n      \
    \  collisions += carLeft\n        collisions += carRight\n        numCollisions\
    \ += 1\n      }\n      numCollisions", "        def collide(car : Car) : Boolean\
    \ = car.position.left < 0 || car.position.right > 0\n        def collide(otherCar\
    \ : Car) : Boolean = otherCar.position.left < 0 || otherCar.position.right > 0\n\
    \        val startLeft = Car(0,0,0)\n        val startRight = Car(0,0,0)\n   \
    \     val endLeft = Car(0,0,0)\n        val endRight = Car(0,0,0)\n        var\
    \ collided = false\n        var count = 0\n        for(x <- 0 to n by 1){\n  \
    \          val car = Car(x.toDouble,0,0)\n            if(collide(car))\n     \
    \           collided = true\n            else\n                count += count\n\
    \            if(car.position.left == 0 && car.position.right == 0)\n         \
    \       startLeft = car\n            if(car.position.right == 0 && car.position.left\
    \ == 0)\n                startRight = car\n            if(car.position.left ==\
    \ 0 && car.position.right == 0)\n                endLeft = car\n            if(car.position.right\
    \ == 0 && car.position.left == 0)\n                endRight = car\n        }\n\
    \        if(collided)\n            carRaceCollision(count+1)\n        else\n \
    \           count", "        // Find the distance between any pair of cars (both\
    \ left and right)\n        val carDistance = (100 * (1 - Math.sqrt(2 * Math.pow(100,\
    \ (n + 1)) / n)))\n        val pairs = mutable.Stack[Long]()\n        // Find\
    \ pairs that collide with each other.\n        for (i <- 1 to n) pairs.push(i)\n\
    \        while (!pairs.isEmpty) {\n            val i = pairs.pop()\n         \
    \   val j = pairs.pop()\n            if (i != j) {\n                val d = carDistance\
    \ / Math.sqrt(\n                    Math.pow(carDistance, 2) +\n             \
    \       Math.pow((carDistance / 100), 2) +\n                    Math.pow((carDistance\
    \ / 100), 2))\n                if (i < j) {\n                    pairs.push(j)\n\
    \                    pairs.push(i)\n                } else {\n               \
    \     pairs.push(i)\n                    pairs.push(j)\n                }\n  \
    \          }\n        }\n        pairs.length", "        val map = new mutable.HashMap[Long,\
    \ Long]\n        val numCollisions = 0\n        for (i <- 0 until n) {\n     \
    \       val collision = i\n            val x = math.abs(i + 1)\n            val\
    \ y = math.abs(n - i)\n            var x1 = -math.abs(i + 1)\n            var\
    \ y1 = -math.abs(n - i)\n            for (j <- 0 until n) {\n                val\
    \ collision2 = j\n                val x2 = math.abs(i + 1)\n                val\
    \ y2 = math.abs(n - j)\n                val speed = (math.sqrt(x1 * x1 + y1 *\
    \ y1) + math.sqrt(x2 * x2 + y2 * y2)) / 2\n                if (((x1 * x1 + y1\
    \ * y1) < (x2 * x2 + y2 * y2)) && ((j * j + i * i) < (n - j - i))) numCollisions\
    \ += 1\n                x1 = x2\n                y1 = y2\n            }\n    \
    \        map.put(collision, collision2)\n        }\n        return numCollisions",
  "        val s = math.pow(2, n) - 1\n        var count = 0\n        var last = -1\n\
    \        var c = 0\n        while (last<n) {\n            c = c + 1\n        \
    \    last = c * s\n            count = count + math.pow(2, n-last)\n        }\n\
    \        count", "        val cars = List.fill(2*n)(Car())\n        cars.foreach(_.setSpeed(0))\n\
    \        val collided = mutable.Set.empty[Long]\n        val collidedLeftToRight\
    \ = mutable.Set.empty[Long]\n        val collidedRightToLeft = mutable.Set.empty[Long]\n\
    \        val collisions = mutable.Set.empty[Long]\n        while(collided.size\
    \ < n ) {\n            cars.foreach{ c => c.driveLeft }\n            cars.foreach{\
    \ c => c.driveRight }\n            collided.clear\n            collidedLeftToRight.clear\n\
    \            collidedRightToLeft.clear\n            collisions.clear\n       \
    \     for(i <- 0 until n-1){\n                for(j <- i+1 until n){\n       \
    \             val collided = cars.map( car => car.collide(i ,j) ).exists(_)\n\
    \                    if(!collided) {\n                        collided.add(j)\n\
    \                    }\n                    val collidedLeftToRight = cars.map(\
    \ car => car.collide(i,j-1) ).exists(_)\n                    if(!collidedLeftToRight)\
    \ {\n                        collidedLeftToRight.add(j)\n                    }\n\
    \                    val collidedRightToLeft = cars.map( car => car.collide(j-1,j)\
    \ ).exists(_)\n                    if(!collidedRightToLeft) {\n              \
    \          collidedRightToLeft.add(j)\n                    }\n               \
    \ }\n            }\n            collided.foreach( collided => collisions.add(collided)\
    \ )\n            collidedLeftToRight.foreach( collidedLeftToRight => collisions.add(collidedLeftToRight)\
    \ )\n            collidedRightToLeft.foreach( collidedRightToLeft => collisions.add(collidedRightToLeft)\
    \ )\n        }\n        collisions.size", "        val initialPositions = mutable.ListBuffer.empty[Array[Int]]\n\
    \        for (i <- 1 to n) {\n            val position = new Array[Int](n+1)\n\
    \            position(0) =  0\n            position(1) = i\n            position(i)\
    \ = n\n            initialPositions += position\n        }\n        val finalPositions\
    \ = mutable.ListBuffer.empty[Array[Int]]\n        for (i <- 1 to n) {\n      \
    \      val position = new Array[Int](n+1)\n            position(0) =  n\n    \
    \        position(1) = i\n            position(i) = n\n            finalPositions\
    \ += position\n        }\n\n        val moves = mutable.ListBuffer.empty[Array[Int]]\n\
    \        for (i <- 1 to n) {\n            val position = new Array[Int](n+1)\n\
    \            position(0) =  n\n            position(1) = 0\n            position(i)\
    \ = n\n            moves += position\n        }\n        val collisions = mutable.ListBuffer.empty[Int]\n\
    \n        val collisions = initialPositions.groupBy(_(0)).map{case (k, v) => (k(0),\
    \ v.toSet)}.toMap\n\n        for (positions <- finalPositions) {\n           \
    \ if (collisions.contains(positions))\n                collisions += \"collision\"\
    \n        }\n        collisions.toSet.size", "        var sum = 0\n        var\
    \ maxSpeed = n\n        var count = 0\n        var x = 0\n        var y = 0\n\
    \        var speed = 0\n        while(maxSpeed>1){\n            speed = rand.nextInt(maxSpeed)+1\n\
    \            while (speed>1){\n                x += 1\n                speed-=1\n\
    \            }\n            while(speed<-1){\n                x -= 1\n       \
    \         speed += 1\n            }\n            y += 1\n            sum += speed\n\
    \            while (y>1){\n                y -= 1\n                sum -= speed\n\
    \            }\n            while (y<-1){\n                y += 1\n          \
    \      sum += speed\n            }\n            maxSpeed -= 1\n            count\
    \ = count + 1\n        }\n        sum", "        val road = mutable.ArrayBuffer[Long]()\n\
    \        for (a <- 1 to n){\n            val b = n\n            road += b\n  \
    \      }\n        road.lastOption.foreach {\n            case Some(_) => return\
    \ road.length\n        }\n        return 0", "        val sets = ListBuffer[Long]()\n\
    \        var i = -1\n        while (i < n) {\n            var j = n-1\n      \
    \      while (j > i) {\n                if (i != j && distance(i-1,j,i-1,j) <=\
    \ distance(i,j,i,j))\n                    sets += distance(i-1,j,i-1,j) - 1\n\
    \                j += 1\n            }\n            i += 1\n        }\n      \
    \  sets.size", "        var collisions = 0L\n        for (i <- 1 to n) {\n   \
    \         val leftCar = i\n            for (j <- i until n) {\n              \
    \  val rightCar = j\n                if (math.abs(leftCar % 100 - rightCar % 100)\
    \ < 2) {\n                    val d = math.pow((leftCar % 100 - rightCar % 100),\
    \ 2)\n                    val d = math.sqrt(d)\n                    if (d < 2)\
    \ {\n                        collisions += 1L\n                    }\n       \
    \         }\n            }\n        }\n        collisions", "        // The length\
    \ of the road.\n        val L = 10000\n\n        // We need to keep track of what\
    \ cars are colliding.\n        val collisions = mutable.ListBuffer[Long]()\n\n\
    \        // We'll keep track of the cars that collide with the previous car.\n\
    \        var lastCollision = 0L\n\n        // Let's add one car per iteration\
    \ and start moving right to left.\n        for(car <- 1 to n) {\n            val\
    \ newCollision: Long = 0L\n            var carPos = L\n\n            // We'll\
    \ do this with nested for loops to get an intuition about what\n            //\
    \ the nested for loops do.  The outer loop keeps track of what car\n         \
    \   // is on the left side of the road, and the inner loop keeps track\n     \
    \       // of what car collides with the previous car.\n            for(carPos\
    \ <- 1 to L) {\n                // The current position of the car is stored as\
    \ a long\n                // to ensure we don't get a type mismatch due to integer\
    \ promotion.\n                var currentCarPos = carPos\n\n                //\
    \ We'll keep track of what cars collide with the previous car\n              \
    \  // that we're checking.\n                for(carPos <- 1 to L) {\n        \
    \            val carPosDifference = currentCarPos - carPos\n                 \
    \   // We'll call this a collision when the current car\n                    //\
    \ is one unit away from the previous car.\n                    if(math.abs(carPosDifference)\
    \ <= 1) {\n                        newCollision += 1L\n                    }\n\
    \                    carPos += 1\n                }\n                carPos +=\
    \ 1\n                currentCarPos += 1\n\n                // We'll add this new\
    \ collision to the collisions list\n                // so that we can keep track\
    \ of them.\n                collisions += newCollision\n            }\n      \
    \  }\n\n        // Finally, we'll add up all of the collisions to get the answer.\n\
    \        lastCollision = collisions.sum\n        lastCollision", "        var\
    \ count=0\n        for (i <- 1 to n) {\n            var isLeft = true\n      \
    \      var isRight = true\n            while (isLeft || isRight) {\n         \
    \       isLeft = !isLeft\n                isRight = !isRight\n               \
    \ if (isLeft && isRight) {\n                    count+=1\n                }\n\
    \            }\n        }\n        count", "       val collisions = mutable.Set[Long]()\n\
    \       for( i <- 1 to n){\n         var i = 0\n         for(j <- i+1 to n){\n\
    \           val collidedLeftToRight = checkCollision(i, j)\n           val collidedRightToLeft\
    \ = checkCollision(j, i)\n           if((collidedLeftToRight && collidedRightToLeft))\n\
    \             collisions.add(i)\n           if((collidedRightToLeft && collidedLeftToRight))\n\
    \             collisions.add(j)\n         }\n       }\n       collisions.size",
  "        val x = Array.fill(2 * n)(Array(0.0,0.0))\n        val y = Array.fill(2\
    \ * n)(Array(0.0,0.0))\n        val s = Array.fill(2 * n)(1.0)\n        val r\
    \ = Array.fill(2 * n)(0.0)\n        val w = Array.fill(2 * n)(0.0)\n        val\
    \ v = Array.fill(2 * n)(0.0)\n        val c = Array.fill(2 * n)(0.0)\n       \
    \ val a = Array.fill(2 * n)(0.0)\n        val d = Array.fill(2 * n)(0.0)\n   \
    \     val l = Array.fill(2 * n)(0.0)\n        val p = Array.fill(2 * n)(0.0)\n\
    \        val t = Array.fill(2 * n)(0.0)\n        val q = Array.fill(2 * n)(0.0)\n\
    \        val y = Array.fill(2 * n)(0.0)\n        val m = Array.fill(2 * n)(0.0)\n\
    \        val h = Array.fill(2 * n)(0.0)\n        val n = Array.fill(2 * n)(0.0)\n\
    \        val x = Array.fill(2 * n)(0.0)\n        val r = Array.fill(2 * n)(0.0)\n\
    \        val s = Array.fill(2 * n)(0.0)\n        val w = Array.fill(2 * n)(0.0)\n\
    \        val v = Array.fill(2 * n)(0.0)\n        val c = Array.fill(2 * n)(0.0)\n\
    \        val a = Array.fill(2 * n)(0.0)\n        val d = Array.fill(2 * n)(0.0)\n\
    \        val l = Array.fill(2 * n)(0.0)\n        val p = Array.fill(2 * n)(0.0)\n\
    \        val t = Array.fill(2 * n)(0.0)\n        val q = Array.fill(2 * n)(0.0)\n\
    \        val y = Array.fill(2 * n)(0.0)\n        val m = Array.fill(2 * n)(0.0)\n\
    \        val h = Array.fill(2 * n)(0.0)\n        val n = Array.fill(2 * n)(0.0)\n\
    \        val x = Array.fill(2 * n)(0.0)\n        val r = Array.fill(2 * n)(0.0)\n\
    \        val s = Array.fill(2 * n)(0.0)\n        val w = Array.fill(2 * n)(0.0)\n\
    \        val v = Array.fill(2 * n)(0.0)\n        val c = Array.fill(2 * n)(0.0)\n\
    \        val a = Array.fill(2 * n)(0.0)\n        val d = Array.fill(2 * n)(0.0)\n\
    \        val l = Array.fill(2 * n)(0.0)\n        val p = Array.fill(2 * n)(0.0)\n\
    \        val t = Array.fill(2 * n)(0.0)\n        val q = Array.fill(2 * n)(0.0)\n\
    \        val y = Array.fill(2 * n)(0.0)\n        val m = Array.fill(2 * n)(0.0)\n\
    \        val h = Array.fill(2 * n)(0.0)\n        val n = Array.fill(2 * n)(0.0)\n\
    \        val x = Array.fill(2 * n)(0.0)\n        val r = Array.", "        val\
    \ roadLength = n / 2 \n        val roadLength = roadLength.toInt\n        val\
    \ collisionCount = 0\n        val road = mutable.ListBuffer[Int](0)\n        road.foreach\
    \ { road.append }\n        for (i <- 0 to roadLength) {\n            road(i) =\
    \ i\n            road(i+1) = road(i) + n\n            road(i+2) = road(i+1) +\
    \ n\n        }\n        road.foreach { x =>\n            road.foreach { y => if\
    \ (x == y) { collisionCount += 1 } }\n        }\n        collisionCount", "  \
    \      // The cars start out at a high speed\n        var vx = 400L\n        var\
    \ vy = 400L\n        var vz = 400L\n        // A car starts out being stationary.\
    \  It moves in direction that it starts\n        var direction = (vx, vy, vz)\n\
    \        // A map to keep track of cars that have collided with each other\n \
    \       var collided = mutable.Map.empty[Long, Long]\n        var i = 0\n    \
    \    // While there are cars still moving left to right\n        while (i < n)\
    \ {\n            // Update position of cars until they hit the other side\n  \
    \          var nextVx = direction._1\n            var nextVy = direction._2\n\
    \            var nextVz = direction._3\n            while (true) {\n         \
    \       // Calculate distance from current position\n                var vDist\
    \ = Math.sqrt(Math.pow(nextVx - vx, 2) + Math.pow(nextVy - vy, 2) + Math.pow(nextVz\
    \ - vz, 2))\n                if (vDist > 20L) {\n                    // Car has\
    \ moved past the wall\n                    vx = nextVx\n                    vy\
    \ = nextVy\n                    vz = nextVz\n                } else {\n      \
    \              // Car has stopped moving past the wall, is at current position\n\
    \                    break;\n                }\n                nextVx += vx *\
    \ 0.1\n                nextVy += vy * 0.1\n                nextVz += vz * 0.1\n\
    \            }\n            // Check if car has collided with anyone\n       \
    \     if (collided.contains(i)) {\n                // Yes, it has collided with\
    \ at least one other car\n                // It must be the one whose next position\
    \ will be next\n                // So update next\n                var nextVx\
    \ = direction._1\n                var nextVy = direction._2\n                var\
    \ nextVz = direction._3\n                while (true) {\n                    //\
    \ Calculate distance from current position\n                    var vDist = Math.sqrt(Math.pow(nextVx\
    \ - vx, 2) + Math.pow(nextVy - vy, 2) + Math.pow(nextVz - vz, 2))\n          \
    \          if (vDist > 20L) {\n                        // Car has moved past the\
    \ wall\n                        vx = nextVx\n                        vy = nextVy\n\
    \                        vz = nextVz\n                    } else {\n         \
    \               // Car has stopped moving past the wall, is at current position\n\
    \                        break;\n                    }\n                    nextVx\
    \ += vx * 0.1\n                    nextVy += vy * 0.1\n                    nextVz\
    \ += vz * 0.1\n                }\n            } else {\n                // No\
    \ one has collided with this car.\n                // It must be the one next\
    \ to the current one\n                collided(i) = i + 1\n                vx\
    \ += 1\n                vy += 1\n                v", "        // The distance\
    \ from one car point to the next.\n        var distanceToNext = Long.MaxValue\n\
    \n        // The set of points from one car point to the next.\n        var pointsToNext\
    \ = mutable.Set.empty[Long]\n\n        // For each pair of cars, calculate the\
    \ distance between them.\n        for (i <- 0 to (n-2))\n            for (j <-\
    \ (i+1) until n)\n                distanceToNext += math.abs(carDistance(i, j))\n\
    \        // Add a point to the points set.\n        pointsToNext += distanceToNext\n\
    \n        // If two cars collide, they must travel at the same speed or else they\
    \ would\n        // collide again.  So calculate the minimum distance they travel\
    \ at a time.\n        var minDistance = Long.MaxValue\n        for (a <- 0 to\
    \ (n-2))\n            for (b <- (a+1) until n)\n                minDistance =\
    \ math.min(minDistance, carDistance(a, b))\n        // If no two cars collide,\
    \ return 0.\n        if (minDistance == Long.MaxValue) 0\n        // Otherwise,\
    \ return the number of collisions.\n        else minDistance.minus(distanceToNext).times(n).toLong",
  "        var nCollisions = 0L\n        val carsLeft = List.fill(n)(List(0))\n  \
    \      val carsRight = List.fill(n)(List(0))\n        for (i <- 0 to (n-1)) {\n\
    \            // The cars are moving left and right.\n            // Assume they\
    \ move to equal positions and have equal velocities.\n            val carLeft\
    \ = carsLeft.filter(_._2 == i).head\n            val carRight = carsRight.filter(_._2\
    \ == i).head\n            val vLeft = carLeft._1\n            val vRight = carRight._1\n\
    \            // If one of the cars is moving left to right, the other is moving\
    \ right to left.\n            val collision = if((carLeft._2 < 0 && vRight < 0)\
    \ || (carRight._2 < 0 && vLeft < 0)) 1 else 0L\n            nCollisions += collision\n\
    \        }\n        nCollisions", "        val xs = mutable.List.fill(n)(math.random)\n\
    \        val ys = mutable.List.fill(n)(math.random)\n        var count = 0\n \
    \       for (xi <- xs.indices) {\n            count += if (xs(xi) < xs(xs.size\
    \ - 1)) 1 else 0\n        }\n        for (yi <- ys.indices) {\n            count\
    \ += if (ys(yi) < ys(ys.size - 1)) 1 else 0\n        }\n        count", "    \
    \    val left = new scala.collection.mutable.ArrayBuffer(n).init\n        val\
    \ right = new scala.collection.mutable.ArrayBuffer(n).init\n        val collisions\
    \ = 0\n        while (!left.isEmpty) {\n            val leftTail = left.tail\n\
    \            val rightHead = right.head\n            if (leftTail.head == rightHead.head)\
    \ {\n                collisions += 1\n                left.remove(leftTail.head)\n\
    \                right.remove(rightHead.head)\n            }\n        }\n    \
    \    collisions", "        // The two sets of cars start out being very far from\
    \ each other.\n        var xDiff = (-1l).abs - (-1l).abs\n        var yDiff =\
    \ (-1l).abs - (-1l).abs\n        // The number of collisions is zero.\n      \
    \  var numCollide = 0\n        // The number of collisions is zero.\n        var\
    \ xVelocity = 0\n        var yVelocity = 0\n        var xSpeed = 0\n        var\
    \ ySpeed = 0\n        var x = 0\n        var y = 0\n        var xD = 0\n     \
    \   var yD = 0\n        var yN = 0\n        var xN = 0\n        var i = 0\n  \
    \      var j = 0\n        for (i <- 1 to n) {\n            // The cars on the\
    \ left side of the line initially start out very far from each other.\n      \
    \      xD = math.min(xDiff, ((-1l).abs - (-1l).abs - (xDiff * (i + 0.5)) / i)\
    \ / 2)\n            xD = math.max(xDiff * (i + 0.5), xD)\n            yD = math.min(yDiff,\
    \ ((-1l).abs - (-1l).abs - (yDiff * (i + 0.5)) / i) / 2)\n            yD = math.max(yDiff\
    \ * (i + 0.5), yD)\n            // The cars on the left side of the line are moving\
    \ left to right.\n            xN = (i * xD) / n\n            yN = (i * yD) / n\n\
    \            // The cars on the right side of the line are moving right to left.\n\
    \            xD = (-1l).abs - (-1l).abs + (i * xD) / n\n            yD = (-1l).abs\
    \ - (-1l).abs + (i * yD) / n\n            // The cars on the right side of the\
    \ line are moving right to left.\n            x = (-1l).abs - (-1l).abs + xN\n\
    \            y = (-1l).abs - (-1l).abs + yN\n            // The cars on the right\
    \ side of the line initially start out very far from each other.\n           \
    \ xVelocity = math.sqrt((x - xD) * (x - xD) + (y - yD) * (y - yD))\n         \
    \   xSpeed = math.sqrt((xN - xVelocity) * (xN - xVelocity) + (yN - yVelocity)\
    \ * (yN - yVelocity))\n            // The cars on the right side of the line are\
    \ moving left to right.\n            yVelocity = math.sqrt((x - xD) * (x - xD)\
    \ + (y - yD) * (y - yD))\n            ySpeed = math.sqrt((yN - yVelocity) * (yN\
    \ - yVelocity) + (xN - xVelocity) * (xN - xVelocity))\n            // The cars\
    \ on the right side of the line are moving right ", "        // TODO: Replace\
    \ the following lines with solution\n        val maxSpeed = 300 // Speed at which\
    \ cars stop moving\n        var c = 0\n        for (j <- 0 until n) {\n      \
    \      // For every car in range [0, n), find the car in range (n-j, j+1)\n  \
    \          // that has the largest speed less than or equal to the current car.\n\
    \            val c = j\n            for (i <- j+1 to n) {\n                val\
    \ speed = math.abs(i - j)\n                if ((speed < maxSpeed) && Math.abs(speed\
    \ - speed) <= maxSpeed) {\n                    c += 1\n                }\n   \
    \         }\n        }\n        c", "        val leftCars = mutable.ListBuffer[String]()\n\
    \        val rightCars = mutable.ListBuffer[String]()\n        val collide = mutable.ListBuffer[String]()\n\
    \        for (i<- 1 until n) {\n            val nextCar = i - 1\n            val\
    \ prevCar = n - i\n            val car = i.toString\n            val rightCar\
    \ = nextCar.toString\n            val leftCar = prevCar.toString\n           \
    \ if (!leftCars.contains(leftCar)) {\n                leftCars += leftCar\n  \
    \              if (!rightCars.contains(rightCar)) {\n                    rightCars\
    \ += rightCar\n                    if (rightCars.contains(leftCar)) {\n      \
    \                  collide += car\n                    }\n                }\n\
    \            }\n        }\n        collide.size", "        // Create a map from\
    \ the initial state to the states after collision.\n        val initial = Map(0\
    \ -> List(\n            Car(Vector(0, 0),0),Vector(0,-1),Vector(0,-1)))\n    \
    \    val after = mutable.Buffer.empty[Car]\n        // For each car in the initial\
    \ state, find the set of cars to update with colliding cars.\n        var newCars\
    \ = initial.keys.filter{_ <- 0 until n}.toList\n        while(newCars.length >\
    \ 0) {\n            var collisions : List[Car] = ListBuffer.empty[Car]\n     \
    \       var car : Car = null\n            for (newCar <- newCars) {\n        \
    \        car = newCar\n                val cars = initial.filter(_._1 != car).map(_._2).distinct\n\
    \                collisions = collisions.filter(_._1 == car)\n               \
    \ for (c <- cars) {\n                    val newCar = c(0)\n                 \
    \   val newCarPos = c(1)\n                    val newVelocity = c(2)\n       \
    \             val newAcceleration = c(3)\n                    val collision =\
    \ carRaceCollision(n - 1)\n                    val newCollision = carRaceCollision(collision)\n\
    \                    val newCarToInsert = Car(newCarPos, newVelocity, newAcceleration,\
    \ collision)\n                    after.append(newCarToInsert)\n             \
    \   }\n                newCars = newCars.filter{_ <- 0 until newCollision}\n \
    \           }\n            collisions = collisions.filter(_._1 == car)\n     \
    \       newCars = newCars.filter{_ <- 0 until collisions.max}\n            collisions\
    \ = collisions.filter(_._1 == car)\n            newCars = newCars.filter{_ <-\
    \ 0 until collisions.min}\n            after.filter{_ <- 0 until newCars.length}\n\
    \        }\n        after.size", "        var car : Int = 1\n        var collisions\
    \ : Long = 0\n        for (i <- 1 to n) {\n            if (car < n) {\n      \
    \          val x1 : Double = Math.abs(car - i) / n\n                val x2 : Double\
    \ = Math.abs(n - car) / n\n                val diff : Double = x2 * x1\n     \
    \           if (diff > 0) {\n                    val collision : Int = Math.round((x1\
    \ + x2) / 2)\n                    collisions = collisions + collision\n      \
    \          }\n            }\n            car += 1\n        }\n        return collisions",
  "        var i : Long = 0\n        var v : Vector[Long] = Vector.fill(24)(0)\n \
    \       var cars : Array[Long] = Array.fill(n)(i)\n        var c1 = cars(0)\n\
    \        var c2 = cars(n)\n\n        // The first and last cars, respectively,\
    \ should not collide.\n        if (n <= 1) return 0\n        if (cars(0) != c1\
    \ || cars(n) != c2) return 0\n        if (i < n) return 1\n\n        for(i in\
    \ 1..(n-1)) {\n            v = Vector(cars(i-1),cars(i),cars(i+1),cars(i+2))\n\
    \            if ( v.length == 2 ) return 0\n            if ( Vector.cross(v,v)\
    \ == Vector.unit ) return 0\n        }\n        return 1", "        // Use a list\
    \ of size n to keep track of all the cars.\n        var cars = List.fill(n)(new\
    \ Car())\n        cars foreach (_.start())\n        // Start two threads to handle\
    \ two directions of the same car.\n        val leftCars = ListBuffer(cars.takeRight(1))\n\
    \        val rightCars = ListBuffer(cars.dropRight(1))\n        val left = Thread.start\
    \ {\n            val car1 = cars.remove(leftCars.head).get\n            val car2\
    \ = cars.remove(rightCars.head).get\n            cars.reverse.foreach {car =>\n\
    \                car.handleCollision(car1, car2)\n            }\n        }\n \
    \       val right = Thread.start {\n            val car1 = cars.remove(rightCars.head).get\n\
    \            val car2 = cars.remove(leftCars.head).get\n            cars.reverse.foreach\
    \ {car =>\n                car.handleCollision(car1, car2)\n            }\n  \
    \      }\n        // Wait for the left and right cars to finish.\n        left.join()\n\
    \        right.join()\n        cars.size", "        val collisions = 0\n     \
    \   val v1 = Vector(0.0, 1.0, 2.0)\n        val v2 = Vector(0.0, -1.0, 2.0)\n\
    \        for (i <- 0 until n) {\n            val i1 = i / n\n            val i2\
    \ = i % n\n            val f1 = i1 * v1\n            val f2 = i2 * v2\n      \
    \      val d = f1 dot f2\n            if (d > 0.0)\n                collisions\
    \ += 1\n        }\n        return collisions", "        val road = for(i <- 1\
    \ to n) yield i\n        val other = road.diff(road.init)\n        val collisions\
    \ = mutable.Set[Int]()\n        for (i <- 1 to road.size) {\n            // Collision\
    \ happens when a car collides with its neighbor.\n            for (j <- 1 to road.size)\
    \ {\n                // The collision happens when (i,j) collides with any other\
    \ element (j,k).\n                val collision = (road(i) > road(j) || road(i)\
    \ < road(j)) &&\n                    (road(i) != road(j) && road(j) != road(k))\n\
    \                if (collision)\n                    collisions += road(i)\n \
    \           }\n        }\n        collisions.size", "        val set = scala.collection.mutable.Set[Long]()\n\
    \        // Add all n integers to the set.  For this problem we won't be calculating\
    \ integers\n        // in reverse order.\n        val integers = scala.collection.mutable.Set[Long]()\n\
    \        for (i <- 0 until n)\n            integers.add(i)\n        integers.foreach\
    \ { i => set += i }\n\n        // Now, for every pair of integers, calculate how\
    \ much \"distance\" there is between them.\n        val collisions = scala.collection.mutable.Set[Long]()\n\
    \        integers.foreach { i1 =>\n            integers.foreach { i2 =>\n    \
    \            collisions += math.abs(i1 - i2)\n            }\n        }\n\n   \
    \     collisions.size // Return the number of collisions", "        var collide\
    \ = 0L\n        var count = 0L\n        for( i <- 0 until n ) {\n            val\
    \ l = (i % 2) == 0\n            var r = 0\n            for( j <- 0 until n ) {\n\
    \                val r = (j % 2) == 0\n                if( l && r ) {\n      \
    \              count = 1L\n                    if( j > i ) {\n               \
    \         collide = collide + 1L\n                    }\n                } else\
    \ {\n                    if( l && !r ) {\n                        collide = collide\
    \ + 1L\n                    }\n                }\n            }\n        }\n \
    \       count", "        val speed = 20\n        val distance = 10\n        val\
    \ distances = Array.fill(n)(distance)\n        val speeds = Array.fill(n)(speed)\n\
    \        val xpos = new Array[Double](n)\n        val ypos = new Array[Double](n)\n\
    \        var collisions = 0\n        // Simulate the collisions between all the\
    \ cars.\n        for(ix <- 0 until n) {\n            val jx = n - ix - 1\n   \
    \         for(iy <- 0 until n) {\n                val jy = n - iy - 1\n      \
    \          if(ix == jx || iy == jy) continue\n                xpos(ix) += iy /\
    \ n\n                ypos(iy) += (ix - iy) / n\n                distances2(ix,\
    \ iy, jx, jy)\n                distances2(jx, jy, ix, iy)\n                speed2(ix,\
    \ iy, jx, jy)\n                speed2(jx, jy, ix, iy)\n                for(d <-\
    \ 0 to distances2(ix, iy, jx, jy)) {\n                    if(speed2(ix, iy, jx,\
    \ jy) > 0) {\n                        for(d <- 0 to distances2(jx, jy, ix, iy))\
    \ {\n                            if(speed2(jx, jy, ix, iy) > 0) {\n          \
    \                      if(distance2(ix, iy, jx, jy) > distance2(jx, jy, ix, iy))\
    \ {\n                                    collisions += 1\n                   \
    \             }\n                            }\n                        }\n  \
    \                  }\n                }\n            }\n        }\n        collisions",
  "        val roadLength = n / 2.0\n        val roadSpeed = 100\n\n        val roadLength\
    \ = n / 2.0\n        val roadSpeed = 100\n\n        var collisions = 0\n\n   \
    \     for(x <- 0 until n) {\n            for(y <- 0 until n) {\n             \
    \   val x0 = x - roadLength\n                val y0 = y - roadLength\n       \
    \         val xn = x + roadLength\n                val yn = y + roadLength\n\n\
    \                val dx = x0 - xn\n                val dy = y0 - yn\n\n      \
    \          val slope = dy / dx\n\n                if(x0 > xn || x0 < xn || y0\
    \ > yn || y0 < yn)\n                    collisions += 1\n\n                val\
    \ collisionSpeed = roadSpeed * slope\n\n                val dx = x0 - xn\n   \
    \             val dy = y0 - yn\n                val xDiff = x0 - x\n         \
    \       val yDiff = y0 - y\n\n                val t0 = math.atan2(dy, dx)\n\n\
    \                val t1 = math.atan2(xDiff, yDiff)\n\n                if(math.abs(t0\
    \ - t1) < collisionSpeed)\n                    collisions += 1\n            }\n\
    \        }\n        collisions", "        // (1) The first car is car 1.\n   \
    \     val car1 = 1L\n        // (2) The last car is car n.\n        val car2 =\
    \ n\n\n        // Initialize our state as infinitely far away\n        val state\
    \ = (1L until n).toList\n        // Start with state as if there is no collisions\n\
    \        val collisions = state.foldLeft(0) { (sum, stateItem) => sum + carRaceCollision(stateItem)\
    \ }\n\n        // Go one step forward and one step backwards\n        state.lastOption\
    \ match {\n            // If we're going forward, then flip the direction of all\
    \ the cars (car2 to car1)\n            case Some(n) =>\n                val nextState\
    \ = mutable.ListBuffer.empty[Long]\n                for (car <- car2 until car1)\
    \ {\n                    nextState += carRaceCollision(state - car)\n        \
    \        }\n                nextState.last\n            // If we're going backwards,\
    \ flip back the direction of all the cars (car1 to car2)\n            case None\
    \ =>\n                val nextState = mutable.ListBuffer.empty[Long]\n       \
    \         for (car <- car1 until car2) {\n                    nextState += carRaceCollision(state\
    \ + car)\n                }\n                nextState.last\n        }\n\n   \
    \     collisions", "        val set1 = new mutable.Set[Int]()\n        val set2\
    \ = new mutable.Set[Int]()\n        val set3 = new mutable.Set[Int]()\n      \
    \  for (i <- 1 to n){\n            set1 += i\n            set2 += n - i\n    \
    \        set3 += (n - i - 1)\n        }\n\n        val a1 = set1.toSeq\n     \
    \   val a2 = set2.toSeq\n        val a3 = set3.toSeq\n        var numCol : Long\
    \ = 0\n        for ((_a1, _a2, _a3) <- a1 zip a2 zip a3){\n            val v1\
    \ = _a1 - _a2\n            val v2 = _a2 - _a3\n            val v3 = _a3 - _a1\n\
    \            val d = (v1 * v1) + (v2 * v2)\n            if (d > 1){\n        \
    \        numCol += 1\n            }\n        }\n        numCol", "        var\
    \ count = 0L\n        var start = 0L\n        var finish = n\n        while (start\
    \ < finish) {\n            val x = start + finish/2.0\n            var count =\
    \ 0L\n            while (x < start) {\n                val y = start + finish/2.0\n\
    \                val xdiff = x - y\n                if (xdiff != 0) {\n      \
    \              count = count + 1L\n                }\n                x += 1L\n\
    \            }\n            start += 1L\n            finish -= 1L\n        }\n\
    \        count", "        val m = 100000L\n        val collided = Long.MaxValue\n\
    \        val collisions = mutable.ArrayBuffer.empty[Long]\n        val road =\
    \ mutable.Vector.fill(1000L){0 }\n        val carRight = mutable.Vector.fill(1000L){1\
    \ }\n        val carLeft = mutable.Vector.fill(1000L){1 }\n        val carsOnRoad\
    \ = mutable.ArrayBuffer.fill(1000L){0 }\n        val collision = Long.MinValue\n\
    \        road(10L + n) -= 1\n        road(100L + n) -= 1\n        road(1000L +\
    \ n) -= 1\n        road(10000L + n) -= 1\n        road(100000L + n) -= 1\n   \
    \     road(1000000L + n) -= 1\n        road(10000000L + n) -= 1\n        for (i\
    \ <- 0 until road.length){\n            if((i == 10L || i == 100L || i == 1000L\
    \ || i == 10000L || i == 100000L || i == 1000000L || i == 10000000L) && carsOnRoad(i)\
    \ == 0){\n                collision += 0\n            }\n            else if((i\
    \ == 10L || i == 100L || i == 1000L || i == 10000L || i == 100000L || i == 1000000L\
    \ || i == 10000000L) && carsOnRoad(i) != 0){\n                collision += 0\n\
    \            }\n            else if((i == 10L || i == 10L || i == 100L || i ==\
    \ 100L || i == 1000L || i == 1000L || i == 10000L || i == 10000L || i == 100000L\
    \ || i == 100000L) && carRight(i) == 1 && carLeft(i) == 1){\n                collision\
    \ += 0\n            }\n            else if((i == 10L || i == 10L || i == 100L\
    \ || i == 100L || i == 1000L || i == 1000L || i == 10000L || i == 10000L || i\
    \ == 100000L || i == 100000L) && carRight(i) == 0 && carLeft(i) == 0){\n     \
    \           collision += 0\n            }\n            else if((i == 10L || i\
    \ == 10L || i == 100L || i == 100L || i == 1000L || i == 1000L || i == 10000L\
    \ || i == 10000L || i == 100000L || i == 100000L) && carRight(i) != 1 && carLeft(i)\
    \ != 1){\n                collision += 0\n            }\n            else if((i\
    \ == 10L || i == 10L || i == 100L || i == 100L || i == 1000L || i == 1000L ||\
    \ i == 10000L || i == 10000L || i == 100000L || i == ", "        val leftToRightCollisions\
    \  = mutable.ListBuffer[Long]()\n        val rightToLeftCollisions = mutable.ListBuffer[Long]()\n\
    \        for (i <- 1 to n) { \n            val currentPosition = mutable.ListBuffer[Int]()\n\
    \            val nextPosition = mutable.ListBuffer[Int]()\n            currentPosition\
    \ += i\n            nextPosition += i\n            while (currentPosition.nonEmpty)\
    \ {\n                val lastPosition = currentPosition.last\n               \
    \ currentPosition -= lastPosition\n                nextPosition += lastPosition\n\
    \                leftToRightCollisions += (lastPosition * lastPosition)\n    \
    \            while (nextPosition.nonEmpty) {\n                    val lastPosition\
    \ = nextPosition.last\n                    nextPosition -= lastPosition\n    \
    \                currentPosition += lastPosition\n                    rightToLeftCollisions\
    \ += (lastPosition * lastPosition)\n                }\n            }\n       \
    \ }\n        val collisionCount = leftToRightCollisions.sum + rightToLeftCollisions.sum\n\
    \        collisionCount", "        val cars = Vector.fill(n / 2)(Vector.fill(2).fill(0)).tail\n\
    \        val speeds = Vector.fill(n / 2)(Vector.fill(2).fill(0))\n        val\
    \ collisions = mutable.Map.empty[Long, Long]\n        for (i <- 1 to n-1)\n  \
    \          for (j <- i until n) {\n                var collisionCount = 0\n  \
    \              for (k <- j - 1 to i)\n                    if (cars(j - 1)(k) ==\
    \ cars(k + 1)(j)) {\n                        collisionCount += 1\n           \
    \             collisions(j) = collisions(j) + k\n                        break\n\
    \                    }\n                collisions(i) = collisions(i) + j\n  \
    \              collisions(i) = collisions(i) + i\n                collisions(i)\
    \ = collisions(i) + i\n                collisions(i) = collisions(i) + i\n   \
    \             collisions(i) = collisions(i) + i\n                collisions(i)\
    \ = collisions(i) + i\n                collisions(i) = collisions(i) + i\n   \
    \             collisions(i) = collisions(i) + i\n                collisions(i)\
    \ = collisions(i) + i\n                collisions(i) = collisions(i) + i\n   \
    \             collisions(i) = collisions(i) + i\n                collisions(i)\
    \ = collisions(i) + i\n                collisions(i) = collisions(i) + i\n   \
    \             collisions(i) = collisions(i) + i\n                collisions(i)\
    \ = collisions(i) + i\n                collisions(i) = collisions(i) + i\n   \
    \             collisions(i) = collisions(i) + i\n                collisions(i)\
    \ = collisions(i) + i\n                collisions(i) = collisions(i) + i\n   \
    \             collisions(i) = collisions(i) + i\n                collisions(i)\
    \ = collisions(i) + i\n                collisions(i) = collisions(i) + i\n   \
    \             collisions(i) = collisions(i) + i\n                collisions(i)\
    \ = collisions(i) + i\n                collisions(i) = collisions(i) + i\n   \
    \             collisions(i) = collisions(i) + i\n                collisions(i)\
    \ = collisions(i) + i\n                collisions(i) = collisions(i) + i\n   \
    \             collisions(i) = collisions(i) + i\n                collisions(i)\
    \ = collisions(i) + i\n                collisions(i) = collisions(i) + i\n   \
    \             collisions(i) = collisions(i) + i\n                collisions(i)\
    \ = collisions(i) + i\n                collisions(i) = collisions(i) + i\n   \
    \             collisions(i) = collisions(i) + i\n                collisions(i)\
    \ = collisions(i) + ", "        val collisions = mutable.List.empty[Long]\n  \
    \      var collisionCount : Long = 0\n        var x : Long = 0\n        var y\
    \ : Long = 0\n        var direction = CarDirection.Right\n        var lastDirection\
    \ = CarDirection.Right\n        var carLeft = true\n        var carRight = true\n\
    \        var car = Car(50, 50, direction)\n        var cars = mutable.ListBuffer[Car]()\n\
    \        for {\n            x <- 0 until n\n            y <- 0 until n\n     \
    \   } {\n            cars += Car(x, y, direction)\n        }\n        cars.foreach(c\
    \ => {\n            // Set up directional variables\n            var xVel = c.xVel\n\
    \            var yVel = c.yVel\n            var xDir = c.xDir\n            var\
    \ yDir = c.yDir\n            if ((direction == CarDirection.Right && xDir == CarDirection.Left)\
    \ || (direction == CarDirection.Left && xDir == CarDirection.Right)) {\n     \
    \           xVel *= -1\n                xDir *= -1\n            }\n          \
    \  if ((direction == CarDirection.Right && yDir == CarDirection.Left) || (direction\
    \ == CarDirection.Left && yDir == CarDirection.Right)) {\n                yVel\
    \ *= -1\n                yDir *= -1\n            }\n            if (carLeft) {\n\
    \                xVel -= (c.yVel * yVel)\n                yVel -= (c.xVel * xVel)\n\
    \                xDir -= (c.yDir * yDir)\n                yDir -= (c.xDir * xDir)\n\
    \            }\n            if (carRight) {\n                xVel += (c.yVel *\
    \ yVel)\n                yVel += (c.xVel * xVel)\n                xDir += (c.yDir\
    \ * yDir)\n                yDir += (c.xDir * xDir)\n            }\n          \
    \  // Handle collision\n            if ((c.xVel > 0 && c.xVel < xVel) || (c.xVel\
    \ < 0 && c.xVel > xVel)) {\n                carRight = false\n            }\n\
    \            if ((c.yVel > 0 && c.yVel < yVel) || (c.yVel < 0 && c.yVel > yVel))\
    \ {\n                carLeft = false\n            }\n            if (carLeft &&\
    \ carRight) {\n                carLeft = false\n                carRight = false\n\
    \                collisionCount += 1\n                collisions += collisionCount\n\
    \            }\n            // Update car state\n            c.xVel = xVel\n \
    \           c.yVel = yVel\n            c.xDir = xDir\n            c.yDir = yDir\n\
    \        })\n        return collisionCount", "        // First, find all the possible\
    \ starting points\n        var startingPoints = findStartingPoints(n).asInstanceOf[Array[Array[Long]]]\n\
    \        // Now that we know all of the possible starting points, find the intersections\
    \ between all possible starting points\n        val collisions = findCollisions(startingPoints).asInstanceOf[Set[Long]]\n\
    \        collisions.size", "        var collisionCount : Long = 0\n        var\
    \ currentPosition : Long = 0\n        var currentDirection : Long = 0\n      \
    \  val leftDirection = Right\n        val rightDirection = Left\n        var currentSpeed\
    \ : Long = 1\n\n        for(i <- 0 to n){\n            currentPosition = i\n \
    \           currentDirection = leftDirection\n            currentSpeed = -1\n\n\
    \            for(j <- 0 to i){\n                if(currentPosition == j){\n  \
    \                  continue\n                }\n\n                if(currentDirection\
    \ == leftDirection && currentSpeed == -1){\n                    collisionCount\
    \ += 1\n                    currentDirection = rightDirection\n              \
    \      currentSpeed = currentSpeed + 1\n                }\n\n                if(currentDirection\
    \ == rightDirection && currentSpeed == -1){\n                    collisionCount\
    \ += 1\n                    currentDirection = leftDirection\n               \
    \     currentSpeed = currentSpeed + 1\n                }\n\n                if(currentDirection\
    \ == leftDirection && currentSpeed == 1){\n                    collisionCount\
    \ += 1\n                    currentDirection = rightDirection\n              \
    \      currentSpeed = currentSpeed - 1\n                }\n\n                if(currentDirection\
    \ == rightDirection && currentSpeed == 1){\n                    collisionCount\
    \ += 1\n                    currentDirection = leftDirection\n               \
    \     currentSpeed = currentSpeed - 1\n                }\n            }\n    \
    \    }\n        collisionCount", "        // If there is no solution, return zero\n\
    \        if (n < 2) return 0\n        // Initialize arrays\n        var x0 = Array.fill(6)(0)\n\
    \        var x1 = Array.fill(6)(0)\n        // Initialize variables\n        var\
    \ collisions = 0\n        // Initialize counters\n        var i = 1\n        var\
    \ j = 1\n        // Initialize a temporary variable\n        var k = 0\n     \
    \   // Initialize another temporary variable\n        var collision = 0\n    \
    \    // Initialize the arrays that are being searched\n        var x2 = Array.fill(6)(0)\n\
    \        var y2 = Array.fill(6)(0)\n        // Do one step of searching\n    \
    \    while (i < n && j < n) {\n            // Assign values to arrays\n      \
    \      x0[i - 1] = j\n            x1[i - 1] = j\n            x2[i] = j\n     \
    \       y2[i] = j\n            k = i\n            // Do one step of searching\n\
    \            while (k < n) {\n                // Increment the counter\n     \
    \           k += 1\n                // Find the collision at this point\n    \
    \            val tempCollision : Long = checkCollision(x0, x1, x2, y2, k)\n  \
    \              // Check whether this is the same as the last collision\n     \
    \           collision = if (tempCollision == collision) 0 else tempCollision\n\
    \                // Increment the number of collisions\n                collisions\
    \ += collision\n                // If this was the first collision, store its\
    \ coordinates\n                if (collision == 0) collisions = k\n          \
    \  }\n            // Set the last index\n            j = k\n            // Increment\
    \ the counter\n            i += 1\n        }\n        // Return the number of\
    \ collisions\n        collisions", "        val initialCars = mutable.ListBuffer[Long]()\n\
    \        var collisions = 0L\n        for(i <- 1 to n){\n            initialCars\
    \ += i\n        }\n        initialCars.foreach {x => \n            val initialCarsCopy\
    \ = initialCars.clone\n            for(y <- initialCarsCopy.tail){\n         \
    \       collisions += checkCarCollision(x,y)\n            }\n        }\n     \
    \   collisions", "        var collisions = 0\n        var lastX : Long = 0\n \
    \       var lastY : Long = 0\n        for (i <- 1 to n) {\n            var newX\
    \ : Long = 0\n            var newY : Long = 0\n            for (j <- 1 to n) {\n\
    \                if (i != j) {\n                    var dx = (lastX - newX)\n\
    \                    var dy = (lastY - newY)\n                    if (Math.hypot(dx,\
    \ dy) < 25) {\n                        newX += 1\n                        newY\
    \ += 1\n                        collisions += 1\n                    }\n     \
    \           }\n            }\n            lastX = newX\n            lastY = newY\n\
    \        }\n        collisions", "        // initialize variables\n        val\
    \ collision = 0\n        val collisions = scala.collection.mutable.ListBuffer[String]()\n\
    \        // loop through n times\n        for(i <- 0 until n)\n            for(j\
    \ <- 0 until n)\n                // If the jth car collides the ith car, increment\
    \ collision.\n                if((i == j) && (i != n-1) && (j != n-1)){\n    \
    \                collision += 1\n                    // If two cars collide, store\
    \ their coordinates in collisions.\n                    collisions += \"(\" +\
    \ i + \",\" + j + \")\"\n                }\n        // return the number of collisions\n\
    \        return collision.toLong", "        val (a, b) = n / 2, (n - a) / 2\n\
    \        if (a == b) 0\n        else math.max(a, b) - math.min(a, b)", "     \
    \   val distances : mutable.ArrayList[Int] = new mutable.ArrayList()\n       \
    \ for (i <- 0 until n) {\n            distances.add(0)\n        }\n        distances.add(0)\n\
    \        distances.add(1)\n        for (i <- distances.indices to (distances.size\
    \ -1)) {\n            val previousDistance = distances(i-1)\n            val currentDistance\
    \ = distances(i)\n            val currentSpeed = (currentDistance - previousDistance)\n\
    \            distances(i) =\n                if (currentDistance == previousDistance)\
    \ {\n                    0\n                } else {\n                    distances(i-1)\
    \ + (previousDistance - currentDistance) / currentSpeed\n                }\n \
    \       }\n        distances.lastIndex + 1", "        var i = 1\n        val start1\
    \ = new Array[Int](n)\n        val start2 = new Array[Int](n)\n        val end\
    \ = new Array[Int](n)\n        val hit = new Array[Int](n)\n        // start1\
    \ start2 end\n        start1(0) = 0\n        start2(0) = 1\n        end(0) = 1\n\
    \        hit(0) = 0\n        while(i <= n) {\n            start1(i ) = i\n   \
    \         start2(i ) = i\n            end(i) = i\n            hit(i) = 0\n   \
    \         i += 1\n        }\n        val start1Iter = start1.iterator\n      \
    \  val start2Iter = start2.iterator\n        while(start1Iter.hasNext && start2Iter.hasNext)\
    \ {\n            val x = start1Iter.next\n            val y = start2Iter.next\n\
    \            if (x == y) {\n                continue\n            }\n        \
    \    val xEnd = end(x)\n            val yEnd = end(y)\n            if (xEnd <\
    \ yEnd) {\n                end(x) = xEnd + 1\n            } else {\n         \
    \       end(y) = yEnd + 1\n            }\n            val xHit = hit(x)\n    \
    \        val yHit = hit(y)\n            if (xHit < yHit) {\n                hit(x)\
    \ = xHit + 1\n            } else {\n                hit(y) = yHit + 1\n      \
    \      }\n        }\n        // x start y end hit collision count \n        var\
    \ count = 0\n        while (start1Iter.hasNext) {\n            val x = start1Iter.next\n\
    \            if (hit(x) > 0) {\n                count += 1\n                val\
    \ xEnd = end(x)\n                if (xEnd < x) {\n                    end(x) =\
    \ xEnd + 1\n                }\n            }\n        }\n        while (start2Iter.hasNext)\
    \ {\n            val y = start2Iter.next\n            if (hit(y) > 0) {\n    \
    \            count += 1\n                val yEnd = end(y)\n                if\
    \ (yEnd < y) {\n                    end(y) = yEnd + 1\n                }\n   \
    \         }\n        }\n        count", "        var count  = 0\n        var xPos\
    \   = scala.math.random\n        var yPos   = scala.math.random\n        var speed\
    \  = scala.math.random * 2 - 1\n        var collide = false\n        while (collide)\
    \ {\n            var xNew = scala.math.copy(xPos)\n            var yNew = scala.math.copy(yPos)\n\
    \            if (xPos > 0 && xPos < 1000) {\n                if (yPos > 0 && yPos\
    \ < 1000) {\n                    var xDelta = xNew - xPos\n                  \
    \  var yDelta = yNew - yPos\n                    var distance = math.sqrt(xDelta\
    \ * xDelta + yDelta * yDelta)\n                    if (distance < speed) {\n \
    \                       count += 1\n                        xPos = xNew\n    \
    \                    yPos = yNew\n                    }\n                    else\
    \ {\n                        collide = false\n                    }\n        \
    \        }\n                else {\n                    collide = false\n    \
    \            }\n            }\n            else {\n                collide = false\n\
    \            }\n        }\n        return count", "        var count = 0; var\
    \ j = 0\n        val set = new mutable.HashSet[Int]()\n        while(j < n)\n\
    \        {\n            val i = j\n            while(set.contains(i))\n      \
    \      {\n                count += 1\n                set.retain(set)\n      \
    \          set.add(i+1)\n            }\n            i += 1\n            j += 1\n\
    \        }\n        count", "        val min: Double = math.min(math.min((math.sqrt(n+1)\
    \ + 0.5) / 2, (math.sqrt(n+1) - 0.5) / 2), 1)\n        val max: Double = math.max(math.max((math.sqrt(n+1)\
    \ + 0.5) / 2, (math.sqrt(n+1) - 0.5) / 2), 0)\n        val range = max - min\n\
    \        val counts = (0 until n).map(x => min + range*(x / n).toDouble).toSet\n\
    \        val collisions = (0 until n).filter(_ => counts.contains((range * (_+1)\
    \ / n).toDouble)).length\n        counts.length - collisions", "      val nCars\
    \ = n\n      val x0 = 0.0\n      val x1 = 1.0\n      val y0 = 0.0\n      val y1\
    \ = 1.0\n      var collisions = 0\n      for {\n        x <- nCars\n        y\
    \ <- nCars\n      } yield {\n        val xx = x0 + x * x1 \n        val yy = y0\
    \ + y * y1 \n        if (math.abs(xx - yy - 1.0) <= 1.0) collisions += 1\n   \
    \   }\n      collisions", "        val road = math.pow(2, n).toDouble\n      \
    \  val collisions = mutable.Set.empty[Long]\n        for (x1 <- 1 to road) {\n\
    \            for (x2 <- x1 to road) {\n                val distance = Math.sqrt(x1\
    \ * x1 + x2 * x2)\n                if (distance > road)\n                    continue\n\
    \                if (x1 * x2 < x2 * x1)\n                    collisions += (x2,\
    \ distance)\n            }\n        }\n        collisions.size", "        val\
    \ x = 0\n        val y = 0\n        val collisionCount = 0\n        for (i <-\
    \ 1 to n) { \n            val newX = x + 1\n            val newY = y + 1\n   \
    \         if (newX > 0 && newX + 1 > 0 && newY > 0 && newY + 1 > 0 && newX !=\
    \ newY) {\n                collisionCount += 1\n                println(\"Collision\
    \ at \" + x + \",\" + y + \" with \" + newX + \",\" + newY)\n            }\n \
    \           x = newX\n            y = newY\n        }\n        collisionCount",
  "        // First, define your variables and constants: \n        var counter: Long\
    \ = 0\n        var carsLeft = n\n        var carsRight = n - 1\n\n        // Next,\
    \ define a mutable map from car position to its velocity: \n        var map =\
    \ scala.collection.mutable.Map.empty[Int, Double]\n        for( i <- 0 until n\
    \ )\n            map += (i, 0)\n\n        // Now define two mutable maps: one\
    \ that contains all positions that collide, \n        // and one that does not.\
    \  Loop through carsLeft and carsRight, and whenever\n        // a collision is\
    \ detected, set the corresponding map's value to 0\n        for( i <- 0 until\
    \ carsLeft )\n            map += (0, i)\n\n        for( i <- 0 until carsRight\
    \ )\n            map += (i, 0)\n\n        // Finally, loop through all map elements\
    \ and increment the counter whenever\n        // a car is in collision:\n    \
    \    map.foreach {\n            case (k, v) => \n                if( (carsLeft\
    \ > 0 && carsRight > 0 && k != (n - 1)) && (k != 0) )\n                    counter\
    \ += 1\n        }\n        counter", "        // The collisions occur when there\
    \ are exactly two cars that are colliding.\n        val collisionsCount = if (n==2)\
    \ 2 else n-1\n        // To make our collision counting simpler, we'll add \"\
    collisions\" to the names.\n        // For each car, we'll start at the cars whose\
    \ names are \"1\" and \"2\", and count down\n        // each of those until we\
    \ reach a car's name that we don't yet have.\n        val collisions = mutable.ArrayBuffer(\n\
    \            Car(\"1\"),\n            Car(\"2\"),\n            Car(\"3\"),\n \
    \           Car(\"4\"),\n            Car(\"5\"),\n            Car(\"6\")\n   \
    \     )\n        val cars = mutable.ArrayBuffer(\n            Car(\"1\"),\n  \
    \          Car(\"2\"),\n            Car(\"3\"),\n            Car(\"4\"),\n   \
    \         Car(\"5\"),\n            Car(\"6\")\n        )\n        var collisionsLeft\
    \ = collisionsCount\n        while (cars.length != n && carsLeft(cars.last) !=\
    \ 0)\n            cars += Car(nextName(cars.last))\n        while (cars.length\
    \ != n && carsLeft(cars.last) == 0)\n            cars.last -= 1\n        // If\
    \ we reach the end of the array without adding any cars, this means we found a\n\
    \        // collision.\n        if (collisionsLeft == 0)\n            1\n    \
    \    // Otherwise, the first collision we see is cars[collisionsLeft]\n      \
    \  else\n            collisionsLeft", "        val car1 = new Car\n        val\
    \ car2 = new Car\n        val car3 = new Car\n        val car4 = new Car\n   \
    \     val car5 = new Car\n        val car6 = new Car\n        val car7 = new Car\n\
    \        val car8 = new Car\n        val car9 = new Car\n\n        var collision\
    \ = 0\n        for (i = 1 ; i <= n ; i++) {\n            car1.setSpeed(50);\n\
    \            car2.setSpeed(50);\n            car3.setSpeed(50);\n            car4.setSpeed(50);\n\
    \            car5.setSpeed(50);\n            car6.setSpeed(50);\n            car7.setSpeed(50);\n\
    \            car8.setSpeed(50);\n            car9.setSpeed(50);\n\n          \
    \  car1.setLocation(0,i);\n            car2.setLocation(0,i);\n            car3.setLocation(0,i);\n\
    \            car4.setLocation(0,i);\n            car5.setLocation(0,i);\n    \
    \        car6.setLocation(0,i);\n            car7.setLocation(0,i);\n        \
    \    car8.setLocation(0,i);\n            car9.setLocation(0,i);\n\n          \
    \  val collides = car1.collide(car2);\n            val collides2 = car3.collide(car4);\n\
    \            val collides3 = car5.collide(car6);\n            val collides4 =\
    \ car7.collide(car8);\n            val collides5 = car9.collide(car1);\n     \
    \       val collides6 = car2.collide(car3);\n            val collides7 = car4.collide(car5);\n\
    \            val collides8 = car6.collide(car7);\n            val collides9 =\
    \ car8.collide(car9);\n\n            if (collides) collision = collision + 1;\n\
    \            if (collides2) collision = collision + 1;\n            if (collides3)\
    \ collision = collision + 1;\n            if (collides4) collision = collision\
    \ + 1;\n            if (collides5) collision = collision + 1;\n            if\
    \ (collides6) collision = collision + 1;\n            if (collides7) collision\
    \ = collision + 1;\n            if (collides8) collision = collision + 1;\n  \
    \          if (collides9) collision = collision + 1;\n        }\n        return\
    \ collision;", "        var collisions = 0\n        val carsLeft = carsRight =\
    \ mutable.Stack.empty[Int]\n        val carsRight = carsLeft = mutable.Stack.empty[Int]\n\
    \        val carsLeft = mutable.Stack.empty[Int]\n\n        var i = 1\n      \
    \  while ( i <= n ) {\n            carsLeft.push(i) \n            carsRight.push(i+1)\
    \ \n            i = i+2\n        }\n        while ( carsLeft.nonEmpty || carsRight.nonEmpty\
    \ ) {\n            var currentCarsLeft = 0\n            var currentCarsRight =\
    \ 0\n            var nextCarLeft = 0\n            var nextCarRight = 0\n     \
    \       while ( carsLeft.nonEmpty ) {\n                currentCarsLeft = (carsLeft.pop())\n\
    \                nextCarLeft = currentCarsLeft + 1\n                nextCarRight\
    \ = nextCarLeft + 1\n                val currentCarsRight = (carsRight.pop())\n\
    \                if ( nextCarLeft != nextCarRight ) {\n                    collisions\
    \ += 1\n                }\n                if ( nextCarLeft == nextCarRight )\
    \ {\n                    nextCarLeft = (nextCarLeft + 1)\n                   \
    \ nextCarRight = (nextCarRight + 1)\n                }\n            }\n      \
    \      while ( carsRight.nonEmpty ) {\n                currentCarsRight = (carsRight.pop())\n\
    \                nextCarLeft = currentCarsRight - 1\n                nextCarRight\
    \ = nextCarLeft - 1\n                val currentCarsLeft = (carsLeft.pop())\n\
    \                if ( nextCarLeft != nextCarRight ) {\n                    collisions\
    \ += 1\n                }\n                if ( nextCarLeft == nextCarRight )\
    \ {\n                    nextCarLeft = (nextCarLeft - 1)\n                   \
    \ nextCarRight = (nextCarRight - 1)\n                }\n            }\n      \
    \  }\n        collisions", "        // Use scala.collection.mutable.ArraySeq to\
    \ store collisions found.\n        var collisions = mutable.ArraySeq[Long]()\n\
    \        var speed = 2 * math.pow(n, 2) / (n + 1)\n        val carsLeft = math.ceil(n/3)\n\
    \        val carsRight = math.ceil(n/3)\n        val carsLeft = carsLeft.until(n\
    \ - carsLeft * 3)\n        val carsRight = carsRight.until(n - carsRight * 3)\n\
    \        val allCarsCombined = carsLeft ++ carsRight\n        for (car <- allCarsCombined)\
    \ {\n            val carsLfToRf = (1 to car).map(_ -> car)\n            val carsRtToLf\
    \ = (1 to car).map(_ -> car)\n            val carsLeftToRight = carsLfToRf.zip(carsRtToLf)\n\
    \            val carsRightToLeft = carsRtToLf.zip(carsLfToRf)\n            for\
    \ (leftCarRt <- carsLeftToRight) {\n                for (rightCarLf <- carsRightToLeft)\
    \ {\n                    val leftCar = leftCarRt._1\n                    val rightCar\
    \ = rightCarLf._1\n                    // Check whether this car collides with\
    \ the other car.\n                    val collidesWithLeft = leftCar != rightCar\n\
    \                    val collidesWithRight = leftCar == rightCar\n           \
    \         // If the two cars collide, add them to the collision list\n       \
    \             if (collidesWithLeft || collidesWithRight) {\n                 \
    \       collisions += leftCar\n                        collisions += rightCar\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ collisions.length", "        val l1 = -math.pi/2 + math.pi/3\n        val r1\
    \ = math.pi/2 - math.pi/3\n        val l1l2 = math.atan2(r1, l1)\n        val\
    \ r1l2 = math.atan2(-l1, r1)\n        val l3 = 0\n        val r3 = 0\n       \
    \ val l1r2 = math.atan2(-l1, r2)\n        val r1l3 = math.atan2(l1, r3)\n    \
    \    val l1r3 = math.atan2(-l1, r3)\n        val l2 = -math.pi/2 + math.pi/3\n\
    \        val r2 = math.pi/2 - math.pi/3\n        val l1r2 = math.atan2(l1, r2)\n\
    \        val r1l3 = math.atan2(r1, r3)\n        val l1l3 = math.atan2(l1, r3)\n\
    \        val l3 = -math.pi/2 + math.pi/3\n        val r3 = math.pi/2 - math.pi/3\n\
    \        val l1r3 = math.atan2(l1, r3)\n        val r1l2 = math.atan2(r1, r2)\n\
    \        val l1l2 = math.atan2(l1, r2)\n        val l3 = -math.pi/2 + math.pi/3\n\
    \        val r2 = math.pi/2 - math.pi/3\n        val l1l3 = math.atan2(l1, r3)\n\
    \        val l1r2 = math.atan2(-l1, r2)\n        val r1l3 = math.atan2(l1, r3)\n\
    \        val l1r3 = math.atan2(l1, r2)\n        val r1l3 = math.atan2(r1, r3)\n\
    \        val l1l2 = math.atan2(-l1, r2)\n        val l1l3 = math.atan2(l1, r3)\n\
    \        val r1l2 = math.atan2(l1, r2)\n        val l1r3 = math.atan2(l1, r3)\n\
    \        val l1r2 = math.atan2(r1, r3)\n        val r1l3 = math.atan2(l1, r2)\n\
    \        val l1l2 = math.atan2(-l1, r2)\n        val l1l3 = math.atan2(l1, r3)\n\
    \        val l1r2 = math.atan2(r1, r2)\n        val r1l3 = math.atan2(l1, r2)\n\
    \        val l1r3 = math.atan2(l1, r3)\n        val l1r2 = math.atan2(r1, r3)\n\
    \        val r1l3 = math.atan2(l1, r2)\n        val l1r3 = math.atan2(l1, r3)\n\
    \        val r1l2 = math.atan2(r1, r2)\n        val l1l3 = math.atan2(l1, r3)\n\
    \        val l1r3 = math.atan2(l1, r2)\n", "        var i = 0\n        var j =\
    \ 0\n        var collisions = 0\n        var minDist = math.pow(math.pow(n, 2)\
    \ + math.pow(i, 2) + math.pow(j, 2), 1.5)\n        var lastVec : Double = 0.0\n\
    \        var currentVec : Double = 0.0\n        for(i <- 0 until n) {\n      \
    \      lastVec = currentVec\n            currentVec = math.pow(i, 0.5)\n     \
    \       for(j <- 0 until n) {\n                currentVec = math.pow(j, 0.5)\n\
    \                if(i != j) {\n                    if(math.pow((currentVec - lastVec),\
    \ 2) < minDist) {\n                        collisions += 1\n                 \
    \   }\n                }\n            }\n        }\n        collisions", "   \
    \     // Initialize variables\n        var collide = 0L\n        var i = 0\n \
    \       var sum = 0L\n        var left = 0\n        var right = 0\n        val\
    \ startTime = System.currentTimeMillis()\n        val endTime = startTime + (1000\
    \ * 60)\n        var x = 0\n        while (System.currentTimeMillis() < endTime)\
    \ {\n            val startTime = System.currentTimeMillis()\n            i +=\
    \ 1\n            sum = 0\n            left = i + n - 1\n            right = i\
    \ + n\n            while (left >= 0 && right < 0) {\n                val startTime\
    \ = System.currentTimeMillis()\n                val x1 = x\n                val\
    \ y1 = math.random*100\n                val x2 = x\n                val y2 = math.random*100\n\
    \                var collide = 0\n                if (y1 < y2) {\n           \
    \         x1 = x2\n                    y1 = y2\n                    x2 = math.random*100\n\
    \                    y2 = math.random*100\n                }\n               \
    \ val dx = x2 - x1\n                val dy = y2 - y1\n                val dist\
    \ = math.sqrt(dx * dx + dy * dy)\n                if (dist > 50) {\n         \
    \           if (dx < 0) {\n                        left -= 1\n               \
    \         right -= 1\n                    } else {\n                        right\
    \ -= 1\n                        left -= 1\n                    }\n           \
    \     } else {\n                    left -= 1\n                    right -= 1\n\
    \                }\n                collide += 1\n                if (collide\
    \ > 10) {\n                    collide = 0\n                }\n            }\n\
    \            val endTime = System.currentTimeMillis()\n            val t = endTime\
    \ - startTime\n            if (t > 1000) {\n                println(i)\n     \
    \           collide += 1\n            }\n        }\n        return collide", " \
    \       val x = 0\n        val y = 0\n        var counter = 0\n        for(i <-\
    \ 0 until n){\n            for(j <- 0 until n){\n                if(i == j) continue\n\
    \                x += i * Math.cos(Math.PI * 2 * y / n) - (j * Math.sin(Math.PI\
    \ * 2 * y / n))\n                y += i * Math.sin(Math.PI * 2 * y / n) + (j *\
    \ Math.cos(Math.PI * 2 * y / n))\n                counter += 1\n            }\n\
    \        }\n        counter", "        var collisions = 0\n        for (car <-\
    \ 1 to n){\n            for (car2 <- 1 to n){\n                if (car+1 == car2)\
    \ continue\n                val dx = abs((car - car2))\n                val dy\
    \ = abs((car2-(car+1)))\n                if (dx == dy || dx > n) continue\n  \
    \              collisions += 1\n            }\n        }\n        collisions",
  "        // Scan each car in both directions, counting how many collisions each\
    \ time\n        // we see a collision.  For instance, suppose there are two cars\
    \ c1 and c2 on\n        // an infinitely long road.  The first time we see a collision,\
    \ we say that c1 and\n        // c2 collide.  We say that c1 collides with c2\
    \ if the following two conditions\n        // hold simultaneously.  c1 is moving\
    \ left to right, and c2 is moving right to\n        // left.  Hence, we conclude\
    \ that c1 and c2 collide.  Now, suppose we see the\n        // second collision.\
    \  We say that c1 collides with c2 only if the following two\n        // conditions\
    \ hold simultaneously.  c1 is moving left to right, and c2 is still\n        //\
    \ moving left to right.  Hence, we conclude that c1 and c2 collide.\n        //\
    \ If we have n cars, then we are counting 2*n collisions, because we count\n \
    \       // each time we see a collision.  However, if we increase n to say 100,\
    \ we get\n        // 10n collisions.\n        //\n        // To be clear, suppose\
    \ that n = 2k.  Then, we have 10k collisions because we\n        // have to count\
    \ each collision 10 times.  Each time we see a collision, we\n        // add 2k\
    \ to our total.  When we see a collision k+1 times, we add 2*(k+1)\n        //\
    \ to our total.  We can see that the pattern repeats itself if k is greater\n\
    \        // than two.  If k is 2 or greater, the pattern repeats itself.  If k\
    \ = 1,\n        // the pattern repeats itself, etc.  We only have to do this computation\
    \ once.\n        //\n        // When we see a collision, we'll increment k by\
    \ 1.  Since we added 2k to the\n        // total every time we see a collision,\
    \ we decrement k by 1, because each time\n        // we see a collision, we'll\
    \ add 2*k+1 to the total.\n        val collisions = mutable.MutableLong(0)\n \
    \       val cars = mutable.MutableList.empty[Car]\n        val rightCars = mutable.MutableList.empty[Car]\n\
    \        val leftCars = mutable.MutableList.empty[Car]\n        for (i <- 1 to\
    \ n) {\n            cars ++= List(new Car(true, i)) :: rightCars ++= List(new\
    \ Car(false, i)) :: leftCars ++= List(new Car(true, i))\n        }\n        val\
    \ rt = new TravelingCars(cars, rightCars, leftCars)", "        def computeCollision(x\
    \ : Long, y : Long) : Long = {\n            // This implementation is extremely\
    \ inefficient and impractical for large n\n            // because it calls a recursive\
    \ function computeCollision.\n            // Recursive functions are a bad idea\
    \ in language implementations.\n            \n            val carsAhead = (x /\
    \ n).toInt\n            val carsBehind= (y / n).toInt\n            \n        \
    \    if(Math.abs(x - y) == 0) {\n                return 0\n            }\n   \
    \         val sum : Long = carsAhead + carsBehind\n            val diff : Long\
    \ = if (sum == 1) {\n                Math.abs(x) - Math.abs(y)\n            }\
    \ else {\n                sum - Math.abs(x) - Math.abs(y)\n            }\n   \
    \         if (diff > 0) {\n                diff\n            } else {\n      \
    \          0\n            }\n        }\n        \n        def carCollision(x :\
    \ Long, y : Long) : Long = {\n            if(x < y) {\n                computeCollision(x,\
    \ y + 1)\n            } else {\n                computeCollision(x + 1, y)\n \
    \           }\n        }\n        \n        val collideCounts = Array.fill(n){0L}\n\
    \        \n        for(i<- 1 to n) {\n            for(j<- 1 to n) {\n        \
    \        val carsAhead = i * j\n                val carsBehind = (i + 1) * j\n\
    \                \n                val collision : Long = carCollision(i, j)\n\
    \                \n                collideCounts(carsAhead) += collision\n   \
    \             collideCounts(carsBehind) += collision\n            }\n        }\n\
    \        \n        \n        collideCounts.filter(_ != 0).sum", "        val car\
    \ = scala.util.Random.nextInt((2 * n - 1))\n        var collisions = 0\n     \
    \   val minX = -1000L\n        val maxX = 1000L\n        val minY = -1000L\n \
    \       val maxY = 1000L\n        val minZ = -1000L\n        val maxZ = 1000L\n\
    \        for (x = minX to maxX) yield {\n            for (y = minY to maxY) yield\
    \ {\n                for (z = minZ to maxZ) yield {\n                    if (car\
    \ == 0 || car == 1 || car == 2 || car == 3 || car == 4 || car == 5 || car == 6\
    \ || car == 7 || car == 8 || car == 9) collisions += 1\n                    if\
    \ (x - car == 0 && y + car == 1 && z + car == 2) collisions += 1\n           \
    \         if (x + car == n && y - car == 1 && z + car == 2) collisions += 1\n\
    \                    if (x - car == 0 && y - car == 1 && z + car == 2) collisions\
    \ += 1\n                    if (x + car == n && y - car == 1 && z - car == 2)\
    \ collisions += 1\n                    if (x + car == n && y + car == 1 && z -\
    \ car == 2) collisions += 1\n                    if (x - car == 0 && y + car ==\
    \ 1 && z - car == 2) collisions += 1\n                }\n            }\n     \
    \   }\n        collisions", "        val road = n / 2\n        val cars = n /\
    \ 2\n\n        // Assume that there are no collisions at all\n        var collidedCount\
    \ = 0\n\n        // Assume that there is some collision\n        var collidingCount\
    \ = 0\n\n        // For each road-segment in the road\n        for (x <- 0 until\
    \ road) {\n            for (y <- 0 until road) {\n                // For each\
    \ car\n                for (car <- 0 until  cars) {\n                    val distanceBetweenCars\
    \ = sqrt( pow((road(x) - car(y)), 2.0) + pow((car(x) - road(y)), 2.0))\n     \
    \               if (distanceBetweenCars > car(x) + car(y)) {\n               \
    \         collidingCount += 1\n                        collidedCount += 1\n  \
    \                  }\n                }\n            }\n        }\n        collidedCount\
    \ + (collidingCount * cars)", "        val m = 2 * n\n        var count = 0\n\
    \        for (a <- 1 to n-1 by -1)\n            for (b <- 1 to n-1 by -1)\n  \
    \              count += ((a - b) ^ 2) % m == 0\n        count", "        // Declare\
    \ some mutable variables.\n        var cars : List[Long] = List(0, 1, 2, 3, 4)\n\
    \        var collideCount : Long = 0\n        var firstCollision : Long = -1\n\
    \        var secondCollision : Long = -1\n\n        // Initialize the list of\
    \ cars so that each car has a unique index with\n        // respect to the start\
    \ of the cars list.\n        val carIndexMap = scala.collection.mutable.Map(0\
    \ -> 0, 1 -> 1, 2 -> 2, 3 -> 3, 4 -> 4)\n        cars = List.range(1, n).map(x\
    \ => carIndexMap(x + 1))\n\n        // Loop through the list of cars twice for\
    \ each car.\n        for (i <- 0 to cars.size-1) {\n            // The first time\
    \ we check, each car may collide with itself.\n            if (cars(i) == i) {\n\
    \                collideCount += 1\n                firstCollision = i\n     \
    \       }\n\n            // The second time we check, each car may not collide\
    \ with itself.\n            else {\n                for (j <- 0 to cars.size-1)\
    \ {\n                    // If the current car is colliding with another car,\
    \ then\n                    // we know that that other car must also be colliding.\
    \  So we\n                    // can break out of this inner loop.\n         \
    \           if (cars(i) == j) {\n                        collideCount += 1\n \
    \                       break\n                    }\n\n                    //\
    \ Otherwise, if the current car is not colliding with any\n                  \
    \  // other car, then we know that neither of the other cars\n               \
    \     // is colliding.  So we can break out of this outer loop.\n            \
    \        else {\n                        if (firstCollision >= 0) break\n    \
    \                }\n                }\n            }\n        }\n\n        //\
    \ Return the number of collisions.\n        collideCount", "        var collisions\
    \ = 0\n        for(i <- 1 to n)\n            for (j <- 1 to i)\n             \
    \   if (math.abs(i^2 - j^2) < math.pow(i^2, 2) || math.abs(i^2 - j^2) < math.pow(j^2,\
    \ 2))\n                    collisions += 1\n        collisions", "      // The\
    \ cars start off moving at same speed.\n      // If two cars collide, then they\
    \ will both travel with the same speed.\n      // For cars to collide, they must\
    \ move in opposite directions to avoid a collision.\n      // The cars will travel\
    \ with speed r each step, with 0 <= r < 1.\n      val r = 1.0 - (2.0 * rand.nextDouble());\n\
    \      val x = r * r;\n      val y = r * r;\n      val speed = sqrt(x * x + y\
    \ * y);\n      if (speed > 1.0) {\n        carRaceCollision(n);\n      }\n   \
    \   else {\n        // If collision occurs, travel one more time.\n        val\
    \ collision = carRaceCollision(n + 1);\n        val t = (collision + 1.0) / 2.0\n\
    \        val x = x / speed\n        val y = y / speed\n        val xDiff = x -\
    \ x\n        val yDiff = y - y\n        if (t < 0.5)\n          (rand.nextDouble()\
    \ * 2.0) - 1.0\n        else {\n          (2.0 * rand.nextDouble()) - 1.0\n  \
    \      }\n      }", "        val totalSpeed = 200000  // Total speed of the entire\
    \ race\n        val speedOfLeftToRight = totalSpeed / n\n        val speedOfRightToLeft\
    \ = totalSpeed * (n - 1) / 2\n        // We need to calculate the number of collisions\
    \ within each set of cars.\n        val nCollisionsLeft = carCollisions(speedOfLeftToRight,\
    \ n)\n        val nCollisionsRight = carCollisions(speedOfRightToLeft, n)\n  \
    \      // The collisions are given by the number of cars with their trajectories\
    \ colliding.\n        val collisions = nCollisionsLeft + nCollisionsRight\n  \
    \      // We need to add up the number of collisions that occur at the same time\
    \ as\n        // the collisions they represent.\n        collisions + carRaceCollision(collisions)",
  "        val carsLeft : mutable.Map[Int, Int] = mutable.Map.empty[Int, Int]\n  \
    \      val carsRight : mutable.Map[Int, Int] = mutable.Map.empty[Int, Int]\n \
    \       val collidedCars : mutable.Set[Int] = mutable.Set.empty[Int]\n       \
    \ val carCollisionsLeft : mutable.Map[Int, Int] = mutable.Map.empty[Int, Int]\n\
    \        val carCollisionsRight : mutable.Map[Int, Int] = mutable.Map.empty[Int,\
    \ Int]\n        val initialSpeed = 100\n\n        for (i <- 0 until n) {\n   \
    \         // First collision, either left or right\n            val left = i %%\
    \ 2 == 0\n            val right = i / 2 != 0\n\n            if (left && right)\
    \ {\n                // Left and right collide\n                val collisions\
    \ = carsLeft.get(i / 2) + (carsRight.get(i / 2) / 2)\n                if (collisions\
    \ == 0) {\n                    // Both cars collide in the same direction\n  \
    \                  collidedCars += i\n                } else {\n             \
    \       // Both cars collide in opposite directions\n                    carCollisionsLeft.put(i\
    \ / 2, collisions)\n                }\n            } else if (left) {\n      \
    \          // Left collide\n                val collisions = carsLeft.get(i /\
    \ 2)\n                if (collisions == 0) {\n                    // Both cars\
    \ collide in the same direction\n                    collidedCars += i\n     \
    \           } else {\n                    // Both cars collide in opposite directions\n\
    \                    carCollisionsLeft.put(i / 2, collisions)\n              \
    \  }\n            } else {\n                // Right collide\n               \
    \ val collisions = carsRight.get(i / 2)\n                if (collisions == 0)\
    \ {\n                    // Both cars collide in the same direction\n        \
    \            collidedCars += i\n                } else {\n                   \
    \ // Both cars collide in opposite directions\n                    carCollisionsRight.put(i\
    \ / 2, collisions)\n                }\n            }\n\n            // Second\
    \ collision, either left or right\n            val left = i / 2 != 0\n       \
    \     val right = i %% 2 == 0\n\n            if (left && right) {\n          \
    \      // Left and right collide\n                val collisions = carsLeft.get(i\
    \ / 2) + (carsRight.get(i / 2) / 2)\n                if (collisions == 0) {\n\
    \                    // Both cars collide in the same direction\n            \
    \        collidedCars += i\n                } else {\n                    // Both\
    \ cars collide in opposite directions\n                    carCollisionsLeft.put(i\
    \ / 2, collisions)\n                }\n            } else if (left) {\n      \
    \          // Left collide\n                val collisions = ", "        var carsAlong\
    \ = 0L\n        var carsAtLeft = 0L\n        var carsAtRight = 0L\n        var\
    \ carsAtTheMiddle = 0L\n        var carsWeAreMoving = 0L\n\n        var collisions\
    \ = 0L\n\n        while (n > 0) {\n            n -= 1\n            carsWeAreMoving\
    \ += 1\n            val nextCarsAtTheMiddle = (n - 2) / 2\n            carsAtTheMiddle\
    \ = carsAtTheMiddle + nextCarsAtTheMiddle - 1\n            carsAtTheMiddle = carsAtTheMiddle\
    \ + nextCarsAtTheMiddle - 1\n            carsAtTheMiddle = carsAtTheMiddle + nextCarsAtTheMiddle\
    \ - 1\n            if (carsAtTheMiddle > carsAtLeft) {\n                carsAtTheMiddle\
    \ = carsAtTheMiddle - carsAtLeft\n                carsAtLeft = carsAtLeft - nextCarsAtTheMiddle\n\
    \                collisions += 1\n            }\n        }\n        return collisions",
  "        var nCr : Long = 0\n        val m = (n+1)/2\n        var left = 0\n   \
    \     for(i <- 0 until n) {\n            var right = 0\n            for(j <- 0\
    \ until n) {\n                val d = math.abs(m*(j+1)-(i+1))\n              \
    \  if (d < math.abs(i-j)) {\n                    right += 1\n                }\
    \ else {\n                    left += 1\n                }\n            }\n  \
    \          if (left > right) {\n                nCr += 1\n            }\n    \
    \    }\n        nCr", "        val (leftCars, rightCars) = {\n            var\
    \ leftCars = mutable.Set[Long]()\n            var rightCars = mutable.Set[Long]()\n\
    \            var collisions = mutable.Set[Long]()\n            val startX = scala.math.random\n\
    \            val startY = scala.math.random\n            for (_ <- 1 to n) {\n\
    \                val x = scala.math.random\n                val y = scala.math.random\n\
    \                if (scala.math.abs(x - startX) + scala.math.abs(y - startY) <\
    \ scala.math.pow(2, 24)) {\n                    leftCars += x\n              \
    \      rightCars += y\n                }\n            }\n            (leftCars,\
    \ rightCars)\n        }\n        val collisions = leftCars.intersect(rightCars)\n\
    \        collisions.toSet.size", "        var x = 0\n        for (i <- 0 to n-1)\
    \ {\n            for (j <- i+1 to n) {\n                if (Math.abs(i - j) ==\
    \ 1) {\n                    x++\n                }\n            }\n        }\n\
    \        x", "        val s = List[(Int, Int)]()\n        (1 to n).foreach( x\
    \ => s += (x,x))\n        val g = Graph(s).map(car => car._1 -> car._2)\n    \
    \    val collisions = g.filterNot(_._1.isInstanceOf[Int]).filter(_._1._1 == g.filter(_._1._1).map(_._1._2).sum)\n\
    \        collisions.count", "        // Make a car array.\n        var carArray\
    \ = new Array[Long](n)\n        var carCount = 0\n\n        // Initialize the\
    \ carArray with n random numbers\n        for (i<-0 until n) {\n            carArray(i)\
    \ = (scala.util.Random.nextDouble() *10) - 5\n        }\n\n        // Assume that\
    \ the two arrays of cars are \"sturdy\" i.e. follow the same trajectory.\n   \
    \     var collisionCount = 0\n\n        // Assume that all cars move in the same\
    \ speed (i.e. they all start at the\n        // same speed).\n        var carSpeed\
    \ = 0.5\n\n        // Iterate through the carArray and see what happens to each\
    \ car\n        // when it collides with each other.\n        for (i <- 0 until\
    \ n) {\n            val nextCar = carArray(i)\n\n            // Find the index\
    \ of the other car in the carArray that's moving left.\n            val otherIndex:\
    \ Int = {\n                if (carArray(i) < 0) n else carArray(i) - 1\n     \
    \       }\n\n            // If that other car is currently moving to the right\
    \ and we're moving left,\n            // then they collide and we increment the\
    \ collision count.\n            if (carArray(otherIndex) > 0 && carSpeed == 0)\
    \ {\n                collisionCount += 1\n            }\n\n            // Otherwise,\
    \ if the other car is moving left but we're moving right,\n            // then\
    \ we move the other car to the right and increment the collision count.\n    \
    \        else if (carArray(otherIndex) < 0 && carSpeed > 0) {\n              \
    \  carArray(otherIndex) = carSpeed * 10\n                collisionCount += 1\n\
    \            }\n\n            // Otherwise (if the other car is moving right but\
    \ we're moving left),\n            // then we move the other car to the left and\
    \ increment the collision count.\n            else {\n                carArray(otherIndex)\
    \ = carSpeed * 10\n                collisionCount += 1\n            }\n\n    \
    \        // Move to the next car in the array.\n            carArray(i) = carArray(i)\
    \ + carSpeed * 10\n        }\n\n        // Return the number of collisions.\n\
    \        collisionCount", "        val carsLeft = mutable.Set[Int]()\n       \
    \ val carsRight = mutable.Set[Int]()\n        var collisions = 0\n        for(\
    \ _ <- 0 to n - 1 ) {\n            val carLeft = math.random\n            val\
    \ carRight = math.random\n            if( carLeft < carRight ) {\n           \
    \     carsLeft += carLeft\n                carsRight += carRight\n           \
    \ }\n            else {\n                carsLeft += carRight\n              \
    \  carsRight += carLeft\n            }\n        }\n        if( carsLeft.size <\
    \ carsRight.size ) {\n            collisions = carsLeft.size + carsRight.size\n\
    \        }\n        else {\n            collisions = carsRight.size + carsLeft.size\n\
    \        }\n        collisions", "        // Set up the problem\n        var currentRight\
    \ = Long.MaxValue\n        var currentLeft = Long.MinValue\n        var currentSpeed\
    \ = 0\n        var currentCollision = 0\n        var collisions = []\n       \
    \ var count = 0\n\n        for ( var i = 1; i <n; i++) {\n            // Calculate\
    \ position of current car\n            currentSpeed = math.abs(math.signum(currentRight\
    \ - currentLeft))\n            currentLeft += currentSpeed\n            currentRight\
    \ -= currentSpeed\n\n            // If we've collided with anything before, increment\
    \ collision count and append current position to collisions\n            if (collisions.contains(currentLeft\
    \ + currentSpeed))\n            {\n                currentCollision = collisions.lastIndexOf(currentLeft\
    \ + currentSpeed)\n                count += 1\n                collisions(currentCollision)\
    \ = currentLeft\n                collisions(currentCollision + 1) = currentRight\n\
    \            }\n            // If we have not yet collided with anything, record\
    \ current position into collisions\n            else\n            {\n        \
    \        collisions = Array(currentLeft, currentRight)\n            }\n      \
    \  }\n        count", "        val (left, right) = Array.fill(n / 2)(math.random(2))\n\
    \        val rs = ListBuffer[Int]()\n        for (x1 <- 0 to n - 1) {\n      \
    \      val x1 = math.min(n - 1, x1 + 1)\n            var collide = false\n   \
    \         for (x2 <- x1 to n) {\n                val x2 = x1 + x2\n          \
    \      if (x1 != x2 && left(x1) > right(x2)) {\n                    collide =\
    \ true\n                    break\n                }\n            }\n        \
    \    if (collide) rs += x1\n        }\n        rs.sum", "        // A list where\
    \ the cars are stored left to right\n        var collisions = mutable.ListBuffer.empty[Long]\n\
    \        // A list where the cars are stored right to left\n        var reverseCollisions\
    \ = mutable.ListBuffer.empty[Long]\n        // The cars that are currently moving\n\
    \        var movingCars = ListBuffer.empty[Long]\n\n        // Iterate from left\
    \ to right\n        for (i <- 0 until n) {\n            // Initialize a collision\n\
    \            var collision = 0L\n            // Initialize a reversed collision\n\
    \            var reverseCollision = 0L\n            // For each car\n        \
    \    for (j <- 0 until n) {\n                // If this car is currently moving\n\
    \                if (movingCars.contains(j)) {\n                    // If this\
    \ car is colliding with another car in reverse\n                    if (reverseCollisions.contains(j))\
    \ {\n                        // Increment the reversed collision\n           \
    \             reverseCollision += 1\n                    }\n                 \
    \   // Else, increment the collision\n                    else {\n           \
    \             // Move the car\n                        movingCars.remove(j)\n\
    \                        // Add this car to the collision list\n             \
    \           collision += 1\n                    }\n                }\n       \
    \         // Else, add a car to the moving cars list\n                else {\n\
    \                    // Add this car to the moving cars list\n               \
    \     movingCars += j\n                }\n            }\n            // Add the\
    \ collision to the collisions list\n            collisions += collision\n    \
    \        // Add the reversed collision to the collisions list\n            reverseCollisions\
    \ += reverseCollision\n        }\n        // Return the number of collisions\n\
    \        collisions.size", "        // Given n cars driving left to right, output\
    \ the number of\n        // cars that are strongly colliding.\n        val collides\
    \ = mutable.ListBuffer(0)\n        val left = scala.collection.mutable.ListBuffer(0)\n\
    \        val right = scala.collection.mutable.ListBuffer(0)\n        val leftIsColliding\
    \ = scala.collection.mutable.ListBuffer(0)\n        val rightIsColliding = scala.collection.mutable.ListBuffer(0)\n\
    \        var c = 0\n        for (i <- 0 until n) {\n            c += 1\n     \
    \       right += i\n        }\n        for (i <- 0 until n) {\n            c +=\
    \ 1\n            left += n\n        }\n        for (i <- 0 until n) {\n      \
    \      if (i >= left.size)\n                leftIsColliding += i\n           \
    \ else if (i < right.size)\n                rightIsColliding += i\n          \
    \  else\n                collides += i\n        }\n        val collidesCount =\
    \ collides.size\n        if (collidesCount == 0)\n            0\n        else\
    \ if (collidesCount == 1)\n            collides(collidesCount)\n        else\n\
    \            // collides has 1 or more elements; collides(0) is the number\n \
    \           // of cars that are colliding; collides(1) is the number of\n    \
    \        // cars that are colliding with collides(0).\n            collides(collidesCount)",
  "        // The speed of the cars.\n        val speed = 1 / n\n        val carX\
    \ = 0L\n        val carY = 0L\n        // The speed of the other cars.\n     \
    \   val otherSpeed = 1L\n\n        // Each car will be moving at 1 unit per iteration\n\
    \        // until they've collided with all the other cars.\n        var carXCollisions\
    \ = 0L\n        var carYCollisions = 0L\n\n        // Start moving cars left to\
    \ right\n        // as long as we haven't collided with any cars.\n        while\
    \ (carXCollisions < n && !carXCollisions(carX)) {\n            // Add 1 to the\
    \ number of collisions\n            // we've encountered on one side of the road\n\
    \            // when we collided with another car.\n            carXCollisions\
    \ += 1\n            carX += speed\n        }\n\n        // Move the remaining\
    \ cars right.\n        while (carYCollisions < n && !carYCollisions(carY)) {\n\
    \            carY += speed\n            carYCollisions += 1\n        }\n     \
    \   carXCollisions", "        val cars = List.tabulate(n)(i => (math.random,i))\n\
    \        val collides = mutable.ListBuffer[Long]()\n        cars.filterNot(_._2\
    \ % 2).foreach { car =>\n            cars.filterNot(_._2 % 2).foreach { otherCar\
    \ =>\n                if (car._1 == otherCar._1) {\n                    val collide\
    \ = car._1.toDouble * car._1.toDouble + otherCar._1.toDouble * otherCar._1.toDouble\n\
    \                    if (collide <= math.sqrt((car._2.toDouble - otherCar._2.toDouble)\
    \ * (car._2.toDouble - otherCar._2.toDouble) + car._2.toDouble * car._2.toDouble))\n\
    \                        collides += collide\n                }\n            }\n\
    \        }\n        collides.toList.length", "        val cars = Vector.tabulate(n)(i\
    \ => i + 1)\n        val collisions = mutable.ListBuffer.empty[Long]\n       \
    \ for (a <- 0 until n) {\n            for (b <- 1 until a) {\n               \
    \ collisions += if (cars(a) == cars(b)) {\n                    0\n           \
    \     } else {\n                    carRaceCollisionHelper(cars, a, b, collisions)\n\
    \                }\n            }\n        }\n        collisions.sum", "     \
    \   def collision(i : Int, j : Int) : Long = {\n            // The distance of\
    \ one car from the other car\n            val distx = Math.abs(i - j)\n      \
    \      // The distance of the other car to the other car's right\n           \
    \ val disty = math.abs(n - i - 1)\n            // The max distance of the other\
    \ car to the other car's right\n            val distz = math.abs(n - j - 1)\n\
    \            // The difference between the two distances\n            val dis\
    \ = distx + disty - distz\n            dis\n        }\n        val m = n\n   \
    \     val l = 0\n        val r = m\n        val result = 0\n        while (l <\
    \ r) {\n            val mid = (l + r) / 2\n            val left = (mid + 0) /\
    \ 2\n            val right = (mid + 1) / 2\n            val collisions = collision(right,\
    \ left)\n            val collisionsRight = collision(left, right)\n          \
    \  // If the distance between a car and a car on the right is more\n         \
    \   // than half the distance between a car on the left and the\n            //\
    \ right, there's a collision\n            if (collisions > collisionsRight) {\n\
    \                result += 1\n            }\n            l += 1\n            r\
    \ += 1\n        }\n        result", "        val startCars = Vector.fill(8)(math.random)\n\
    \        val endCars = Vector.fill(8)(math.random)\n        val collisions = 0\n\
    \        // The cars are initially moving from left to right.\n        var i =\
    \ 8\n        while(i < n ) {\n            if(startCars(i) == 1 && endCars(i) ==\
    \ -1) {\n                startCars(i) = -1\n                endCars(i) = 1\n \
    \               collisions = collisions + 1\n            } else if(startCars(i)\
    \ == -1 && endCars(i) == 1) {\n                startCars(i) = 1\n            \
    \    endCars(i) = -1\n                collisions = collisions + 1\n          \
    \  } else {\n                i = i + 1\n            }\n        }\n        return\
    \ collisions", "        // Initialize n to be even.\n        n += n%2\n      \
    \  // Initialize a list to hold the positions of all the cars.\n        var allCarPositions\
    \ = mutable.ListBuffer[Int]()\n        // Initialize a map to hold the positions\
    \ of all the cars.\n        var allCarPositionsMap = mutable.Map()\n        //\
    \ Set up the loop control variables.\n        var i = 1\n        var collision\
    \ = 0\n        // Iterate through the possible positions of all the cars.\n  \
    \      while (i <= n) {\n            // Add the current position to the list of\
    \ all positions.\n            allCarPositions += i\n            // Store the list\
    \ of positions so we can check later on.\n            allCarPositionsMap += i\
    \ -> allCarPositions\n            // Increment the loop variable.\n          \
    \  i += 1\n        }\n        // Set up the loop variables.\n        var j = 1\n\
    \        var collisionCount = 0\n        // Iterate through the possible positions\
    \ of all the cars.\n        while (j <= n) {\n            // Add the current position\
    \ to the list of all positions.\n            allCarPositions += j\n          \
    \  // Iterate through the possible positions of all the cars.\n            while\
    \ (j <= n) {\n                // Add the current position to the list of all positions.\n\
    \                allCarPositions += j\n                // Set up the collision\
    \ test variables.\n                var k = 1\n                var collisionTest\
    \ = 0\n                // Iterate through the possible positions of all the cars.\n\
    \                while (k <= n) {\n                    // Add the current position\
    \ to the list of all positions.\n                    allCarPositions += k\n  \
    \                  // Test the collision between the current position and the\
    \ adjacent\n                    // position.\n                    if (allCarPositionsMap(j\
    \ + 1) contains allCarPositionsMap(k)) {\n                        collisionTest\
    \ += 1\n                        // If this is the first time we've detected a\
    \ collision, then\n                        // set the collision variable.\n  \
    \                      if (collision == 0) {\n                            collision\
    \ = collisionTest\n                        }\n                    }\n        \
    \            // Increment the loop variable.\n                    k += 1\n   \
    \             }\n                // Increment the loop variable.\n           \
    \     j += 1\n            }\n            // Increment the loop variable.\n   \
    \         j += 1\n        }\n        // Return the result.\n        collision",
  "        var c = 0\n        var h = 0\n        for (x <- 1 to n) {\n           \
    \ val hi = n\n            val lo = 1\n            while (lo < hi) {\n        \
    \        val mid = (lo + hi) >>> 1\n                val x = mid - 1\n        \
    \        val y = mid + 1\n                if (carRaceCollisionInternal(x, y))\
    \ {\n                    c = c + mid\n                    hi = mid - 1\n     \
    \           } else {\n                    lo = mid + 1\n                }\n  \
    \          }\n        }\n        c", "        val collisions : Long = 0\n    \
    \    var currentDistance : Long = 0\n\n        // Initialize our data structures\n\
    \        val speed: MutableList[Double] = ArrayBuffer.fill(n) { (0 /  n).abs }.map(math.pow)\n\
    \        val collisions : MutableList[Boolean] = ArrayBuffer.fill(n) { false }.map(math.abs)\n\
    \n        // Set up our initial conditions.\n        for (i <- 0 until n) {\n\
    \            speed(i) = math.pow(0.1, math.ceil(i))\n            collisions(i)\
    \ = false\n        }\n\n        // Main loop\n        for(i <- 0 until n) {\n\
    \            // Figure out how much we're currently going\n            val distanceLeft\
    \ = currentDistance + speed(i)\n            val distanceRight = currentDistance\
    \ - speed(i)\n\n            // If we're moving left and colliding, move right\n\
    \            if(collisions(i) && distanceLeft > distanceRight) {\n           \
    \     currentDistance += speed(i)\n                collisions(i) = false\n   \
    \         }\n            // If we're moving right and colliding, move left\n \
    \           else if(!collisions(i) && distanceLeft < distanceRight) {\n      \
    \          currentDistance -= speed(i)\n                collisions(i) = true\n\
    \            }\n        }\n        collisions.sum", "        val x = mutable.ArrayBuffer(1\
    \ to n).reverse.sorted\n        val y = mutable.ArrayBuffer(1 to n).reverse.sorted\n\
    \        val xx = mutable.ArrayBuffer(1 to n).reverse.sorted\n        val yy =\
    \ mutable.ArrayBuffer(1 to n).reverse.sorted\n        val xy = mutable.ArrayBuffer(1\
    \ to n).reverse.sorted\n        val xx = mutable.ArrayBuffer(1 to n).reverse.sorted\n\
    \        val yy = mutable.ArrayBuffer(1 to n).reverse.sorted\n        val xy =\
    \ mutable.ArrayBuffer(1 to n).reverse.sorted\n        var count = 0\n        for\
    \ (ix <- 1 to n){\n            val x = x(ix)\n            val y = y(ix)\n    \
    \        val xx = x(ix)\n            val yy = y(ix)\n            val xy = y(ix)\n\
    \            val xx = x(ix)\n            val yy = y(ix)\n            val xy =\
    \ y(ix)\n            val xx = x(ix)\n            val yy = y(ix)\n            val\
    \ xy = y(ix)\n            val xx = x(ix)\n            val yy = y(ix)\n       \
    \     val xy = y(ix)\n            val xx = x(ix)\n            val yy = y(ix)\n\
    \            val xy = y(ix)\n            val xx = x(ix)\n            val yy =\
    \ y(ix)\n            val xy = y(ix)\n            val xx = x(ix)\n            val\
    \ yy = y(ix)\n            val xy = y(ix)\n            val xx = x(ix)\n       \
    \     val yy = y(ix)\n            val xy = y(ix)\n            val xx = x(ix)\n\
    \            val yy = y(ix)\n            val xy = y(ix)\n            val xx =\
    \ x(ix)\n            val yy = y(ix)\n            val xy = y(ix)\n            val\
    \ xx = x(ix)\n            val yy = y(ix)\n            val xy = y(ix)\n       \
    \     val xx = x(ix)\n            val yy = y(ix)\n            val xy = y(ix)\n\
    \            val xx = x(ix)\n            val yy = y(ix)\n            val xy =\
    \ y(ix)\n            val xx = x(ix)\n            val yy = y(ix)\n            val\
    \ xy = y(ix)\n            val xx = x(ix)\n            val yy = y(ix)\n       \
    \     val xy = y(ix)\n            val xx = x(ix)\n            val yy = y(ix)\n\
    \            val xy = y(ix)\n            val xx = x(ix)\n            val yy =\
    \ y(ix)\n            val xy = y(ix)\n            val xx = x(ix)\n            val\
    \ yy = y(ix)\n", "        val l = scala.math.ceil(n/2).asInstanceOf[Int]\n   \
    \     val r = n - l\n        val c = new HashMap[Long,Long]()\n        var x =\
    \ 0\n        for (x <- 0 until l) {\n            var y = 0\n            for (y\
    \ <- 0 until r) {\n                val collision = carRaceCollision(x, y)\n  \
    \              if (collision != -1) {\n                    val carCollision =\
    \ collision + 1\n                    if (!c.contains(carCollision)) {\n      \
    \                  c.put(carCollision, 1)\n                    }\n           \
    \     }\n            }\n        }\n        c.size", "        var collision : Long\
    \ = 0\n        // To speed things up, only do up to n cars at a time.  Then, do\
    \ the same for the\n        // \"right\" set of n cars, and merge the results.\n\
    \        var rightToLeft : Seq[Car] = new mutable.LinkedList[Car](n)\n       \
    \ val leftToRight = new mutable.LinkedList[Car](n)\n        var leftCounter :\
    \ Long = 0\n        var rightCounter : Long = 0\n        var leftCollision : Long\
    \ = 0\n        var rightCollision : Long = 0\n        while (rightToLeft.size\
    \ < n) {\n            val nextLeft : Car = Random.nextInt(n)\n            val\
    \ nextRight = Random.nextInt(n)\n            if (nextLeft < nextRight) {\n   \
    \             leftToRight.addFirst(nextLeft)\n                rightToLeft.addLast(nextRight)\n\
    \                leftCounter = leftCounter + 1\n                rightCounter =\
    \ rightCounter + 1\n            } else {\n                leftToRight.addLast(nextRight)\n\
    \                rightToLeft.addFirst(nextLeft)\n                rightCounter\
    \ = rightCounter + 1\n                leftCounter = leftCounter + 1\n        \
    \    }\n            leftCollision = leftCollision + (nextLeft ne nextRight)\n\
    \            rightCollision = rightCollision + (nextRight ne nextLeft)\n     \
    \   }\n        while (leftToRight.size < n) {\n            val nextLeft : Car\
    \ = Random.nextInt(n)\n            val nextRight = Random.nextInt(n)\n       \
    \     if (nextLeft < nextRight) {\n                rightToLeft.addFirst(nextRight)\n\
    \                leftToRight.addLast(nextLeft)\n                rightCounter =\
    \ rightCounter + 1\n                leftCounter = leftCounter + 1\n          \
    \  } else {\n                rightToLeft.addLast(nextLeft)\n                leftToRight.addFirst(nextRight)\n\
    \                leftCounter = leftCounter + 1\n                rightCounter =\
    \ rightCounter + 1\n            }\n            leftCollision = leftCollision +\
    \ (nextLeft ne nextRight)\n            rightCollision = rightCollision + (nextRight\
    \ ne nextLeft)\n        }\n        collision = collision + leftCounter - rightCounter\n\
    \        collision = collision + leftCollision - rightCollision\n        collision"]
stop_tokens:
- "\n    }\n"
