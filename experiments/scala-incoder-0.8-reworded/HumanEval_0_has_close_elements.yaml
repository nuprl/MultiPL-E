name: HumanEval_0_has_close_elements
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Check if in given list of numbers, are any two numbers closer to each other\
  \ than\n    // given threshold.\n    // >>> hasCloseElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat)), (0.5f))\n    // (false)\n    // >>> hasCloseElements((List[Float](1.0f.toFloat,\
  \ 2.8f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.3f))\n\
  \    // (true)\n    def hasCloseElements(numbers : List[Float], threshold : Float)\
  \ : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(hasCloseElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.3f))\
  \ == (true));\n    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)), (0.05f)) == (false));\n\
  \    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 5.9f.toFloat,\
  \ 4.0f.toFloat, 5.0f.toFloat)), (0.95f)) == (true));\n    assert(hasCloseElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat)), (0.8f)) == (false));\n\
  \    assert(hasCloseElements((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
  \ 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)), (0.1f)) == (true));\n    assert(hasCloseElements((List[Float](1.1f.toFloat,\
  \ 2.2f.toFloat, 3.1f.toFloat, 4.1f.toFloat, 5.1f.toFloat)), (1.0f)) == (true));\n\
  \    assert(hasCloseElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat,\
  \ 4.1f.toFloat, 5.1f.toFloat)), (0.5f)) == (false));\n    }\n\n}\n"
completions: ["        val diffs = numbers.map(x => (x - threshold).abs)\n       \
    \ val minDiff : Float = diffs.min\n        diffs.forall { diff => diff < minDiff\
    \ }", '        numbers.sliding(2).forall(x => x.map(_ - threshold).min < 0)',
  "        val sorted = numbers.toList.sortWith((x,y) => x.abs <=> y.abs)\n      \
    \  val n = sorted.size\n\n        var closeElem : Float = 0.0f\n        for( i\
    \ <- 0 until n ) {\n            if( Math.abs(sorted (i) - sorted((i+1) % n)) <\
    \ threshold ) {\n                closeElem = sorted (i)\n            }\n     \
    \   }\n\n        closeElem != 0.0f", "        numbers.zipWithIndex.filter{ case\
    \ (elem, index) =>\n            val lastElem = numbers(numbers.length-1)\n   \
    \         elem - threshold < lastElem - elem && elem - threshold > lastElem -\
    \ threshold\n        }.size == numbers.size", "        // Use mutable collection\
    \ to keep track of all pairs of elements that are not closer than threshold\n\
    \        // Also keep track of elements closer than threshold so that we can check\
    \ them on first pass through\n        val not_closer = mutable.LinkedHashSet[Float]()\n\
    \        val closer = mutable.LinkedHashSet[Float]()\n        for(a <- numbers)\
    \ {\n            for(e <- numbers.filter(_ != a))\n                if(a != e &&\
    \ not_closer.contains(e)) {\n                    not_closer remove e\n       \
    \             not_closer add a\n                    if(not_closer.size > threshold)\
    \ closer add a\n                }\n            not_closer add a\n        }\n\n\
    \        // If there are any closer elements, than it must have found at least\
    \ two elements that are closer\n        // We also need to check all elements\
    \ that are closer than threshold\n        // If they do not exceed threshold,\
    \ then we can return true\n        if(closer.size > 0) false\n        else not_closer.forall(x\
    \ => closer.contains(x) || not_closer.contains(x))", '        numbers.size >=
    2 && numbers.exists(number => math.abs(number - numbers(0)).abs < threshold)',
  '        numbers.forall(number => Math.abs(number - threshold) <= Math.abs(number
    - numbers.min))', "        numbers.forall {\n            x => numbers.map { y\
    \ => abs(x - y) < threshold }.forall(x => x)\n        }", "        val distances\
    \ = numbers.map(x => (x - threshold).abs)\n        val min = distances.min\n \
    \       if (min < distances.max) true else false", '        numbers.exists(x =>
    Math.abs(x - numbers.min) <= threshold)', "        require(numbers.nonEmpty)\n\
    \        require(numbers.size == numbers.size, \"List size does not match elements\"\
    )\n        require(threshold >= 0f && threshold <= 1f, s\"Threshold should be\
    \ between 0 and 1, inclusive\")\n\n        numbers.sorted.zipWithIndex.forAll\
    \ { case (n, i) => Math.abs(n.toFloat - numbers(i + (numbers.size - 1) * 0.5f))\
    \ <= threshold }", "        val sortedNumbers = numbers.sorted\n        val distances\
    \ = mutable.ArrayBuffer.empty[(Int, Float)]\n        val threshold = sortedNumbers.head.abs\
    \ * (threshold / 100)\n        var currentDistance = 0.0\n        var currentNumber\
    \ = sortedNumbers.head\n\n        for(i <- 0 until sortedNumbers.length)\n   \
    \         currentDistance = sortedNumbers(i) - currentNumber\n            distances\
    \ += ((i, currentDistance))\n            currentNumber = sortedNumbers(i)\n\n\
    \        distances.foreach { case (i, d) =>\n            val closest = distances.minBy(_._2)._2\n\
    \            if( d.abs <= threshold && d >= closest) {\n                return\
    \ true\n            }\n        }\n        false", "        if(numbers.isEmpty)\
    \ {\n            false\n        } else {\n            val sortedList = numbers.sortBy(_)\n\
    \            val leftSum = sortedList(0)\n            val rightSum = sortedList(0)\n\
    \            var closestElement : Float = null\n            val index = -1\n \
    \           for((number, value) <- sortedList) {\n                val difference\
    \ = math.abs(value - threshold)\n                val valueDiff = math.abs(value\
    \ - leftSum)\n                val valueDiff2 = math.abs(value - rightSum)\n  \
    \              if(difference <= valueDiff && difference <= valueDiff2) {\n   \
    \                 leftSum = value\n                    index = number\n      \
    \          }\n                if(value <= rightSum) {\n                    rightSum\
    \ = number\n                }\n                val difference2 = math.abs(value\
    \ - closestElement)\n                if(difference <= difference2) {\n       \
    \             closestElement = value\n                }\n            }\n     \
    \       closestElement != null\n        }", "        val list = new mutable.LinkedList[Float]()\n\
    \        for (n <- numbers) {\n            list += n\n        }\n        var found\
    \ = false\n        for (n1 <- list) {\n            for (n2 <- list) {\n      \
    \          if (Math.abs(n1 - n2) <= threshold) {\n                    found =\
    \ true\n                }\n            }\n        }\n        found", "       \
    \ val diff = (0 until numbers.size).map(x => numbers(x) - threshold).filter(x\
    \ => x != 0.0f).sum\n        diff < 0.0001f", "        val threshold1 = threshold\
    \ * threshold\n        numbers.forall { x =>\n            val y = numbers.filter(n\
    \ => Math.abs(x - n) < threshold1).min\n            y < x && y != x\n        }",
  "        val elements = numbers.map(x => (x % 1) == 0)\n        val differences\
    \ = elements.zip(elements.tail).map(x => Math.abs(x._1 - x._2)).filter(x => x\
    \ > threshold)\n        if (differences.isEmpty) {\n            false\n      \
    \  } else {\n            true\n        }", "        val result = mutable.LinkedHashMap[Float,\
    \ Float]()\n        numbers.foreach{ elem =>\n            val previousDistance\
    \ = result.getOrElse(elem, 0f)\n            val currentDistance = previousDistance\
    \ + elem\n            val difference = currentDistance - threshold\n         \
    \   if (currentDistance < threshold) {\n                result.put(elem, currentDistance)\n\
    \            } else {\n                result.put(elem, difference)\n        \
    \    }\n        }\n        !result.isEmpty", "        numbers.exists(\n      \
    \      x => math.abs(x - numbers.head) < threshold\n        )", "        var minIndex\
    \ = -1\n        var minDiff = Float.PositiveInfinity\n        var minNum = 0.0f\n\
    \        numbers.foreach(num => {\n            var diff = abs(num - threshold)\n\
    \            if (diff < minDiff) {\n                minIndex = numbers.indexOf(num)\n\
    \                minDiff = diff\n                minNum = num\n            }\n\
    \        })\n        return minIndex != -1", "        numbers.toSet.toList.groupBy(_\
    \ - threshold).map {\n            case (threshold, group) => if (group.length\
    \ == 1) false else if (group.length == 2) group(0).productIterator.forall(x =>\
    \ group(0).productIterator.toSet.contains(x)) else false\n        }.forall(x =>\
    \ x) == false", "      val nums = numbers.toList\n      // Sort by distance from\
    \ center\n      val sortedNums = nums.sortWith((num1, num2) => (num1 - num2).abs)\n\
    \      val center = sortedNums.size / 2\n      // Return true if distance from\
    \ center is smaller than threshold\n      val flag = sortedNums.sliding(center).forall\
    \ {\n        case Seq(_, _) => (sortedNums.head - center).abs <= threshold\n \
    \       case _ => true\n      }\n      flag", "        if (numbers.size < 2) {\
    \ return false }\n        var currentMax : Float = numbers.min\n        var currentMin\
    \ : Float = numbers.max\n        val closeSet : Set[Float] = numbers.filter(x\
    \ => Math.abs(x - currentMax) < threshold) ++\n                              \
    \     numbers.filter(x => Math.abs(x - currentMin) < threshold)\n        if (closeSet.size\
    \ < 2) { return false }\n        val closestPair = closeSet.toArray\n        (currentMax,\
    \ currentMin)", "        val sortedList = numbers.sortWith(_.toDouble < _.toDouble)\n\
    \        val lastElement = sortedList(0)\n        val counter = sortedList.zipWithIndex.map\
    \ { case (element, index) => if(index != 0) (element - lastElement)/lastElement\
    \ else 0 }\n        val closerPairs = counter.groupBy(_._2).mapValues(_.map(_._1).toList)\n\
    \        closerPairs.forall { case (threshold, numbers) => numbers.forall(number\
    \ => number <= threshold) }", "        val elements = numbers.size\n        var\
    \ result = false\n        var i = 1\n        while (i <= elements) {\n       \
    \     if (numbers(i-1) + threshold > numbers(i)) {\n                result = true\n\
    \                break\n            }\n            i += 1\n        }\n       \
    \ result", "        numbers.foldLeft(true)((acc, n) => {\n            if(acc.orElse(Math.abs(n\
    \ - numbers(0)) < threshold)) {\n                if(acc.orElse(Math.abs(n - numbers(1))\
    \ < threshold)) {\n                    if(acc.orElse(Math.abs(n - numbers(2))\
    \ < threshold)) {\n                        false\n                    } else {\n\
    \                        true\n                    }\n                } else {\n\
    \                    true\n                }\n            } else {\n         \
    \       acc\n            }\n        })", "        val set = numbers.toSet\n  \
    \      val differences = numbers.zipWithIndex.map{case (n, i) => abs(n - threshold)}.toSet\n\
    \        differences.isEmpty || set.isSubsetOf(differences)", '        numbers.exists((number:
    Float) => Math.abs(number - threshold) < numbers.length/2.0)', "        val d\
    \ = numbers.map(x => x - threshold).map(x => math.sqrt(x.toDouble)).max\n    \
    \    d < 0.01f", "        // initialize counter for number of consecutive elements\n\
    \        var counter = 0\n        var closestElements = List[Int]()\n        numbers.foreach(\
    \ n => {\n            // increment counter\n            counter += 1\n       \
    \     // check if element is closer to previous one\n            if (n < numbers(counter\
    \ - 1)) {\n                // if yes, store first element and increment counter\
    \ by one\n                closestElements = closestElements :+ (counter - 1) :+\
    \ counter\n                // if not, decrease counter\n                counter\
    \ -= 1\n            } else {\n                // if no, decrease counter and add\
    \ counter to list of closest elements\n                counter -= 1\n        \
    \        closestElements = closestElements :+ counter\n            }\n       \
    \     // if we are close enough to threshold, return true\n            if (counter\
    \ == numbers.length - 1) {\n                // and break out of foreach\n    \
    \            break\n            }\n        })\n        // if we are here we have\
    \ found at least 2 elements that are close to each other\n        counter <= 2",
  "        var pairs = numbers.zipWithIndex.filter(_._2 % 2 == 1).groupBy(n => n)\n\
    \        pairs = pairs.mapValues(_.toList.sortWith(_._1 < _._1) :+ _._2)\n   \
    \     pairs.exists (pair._2 != 0)", '        numbers.zipWithIndex.forall { case
    (n, i) => Math.abs(n - numbers(i)) <= threshold }', "        if (numbers == null\
    \ || numbers.length == 0) return true\n        var isCloseToThese = false;\n \
    \       var num = new MutableList[Float]()\n        numbers.foreach { x =>\n \
    \           num append x\n        }\n        for (i <- 0 to num.length - 1) {\n\
    \            var previous = num(i), next = num(i+1);\n            var distance\
    \ = math.sqrt(math.pow((next - previous), 2) + math.pow((next - previous), 2))\n\
    \            if (distance < threshold) {\n                isCloseToThese = true\n\
    \            }\n        }\n        return isCloseToThese", "        var closeEl\
    \ : Float = numbers.head\n        for (el <- numbers) {\n            if (Math.abs(closeEl\
    \ - el) < threshold) {\n                closeEl = el\n            }\n        }\n\
    \        (numbers.size >= 2) && (closeEl != numbers.last)", "        var minDistance\
    \ = 0.0f\n        numbers.foreach {\n            number =>\n                val\
    \ distance = (number - numbers.head).abs.abs\n                val minDistance\
    \ =\n                    if (distance < minDistance) distance\n              \
    \      else minDistance\n        }\n        minDistance < threshold", "      \
    \  // Use a Map to hold the distances from each number\n        val map = new\
    \ mutable.HashMap[Float, Float]()\n        numbers.foreach { n =>\n          \
    \  val dist = Math.abs(n-1f)\n            map.put(dist, map.getOrElse(dist, 0f)\
    \ + n)\n        }\n        map.size == numbers.size", '        numbers.toList.groupBy(x
    => x).map(_._2.size).min._2 > threshold', "        val minDistance : Float = numbers.min.abs\n\
    \        val maxDistance : Float = numbers.max.abs\n        val minElement = numbers.min\n\
    \        val maxElement = numbers.max\n        val elements : List[Float] = numbers.toList\n\
    \n        if(minDistance < threshold * maxDistance) return true\n        else\
    \ if(minDistance > maxDistance * threshold) return false\n        else if(minElement\
    \ == maxElement) return false\n\n        var closerToLeft : Option[Float] = None\n\
    \        var closerToRight : Option[Float] = None\n        var closerToMiddle\
    \ : Option[Float] = None\n\n        for(i <- elements) {\n            val distanceToElement\
    \ = abs(minDistance - i)\n\n            if(minDistance < threshold * maxDistance\
    \ && distanceToElement < threshold) {\n                closerToLeft = Some(i)\n\
    \                minDistance = distanceToElement\n            }\n            else\
    \ if(minDistance > maxDistance * threshold && distanceToElement < minDistance)\
    \ {\n                closerToRight = Some(i)\n                minDistance = distanceToElement\n\
    \            }\n            else if( minDistance > maxDistance * threshold &&\
    \ distanceToElement > maxDistance) {\n                closerToMiddle = Some(i)\n\
    \                minDistance = distanceToElement\n            }\n        }\n\n\
    \        (closerToLeft != None) || (closerToRight != None) || (closerToMiddle\
    \ != None)", "        val sortedNumbers = numbers.toList\n        val closeNumbers\
    \ = sortedNumbers.sliding(2)\n        val threshold = threshold * threshold\n\
    \        val result = closeNumbers.forall(x => x.forall(y => y < threshold))\n\
    \        result", "        val sortedList = numbers.sorted\n        val firstClose\
    \ = sortedList.takeWhile(_ < threshold).last\n        val secondClose = sortedList.takeWhile(_\
    \ > threshold).last\n        firstClose == secondClose", "        var count :\
    \ Int = 0\n        numbers.foreach { n =>\n            val difference = math.sqrt(math.pow(n-threshold,2)+math.pow(n-threshold,2))\n\
    \            if (difference < 0.0001f) count += 1\n        }\n        count >\
    \ 0", "        val sortedNumbers = numbers.sorted\n        val diffs = sortedNumbers.zipWithIndex.map\
    \ { case (v, i) => math.abs(v - sortedNumbers(i)) }\n        // We are looking\
    \ for pairs whose difference is bigger than threshold\n        val threshold =\
    \ threshold\n        val maxDifference = math.max(diffs.toSeq)\n        val pairs\
    \ = diffs.filter(_ > threshold).toSeq.filter(_ > maxDifference)\n        pairs.size\
    \ == numbers.size", "        numbers.foldLeft((List[Float](), List[Float]())){\
    \ case ((smaller, greater), element) =>\n            if (element <= threshold)\
    \ ((List(element), List(element)), (smaller, greater))\n            else if (element\
    \ > threshold) ((List(element), smaller), (smaller, greater.reverse))\n      \
    \      else ((smaller, List(element)), (smaller, greater.reverse))\n        }._2.isEmpty\
    \ == true", "        if(numbers.isEmpty)\n            return false\n        val\
    \ distance = numbers.map((_, 0.0f)).map(x=> math.abs(x._1 - x._2)).sum\n     \
    \   return (distance < threshold)", "        if (numbers.isEmpty)\n          \
    \  true\n        else\n            val closestNumbers = numbers.map(math.min)\n\
    \            val closest = closestNumbers.head\n            val diffs = numbers.map(n\
    \ => math.abs(n - closest)).toArray\n            val threshold = threshold.toFloat\n\
    \            if (diffs.forall(math.abs <= threshold))\n                true\n\
    \            else\n                false", '        numbers.groupBy(x => math.abs(x
    - threshold)).size > 0', "        // Using sorted list to ensure all pairs within\
    \ range\n        val sortedNumbers = numbers.toList\n        val range = sortedNumbers.max\
    \ - sortedNumbers.min\n        if (range <= 0.0) {\n            false\n      \
    \  } else {\n            var minIdx : Int = sortedNumbers.indexWhere(x => x <=\
    \ threshold)\n            if (minIdx > 0) {\n                minIdx -= 1\n   \
    \             val minElem = sortedNumbers(minIdx)\n                minIdx = sortedNumbers.indexWhere(x\
    \ => x > minElem && x <= threshold)\n                minIdx match {\n        \
    \            case i if i < 0 => false\n                    case i => true\n  \
    \              }\n            } else {\n                sortedNumbers.isEmpty\
    \ || sortedNumbers.size == 1\n            }\n        }", "        val lists =\
    \ numbers :+ numbers.getOrElse(0.0f)\n        var lastClose = numbers.getOrElse(0.0f)\n\
    \        for(i <- lists.indices) {\n            val currentClose = numbers.get(i).abs\n\
    \            if(currentClose < lastClose + threshold) lastClose = currentClose\n\
    \        }\n        lastClose < threshold", "        val dist = (numbers(0) -\
    \ numbers(1)).abs\n\n        if (dist < threshold) {\n            return false\n\
    \        }\n\n        for (i <- 2 to numbers.size - 1) {\n            val nextDist\
    \ = (numbers(i) - numbers(i - 1)).abs\n            if (nextDist < dist && nextDist\
    \ < threshold) {\n                return true\n            }\n        }\n\n  \
    \      false", "        val map = numbers.foldLeft(Map[Float, Float]())((map,\
    \ number) => {\n            val value = map(number.toFloat)\n            if (value\
    \ == None) map + (number -> (number + 1.0f)) else map + (number -> ((value + 1.0f)\
    \ + 0.5f))\n        })\n        map.values.exists(_ > threshold)", "        val\
    \ pairs: List[(Int, Int)] = numbers.zipWithIndex\n        pairs.sortWith( (a,\
    \ b) => a._1 - b._1)\n            .find(pairsWithIndex => {\n                var\
    \ a = pairsWithIndex._1\n                var b = pairsWithIndex._2\n         \
    \       val diff = a.toDouble - b.toDouble\n                val epsilon = threshold\n\
    \                (diff < epsilon)\n            })\n            .isDefined", " \
    \       // Find minimum distance between adjacent elements\n        val distances\
    \ = numbers.foldLeft(0.0f)((acc,x) => math.abs(acc - x) + x)\n        // If any\
    \ adjacent elements are less than threshold, return false \n        return distances\
    \ < (numbers.size + threshold)", "        val m = numbers.foldLeft(0.0f) { (sum,\
    \ n) => sum + n.toFloat }\n        if (m == 0.0f) return true\n        val n =\
    \ numbers.foldRight(0.0f) { (sum, n) => sum + n.toFloat }\n        return abs(m\
    \ - n) < threshold", "        numbers.foldLeft(false)((res, element) =>\n    \
    \        (res & Math.abs(element - numbers(numbers.indexOfLast(element < numbers).toInt)))\
    \ < threshold)", "        numbers.foldLeft(true) {\n            case (hasClose,\
    \ element) =>\n                val diff = element - threshold\n              \
    \  if (diff <= 0) {\n                    false\n                } else {\n   \
    \                 hasClose && diff < 0\n                }\n        }", '        numbers.map((_
    - threshold).abs).min < 0.0f', "        val sortedNumbers = numbers.sort\n   \
    \     val currentMin = sortedNumbers(0)\n        val currentMax = sortedNumbers(sortedNumbers.length\
    \ - 1)\n        val middle = (currentMax + currentMin) / 2\n        var hasBeenCalled\
    \ = false\n\n        val isCloser = () => {\n            val current = sortedNumbers(sortedNumbers.length\
    \ - 1)\n            val next = sortedNumbers(sortedNumbers.length - 2)\n\n   \
    \         if (Math.abs(currentMax - current) < Math.abs(currentMax - next)) {\n\
    \                if (current < middle && next > middle) {\n                  \
    \  hasBeenCalled = true\n                    true\n                } else if (current\
    \ > middle && next < middle) {\n                    hasBeenCalled = true\n   \
    \                 false\n                } else {\n                    false\n\
    \                }\n            } else {\n                if (current < middle\
    \ && next > middle) {\n                    hasBeenCalled = true\n            \
    \        false\n                } else if (current > middle && next < middle)\
    \ {\n                    hasBeenCalled = true\n                    true\n    \
    \            } else {\n                    true\n                }\n         \
    \   }\n        }\n\n        isCloser()", '        numbers.map(_.toFloat).map(_.toInt).zip(numbers.map(_.toInt)).reduce(_+_)
    < (numbers.map(_.toInt).map(_.toFloat).reduce(_+_) - threshold*2)', "        val\
    \ list = numbers.toList\n        val sortedList = list.sorted\n        val differenceBetween\
    \ = sortedList.diff(sortedList.tail).length\n        val threshold = sortedList.last\n\
    \n        val closestToEnd = sortedList.head + threshold - differenceBetween\n\
    \        val closestToStart = (sortedList.head - threshold) - differenceBetween\n\
    \n        val minDiff = if (differenceBetween > threshold) differenceBetween else\
    \ threshold\n        val minDiffIndex = (sortedList zip sortedList.tail).minBy(_._2)._1\n\
    \        minDiff <= differenceBetween", "        numbers.exists((number:Float)\
    \ => {\n            val distance1 = scala.math.pow((number - threshold),2);\n\
    \            val distance2 = scala.math.pow((threshold - number),2);\n       \
    \     val distance = math.sqrt(distance1 + distance2);\n            if (distance\
    \ < (threshold * threshold)) {\n                return true;\n            }\n\
    \        })", "        val set = new mutable.HashSet[Float]()\n        numbers.foreach{\
    \ number =>\n            set.add((number))\n        }\n        if (set.size ==\
    \ 0) false\n        else if (set.size == 1) true\n        else {\n           \
    \ val sortedSet : Set[Float] = set.toSeq.sortWith(_ < _)\n            val sortedSetSize\
    \ : Int = sortedSet.size\n            val closestElementsSize = (sortedSetSize\
    \ * threshold).toInt\n            val currentElement : Float = sortedSet.toSeq(0)\n\
    \            val currentElementSize : Int = sortedSetSize\n            for {\n\
    \                i <- (1 to closestElementsSize)\n                j <- (1 to closestElementsSize)\n\
    \            } yield {\n                if (sortedSetSize == (currentElementSize\
    \ * threshold)) true\n                else {\n                    val diff = (currentElement\
    \ - sortedSet(j)).toFloat\n                    val absDiff = Math.abs(diff)\n\
    \                    absDiff < threshold && (absDiff < ((currentElementSize -\
    \ i) * threshold))\n                }\n            }\n        }", "        if\
    \ (numbers.isEmpty)\n            return false\n        var minimum = numbers.head\n\
    \        var maximum = numbers.last\n        var elementCount = numbers.size\n\
    \        for (i <- 1 until elementCount) {\n            var currentValue = numbers.apply(i)\n\
    \            var newMinimum = minimum\n            var newMaximum = maximum\n\
    \            var newElementCount = elementCount\n            var threshold = elements.size\
    \ / 2\n            if (currentValue < minimum) {\n                newMinimum =\
    \ currentValue\n                newMaximum = minimum\n                newElementCount\
    \ = 1\n            }\n            else if (currentValue > maximum) {\n       \
    \         newMinimum = minimum\n                newMaximum = currentValue\n  \
    \              newElementCount = 1\n            }\n            else if (currentValue\
    \ < minimum + threshold) {\n                newMinimum = currentValue\n      \
    \          newMaximum = minimum\n                newElementCount = 1\n       \
    \     }\n            else if (currentValue > maximum - threshold) {\n        \
    \        newMinimum = minimum\n                newMaximum = currentValue\n   \
    \             newElementCount = 1\n            }\n            else if (minimum\
    \ == maximum) {\n                newMinimum = minimum\n                newMaximum\
    \ = minimum\n                newElementCount = 1\n            }\n            else\
    \ {\n                var mid = (newMinimum + newMaximum) / 2\n               \
    \ if (mid < currentValue) {\n                    newMinimum = mid\n          \
    \          newMaximum = mid\n                    newElementCount = elementCount\
    \ - 1\n                }\n                else if (mid > currentValue) {\n   \
    \                 newMinimum = mid\n                    newMaximum = mid\n   \
    \                 newElementCount = elementCount - 1\n                }\n    \
    \            else {\n                    newMinimum = currentValue\n         \
    \           newMaximum = currentValue\n                    newElementCount = elementCount\
    \ - 1\n                }\n            }\n            if (newElementCount > elementCount)\n\
    \                return true\n            else\n                elementCount =\
    \ newElementCount\n        }\n        return false", '        numbers.map(_.toFloat).map(i
    => Math.abs(i - threshold)).min < threshold', "        numbers.foreach{ x =>\n\
    \            if (Math.abs(numbers.indexWhere{ x => x < threshold - 0.0000000001\
    \ }.toDouble) - numbers.indexWhere{ x => x < threshold + 0.0000000001 }.toDouble)\
    \ < 1) {\n                return true\n            }\n        }\n        false",
  "        var i = 1\n        var j = 1\n        var close = numbers.get(0)\n    \
    \    val closed = numbers.get(0)\n        while (i < numbers.size && j < numbers.size)\
    \ {\n            if (Math.abs(numbers(i) - numbers(j)) <= threshold) {\n     \
    \           closed = numbers(i)\n                close = numbers(j)\n        \
    \        i += 1\n                j += 1\n            } else {\n              \
    \  closed = numbers(j)\n                close = numbers(i)\n                j\
    \ += 1\n            }\n        }\n        return close == closed", "        val\
    \ numberSet = numbers.toSet\n        for (elem <- numberSet) {\n            val\
    \ distToNeighbours = Math.abs(elem - numbers.min.abs)\n            if (distToNeighbours\
    \ < threshold) {\n                return true\n            }\n        }\n    \
    \    return false", "        val n = numbers.size\n        val d = numbers.map(x\
    \ => abs(x - threshold)).sum\n        (n != 0) &&\n          (n <= d) &&\n   \
    \       numbers.forall(x => abs(x - threshold) < threshold)", "        val closed\
    \ = mutable.LinkedHashSet[Float]()\n        val closest = numbers.get(0)\n   \
    \     for (number <- numbers.drop(1)) {\n            if (number != closest &&\
    \ (Math.abs(number - closest) < threshold)) {\n                closed += number\n\
    \                closest = number\n            }\n        }\n        closed.isEmpty",
  '        numbers.foldLeft(true)(_ || _)', "        // 1. Create a list of pairs\
    \ of adjacent numbers in the list.\n        val pairs = numbers.zip(numbers.tail).filter\
    \ { case (first, second) => second > first }\n\n        // 2. Create list of pairs\
    \ sorted by first element of the pair.\n        val pairSorted = pairs.sortWith(_.f1\
    \ < _.f2)\n\n        // 3. Check if any two numbers are closer than given threshold.\n\
    \        pairSorted.exists { case (a, b) =>\n            Math.abs(a - threshold)\
    \ < Math.abs(b - threshold)\n        }", "        numbers.foldLeft(true)((acc,\
    \ number) => {\n            val close = math.abs(math.abs(number - threshold)\
    \ - threshold) < Math.abs(math.abs(number - numbers(numbers.indexOf(number)) %\
    \ numbers.size))\n            acc && close\n        })", "        // Find minimum\
    \ value from numbers and store it.\n        var minimum = numbers.min\n      \
    \  val numsCopy = numbers.toList\n\n        // Loop through each element and compare\
    \ with minimum value.\n        for(i <- 0 until numsCopy.size) {\n           \
    \ val currentElement = numsCopy(i)\n\n            // Compare two adjacent elements\
    \ to check if they are closer or not.\n            if( i != numsCopy.size - 1\
    \ ) {\n                if( Math.abs(currentElement - minimum) > threshold ) {\n\
    \                    minimum = currentElement\n                }\n           \
    \ }\n        }\n\n        // If we got minimum value, then we know that there\
    \ are two elements that are closer to each other\n        // than given threshold.\n\
    \        minimum != 0.0f && minimum < threshold", "        // Return true when\
    \ numbers are sorted\n        if(numbers.isEmpty) return\n\n        // If list\
    \ contains just one element, then no two numbers can be closer than\n        //\
    \ threshold\n        if(numbers.size == 1) return\n\n        // If number of elements\
    \ is odd, then just check if first element can be closer than\n        // threshold\n\
    \        if(numbers.size % 2 == 1) {\n            val first = numbers.head\n \
    \           if(numbers.size == 2) return first < threshold\n            val firstDiff\
    \ = math.abs(first - threshold)\n            val secondDiff = math.abs(numbers.last\
    \ - threshold)\n            if(firstDiff < secondDiff) return\n        }\n\n \
    \       // Check if all elements are closer than threshold\n        val first\
    \ = numbers.head\n        val last = numbers.last\n        if(numbers.size ==\
    \ 2) return first < threshold && last < threshold\n        val firstDiff = math.abs(first\
    \ - threshold)\n        val secondDiff = math.abs(numbers.last - threshold)\n\
    \        return firstDiff < secondDiff", "        numbers.exists { n =>\n    \
    \        var minDistance : Float = sys.float.PositiveInfinity\n            val\
    \ candidates = numbers.filter { x =>\n                val d = ((n - x) * (n -\
    \ x)).abs\n                if (d < minDistance) {\n                    minDistance\
    \ = d\n                    false\n                } else {\n                 \
    \   true\n                }\n            }\n            candidates.forall(_.toFloat\
    \ < threshold)\n        }", "        val list = numbers.toList\n        var lowest:\
    \ Float = numbers.head\n        val lowestIndex = numbers.indexOf(lowest)\n  \
    \      val maxDifference = numbers.map(_.toFloat).sum\n        for ((index, number)\
    \ => number - threshold > lowest) yield\n            if (list.remove(index)) lowest\n\
    \        else\n            false\n        maxDifference - lowest < 0", "     \
    \   val closestTo = numbers.zip(numbers.zipWithIndex).filter(_._1.toFloat - threshold\
    \ < _._2.toFloat && _._2.toFloat < _._1.toFloat)\n        if (closestTo.size ==\
    \ 0) false else closestTo.forall(_._1 == true)", "        val result = numbers.foldLeft(true){\n\
    \            case (true, a) =>\n                val closest = numbers.indexOf(a.abs)\n\
    \                if (closest != numbers.indexOf(a.abs) && a.abs < threshold &&\
    \ numbers.count(x => x.abs < a.abs) < 2) {\n                    false\n      \
    \          } else {\n                    true\n                }\n        }\n\
    \        result", "        val list = numbers.toList\n        for (i <- 0 until\
    \ list.size - 1) {\n            if (abs(list(i) - list(i + 1)) > threshold) {\n\
    \                return true\n            }\n        }\n        false", '        numbers.count(_
    => math.abs(_ - threshold) < 1e-12) > 1', "        var hasCloseElements = false\n\
    \n        // Sort array by absolute values\n        numbers.sortWith((x, y) =>\
    \ math.abs(y) < math.abs(x))\n        numbers.foreach(x => if (math.abs(x) < math.abs(threshold))\
    \ {\n            if (x == 0.0f || x == 1.0f) hasCloseElements = true\n       \
    \ } else {\n            hasCloseElements = true\n        })\n\n        return\
    \ hasCloseElements", "        val sortedNumbers = numbers.toList.sortWith(_ <\
    \ _)\n        if (sortedNumbers.isEmpty) return false\n        if (sortedNumbers.last\
    \ - sortedNumbers.head > threshold) return true\n        val maxDifference = (sortedNumbers.last\
    \ - sortedNumbers.head) / 2.0\n        val elements = sortedNumbers.takeWhile(_\
    \ < maxDifference)\n        if (elements.length == 0) return false\n        elements.forall(el\
    \ => hasCloseElements(numbers.tail, threshold)) &&\n            hasCloseElements(numbers.tail.reverse,\
    \ threshold)", "        var index = 0\n        var count = 2\n        // Find\
    \ two closest numbers less than or equal to threshold.\n        numbers.zipWithIndex.foreach\
    \ { n =>\n            if (n._2 < threshold) count -= 1\n            if (n._2 >\
    \ threshold) count += 1\n            index += 1\n            if (index >= count)\
    \ return false\n        }\n        index = 0\n        count = 1\n        // Find\
    \ two closest numbers greater than or equal to threshold.\n        numbers.zipWithIndex.foreach\
    \ { n =>\n            if (n._2 < threshold) count -= 1\n            if (n._2 >=\
    \ threshold) count += 1\n            index += 1\n            if (index >= count)\
    \ return false\n        }\n        index = 0\n        count = 2\n        // Find\
    \ two closest numbers greater than or equal to or less than threshold.\n     \
    \   numbers.zipWithIndex.foreach { n =>\n            if (n._2 < threshold && n._2\
    \ > numbers.last._2) count -= 1\n            if (n._2 >= threshold && n._2 <=\
    \ numbers.last._2) count += 1\n            index += 1\n            if (index >=\
    \ count) return false\n        }\n        index = 0\n        count = 1\n     \
    \   // Find two closest numbers greater than or equal to or less than or equal\
    \ to threshold.\n        numbers.zipWithIndex.foreach { n =>\n            if (n._2\
    \ < threshold && n._2 > numbers.last._2) count -= 1\n            if (n._2 >= threshold\
    \ && n._2 <= numbers.last._2) count += 1\n            index += 1\n           \
    \ if (index >= count) return false\n        }\n        index = 0\n        count\
    \ = 2\n        // Find two closest numbers greater than or equal to or less than\
    \ or equal to or greater than threshold.\n        numbers.zipWithIndex.foreach\
    \ { n =>\n            if (n._2 < threshold && n._2 > numbers.last._2) count -=\
    \ 1\n            if (n._2 >= threshold && n._2 <= numbers.last._2) count += 1\n\
    \            if (n._2 < threshold && n._2 <= numbers.last._2) count -= 1\n   \
    \         if (n._2 >= threshold && n._2 > numbers.last._2) count += 1\n      \
    \      index += 1\n            if (index >= count) return false\n        }\n \
    \       return true", "        for (a <- numbers.toSeq) yield {\n            for\
    \ (b <- numbers.toSeq) yield {\n                if (Math.max(Math.abs(a - b),\
    \ Math.abs(b - a)) < threshold) {\n                    return true\n         \
    \       }\n            }\n        }\n        false", "        val a = numbers.map(x\
    \ => x - threshold)\n        val b = numbers.map(x => x + threshold)\n       \
    \ val c = numbers.zip(numbers)\n        val d = numbers.zipWithIndex.map(x =>\
    \ x._2.zip(x._1).map(y => (y._2 - y._1).abs).sum)\n        ((c.toSet intersect\
    \ d).size >= 2)", "        // Using a hash set instead of a sorted list for performance.\n\
    \        var setHash = new scala.collection.mutable.HashSet[Float]\n        for\
    \ (number <- numbers) {\n            setHash.add(number)\n        }\n\n      \
    \  // Check if set has any pair of numbers in given threshold distance\n     \
    \   val pairs = sets.filter(set => setHash.intersect(set).length == 2)\n\n   \
    \     // Check if any pairs exist\n        setHash.size == pairs.size", "    \
    \    numbers.exists { number =>\n            val closest = (numbers, List.empty)\n\
    \            numbers.map {\n                case n => if (abs(n - number) < threshold)\
    \ n else closest(n :: closest(closest._1), closest._2)\n            }.exists {\
    \ x => x == number }\n        }", "        val sorted = numbers.toList.sorted\n\
    \        val closestTo0 = sorted.head\n\n        (sorted.length == 2) ||\n   \
    \     (Math.abs(closestTo0 - sorted.last) < threshold) ||\n        (Math.abs(sorted.last\
    \ - sorted.head) < threshold)", "        val sortedNums = numbers.sorted\n   \
    \     for (i <- 0 until sortedNums.length - 1) {\n            val num1 = sortedNums(i)\n\
    \            val num2 = sortedNums(i + 1)\n            if (Math.abs(num1 - num2)\
    \ < threshold) {\n                return true\n            }\n        }\n    \
    \    false", '      numbers.map(n => Math.abs(n - numbers(numbers.indexOf(n)))
    < threshold).forall(!_)', '        numbers.foldLeft(true){ (acc, elm) => acc &&
    elm <= threshold}', "        val pairs = numbers.map((_, number)).toMap\n    \
    \    numbers.exists(pair => {\n            val lowerValue = pair._1\n        \
    \    val higherValue = pair._2\n            val thresholdDifference = higherValue\
    \ - threshold\n            val lowerDifference = threshold - lowerValue\n    \
    \        val diff = math.abs(thresholdDifference - lowerDifference)\n        \
    \    diff < thresholdDifference\n        })", "        val numSet = numbers.toSet\n\
    \        val min = numbers.min\n        val max = numbers.max\n        var minSet\
    \ = numSet.toSet\n        var maxSet = numSet.toSet\n\n        // Remove all numbers\
    \ that are smaller than min from both sets\n        minSet = minSet - min\n  \
    \      maxSet = maxSet - max\n        val common = minSet.intersect(maxSet)\n\
    \        minSet.clear()\n        maxSet.clear()\n\n        common.isEmpty", " \
    \       // If no numbers were supplied return false\n        if (numbers.isEmpty)\
    \ {\n            return false\n        }\n\n        // If no threshold was supplied\
    \ return true\n        if (threshold < 0f) {\n            return true\n      \
    \  }\n\n        // Define a list of elements that are closer to each other\n \
    \       val closedElements = mutable.HashSet[Float]()\n\n        // Go through\
    \ each element in the list of numbers\n        numbers.foreach(x => {\n      \
    \      // Go through each element in the list of numbers and see if it's closer\
    \ to x than the current element\n            numbers.foreach(y => {\n        \
    \        // If two elements are closer to each other than the threshold then add\
    \ x and y to the list\n                if (abs(x - y) <= threshold) {\n      \
    \              closedElements += x\n                    closedElements += y\n\
    \                }\n            })\n        })\n\n        // If two elements are\
    \ closer to each other than the threshold return true otherwise false\n      \
    \  closedElements.size == 2", "        val closeElements  = mutable.HashSet[Float]()\n\
    \        val sortedNumbers  = numbers.sortBy(math.abs(_))\n        val firstElement\
    \ = sortedNumbers(0)\n        val secondElement = sortedNumbers(1)\n        //\
    \ for each pair of numbers, check if they are close enough\n        (firstElement,\
    \ secondElement) match {\n            case (firstElement, secondElement) if (Math.abs(firstElement)\
    \ < threshold) && (Math.abs(secondElement) < threshold) =>\n                closeElements\
    \ += firstElement\n                closeElements += secondElement\n          \
    \  case _ =>\n        }\n        // if the number of elements is greater than\
    \ 2 then two numbers have to be in the same group\n        closeElements.size\
    \ > 1", "        // Sorting will ensure that the closest two numbers are in consecutive\
    \ positions \n        // and they will get closer to each other by increasing\
    \ distance.\n        val sortedList = numbers.sortWith(_ < _)\n        // Two\
    \ numbers are considered close, if their difference is less than threshold\n \
    \       // so we need to check both adjacent pairs\n        val close = sortedList.sliding(2).forall\
    \ { pairs =>\n            Math.abs(pairs.last - pairs.head) <= threshold\n   \
    \     }\n        close", '        numbers.count(_ > threshold) > 1', "       \
    \ val distances = numbers.map(\n            x => Math.abs(x - threshold)) // Map\
    \ to list of distance from threshold\n        distances.forall(distance => distance\
    \ < 0.5f) // Check if all distances smaller than threshold", "        val map\
    \ = new HashMap[Int, Float]()\n        numbers.foreach { number =>\n         \
    \   if (map.contains(number)) {\n                if (Math.abs(map.get(number)\
    \ - threshold) < Math.abs(map.get(number) - number))\n                    false\n\
    \                else\n                    true\n            }\n            else\
    \ {\n                map.put(number, number)\n            }\n        }", "   \
    \     val numPairsMap = numbers.map {\n            n => n -> (math.abs(n.toFloat\
    \ - 1.0f), n) }.toMap\n        val numPairs = numPairsMap.toSeq\n        val numPairsSortedByKey\
    \ = numPairs.sortBy(_._1)\n        val closerTo = numPairsSortedByKey.last\n \
    \       (closerTo.last._2 < threshold) }\n}\n</code>\n<|/ a tags=scala,functional-programming\
    \ |>\n<| a tags=scala,functional-programming |>\nI think I finally have found\
    \ a solution for your problem :)\n<code>\ndef hasCloseElements(numbers: List[Float],\
    \ threshold: Float): Boolean = {\n  val distances = numbers.map(distance => distance\
    \ -> distance)\n  val sorted = distances.toSeq.sortBy(_._2)\n  val current = sorted.last\n\
    \  current._2 < threshold\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThis answer\
    \ is not Scala specific, and will work well with any Scala collection type. First,\
    \ compute the distances between the elements, and then check whether all elements\
    \ are closer than a given threshold. \nFirst define this function:\n<code>\n \
    \ def findCloseElements[A](a: Seq[A], threshold: Float) = {\n    val dist = a\n\
    \      .zipWithIndex\n      .map { case (v, i) => v -> math.abs(i - a.indexOf(v))\
    \ }\n      .toMap\n\n    (dist forall { case (v, d) =>\n      d < threshold\n\
    \    }).get\n  }\n</code>\nThen try it out:\n<code>\nscala> findCloseElements(List(1,2,3,4,5,6,7,8,9,10),\
    \ 0.3)\nres1: Float = 0.0\n\nscala> findCloseElements(List(1,2,3,4,5,6,7,8,9,10),\
    \ 0.4)\nres2: Float = 0.5\n\nscala> findCloseElements(List(1,2,3,4,5,6,7,8,9,10),\
    \ 0.8)\nres3: Float = 0.5\n\nscala> findCloseElements(List(1,2,3,4,5,6,7,8,9,10),\
    \ 0.3)\nres4: Float = 0.5\n\nscala> findCloseElements(List(1,2,3,4,5,6,7,8,9,10),\
    \ 0.7)\nres5: Float = 0.0\n\nscala> findCloseElements(List(1,2,3,4,5,6,7,8,9,10),\
    \ 0.3)\nres6: Float = 0.5\n\nscala> findCloseElements(List(1,2,3,4,5,6,7,8,9,10),\
    \ 0.7)\nres7: Float = 0.5\n\nscala> findCloseElements(List(1,2,3,4,5,6,7,8,9,10), ",
  "        val numSet = numbers.toSet\n        val numSize = numSet.size\n       \
    \ val elements = numSet.map(_ => true)\n        for (i <- 0 until numSize - 1)\
    \ {\n            for (j <- i + 1 until numSize) {\n                if (Math.abs((elements(i)\
    \ + elements(j)) / 2) < threshold) {\n                    elements(i) = false\n\
    \                    elements(j) = false\n                }\n            }\n \
    \       }\n        !elements.contains(false)", "        if (numbers.length <=\
    \ 1) return false\n        var i = 0\n        var found = false\n        var lower\
    \ = numbers(0)\n        var upper = numbers(0)\n        while (i < numbers.length)\
    \ {\n            val curr = numbers(i)\n            if (curr < lower) lower =\
    \ curr\n            if (curr > upper) upper = curr\n            found = false\n\
    \            while (i < numbers.length - 1 && curr == numbers(i + 1)) {\n    \
    \            i += 1\n                found = true\n            }\n           \
    \ if (found) lower = lower * 0.1f\n            else upper = upper * 0.1f\n   \
    \     }\n        return upper - lower < threshold", "        numbers.foldLeft((List.empty[Float],\
    \ List.empty[Float], threshold)) {\n            case ((l1, l2, threshold), (element))\
    \ =>\n                val d = abs(element - l2.last)\n                if (d <\
    \ threshold) {\n                    (l1 :+ element, l2 :+ element, threshold)\n\
    \                } else {\n                    (element :: l1, l2 :+ element,\
    \ threshold)\n                }\n            }._3.forall(number => abs(number)\
    \ < threshold)", "        val closeList = mutable.LinkedList[Float]()\n      \
    \  var count : Int = 0\n        for (n <- numbers) {\n            val diff : Float\
    \ = Math.abs(n - threshold)\n            if (diff < 0.01f) {\n               \
    \ count += 1\n            } else {\n                closeList += n\n         \
    \   }\n        }\n        if (count > 1) {\n            false\n        } else\
    \ {\n            closeList.isEmpty\n        }", "        var closeCount = numbers.size\n\
    \        var lastNumbers : List[Float] = Nil\n        for(i <- 0 until numbers.size)\
    \ {\n            val num1 = numbers(i)\n            val num2 = numbers(numbers.size\
    \ - i)\n            if (num2 == 0.0f) {\n                closeCount -= 1\n   \
    \         } else if (num2 == num1) {\n                closeCount -= 1\n      \
    \      } else if (Math.abs(num2 - num1) > threshold) {\n                closeCount\
    \ -= 1\n            } else {\n                lastNumbers = numbers :: lastNumbers\n\
    \            }\n        }\n        lastNumbers.size == closeCount", "        numbers.forall\
    \ { num1 =>\n            numbers.forall { num2 =>\n                Math.abs(num1\
    \ - num2) < threshold\n            }\n        }", "        var hasCloseElements\
    \ = false\n        numbers.sortWith(_ < _)\n        for (a <- numbers ; b <- numbers)\
    \ {\n            val dist = (a - b) * (a - b)\n            if (dist < threshold)\
    \ {\n                hasCloseElements = true\n                return hasCloseElements\n\
    \            }\n        }\n        hasCloseElements", "        if (numbers.isEmpty)\
    \ return false\n        var foundFirstMatch = false\n        var distance = 0.0f\n\
    \        val minDistance = math.min(numbers)\n        val maxDistance = math.max(numbers)\n\
    \        for (i <- numbers.indices) {\n            var tempDistance = numbers(i)\n\
    \            var tempFirstMatch = false\n            for (j <- numbers.indices)\
    \ {\n                distance += math.pow(tempDistance - numbers(j), 2)\n    \
    \            tempDistance = numbers(j)\n                if (!tempFirstMatch) {\n\
    \                    if (tempDistance > minDistance) {\n                     \
    \   tempFirstMatch = true\n                        foundFirstMatch = true\n  \
    \                  } else if (tempDistance < minDistance + threshold) {\n    \
    \                    tempFirstMatch = true\n                        foundFirstMatch\
    \ = true\n                    } else if (tempDistance < minDistance + threshold\
    \ + maxDistance) {\n                        return true\n                    }\n\
    \                }\n            }\n        }\n        return foundFirstMatch",
  "        val sortedNumbers = numbers.sortBy(math.abs(_))\n        var i = 0\n  \
    \      var lastClose = false\n        val sizeOfList = numbers.size\n        while\
    \ (i < sizeOfList) {\n            if (sortedNumbers(i).abs() < threshold) {\n\
    \                lastClose = true\n                i += 1\n            } else\
    \ {\n                lastClose = false\n            }\n            if (lastClose)\
    \ i += 1\n        }\n        lastClose", "        val numbersSize = numbers.size\n\
    \        if(numbersSize == 0) return false\n        val currentIndex = numbers.head\
    \ - 1\n        var currentDistance = numbers(currentIndex) - threshold\n     \
    \   var currentIndexInc = 1\n        var nextIndex = currentIndex\n        var\
    \ nextDistance = numbers(currentIndex) - threshold\n        while(currentIndexInc\
    \ < numbersSize) {\n            nextIndex = currentIndex\n            nextDistance\
    \ = numbers(currentIndex) - threshold\n            currentIndexInc += 1\n    \
    \        currentIndex -= 1\n            currentDistance += nextDistance * nextIndex\n\
    \        }\n        currentIndexInc += 1\n        nextDistance -= currentDistance\
    \ * currentIndex\n        if(currentDistance <= nextDistance) {\n            return\
    \ true\n        } else {\n            return false\n        }", "        val minThreshold\
    \ = numbers.foldLeft((numbers.min, numbers.max)) {\n            case ((min, max),\
    \ element) =>\n                val closest = (element - min) / max\n         \
    \       (min, closest)\n        }._2\n        numbers.forall(x => x <= minThreshold\
    \ + threshold && x >= minThreshold - threshold)", '        numbers.exists { x
    => Math.abs(x - numbers.min) < threshold }', "        var flag = false\n     \
    \   for (number <- numbers) {\n            flag = flag || number - threshold <=\
    \ numbers.last\n        }\n        flag", "        val sets = numbers.groupBy(n\
    \ => n).map { case (n, vs) => n -> (vs.min, vs.max) }.toMap\n        numbers.forall(x\
    \ => sets.get(x) match {\n            case Some((l, r)) =>\n                l.toFloat\
    \ - r.toFloat < threshold\n            case None =>\n                false\n \
    \       })", "        val thresholdSquare = threshold * threshold\n        numbers.foreach\
    \ { x =>\n            val smallestDiff = math.max(x.toFloat, 0.0f)\n         \
    \   val largestDiff = math.min(x.toFloat, 1.0f)\n            if (smallestDiff\
    \ < thresholdSquare && largestDiff > thresholdSquare) {\n                println(s\"\
    $x is the closest to threshold\")\n                return true\n            }\n\
    \        }\n        false", "        val n = numbers.toList\n        // Store\
    \ the distances of any two numbers encountered during traversal.\n        val\
    \ distance = mutable.HashMap[Float, Float]()\n        // Store the distance of\
    \ any two numbers encountered during traversal.\n        val threshold = mutable.HashMap[Float,\
    \ Float]()\n        // Keep track of any two numbers encountered during traversal.\n\
    \        val found = mutable.HashSet[Float]()\n        // Keep track of any two\
    \ numbers encountered during traversal.\n        val not = found.toSet\n\n   \
    \     // Check numbers one by one.\n        for (i <- 0 until n.size) {\n    \
    \        // For each number\n            val a = n(i)\n            // If the current\
    \ number is not already encountered during the traversal\n            if (!found.contains(a))\
    \ {\n                // For each other number\n                val b = for (j\
    \ <- 0 until n.size) {\n                    if (!found.contains(j)) {\n      \
    \                  // If both numbers are not already encountered during the traversal\n\
    \                        if (distance(a) < distance(b)) {\n                  \
    \          // Find the distance between current number and other number\n    \
    \                        distance(b) = distance(a) + a\n                     \
    \       // And add the distance of current number to both found and not\n    \
    \                        found.add(b)\n                            not.add(j)\n\
    \                        }\n                    }\n                }\n       \
    \         // Add the distance of current number to both found and not\n      \
    \          found.add(a)\n                not.add(i)\n            }\n        }\n\
    \        // The above two sets are the sets of numbers, not their distances\n\
    \        !found.toSet.subsetOf(not.toSet) && found.toSet.subsetOf(found.toSet)",
  "        var found : Boolean = false\n        var num1 = numbers(0)\n        var\
    \ num2 = numbers(1)\n        var count1 : Int = 0\n        var count2 : Int =\
    \ 0\n        var currentNum1 = 0.0f\n        var currentNum2 = 0.0f\n        var\
    \ currentCount1 = 0.0f\n        var currentCount2 = 0.0f\n        var currentSum\
    \ = 0.0f\n        var currentDiff = 0.0f\n\n        numbers.foreach(num => {\n\
    \            if (found) return\n            if (num1.toFloat == num.toFloat) {\n\
    \                currentCount1 += 1\n                if (currentCount1 >= currentCount2)\
    \ {\n                    found = true\n                }\n            } else if\
    \ (num2.toFloat == num.toFloat) {\n                currentCount2 += 1\n      \
    \          if (currentCount1 >= currentCount2) {\n                    found =\
    \ true\n                }\n            }\n            currentNum1 = num1.toFloat\n\
    \            currentNum2 = num2.toFloat\n            currentCount1 = 0\n     \
    \       currentCount2 = 0\n        })\n\n        if (found) {\n            //\
    \ If all numbers are equal, return true\n            if (count1 == count2) {\n\
    \                found = true\n            } else {\n                // If number\
    \ of numbers more than 2 then return false\n                if (count1 > 2) {\n\
    \                    found = false\n                } else {\n               \
    \     // If numbers more than 2 but less than 5 return false\n               \
    \     if (count1 > 5) {\n                        found = false\n             \
    \       }\n                    // If numbers more than 5 but less than 10 return\
    \ true\n                    else {\n                        found = true\n   \
    \                 }\n                }\n            }\n        }\n\n        found",
  "        if (numbers.isEmpty) {\n            false\n        } else {\n         \
    \   var minDiff = numbers.head\n            var minIndex = 0\n            var\
    \ lastDiff = numbers.head\n            for (x <- numbers.tail) {\n           \
    \     val diff = Math.abs(x - lastDiff)\n                if (diff < minDiff) {\n\
    \                    minDiff = diff\n                    minIndex = x\n      \
    \          }\n                lastDiff = x\n            }\n            val diff\
    \ = Math.abs(lastDiff - threshold)\n            if (diff < minDiff) {\n      \
    \          true\n            } else {\n                false\n            }\n\
    \        }", "        val numbersScalaList = new mutable.WrappedArray[Float](numbers)\n\
    \        numbersScalaList.map( x => (x - threshold) < 0.0f ).reduce( _ || _ )",
  "        numbers.groupBy(x => math.abs(x - threshold))\n            .map(_._2.length)\n\
    \            .max > 1", "        val dists = numbers.map(x => x - threshold)\n\
    \        val len = dists.map(x => math.sqrt(math.pow(x, 2) + math.pow(threshold,\
    \ 2)))\n        len.count(_ < 0.0f) > 0", "        val (close, not_close) = numbers.partition(x\
    \ => abs(x - threshold) < threshold)\n        close.isEmpty || not_close.isEmpty",
  "        numbers.zipWithIndex.foreach { case (x, i) =>\n            if(x < threshold)\n\
    \                if(i >= numbers.length - 1)\n                    return false\n\
    \                else {\n                    numbers.remove(i)\n             \
    \       if(hasCloseElements(numbers, threshold))\n                        return\
    \ true\n                    else\n                        return false\n     \
    \           }\n            else\n                if(i >= numbers.length)\n   \
    \                 return false\n        }\n        false", "        if(numbers.isEmpty)\
    \ {\n            return false\n        }\n\n        // Store the sum of previous\
    \ numbers\n        val previousSum = numbers.reduce(_ + _)\n\n        // Store\
    \ the sum of current numbers\n        val currentSum = numbers.foldLeft(0.0f)(_\
    \ + _)\n\n        // If sum of current numbers is less than sum of previous numbers,\
    \ return false\n        if(currentSum <= previousSum) {\n            return false\n\
    \        }\n\n        // Calculate squared differences between each number in\
    \ the list and the threshold value\n        val differences = numbers.zipWithIndex.flatMap\
    \ {\n            case (num, index) if (index <= numbers.size - 1) => {\n     \
    \           val difference = num - threshold\n                val squareDifference\
    \ = difference * difference\n                (squareDifference, index)\n     \
    \       }\n        }\n\n        // Return the first element if there aren't any\
    \ differences greater than the threshold\n        differences.head == 0.0f", " \
    \       numbers.zipWithIndex.map(n => (Math.abs(n._1 - threshold), n._2)).\n \
    \           toList.groupBy(f => f._1).\n            map { case (threshold, elements)\
    \ => (threshold, elements.map(e => e._2).toSet.size) }\n            .exists {\
    \ case (threshold, count) => count >= 2}", "        numbers.sortWith(_ > _).forall\
    \ {\n            num => math.abs(num - threshold) <= threshold\n        }", " \
    \       require(numbers.nonEmpty)\n        require(numbers.forall(_.isInstanceOf[Float]))\n\
    \        require(numbers.forall(_.nonEmpty))\n        require(threshold > 0.0f)\n\
    \        require(threshold < 1.0f)\n\n        val sortedNumbers = numbers.toSeq.sortBy(_.toDouble).reverse\n\
    \        val middle = (sortedNumbers.size / 2).toDouble\n        val middleDouble\
    \ = numbers.toSeq.zipWithIndex.foldLeft(0.0d) {\n            case (sum, (x, i))\
    \ => sum + x.toDouble\n        }\n        val diff = sortedNumbers.map(x => (x.toDouble\
    \ - middleDouble) / middle)\n        val threshold = diff diff :+ threshold\n\n\
    \        (threshold diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff diff\
    \ diff diff diff ", '        numbers.map(_ - threshold).reduceLeft(_ + _) > 1',
  "        // Sort numbers in ascending order\n        val sortedNumbers = numbers.sortBy(_.toFloat)\n\
    \n        val closeElmnts = ListBuffer[Float]()\n        val currentCloseElmnt\
    \ = sortedNumbers(0)\n        var closeElmntCount = 0\n\n        // Check each\
    \ number in sorted numbers for its distance to current closeElmnt\n        //\
    \ If threshold is satisfied, add that number to closeElmnts\n        // Also keep\
    \ track of how many numbers satisfy the condition\n        for (number <- sortedNumbers)\
    \ {\n            if (number - currentCloseElmnt <= threshold) {\n            \
    \    closeElmnts ::= number\n                closeElmntCount += 1\n          \
    \  }\n        }\n\n        // Return true if there were more than 1 numbers closer\
    \ to each other\n        return closeElmntCount > 1", "        val distances =\
    \ numbers.map(n => Math.abs(n - threshold)).map(abs)\n        distances.min.isLessThanOrEqualTo(0)\
    \ && distances.min.isLessThanOrEqualTo(distances.max)", "        val sortedNumbers\
    \ = numbers.sorted\n        def hasElements(i : Int, j : Int, threshold : Float)\
    \ : Boolean = \n            i >= 0 && j >= 0 && i < numbers.length && j < numbers.length\
    \ &&\n                numbers(i) - numbers(j) < threshold\n        val first =\
    \ sortedNumbers(0)\n        val last = sortedNumbers(sortedNumbers.length - 1)\n\
    \        if(hasElements(0, 0, threshold)) {\n            return true\n       \
    \ }\n        var flag = false\n        val length = numbers.length\n        for(i\
    \ <- 0 until length) {\n            for(j <- i + 1 until length) {\n         \
    \       if(hasElements(i, j, threshold)) {\n                    flag = true\n\
    \                    println(s\"Found close elements $first $last, ${numbers(i)}\
    \ ${numbers(j)} with threshold $threshold\")\n                    break\n    \
    \            }\n            }\n        }\n        flag", "        // Get all indexes\
    \ of elements that are close to each other than\n        // given threshold\n\
    \        val indexes = numbers.zipWithIndex.filter(_._2 < threshold).map(_._1).toList\n\
    \        val isClosed = indexes.forall(x => indexes.exists(y => math.abs(x - y)\
    \ < threshold))\n        isClosed", "        // Sort numbers by absolute value\
    \ and compare them with given threshold\n        numbers.sortWith(_ < _).forall(_.abs2\
    \ < threshold)", "        val distances = numbers.map { number =>\n          \
    \  val diff = (number - threshold).abs()\n            (diff, number)\n       \
    \ }\n        val minimum = distances.minBy(_._1)\n        val maximum = distances.maxBy(_._1)\n\
    \        maximum._2 < minimum._2", "        val sortedNumbers = numbers.sorted\n\
    \        val n = sortedNumbers.size\n        (n > 1) &&\n            (n >= 2)\
    \ &&\n            (threshold - sortedNumbers(n - 2) > sortedNumbers(n - 1))",
  '        numbers.sorted.forall(x => numbers.indexWhere(y => abs(x - y) < threshold)
    == numbers.lastIndexWhere(y => abs(x - y) < threshold))', "        // For each\
    \ element in the list, check if it is closer to threshold than any element in\
    \ the list.\n        numbers.map(number => Math.abs(number - threshold)).min <\
    \ 0", "        require(numbers.nonEmpty)\n        require(threshold > 0.0f)\n\
    \        numbers.tail.foldLeft(true) {\n            (acc, number) => {\n     \
    \           val currentDiff = math.abs(acc.getOrElse(0f) - number)\n         \
    \       if (currentDiff < acc.getOrElse(1f)) {\n                    acc.update(currentDiff,\
    \ acc)\n                } else {\n                    acc.update(0, acc)\n   \
    \             }\n            }\n        }.getOrElse(false)", "        if(numbers.length\
    \ <= 2) return false\n        val min = numbers(0)\n        val max = numbers(0)\n\
    \        numbers.foreach(x => {\n            if(x < min) min = x\n           \
    \ if(x > max) max = x\n        })\n        if(max - min < threshold) true\n  \
    \      else false", "        var minDiff : Float = math.abs(numbers(1).toFloat\
    \ - numbers(0).toFloat)\n        var maxDiff : Float = math.abs(numbers(0).toFloat\
    \ - numbers(numbers.size-1).toFloat)\n        for(x <- numbers : (1 to numbers.size-1))\
    \ {\n            val diff = math.abs(x.toFloat - numbers(x.toInt).toFloat)\n \
    \           if((diff < minDiff) && (diff > maxDiff)) {\n                minDiff\
    \ = diff\n            }\n            if(diff > maxDiff) {\n                maxDiff\
    \ = diff\n            }\n        }\n        maxDiff < threshold", "        val\
    \ pairs = numbers.toList.groupBy(x => math.abs(x - threshold))\n        pairs.forall\
    \ {\n            case (pair, list) =>\n                if (list.isEmpty)\n   \
    \                 false\n                else {\n                    val min =\
    \ list.getMin\n                    val max = list.getMax\n                   \
    \ math.abs(pair._1 - min) < math.abs(pair._1 - max)\n                }\n     \
    \   }", '        numbers.distinct.size > 1', '        numbers.groupBy(x => math.abs(x
    - threshold)).mapValues(_.length).map(_ >= 2).getOrElse(true)', "        val n\
    \ = numbers.map(_.toFloat)\n        val maxDelta = math.abs(n.max - n.min).toFloat\n\
    \        if (maxDelta == 0.0f) return false\n        val numElements = n.length\n\
    \        var totalDelta = 0.0f\n        var closest = 0.0f\n        var count\
    \ = 0\n        for(i <- 0 until numElements){\n            val currentDelta =\
    \ math.sqrt(math.pow(numbers(i), 2.0f) + math.pow(n.min, 2.0f))\n            totalDelta\
    \ += currentDelta\n            closest += currentDelta\n            if(closest\
    \ > threshold) count = i + 1;\n        }\n        return count == numElements",
  "        def dist(x: Float, y: Float) : Float = {\n            val deltaX : Float\
    \ = Math.abs(x - y)\n            if (deltaX == 0.0f) {\n                0.0f\n\
    \            } else {\n                Math.pow(deltaX, 2)\n            }\n  \
    \      }\n        numbers match {\n            case Nil => false\n           \
    \ case x :: y => dist(x.toFloat, y.toFloat) <= dist(threshold, threshold)\n  \
    \      }", "        numbers.minBy { x =>\n            math.abs(x - threshold)\n\
    \        }.isDefined && numbers.maxBy { x =>\n            math.abs(x - threshold)\n\
    \        }.isDefined", "        val n = numbers.size\n        if (n == 0)\n  \
    \          false\n        else if (n == 1)\n            numbers.head.abs < threshold\n\
    \        else\n            numbers.zipWithIndex.forall {\n                case\
    \ (x, i) =>\n                    val xPos = i - 1\n                    val nPos\
    \ = n - i - 1\n                    if (nPos == 0) {\n                        x\
    \ == numbers.last\n                    } else if (nPos == 1) {\n             \
    \           x == numbers.last * numbers.last\n                    } else {\n \
    \                       val xDiff =\n                            (xPos * x) +\
    \ (numbers.last * numbers.last)\n                        val nDiff =\n       \
    \                     (nPos * x) + (numbers.last * numbers.last)\n           \
    \             (xPos * xDiff) + (nPos * nDiff) < threshold\n                  \
    \  }\n            }", "        var result : Boolean = false\n\n        numbers.foreach\
    \ { n =>\n            val mid = (n + numbers.last) / 2\n            val diff =\
    \ math.abs(mid - threshold)\n            if (diff < numbers.last)\n          \
    \      result = true\n        }\n\n        result", '        numbers.map(n =>
    sqrt(math.pow(n,2.0f) + math.pow(n,2.0f))).max() <= threshold', "        def closestNumber(numbers\
    \ : List[Float], number : Float, distance : Float) : Float = {\n            val\
    \ maxDistance = math.sqrt(distance * distance)\n            var currentClosest\
    \ = number\n            val toBeChecked = numbers :+ currentClosest\n        \
    \    for (i <- 0 until toBeChecked.size) {\n                if (Math.abs(currentClosest\
    \ - number) < maxDistance) {\n                    currentClosest = toBeChecked(i)\n\
    \                }\n            }\n            currentClosest\n        }\n   \
    \     if (numbers.isEmpty) {\n            false\n        } else {\n          \
    \  var first = numbers(0)\n            var second = numbers(0)\n            val\
    \ distance = math.sqrt(first * first + second * second)\n            for (number\
    \ <- numbers) {\n                val closestFirst = closestNumber(numbers, first,\
    \ distance)\n                val closestSecond = closestNumber(numbers, second,\
    \ distance)\n                if (Math.abs(closestFirst - number) < threshold &&\
    \ Math.abs(closestSecond - number) < threshold) {\n                    return\
    \ true\n                }\n                if (Math.abs(closestFirst - number)\
    \ > threshold || Math.abs(closestSecond - number) > threshold) {\n           \
    \         first = number\n                    second = number\n              \
    \      distance = math.sqrt(first * first + second * second)\n               \
    \ }\n            }\n        }\n        false", "        val closestValues = numbers.map((x)\
    \ => Math.abs(x - threshold.toFloat)).min\n        closestValues == 0f", "   \
    \     if (numbers.isEmpty)\n            false\n        else {\n            val\
    \ dist = new mutable.HashMap[Float,Float]()\n            numbers.foreach{ n =>\
    \ dist.update(n,dist.getOrElse(n,n)+(n-threshold))}\n            dist.keys.forall{\
    \ n => dist.get(n) < threshold }\n        }", "        numbers.zipWithIndex.forall\
    \ { n =>\n            val idx = (n._2 - n._1).abs <= threshold\n            idx\
    \ && (n._1 - numbers(n._2).abs <= threshold)\n        }", "        numbers.zipWithIndex.foldLeft(false)\
    \ { (result, v) =>\n            if (result) { false } else {\n               \
    \ if (math.abs(v.head - v.last) < threshold) { true } else {\n               \
    \     result\n                }\n            }\n        }", "        // Sort by\
    \ ascending elements\n        numbers.sortWith(math.abs)\n        // Find position\
    \ of all elements less than threshold\n        val pos = numbers.zipWithIndex.filter(_._2\
    \ < threshold).map(_._1)\n        // If two elements are closer than threshold,\
    \ return true\n        (pos.length == 2 && pos(0) == pos(1)) || (pos.length ==\
    \ 1 && pos(0) == pos.length)", "        numbers.foldLeft(true) {\n           \
    \ (accum, element) => accum && abs(element - threshold) < 1e-6\n        }", " \
    \       var closed = false\n        numbers.sortWith(_.toFloat - _)\n        var\
    \ i = numbers.indexOf(0.0)\n        if (i == -1) {\n            i = 0\n      \
    \  }\n        val length = numbers.length\n        while (i < length) {\n    \
    \        var j = i + 1\n            while (j < length && !closed && numbers(j\
    \ - 1) < numbers(j)) {\n                j += 1\n            }\n            if\
    \ (!closed) {\n                val closed = closed || numbers(i - 1) < numbers(j)\n\
    \                closed = closed || numbers(i) > numbers(j)\n                closed\
    \ = closed || numbers(j - 1) < numbers(j)\n                closed = closed ||\
    \ numbers(j) > numbers(j)\n            }\n            i += j - i + 1\n       \
    \ }\n        return closed", "        val numSet = numbers.toSet\n        val\
    \ distances = numbers.map(x => x - threshold)\n        distances.sum < 1.0f",
  "        require(numbers != null && numbers.size > 0, \"numbers must be not null\"\
    )\n        require(threshold != null, \"threshold must be not null\")\n      \
    \  val list = numbers.toList\n        val map = new mutable.LinkedHashMap[Float,\
    \ Float]()\n        for (n <- list) {\n            map.put(n, threshold)\n   \
    \     }\n        val numPairs = (list zip map.toList).filter(_._2 > _._1).size\n\
    \        if (numPairs == 0) {\n            false\n        }\n        if (numPairs\
    \ == list.size) {\n            true\n        }\n        val minDistance = list.map(_.toFloat).min\n\
    \        val maxDistance = list.map(_.toFloat).max\n        val minDistanceNum\
    \ = list.map(x => x - minDistance).min\n        val maxDistanceNum = list.map(x\
    \ => x - minDistance).max\n        if (minDistanceNum == maxDistanceNum) {\n \
    \           false\n        }\n        if (minDistanceNum < maxDistanceNum) {\n\
    \            true\n        }", "        val set = new mutable.HashSet[Float]()\n\
    \        numbers.foreach(n => set.addOption(n))\n\n        var close = false\n\
    \n        set.find(n => n < threshold).isDefined match {\n            case true\
    \ => close = true\n            case false => set.find(n => n < threshold + 1e-6).isDefined\
    \ match {\n                case true => close = true\n                case false\
    \ => set.find(n => n < threshold - 1e-6).isDefined match {\n                 \
    \   case true => close = true\n                    case false => false\n     \
    \           }\n            }\n        }\n        close", "        require(numbers.size\
    \ > 0, \"List cannot be empty\")\n        var max = 0f\n        var min = 1f\n\
    \        numbers.foreach(number => {\n            if(max < number) max = number\n\
    \            if(min > number) min = number\n        })\n        var diff = (max\
    \ - min) * threshold\n        return numbers.foldLeft(true){ (result, number)\
    \ => {\n            val diff = (number - min) * threshold\n            if(diff\
    \ < diff) result && (diff == diff)\n            else result && (diff > diff)\n\
    \        }}", "        // Define a helper function which will give the difference\
    \ of two number\n        // and return the smallest one.\n        def getDifference(x:\
    \ Float, y: Float) : Float = {\n            if (x == 0.0f) {\n               \
    \ return 0.0f\n            }\n            else if (y == 0.0f) {\n            \
    \    return x\n            }\n            else {\n                return x - y\n\
    \            }\n        }\n\n        // A bit inefficient but works.\n       \
    \ // We use two sorted lists sorted by their difference and see if their diff\n\
    \        // is smaller then the given threshold.\n        var list1 = numbers.sorted.toList\n\
    \        var list2 = numbers.sorted.toList\n        list1 ::: list2 ::: List (0.0f)\n\
    \          .map {\n            x => getDifference(x, list2.last)\n          }\n\
    \          .min < threshold", "        val listNum = numbers.toList\n        //\
    \ We take distance between each two consecutive numbers.\n        // If first\
    \ number - second number < threshold, we return true, otherwise we return false.\n\
    \        (listNum.tail.zip(listNum.init).map { case ((a, b), (c, d)) => (a - b).abs\
    \ < (c - d).abs }.toList.lastOption) match {\n            case Some(true) => true\n\
    \            case None => false\n        }", "        var diffs : List[Float]\
    \ = List.empty\n        val diffsSet = new mutable.HashSet[Float]\n        numbers.foreach(x\
    \ => diffsSet.add(x))\n        numbers.foreach(x => diffs += {if (diffsSet.contains(x\
    \ - threshold)) x else Float.PositiveInfinity})\n        diffs.distinct.count(_\
    \ == Float.PositiveInfinity)", "        numbers.foldLeft(false){\n           \
    \ (acc, n) =>\n                val diff = math.abs(n - threshold)\n          \
    \      acc && diff < math.min(math.abs(n - numbers(0)), math.abs(n - numbers(1)))\n\
    \        }", "        def distance(a: Float, b: Float) : Float = {\n         \
    \   math.sqrt(math.pow(b,2) + math.pow(a, 2))\n        }\n        val closest\
    \ = numbers.minBy(distance)\n        val closestDistance = distance(closest, threshold)\n\
    \        numbers.forall(a => distance(a, threshold) < closestDistance)", "   \
    \     var closest: Float = 0.0\n        var closestIndex: Int = -1\n        var\
    \ foundClosest = false\n        for (number <- numbers) {\n            if (number\
    \ != closest) {\n                // Check if we found the nearest number to the\
    \ current closest. If we didn't, the\n                // number will be closer\
    \ to the current closest if and only if it's bigger than the\n               \
    \ // current closest or the current closest is bigger than the threshold.\n  \
    \              if (!foundClosest && number > closest || number < closest && number\
    \ >= threshold) {\n                    closest = number\n                    closestIndex\
    \ = numbers.indexOf(number)\n                    foundClosest = true\n       \
    \         }\n            }\n        }\n        foundClosest && closestIndex !=\
    \ -1", "        val maxDistanceBetweenElements = if (numbers.isEmpty) 1.0f else\
    \ numbers(numbers.size - 1)\n        for (i <- 0 until numbers.size) {\n     \
    \       val currentNumber = numbers(i)\n            val currentDistance = math.abs(currentNumber\
    \ - threshold)\n            if (currentDistance > maxDistanceBetweenElements)\
    \ return false\n        }\n        true", "        // Using set and map operation\n\
    \        val setOfNumbers = numbers.toSet\n        val setOfResult = setOfNumbers.map((n)\
    \ => (n - threshold) < 0.01f).toSet\n        setOfNumbers.exists(setOfResult)",
  "        if (numbers.isEmpty) return false\n        val numbersInOrder = numbers.sortWith(math.abs(_)\
    \ < math.abs(_))\n        val sortedDistances = numbersInOrder.map(math.abs)\n\
    \        val closestIndexes = sortedDistances.zip(numbersInOrder).filter(_._2\
    \ < threshold).map(_._1)\n        if (closestIndexes.size == 0) return false\n\
    \        val closestIndex = closestIndexes.head\n        if (numbersInOrder.size\
    \ == 0) return false\n        if (closestIndex == 0) return true\n        val\
    \ closestFirst = numbersInOrder.take(closestIndex)\n        val closestSecond\
    \ = numbersInOrder.take(closestIndex + 1)\n        if (closestFirst == closestSecond)\
    \ hasCloseElements(numbersInOrder.drop(closestIndex + 1), threshold)\n       \
    \ else (closestFirst > closestSecond) || hasCloseElements(numbersInOrder.drop(closestIndex\
    \ + 1), threshold)", "        var result = true\n        var minDiff = math.max(numbers(0),\
    \ numbers(1)) - threshold\n        for (n <- numbers.tail) {\n            val\
    \ diff = Math.abs(n - threshold)\n            if (diff < minDiff) {\n        \
    \        result = false\n                minDiff = diff\n            }\n     \
    \   }\n        result", '        numbers.zip(numbers.tail).forall(x => x._1 -
    x._2 < threshold)', "        val distances = numbers.map (x => x - threshold).drop(1).zipWithIndex.map\
    \ (x => (x._2, x._1)).toMap\n        distances.exists { case (d1, _) =>\n    \
    \        distances.exists { case (d2, _) => d1 + d2 < threshold*threshold}\n \
    \       }", "        val map1 = numbers.map(_ + threshold).map(math.abs)\n   \
    \     val map2 = numbers.map(_ - threshold).map(math.abs)\n        map1.forall\
    \ { x => map2.contains(x) }", "        val numberSet = new HashSet[Float]()\n\
    \        val setSize = numbers.size\n        var numberWithinThreshold = false;\n\
    \        for (number <- numbers) {\n            numberWithinThreshold =\n    \
    \            if (numberSet.add(number) && setSize > 1) {\n                   \
    \ numberSet.size < setSize / 2\n                } else numberWithinThreshold\n\
    \        }\n        numberWithinThreshold", "        if(numbers.isEmpty) {\n \
    \           return false\n        }\n        var closed = false\n        var closeEnough\
    \ = numbers.head\n        var i = 1\n        var maxDistance = numbers.last.abs()\n\
    \        var minDistance = numbers.head.abs()\n        while(i < numbers.size)\
    \ {\n            if(Math.abs(numbers.head - numbers.last) < threshold) {\n   \
    \             closed = true\n                break\n            }\n          \
    \  var currentDistance = numbers.head.abs()\n            if(currentDistance <\
    \ minDistance && currentDistance > maxDistance) {\n                minDistance\
    \ = currentDistance\n            }\n            if(currentDistance > maxDistance)\
    \ {\n                maxDistance = currentDistance\n            }\n          \
    \  i += 1\n        }\n        closed", "        val closestPairs : List[(Float,\
    \ Float)] = numbers.foldLeft((Float.NegativeInfinity, Float.PositiveInfinity))\
    \ {\n            case ((a, b), element) =>\n                val currentPair =\
    \ (a, b)\n                val currentDistance = distance(currentPair, element)\n\
    \                if (currentDistance < currentPair._1) {\n                   \
    \ currentPair\n                } else if (currentDistance > currentPair._2) {\n\
    \                    (currentPair._2, currentDistance)\n                } else\
    \ {\n                    (a, (currentPair._1 + currentDistance))\n           \
    \     }\n        }\n\n        closestPairs.forall(pair => pair._2 > threshold)",
  "        val minDistance = minElementDistance(numbers)\n        numbers.exists(number\
    \ => Math.abs(number - minDistance) < threshold)", '        numbers.zipWithIndex.foreach
    { case (n, i) => if (n - threshold > 0) true else false }', "        def isClose(n1\
    \ : Float, n2 : Float) : Boolean = {\n            math.abs(n1 - n2) < threshold\n\
    \        }\n\n        // Sort the list so that it is easily searched.\n      \
    \  val numbersList = numbers.sorted\n        var found : Boolean = false\n   \
    \     numbersList.foreach {\n            case n : Float if (isClose(n, numbersList(0)))\
    \ =>\n                found = true\n            case n : Float =>\n          \
    \      if (isClose(n, numbersList(numbersList.size - 1))) {\n                \
    \    found = true\n                }\n        }\n        found", "        // sort\
    \ numbers in descending order\n        val sorted = numbers.sortWith(_.compareTo(_)\
    \ < 0)\n        // If there is no pair of elements greater than threshold, return\
    \ false\n        if (sorted.isEmpty)\n            false\n        else {\n    \
    \        // Loop through the sorted list to find two elements less than threshold\n\
    \            var found : Boolean = true\n            sorted.foreach { x =>\n \
    \               // find next two elements greater than threshold\n           \
    \     var minX : Float = -1\n                var maxX : Float = -1\n         \
    \       sorted.foreach { y =>\n                    if (x.compareTo(y) < 0) {\n\
    \                        // found two elements greater than threshold, so break\
    \ the loop\n                        if (minX >= 0)\n                         \
    \   maxX = minX\n                        minX = y\n                        break\n\
    \                    }\n                }\n                // check whether all\
    \ three elements are close to each other\n                if (Math.abs(x - minX)\
    \ < threshold && Math.abs(x - maxX) < threshold) {\n                    // found\
    \ two elements close to each other\n                    found = false\n      \
    \              break\n                }\n            }\n            if (found)\n\
    \                // At least one element is close to each other\n            \
    \    true\n            else\n                // No elements are close to each\
    \ other\n                false\n        }", "        var closestDist = 0\n   \
    \     var closestIndex = -1\n        for (number <- numbers) {\n            var\
    \ localDistance = math.abs(number - threshold)\n            if (localDistance\
    \ < closestDist) {\n                closestDist = localDistance\n            \
    \    closestIndex = 0\n            } else if (localDistance < closestDist + 1)\
    \ {\n                closestDist = localDistance\n                closestIndex\
    \ = 1\n            }\n        }\n        closestIndex == numbers.size || closestIndex\
    \ == 0", "        val distances = numbers.map(x => (x, abs(x - threshold)))\n\
    \        val pairs = distances.groupBy(x => x._1).flatMap(_._2.toList).toList\n\
    \        (pairs.size == 2) && pairs.forall(x => x._2 == pairs.head.lt(x._2))",
  "        val threshold = threshold.toFloat\n        numbers.foldLeft(false)((x,\
    \ y) => if (Math.abs(x - y) < threshold) true else x)", "        val n = numbers.count\n\
    \        var i = 0\n        var j = 0\n        var diff = 0\n        var inOrder\
    \ = false\n        while (i < n && j < n) {\n            diff = math.abs(numbers(i)\
    \ - numbers(j))\n            if (diff < threshold) {\n                inOrder\
    \ = true\n            }\n            if (diff < diff) {\n                inOrder\
    \ = false\n            }\n            i += 1\n            j += 1\n        }\n\
    \        if (!inOrder) {\n            return false\n        } else {\n       \
    \     return true\n        }", "        val minValue = numbers.min\n        val\
    \ maxValue = numbers.max\n        val nums = numbers.toArray\n        val diffs\
    \ = nums.zip(nums).map { case (a, b) => (a -b) / (b - a) }\n        val closeElements\
    \ = diffs.filter(d => d < threshold)\n        if (closeElements.isEmpty) false\n\
    \        else numbers.containsAll(closeElements)", "        if (numbers.isEmpty)\
    \ {\n            true\n        } else {\n            val maxNums = numbers.max\n\
    \            val minNums = numbers.min\n            val maxAbs = maxNums.abs -\
    \ (minNums.abs + threshold)\n            val minAbs = maxNums.abs + (minNums.abs\
    \ - threshold)\n            numbers.length == 0 || maxAbs == minAbs\n        }",
  "        numbers.foldLeft(true)((result, element) => {\n            val distance1\
    \ = (element - numbers.min) squareRoot\n            val distance2 = (element -\
    \ numbers.max) squareRoot\n            result && (distance1 > threshold || distance2\
    \ > threshold)\n        })", "        var closeNumber : Float = -1.toFloat\n \
    \       var sum : Float = 0f\n\n        for(number <- numbers) {\n           \
    \ sum += number\n        }\n\n        if (sum >= 0) {\n            // iterate\
    \ through all elements, if any two elements are closer than given\n          \
    \  // threshold, return true, otherwise false\n            for(number <- numbers)\
    \ {\n                val diff = abs(sum - number)\n                if (diff <=\
    \ threshold) {\n                    return true\n                }\n\n       \
    \         closeNumber = number\n                sum = number\n            }\n\
    \        }\n\n        return false", "        numbers.toSeq\n            .zipWithIndex\n\
    \            .filter(x => x._2 != numbers.size)\n            .forall(x => Math.abs(x._1\
    \ - threshold) < Math.abs(numbers.last._1 - threshold))", "        var numberList\
    \ = new mutable.ListBuffer[Float]()\n        numbers.foreach(x => numberList +=\
    \ x)\n\n        numberList.groupBy(x => (x - threshold).abs)\n            .values.exists(x\
    \ => x.size < 3)", "        numbers.foldLeft(false) { (isClose, elem) =>\n   \
    \         if(isClose && (elem > threshold)) {\n                isClose = false\n\
    \            }\n            isClose\n        }", "        // 1. Count the number\
    \ of pairs of numbers which are closer to each other than threshold.\n       \
    \ // >>> numbers.size\n        // 5\n        // >>> pairs.lenght\n        // 4\n\
    \        // >>> pairs.groupBy(_._2).map(k => k._2).filter(_._2 < threshold)\n\
    \        // Map(1.0 -> Map(1 -> 0.0), 2.0 -> Map(1 -> 1.0), 3.0 -> Map(2 -> 1.0))\n\
    \        // >>> pairs.groupBy(_._2).map(k => k._2).filter(_._2 < threshold).filter(_._1\
    \ < threshold).lenght\n        // 3\n        // >>> pairs.groupBy(_._2).map(k\
    \ => k._2).filter(_._2 < threshold).filter(_._1 < threshold).filter(_._2 > threshold).lenght\n\
    \        // 0\n        // >>> pairs.groupBy(_._2).map(k => k._2).filter(_._2 <\
    \ threshold).filter(_._1 < threshold).filter(_._2 > threshold).filter(_._3 < threshold).lenght\n\
    \        // 3\n        // >>> pairs.groupBy(_._2).map(k => k._2).filter(_._2 <\
    \ threshold).filter(_._1 < threshold).filter(_._2 > threshold).filter(_._3 < threshold).filter(_._4\
    \ < threshold).lenght\n        // 3\n        // >>> pairs.groupBy(_._2).map(k\
    \ => k._2).filter(_._2 < threshold).filter(_._1 < threshold).filter(_._2 > threshold).filter(_._3\
    \ < threshold).filter(_._4 < threshold).filter(_._5 < threshold).lenght\n    \
    \    // 3\n        // >>> pairs.groupBy(_._2).map(k => k._2).filter(_._2 < threshold).filter(_._1\
    \ < threshold).filter(_._2 > threshold).filter(_._3 < threshold).filter(_._4 <\
    \ threshold).filter(_._5 < threshold).filter(_._6 < threshold).lenght\n      \
    \  // 4\n        // >>> pairs.groupBy(_._2).map(k => k._2).filter(_._2 < threshold).filter(_._1\
    \ < threshold).filter(_._2 > threshold).filter(_._3 < threshold).filter(_._4 <\
    \ threshold).filter(_._5 < threshold).filter(_._6 < threshold).filter(_._7 < threshold).lenght\n\
    \        // 5\n        val pairs = numbers.groupBy(_._2).map(k => k._2).filter(_._2\
    \ < threshold).filter(_._1 < threshold).filter(_._2 > threshold).filter(_._3 <\
    \ threshold).filter(_._4 < threshold).filter(_._5 < threshold).filter(_", "  \
    \      numbers.exists { n1 =>\n            numbers.exists { n2 =>\n          \
    \      val diff = (n1 - n2)\n                if (diff < threshold) {\n       \
    \             false\n                } else {\n                    true\n    \
    \            }\n            }\n        }", "        val listOfDistances = numbers.map{\
    \ x =>\n            val d = x\n            val otherDistances = numbers.map{ y\
    \ => Math.abs(y - d)}\n            val isClose = otherDistances.min.toFloat <\
    \ threshold\n            (d, isClose)\n        }\n        listOfDistances.exists\
    \ { case (isClose, _) =>\n            isClose\n        }", "        var count\
    \ = 0\n        var previous = math.max(numbers(0), numbers(1))\n        var next\
    \   = math.min(numbers(0), numbers(1))\n\n        for (i <- 0 to numbers.size\
    \ - 2) {\n            val diff = next - previous\n            if (diff < threshold)\
    \ {\n                count += 1\n                previous = next\n           \
    \     next   = numbers(i + 2)\n            }\n        }\n\n        if (count ==\
    \ numbers.size)\n            true\n        else\n            false", '        numbers.foldLeft(false)((a,
    x) => a || (Math.abs(x - threshold) < Math.abs(x - numbers(a))))', "        val\
    \ set = numbers.toSet\n        if (numbers.length < 2) {\n            return false\n\
    \        }\n        val sortedNumbers = numbers.toList.sortWith(_ <= _)\n    \
    \    val differences = for (i <- sortedNumbers.indices) yield\n            sortedNumbers(i)\
    \ - sortedNumbers(i + 1)\n        for {\n            d <- differences\n      \
    \  } if (d < threshold) {\n            return true\n        }\n        false",
  "        // First calculate the minimum distance between numbers in the given list\n\
    \        // and the threshold\n        val minDistance = numberList.map(number\
    \ => math.abs(number - threshold)).min()\n        // Check if any of the elements\
    \ in the given list is closer than threshold\n        numbers.exists(number =>\
    \ math.abs(number - threshold) < minDistance)", "        val distances: List[Float]\
    \ = numbers.map{ n => n.abs }\n        val sortedDistances = distances.sortBy(_)\n\
    \        var distance = 0\n        var firstClose = sortedDistances.head\n\n \
    \       sortedDistances.foreach{ (d, n) =>\n            distance += d\n      \
    \      if (distance > threshold) {\n                distance = firstClose\n  \
    \              firstClose = n\n            }\n        }\n        firstClose.isDefined",
  "        // The difference between numbers and threshold.\n        val diff = (numbers\
    \ - threshold).abs\n        val threshold = diff.toInt\n        // For every number\
    \ in the list, compare with other numbers in the list\n        // and see if either\
    \ of them is closer to given threshold.\n        numbers.forall {\n          \
    \  // If the current number is closer to given threshold, it means the\n     \
    \       // two numbers are close to each other.\n            val diff = it.abs\
    \ - threshold\n            if (diff < threshold && diff > 0) {\n             \
    \   return true\n            }\n        }\n        // If the numbers list is empty,\
    \ return false because there aren't any\n        // two numbers closer to each\
    \ other than given threshold.\n        false"]
stop_tokens:
- "\n    }\n"
