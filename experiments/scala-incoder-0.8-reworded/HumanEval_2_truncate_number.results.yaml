language: scala
name: HumanEval_2_truncate_number
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val floor = math.floor(number)\n        val fracPart\
    \ = number - floor\n        val intPart = math.trunc(number)\n        intPart\
    \ * fracPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk07sv7nh.scala:13:27 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mintPart\e[0m = math.trunc(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                    value trunc is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val numberString = number.toString\n        var\
    \ integerPart = number % 1.0\n        var decimalPart = 1.0\n        if (number\
    \ < 1.0) decimalPart = number % 1.0\n        while (decimalPart > 0.0 && decimalPart\
    \ > numberString.charAt(decimalPart.toInt - 1)) {\n            decimalPart = decimalPart\
    \ / 10\n        }\n        return (integerPart * 10).toFloat + decimalPart\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpybasumgm.scala:18:15\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mreturn\e[0m (integerPart\
    \ * \e[31m10\e[0m).toFloat + decimalPart\n\e[31m\e[31m   |\e[0m              \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    Double\n\e[31m   |\e[0m               Required: Float\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        def decimalPart(number : Float) : Float = {\n\
    \            var decimal = 0f\n            var remainder = 0f\n            while\
    \ (number >= 1) {\n                number = number / 10f\n                decimal\
    \ += 1f\n                remainder = number % 10f\n            }\n           \
    \ (decimal + remainder) / 1f\n        }\n\n        // Get the decimal part and\
    \ remove it.\n        var decimalPart = decimalPart(number)\n        number =\
    \ number - decimalPart\n\n        decimalPart\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpflkcymvk.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mdecimalPart\e[0m = decimalPart(number)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecimalPart is already defined as \e[33mmethod\e[0m \e[35mdecimalPart\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E052] Type\
    \ Error: /tmp/tmpflkcymvk.scala:15:23 -----------------------------\e[0m\e[0m\n\
    \e[31m15 |\e[0m                number = number / \e[31m10f\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \        Reassignment to val number\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpflkcymvk.scala:24:24 -----------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        number = number - decimalPart\n\e[31m\e[31m   |\e[0m         \
    \        ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mFloat\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Float\n\e[31m   |\e[0m (x: Int): Float\n\e[31m   |\e[0m\
    \ (x: Char): Float\n\e[31m   |\e[0m (x: Short): Float\n\e[31m   |\e[0m (x: Byte):\
    \ Float\n\e[31m   |\e[0mmatch arguments (Float => Float)\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpflkcymvk.scala:26:8 ---------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        decimalPart\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mFloat\e[0m\e[1m\e[31m \e[0m\e\
    [1m\e[31m=\e[0m\e[1m\e[31m>\e[0m\e[1m\e[31m \e[0mFloat\n\e[31m   |\e[0m      \
    \  Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        assert(number >= 0);\n        val remainder =\
    \ math.floor(number);\n        val wholeNumber = number - remainder;\n       \
    \ if (wholeNumber <= 0.0) 0.0;\n        else wholeNumber;\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpahdg_s21.scala:15:13\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33melse\e[0m wholeNumber;\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \   Found:    (wholeNumber : Double)\n\e[31m   |\e[0m             Required: Float\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number match {\n            case x if x < 1  =>\
    \ 1.0f / number\n            case _            => number.toInt\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk01csym7.scala:17)\n\tat Problem.main(tmpk01csym7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val l = math.ceil(math.log10(number))\n      \
    \  number / Math.pow(10.0, l)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6ppl2hvd.scala:12:8\
    \ ---------------------\e[0m\e[0m\n\e[31m12 |\e[0m        number / Math.pow(\e\
    [31m10.0\e[0m, l)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    Double\n\e[31m   |\e[0m        Required: Float\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Split number into integer and fractional parts\n\
    \        val integer = number.toInt\n        val fractional = number - integer\n\
    \        fractional\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010095
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // 1.1 => 2.0\n        // 1.10 => 2.0\n      \
    \  // 1.100 => 2.0\n        // 1.10000 => 2.0\n        // 1.100000 => 2.0\n  \
    \      val parts = number.toString.split(\"\\\\.\");\n        val decimal = parts(1).substring(0,\
    \ parts(1).length - 1);\n        val intPart = parts(0).substring(0,\n       \
    \                               parts(0).length - decimal.length);\n        val\
    \ intPartLength = intPart.length\n        // For negative numbers, we want the\
    \ positive integer part and the\n        // negative decimal part, with leftover\
    \ digits truncated.\n        if (number < 0) {\n            (1.0f - (intPartLength\
    \ - decimal.length + 1) * Math.signum(number)) *\n                floatToIntBits(intPart)\
    \ +\n            decimal.substring(0).toFloat\n        } else {\n            intPart.toFloat\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmuq9eo_4.scala:25:16 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                floatToIntBits(intPart) +\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: floatToIntBits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010092
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val i = BigInt(number)\n        val d = BigDecimal(number)\n\
    \        val ii = i / BigInt(10)\n        val fi = i - (BigInt(10) * ii).intValue\n\
    \        fi\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpr1n0plyz.scala:11:16 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mi\e[0m = BigInt(number)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mobject\e[0m \e[35mBigInt\e\
    [0m with types\n\e[31m   |\e[0m (x: java.math.BigInteger): BigInt\n\e[31m   |\e\
    [0m (x: String, radix: Int): BigInt\n\e[31m   |\e[0m (x: String): BigInt\n\e[31m\
    \   |\e[0m (numbits: Int, rnd: scala.util.Random): BigInt\n\e[31m   |\e[0m (bitlength:\
    \ Int, certainty: Int, rnd: scala.util.Random): BigInt\n\e[31m   |\e[0m (signum:\
    \ Int, magnitude: Array[Byte]): BigInt\n\e[31m   |\e[0m (x: Array[Byte]): BigInt\n\
    \e[31m   |\e[0m (l: Long): BigInt\n\e[31m   |\e[0m (i: Int): BigInt\n\e[31m  \
    \ |\e[0mmatch arguments ((number : Float))\n1 error found\n"
  stdout: ''
  timestamp: 1660010093
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // We round the number to 1 decimal place before\
    \ truncating the fractional part.\n        // This avoids overflowing our Float\
    \ range.\n        var fractionalPart = Math.round(number * 100) / 100.0\n    \
    \    var integerPart = Math.round(fractionalPart)\n        return (fractionalPart\
    \ - integerPart).toFloat\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd43vuayv.scala:18)\n\tat Problem.main(tmpd43vuayv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var decomp = number.toInt\n        while (decomp\
    \ > 1) {\n            decomp = decomp.toInt / 10\n        }\n        number\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps917jpds.scala:18)\n\tat Problem.main(tmps917jpds.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val digits = (number % 1).toInt\n        number\
    \ - (digits * Math.pow(10, digits))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpev_3i04e.scala:12:8\
    \ ---------------------\e[0m\e[0m\n\e[31m12 |\e[0m        number - (digits * Math.pow(\e\
    [31m10\e[0m, digits))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Double\n\e[31m   |\e[0m        Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val parts = number.toIntPart\n        val leftover\
    \ = number.toFloat\n        (leftover - math.pow(10.0, parts)) * math.pow(10.0,\
    \ parts)\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprgew4ryj.scala:11:27 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mparts\e[0m = number.toIntPart\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    value toIntPart is not a member of Float\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmprgew4ryj.scala:13:8 ---------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        (leftover - math.pow(\e[31m10.0\e[0m, parts))\
    \ * math.pow(\e[31m10.0\e[0m, parts)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Double\n\e[31m   |\e[0m        Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val truncatedInt = math.floor(number).toInt\n\
    \        val truncatedFraction = number - truncatedInt\n        return truncatedInt.toFloat\
    \ + truncatedFraction\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwwo68cu4.scala:16)\n\tat Problem.main(tmpwwo68cu4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fraction = math.trunc(number*1e9).toFloat\n\
    \        fraction * 1e9\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiq5i09en.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mfraction\e[0m = math.trunc(number*\e\
    [31m1e9\e[0m).toFloat\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       value trunc is not a member of math\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010095
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val splitted = number.toString.split(\"\\\\.\"\
    .toRegex)\n        val result = splitted.map(_.toFloat).getOrElse(1f)\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsziri25a.scala:11:51 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36msplitted\e[0m = number.toString.split(\e\
    [31m\"\\\\.\"\e[0m.toRegex)\n\e[31m\e[31m   |\e[0m                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          value toRegex is not a member of String\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpsziri25a.scala:12:45 ------------------------\e[0m\e[0m\n\
    \e[31m12 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = splitted.map(_.toFloat).getOrElse(\e\
    [31m1f\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     value getOrElse is not a member of Array[Float]\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010097
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = (number / BigDecimal(number.toInt)).toFloat\n\
    \        (number - BigDecimal(intPart) * BigDecimal(number.toInt)).toFloat\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpmrtuh9qi.scala:11:30 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mintPart\e[0m = (number /\
    \ BigDecimal(number.toInt)).toFloat\n\e[31m\e[31m   |\e[0m                   \
    \    ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m/\e[0m in \e[33mclass\e[0m \e[35mFloat\e[0m with types\n\e[31m   |\e\
    [0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x:\
    \ Long): Float\n\e[31m   |\e[0m (x: Int): Float\n\e[31m   |\e[0m (x: Char): Float\n\
    \e[31m   |\e[0m (x: Short): Float\n\e[31m   |\e[0m (x: Byte): Float\n\e[31m  \
    \ |\e[0mmatch arguments (BigDecimal)\n1 error found\n"
  stdout: ''
  timestamp: 1660010093
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var i : Int = math.ceil(number)\n        var fraction\
    \ : Float = (number - math.floor)(math.pow(10, i-1))\n        if (math.abs(fraction)\
    \ < 1.0) {\n            i -= 1\n        }\n        fraction\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgndwz53_.scala:11:31\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mi\e\
    [0m : \e[35mInt\e[0m = math.ceil(number)\n\e[31m\e[31m   |\e[0m              \
    \        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      Found: \
    \   Double\n\e[31m   |\e[0m                      Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmpgndwz53_.scala:12:39 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mfraction\e[0m : \e[35mFloat\e\
    [0m = (number - math.floor)(math.pow(\e[31m10\e[0m, i-\e[31m1\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e\
    [0m \e[35mFloat\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m \
    \  |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Float\n\e[31m   |\e[0m\
    \ (x: Int): Float\n\e[31m   |\e[0m (x: Char): Float\n\e[31m   |\e[0m (x: Short):\
    \ Float\n\e[31m   |\e[0m (x: Byte): Float\n\e[31m   |\e[0mmatch arguments (Double\
    \ => Double)\n2 errors found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fraction = number.toInt\n        if (fraction\
    \ == number) {\n            (number / 1)\n        } else {\n            (number\
    \ - fraction)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpetluqww4.scala:21)\n\tat Problem.main(tmpetluqww4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val (integer, decimal) = math.round(number).toInt\
    \ / 10.0\n        if (decimal > 1.0) {\n            truncateNumber(number * 10.0)\n\
    \        } else {\n            number\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplt3r0i1t.scala:12:20 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mif\e[0m (decimal > \e[31m1.0\e[0m) {\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue > is not a\
    \ member of Any, but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplt3r0i1t.scala:13:27 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            truncateNumber(number * \e[31m10.0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           Found:    Double\n\e[31m   |\e[0m              \
    \             Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010097
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var integer = math.min(math.ceil(number), Int.MaxValue)\
    \ \n        var decimal = (number - integer).toFloat\n        while (decimal >=\
    \ 1.0) {\n            decimal -= 1.0\n            integer += 1\n        }\n  \
    \      integer += 1\n        math.max(0.0, decimal)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp27lm4c2k.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            decimal -= \e[31m1.0\e[0m\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not\
    \ a member of Float - did you mean Float.!=?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp27lm4c2k.scala:18:16 --------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        math.max(\e[31m0.0\e[0m, decimal)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Double\n\e[31m\
    \   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010097
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var fractionalPart = number.toInt\n        var\
    \ integerPart = number.toInt\n        var decimalPart = number.toFloat\n     \
    \   while(fractionalPart.toFloat != 0.0) {\n            fractionalPart = fractionalPart\
    \ / 10.0\n            integerPart = integerPart * 10\n        }\n        return\
    \ (decimalPart * Math.pow(10, (integerPart % 1)))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnv3sji4_.scala:15:29\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m            fractionalPart =\
    \ fractionalPart / \e[31m10.0\e[0m\n\e[31m\e[31m   |\e[0m                    \
    \         ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \     Found:    Double\n\e[31m   |\e[0m                             Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnv3sji4_.scala:18:16\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mreturn\e[0m (decimalPart\
    \ * Math.pow(\e[31m10\e[0m, (integerPart % \e[31m1\e[0m)))\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Found:    Double\n\e[31m   |\e[0m                Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // use BigDecimal to truncate a Float.\n     \
    \   val result = BigDecimal(number).setScale(0, BigDecimal.RoundingMode.HALF_UP).toFloat\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2k1tec0p.scala:16)\n\tat Problem.main(tmp2k1tec0p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010096
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = math.floor( number )\n        val\
    \ floatPart = number - intPart\n        val decimalPart = math.abs( floatPart\
    \ )\n        intPart + ( decimalPart * 100 )\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv_zzu6q1.scala:14:8\
    \ ---------------------\e[0m\e[0m\n\e[31m14 |\e[0m        intPart + ( decimalPart\
    \ * \e[31m100\e[0m )\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Double\n\e[31m   |\e[0m        Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010103
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number <= 0) 0\n        else if(number ==\
    \ 0) 1\n        else {\n            var x = math.BigDecimal(number)\n        \
    \    while(x.compareTo(BigDecimal(1)) >= 0) {\n                x = x.divide(BigDecimal(10).pow(x.signum()))\n\
    \            }\n            x.toFloat\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpel05hmx2.scala:16:22 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                x = x.divide(BigDecimal(\e[31m10\e[0m).pow(x.signum()))\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \              value divide is not a member of BigDecimal\n\e[31m\e[31m-- [E050]\
    \ Type Error: /tmp/tmpel05hmx2.scala:16:50 -----------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m                x = x.divide(BigDecimal(\e[31m10\e[0m).pow(x.signum()))\n\
    \e[31m\e[31m   |\e[0m                                                ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m              \e[33mmethod\e[0m \e[35msignum\e[0m in \e[33mclass\e\
    [0m \e[35mBigDecimal\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010103
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Find the largest integer smaller than the number.\n\
    \        // Start with a new big number for the integer part.\n        val largeInteger\
    \ = BigInt(number).floor\n\n        // Remove everything after the first decimal.\n\
    \        val leftOver = BigInt(number).minus(largeInteger)\n\n        // Return\
    \ the decimal part.\n        leftOver.floor.toFloat\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpb7am181m.scala:13:27 -----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mlargeInteger\e[0m = BigInt(number).floor\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mobject\e\
    [0m \e[35mBigInt\e[0m with types\n\e[31m   |\e[0m (x: java.math.BigInteger): BigInt\n\
    \e[31m   |\e[0m (x: String, radix: Int): BigInt\n\e[31m   |\e[0m (x: String):\
    \ BigInt\n\e[31m   |\e[0m (numbits: Int, rnd: scala.util.Random): BigInt\n\e[31m\
    \   |\e[0m (bitlength: Int, certainty: Int, rnd: scala.util.Random): BigInt\n\e\
    [31m   |\e[0m (signum: Int, magnitude: Array[Byte]): BigInt\n\e[31m   |\e[0m (x:\
    \ Array[Byte]): BigInt\n\e[31m   |\e[0m (l: Long): BigInt\n\e[31m   |\e[0m (i:\
    \ Int): BigInt\n\e[31m   |\e[0mmatch arguments ((number : Float))\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmpb7am181m.scala:16:23 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mleftOver\e[0m = BigInt(number).minus(largeInteger)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^\e[0m\n\e[31m   |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mobject\e\
    [0m \e[35mBigInt\e[0m with types\n\e[31m   |\e[0m (x: java.math.BigInteger): BigInt\n\
    \e[31m   |\e[0m (x: String, radix: Int): BigInt\n\e[31m   |\e[0m (x: String):\
    \ BigInt\n\e[31m   |\e[0m (numbits: Int, rnd: scala.util.Random): BigInt\n\e[31m\
    \   |\e[0m (bitlength: Int, certainty: Int, rnd: scala.util.Random): BigInt\n\e\
    [31m   |\e[0m (signum: Int, magnitude: Array[Byte]): BigInt\n\e[31m   |\e[0m (x:\
    \ Array[Byte]): BigInt\n\e[31m   |\e[0m (l: Long): BigInt\n\e[31m   |\e[0m (i:\
    \ Int): BigInt\n\e[31m   |\e[0mmatch arguments ((number : Float))\n2 errors found\n"
  stdout: ''
  timestamp: 1660010101
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Find the integer part using integer division\
    \ and remainder operations.\n        val intPart = (number % 1).toInt\n      \
    \  // Find the decimal part using remainder and modulus operations.\n        val\
    \ decimalPart = number - (intPart * 1.0).toFloat\n        intPart +: decimalPart\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvic0uigc.scala:15:16 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        intPart +: decimalPart\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value +:\
    \ is not a member of Float\n1 error found\n"
  stdout: ''
  timestamp: 1660010106
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val remainder = number - Math.floor((number -\
    \ 1).toDouble)\n        val decimalPart = number - remainder\n        decimalPart\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_ewgz7qa.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        decimalPart\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (decimalPart\
    \ : Double)\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010105
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val numIntPart = number.toInt\n        val decimal\
    \ = number - numIntPart\n        val decimalPart = decimal.toInt\n        val\
    \ numDecimalPart = if (decimalPart < 1) 1 else decimalPart\n        val numRemainingPart\
    \ = number.toInt % numIntPart\n        ((numIntPart * numDecimalPart) + numRemainingPart)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph2akbyff.scala:19)\n\tat Problem.main(tmph2akbyff.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integer = number.toInt\n        val fraction\
    \ = number - integer\n        if (fraction > 1.F) 1.F - fraction\n        else\
    \ fraction\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwka_peak.scala:13:25 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mif\e[0m (fraction > \e[31m1\e[0m.F) \e\
    [31m1\e[0m.F - fraction\n\e[31m\e[31m   |\e[0m                       ^^^\e[0m\n\
    \e[31m   |\e[0m                       value F is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpwka_peak.scala:13:30 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mif\e[0m (fraction > \e[31m1\e[0m.F) \e\
    [31m1\e[0m.F - fraction\n\e[31m\e[31m   |\e[0m                            ^^^\e\
    [0m\n\e[31m   |\e[0m                            value F is not a member of Int\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = math.ceil(number).toInt\n      \
    \  val fractionalPart = number - intPart\n        fractionalPart\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6zced6j8.scala:16)\n\tat Problem.main(tmp6zced6j8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var integer = number.toInt\n        if (number\
    \ < 1.0) {\n            while (integer < 1.0) {\n                integer = integer.toInt\n\
    \            }\n        }\n        val fraction = number.toFloat - (integer +\
    \ 1.0).toFloat\n        (fraction)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiltm20le.scala:21)\n\tat Problem.main(tmpiltm20le.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Find the integer part by truncating it to int.\n\
    \        // If number was greater than 0, this would have returned 0\n       \
    \ // for integer part.\n        val integerPart = math.trunc(number)\n       \
    \ // Find the decimal part by multiplying by 10^((number of decimal places - 1))\n\
    \        val decimalPart = math.pow(10.0, (number.asInstanceOf[Double]).asInstanceOf[Int]*(number.asInstanceOf[Double]).asInstanceOf[Int]-1.0)\n\
    \        decimalPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpev6pwaau.scala:14:31 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mintegerPart\e[0m = math.trunc(number)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          value trunc is not a member of math\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpev6pwaau.scala:17:8 ---------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        decimalPart\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (decimalPart : Double)\n\e[31m   |\e[0m\
    \        Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Extract the integer part and drop it from the\
    \ decimals.\n        val integer = math.ceil(number - math.floor(number))\n  \
    \      // Return the number truncated only to the integer part.\n        number\
    \ * integer.toInt\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcchekzws.scala:17)\n\tat Problem.main(tmpcchekzws.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number == 0) {\n            return 0f\n  \
    \      }\n        val decimalPart = number % 1\n        val isPositive = number\
    \ > 0\n        if (isPositive) {\n            if (number < 1) {\n            \
    \    return number\n            }\n            return truncateNumber(number /\
    \ 1f * 1f) + decimalPart\n        } else {\n            return truncateNumber(number\
    \ / 1f) - 1f + decimalPart\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\tat Problem$.truncateNumber(tmpd373ious.scala:20)\n\
    \tat Problem$.truncateNumber(tmpd373ious.sc"
  stdout: ''
  timestamp: 1660010106
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number < 0) {\n            throw new IllegalArgumentException(\"\
    Number can not be negative\")\n        } else if (number == 0) {\n           \
    \ return 0f\n        } else {\n            val n = math.ceil(number * 100)\n \
    \           val decimals = number - n * 100\n            return n * 100 + decimals\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphn4v67cl.scala:18:19\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mreturn\e[0m\
    \ n * \e[31m100\e[0m + decimals\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    Double\n\e[31m   |\e[0m     \
    \              Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Truncating floats might not give the expected\
    \ result. Let's test that.\n        // For this problem we might want to use Math#floor\n\
    \        // >>> truncateNumber(3.5f) == 3.5f\n        // true\n        // >>>\
    \ truncateNumber(3.6) == 3.5f\n        // false\n        val floor = number.floor\n\
    \        // Floating point numbers have a limited number of significant figures.\n\
    \        // Here we'll test that it is okay if we truncate more significant figures.\n\
    \        // >>> truncateNumber(3.4f) == 3.4f\n        // true\n        // >>>\
    \ truncateNumber(3.4) == 3.4f\n        // false\n        if (number > floor) {\n\
    \            floor\n        } else {\n            number\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgxd6rfo0.scala:31)\n\tat Problem.main(tmpgxd6rfo0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val floatPart = number\n        val intPart  =\
    \ math.floor(floatPart)\n        val decPart = math.min(number, intPart).toFloat\n\
    \        val decPart = math.min(decPart, 1.0f)\n        math.max(decPart, 1.0f)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2mpk4xwm.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mdecPart\e[0m = math.min(decPart,\
    \ \e[31m1.0f\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecPart is already defined as \e[33mvalue\e[0m \e[35mdecPart\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1660010103
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integer = Math.floor(number)\n        val\
    \ decimal = number - integer\n        decimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp37on91e8.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        decimal\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (decimal : Double)\n\
    \e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val decPart = number.toInt\n        val remPart\
    \ = number.toFloat\n        decPart * Math.pow(10, number.toInt)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqf42fbcu.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        decPart * Math.pow(\e\
    [31m10\e[0m, number.toInt)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Double\n\e[31m   |\e[0m        Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010106
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val numStr = number.toString.toInt\n        val\
    \ intPart = numStr.floor\n        val decimalPart = numStr.drop - intPart\n  \
    \      decimalPart.toFloat\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb9b94i0f.scala:12:29 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mintPart\e[0m = numStr.floor\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \      value floor is not a member of Int.\n\e[31m   |\e[0m      An extension\
    \ method was tried, but could not be fully constructed:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m          doubleWrapper(numStr)\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpb9b94i0f.scala:13:33 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mdecimalPart\e[0m = numStr.drop - intPart\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                     value drop is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fractional = math.round(number * 100) / 100\n\
    \        val integerPart = math.trunc(number)\n        val decimalPart = fractional\
    \ - integerPart\n        (fractional, integerPart, decimalPart)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp523ui1yt.scala:12:31 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mintegerPart\e[0m = math.trunc(number)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          value trunc is not a member of math\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp523ui1yt.scala:14:8 ---------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        (fractional, integerPart, decimalPart)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Found:    (Int, Nothing, Nothing)\n\e[31m   |\e[0m        Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val l = math.floor(number)\n        val r = number\
    \ - l\n        val i = l.toInt\n        if (i >= 1) r -= (l.toDouble * i)\n  \
    \      r\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprll5j6zi.scala:14:22 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mif\e[0m (i >= \e[31m1\e[0m) r -= (l.toDouble\
    \ * i)\n\e[31m\e[31m   |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m  \
    \               value -= is not a member of Double - did you mean r.!=?\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmprll5j6zi.scala:15:8 ---------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        r\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m\
    \   |\e[0m        Found:    (r : Double)\n\e[31m   |\e[0m        Required: Float\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010108
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = math.ceil(number)\n        val decimalPart\
    \ = (number - intPart).toFloat\n        decimalPart\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjql6awyn.scala:16)\n\tat Problem.main(tmpjql6awyn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // TODO: Refactor as part of your project\n  \
    \      // 1. Find the floor of the number\n        // 2. Find the first non-zero\
    \ digit after the decimal\n        // 3. Return number - floor - digit\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4t0nl8ky.scala:10:49\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m    \e[33mdef\e[0m \e[36mtruncateNumber\e\
    [0m(\e[36mnumber\e[0m : \e[35mFloat\e[0m) : \e[35mFloat\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                 ^\e[0m\n\e[31m   |\e\
    [0m                                                 Found:    Unit\n\e[31m   |\e\
    [0m                                                 Required: Float\n\e[31m11\
    \ |\e[0m        \e[34m// TODO: Refactor as part of your project\e[0m\n\e[31m12\
    \ |\e[0m        \e[34m// 1. Find the floor of the number\e[0m\n\e[31m13 |\e[0m\
    \        \e[34m// 2. Find the first non-zero digit after the decimal\e[0m\n\e\
    [31m14 |\e[0m        \e[34m// 3. Return number - floor - digit\e[0m\n\e[31m15\
    \ |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = math.max(number, Integer.MIN_VALUE)\n\
    \        val decimalPart = number - intPart\n        (decimalPart, intPart)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp14e1qeg0.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        (decimalPart, intPart)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mFloat\e[0m\e[1m\e[31m,\e[0m\e[1m\e\
    [31m \e[0mFloat\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: Float\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010108
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = math.ceil(number).toInt\n      \
    \  val decimalPart = number - math.floor\n        decimalPart * Math.pow(10, intPart\
    \ - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpfg_nganv.scala:12:33 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mdecimalPart\e[0m = number\
    \ - math.floor\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e\
    [0m in \e[33mclass\e[0m \e[35mFloat\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Float\n\
    \e[31m   |\e[0m (x: Int): Float\n\e[31m   |\e[0m (x: Char): Float\n\e[31m   |\e\
    [0m (x: Short): Float\n\e[31m   |\e[0m (x: Byte): Float\n\e[31m   |\e[0mmatch\
    \ arguments (Double => Double)\n1 error found\n"
  stdout: ''
  timestamp: 1660010109
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val floatPart = number - Math.floor(number)\n\
    \        val intPart   = math.min(number - Math.floor(number), floatPart)\n  \
    \      intPart * 1.0f\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp85uqu9dl.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        intPart * \e[31m1.0f\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \ Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010112
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var result = number\n        var divisor = number\n\
    \        while (result > 1 & divisor > 1) {\n            divisor /= 10\n     \
    \       result /= 10\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzgu6w8kq.scala:20)\n\tat Problem.main(tmpzgu6w8kq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010114
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = math.max(math.min(number, 1.0f),\
    \ 0.0f)\n        math.min(number - intPart, 1.0f)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3do3dn7f.scala:15)\n\tat Problem.main(tmp3do3dn7f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var decPart : Float = 0f\n        var intPart\
    \ : Float = 0f\n        var bigInt : BigInt = number.toBigInt\n        if (bigInt\
    \ != 0f) {\n            val decimalPos = bigInt.toInt\n            intPart = bigInt.toFloat\
    \ / BigInt(10).toInt\n            bigInt = bigInt.toFloat % BigInt(10).toInt\n\
    \            decPart = bigInt / BigInt(10).toInt\n        }\n        intPart.toFloat\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj258rp1r.scala:13:37 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mvar\e[0m \e[36mbigInt\e[0m : \e[35mBigInt\e\
    [0m = number.toBigInt\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toBigInt is not a member of Float, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following\
    \ import might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.BigDecimal.double2bigDecimal\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpj258rp1r.scala:17:21 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            bigInt = bigInt.toFloat % BigInt(\e[31m10\e\
    [0m).toInt\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    Float\n\e[31m   |\e[0m    \
    \                 Required: BigInt\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpj258rp1r.scala:18:22 --------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m            decPart = bigInt / BigInt(\e[31m10\e[0m).toInt\n\e[31m\e[31m\
    \   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      Found:    BigInt\n\e[31m   |\e[0m                     \
    \ Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = math.floor(number).toInt\n     \
    \   val fractionalPart = number - intPart\n        if (fractionalPart <= 1.0)\
    \ {\n            intPart\n        } else {\n            intPart + 1\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqjs3522e.scala:20)\n\tat Problem.main(tmpqjs3522e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010116
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number < 0) 0\n        else (number % 1).toFloat\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010117
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fraction = number - math.min(number)\n   \
    \     math.min(math.floor(fraction + math.pow(10, math.log10(fraction)) - math.pow(10,\
    \ math.log10(math.pow(10, math.log10(fraction)))))) / math.pow(10, math.log10(math.pow(10,\
    \ math.log10(fraction))))\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp18cihggd.scala:11:37 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mfraction\e[0m = number -\
    \ math.min(number)\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((number : Float))\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmp18cihggd.scala:12:13 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        math.min(math.floor(fraction + math.pow(\e[31m10\e\
    [0m, math.log10(fraction)) - math.pow(\e[31m10\e[0m, math.log10(math.pow(\e[31m10\e\
    [0m, math.log10(fraction)))))) / math.pow(\e[31m10\e[0m, math.log10(math.pow(\e\
    [31m10\e[0m, math.log10(fraction))))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments (Double)\n2 errors found\n"
  stdout: ''
  timestamp: 1660010113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = math.floor(number).toInt\n     \
    \   val fracPart = number - math.floor[Float](intPart)\n        fracPart\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp86f1a45v.scala:12:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mfracPart\e[0m = number -\
    \ math.floor[\e[35mFloat\e[0m](intPart)\n\e[31m\e[31m   |\e[0m               \
    \                 ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e\
    [0m \e[35mfloor\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m does not take\
    \ type parameters\n1 error found\n"
  stdout: ''
  timestamp: 1660010113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = math.floor(number)\n        val\
    \ decimalPart = number - intPart\n        intPart + decimalPart\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcecsbha_.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        intPart + decimalPart\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659803977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number.toDouble < 1.0) {\n            1.0f\n\
    \        } else {\n            number.toDouble - math.floor(number.toDouble)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaloboxtw.scala:14:12\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m            number.toDouble -\
    \ math.floor(number.toDouble)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    Double\n\e[31m   |\e[0m            Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010117
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        def divideAndRound(x: Float, y: Float) : Float\
    \ = {\n            val r = x / y\n            val f = x - r * y\n            r\
    \ +  f\n        }\n        var i = number\n        val dec = if (i < 0) 1 else\
    \ 0\n        var count = 0\n        while ((i = divideAndRound(i, 10)) > 0) {\n\
    \            count += 1\n        }\n        i / 10 * dec + (dec + count)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_x44hjlo.scala:19:43 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mwhile\e[0m ((i = divideAndRound(i, \e[31m10\e\
    [0m)) > \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue > is not a member of Unit, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordering.Unit.mkOrderingOps\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660010118
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // We are only interested in the fractional part.\
    \ Divide the\n        // given number by 100 to get rid of the fractional part.\n\
    \        val fractionalPart = number / 100f\n        // Round the number to get\
    \ rid of the fractional part.\n        val roundedNumber = math.round(fractionalPart)\n\
    \        // We still have some leftover part, divide by 10 to strip it off.\n\
    \        val fractionalPart2 = roundedNumber / 10f\n        val decimalPart =\
    \ fractionalPart2 - fractionalPart\n        val roundedDecimalPart = math.round(decimalPart)\n\
    \        roundedDecimalPart\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz6fcgvv9.scala:23)\n\tat Problem.main(tmpz6fcgvv9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010117
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var ipart = math.ceil(number);\n        var decimal\
    \ = number - ipart\n        if (decimal < 0.0000001) {\n            ipart = math.floor(ipart);\n\
    \        }\n        ipart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo76nrit7.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        ipart\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (ipart : Double)\n\
    \e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010117
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Get the fractional part of the number and discard\
    \ the integer part\n        val frac = number.toString.substring(number.toString.indexOf(\"\
    .\") + 1).trim\n        val i = frac.indexOf(\"f\")\n        val x = frac.substring(0,\
    \ i).trim\n        val y = frac.substring(i).trim\n        if (y.equals(\"\")\
    \ || y.equals(\"f\"))\n            return 0f\n        val y = y.toFloat\n    \
    \    return Math.ceil(x / y) * y + y\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe1zwq2w4.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36my\e[0m = y.toFloat\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0my is already defined\
    \ as \e[33mvalue\e[0m \e[35my\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe1zwq2w4.scala:19:27 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mreturn\e[0m Math.ceil(x / y) * y + y\n\e\
    [31m\e[31m   |\e[0m                         ^^^\e[0m\n\e[31m   |\e[0mvalue / is\
    \ not a member of String, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010118
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = math.round(number)\n       \
    \ val decimalPart = math.min(1.0, number - integerPart)\n        integerPart +\
    \ decimalPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpao_pu6f8.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        integerPart + decimalPart\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010117
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Get the integer part of the number (integer\
    \ part is also the number\n        // without the decimal part)\n        val intPart\
    \ = number.toInt\n        // Remove the decimal part\n        val fractionalPart\
    \ = intPart.toFloat - intPart.toFloat % 1\n        fractionalPart\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_pcdmbow.scala:19)\n\tat Problem.main(tmp_pcdmbow.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010117
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var integer = math.min(math.floor(number), 100)\n\
    \        number = number - math.floor(number)\n        val d = number / 100\n\
    \        integer = math.min(math.floor(d * (math.min(100, integer) - integer)),\
    \ 100)\n        number * 100\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp85e_i8g3.scala:12:17\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        number = number - math.floor(number)\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                 Found:    Double\n\e[31m   |\e[0m                 Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010117
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = number.toInt\n        val decimalPart\
    \ = number - integerPart\n        val resultingPart = decimalPart / 10\n     \
    \   return resultingPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0z_ynu0z.scala:17)\n\tat Problem.main(tmp0z_ynu0z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010117
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = Math.floor(number)\n       \
    \ val decimalPart = number - integerPart\n        integerPart + (decimalPart *\
    \ Math.pow(10,\n        decimalPart.toInt))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppuj_m5ds.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        integerPart + (decimalPart\
    \ * Math.pow(\e[31m10\e[0m,\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e\
    [0m        Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m14\
    \ |\e[0m        decimalPart.toInt))\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010117
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var fractionalPart = number.toString.substring(0,\
    \ number.toString.length-1)\n        fractionalPart.toFloat/10\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa742xb72.scala:15)\n\tat Problem.main(tmpa742xb72.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010118
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var fractionalPart = number.toInt\n        var\
    \ integerPart = 0.toFloat\n        var decimalPart = 0.toFloat\n        while\
    \ (fractionalPart > 0) {\n            fractionalPart -= fractionalPart % 10\n\
    \            integerPart += fractionalPart / 10\n            decimalPart += (fractionalPart\
    \ % 10) / 10\n        }\n        decimalPart\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp5_pyty1.scala:22)\n\tat Problem.main(tmpp5_pyty1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010118
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = math.floor(number)\n        val\
    \ dec = number - intPart\n        intPart + (dec / (1.0f * math.pow(10.0, math.ceil(math.log10(dec))))).toFloat\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd4yspbrr.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        intPart + (dec / (\e\
    [31m1.0f\e[0m * math.pow(\e[31m10.0\e[0m, math.ceil(math.log10(dec))))).toFloat\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Double\n\e[31m   |\e[0m        Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010118
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fraction = number % 1\n        var intPart\
    \ = number - fraction\n        if (intPart < 0) intPart *= -1\n        (fraction\
    \ / (1 - fraction)) * (1 / Int) \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp9aiwli11.scala:14:41 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        (fraction / (\e[31m1\e[0m - fraction)) * (\e\
    [31m1\e[0m / Int) \n\e[31m\e[31m   |\e[0m                                    \
    \   ^^^\e[0m\n\e[31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m/\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m\
    \  (x: Double): Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x:\
    \ Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\
    \e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e\
    [0m match arguments (Int.type)\n1 error found\n"
  stdout: ''
  timestamp: 1660010115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var result = number\n        \n        // If number\
    \ is not an integer, we split it into an integer part and decimals.\n        if\
    \ (number % 1 != 0) \n            result = math.floor(number / 1)\n        \n\
    \        // If number is an integer, then we return that integer part.\n     \
    \   else\n            result\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpadoejcr9.scala:15:31\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m            result = math.floor(number\
    \ / \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    Double\n\e[31m   |\e[0m   \
    \                  Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010119
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = number.toInt\n        val decimalPart\
    \ = number - intPart\n        (decimalPart, intPart)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8hw2ir4l.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        (decimalPart, intPart)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    \e[1m\e[31m(\e[0mFloat\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e\
    [31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: Float\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010123
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integer = math.floor(number).toInt - 1\n \
    \       val decimal = number.toDouble - number * integer.toDouble\n        (decimal\
    \ + 1.0f).toFloat\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbp67cnt1.scala:16)\n\tat Problem.main(tmpbp67cnt1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010124
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val ipart = floor(number)\n        val fpart =\
    \ number - ipart\n        (ipart + (if (ipart % 1 == 0) 0.5f else 0f)) * (if (fpart\
    \ < 0) 1 else fpart)\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq4jp_fpg.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        (ipart + (\e[33mif\e\
    [0m (ipart % \e[31m1\e[0m == \e[31m0\e[0m) \e[31m0.5f\e[0m \e[33melse\e[0m \e\
    [31m0f\e[0m)) * (\e[33mif\e[0m (fpart < \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e\
    [0m fpart)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Double\n\e[31m   |\e[0m        Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010123
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fractionalPart = number.toInt\n        val\
    \ decimalPart = math.ceil(number.toDouble * 100) / 100\n        fractionalPart\
    \ * 10 / decimalPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpktgfvu61.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        fractionalPart * \e\
    [31m10\e[0m / decimalPart\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Double\n\e[31m   |\e[0m        Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010123
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val remainder = number % 1.0\n        number -\
    \ (remainder * 1.0)\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1f1cj7j5.scala:12:8\
    \ ---------------------\e[0m\e[0m\n\e[31m12 |\e[0m        number - (remainder\
    \ * \e[31m1.0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Double\n\e[31m   |\e[0m        Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010124
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var integer = math.min(math.floor(number), math.ceil(number))\n\
    \        integer = math.min(integer, 10)\n        number - math.floor(number)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeyf70ga6.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        number - math.floor(number)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010126
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      val integer = math.floor(number)\n      val fraction\
    \ = number - integer\n      fraction\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp60af4q7l.scala:13:6\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m      fraction\n\e[31m\e[31m\
    \   |\e[0m      ^^^^^^^^\e[0m\n\e[31m   |\e[0m      Found:    (fraction : Double)\n\
    \e[31m   |\e[0m      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010127
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = math.ceil(number).toInt\n  \
    \      val fractionPart = number - math.ceil(number).toFloat\n        math.round(fractionPart*10f)/10f\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6wlxp1a0.scala:16)\n\tat Problem.main(tmp6wlxp1a0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = math.ceil(number).toInt\n      \
    \  (number - math.floor(number)).pow(10 * intPart)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3jqjo0m5.scala:12:38 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        (number - math.floor(number)).pow(\e[31m10\e\
    [0m * intPart)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue pow is not a member of Double, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigDecimal.double2bigDecimal\n\
    \e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660010128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val f = number\n        val s = BigDecimal(f).toBigDecimal.setScale(1,\
    \ RoundingMode.HALF_UP)\n        val d = s.divide(BigDecimal(1), BigDecimal.ROUND_HALF_UP)\n\
    \        val res = (f.toInt - d.toInt).toFloat\n        return res\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprbcmr9gm.scala:12:30 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = BigDecimal(f).toBigDecimal.setScale(\e\
    [31m1\e[0m, RoundingMode.HALF_UP)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toBigDecimal is not a member of BigDecimal - did you\
    \ mean BigDecimal.bigDecimal?\n1 error found\n"
  stdout: ''
  timestamp: 1660010127
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val splitted = number.toString.split(\"\\\\.\"\
    ) // [\"3\",\"5\"]\n        val truncated = splitted.head.trim.toDouble  // 5\n\
    \        val decimals = splitted.length.toDouble - truncated.toDouble - 1  //\
    \ 0\n        truncated.toFloat / 10f.toFloat * 10f.toFloat + decimals  // 5.5\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbph4ab92.scala:14:8\
    \ ---------------------\e[0m\e[0m\n\e[31m14 |\e[0m        truncated.toFloat /\
    \ \e[31m10f\e[0m.toFloat * \e[31m10f\e[0m.toFloat + decimals  \e[34m// 5.5\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Double\n\e[31m   |\e[0m        Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010127
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val i = math.ceil(math.abs(number))\n        val\
    \ decimal = (number - math.ceil(i)).toFloat\n        (decimal + 0.5f).toFloat\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvo7v_s6m.scala:16)\n\tat Problem.main(tmpvo7v_s6m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fractionalPart = number % 1.0\n        //\
    \ Truncate to nearest integer\n        if (fractionalPart >= 0.5) {\n        \
    \    return number - fractionalPart\n        } else {\n            return number\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkolp7614.scala:14:19\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m            \e[33mreturn\e[0m\
    \ number - fractionalPart\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    Double\n\e[31m   |\e[0m     \
    \              Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val floorexp = math.floor(number)\n        if\
    \ (floorexp == number) {\n            return number\n        }\n\n        val\
    \ fraction = (number - floorexp).abs\n        if (fraction < 1) {\n          \
    \  return number\n        }\n\n        // fraction is greater than 1, return floorexp\n\
    \        floorexp\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp28f0hmiq.scala:22:8\
    \ ---------------------\e[0m\e[0m\n\e[31m22 |\e[0m        floorexp\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (floorexp :\
    \ Double)\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val decimals = number.toString.split('.')\n  \
    \      val integer = decimals(0)\n        val remainder = decimals(1)\n      \
    \  val finalRemainder = remainder.toString.toFloat\n        ((number - integer\
    \ - remainder) / finalRemainder) * finalRemainder\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpv8gxdz0j.scala:15:17 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        ((number - integer - remainder) / finalRemainder)\
    \ * finalRemainder\n\e[31m\e[31m   |\e[0m          ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e\
    [33mclass\e[0m \e[35mFloat\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\
    \e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Float\n\e[31m  \
    \ |\e[0m (x: Int): Float\n\e[31m   |\e[0m (x: Char): Float\n\e[31m   |\e[0m (x:\
    \ Short): Float\n\e[31m   |\e[0m (x: Byte): Float\n\e[31m   |\e[0mmatch arguments\
    \ ((integer : String))\n1 error found\n"
  stdout: ''
  timestamp: 1660010125
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number < 0) {\n            throw new IllegalArgumentException(\"\
    The number cannot be negative.\")\n        }\n        val frac = number - Math.floor(number)\n\
    \        if (frac < 0) {\n            frac * -1\n        } else {\n          \
    \  frac\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_8lksez0.scala:16:12\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m            frac * -\e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \    Found:    Double\n\e[31m   |\e[0m            Required: Float\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_8lksez0.scala:18:12 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            frac\n\e[31m\e[31m   |\e[0m            ^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    (frac : Double)\n\e[31m   |\e[0m   \
    \         Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val f = new DecimalFormat(\"#.##\")\n        f.setRoundingMode(RoundingMode.HALF_UP)\n\
    \        val result = f.format(number)\n        if(result != \"0\") f.parse(result).toFloat\n\
    \        else 0f\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpge0quz2s.scala:11:20 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mf\e[0m = \e[33mnew\e[0m\
    \ \e[35mDecimalFormat\e[0m(\e[31m\"#.##\"\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \             ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ type DecimalFormat\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010124
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fractionalPart = number - math.floor(number)\n\
    \        fractionalPart % 1\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi3nlgxnf.scala:12:8\
    \ ---------------------\e[0m\e[0m\n\e[31m12 |\e[0m        fractionalPart % \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var result : Float = 0.f\n        var exponent\
    \ : Int = number.toInt\n        while (exponent > 0) {\n            result = (result\
    \ + number.toFloat.toInt).toFloat / 10\n            exponent -= 1\n        }\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpndemor7n.scala:11:31 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m : \e[35mFloat\e\
    [0m = \e[31m0\e[0m.f\n\e[31m\e[31m   |\e[0m                             ^^^\e\
    [0m\n\e[31m   |\e[0m                             value f is not a member of Int\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010129
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var decimalPart = number.toFloat\n        decimalPart\
    \ -= Math.floor(decimalPart)\n        decimalPart\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqdjuqmhz.scala:12:20 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        decimalPart -= Math.floor(decimalPart)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value -= is not\
    \ a member of Float - did you mean Float.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        require(number > 0)\n        // Get integer part\n\
    \        var integerPart = number.toInt\n        require(integerPart > 0)\n  \
    \      // Get decimals\n        var decimals = number - integerPart\n        require(decimals\
    \ >= 0)\n        // Return\n        decimals\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010129
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number > 1.0f) 1.0f\n        else {\n    \
    \        val integer = math.floor(number)\n            if (integer >= 1.0f) integer\
    \ - 1.0f\n            else 1.0f\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnaaw0si4.scala:14:33\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m            \e[33mif\e[0m (integer\
    \ >= \e[31m1.0f\e[0m) integer - \e[31m1.0f\e[0m\n\e[31m\e[31m   |\e[0m       \
    \                          ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                   Found:    Double\n\e[31m   |\e[0m                        \
    \         Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010129
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Create new number with rounded off digits\n\
    \        var newNumber = round(number*1000.0f)\n        val decimalPart = newNumber.toInt/10.0f\n\
    \        newNumber = newNumber.toInt % 10\n        return decimalPart\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps_0nt3n7.scala:18)\n\tat Problem.main(tmps_0nt3n7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010129
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Convert the given number to an integer.\n \
    \       val integerPart = math.ceil(number).toInt\n\n        // Get the decimal\
    \ part of the number from right to left.\n        // Note that if the decimal\
    \ part is 0, the result would be 0 instead.\n        // We will get 0 only if\
    \ the input number is smaller than 1.\n        var decimalPart = number - math.pow(10,\
    \ integerPart.toInt)\n\n        // If the decimal part is 0, then we will simply\
    \ return zero.\n        // Otherwise, truncate it to closest integer by rounding\
    \ down.\n        if (decimalPart == 0)\n            return 0\n        else\n \
    \           math.round(decimalPart)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqj3pv5uc.scala:27)\n\tat Problem.main(tmpqj3pv5uc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010134
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fractionalPart = number.toInt\n        var\
    \ decimalPart = 1\n\n        while (fractionalPart > 0) decimalPart *= 10\n  \
    \      fractionalPart += decimalPart\n        fractionalPart\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsifh59fp.scala:15:23 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        fractionalPart += decimalPart\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       value += is not\
    \ a member of Int - did you mean fractionalPart.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010134
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = math.ceil(number)\n        (number-intPart).toFloat\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8y_qsdnf.scala:15)\n\tat Problem.main(tmp8y_qsdnf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010134
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val maxInteger = number.toInt\n        val fractionalPart\
    \ = number - maxInteger\n        if (fractionalPart > 0.0f)\n            fractionalPart\
    \ else 0.0f\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010134
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val numInt = math.floor(number)\n        val numFloat\
    \ = math.floor(number-numInt)\n        (numFloat, numInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph7wp57ov.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        (numFloat, numInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    (Double, Double)\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010134
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = math.floor(number)\n        val\
    \ fracPart = number - intPart\n        fracPart < 1.0 ? (intPart / float(intPart))\
    \ : (intPart + 1) / float(math.ceil(intPart) + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp46ug9l6f.scala:13:75 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        fracPart < \e[31m1.0\e[0m ? (intPart / float(intPart))\
    \ : (\e[35mintPart\e[0m \e[35m+\e[0m \e[31m1\e[0m) \e[35m/\e[0m \e[35mfloat\e\
    [0m(math.ceil(intPart) + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \                                                           ^\e[0m\n\e[31m   |\e\
    [0m                                 end of statement expected but '(' found\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp46ug9l6f.scala:13:68 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        fracPart < \e[31m1.0\e[0m ? (intPart / float(intPart))\
    \ : (\e[35mintPart\e[0m \e[35m+\e[0m \e[31m1\e[0m) \e[35m/\e[0m \e[35mfloat\e\
    [0m(math.ceil(intPart) + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                                                      Not found: type /\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp46ug9l6f.scala:13:23 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        fracPart < \e[31m1.0\e[0m ? (intPart / float(intPart))\
    \ : (\e[35mintPart\e[0m \e[35m+\e[0m \e[31m1\e[0m) \e[35m/\e[0m \e[35mfloat\e\
    [0m(math.ceil(intPart) + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \   ^^^^^\e[0m\n\e[31m   |\e[0m                   value ? is not a member of Double\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp46ug9l6f.scala:13:36 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        fracPart < \e[31m1.0\e[0m ? (intPart / float(intPart))\
    \ : (\e[35mintPart\e[0m \e[35m+\e[0m \e[31m1\e[0m) \e[35m/\e[0m \e[35mfloat\e\
    [0m(math.ceil(intPart) + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \                    ^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \       Not found: float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010134
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = math.ceil(number).intValue\n\
    \        val decimalPart = number - integerPart\n        number\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc522xbzx.scala:16)\n\tat Problem.main(tmpc522xbzx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010136
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integer = math.floor(number);\n        val\
    \ fraction = number - integer\n        val decimal = math.round(fraction * 100)\
    \ / 100\n        decimal + integer\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa9n7c4ep.scala:14:8\
    \ ---------------------\e[0m\e[0m\n\e[31m14 |\e[0m        decimal + integer\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010136
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = number/Integer.MaxValue\n  \
    \      val decimalPart = number - integerPart*Integer.MaxValue\n        decimalPart\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptiwnqq51.scala:11:41 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mintegerPart\e[0m = number/Integer.MaxValue\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        value MaxValue is not a member of object\
    \ Integer\n1 error found\n"
  stdout: ''
  timestamp: 1660010137
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        def truncateDecimal(number : Float, decimal :\
    \ Int) : Float = {\n            number / math.pow(10, decimal)\n        }\n  \
    \      val bigger = math.abs(number)\n        val power = math.log(bigger)\n \
    \       val result = number / math.pow(10, math.abs(power))\n        truncateDecimal(result,\
    \ power)\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplrzwn44t.scala:12:12\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m            number / math.pow(\e\
    [31m10\e[0m, decimal)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    Double\n\e[31m   |\e[0m            Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplrzwn44t.scala:17:24\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        truncateDecimal(result,\
    \ power)\n\e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Found:    (result : Double)\n\e[31m   |\e[0m      \
    \                  Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmplrzwn44t.scala:17:32 --------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        truncateDecimal(result, power)\n\e[31m\e[31m   |\e[0m        \
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \       Found:    (power : Double)\n\e[31m   |\e[0m                          \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010139
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var digits = number\n        // truncate to the\
    \ leftmost significant digit (smallest possible)\n        digits -= digits % 1\n\
    \        // the remaining fractional digits are the decimal part of the number\n\
    \        digits = digits * 10\n        digits\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp9lws8zo.scala:19)\n\tat Problem.main(tmpp9lws8zo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = math.ceil(number).toFloat\n    \
    \    val fractionalPart = number - intPart\n        (fractionalPart, intPart)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuiv0uiey.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        (fractionalPart, intPart)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mFloat\e[0m\e[1m\e[31m,\e[0m\e[1m\e\
    [31m \e[0mFloat\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: Float\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integer = math.floor(number)\n        val\
    \ fraction = number - integer\n        fraction\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5ms2_88y.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        fraction\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (fraction :\
    \ Double)\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010137
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fraction = (number.toInt - intPart(number)).toFloat\n\
    \        fraction\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7cwvregu.scala:11:39 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mfraction\e[0m = (number.toInt\
    \ - intPart(number)).toFloat\n\e[31m\e[31m   |\e[0m                          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \     Not found: intPart\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010135
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val num = number.toInt\n        val dec = num\
    \ % 1\n        val intPart = num - dec\n        val remainder = number - intPart\
    \ * 1.0\n        val newNum = remainder * 10 + dec\n        newNum\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkvg97y05.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        newNum\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (newNum : Double)\n\
    \e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010139
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var num = number\n        val dec = num.toInt\n\
    \        while(dec > 0) {\n            num = num.toDouble / 10\n            dec\
    \ -= 1\n        }\n        num\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp27w_0fv4.scala:14:18\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m            num = num.toDouble\
    \ / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Found:    Double\n\e[31m   |\e[0m      \
    \            Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp27w_0fv4.scala:15:16 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m            dec -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value -= is not a member of Int - did you mean\
    \ dec.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010139
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fraction = math.trunc(number).toInt - 1.0\n\
    \        number - fraction * math.pow(10.0, number.toInt)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3vsngpd0.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mfraction\e[0m = math.trunc(number).toInt\
    \ - \e[31m1.0\e[0m\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       value trunc is not a member of math\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010138
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = number % 1\n        val decimalPart\
    \ = math.floor(number - intPart).toFloat\n        (decimalPart * 1).toInt\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu_g_e0f_.scala:16)\n\tat Problem.main(tmpu_g_e0f_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010139
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val num = number % 1.0\n        if (num < 0.0)\
    \ {\n            math.abs(num.toInt) * 1.0\n        } else {\n            num.toInt\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3gl25nt4.scala:13:12\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m            math.abs(num.toInt)\
    \ * \e[31m1.0\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    Double\n\e[31m   |\e[0m            Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010139
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number <= 0) {\n            return 0f\n  \
    \      }\n        // find decimal portion\n        var dec = 0\n        var intPart\
    \ = 0\n        while (number >= 1) {\n            number = number / 10f\n    \
    \        intPart++\n            dec += 1\n        }\n        val intPart = intPart\
    \ * 10f\n        val finalDec = dec * 10f\n        val finalInt = intPart + finalDec\n\
    \        val finalNumber = intPart * 10f + finalDec\n        // check if finalNumber\
    \ is smaller than original number\n        if (finalNumber < number) {\n     \
    \       val remainingPart = (number - finalNumber) * 10f\n            finalNumber\
    \ += remainingPart\n            finalInt += remainingPart\n        }\n       \
    \ return finalNumber\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2k6e0o97.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mintPart\e[0m = intPart *\
    \ \e[31m10f\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mintPart is already defined as \e[33mvariable\e[0m \e[35mintPart\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E052] Type\
    \ Error: /tmp/tmp2k6e0o97.scala:18:19 -----------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m            number = number / \e[31m10f\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val number\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2k6e0o97.scala:19:19\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            intPart++\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ ++ is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2k6e0o97.scala:29:24\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            finalNumber +=\
    \ remainingPart\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        value += is not a member of Float - did you mean finalNumber.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2k6e0o97.scala:30:21 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            finalInt += remainingPart\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value += is not\
    \ a member of Float - did you mean finalInt.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1660010140
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // TODO: Complete this function\n        var integer\
    \ = 1\n        var decimal = 0\n        while (decimal < 1 && number >= 1) {\n\
    \            number /= 10\n            decimal += 1\n        }\n        decimal\
    \ * 10\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpds0insf_.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            number /= \e[31m10\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Float - did you mean number.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010140
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fracPart = number.toInt/number.toInt\n   \
    \     val truncated = number.toInt - (fracPart*number.toInt)\n        truncated\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpneb6xlqt.scala:16)\n\tat Problem.main(tmpneb6xlqt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010140
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fractional = math.trunc(number)\n        val\
    \ integer = math.floor(number)\n        fractional + integer / 10\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6uzstt8p.scala:11:30 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mfractional\e[0m = math.trunc(number)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         value trunc is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010140
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val (integerPart, decimalPart) = math.partition(number)\n\
    \        integerPart * 0.1f\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjzvgjzfb.scala:11:46 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m (integerPart, decimalPart) = math.partition(number)\n\
    \e[31m\e[31m   |\e[0m                                         ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 value partition is not a\
    \ member of math\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjzvgjzfb.scala:11:13\
    \ ---------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m\
    \ (integerPart, decimalPart) = math.partition(number)\n\e[31m\e[31m   |\e[0m \
    \            ^\e[0m\n\e[31m   |\e[0m             Recursive \e[33mvalue\e[0m \e\
    [35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjzvgjzfb.scala:11:26\
    \ ---------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m\
    \ (integerPart, decimalPart) = math.partition(number)\n\e[31m\e[31m   |\e[0m \
    \                         ^\e[0m\n\e[31m   |\e[0m                          Recursive\
    \ \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010145
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val dec = number % 1\n        val integer = math.trunc(number)\n\
    \        (integer - dec, dec)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6g50wrjf.scala:12:27 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36minteger\e[0m = math.trunc(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                    value trunc is not a member of math\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp6g50wrjf.scala:13:8 ---------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        (integer - dec, dec)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (Nothing, Float)\n\
    \e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010146
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if(number.toInt() > 0) {\n            val remainder\
    \ = number % 1\n            number - remainder\n        } else {\n           \
    \ 0.0\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpvw8969ah.scala:11:18 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mif\e[0m(number.toInt() > \e[31m0\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \     \e[33mmethod\e[0m \e[35mtoInt\e[0m in \e[33mclass\e[0m \e[35mFloat\e[0m\
    \ does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010141
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val a = number.toInt\n        val b = number.toFloat\
    \ - number.toInt * number.toDouble\n        return b\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwv_k1rtd.scala:13:15\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mreturn\e[0m b\n\
    \e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (b : Double)\n\e[31m   |\e[0m               Required: Float\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010145
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val (integ, dec) = (math.floor, math.floor)\n\
    \        (number / dec) match {\n            case 0 => (integer - 1)\n       \
    \     case _ => (integer - 1) + dec\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0o8zu4ss.scala:12:16 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        (number / dec) \e[33mmatch\e[0m {\n\e[31m\e[31m\
    \   |\e[0m         ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m/\e[0m in \e[33mclass\e[0m \e[35mFloat\e[0m with\
    \ types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\
    \e[31m   |\e[0m (x: Long): Float\n\e[31m   |\e[0m (x: Int): Float\n\e[31m   |\e\
    [0m (x: Char): Float\n\e[31m   |\e[0m (x: Short): Float\n\e[31m   |\e[0m (x: Byte):\
    \ Float\n\e[31m   |\e[0mmatch arguments ((dec : Double => Double))\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp0o8zu4ss.scala:13:23 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mcase\e[0m \e[31m0\e[0m => (integer\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                       Not found: integer\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0o8zu4ss.scala:14:23 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mcase\e[0m _ => (integer - \e[31m1\e\
    [0m) + dec\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                       Not found: integer\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010143
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var intPart = number.toInt\n        var fractionalPart\
    \ = (number - intPart).toFloat\n        // The fractional part will always be\
    \ smaller than 1\n        fractionalPart = fractionalPart / (intPart + 1) \n \
    \       intPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpto2680zz.scala:18)\n\tat Problem.main(tmpto2680zz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010146
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fractionalPart = number.toInt\n        val\
    \ integralPart = math.ceil(fractionalPart * 10) / 10\n        val truncatedNumber\
    \ = number.toDouble / (math.pow(10.0, integralPart))\n        truncatedNumber\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbc8wdem3.scala:14:8\
    \ ---------------------\e[0m\e[0m\n\e[31m14 |\e[0m        truncatedNumber\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    (truncatedNumber : Double)\n\e[31m   |\e[0m        Required: Float\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010146
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val num = math.abs(number)\n        val integerPart\
    \ = (num - math.floor(num)) % 1\n        val decimalPart = (num - math.floor(num))\
    \ / 1\n        decimalPart * 1.0f\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg54u6410.scala:14:8\
    \ ---------------------\e[0m\e[0m\n\e[31m14 |\e[0m        decimalPart * \e[31m1.0f\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \     Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010147
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integer = Math.floor(number);\n        var\
    \ remainder = number - integer;\n        while(integer > 0) {\n            integer\
    \ /= 10;\n            remainder /= 10;\n        }\n        (remainder).abs()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmky0zbc1.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            integer /= \e[31m10\e[0m;\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value /= is not\
    \ a member of Double - did you mean integer.!=?\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmpmky0zbc1.scala:17:20 -----------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        (remainder).abs()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        \e[33mmethod\e[0m \e[35mabs\e[0m in \e[33mclass\e\
    [0m \e[35mRichDouble\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010148
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = number/1\n        val decimalPart\
    \ = number-integerPart*1\n        decimalPart\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7vocsth3.scala:16)\n\tat Problem.main(tmp7vocsth3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010147
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      var temp : Int = 0\n      var i = number\n     \
    \ while (i <= Float.PositiveInfinity) {\n        if (i % 1.0f == 0) {\n      \
    \    temp = temp + 1\n        }\n        i = i / 10f\n      }\n      number\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660010152
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var integer : Float = 0\n        var decimals\
    \ : Float = 1\n        var fractional : Float = 1\n        if (number == 0) {\n\
    \            return float(0)\n        } else {\n            while(number != 0)\
    \ {\n                integer += number % 1\n                decimals += 1\n  \
    \              fractional *= 10\n                number /= 10\n            }\n\
    \        }\n        (integer + fractional) / decimals\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpeikg_zrs.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mreturn\e[0m float(\e[31m0\e[0m)\n\e\
    [31m\e[31m   |\e[0m                   ^^^^^\e[0m\n\e[31m   |\e[0m            \
    \       Not found: float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpeikg_zrs.scala:21:23 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m                number /= \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m            \
    \    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value /= is not a member of Float\
    \ - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integer = math.floor(number)\n        val\
    \ fraction = number - integer\n        if (fraction < 1.0) integer else number\
    \ - integer - 1\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprphoveud.scala:13:28\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mif\e[0m (fraction\
    \ < \e[31m1.0\e[0m) integer \e[33melse\e[0m number - integer - \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                           Found:    (integer : Double)\n\e[31m   |\e[0m    \
    \                        Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmprphoveud.scala:13:41 --------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mif\e[0m (fraction < \e[31m1.0\e[0m) integer\
    \ \e[33melse\e[0m number - integer - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m     \
    \                                    ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                         Found:    Double\n\e[31m   |\e[0m  \
    \                                       Required: Float\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val negative = number < 0\n        val integer\
    \ = math.round(number)\n        val decimal = number - integer\n        if (negative)\
    \ {\n            if (integer < 0) {\n                0f\n            } else {\n\
    \                0f\n            }\n        } else {\n            if (integer\
    \ > 1) {\n                1f\n            } else {\n                decimal\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj9hsxn32.scala:29)\n\tat Problem.main(tmpj9hsxn32.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val frac = number % 1\n        if (frac > 0.5)\
    \ {\n            number - frac\n        }\n        else {\n            number\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps3jcm_l1.scala:20)\n\tat Problem.main(tmps3jcm_l1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var newNum : Float = 0f\n        var isInt : Boolean\
    \ = false\n        var decimal : Float = 1f\n        while (number != 0f) {\n\
    \            val floatPart = number.toInt\n            if (floatPart > newNum)\
    \ {\n                newNum = floatPart\n                decimal = 1f\n      \
    \      } else {\n                if (newNum != 0f) {\n                    isInt\
    \ = true\n                    newNum += decimal\n                }\n         \
    \   }\n            number -= floatPart\n        }\n        if (isInt) {\n    \
    \        newNum.toFloat\n        } else {\n            0f\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2da7ng5h.scala:25:19 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            number -= floatPart\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Float - did you mean number.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010150
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = number.toInt\n        val decimal\
    \ = number.toDouble - intPart\n        return intPart + decimal\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr9dlgor4.scala:13:15\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mreturn\e[0m intPart\
    \ + decimal\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m               Found:    Double\n\e[31m   |\e[0m               Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010150
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = Math.floor(number)\n        val\
    \ fract = number - intPart\n        val decimalPart = fract * 10\n        decimalPart\
    \ / 10\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjshylxv4.scala:14:8\
    \ ---------------------\e[0m\e[0m\n\e[31m14 |\e[0m        decimalPart / \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010150
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var intPart : Int = math.floor( math.abs(number)\
    \ )\n        val fracPart = number - intPart\n        if (fracPart < 0.01f)\n\
    \            return 0.0f + intPart\n        else\n            return intPart\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3_xiae3q.scala:11:38\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mintPart\e\
    [0m : \e[35mInt\e[0m = math.floor( math.abs(number) )\n\e[31m\e[31m   |\e[0m \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                            Found:    Double\n\e[31m   |\e[0m             \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010150
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Return integer part if it's whole number\n\
    \        if (math.trunc(number) == number) number\n        else number / 10f\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqb4268cm.scala:12:17 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mif\e[0m (math.trunc(number) == number)\
    \ number\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \          value trunc is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010150
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val decimalPart = number.toInt\n        val floorPart\
    \ = (number - decimalPart).abs.toInt\n        floorPart * 1.0 / number\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpghslw0gp.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        floorPart * \e[31m1.0\e\
    [0m / number\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fractionalPart = number.toInt % 1\n      \
    \  number.toFloat - fractionalPart\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplcdvwict.scala:15)\n\tat Problem.main(tmplcdvwict.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val whole = number.toInt\n        val fraction\
    \ = number.toDouble\n        if(fraction < 1.0) whole\n        else whole - fraction.toInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4z71sybv.scala:17)\n\tat Problem.main(tmp4z71sybv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fractionalPart = number % 1\n        val integerPart\
    \ = (number - fractionalPart).toInt\n        (fractionalPart, integerPart)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd2sxpxc_.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        (fractionalPart, integerPart)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Found:    \e[1m\e[31m(\e[0mFloat\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e\
    [1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: Float\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fraction = number.toInt\n        val decimals\
    \ = (fraction - 1) / 2\n        fraction - decimals\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiv0toq67.scala:16)\n\tat Problem.main(tmpiv0toq67.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010155
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val decPart = math.trunc(number)\n        val\
    \ intPart = math.trunc(number - decPart)\n        decPart * 10f / intPart\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbwgzhftw.scala:11:27 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mdecPart\e[0m = math.trunc(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                    value trunc is not a member of math\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpbwgzhftw.scala:12:27 ------------------------\e[0m\e\
    [0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mintPart\e[0m = math.trunc(number\
    \ - decPart)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      value trunc is not a member of math\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010156
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      val integerPart = (number / 1.0).floor.toFloat\n\
    \      val decimalPart = (number - integerPart*1.0).toFloat\n      decimalPart\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010157
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number == 0) 0f\n        else BigDecimal(number).divide(BigDecimal(number).add(BigDecimal.ONE),\
    \ 2, BigDecimal.ROUND_HALF_DOWN).toFloat\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd68hpzy8.scala:12:32 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33melse\e[0m BigDecimal(number).divide(BigDecimal(number).add(BigDecimal.ONE),\
    \ \e[31m2\e[0m, BigDecimal.ROUND_HALF_DOWN).toFloat\n\e[31m\e[31m   |\e[0m   \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value divide\
    \ is not a member of BigDecimal\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd68hpzy8.scala:12:58\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33melse\e[0m BigDecimal(number).divide(BigDecimal(number).add(BigDecimal.ONE),\
    \ \e[31m2\e[0m, BigDecimal.ROUND_HALF_DOWN).toFloat\n\e[31m\e[31m   |\e[0m   \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m  value add is not a member of BigDecimal - did you mean BigDecimal.abs?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpd68hpzy8.scala:12:73 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33melse\e[0m BigDecimal(number).divide(BigDecimal(number).add(BigDecimal.ONE),\
    \ \e[31m2\e[0m, BigDecimal.ROUND_HALF_DOWN).toFloat\n\e[31m\e[31m   |\e[0m   \
    \                                                           ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m               value ONE is not a member of object scala.math.BigDecimal\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd68hpzy8.scala:12:93 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33melse\e[0m BigDecimal(number).divide(BigDecimal(number).add(BigDecimal.ONE),\
    \ \e[31m2\e[0m, BigDecimal.ROUND_HALF_DOWN).toFloat\n\e[31m\e[31m   |\e[0m   \
    \                                                                            \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value ROUND_HALF_DOWN is\
    \ not a member of object scala.math.BigDecimal\n4 errors found\n"
  stdout: ''
  timestamp: 1660010157
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        require (number > 0, \"The number is negative\"\
    )\n        val remainder = number.toFloat % 1\n        (remainder - number.toFloat\
    \ / 1).toFloat\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu9kwlrt2.scala:16)\n\tat Problem.main(tmpu9kwlrt2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010157
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val maxInt = math.pow(10, math.ceil(math.log10(number))).toInt\n\
    \        (number - math.pow(10, math.floor(math.log10(number)))).*(1/maxInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp15hol47h.scala:12:65\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        (number - math.pow(\e\
    [31m10\e[0m, math.floor(math.log10(number)))).*(\e[31m1\e[0m/maxInt)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Double\n\e[31m   |\e[0m        Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010156
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Using binary search to find the integer part\n\
    \        val i = (number.toInt - Math.floor(number.toInt))/2\n        if (i <=\
    \ number.toInt)\n            number\n        else\n            truncateNumber(number/(i.toFloat))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8cf61l8r.scala:19)\n\tat Problem.main(tmp8cf61l8r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010158
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        def toInt(number : Float) : Int = {\n        \
    \    math.round(number).toInt\n        }\n        def toFloat(number : Int) :\
    \ Float = {\n            number / java.lang.Math.pow(10, toInt(number).toInt)\n\
    \        }\n\n        toFloat(toInt(number))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjhd0liyq.scala:15:12\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m            number / java.lang.Math.pow(\e\
    [31m10\e[0m, toInt(number).toInt)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    Double\n\e[31m   |\e[0m            Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010158
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val decomp = number.toInt\n        val fraction\
    \ = number - decomp\n        val newFraction = (fraction.abs % 1) // fraction.abs\
    \ -> absolute value\n        val newDecomp = (decomp.abs + newFraction) / fraction.abs\
    \ // fraction.abs -> absolute value\n        number - (newDecomp * fraction)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi2flw5gv.scala:18)\n\tat Problem.main(tmpi2flw5gv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010159
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var whole = math.trunc(number)\n        var decimal\
    \ = math.abs(number - whole) * 10\n        if (decimal > 1) {\n            whole\
    \ += 1\n            decimal -= 10\n        }\n        (whole + decimal) / 10\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5f8td1mn.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mvar\e[0m \e[36mwhole\e[0m = math.trunc(number)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value trunc is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010159
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val number = number.toInt;\n        if (number\
    \ < 1) number;\n        else number / 10f\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8om4atbg.scala:11:21 ---------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mnumber\e[0m = number.toInt;\n\
    \e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m            \
    \         Recursive \e[33mvalue\e[0m \e[35mnumber\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010155
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val truncate = math.trunc(number)\n        val\
    \ decimals = truncate.toInt\n        (number - truncate).toFloat / (math.pow(2,\
    \ decimals))\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjwlyxdwk.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mtruncate\e[0m = math.trunc(number)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                      value trunc is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1660010159
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integer = math.ceil(number.toDouble)\n   \
    \     val fractional = number.toDouble - integer\n        fractional\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj6h3_7br.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        fractional\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (fractional\
    \ : Double)\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010159
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Use ceil instead of floor since ceil is inclusive\
    \ for positive numbers\n        // and truncate is inclusive.\n        math.ceil(number).toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphp0wvz6q.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        math.ceil(number).toString\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    String\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010159
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var decomp = number.toInt\n        var rem = 0\n\
    \        while (decomp > 0) {\n            rem = decomp % 10\n            decomp\
    \ = decomp / 10\n        }\n        rem\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbghtf4j6.scala:20)\n\tat Problem.main(tmpbghtf4j6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010160
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var integerPart : Float = 0f\n        var fractionalPart\
    \ : Float = 0f\n        var decimalPart : Float = 0f\n        var decimalRemainder\
    \ : Float = 0f\n        var decimalDigits : Int = 8\n        // Divide up the\
    \ number into the integer and fractional parts\n        while (number >= 1) {\n\
    \            fractionalPart += number\n            number = fractionalPart / 10f\n\
    \            integerPart += number\n            fractionalPart %= 10f\n      \
    \  }\n        // If the integer part is less than 10, add it to our decimal\n\
    \        // part so it will always fit in the number of decimal digits we\n  \
    \      // want (8 in this case).\n        if (integerPart < 10) {\n          \
    \  decimalPart = (10f / integerPart * fractionalPart).toFloat\n            integerPart\
    \ = 0f\n        }\n        // If the number of decimal digits to return is less\
    \ than the\n        // number of digits in the decimal part, then fill the decimal\n\
    \        // part with zeros until we get 8 digits of precision.\n        val maxDecimalDigits\
    \ = decimalDigits\n        if (decimalDigits < fractionalPart.toString.length)\
    \ maxDecimalDigits -= 1\n        var lastDecimalDigit : Int = -1\n        var\
    \ digitIndex = 0\n        while (decimalDigits > maxDecimalDigits) {\n       \
    \     decimalRemainder = fractionalPart % 10\n            lastDecimalDigit = digitIndex\n\
    \            fractionalPart /= 10\n            digitIndex += 1\n        }\n  \
    \      // Finally, divide into the decimal part and add our integer\n        //\
    \ part.\n        decimalPart = decimalPart * 10f + (fractionalPart / 10f).toFloat\n\
    \        integerPart += integerPart\n        decimalPart += decimalRemainder\n\
    \        val finalDecimalPart = decimalPart / 10f\n        val finalInteger =\
    \ integerPart\n        val finalDecimal = finalDecimalPart * 10f\n        if (finalDecimalDigits\
    \ < finalDecimal.toString.length) finalDecimalDigits -= 1\n        val finalInteger\
    \ = finalInteger.toString.padLeft(finalDecimalDigits, '0').substring(0,)\n   \
    \     val finalDecimal = finalDecimal.toString.padLeft(finalDecimalDigits, '0').substring(0,)\n\
    \        (finalDecimal, finalInteger)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpe953tm4l.scala:52:94 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mfinalInteger\e[0m = finalInteger.toString.padLeft(finalDecimalDigits,\
    \ \e[31m'0'\e[0m).substring(\e[31m0\e[0m,)\n\e[31m\e[31m   |\e[0m            \
    \                                                                            \
    \      ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpe953tm4l.scala:53:94 ---------------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m        \e[33mval\e[0m \e[36mfinalDecimal\e[0m = finalDecimal.toString.padLeft(finalDecimalDigits,\
    \ \e[31m'0'\e[0m).substring(\e[31m0\e[0m,)\n\e[31m\e[31m   |\e[0m            \
    \                                                                            \
    \      ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpe953tm4l.scala:19:19 -----------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m            number = fractionalPart / \e[31m10f\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \ Reassignment to val number\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpe953tm4l.scala:34:77 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mif\e[0m (decimalDigits < fractionalPart.toString.length) maxDecimalDigits\
    \ -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                     \
    \                       ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     value -=\
    \ is not a member of Int - did you mean maxDecimalDigits.!=?\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpe953tm4l.scala:51:12 ------------------------\e[0m\e\
    [0m\n\e[31m51 |\e[0m        \e[33mif\e[0m (finalDecimalDigits < finalDecimal.toString.length)\
    \ finalDe"
  stdout: ''
  timestamp: 1660010161
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      val integer = number.toInt\n      val fraction =\
    \ number - integer\n      (fraction.toDouble * Math.pow(10.0, floor(fraction.toInt))).toFloat\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010160
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val dec = number.toDouble\n        var sign =\
    \ if (dec < 0.0) -1 else 1\n        val frac = (dec.toInt) + 1\n        val intPart\
    \ = (dec - frac)\n        new Float(intPart * 10.0).toFloat\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpllzxgv7m.scala:15:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mnew\e[0m \e[35mFloat\e[0m(intPart * \e\
    [31m10.0\e[0m).toFloat\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m      too many arguments for \e[33mconstructor\e[0m \e[35mFloat\e\
    [0m in \e[33mclass\e[0m \e[35mFloat\e[0m: (): Float\n1 error found\n"
  stdout: ''
  timestamp: 1660010157
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = number.toInt\n        if (intPart\
    \ <= 0)\n            0.0\n        else\n            number.toFloat - number.toFloat\
    \ % intPart * intPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpls133mcd.scala:18)\n\tat Problem.main(tmpls133mcd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010160
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Find largest integer smaller than the given\
    \ number\n        def largest(n : Int) : Int = if (n > 0) largest(n - 1) else\
    \ n\n        largest(math.ceil(number)) * (number / largest(math.ceil(number)))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcqt8292f.scala:13:25\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        largest(math.ceil(number))\
    \ * (number / largest(math.ceil(number)))\n\e[31m\e[31m   |\e[0m             \
    \   ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Found:    Double\n\e\
    [31m   |\e[0m                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpcqt8292f.scala:13:64 --------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        largest(math.ceil(number)) * (number / largest(math.ceil(number)))\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Found:\
    \    Double\n\e[31m   |\e[0m                                                 \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010161
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var fraction = number.toInt\n        var remainder\
    \ = number - fraction\n        fraction = fraction.toFloat\n        if (fraction\
    \ > 1) {\n            fraction = 1\n        }\n        fraction\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1dkvunzp.scala:13:28\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        fraction = fraction.toFloat\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                   Found:    Float\n\e[31m   |\e[0m                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010161
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        require(number > 0)\n        val intPart = math.max(math.min(number,\
    \ 1), 0)\n        val decimalPart = (number - intPart).toFloat\n        decimalPart\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmekwc565.scala:17)\n\tat Problem.main(tmpmekwc565.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010161
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var fractional : Float = number % 1\n        var\
    \ integer : Float = number - fractional\n        if (integer <= 0) return fractional\n\
    \        return (integer + fractional) / 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptt4hyqvr.scala:17)\n\tat Problem.main(tmptt4hyqvr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010162
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integer = math.floor(number)\n        val\
    \ fraction = number - integer\n        if (fraction < 0.0) 0.0 else fraction\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbyi66gwx.scala:13:37\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mif\e[0m (fraction\
    \ < \e[31m0.0\e[0m) \e[31m0.0\e[0m \e[33melse\e[0m fraction\n\e[31m\e[31m   |\e\
    [0m                                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                              Found:    (fraction : Double)\n\e[31m   |\e[0m\
    \                                     Required: Float\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010164
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var floatNumber = number.toDouble\n        var\
    \ integer = scala.math.floor(floatNumber)\n        var decimals = scala.math.abs(scala.math.floor\
    \ - float)\n        return scala.math.round(floatNumber - integer) * scala.math.pow(10.0,\
    \ decimals)\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp62fbr3r7.scala:13:55 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mvar\e[0m \e[36mdecimals\e[0m = scala.math.abs(scala.math.floor\
    \ - float)\n\e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of Double => Double, but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp62fbr3r7.scala:13:57 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mvar\e[0m \e[36mdecimals\e[0m = scala.math.abs(scala.math.floor\
    \ - float)\n\e[31m\e[31m   |\e[0m                                            \
    \             ^^^^^\e[0m\n\e[31m   |\e[0m                                    \
    \                    Not found: float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp62fbr3r7.scala:14:15 --------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mreturn\e[0m scala.math.round(floatNumber - integer)\
    \ * scala.math.pow(\e[31m10.0\e[0m, decimals)\n\e[31m\e[31m   |\e[0m         \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Double\n\e[31m   |\e[0m         \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010166
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number == 0.0)\n            1.0\n        else\
    \ if (number > 0.0)\n            truncateNumber(math.floor(number) + math.min(1.0,\
    \ math.floor(number - math.floor(number))))\n        else -1.0\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf_i8shlq.scala:14:27\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m            truncateNumber(math.floor(number)\
    \ + math.min(\e[31m1.0\e[0m, math.floor(number - math.floor(number))))\n\e[31m\e\
    [31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    Double\n\e[31m   |\e\
    [0m                           Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010166
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number < 0)\n            throw new IllegalArgumentException(\"\
    Negative numbers cannot be truncated\")\n        if (number == 0)\n          \
    \  return 0f\n        val numberWithLeadingZeros = number / 10f\n        if (numberWithLeadingZeros\
    \ < number)\n            numberWithLeadingZeros + 1f\n        else\n         \
    \   number - numberWithLeadingZeros * 10f\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuwqo8xi6.scala:22)\n\tat Problem.main(tmpuwqo8xi6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010167
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = (number.toInt * 10).floor.toFloat\n\
    \        val decimalPart = (number.toInt * 10).floor.toFloat - intPart\n     \
    \   decimalPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4gfddh3r.scala:11:42 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mintPart\e[0m = (number.toInt\
    \ * \e[31m10\e[0m).floor.toFloat\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m      value floor is not a member of Int.\n\e[31m   |\e[0m\
    \      An extension method was tried, but could not be fully constructed:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m          floatWrapper(number.toInt.*(\e[31m10\e\
    [0m))\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4gfddh3r.scala:12:46 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mdecimalPart\e[0m = (number.toInt\
    \ * \e[31m10\e[0m).floor.toFloat - intPart\n\e[31m\e[31m   |\e[0m            \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value floor\
    \ is not a member of Int.\n\e[31m   |\e[0m      An extension method was tried,\
    \ but could not be fully constructed:\n\e[31m   |\e[0m\n\e[31m   |\e[0m      \
    \    floatWrapper(number.toInt.*(\e[31m10\e[0m))\n2 errors found\n"
  stdout: ''
  timestamp: 1660010163
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        number match {\n            case Float.PositiveInfinity\
    \ | Float.NegativeInfinity => number\n            case Float.PositiveInfinity\
    \   => number.toInt\n            case Float.NegativeInfinity  => number.toInt\
    \ * (-1)\n            case Float.NaN               => number\n            case\
    \ _                         => Math.floor(number * 10) / 10\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp213vwphp.scala:16:46\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mcase\e[0m _\
    \                         => Math.floor(number * \e[31m10\e[0m) / \e[31m10\e[0m\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                              Found:    Double\n\
    \e[31m   |\e[0m                                              Required: Float\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010167
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number == 0.0f)\n            0.0f\n      \
    \  else {\n            val truncated = Math.floor(number)\n            val leftOver\
    \ = number - truncated\n            if (leftOver < 1.0f) leftOver\n          \
    \  else 0.0f\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpol91q810.scala:16:33\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m (leftOver\
    \ < \e[31m1.0f\e[0m) leftOver\n\e[31m\e[31m   |\e[0m                         \
    \        ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 Found:\
    \    (leftOver : Double)\n\e[31m   |\e[0m                                 Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010166
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fractionalPart = number - math.min(number)\n\
    \        val roundedDecimalPart = math.round(fractionalPart * 1e6)\n        roundedDecimalPart\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp06ffb4wk.scala:11:43 -----------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mfractionalPart\e[0m = number\
    \ - math.min(number)\n\e[31m\e[31m   |\e[0m                                  \
    \    ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((number : Float))\n1 error found\n"
  stdout: ''
  timestamp: 1660010165
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = number.toInt\n        val decimalPart\
    \ = number.toDouble - number\n        decimalPart.toFloat\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyygsgfsj.scala:16)\n\tat Problem.main(tmpyygsgfsj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010169
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fractionalPart = (number * 10.toDouble).toInt\
    \ / 10\n        number - fractionalPart\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010167
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // if number is a whole number, return number\n\
    \        if (number == number) number\n        \n        // If number is negative,\
    \ return 0\n        if (number < 0)  0\n        \n        // If number is positive,\
    \ find largest integer less than or equal to number\n        // and return the\
    \ fractional part\n        else {\n            var maxInt : Int = 0\n        \
    \    var maxFrac : Float = 0\n            for (i <- 0 until number.toInt) {\n\
    \                val frac = (number / (float) i).toFloat\n                if (frac\
    \ > maxFrac) {\n                    maxFrac = frac\n                    maxInt\
    \ = i\n                }\n            }\n            \n            // Return truncated\
    \ value\n            maxFrac\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpnsz6izd9.scala:23:46 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mval\e[0m \e[36mfrac\e[0m = (number\
    \ / (float) i).toFloat\n\e[31m\e[31m   |\e[0m                                \
    \              ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpnsz6izd9.scala:23:38 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m                \e[33mval\e[0m \e[36mfrac\e[0m = (number / (float) i).toFloat\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                      Not found: float\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmpnsz6izd9.scala:12:30 ----------------\e\
    [0m\e[0m\n\e[33m12 |\e[0m        \e[33mif\e[0m (number == number) number\n\e[33m\e\
    [33m   |\e[0m                              ^^^^^^\e[0m\n\e[33m   |\e[0mA pure\
    \ expression does nothing in statement position; you may be omitting necessary\
    \ parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 warning found\n2 errors found\n"
  stdout: ''
  timestamp: 1660010166
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var integerPart = number / 10\n        var decimalPart\
    \ = number - integerPart * 10\n        integerPart = integerPart + (decimalPart\
    \ > 0 ? 1 : 0)\n        decimalPart\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn36tgjmw.scala:13:53 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        integerPart = integerPart + (decimalPart > \e\
    [31m0\e[0m ? \e[31m1\e[0m : \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m             \
    \                                      ^^^\e[0m\n\e[31m   |\e[0m             \
    \                             value ? is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660010168
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fraction = number.toString.split(\"\\\\.\"\
    ).map(_.toDouble)\n        if(fraction.length > 1) {\n            fraction(0)\n\
    \        } else {\n            0f\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplqvvk8m7.scala:13:20\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m            fraction(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \       Found:    Double\n\e[31m   |\e[0m            Required: Float\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fraction : Float = number.toInt\n        val\
    \ remainder : Float = (number - fraction).toInt\n        if (remainder == 0)\n\
    \            fraction\n        else\n            fraction.toFloat + remainder\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpouev45di.scala:19)\n\tat Problem.main(tmpouev45di.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var dec = number.toInt\n        while (dec >=\
    \ 1) {\n            dec -= 1\n        }\n        dec\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpftpik7k5.scala:18)\n\tat Problem.main(tmpftpik7k5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var num : Float = number\n        val remainder\
    \ = num % 1\n        if (remainder > 0.5) {\n            num = num - remainder\n\
    \        }\n        return num\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc5p31dxq.scala:19)\n\tat Problem.main(tmpc5p31dxq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // The number may be fractional, so we can't just\
    \ truncate it to an int\n        // without risking being off by a whole number.\n\
    \        val fractionalPart = number % 1\n\n        // Convert the fractional\
    \ part to int\n        val intPart = math.floor(number - fractionalPart).toFloat\n\
    \n        // If we've gone over 1.0 without rounding, we're done\n        if (intPart.toDouble\
    \ > 1.0) {\n            return number\n        } else {\n            // Otherwise\
    \ return the fractional part\n            return intPart + fractionalPart\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkrs7nre7.scala:27)\n\tat Problem.main(tmpkrs7nre7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fraction = number - Math.floor(number)\n \
    \       val whole = number - Math.floor(number)\n        (fraction + whole) /\
    \ Math.pow(10.0, fraction.signum).asInstanceOf[Float]\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpabgynjug.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        (fraction + whole) /\
    \ Math.pow(\e[31m10.0\e[0m, fraction.signum).asInstanceOf[\e[35mFloat\e[0m]\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Double\n\e[31m   |\e[0m        Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var iPart = number / 1\n        var fPart = number\
    \ % 1\n        while (fPart < 0.00000001) fPart *= 10\n        return (iPart +\
    \ fPart).toFloat\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpitci04t7.scala:17)\n\tat Problem.main(tmpitci04t7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fractionalPart = number % 1\n        val intPart\
    \ = (number - fractionalPart).truncate()\n        fractionalPart * intPart\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4lo8m1uj.scala:12:48 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mintPart\e[0m = (number -\
    \ fractionalPart).truncate()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value truncate is not a member of Float\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010170
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val fraction = number.toInt\n        val decimal\
    \ = number - fraction\n        fraction / 10f\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe7ow9296.scala:16)\n\tat Problem.main(tmpe7ow9296.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      def digits(f : Float) : List[Float] = {\n      \
    \  if (f<0) List(-1) :: digits((-f).abs) else (f/f.abs).dropWhile(_>0)\n     \
    \ }\n      val intPart = digits(number).filter(_<=1).last\n      val decimalPart\
    \ = digits(number).filter(_>=1).last\n      intPart + decimalPart\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp26byltn4.scala:12:21\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mif\e[0m (f<\e[31m0\e\
    [0m) List(-\e[31m1\e[0m) :: digits((-f).abs) \e[33melse\e[0m (f/f.abs).dropWhile(_>\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                 Found:    List[Int]\n\e[31m   |\e[0m                 Required:\
    \ Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp26byltn4.scala:12:61\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mif\e[0m (f<\e\
    [31m0\e[0m) List(-\e[31m1\e[0m) :: digits((-f).abs) \e[33melse\e[0m (f/f.abs).dropWhile(_>\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \     value dropWhile is not a member of Float\n2 errors found\n"
  stdout: ''
  timestamp: 1660010173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = math.floor(number)\n        val\
    \ decimalPart = number - intPart\n        decimalPart * 10\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmyoct6gu.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        decimalPart * \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010172
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n      val decimal = number.toInt\n      (number - decimal).toFloat\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010173
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = (math.floor(number)).ceil.toFloat\n\
    \        val decimalPart = (number - intPart).toFloat\n        intPart + decimalPart\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0ssgrewy.scala:16)\n\tat Problem.main(tmp0ssgrewy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010174
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // First find out how much decimal is left\n \
    \       var decimalPart = math.modf(number)\n        // If it is 0, there is no\
    \ decimal left\n        if(decimalPart._1 == 0) {\n            return 0f\n   \
    \     }\n        // If it is not 0, the left most digit is our answer\n      \
    \  // To get the decimal part, we need to floor our decimal part\n        var\
    \ answer = math.floor(decimalPart._1)\n        // If the answer is 0, there is\
    \ nothing to truncate\n        if(answer == 0f) {\n            return 0f\n   \
    \     }\n        // If it is 0, just return the answer\n        if(answer == 0f)\
    \ {\n            return answer\n        }\n        // Otherwise, return answer\
    \ with the right most number of decimals\n        return answer + decimalPart._1\
    \ * 10\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfob6ez6m.scala:12:31 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mvar\e[0m \e[36mdecimalPart\e[0m = math.modf(number)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          value modf is not a member of math\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpfob6ez6m.scala:26:19 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mreturn\e[0m answer\n\e[31m\e[31m  \
    \ |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:\
    \    (answer : Double)\n\e[31m   |\e[0m                   Required: Float\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010174
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val numStr = (number / 1).toString.toInt\n   \
    \     val digits = math.pow(10, numStr.toInt)\n        val fracPart = number -\
    \ math.pow(10, numStr).toFloat\n        fracPart * digits\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppj3nfkm0.scala:14:8\
    \ ---------------------\e[0m\e[0m\n\e[31m14 |\e[0m        fracPart * digits\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    Double\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010174
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val intPart = (number).toInt\n        val decimalPart\
    \ = (number - intPart).toFloat\n        decimalPart\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010174
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        var numberIntPart = number\n        var numberDecimalPart\
    \ = 0\n        if (numberIntPart < Integer.MIN_VALUE) {\n            numberIntPart\
    \ = Integer.MIN_VALUE\n        }\n        if (numberIntPart > Integer.MAX_VALUE)\
    \ {\n            numberIntPart = Integer.MAX_VALUE\n        }\n        val intPartLen\
    \ = numberIntPart.toInt\n        val decimalPartLen = numberIntPart - intPartLen\n\
    \        if (numberDecimalPart < decimalPartLen) {\n            numberDecimalPart\
    \ = decimalPartLen\n        }\n        return (number - numberIntPart).toFloat\
    \ / numberDecimalPart * BigDecimal(1.0F)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj45hdtvw.scala:22:32\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            numberDecimalPart\
    \ = decimalPartLen\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Found:    (decimalPartLen\
    \ : Float)\n\e[31m   |\e[0m                                Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpj45hdtvw.scala:24:68 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mreturn\e[0m (number - numberIntPart).toFloat\
    \ / numberDecimalPart * BigDecimal(\e[31m1.0F\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e[0m\
    \ in \e[33mclass\e[0m \e[35mFloat\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Float\n\
    \e[31m   |\e[0m (x: Int): Float\n\e[31m   |\e[0m (x: Char): Float\n\e[31m   |\e\
    [0m (x: Short): Float\n\e[31m   |\e[0m (x: Byte): Float\n\e[31m   |\e[0mmatch\
    \ arguments (BigDecimal)\n2 errors found\n"
  stdout: ''
  timestamp: 1660010175
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val negative = if (number < 0) -1 else 0\n   \
    \     val sign = if (number < 0) 1 else -1\n\n        val integralPart = number.toInt\n\
    \        val decimalPart = (number - (integral Part)) / Math.pow(10, integralPart.toInt)\n\
    \n        if (number < 1) 0\n        else decimalPart * Math.pow(10, integralPart.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp82t33oa1.scala:15:50 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mdecimalPart\e[0m = (number\
    \ - (integral Part)) / Math.pow(\e[31m10\e[0m, integralPart.toInt)\n\e[31m\e[31m\
    \   |\e[0m                                                  ^\e[0m\n\e[31m   |\e\
    [0m                                       expression expected but \e[31m')'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp82t33oa1.scala:15:37\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mdecimalPart\e[0m = (number - (integral Part)) / Math.pow(\e[31m10\e[0m, integralPart.toInt)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     Not found: integral\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010173
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        // Find out how many integer parts there will\
    \ be.\n        // Find out how many decimal parts there will be.\n        // Decompose\
    \ the number into integer and decimal parts.\n        // Round the decimal part\
    \ up to the nearest whole number\n        // Return the integer part and the decimal\
    \ part as an int.\n        (number - Math.round(number)).intValue()\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n\
    \    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9y2unyir.scala:19)\n\tat Problem.main(tmp9y2unyir.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010175
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = number.toInt\n        val decimalPart\
    \ = number - integerPart\n        (decimalPart / 10f)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0fddfs1m.scala:16)\n\tat Problem.main(tmp0fddfs1m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010175
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val remainder = math.fmod(number, 1.0)\n     \
    \   val integerPart = math.ceil(remainder)\n        val decimalPart = math.floor(remainder)\n\
    \        decimalPart\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi1dw3usl.scala:11:29 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mremainder\e[0m = math.fmod(number,\
    \ \e[31m1.0\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        value fmod is not a member of math\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi1dw3usl.scala:14:8 ---------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        decimalPart\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (decimalPart : Double)\n\e[31m   |\e[0m\
    \        Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010175
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        val integerPart = number.toInt\n        val decimalPart\
    \ = number.toDouble\n        decimalPart\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(truncateNumber((3.5f)) == (0.5f));\n    assert(truncateNumber((1.25f))\
    \ == (0.25f));\n    assert(truncateNumber((123.0f)) == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppm7ltmoh.scala:13:8\
    \ ---------------------\e[0m\e[0m\n\e[31m13 |\e[0m        decimalPart\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (decimalPart\
    \ : Double)\n\e[31m   |\e[0m        Required: Float\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010175
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        if (number < 0) {\n            throw new IllegalArgumentException(s\"\
    The given number ${number} is negative.\")\n        }\n        val integerPart\
    \ = (number >>> 1).asInstanceOf[Float]\n        val decimalPart = number - integerPart\n\
    \        if (decimalPart > 0.5) {\n            0.0f\n        } else {\n      \
    \      1.0f\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph8sswy_s.scala:14:34 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mintegerPart\e[0m = (number\
    \ >>> \e[31m1\e[0m).asInstanceOf[\e[35mFloat\e[0m]\n\e[31m\e[31m   |\e[0m    \
    \                       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \      value >>> is not a member of Float\n1 error found\n"
  stdout: ''
  timestamp: 1660010175
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive floating point number, it can be decomposed into\n\
    \    // and integer part (largest integer smaller than given number) and decimals\n\
    \    // (leftover part always smaller than 1).\n    // Return the decimal part\
    \ of the number.\n    // >>> truncateNumber((3.5f))\n    // (0.5f)\n    def truncateNumber(number\
    \ : Float) : Float = {\n        def findDecimal(number : Float) : Float = {\n\
    \            val numDec = math.ceil(math.abs(number))\n            if(number <\
    \ 1) numDec else numDec\n        }\n        val sign = if (number < 0) 1 else\
    \ -1\n        val newSign = if (number < 0) number / sign else number * sign\n\
    \        val newNumber = sign * math.floor(newSign / findDecimal(number))\n  \
    \      newNumber\n    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
    \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
    \ == (0.0f));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyg5yc6xn.scala:13:27\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m            \e[33mif\e[0m(number\
    \ < \e[31m1\e[0m) numDec \e[33melse\e[0m numDec\n\e[31m\e[31m   |\e[0m       \
    \                    ^^^^^^\e[0m\n\e[31m   |\e[0m                           Found:\
    \    (numDec : Double)\n\e[31m   |\e[0m                           Required: Float\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyg5yc6xn.scala:13:39\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m            \e[33mif\e[0m(number\
    \ < \e[31m1\e[0m) numDec \e[33melse\e[0m numDec\n\e[31m\e[31m   |\e[0m       \
    \                                ^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                       Found:    (numDec : Double)\n\e[31m   |\e[0m         \
    \                              Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpyg5yc6xn.scala:18:8 ---------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        newNumber\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (newNumber : Double)\n\e[31m   |\e[0m  \
    \      Required: Float\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010176
