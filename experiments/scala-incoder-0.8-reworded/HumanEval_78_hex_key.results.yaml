language: scala
name: HumanEval_78_hex_key
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val result = mutable.LinkedHashMap[(Int,\
    \ Int), Long]()\n        for(i <- 0 until num.length) yield {\n            val\
    \ hexDigit = num.toChar(i).toInt\n            val decimalDigit = (hexDigit - 48)\n\
    \            val binary = decimalDigit * (10l << 4)\n            val digit = decimalDigit\
    \ % 2\n            result += (\n                (binary.asInstanceOf[(Int, Int)])\
    \ -> (\n                    if (digit == 0) 1\n                    else if (digit\
    \ == 1) 3\n                    else digit\n                )\n            )\n\
    \        }\n        val maxSize = 3 \n        val maxKey = result.map(_._1).filter(_._2\
    \ > maxSize).max\n        val maxValue = result.map(_._2).max\n        result.get(maxKey).map(_._2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi6n3ieoh.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.LinkedHashMap[(\e\
    [35mInt\e[0m, \e[35mInt\e[0m), \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi6n3ieoh.scala:28:31\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m\
    \ \e[36mhexDigit\e[0m = num.toChar(i).toInt\n\e[31m\e[31m   |\e[0m           \
    \                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           value\
    \ toChar is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1660009838
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // I solved the problem with\
    \ recursion and pattern matching\n        // and I didn't use loops.\n       \
    \ val result: Long = num.toLong\n        val arr: Array[Char] = num.toCharArray\n\
    \        if (arr.length > 0) {\n            val first = arr.head\n           \
    \ val rest = arr.tail\n            // If there is a remaining array, then there\
    \ are more digits\n            if (rest.length > 0) {\n                val result1\
    \ = hexKey(rest)\n                // If the first digit is a prime number, then\
    \ the result is a prime number\n                if (first == 1 ||\n          \
    \          (first == 2 && arr.length == 2 && (rest == 2 || rest == 3) ||\n   \
    \                 (first == 3 && arr.length == 2 && (rest == 3 || rest == 5) ||\n\
    \                    (first == 4 && arr.length == 2 && (rest == 4 || rest == 7)\
    \ ||\n                    (first == 5 && arr.length == 2 && (rest == 5 || rest\
    \ == 11) ) ||\n                    (first == 6 && arr.length == 2 && (rest ==\
    \ 6 || rest == 13) ) ||\n                    (first == 7 && arr.length == 2 &&\
    \ (rest == 7 || rest == 17) ) ||\n                    (first == 8 && arr.length\
    \ == 2 && (rest == 8 || rest == 19) ) ||\n                    (first == 9 && arr.length\
    \ == 2 && (rest == 9 || rest == 29))))\n                    result += result1\n\
    \                // If there is only 1 digit left, then result is a prime number\n\
    \                else if (arr.length == 1) {\n                    result += 1\n\
    \                }\n            }\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpv1s_06tf.scala:46:37 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                    result += result1\n\e[31m\e[31m \
    \  |\e[0m                                     ^\e[0m\n\e[31m   |\e[0m        \
    \                             expression expected but \e[31melse\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv1s_06tf.scala:35:37\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m                \e[33mval\e[0m\
    \ \e[36mresult1\e[0m = hexKey(rest)\n\e[31m\e[31m   |\e[0m                   \
    \                  ^^^^\e[0m\n\e[31m   |\e[0m                                \
    \     Found:    (rest : Array[Char])\n\e[31m   |\e[0m                        \
    \             Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpv1s_06tf.scala:38:55\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m38 |\e[0m       \
    \             (first == \e[31m2\e[0m && arr.length == \e[31m2\e[0m && (rest ==\
    \ \e[31m2\e[0m || rest == \e[31m3\e[0m) ||\n\e[31m\e[31m   |\e[0m            \
    \                                           ^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \  Values of types Array[Char] and Int cannot be compared with == or !=\n\e[31m\e\
    [31m-- Error: /tmp/tmpv1s_06tf.scala:38:68 -----------------------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                    (first == \e[31m2\e[0m && arr.length\
    \ == \e[31m2\e[0m && (rest == \e[31m2\e[0m || rest == \e[31m3\e[0m) ||\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types Array[Char] and Int cannot\
    \ be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpv1s_06tf.scala:39:55\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m39 |\e[0m       \
    \             (first == \e[31m3\e[0m && arr.length == \e[31m2\e[0m && (rest ==\
    \ \e[31m3\e[0m || rest == \e[31m5\e[0m) ||\n\e[31m\e[31m   |\e[0m            \
    \                                           ^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \  Values of types Array[Char] a"
  stdout: ''
  timestamp: 1660009841
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        def pow(x:Long, y:Int) : Long\
    \ = {\n            val result = 1L\n            for(i <- 0 until y-1) result *=\
    \ x\n            result\n        }\n        val chars = num.split(\"\").toList\n\
    \        val n = chars.count { case c: Char => c.isDigit }\n        val m = chars.count\
    \ { case c: Char => c.isUpper }\n        val m = if(m < n) n else m\n        val\
    \ n = if(n < m) n else m\n        val d = chars.count { case c: Char => c.isUpper\
    \ }\n        val b = chars.count { case c: Char => c.isLower }\n        val d\
    \ = if(d < b) d else b\n        val result = pow(n*n, d)\n        result * pow(2,\
    \ d)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"\
    )) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwziskr3o.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mif\e[0m(m\
    \ < n) n \e[33melse\e[0m m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpwziskr3o.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = \e[33mif\e[0m(n < m) n \e[33melse\e\
    [0m m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwziskr3o.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36md\e[0m = \e[33mif\e[0m(d < b) d \e[33melse\e[0m b\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwziskr3o.scala:28:41 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mfor\e[0m(i <- \e[31m0\e[0m until y-\e\
    [31m1\e[0m) result *= x\n\e[31m\e[31m   |\e[0m                               \
    \   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value *= is not a member of Long\
    \ - did you mean result.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660009836
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val n = num.trim().toUpperCase\n\
    \        val digits = n.chars().filter(c => c <= 'F').count()\n        var count\
    \ = 0\n        var prime = 1\n\n        while (digits(prime) < digits(n)) {\n\
    \            prime = (prime * 3)\n        }\n        // if the first number was\
    \ prime (prime = 1) we add 0\n        if (prime == 1) {\n            count +=\
    \ 0\n        }\n        for (i <- 2 to prime-1) {\n            val isPrime = true\n\
    \            for (j -> k <- prime-i+1 until i) {\n                if (i % j ==\
    \ 0) {\n                    isPrime = false\n                    break\n     \
    \           }\n            }\n            if (isPrime) {\n                count\
    \ += i\n            }\n        }\n        count + 1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpr7f_wvs6.scala:31:15 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mwhile\e[0m (digits(prime) < digits(n))\
    \ {\n\e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \       \e[33mvalue\e[0m \e[35mdigits\e[0m does not take parameters\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpr7f_wvs6.scala:41:22 -----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                \e[33mif\e[0m (i % j == \e[31m0\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m None of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35m%\e[0m in \e[33mclass\e\
    [0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\e[31m  \
    \ |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m\
    \  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short):\
    \ Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments ((j :\
    \ Any))\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpr7f_wvs6.scala:42:28 -----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                    isPrime = \e[31mfalse\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Reassignment to val isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpr7f_wvs6.scala:43:20 ------------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m                    break\n\e[31m\e[31m   |\e[0m         \
    \           ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val a = num.toCharArray\n  \
    \      val n = a.length\n        val hex = num.toList\n        val result = 0\n\
    \        var i : Int = 0\n        while (i < n) {\n            val y = hex(i).toInt\n\
    \            val x = y() - 48\n            if (x >= 0 && x <= 9) {\n         \
    \       result = result + (x * 10)\n            }\n            i += 1\n      \
    \  }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpv6mcluur.scala:33:20 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36mx\e[0m = y() - \e[31m48\e\
    [0m\n\e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m        \
    \            \e[33mvalue\e[0m \e[35my\e[0m does not take parameters\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpv6mcluur.scala:35:23 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                result = result + (x * \e[31m10\e[0m)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                Reassignment to val result\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hex = num.toLowerCase.replaceAll(\"\
    \\\"\", \"\").toUpperCase\n        if (hex.length == 6){\n            val digits\
    \ = hex.split(\"\").map(_.toInt)\n            var prime = 1\n            val l\
    \ = digits.length\n            val counter = mutable.Buffer[Int]()\n         \
    \   var j = 0\n            while (j < l){\n                val p = digits(j) *\
    \ digits(j + 1)\n                counter.append(p)\n                if (p != 1\
    \ && p != prime){\n                    prime = p\n                }\n        \
    \        j += 1\n            }\n            val counters = counter.distinct\n\
    \            counters.toList.map(_.toLong).sum\n        }\n        else{\n   \
    \         0\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpowlh2x0l.scala:31:26 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36mcounter\e[0m = mutable.Buffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009834
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var result : Long = 0\n    \
    \    var isPrime : Boolean = false\n        var hexDigit : Int = 0\n        var\
    \ isHexDigit : Boolean = false\n        var isPrimeDigit : Boolean = false\n \
    \       for(i <- 0 until num.length){\n            hexDigit = num(i).toInt\n \
    \           hexDigit = hexDigit match {\n                case x if x >= 'A' &&\
    \ x <= 'F' => {\n                    isHexDigit = true\n                    hexDigit\
    \ - 'A' + 1\n                }\n                case x if x >= '0' && x <= '9'\
    \ => {\n                    isHexDigit = true\n                    hexDigit -\
    \ '0' + 1\n                }\n                case _ => throw new Exception(\"\
    Invalid hexadecimal number string: \" + num)\n            }\n            if(isHexDigit)\
    \ {\n                isPrimeDigit = true\n                isPrime = isPrime ||\
    \ (hexDigit == 2)\n                isPrime = isPrime || (hexDigit == 3)\n    \
    \            isPrime = isPrime || (hexDigit == 5)\n                isPrime = isPrime\
    \ || (hexDigit == 7)\n                isPrime = isPrime || (hexDigit == 11)\n\
    \                isPrime = isPrime || (hexDigit == 13)\n                isPrime\
    \ = isPrime || (hexDigit == 17)\n                isPrime = isPrime || (hexDigit\
    \ == 19)\n                isPrime = isPrime || (hexDigit == 23)\n            \
    \    isPrime = isPrime || (hexDigit == 29)\n                isPrime = isPrime\
    \ || (hexDigit == 31)\n                isPrime = isPrime || (hexDigit == 37)\n\
    \                isPrime = isPrime || (hexDigit == 43)\n                isPrime\
    \ = isPrime || (hexDigit == 59)\n                isPrime = isPrime || (hexDigit\
    \ == 67)\n                isPrime = isPrime || (hexDigit == 73)\n            \
    \    isPrime = isPrime || (hexDigit == 79)\n                isPrime = isPrime\
    \ || (hexDigit == 83)\n                isPrime = isPrime || (hexDigit == 89)\n\
    \                isPrime = isPrime || (hexDigit == 97)\n            }\n      \
    \      if(!isPrimeDigit) result += hexDigit\n        }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8n5mqrpv.scala:72)\n\tat Problem.main(tmp8n5mqrpv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val nums = num.toList.flatMap(_.toDigit)\n\
    \        val key = (2 to nums.length).foldLeft(1l)(\n            (x: Long, i)\
    \ => \n                if (num(i) == 0) \n                    1l \n          \
    \      else if (nums(i) >= 0 && nums(i) < 10) {\n                    x + (10 **\
    \ i)\n                } else if (nums(i) == 10) {\n                    x + (5\
    \ ** i)\n                } else if (nums(i) == 13) {\n                    x +\
    \ (7 ** i)\n                } else if (nums(i) == 11) {\n                    x\
    \ + (11 ** i)\n                } else if (nums(i) == 17) {\n                 \
    \   x + (13 ** i)\n                } else if (nums(i) == 19) {\n             \
    \       x + (17 ** i)\n                } else 1l\n        )\n        key\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpidb57fxk.scala:26:40 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = num.toList.flatMap(_.toDigit)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                   value toDigit is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpidb57fxk.scala:31:33\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                \e[33melse\e\
    [0m \e[33mif\e[0m (nums(i) >= \e[31m0\e[0m && nums(i) < \e[31m10\e[0m) {\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \   value >= is not a member of Nothing - did you mean Nothing.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpidb57fxk.scala:32:28 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    x + (\e[31m10\e[0m ** i)\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^\e[0m\n\e[31m   |\e[0m            \
    \             value ** is not a member of Int\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpidb57fxk.scala:34:27 ------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m                    x + (\e[31m5\e[0m ** i)\n\e[31m\e[31m   |\e[0m   \
    \                      ^^^^\e[0m\n\e[31m   |\e[0m                         value\
    \ ** is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpidb57fxk.scala:36:27\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                    x + (\e\
    [31m7\e[0m ** i)\n\e[31m\e[31m   |\e[0m                         ^^^^\e[0m\n\e\
    [31m   |\e[0m                         value ** is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpidb57fxk.scala:38:28 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                    x + (\e[31m11\e[0m ** i)\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^\e[0m\n\e[31m   |\e[0m            \
    \             value ** is not a member of Int\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpidb57fxk.scala:40:28 ------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m                    x + (\e[31m13\e[0m ** i)\n\e[31m\e[31m   |\e[0m  \
    \                       ^^^^^\e[0m\n\e[31m   |\e[0m                         value\
    \ ** i"
  stdout: ''
  timestamp: 1660009838
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // 1. Split num in digits and\
    \ chars and transform the chars in int\n        val (digits, chars) = num.toInt\
    \ split \"\"\n        \n        // 2. Make an immutable set of primes\n      \
    \  val primes = scala.collection.mutable.Set[Int]() ++= List(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97)\n\
    \        val primesIterator = primes.iterator\n        val primes = primesIterator.mkString\n\
    \        \n        // 3. Make an immutable list of all digits\n        val digits\
    \ = scala.collection.mutable.ListBuffer[Int]()\n        for(i <- 0 to digits.length\
    \ - 1)\n            digits += digits(i)\n\n        // 4. Count the number of prime\
    \ digits in digits that are not divisible by primes.\n        val (count, primes)\
    \ = (digits.length - primes.splitAt(digits.length).length, primes)\n        \n\
    \        // 5. Return the count of digits not divisible by primes\n        digits.count(x\
    \ => !primesIterator.contains(x) && !primes.contains(x / primesIterator.length).toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_k_g7u_1.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = primesIterator.mkString\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mprimes is already defined as \e[33mvalue\e[0m \e[35mprimes\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_k_g7u_1.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = scala.collection.mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdigits is already defined as \e[33mvalue\e[0m \e[35mdigits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_k_g7u_1.scala:40:20 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m (count, primes) = (digits.length - primes.splitAt(digits.length).length,\
    \ primes)\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e\
    [0mprimes is already defined as \e[33mvalue\e[0m \e[35mprimes\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_k_g7u_1.scala:27:40\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m (digits,\
    \ chars) = num.toInt split \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m            \
    \                  ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \         value split is not a member of Int\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp_k_g7u_1.scala:27:13 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m (digits, chars) = num.toInt split \e[31m\"\"\e\
    [0m\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e[0m             Recursive\
    \ \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when com"
  stdout: ''
  timestamp: 1660009837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexs = hexDigits(num)\n\
    \        val count = new mutable.HashMap[String, Long]\n        hexs.foreach {\
    \ hexNum =>\n            val key = hexNum.toString\n            if (count.contains(key))\
    \ {\n                count(key) = count(key) + 1\n            } else {\n     \
    \           count.put(key, 1)\n            }\n        }\n        count.values.toArray.max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgtxuxj0i.scala:26:19 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mhexs\e[0m = hexDigits(num)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \             Not found: hexDigits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpgtxuxj0i.scala:27:24 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m        \e[33mval\e[0m \e[36mcount\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n      val key = scala.collection.mutable.ListBuffer[Long]()\n\
    \      for (hex <- num.toCharArray) {\n        val value = scala.math.pow(hex,\
    \ num.length)\n        // If the value is less than two, then that is not a prime,\
    \ otherwise\n        // it is.\n        if (value <= 2) key += value\n      }\n\
    \      key.sum\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv915b96y.scala:31:31\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mif\e[0m (value\
    \ <= \e[31m2\e[0m) key += value\n\e[31m\e[31m   |\e[0m                       \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                               Found:    (value\
    \ : Double)\n\e[31m   |\e[0m                               Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        //Complete the function here\n\
    \        val n = num.toInt\n        val a = 1\n        val b = n\n        val\
    \ nPrime = 0\n        var nDivisor = 0\n        var nDivisorTemp = 0\n       \
    \ var nFactor = 0\n        while(a <= b){\n            nDivisorTemp = nDivisor\n\
    \            nDivisor = n%a\n            nFactor = a\n            while (nDivisor\
    \ != 0){\n                nDivisorTemp = nDivisorTemp*nFactor\n              \
    \  nDivisor = nDivisor/a\n                nFactor = a\n            }\n       \
    \     if (nDivisorTemp == 0){\n                nPrime = nPrime+1\n           \
    \ }\n            a = nFactor+1\n        }\n        nPrime\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpwjwh2t4l.scala:44:23 -----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                nPrime = nPrime+\e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \       Reassignment to val nPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpwjwh2t4l.scala:46:14 -----------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m            a = nFactor+\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val a\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexaNumberList = num.split(\"\
    (?<=\\\\d)(?=[A-F])\").map(_.toInt)\n        var count = 1\n        var primes\
    \ = mutable.Set[Long]()\n        hexaNumberList.foreach{x => primes += x }\n \
    \       var primeCheck = primes.toList\n        primes.clear()\n        var hexaCheck\
    \ = hexaNumberList\n        var remainder = 0\n        while (primeCheck.length\
    \ > 0){\n            primeCheck = primeCheck.filter(_%primeCheck.head == 0)\n\
    \            hexaCheck = hexaCheck.filter(_%hexaCheck.head == 0)\n           \
    \ count += 1\n        }\n        remainder = hexaCheck.sum % hexaCheck.length\n\
    \        if (remainder == 0) {\n            count\n        } else {\n        \
    \    count\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsvux4ae3.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m \e[36mprimes\e[0m = mutable.Set[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009835
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexNum = num.toUpperCase\
    \ // \"1077E\", \"ABED1A33\", \"123456789ABCDEF0\"\n        var count : Long =\
    \ 0\n        hexNum.map(c => if (c == 'A' || c == 'B' || c == 'C' || c == 'D'\
    \ || c == 'E' || c == 'F') count += 1\n        else count += 0)\n        return\
    \ count\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"\
    )) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwgevu5nv.scala:33)\n\tat Problem.main(tmpwgevu5nv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n       val digits = (num match {\n \
    \           case \"\" => Seq()\n            case x => x.toString.toList\n    \
    \    })\n       val primes = (digits collect {\n            case x if x.isPrime\
    \ => x\n        })\n       primes.distinct.size\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1que_de_.scala:31:24 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m x.isPrime\
    \ => x\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value isPrime is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1660009837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n      val counts = mutable.Map.empty[String,\
    \ Long]\n      val digits = num.toCharArray.takeRight(6)\n      val digitMap =\
    \ digitToInt(digits)\n      digits foreach { digit =>\n        val prime = digitToPrime(digit)\n\
    \        counts.get(prime.toString) match {\n          case Some(count) => count\
    \ += digitMap.get(digit)\n          case None =>\n            counts += digit\
    \ -> digitMap.get(digit)\n        }\n      }\n      counts.values.sum\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbg62gsmq.scala:26:19 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m      \e[33mval\e[0m \e[36mcounts\e[0m = mutable.Map.empty[\e\
    [35mString\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpbg62gsmq.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m      \e[33mval\e[0m \e[36mdigitMap\e[0m = digitToInt(digits)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                  Not found: digitToInt\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpbg62gsmq.scala:30:20 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mprime\e[0m = digitToPrime(digit)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  Not found: digitToPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpbg62gsmq.scala:32:30 ------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m          \e[33mcase\e[0m Some(count) => count += digitMap.get(digit)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Not found: count\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // TODO: Implement this method.\n\
    \        // You should use String and Char primitives to do so.\n        \n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp50_3mvq8.scala:25:38\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mhexKey\e\
    [0m(\e[36mnum\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m  \
    \ |\e[0m                                      ^\e[0m\n\e[31m   |\e[0m        \
    \                              Found:    Unit\n\e[31m   |\e[0m               \
    \                       Required: Long\n\e[31m26 |\e[0m        \e[34m// TODO:\
    \ Implement this method.\e[0m\n\e[31m27 |\e[0m        \e[34m// You should use\
    \ String and Char primitives to do so.\e[0m\n\e[31m28 |\e[0m        \n\e[31m29\
    \ |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        def factorize(v : Int) : List[Int]\
    \ = if (v < 2) {\n            List[Int](v)\n        } else {\n            v ::\
    \ factorize(v / 2)\n        }\n        val n = num.toLong\n        val hexa =\
    \ n.toString.toUpperCase \n        val primes = factorize(hexa.length.toInt)\n\
    \        primes.foldLeft((1l,0l)) { case ((l,cnt),(p,m)) =>\n            if (p%2\
    \ != 0 && primes.contains(p)) {\n                val c = primes.indexOf(p)\n \
    \               if (c < primes.length - 1) {\n                    (l + cnt,c)\n\
    \                } else {\n                    (l + cnt,primes.indexOf(p)+2)\n\
    \                }\n            } else {\n                (l,cnt)\n          \
    \  }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp70hnp957.scala:35:17 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mif\e[0m (p%\e[31m2\e[0m != \e[31m0\e\
    [0m && primes.contains(p)) {\n\e[31m\e[31m   |\e[0m                ^^\e[0m\n\e\
    [31m   |\e[0mvalue % is not a member of Any, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val keys = num.split(\"\").toList\n\
    \        var count : Long = 0\n        for (key <- keys) {\n            val keyStr\
    \ = key.toInt\n            for (d <- keyStr) {\n                if (checkPrime(d,\
    \ keyStr)) {\n                    count += 1\n                }\n            }\n\
    \        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv5z9qywn.scala:30:22 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mfor\e[0m (d <- keyStr) {\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \        value foreach is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660009837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n       val hexDigitsCount = num.length.toLong\n\
    \       val countMap = Map[String, Long]()\n       var count = 0L\n       for\
    \ (i <- 0 until hexDigitsCount) {\n           if (num(i).isDigit()) {\n      \
    \       count += (10L * hexDigitsCount - i).toLong\n             val key = num(i).toString\n\
    \             val countValue = countMap(key)\n             if (countValue > 0)\
    \ {\n                countValue -= 1\n             }\n             countMap(key)\
    \ = countValue\n             }\n           }\n       for (key <- countMap) {\n\
    \          count += 1L\n       }\n       count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp390idrso.scala:29:25\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \e[33mfor\e[0m (i <- \e\
    [31m0\e[0m until hexDigitsCount) {\n\e[31m\e[31m   |\e[0m                    \
    \     ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         Found:    (hexDigitsCount\
    \ : Long)\n\e[31m   |\e[0m                         Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E050] Type Error: /tmp/tmp390idrso.scala:30:22 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m           \e[33mif\e[0m (num(i).isDigit()) {\n\e[31m\e\
    [31m   |\e[0m               ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  \e[33mmethod\e[0m \e[35misDigit\e[0m in \e[33mclass\e[0m \e[35mRichChar\e[0m\
    \ does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp390idrso.scala:35:27 ------------------------\e[0m\e[0m\n\e[31m35 |\e\
    [0m                countValue -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m         \
    \       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          value -= is not a member\
    \ of Long - did you mean countValue.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660009837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        def hexDigit(hex : String) :\
    \ String = {\n            val res = hex.charAt(0).toUpperCase + hex.substring(1).replaceAll(\"\
    \\\\W\", \"\").toLowerCase\n            if(res.length != hex.length) throw new\
    \ IllegalArgumentException(\"Cannot process invalid hexadecimal number: \" + hex)\n\
    \            else res\n        }\n        def checkPrime(n : Long) : Boolean =\
    \ {\n            var isPrime = false\n            for((i <- 1 to n / 2) if(!isPrime\
    \ && (n % i == 0))) {\n                isPrime = true\n            }\n       \
    \     isPrime\n        }\n        def isPrime(n : Long) : Boolean = {\n      \
    \      var isPrime = false\n            for((i <- 1 to n / 2) if(!isPrime && (n\
    \ % i == 0))) {\n                isPrime = true\n            }\n            isPrime\n\
    \        }\n        val numStr = hexDigit(num)\n        val numArray = numStr.chars.toList.toArray\n\
    \        val isPrime = numArray.length == numStr.length && checkPrime(Integer.parseInt(numArray.toString))\n\
    \        if(numStr.length == 1 || isPrime) 1l else 2l\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp42tdvevp.scala:33:19 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mfor\e[0m((i <- \e[31m1\e[0m to n /\
    \ \e[31m2\e[0m) \e[33mif\e[0m(!isPrime && (n % i == \e[31m0\e[0m))) {\n\e[31m\e\
    [31m   |\e[0m                   ^^\e[0m\n\e[31m   |\e[0m                   ')'\
    \ expected, but '<-' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp42tdvevp.scala:33:34\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mfor\e\
    [0m((i <- \e[31m1\e[0m to n / \e[31m2\e[0m) \e[33mif\e[0m(!isPrime && (n % i ==\
    \ \e[31m0\e[0m))) {\n\e[31m\e[31m   |\e[0m                                  ^^\e\
    [0m\n\e[31m   |\e[0m                                  '<-' expected, but 'if'\
    \ found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp42tdvevp.scala:40:19 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mfor\e[0m((i <- \e[31m1\e[0m to n /\
    \ \e[31m2\e[0m) \e[33mif\e[0m(!isPrime && (n % i == \e[31m0\e[0m))) {\n\e[31m\e\
    [31m   |\e[0m                   ^^\e[0m\n\e[31m   |\e[0m                   ')'\
    \ expected, but '<-' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp42tdvevp.scala:40:34\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m            \e[33mfor\e\
    [0m((i <- \e[31m1\e[0m to n / \e[31m2\e[0m) \e[33mif\e[0m(!isPrime && (n % i ==\
    \ \e[31m0\e[0m))) {\n\e[31m\e[31m   |\e[0m                                  ^^\e\
    [0m\n\e[31m   |\e[0m                                  '<-' expected, but 'if'\
    \ found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp42tdvevp.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36misPrime\e[0m = numArray.length\
    \ == numStr.length && checkPrime(Integer.parseInt(numArray.toString))\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misPrime is already defined as \e[33mmethod\e[0m \e[35misPrime\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp42tdvevp.scala:27:36 ------------------------\e[0m\e[0m\n\
    \e[31m27 |\e[0m    "
  stdout: ''
  timestamp: 1660009839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\").toList\n\
    \        val res = new mutable.HashMap[Int, Int]()\n        for (i<- 0 until nums.length)\
    \ {\n            if (res.contains(nums(i)) {\n                res.update(nums(i),\
    \ res.get(nums(i)) + 1)\n            } else {\n                res.update(nums(i),\
    \ 1)\n            }\n        }\n        val res2 = res.filter(_._2 > 1).map {\
    \ case (k, v) => (k, v / 2) }\n        res2.map { case (k, v) => (k, v * 2) }.reduce(_\
    \ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"\
    )) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprbbdfida.scala:31:14 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            } \e[33melse\e[0m {\n\e[31m\e[31m   |\e[0m\
    \              ^^^^\e[0m\n\e[31m   |\e[0m              ')' expected, but 'else'\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprbbdfida.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmprbbdfida.scala:34:8\
    \ -----------------\e[0m\e[0m\n\e[33m33 |\e[0m            }\n\e[33m34 |\e[0m \
    \       }\n\e[33m\e[33m   |\e[0m             ^\e[0m\n\e[33m   |\e[0mA pure expression\
    \ does nothing in statement position; you may be omitting necessary parentheses\n\
    \e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 warning found\n2 errors found\n"
  stdout: ''
  timestamp: 1660009834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // write your code here\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaugfex5e.scala:25:38\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mhexKey\e\
    [0m(\e[36mnum\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m  \
    \ |\e[0m                                      ^\e[0m\n\e[31m   |\e[0m        \
    \                              Found:    Unit\n\e[31m   |\e[0m               \
    \                       Required: Long\n\e[31m26 |\e[0m        \e[34m// write\
    \ your code here\e[0m\n\e[31m27 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009836
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var numOfDigits = 0\n      \
    \  var key = 1 // 1 = 2\n        for (x <- num) {\n            if (x != ('A' |\
    \ 'B' | 'C' | 'D' | 'E' | 'F')) {\n                numOfDigits += x.toInt % 2\n\
    \            }\n            key = key * 3\n        }\n        if (numOfDigits\
    \ > 0)\n            return key.asInstanceOf[Long]\n        else\n            return\
    \ 0\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"))\
    \ == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdfp9ubig.scala:40)\n\tat Problem.main(tmpdfp9ubig.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var n = 0\n        var m = 1\n\
    \        var k = 0\n        val primes = Set(2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n        val digits\
    \ = num.toString.toCharArray.map(_.toInt)\n        val n = digits.length\n   \
    \     digits.foreach { i =>\n            val l = digits(i) * m\n            k\
    \ += primes.contains(l)\n            m += 1\n        }\n        (1L / k).toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4ae_bzos.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = digits.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvariable\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4ae_bzos.scala:34:14 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            k += primes.contains(l)\n\e[31m\e[31m   |\e\
    [0m            ^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val numLength = num.length\n\
    \        if (numLength == 0)\n            return 0\n        val firstDigit = num\
    \ take(1) + num.drop(1).take(1).toUpperCase + num.drop(1).drop(2).toUpperCase\
    \ + num.drop(1).drop(3).toUpperCase + num.drop(1).drop(4).toUpperCase + num.drop(1).drop(5).toUpperCase\
    \ + num.drop(1).drop(6).toUpperCase + num.drop(1).drop(7).toUpperCase + num.drop(1).drop(8).toUpperCase\
    \ + num.drop(1).drop(9).toUpperCase\n        val primes = primes\n        val\
    \ key = primes.find(num take (2).toUpperCase == firstDigit + num.drop(2).toUpperCase\
    \ + num.drop(2).toUpperCase + num.drop(3).toUpperCase + num.drop(4).toUpperCase\
    \ + num.drop(5).toUpperCase + num.drop(6).toUpperCase + num.drop(7).toUpperCase\
    \ + num.drop(8).toUpperCase + num.drop(9).toUpperCase)\n        if (key == None)\n\
    \            return 0\n        key.get.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkp_zq45p.scala:29:33\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mfirstDigit\e\
    [0m = num take(\e[31m1\e[0m) + num.drop(\e[31m1\e[0m).take(\e[31m1\e[0m).toUpperCase\
    \ + num.drop(\e[31m1\e[0m).drop(\e[31m2\e[0m).toUpperCase + num.drop(\e[31m1\e\
    [0m).drop(\e[31m3\e[0m).toUpperCase + num.drop(\e[31m1\e[0m).drop(\e[31m4\e[0m).toUpperCase\
    \ + num.drop(\e[31m1\e[0m).drop(\e[31m5\e[0m).toUpperCase + num.drop(\e[31m1\e\
    [0m).drop(\e[31m6\e[0m).toUpperCase + num.drop(\e[31m1\e[0m).drop(\e[31m7\e[0m).toUpperCase\
    \ + num.drop(\e[31m1\e[0m).drop(\e[31m8\e[0m).toUpperCase + num.drop(\e[31m1\e\
    [0m).drop(\e[31m9\e[0m).toUpperCase\n\e[31m\e[31m   |\e[0m                   \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    String\n\e[31m\
    \   |\e[0m                                 Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkp_zq45p.scala:30:21 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = primes\n\e\
    [31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m              \
    \       Recursive \e[33mvalue\e[0m \e[35mprimes\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009845
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var numList : List[Long] = num.toCharArray.toList.map(_.toLong)\n\
    \        var tempNum : int = 2\n        var primeList : List[Long] = List(2, 3,\
    \ 5)\n        var hexaList : List[Int] = List(2, 3, 5)\n        var count : Int\
    \ = 0\n        var currentNum : int = 2\n        \n        while(numList.length\
    \ > 0) {\n            currentNum = numList.head\n            numList.remove(0)\n\
    \            hexaList.lastOption.getOrElse(1)\n            if(!hexaList.contains(currentNum))\
    \ {\n                if(currentNum !% 2 == 0 && currentNum !% 3 == 0 && currentNum\
    \ !% 5 == 0) {\n                    hexaList += currentNum\n                 \
    \   count += hexaList.lastOption.getOrElse(1)\n                    hexaList.remove(hexaList.lastOption)\n\
    \                    \n                    if(hexaList == primeList) {\n     \
    \                   primeList += currentNum\n                        count +=\
    \ hexaList.lastOption.getOrElse(1)\n                        hexaList.remove(hexaList.lastOption)\n\
    \                    }\n                }\n            }\n        }\n        count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2nxf2i6l.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e[36mtempNum\e[0m : \e[35mint\e\
    [0m = \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: type int\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2nxf2i6l.scala:31:25 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m \e[36mcurrentNum\e[0m : \e[35mint\e\
    [0m = \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: type int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp2nxf2i6l.scala:35:20 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            numList.remove(\e[31m0\e[0m)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove is not\
    \ a member of List[Long] - did you mean List[Long].reduce?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp2nxf2i6l.scala:39:29 ------------------------\e[0m\e\
    [0m\n\e[31m39 |\e[0m                    hexaList += currentNum\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value += is\
    \ not a member of List[Int] - did you mean List[Int].!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp2nxf2i6l.scala:41:29 ------------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m                    hexaList.remove(hexaList.lastOption)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ remove is not a member of List[Int], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitCo"
  stdout: ''
  timestamp: 1660009849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // A prime number (or prime)\
    \ is a natural number greater than 1 that \n        // is not a product of two\
    \ smaller natural numbers. \n        // A natural number is a natural number greater\
    \ than 1, whose \n        // highest value is less than 10 and who's least significant\
    \ digit \n        // is 1.\n        val primes = mutable.ArrayBuffer(2, 3, 5,\
    \ 7, 11, 13, 17, 19)\n\n        // A prime number is prime, if it has no divisors\
    \ other than itself.\n        // For example (2) and (3) are prime, 3 is only\
    \ a divisor of 2, so \n        // prime(3) returns true. \n        def isPrime(number\
    \ : Int) : Boolean = {\n            val prime = primes.find(_ == number)\n   \
    \         prime != None\n        }\n\n        // Return count of prime numbers\
    \ from 0 to 16\n        def countPrimes(startIndex : Int) : Int = {\n        \
    \    val count = startIndex\n            val primes = mutable.ArrayBuffer(2, 3,\
    \ 5, 7, 11, 13, 17, 19)\n            var index : Int = startIndex\n          \
    \  while (primes.nonEmpty && count < 16) {\n                val prime = primes.find(_\
    \ == index)\n                if (prime != None) {\n                    primes.remove(prime)\n\
    \                    count += 1\n                }\n                index += 1\n\
    \            }\n            count\n        }\n\n        // Return count of divisors\n\
    \        def countDivisors(startIndex : Int) : Int = {\n            val count\
    \ = startIndex\n            val divisors = mutable.ArrayBuffer(2, 3, 5, 7, 11,\
    \ 13, 17, 19)\n            var index : Int = startIndex\n            var count\
    \ : Int = 0\n            while (divisors.nonEmpty && count < 16) {\n         \
    \       val divisor = divisors.find(_ % index == 0)\n                if (divisor\
    \ != None) {\n                    divisors.remove(divisor)\n                 \
    \   count += 1\n                }\n                index += 1\n            }\n\
    \            count\n        }\n\n        // Return the product of the hexadecimal\
    \ digits\n        def hexProduct(x:Int):Int = {\n            x match {\n     \
    \           case x if x % 10 == 0  => x\n                case x if x % 10 == 1\
    \ => hexProduct(x / 10) * 10 + x%10\n                case x if x % 10 == 2 =>\
    \ hexProduct(x / 10) * 10 + x%10\n                case x if x % 10 == 3 => hexProduct(x\
    \ / 10) * 10 + x%10\n                case x if x % 10 == 4 => hexProduct(x / 10)\
    \ * 10 + x%10\n                case x if x % 10 == 5 => hexProduct(x / 10) * 10\
    \ + x%10\n                case x if x % 10 == 6 => hexProduct(x / 10) * 10 + x%10\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp919yv0ot.scala:96:0 ----------------------------\e\
    [0m\e[0m\n\e[31m96 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp919yv0ot.scala:31:21\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mprimes\e[0m = mutable.ArrayBuffer(\e[31m2\e[0m, \e[31m3\e[0m, \e[31m5\e[0m,\
    \ \e[31m7\e[0m, \e[31m11\e[0m, \e[31m13\e[0m, \e[31m17\e[0m, \e[31m19\e[0m)\n\e\
    [31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp919yv0ot.scala:44:25 ------------------------\e[0m\e[0m\n\e[31m44 |\e\
    [0m            \e[33mval\e[0m \e[36mprimes\e[0m = mutable.ArrayBuffer(\e[31m2\e\
    [0m, \e[31m3\e[0m, \e[31m5\e[0m, \e[31m7\e[0m, \e[31m11\e[0m, \e[31m13\e[0m, \e\
    [31m17\e[0m, \e[31m19\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp919yv0ot.scala:50:26 ------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                    count += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ += is not a member of Int - did you mean count.!=?\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp919yv0ot.scala:62:16 ---------------------------\e[0m\e[0m\n\e\
    [31m62 |\e[0m            \e[33mvar\e[0m \e[36mcount\e[0m : \e[35mInt\e[0m = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mcount is already defined as \e[33mvalue\e[0m \e[35mcount\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp919yv0ot.scala:60:27 ------------------------\e[0m\e[0m\n\e[31m60 |\e\
    [0m            \e[33mval\e[0m \e[36mdivisors\e[0m = mutable.ArrayBuffer(\e[31m2\e\
    [0m, \e[31m3\e[0m, \e[31m5\e[0m, \e[31m7\e"
  stdout: ''
  timestamp: 1660009849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Complete the function below\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppsipfv0n.scala:25:38\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mhexKey\e\
    [0m(\e[36mnum\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m  \
    \ |\e[0m                                      ^\e[0m\n\e[31m   |\e[0m        \
    \                              Found:    Unit\n\e[31m   |\e[0m               \
    \                       Required: Long\n\e[31m26 |\e[0m        \e[34m// Complete\
    \ the function below\e[0m\n\e[31m27 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val digits = num.toCharArray.filter(x\
    \ => x >= '0' && x <= '9').toList\n        val bases = List('2', '3', '5', '7',\
    \ 'B', 'D')\n        val primes = bases.map(x => digits.length).filter(x => digits(x)\
    \ <= 3)\n        val toAdd = primes.length + 2\n        val total = (primes zip\
    \ digits).filter { case (p,c) => p*c <= toAdd }.count\n        total.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgczpxho4.scala:31:14 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        total.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of (((Int, Char)) => Boolean)\
    \ => Int, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Use a List to store the numbers\
    \ of 2 to the power of each hexadecimal digit\n        val numbers = mutable.ListBuffer.empty[Long]\n\
    \        for (i <- 0 until num.length) {\n            numbers += 2L.toLong * Integer.parseInt(num(i).toChar,\
    \ 16)\n        }\n\n        // Iterate through the numbers list and determine\
    \ if they are prime\n        var count = 0L\n        var isPrime = true\n    \
    \    for (i = 3L until num.length) { \n            if (numbers(i) == 0) {\n  \
    \              count += 1L\n                isPrime = true\n            }\n  \
    \          else {\n                count += 1L\n                isPrime = false\n\
    \                if (isPrime) {\n                    for ((j <- 3L to i); j <-\
    \ 3L to i) {\n                        if (numbers(j) > 0) {\n                \
    \            isPrime = false\n                            break\n            \
    \            }\n                    }\n                }\n            }\n    \
    \    }\n        count \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpchaghb_y.scala:35:15 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mfor\e[0m (i = \e[31m3L\e[0m until num.length)\
    \ { \n\e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m            \
    \   ')' expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpchaghb_y.scala:35:38\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mfor\e[0m\
    \ (i = \e[31m3L\e[0m until num.length) { \n\e[31m\e[31m   |\e[0m             \
    \                         ^\e[0m\n\e[31m   |\e[0m                            \
    \          '<-' expected, but '{' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpchaghb_y.scala:54:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m \
    \  |\e[0m    ^\e[0m\n\e[31m   |\e[0m    '<-' expected, but '}' found\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpchaghb_y.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mnumbers\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpchaghb_y.scala:52:9 -------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m\
    \   |\e[0mvalue foreach is not a member of Null, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversion"
  stdout: ''
  timestamp: 1660009848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val arr = num.map(_.toUpperCase).toArray\n\
    \        val arr = arr.filterNot(arr(_) == \"0\")\n        val arr = arr.filterNot(arr(_)\
    \ == \"A\")\n        val arr = arr.filterNot(arr(_) == \"B\")\n        val arr\
    \ = arr.filterNot(arr(_) == \"C\")\n        val arr = arr.filterNot(arr(_) ==\
    \ \"D\")\n        val arr = arr.filterNot(arr(_) == \"E\")\n        val arr =\
    \ arr.filterNot(arr(_) == \"F\")\n        val arr = arr.map(_.toInt)\n       \
    \ val nums = arr.toList\n        val n = nums.foldLeft(2l) { (a, v) => v == a\
    \ ? a : v * a }\n        val hexNum = n.toString.reverse\n        hexNum.foldLeft(2l)\
    \ { (a, b) => b == a ? b : a * b }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpknp6vb5t.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.filterNot(arr(_)\
    \ == \e[31m\"0\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpknp6vb5t.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.filterNot(arr(_) == \e[31m\"\
    A\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpknp6vb5t.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.filterNot(arr(_) == \e[31m\"\
    B\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpknp6vb5t.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.filterNot(arr(_) == \e[31m\"\
    C\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpknp6vb5t.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.filterNot(arr(_) == \e[31m\"\
    D\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defin"
  stdout: ''
  timestamp: 1660009848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val len = num.length()\n   \
    \     val hex = num.toList.reverse.dropWhile(_ != '0')\n        val count = hex.count(\
    \ _ isPrime)\n        ((len * 2) + count).toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppek4tmx2.scala:28:40 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mcount\e[0m = hex.count(\
    \ _ isPrime)\n\e[31m\e[31m   |\e[0m                                        ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var result : Long = 0\n    \
    \    num.toCharArray.foreach {\n            c => {\n                if (c.toUpper\
    \ == \"A\" || c.toUpper == \"B\"){\n                    result += 2\n        \
    \        }\n                else if (c.toUpper == \"C\" || c.toUpper == \"D\"\
    ){\n                    result += 3\n                }\n                else if\
    \ (c.toUpper == \"E\" || c.toUpper == \"F\"){\n                    result += 5\n\
    \                }\n                else {\n                    result += c.toInt\
    \ % 10\n                }\n            }\n        }\n        result\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp4g0dilkn.scala:29:20 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mif\e[0m (c.toUpper == \e[31m\"\
    A\"\e[0m || c.toUpper == \e[31m\"B\"\e[0m){\n\e[31m\e[31m   |\e[0m           \
    \         ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types Char and\
    \ String cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp4g0dilkn.scala:29:40\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \         \e[33mif\e[0m (c.toUpper == \e[31m\"A\"\e[0m || c.toUpper == \e[31m\"\
    B\"\e[0m){\n\e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp4g0dilkn.scala:32:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (c.toUpper\
    \ == \e[31m\"C\"\e[0m || c.toUpper == \e[31m\"D\"\e[0m){\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp4g0dilkn.scala:32:45 -----------------------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (c.toUpper ==\
    \ \e[31m\"C\"\e[0m || c.toUpper == \e[31m\"D\"\e[0m){\n\e[31m\e[31m   |\e[0m \
    \                                            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmp4g0dilkn.scala:35:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (c.toUpper\
    \ == \e[31m\"E\"\e[0m || c.toUpper == \e[31m\"F\"\e[0m){\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp4g0dilkn.scala:35:45 -----------------------------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (c.toUpper ==\
    \ \e[31m\"E\"\e[0m || c.toUpper == \e[31m\"F\"\e[0m){\n\e[31m\e[31m   |\e[0m \
    \     "
  stdout: ''
  timestamp: 1660009850
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexDigits: Array[String]\
    \ = num.toLowerCase ++ \"ABCDEF\".toLowerCase ++ \"0\".toLowerCase \n        val\
    \ hexChar: Char = 'A'\n        val hexKeys: mutable.Set[Long] = mutable.Set()\n\
    \        val n = 0\n        val prime: Long = 1\n        while (n < hexDigits.length)\
    \ {\n            val currentDigit = hexDigits(n)\n            val remainder =\
    \ hexDigits(n) rem hexChar.toLong\n            val isPrime: Boolean = (prime <=\
    \ hexDigits.length \n                && hexDigits(n).equalsIgnoreCase(hexDigits(n+1)))\n\
    \            if (!isPrime) {\n                hexKeys += (currentDigit * prime)\n\
    \                prime++\n            }\n            n++\n        }\n        if\
    \ (hexKeys.size > 1) {\n            hexKeys.size\n        } else {\n         \
    \   return 0\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmptu75zga3.scala:38:23 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                prime++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmptu75zga3.scala:40:15 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m            n++\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m  \
    \ |\e[0m               expression expected but \e[31m'}'\e[0m found\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptu75zga3.scala:26:39 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mhexDigits\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m] = num.toLowerCase ++ \e[31m\"ABCDEF\"\e[0m.toLowerCase\
    \ ++ \e[31m\"0\"\e[0m.toLowerCase \n\e[31m\e[31m   |\e[0m                    \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    String\n\e\
    [31m   |\e[0m                                       Required: \e[1m\e[32mArray\e\
    [0m\e[1m\e[32m[\e[0mString\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmptu75zga3.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhexKeys\e[0m: mutable.Set[\e\
    [35mLong\e[0m] = mutable.Set()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmptu75zga3.scala:28:41 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhexKeys\e[0m: mutable.Set[\e\
    [35mLong\e[0m] = mutable.Set()\n\e[31m\e[31m   |\e[0m                        \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \           Not found:"
  stdout: ''
  timestamp: 1660009850
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // (1) The first six digits\
    \ are the binary representation of the number.\n        // (2) The last two digits\
    \ are the last two bits.\n        // The first six digits are represented as binary\
    \ number, and each \n        // of the last two digits is represented as the sum\
    \ of two powers of \n        // two.\n        // The binary number 10 is represented\
    \ as 10 (=decimal 10).\n        // The binary representation for 10 is 10 (=decimal\
    \ 10).\n        // So, for 10, the last two bits is 10 (=decimal 10).\n      \
    \  // Then, the sum of two powers of two equals to 10 (=decimal 10).\n       \
    \ // Thus, the last two digits is 10.\n        // If any number is prime, the\
    \ last two digits will be a power of two,\n        // and all numbers with last\
    \ two digits equal to a power of two will \n        // be primes.\n        //\
    \ For each number in the range, if the last two digits is a power of \n      \
    \  // two, the number is prime. Otherwise, it is not.\n        val binaryRep =\
    \ num.substring(0, 6).map(_.toInt).map(Integer.pow(_)).toList\n        val lastTwoBits\
    \ = num.substring(6, num.length)\n        val sumTwoPowOfTwo = Integer.parseInt(lastTwoBits.substring(0,\
    \ lastTwoBits.length - 2))\n        val lastTwoDigitsPowOfTwo = Integer.parseInt(lastTwoBits.substring(lastTwoBits.length\
    \ - 2, lastTwoBits.length))\n        if (binaryRep.forall(_.isPowerOfTwo)) {\n\
    \            if (lastTwoDigitsPowOfTwo.isPowerOfTwo) {\n                return\
    \ binaryRep.count(_ == lastTwoDigitsPowOfTwo)\n            } else {\n        \
    \        return 0\n            }\n        } else {\n            return 0\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"\
    )) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvw5on372.scala:41:69 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mbinaryRep\e[0m = num.substring(\e\
    [31m0\e[0m, \e[31m6\e[0m).map(_.toInt).map(Integer.pow(_)).toList\n\e[31m\e[31m\
    \   |\e[0m                                                             ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value pow is not a member of\
    \ object Integer\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvw5on372.scala:45:31\
    \ ------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mif\e[0m (binaryRep.forall(_.isPowerOfTwo))\
    \ {\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                           value isPowerOfTwo is not a member of\
    \ Nothing\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvw5on372.scala:46:38\
    \ ------------------------\e[0m\e[0m\n\e[31m46 |\e[0m            \e[33mif\e[0m\
    \ (lastTwoDigitsPowOfTwo.isPowerOfTwo) {\n\e[31m\e[31m   |\e[0m              \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ isPowerOfTwo is not a member of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1660009849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexChars = \"0123456789ABCDEF\"\
    \n        val hexCount = num.length()\n        var numArray = Array.fill(hexCount)(0)\n\
    \        for (i <- 0 until hexCount) {\n            val hexChar = hexChars(i)\n\
    \            val hexCharVal = hexChar.charAt(i)\n            if (hexCharVal ==\
    \ 'A'){\n                numArray(i) = 1\n            }\n            else if (hexCharVal\
    \ == 'B'){\n                numArray(i) = 2\n            }\n            else if\
    \ (hexCharVal == 'C'){\n                numArray(i) = 3\n            }\n     \
    \       else if (hexCharVal == 'D'){\n                numArray(i) = 5\n      \
    \      }\n            else if (hexCharVal == 'E'){\n                numArray(i)\
    \ = 7\n            }\n            else if (hexCharVal == 'F'){\n             \
    \   numArray(i) = 11\n            }\n            else if (hexCharVal == '0'){\n\
    \                numArray(i) = 13\n            }\n        }\n        var primes\
    \ = 0\n        var maxPrime = 0\n        var maxCount = 0\n        for (i <- 0\
    \ until hexCount) {\n            val hexChar = hexChars(i)\n            val hexCharVal\
    \ = hexChar.charAt(i)\n            if (hexCharVal == 'A'){\n                numArray(i)\
    \ = 1\n            }\n            else if (hexCharVal == 'B'){\n             \
    \   numArray(i) = 2\n            }\n            else if (hexCharVal == 'C'){\n\
    \                numArray(i) = 3\n            }\n            else if (hexCharVal\
    \ == 'D'){\n                numArray(i) = 5\n            }\n            else if\
    \ (hexCharVal == 'E'){\n                numArray(i) = 7\n            }\n     \
    \       else if (hexCharVal == 'F'){\n                numArray(i) = 11\n     \
    \       }\n            else if (hexCharVal == '0'){\n                numArray(i)\
    \ = 13\n            }\n        }\n        var maxCountHex = maxCount * 16\n  \
    \      val maxPrimeHex = maxPrime * 16\n        for (i <- 0 until hexCount) {\n\
    \            val hexChar = hexChars(i)\n            val hexCharVal = hexChar.charAt(i)\n\
    \            if (numArray(i) == 2){\n                maxPrimeHex = i\n       \
    \         maxCountHex = 1\n            }\n            else if (numArray(i) ==\
    \ 3){\n                maxPrimeHex = i\n                maxCountHex = 2\n    \
    \        }\n            else if (numArray(i) == 5){\n                maxPrimeHex\
    \ = i\n                maxCountHex = 4\n            }\n            else if (numArray(i)\
    \ == 7){\n                maxPrimeHex = i\n                \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpapuohsop.scala:113:0 ---------------------------\e\
    [0m\e[0m\n\e[31m113 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpapuohsop.scala:31:37\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m\
    \ \e[36mhexCharVal\e[0m = hexChar.charAt(i)\n\e[31m\e[31m   |\e[0m           \
    \                  ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \       value charAt is not a member of Char\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpapuohsop.scala:59:37 ------------------------\e[0m\e[0m\n\e[31m59\
    \ |\e[0m            \e[33mval\e[0m \e[36mhexCharVal\e[0m = hexChar.charAt(i)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             value charAt is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpapuohsop.scala:86:37 ------------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m            \e[33mval\e[0m \e[36mhexCharVal\e[0m = hexChar.charAt(i)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             value charAt is not a member of Char\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpapuohsop.scala:88:28 -----------------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m                maxPrimeHex = i\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val maxPrimeHex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpapuohsop.scala:92:28\
    \ -----------------------------\e[0m\e[0m\n\e[31m92 |\e[0m                maxPrimeHex\
    \ = i\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Reassignment to val maxPrimeHex\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpapuohsop.scala:96:28 -----------------------------\e\
    [0m\e[0m\n\e[31m96 |\e[0m                maxPrimeHex = i\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |"
  stdout: ''
  timestamp: 1660009851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        if (num.length == 0)\n     \
    \       return 0\n        val hex = num.toUpperCase().toCharArray\n        val\
    \ digits = hex.map(c => Integer.parseInt(c.toString, 16))\n        val primes\
    \ = mutable.HashSet[Long]()\n        digits: foreach { i =>\n            if (i\
    \ % 3 == 0 || i % 5 == 0 || i % 7 == 0)\n                primes += i\n       \
    \ }\n        primes.toList.length\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E103] Syntax Error: /tmp/tmpvutk2ue3.scala:31:26 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        digits: \e[35mforeach\e[0m { i =>\n\e[31m\e[31m\
    \   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m                  \
    \        Illegal start of declaration\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E103]\
    \ Syntax Error: /tmp/tmpvutk2ue3.scala:33:16 ---------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m                primes += i\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^^^\e[0m\n\e[31m   |\e[0m                Illegal start of declaration\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvutk2ue3.scala:30:21\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mprimes\e[0m = mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvutk2ue3.scala:31:16\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        digits: \e[35mforeach\e\
    [0m { i =>\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Not found: type foreach\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val count = hexaNumToInt(num)\n\
    \        val hexaNum = hexaNumToStr(num)\n        val numMap = hexaNum.map(hexToChar)\n\
    \        numMap.count(_ == 'A')\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj7czxyc0.scala:26:20 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mcount\e[0m = hexaNumToInt(num)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  Not found: hexaNumToInt\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpj7czxyc0.scala:27:22 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mhexaNum\e[0m = hexaNumToStr(num)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      Not found: hexaNumToStr\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Your code here\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1aob79f4.scala:25:38\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mhexKey\e\
    [0m(\e[36mnum\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m  \
    \ |\e[0m                                      ^\e[0m\n\e[31m   |\e[0m        \
    \                              Found:    Unit\n\e[31m   |\e[0m               \
    \                       Required: Long\n\e[31m26 |\e[0m        \e[34m// Your code\
    \ here\e[0m\n\e[31m27 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val nums = num.toUpperCase match\
    \ {\n            case \"\" => \"\"\n            case str => str.split(\"(?<=\\\
    \\G(.{4}))\")\n        }\n        val ans = nums.length\n        val primes =\
    \ List(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97)\n\
    \        primes.foreach { x =>\n            if (nums.contains(x)) {\n        \
    \        ans += 1\n            }\n        }\n        ans * (2l - 1)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxu049e2s.scala:30:23 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mans\e[0m = nums.length\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \             value length is not a member of Object\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpxu049e2s.scala:33:21 ------------------------\e[0m\e[0m\n\
    \e[31m33 |\e[0m            \e[33mif\e[0m (nums.contains(x)) {\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ contains is not a member of Object\n2 errors found\n"
  stdout: ''
  timestamp: 1660009851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val res = num.toCharArray.filter(f\
    \ => f >= '0' && f <= '9').toList.foldLeft(0){ (acc,x) =>\n            acc +=\
    \ x.toInt\n        }\n        val len = num.length\n        val firstChar = num(0)\n\
    \        val lastChar = num(len-1)\n        if(firstChar >= '0' && firstChar <=\
    \ '9' && lastChar >= '0' && lastChar <= '9') res\n        else 0\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8p85cd8s.scala:27:16 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            acc += x.toInt\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean acc.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660009851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val input = num\n        var\
    \ count = 0\n        for (i<-0 to input.length-1) {\n            if (input(i)\
    \ != \"A\" && input(i) != \"B\" && input(i) != \"C\" && input(i) != \"D\" && input(i)\
    \ != \"E\" && input(i) != \"F\") {\n                if (input(i).isDigit) {\n\
    \                    if (input.substring(i + 1, i+2).drop(1).forall(i => i.toInt\
    \ == 2).toBoolean) {\n                        count = count + 1\n            \
    \        }\n                }\n            }\n        }\n        count.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpd0i4_6mq.scala:29:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m (input(i) != \e[31m\"A\"\e\
    [0m && input(i) != \e[31m\"B\"\e[0m && input(i) != \e[31m\"C\"\e[0m && input(i)\
    \ != \e[31m\"D\"\e[0m && input(i) != \e[31m\"E\"\e[0m && input(i) != \e[31m\"\
    F\"\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Values of types Char and String cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- Error: /tmp/tmpd0i4_6mq.scala:29:35 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m (input(i) != \e[31m\"A\"\e\
    [0m && input(i) != \e[31m\"B\"\e[0m && input(i) != \e[31m\"C\"\e[0m && input(i)\
    \ != \e[31m\"D\"\e[0m && input(i) != \e[31m\"E\"\e[0m && input(i) != \e[31m\"\
    F\"\e[0m) {\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpd0i4_6mq.scala:29:54 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m (input(i) != \e[31m\"A\"\e\
    [0m && input(i) != \e[31m\"B\"\e[0m && input(i) != \e[31m\"C\"\e[0m && input(i)\
    \ != \e[31m\"D\"\e[0m && input(i) != \e[31m\"E\"\e[0m && input(i) != \e[31m\"\
    F\"\e[0m) {\n\e[31m\e[31m   |\e[0m                                           \
    \           ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types Char\
    \ and String cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpd0i4_6mq.scala:29:73\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \     \e[33mif\e[0m (input(i) != \e[31m\"A\"\e[0m && input(i) != \e[31m\"B\"\e\
    [0m && input(i) != \e[31m\"C\"\e[0m && input(i) != \e[31m\"D\"\e[0m && input(i)\
    \ != \e[31m\"E\"\e[0m && input(i) != \e[31m\"F\"\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                                                                         ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types Char and String cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpd0i4_6mq.scala:29:92 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m (input(i) != \e[31m"
  stdout: ''
  timestamp: 1660009853
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexDigits = \"0123456789ABCDEF\"\
    \n        var count = 2L\n        var pos = 0\n        // The prime numbers are\
    \ those numbers whose first \n        // hexadecimal digit is a prime number.\n\
    \        var primes = mutable.Set[Long]()\n        // Count the number of hexadecimal\
    \ digits in the \n        // input string.\n        while(pos < num.length) {\n\
    \            // Count and skip to the next hexadecimal digit.\n            count\
    \ += hexDigits.count(hexDigits(pos))\n            pos = pos + 1\n        }\n \
    \       // Find all prime numbers up to count (inclusively) \n        // and add\
    \ them to the primes set.\n        while(count <= hexDigits.length()) {\n    \
    \        val hexDigit = hexDigits(count).toInt\n            if (hexDigit <= hexDigits.length())\
    \ {\n                val factor = hexDigits(hexDigit).toInt / hexDigits.length()\n\
    \                primes.add(hexDigits(count + factor).toLong)\n            }\n\
    \            count += 1\n        }\n        // Find the first prime number which\
    \ has only \n        // \"count\" digits.\n        val firstPrime = primes.find(_\
    \ <= count)\n        // Count primes up until the first prime number.\n      \
    \  var nextPrime = 1L\n        while(nextPrime <= firstPrime) {\n            val\
    \ prime = primes.find(_ <= nextPrime)\n            if (prime == null) {\n    \
    \            nextPrime += 1L\n            } else {\n                count = 1L\n\
    \                break\n            }\n        }\n        // The last prime number\
    \ is a prime number which \n        // has only \"count\" digits.\n        val\
    \ lastPrime = primes.find(_ > count)\n        // The number to be returned.\n\
    \        return count + (lastPrime - firstPrime) + 1L\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsb7ispnj.scala:31:21 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m \e[36mprimes\e[0m = mutable.Set[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpsb7ispnj.scala:36:18 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            count += hexDigits.count(hexDigits(pos))\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Long - did you mean Long.!=?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpsb7ispnj.scala:36:46 --------------------\e[0m\e[0m\n\
    \e[31m36 |\e[0m            count += hexDigits.count(hexDigits(pos))\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     Found:    Char\n\e[31m   |\e[0m\
    \                                     Required: Char => Boolean\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsb7ispnj.scala:42:37 --------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e[0m \e[36mhexDigit\e[0m = hexDigits(count).toInt\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                     Found:    (count : Long)\n\e[31m\
    \   |\e[0m                                     Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpsb7ispnj.scala:60:16 ------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660009852
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // your code here\n        val\
    \ hexStr =  num.toCharArray.map(x => x.toInt).toList\n        val n = hexStr.length\n\
    \        val hex = hexStr.filter(x => x%2 == 0).toList\n        val hex1 = hex.filter(x\
    \ => x != 0)\n        val hex2 = hex1.filter(x => x != 1)\n        val hex3 =\
    \ hex2.filter(x => x != 2)\n        val hex4 = hex3.filter(x => x != 3)\n    \
    \    val hex5 = hex4.filter(x => x != 4)\n        val hex6 = hex5.filter(x =>\
    \ x != 5)\n        val hex7 = hex6.filter(x => x != 6)\n        val hex8 = hex7.filter(x\
    \ => x != 7)\n        val hex9 = hex8.filter(x => x != 8)\n        val hex10 =\
    \ hex9.filter(x => x != 9)\n        val hex11 = hex10.filter(x => x != 10)\n \
    \       val hex13 = hex11.filter(x => x != 11)\n        val hex17 = hex13.filter(x\
    \ => x != 13)\n        val hexB = hex17.filter(x => x != 17)\n        val hexD\
    \ = hexB.filter(x => x != 11)\n        val hexF = hexD.filter(x => x != 13)\n\
    \        val hexDigits = hexB\n        val hexDigits2 = hexD\n        val hexDigits3\
    \ = hexF\n        val hexDigits4 = hex3\n        val hexDigits5 = hex4\n     \
    \   val hexDigits6 = hex5\n        val hexDigits7 = hex6\n        val hexDigits8\
    \ = hex7\n        val hexDigits9 = hex8\n        val hexDigits10 = hex9\n    \
    \    val hexDigits11 = hex10\n        val hexDigits13 = hex11\n        val hexDigits17\
    \ = hex13\n        val hexDigitsB = hex17\n        val hexDigitsD = hexB\n   \
    \     val hexDigitsF = hexD\n        // hexDigits = hexB, hexD, hexF\n       \
    \ // hexDigits = hexB, hexD, hexF, hex3, hex4, hex5, hex6, hex7, hex8, hex9, hex10,\
    \ hex11, hex13, hex17\n        // hexDigits = hexB, hexD, hexF, hex3, hex4, hex5,\
    \ hex6, hex7, hex8, hex9, hex10, hex11, hex13, hex17, hexB, hexD\n        // hexDigits\
    \ = hexB, hexD, hexF, hex3, hex4, hex5, hex6, hex7, hex8, hex9, hex10, hex11,\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"))\
    \ == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw4j3pyk1.scala:66:5\
    \ ---------------------\e[0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009851
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val primeDigit = num.chars().map(_\
    \ % 16).filter(_ >= 2).count() + 1\n        num.chars().map(_ % 16).filter(_ >=\
    \ 2).count() + 1\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps6t45fex.scala:30)\n\tat Problem.main(tmps6t45fex.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009853
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var count=0\n        var key=0\n\
    \        for(i <- num.toCharArray) {\n            if((i=='A')||(i=='B')||(i=='C')||(i=='D')||(i=='E')||(i=='F'))\
    \ {\n                count+=1\n                if(count>3) key+=count\n      \
    \          count=0\n            }\n            else {\n                count-=1\n\
    \            }\n        }\n        key\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo7_u5k14.scala:41)\n\tat Problem.main(tmpo7_u5k14.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var hex = num.toCharArray.toList\n\
    \        hex.foreach(c => c match {\n            case 'A' => hex.update(0, \"\
    B\")\n            case 'B' => hex.update(0, \"D\")\n            case 'C' => hex.update(0,\
    \ \"F\")\n            case 'D' => hex.update(0, \"E\")\n            case 'E' =>\
    \ hex.update(0, \"A\")\n            case 'F' => hex.update(0, \"9\")\n       \
    \     case '0' => hex.update(0, '0')\n            case _ =>\n        })\n    \
    \    hex.filter(c => c.toLong > 0).count() - hex.filter(c => c.toLong < 0).count()\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"))\
    \ == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9ezx6b1p.scala:28:28 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mcase\e[0m \e[31m'A'\e[0m => hex.update(\e\
    [31m0\e[0m, \e[31m\"B\"\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue update is not a member of List[Char] - did you mean\
    \ List[Char].updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9ezx6b1p.scala:29:28\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mcase\e\
    [0m \e[31m'B'\e[0m => hex.update(\e[31m0\e[0m, \e[31m\"D\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update\
    \ is not a member of List[Char] - did you mean List[Char].updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp9ezx6b1p.scala:30:28 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mcase\e[0m \e[31m'C'\e[0m => hex.update(\e\
    [31m0\e[0m, \e[31m\"F\"\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue update is not a member of List[Char] - did you mean\
    \ List[Char].updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9ezx6b1p.scala:31:28\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mcase\e\
    [0m \e[31m'D'\e[0m => hex.update(\e[31m0\e[0m, \e[31m\"E\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update\
    \ is not a member of List[Char] - did you mean List[Char].updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp9ezx6b1p.scala:32:28 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mcase\e[0m \e[31m'E'\e[0m => hex.update(\e\
    [31m0\e[0m, \e[31m\"A\"\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue update is not a member of List[Char] - did you mean\
    \ List[Char].updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9ezx6b1p.scala:33:28\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mcase\e\
    [0m \e[31m'F'\e[0m => hex.update(\e[31m0\e[0m, \e[31m\"9\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update\
    \ is not a member of List[Char] - did you mean List[Char].updated?\n\e[31m\e[31m--\
    \ ["
  stdout: ''
  timestamp: 1660009858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n       var count = 1\n       for (ch\
    \ <- num.toCharArray) {\n           val num = Integer.parseInt(ch, 16)\n     \
    \      count += primeFactors(num)\n       }\n       count\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphsualz2e.scala:28:38\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m           \e[33mval\e[0m \e\
    [36mnum\e[0m = Integer.parseInt(ch, \e[31m16\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                                  ^^\e[0m\n\e[31m   |\e[0m                  \
    \                    Found:    (ch : Char)\n\e[31m   |\e[0m                  \
    \                    Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmphsualz2e.scala:29:17 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m           count += primeFactors(num)\n\e[31m\e[31m   |\e\
    [0m           ^^^^^^^^\e[0m\n\e[31m   |\e[0m           value += is not a member\
    \ of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphsualz2e.scala:29:20\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m           count += primeFactors(num)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  Not found: primeFactors\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        def powersOfX() : List[Int]\
    \ = {\n            val powersOfX = List[Int](1,1)\n            for(x <- powersOfX)\
    \ yield {\n                val newX = x*x\n                if(num.charAt(newX)\
    \ != '0') powersOfX += newX\n            }\n        }\n        val digits = num.toCharArray.filter(_.isDigit).toList\n\
    \        val powers = powersOfX().reverse\n        val primes = List(2, 3, 5,\
    \ 7, 11, 13, 17)\n        val result = 0\n        for(x <- powers) result += (primes.indexOf(digits(x))\
    \ * primes.indexOf(digits(x - 1)))\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxfkshstt.scala:30:54 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mif\e[0m(num.charAt(newX) != \e\
    [31m'0'\e[0m) powersOfX += newX\n\e[31m\e[31m   |\e[0m                       \
    \                     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value += is not\
    \ a member of List[Int] - did you mean powersOfX.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpxfkshstt.scala:37:32 ------------------------\e[0m\e[0m\n\
    \e[31m37 |\e[0m        \e[33mfor\e[0m(x <- powers) result += (primes.indexOf(digits(x))\
    \ * primes.indexOf(digits(x - \e[31m1\e[0m)))\n\e[31m\e[31m   |\e[0m         \
    \                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m               value += is not\
    \ a member of Int - did you mean result.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val n = num.length\n       \
    \ val primes = scala.collection.mutable.Set[Long]()\n        var power = 0\n \
    \       for {\n            x <- 0 until n\n            pow = (n+x-1)*16\n    \
    \        if pow > n\n        } pow = (n+x-1)*16\n        pow *= 0\n        for\
    \ (i<- 0 until n-1) {\n            primes.add((pow/16).toInt)\n            pow\
    \ = pow % 16\n        }\n        primes.toList.foldLeft(0l){_ + _}\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpm0cuf393.scala:33:14 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        } pow = (n+x-\e[31m1\e[0m)*\e[31m16\e[0m\n\e\
    [31m\e[31m   |\e[0m          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          Reassignment\
    \ to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm0cuf393.scala:34:12\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        pow *= \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0mvalue *= is not\
    \ a member of (Double, Double) => Double - did you mean (Double, Double) => Double.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm0cuf393.scala:36:27 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            primes.add((pow/\e[31m16\e[0m).toInt)\n\e\
    [31m\e[31m   |\e[0m                        ^^^^\e[0m\n\e[31m   |\e[0mvalue / is\
    \ not a member of (Double, Double) => Double, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpm0cuf393.scala:37:22 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m            pow = pow % \e[31m16\e[0m\n\e[31m\e[31m   |\e\
    [0m                  ^^^^^\e[0m\n\e[31m   |\e[0mvalue % is not a member of (Double,\
    \ Double) => Double, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mThe following import might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\
    \e[31m   |\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660009859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val num = num.toUpperCase //\
    \ use toUpperCase to ensure 'A' < 'b'\n        val key = num.zipWithIndex.filter(_._1\
    \ == 2).map(_._2)\n        key.filter(_ > 0).foldLeft(1l) { (x, z) =>\n      \
    \      if (z > 0) {\n                val z2 = z\n                ((z2 * z2) +\
    \ (z2 + 1) * x) % z2\n            } else x\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcynaq2i7.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mnum\e[0m = num.toUpperCase\
    \ \e[34m// use toUpperCase to ensure 'A' < 'b'\e[0m\n\e[31m\e[31m   |\e[0m   \
    \               ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35mnum\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009853
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val l = num.length\n       \
    \ val k = l*l/2\n        var count = 0\n        for(i<-0 to k-2){\n          \
    \  val hex = num.charAt(i)\n            val deci = hex.asInstanceOf[Int]\n   \
    \         val rem = deci % 16\n            val hexa = rem + 16\n            val\
    \ deci2 = hexa.asInstanceOf[Int]\n            val rem2 = deci2 % 16\n        \
    \    val hexa2 = rem2 + 16\n            if(hexa != 0 && hexa2 != 0){\n       \
    \         if(hex.asInstanceOf[Int] == hexa){\n                    count+=1\n \
    \               }\n                if(hex.asInstanceOf[Int] == hexa2){\n     \
    \               count+=1\n                }\n            }\n        }\n      \
    \  count\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdrqmmp8u.scala:49)\n\tat Problem.main(tmpdrqmmp8u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009861
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var len = 0\n        val numbers\
    \ = num.map(x=>x.toInt)\n        for (i <- 0 until num.length) {\n           \
    \ len += i * numbers.apply(i)\n        }\n        val digits = len.toString.toInt\n\
    \        val n = digits / 16\n        val res = digits - (n * 16)\n        return\
    \ res \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"\
    )) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6qvfhht9.scala:37)\n\tat Problem.main(tmp6qvfhht9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009862
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val n = num.toCharArray.toList\n\
    \        var nums = 0\n        var i = 0\n        while(i < n.length) {\n    \
    \        if(n(i) == 'A') {\n                nums += 1\n            }\n       \
    \     if(n(i) == 'B') {\n                nums += 1\n            }\n          \
    \  if(n(i) == 'C') {\n                nums += 1\n            }\n            if(n(i)\
    \ == 'D') {\n                nums += 1\n            }\n            if(n(i) ==\
    \ 'E') {\n                nums += 1\n            }\n            if(n(i) == 'F')\
    \ {\n                nums += 1\n            }\n            i += 1\n        }\n\
    \        nums\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjtsl00gw.scala:53)\n\tat Problem.main(tmpjtsl00gw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val primeList = getPrimes(num.length)\n\
    \        var count = 0\n        for (i <- 0 until primeList.length) {\n      \
    \      var hexNum = num.toInt + primeList(i)\n            var hexKey = 0\n   \
    \         while (hexNum > 0) {\n                hexKey += hexNum % 16L\n     \
    \           hexNum /= 16L\n            }\n            if (hexKey % 2L == 1L)\n\
    \                count += primeList(i) + 1\n        }\n        count // return\
    \ number of hexadecimal digits that are primes\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7j9xlpsm.scala:26:24 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mprimeList\e[0m = getPrimes(num.length)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                       Not found: getPrimes\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Your code here\n        val\
    \ arr = num.split(\"\").toList\n        var count = 0\n        for(i <- arr.indices)\
    \ {\n            val current = arr(i)\n            val len = arr.length\n    \
    \        for(j <- 0 until len) {\n                val j = arr(j)\n           \
    \     val n = current * j\n                if(n % 10 != 0) {\n               \
    \     continue\n                }\n                if(((n * 6 + 1) > 7) && ((n\
    \ * 6 + 1) < 11)) {\n                    count = count + 1\n                }\n\
    \            }\n        }\n        count.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgozt64ix.scala:33:28 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                \e[33mval\e[0m \e[36mj\e[0m = arr(j)\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       Recursive \e[33mvalue\e[0m \e[35mj\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgozt64ix.scala:34:34\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m                \e[33mval\e[0m\
    \ \e[36mn\e[0m = current * j\n\e[31m\e[31m   |\e[0m                          \
    \        ^\e[0m\n\e[31m   |\e[0m                                  Found:    (j\
    \ : String)\n\e[31m   |\e[0m                                  Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgozt64ix.scala:35:21\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                \e[33mif\e\
    [0m(n % \e[31m10\e[0m != \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m              \
    \     ^^^\e[0m\n\e[31m   |\e[0mvalue % is not a member of String, but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe\
    \ following import might make progress towards fixing the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m\
    \   |\e[0m\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgozt64ix.scala:36:20\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                    continue\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \              Not found: continue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpgozt64ix.scala:38:34 --------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m                \e[33mif\e[0m(((n * \e[31m6\e[0m + \e[31m1\e[0m) > \e\
    [31m7\e[0m) && ((n * \e[31m6\e[0m + \e[31m1\e[0m) < \e[31m11\e[0m)) {\n\e[31m\e\
    [31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m       \
    \                           Found:    (\e[31m7\e[0m : Int)\n\e[31m  "
  stdout: ''
  timestamp: 1660009861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val primes = mutable.Set[Long]()\n\
    \        val count   = mutable.Map[Long, Long]()\n        for (i <- num.toCharArray)\
    \ {\n            val h = scala.math.BigInt(i.toInt, 16).asInstanceOf[scala.Int]\n\
    \            if (primes.contains(h)) count(h+1)\n            else primes.add(h)\n\
    \        }\n        count.toSeq.sortBy(_._2).reverse.headOption.map(_._1)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6uh96fdr.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = mutable.Set[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp6uh96fdr.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcount\e[0m   = mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmp6uh96fdr.scala:29:20 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mh\e[0m = scala.math.BigInt(i.toInt,\
    \ \e[31m16\e[0m).asInstanceOf[scala.Int]\n\e[31m\e[31m   |\e[0m              \
    \      ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mobject\e[0m \e[35mBigInt\e[0m\
    \ with types\n\e[31m   |\e[0m (x: java.math.BigInteger): BigInt\n\e[31m   |\e\
    [0m (x: String, radix: Int): BigInt\n\e[31m   |\e[0m (x: String): BigInt\n\e[31m\
    \   |\e[0m (numbits: Int, rnd: scala.util.Random): BigInt\n\e[31m   |\e[0m (bitlength:\
    \ Int, certainty: Int, rnd: scala.util.Random): BigInt\n\e[31m   |\e[0m (signum:\
    \ Int, magnitude: Array[Byte]): BigInt\n\e[31m   |\e[0m (x: Array[Byte]): BigInt\n\
    \e[31m   |\e[0m (l: Long): BigInt\n\e[31m   |\e[0m (i: Int): BigInt\n\e[31m  \
    \ |\e[0mmatch arguments ((i.toInt : => Int), (\e[31m16\e[0m : Int))\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val primes = mutable.HashSet[Long]()\n\
    \        for (nthDigit <- num.toCharArray.takeWhile(_ != '0')) {\n           \
    \ val hex = Integer.parseInt(nthDigit.toString)\n            primes += (hex to\
    \ hex)\n        }\n        if (primes.contains(\"2\") || primes.contains(\"3\"\
    ) || primes.contains(\"5\") || primes.contains(\"7\")) {\n            primes.toSet.size\
    \ + 1\n        }\n        else {\n            primes.toSet.size + 0\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptsipwg05.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = mutable.HashSet[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009858
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val str = num.toString.toUpperCase\n\
    \        val hex = str.map(x => x.toInt)\n        var count = 0\n        var prime\
    \ = 0\n        for (i <- hex) {\n            prime += i\n            if (prime\
    \ > 1) prime = 0\n            count += 1\n        }\n        count\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4aavxa1l.scala:38)\n\tat Problem.main(tmp4aavxa1l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val len = num.length\n     \
    \   val list = num.toList.map(c => c.toLong)\n        val firstNum = list.head\n\
    \        if (list.length == 1) {\n            firstNum\n        } else {\n   \
    \         var nextNum = list.tail.head\n            var count = 0\n          \
    \  val primes = new mutable.ListBuffer[Long]()\n            // Find the primes\
    \ less than 2 * firstNum\n            while (nextNum % 2 == 0) {\n           \
    \     primes += 2\n                nextNum = (nextNum / 2).toLong\n          \
    \  }\n\n            // Find the primes less than 3 * firstNum\n            while\
    \ (nextNum % 3 == 0) {\n                primes += 3\n                nextNum =\
    \ (nextNum / 3).toLong\n            }\n\n            // Find the primes less than\
    \ 5 * firstNum\n            while (nextNum % 5 == 0) {\n                primes\
    \ += 5\n                nextNum = (nextNum / 5).toLong\n            }\n\n    \
    \        // Find the primes less than 7 * firstNum\n            while (nextNum\
    \ % 7 == 0) {\n                primes += 7\n                nextNum = (nextNum\
    \ / 7).toLong\n            }\n\n            // Find the primes less than 9 * firstNum\n\
    \            while (nextNum % 9 == 0) {\n                primes += 9\n       \
    \         nextNum = (nextNum / 9).toLong\n            }\n\n            // Find\
    \ the primes less than 11 * firstNum\n            while (nextNum % 11 == 0) {\n\
    \                primes += 11\n                nextNum = (nextNum / 11).toLong\n\
    \            }\n\n            // Find the primes less than 13 * firstNum\n   \
    \         while (nextNum % 13 == 0) {\n                primes += 13\n        \
    \        nextNum = (nextNum / 13).toLong\n            }\n\n            // Find\
    \ the primes less than 17 * firstNum\n            while (nextNum % 17 == 0) {\n\
    \                primes += 17\n                nextNum = (nextNum / 17).toLong\n\
    \            }\n\n            // Find the primes less than 19 * firstNum\n   \
    \         while (nextNum % 19 == 0) {\n                primes += 19\n        \
    \        nextNum = (nextNum / 19).toLong\n            }\n\n            // Find\
    \ the primes less than 20 * firstNum\n            while (nextNum % 20 == 0) {\n\
    \                primes += 20\n                nextNum = (nextNum / 20).toLong\n\
    \            }\n\n            for (i <- primes) {\n                if (list.exists(c\
    \ => c % i == 0)) {\n                    count += 1\n                }\n     \
    \       }\n\n            firstNum * count\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcszyuxal.scala:34:29 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mprimes\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexArray = num.toCharArray.map\
    \ { ch =>\n            val b = (ch - 'A') + (ch - '0')\n            if( b > 9\
    \ ) \n                throw new IllegalArgumentException(s\"The character $ch\
    \ is not in the range 'A' to 'F'.\")\n            if( b < 10 ) \n            \
    \    b + 4\n            else \n                b\n        }\n        var count\
    \ = 0\n        hexArray.foreach { e =>\n            val isPrime = 2 until hexArray.length\
    \ filter (e == _)\n            count += isPrime.size filter (e % _ == 0)\n   \
    \     }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp16sxra7z.scala:38:18 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            count += isPrime.size filter (e % _ == \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \           value += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp16sxra7z.scala:38:34 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            count += isPrime.size filter (e % _ == \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                     value filter is not a member of Int\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        def hex(n: Int) : Int = n match\
    \ {\n            case  0 => 0\n            case  1 => 0\n            case  2 =>\
    \ 0\n            case  3 => 0\n            case  4 => 1\n            case  5 =>\
    \ 2\n            case  6 => 2\n            case  7 => 3\n            case  8 =>\
    \ 3\n            case  9 => 3\n            case 10 => 4\n            case 11 =>\
    \ 5\n            case 12 => 5\n            case 13 => 6\n            case 14 =>\
    \ 6\n            case 15 => 7\n            case 16 => 7\n            case 17 =>\
    \ 7\n            case 18 => 8\n            case 19 => 8\n            case 20 =>\
    \ 8\n            case 21 => 9\n            case 22 => 9\n            case 23 =>\
    \ 9\n            case 24 => 10\n            case 25 => 10\n            case 26\
    \ => 10\n            case 27 => 11\n            case 28 => 11\n            case\
    \ 29 => 11\n            case 30 => 12\n            case 31 => 12\n           \
    \ case 32 => 12\n            case 33 => 13\n            case 34 => 13\n      \
    \      case 35 => 13\n            case 36 => 14\n            case 37 => 14\n \
    \           case 38 => 14\n            case 39 => 15\n            case 40 => 15\n\
    \            case 41 => 15\n            case 42 => 15\n            case 43 =>\
    \ 16\n            case 44 => 16\n            case 45 => 16\n            case 46\
    \ => 16\n            case 47 => 17\n            case 48 => 17\n            case\
    \ 49 => 17\n            case 50 => 17\n            case 51 => 18\n           \
    \ case 52 => 18\n            case 53 => 18\n            case 54 => 18\n      \
    \      case 55 => 18\n            case 56 => 19\n            case 57 => 19\n \
    \           case 58 => 19\n            case 59 => 19\n            case 60 => 20\n\
    \            case 61 => 20\n            case 62 => 20\n            case 63 =>\
    \ 20\n            case 64 => 21\n            case 65 => 21\n            case 66\
    \ => 21\n            case 67 => 21\n            case 68 => 21\n            case\
    \ 69 => 21\n            case 70 => 21\n            case 71 => 21\n           \
    \ case 72 => 22\n            case 73 => 22\n            case 74 => 22\n      \
    \      case 75 => 22\n            case 76 => 22\n            case 77 => 23\n \
    \           case 78 => 23\n            case 79 => 23\n            case 80 => 23\n\
    \            case 81 => 23\n            case 82 => 23\n            case 83 =>\
    \ 24\n            case 84 => 24\n            case 85 => 24\n            case 86\
    \ => 24\n            case 87 => 25\n            case 88 => 25\n            case\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"))\
    \ == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpq7v3j5yz.scala:116:16 --------------------------\e\
    [0m\e[0m\n\e[31m116 |\e[0m            \e[33mcase\e[0m \n\e[31m\e[31m    |\e[0m\
    \                ^\e[0m\n\e[31m    |\e[0m                pattern expected\n\e\
    [31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq7v3j5yz.scala:128:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m128 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpq7v3j5yz.scala:117:4 --------------------\e[0m\e\
    [0m\n\e[31m117 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e[0m\
    \    Found:    Unit\n\e[31m    |\e[0m    Required: Int\n\e[31m    |\e[0m\n\e[31m\
    \    |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpq7v3j5yz.scala:127:1 --------------------\e\
    [0m\e[0m\n\e[31m127 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e[0m\n\e[31m    |\e[0m Found:\
    \    Unit\n\e[31m    |\e[0m Required: Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpq7v3j5yz.scala:118:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m118 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m    |\e[0m    ^\e[0m\n\
    \e[33m    |\e[0m    Line is indented too far to the left, or a `}` is missing\n\
    1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1660009863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        require(num.matches(\".*[A-Z0-9]{2}$\"\
    ), \"Input String must contain only hexadecimal characters\")\n        require(num.length\
    \ == num.length, \"Input String must be hexadecimal only\")\n        var primeNum\
    \ = 1l\n        var primeNumSet = Set[Long]()\n        var hexNum = num.charAt(0).toInt\n\
    \        hexNum match {\n            case hexNum if hexNum <= 9 => (hexNum + hexNum).asInstanceOf[Int].toLong\n\
    \            case hexNum if hexNum <= 15 => (hexNum + hexNum - 10).asInstanceOf[Int].toLong\n\
    \            case _ =>\n        }\n\n        for (d <- 0 until hexNum + 1) {\n\
    \            val divisor = (hexNum + d - hexNum).asInstanceOf[Int]\n         \
    \   if (divisor <= 1 || (hexNum - divisor).asInstanceOf[Int] <= 1) {\n       \
    \         if (primeNumSet.add(primeNum)) {\n                    primeNum += 1l\n\
    \                }\n            } else {\n                primeNum += 1l\n   \
    \             primeNumSet = primeNumSet - Set(divisor)\n            }\n      \
    \  }\n\n        primeNumSet\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpis1zh_xv.scala:45:47\
    \ --------------------\e[0m\e[0m\n\e[31m45 |\e[0m                primeNumSet =\
    \ primeNumSet - Set(divisor)\n\e[31m\e[31m   |\e[0m                          \
    \                  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \     Found:    scala.collection.mutable.Set[Int]\n\e[31m   |\e[0m           \
    \                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpis1zh_xv.scala:49:8 ---------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m        primeNumSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        Found:    (primeNumSet : scala.collection.mutable.Set[Long])\n\
    \e[31m   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var res = 1\n        val map\
    \ = new mutable.HashMap[Int, Int]\n        val digits = num.substring(1).split('').toList\n\
    \        for (i <- 0 until digits.length) {\n            map.put(digits(i).toInt,\
    \ 0)\n        }\n        for (i <- 2 until digits.length - 1) {\n            var\
    \ p = 1\n            for (j <- 0 until digits.length - i - 1) {\n            \
    \    p *= digits(j)\n            }\n            if (map.get(i) == 0) {\n     \
    \           res += 1\n                map.put(i, 1)\n            } else if (map.get(i)\
    \ > p) {\n                res += map.get(i) - p\n                map.put(i, p)\n\
    \            } else {\n                res += map.get(i)\n                map.put(i,\
    \ 0)\n            }\n        }\n        res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpkru99dem.scala:28:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = num.substring(\e\
    [31m1\e[0m).split('').toList\n\e[31m\e[31m   |\e[0m                          \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   \
    \         empty character literal\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkru99dem.scala:27:22\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mmap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val n = num.toInt\n        val\
    \ sum: Long = 0\n        // Convert n to an array of digits, i.e. hex[n] to hex[\"\
    A\", \"B\", \"C\", ... \"F\"]\n        val hex = n.toString.toCharArray.map(x\
    \ => x.toChar).mkString\n        // Use sliding window to calculate sum of digits\
    \ \n        hex.sliding(2, 2).map { \n            case Array(a,b) => a + b \n\
    \            case _ => 0 \n        }.foreach(sum +=_)\n        math.pow(10, sum.toInt)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp41meqxun.scala:32:33 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mcase\e[0m Array(a,b) => a + b \n\e\
    [31m\e[31m   |\e[0m                               ^^^\e[0m\n\e[31m   |\e[0m  \
    \    value + is not a member of T$1.\n\e[31m   |\e[0m      An extension method\
    \ was tried, but could not be fully constructed:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m          Character2char(a)\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp41meqxun.scala:34:22\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        }.foreach(sum +=_)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \       value += is not a member of Long - did you mean sum.!=?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp41meqxun.scala:35:16 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        math.pow(\e[31m10\e[0m, sum.toInt)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    Double\n\e[31m   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009865
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // TODO: add your code here\n\
    \        // write your code here\n        var count = 0\n        for (i <- 0 to\
    \ num.length-1) {\n            if (num(i) == num(i).toLowerCase()) {\n       \
    \         count += 2\n            } else {\n                count += 1\n     \
    \       }\n        }\n        count * hexToInt(num) // return hexToInt(num) if\
    \ num is hexadecimal string\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9yufhutl.scala:30:33 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m (num(i) == num(i).toLowerCase())\
    \ {\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          value toLowerCase is not a member of Char\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9yufhutl.scala:36:16 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        count * hexToInt(num) \e[34m// return hexToInt(num)\
    \ if num is hexadecimal string\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Not found: hexToInt\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var count = 0L\n        var\
    \ primes = scala.collection.mutable.Set[Long]()\n        var primesArray = scala.collection.mutable.Array[Long]()\n\
    \        // You will need to check all hexadecimal digits one by one:\n      \
    \  for ( i <- 0 until num.length ) {\n            // We use the next hexadecimal\
    \ digit as the symbol\n            var symbol = num(i).toInt\n            val\
    \ upperCase = symbol.toString.toUpper\n            if ( upperCase == \"A\" ||\
    \ upperCase == \"B\" || upperCase == \"C\" || upperCase == \"D\" || upperCase\
    \ == \"E\" || upperCase == \"F\" ) symbol.toInt\n            else {\n        \
    \        // Check if it's one of the digits that belongs to primes\n         \
    \       var checkHexDigit = true\n                for ( j <- 0 until primesArray.length\
    \ ) {\n                    if ( symbol == primesArray(j) ) {\n               \
    \         checkHexDigit = false\n                        break\n             \
    \       }\n                }\n                if ( checkHexDigit ) primes += symbol\n\
    \            }\n        }\n        // Now you have a set of primes\n        for\
    \ ( prime <- primes ) {\n            count += prime\n        }\n        count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr1tuu9j5.scala:28:51 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m \e[36mprimesArray\e[0m = scala.collection.mutable.Array[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue Array is not a member of scala.collection.mutable -\
    \ did you mean mutable.ArraySeq?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr1tuu9j5.scala:33:44\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m\
    \ \e[36mupperCase\e[0m = symbol.toString.toUpper\n\e[31m\e[31m   |\e[0m      \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                   value toUpper is not a member of String\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpr1tuu9j5.scala:41:24 ------------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m                        break\n\e[31m\e[31m   |\e[0m     \
    \                   ^^^^^\e[0m\n\e[31m   |\e[0m                        Not found:\
    \ break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009865
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Your code here\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1aob79f4.scala:25:38\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mhexKey\e\
    [0m(\e[36mnum\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m  \
    \ |\e[0m                                      ^\e[0m\n\e[31m   |\e[0m        \
    \                              Found:    Unit\n\e[31m   |\e[0m               \
    \                       Required: Long\n\e[31m26 |\e[0m        \e[34m// Your code\
    \ here\e[0m\n\e[31m27 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val a = num.toUpperCase + \"\
    ABCDEF\"\n        // We are going to create a mutable list of digits from the\
    \ given string.\n        val digits = mutable.Buffer.empty[Char]\n        // The\
    \ final result will be a sum of the primes that we find.\n        var sum = 0\n\
    \        // We iterate over the string and add the digits from the buffer to the\
    \ mutable list.\n        for ((i, x) <- num.lengths.map(x => a index (x minBound)).zip(num))\
    \ {\n            digits ++= x.toCharArray\n        }\n        // Iterate over\
    \ the digits list and count the primes that are contained in the list.\n     \
    \   digits foreach { c =>\n            if (a.contains (c)) sum += a.indexOf(c).toLong\n\
    \        }\n        sum\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpljl6qtzm.scala:32:63 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mfor\e[0m ((i, x) <- num.lengths.map(\e\
    [36mx\e[0m => a index (x minBound)).zip(num)) {\n\e[31m\e[31m   |\e[0m       \
    \                                                        ^\e[0m\n\e[31m   |\e\
    [0m                                       expression expected but \e[31m')'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpljl6qtzm.scala:28:21\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mdigits\e[0m = mutable.Buffer.empty[\e[35mChar\e[0m]\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpljl6qtzm.scala:32:27\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mfor\e[0m ((i,\
    \ x) <- num.lengths.map(\e[36mx\e[0m => a index (x minBound)).zip(num)) {\n\e\
    [31m\e[31m   |\e[0m                       ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \    value lengths is not a member of String - did you mean num.length?\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009865
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexa = num.split(\"\\\\\"\
    )\n        var count = 0\n        for(i <- 0 to hexa.size - 1){\n            if(hexa(i).matches(\"\
    \"\"\\d.\"\"\")){\n                count = count + 1\n            }\n        }\n\
    \        hexa.size\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.regex.PatternSyntaxException: Unexpected internal error near\
    \ index 1\n\\\n\tat java.base/java.util.regex.Pattern.error(Pattern.java:2028)\n\
    \tat java.base/java.util.regex.Pattern.compile(Pattern.java:1789)\n\tat java.base/java.util.regex.Pattern.<init>(Pattern.java:1430)\n\
    \tat java.base/java.util.regex.Pattern.compile(Pattern.java:1069)\n\tat java.base/java.lang.String.split(String.java:3153)\n\
    \tat java.base/java.lang.String.split(String.java:3199)\n\tat Problem$.hexKey(tmp94qucb4h.scala:26)\n\
    \tat Problem$.main(tmp94qucb4h.scala:36)\n\tat Problem.main(tmp94qucb4h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // your solution\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplm6xh6n5.scala:25:38\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mhexKey\e\
    [0m(\e[36mnum\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m  \
    \ |\e[0m                                      ^\e[0m\n\e[31m   |\e[0m        \
    \                              Found:    Unit\n\e[31m   |\e[0m               \
    \                       Required: Long\n\e[31m26 |\e[0m        \e[34m// your solution\e\
    [0m\n\e[31m27 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val nList = num.toUpperCase\
    \ match {\n            case \"A\"..\"F\" => \n                val n1 = hex2Int(num.substring(0,\
    \ 1)) \n                val n2 = hex2Int(num.substring(1, 2))\n              \
    \  n1 :: n2\n            case \"0\"..\"9\" => \n                val n1 = hex2Int(num.substring(0,\
    \ 1)) \n                val n2 = hex2Int(num.substring(1, 2))\n              \
    \  n1 :: n2\n            case _ => 0\n        }\n        nList.count(x => x ==\
    \ 2)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"\
    )) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpy8sfbmqd.scala:27:20 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mcase\e[0m \e[31m\"A\"\e[0m..\e[31m\"\
    F\"\e[0m => \n\e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m\
    \                    '=>' expected, but '.' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpy8sfbmqd.scala:31:20 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m            \e[33mcase\e[0m \e[31m\"0\"\e[0m..\e[31m\"9\"\e[0m =>\
    \ \n\e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m         \
    \           '=>' expected, but '.' found\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpy8sfbmqd.scala:37:14 ------------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m        nList.count(\e[36mx\e[0m => x == \e[31m2\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value count is not a member\
    \ of AnyVal\n3 errors found\n"
  stdout: ''
  timestamp: 1660009868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val num = num.toLowerCase\n\
    \        var digits = num.count(\"a\").map(_.toInt)\n        val p = Array(2,\
    \ 3, 5, 7, 11, 13, 17, 19)\n        val i = p.toStream\n        val primes = Seq(2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157,\
    \ 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241,\
    \ 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347,\
    \ 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439,\
    \ 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,\
    \ 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\
    \ 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751,\
    \ 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,\
    \ 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\
    \ 983, 991, 997)\n        primes foreach(x => digits.filterNot(_==x).foreach(y\
    \ => digits.remove(y)))\n        p.zipWithIndex.filter(_._2 % p.sum == 0).flatMap(x\
    \ => (digits.filter(_==x._).map(x._), x._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0ohkt35w.scala:32:82 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        p.zipWithIndex.filter(_._2 % p.sum == \e[31m0\e\
    [0m).flatMap(\e[36mx\e[0m => (digits.filter(_==x._).map(x._), x._2))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   an\
    \ identifier expected, but '_' found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmp0ohkt35w.scala:32:91 ---------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m        p.zipWithIndex.filter(_._2 % p.sum == \e[31m0\e[0m).flatMap(\e\
    [36mx\e[0m => (digits.filter(_==x._).map(x._), x._2))\n\e[31m\e[31m   |\e[0m \
    \                                                                            \
    \              ^\e[0m\n\e[31m   |\e[0m                                   an identifier\
    \ expected, but '_' found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp0ohkt35w.scala:26:18 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mnum\e[0m = num.toLowerCase\n\e[31m\e[31m\
    \   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35mnum\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmp0ohkt35w.scala:32:101 ----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        p.zipWithIndex.filter(_._2 % p.sum == \e[31m0\e\
    [0m).flatMap(\e[36mx\e[0m => (digits.filter(_==x._).map(x._), x._2))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                     ^\e[0m\n\e[31m   |\e[0mno given instance\
    \ of type ((Nothing, Int)) => Iterable[B] was found for parameter asIterable of\
    \ \e[33mmethod\e[0m \e[35mflatMap\e[0m in \e[33mclass\e[0m \e[35mArrayOps\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mwhere:    B is a type variable\n4 errors found\n"
  stdout: ''
  timestamp: 1660009868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hex = num.split(\"\\\\W\"\
    )\n        // We create our set of primes (set of natural numbers less than or\
    \ equal \n        // to the number that we want to count).\n        val numbers\
    \ = hex.map(n => n.toLong)\n        // We are going to count the number of primes\
    \ we have.\n        var count = 0\n        // While there are still primes left,\
    \ we are going to divide them and \n        // count the number we find there.\n\
    \        while (numbers.length > 0) {\n            // Since we know that we are\
    \ dividing by primes lesser than or \n            // equal to the current number,\
    \ we do not divide them by primes\n            // greater than the current number.\n\
    \            val num = numbers.dropWhile(n => n < num).head\n            // We\
    \ found a prime, we are going to count it.\n            count += 1\n         \
    \   // And we are going to remove it from the set of numbers to divide with.\n\
    \            numbers = numbers.tail\n        }\n        // We are returning our\
    \ count.\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpelue1haq.scala:38:49 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e[0m \e[36mnum\e[0m = numbers.dropWhile(\e\
    [36mn\e[0m => n < num).head\n\e[31m\e[31m   |\e[0m                           \
    \                      ^\e[0m\n\e[31m   |\e[0m                               \
    \           Recursive \e[33mvalue\e[0m \e[35mnum\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpelue1haq.scala:42:20 -----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            numbers = numbers.tail\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val numbers\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009867
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var numCount : Long = 0\n  \
    \      num.toCharArray.foreach(c => {\n            val val = (c.toLong + 96).toHexString\n\
    \            if (val.toInt==1 && val.toHexString==\"20\") {\n                numCount\
    \ += 1\n            }\n        })\n        return numCount\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpw1loqhi5.scala:28:16 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[33mval\e[0m = (c.toLong\
    \ + \e[31m96\e[0m).toHexString\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\
    \e[31m   |\e[0m                pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E018] Syntax Error: /tmp/tmpw1loqhi5.scala:29:16 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m (\e[33mval\e[0m.toInt==\e[31m1\e\
    [0m && \e[33mval\e[0m.toHexString==\e[31m\"20\"\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m                expression expected\
    \ but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009866
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val numArray = num.split(\"\"\
    ).toList\n        val numChar = numArray(0)\n        var i = 0\n        var digits\
    \ = \"\"\n        var prime = 0\n        for (hexDigit <- numArray) {\n      \
    \      digits = digits + hexDigit + \" \"\n            if (hexDigit == \"A\")\
    \ {\n                prime = 1\n            }\n            else if (hexDigit ==\
    \ \"B\") {\n                prime = 2\n            }\n            else if (hexDigit\
    \ == \"C\") {\n                prime = 3\n            }\n            else if (hexDigit\
    \ == \"D\") {\n                prime = 5\n            }\n            else if (hexDigit\
    \ == \"E\") {\n                prime = 7\n            }\n            else if (hexDigit\
    \ == \"F\") {\n                prime = 11\n            }\n            else {\n\
    \                prime = 2\n            }\n        }\n        var numDigits =\
    \ digits.length\n        var primes = 0\n        val primeFactors = primeFactorsOfNumberOfDigits(numDigits)\n\
    \        var hexNumChars = numChar.toString.length\n        var hexNumPrimes =\
    \ numDigits.length\n        val hexNumPrimeFactors = primeFactorsOfNumberOfDigits(hexNumPrimes)\n\
    \        for (hexPrime <- hexNumPrimeFactors) {\n            if (hexPrime == numDigits)\
    \ {\n                primes = primes + 1\n            }\n        }\n        val\
    \ hexNumPrimeFactorsArray = primeFactorsOfNumberOfDigits(primes)\n        val\
    \ hexNumPrimes = hexNumPrimeFactorsArray(0)\n        val hexNumPrimesArray = primeFactorsOfNumberOfDigits(hexNumPrimes)\n\
    \        val hexNumPrimesSum = hexNumPrimes.toInt\n        val hexNumPrimesSumArray\
    \ = primeFactorsOfNumberOfDigits(hexNumPrimesSum)\n        for (hexPrime <- hexNumPrimesArray)\
    \ {\n            if (hexPrime == primes) {\n                primes = primes +\
    \ 1\n            }\n        }\n        var hexNumPrimesSumPrimes = 0\n       \
    \ val hexNumPrimesSumPrimesArray = primeFactorsOfNumberOfDigits(hexNumPrimesSumPrimes)\n\
    \        for (hexPrime <- hexNumPrimesSumArray) {\n            if (hexPrime ==\
    \ primes) {\n                primes = primes + 1\n            }\n        }\n \
    \       primes = primes - 1\n        hexNumPrimes = hexNumPrimes - 1\n       \
    \ for (hexPrime <- hexNumPrimeFactorsArray) {\n            if (hexPrime == primes)\
    \ {\n                primes = primes + 1\n            }\n        }\n        hexNum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpep1r1psq.scala:67:12 ---------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m        \e[33mval\e[0m \e[36mhexNumPrimes\e[0m = hexNumPrimeFactorsArray(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhexNumPrimes is already defined as \e[33mvariable\e[0m \e\
    [35mhexNumPrimes\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpep1r1psq.scala:57:27 ------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \e[36mprimeFactors\e[0m = primeFactorsOfNumberOfDigits(numDigits)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: primeFactorsOfNumberOfDigits\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpep1r1psq.scala:59:37\
    \ ------------------------\e[0m\e[0m\n\e[31m59 |\e[0m        \e[33mvar\e[0m \e\
    [36mhexNumPrimes\e[0m = numDigits.length\n\e[31m\e[31m   |\e[0m              \
    \             ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \  value length is not a member of Int\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpep1r1psq.scala:60:33 ------------------------\e[0m\e[0m\n\e[31m60 |\e\
    [0m        \e[33mval\e[0m \e[36mhexNumPrimeFactors\e[0m = primeFactorsOfNumberOfDigits(hexNumPrimes)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Not found: primeFactorsOfNumberOfDigits\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpep1r1psq.scala:66:38\
    \ ------------------------\e[0m\e[0m\n\e[31m66 |\e[0m        \e[33mval\e[0m \e\
    [36mhexNumPrimeFactorsArray\e[0m = primeFactorsOfNumberOfDigits(primes)\n\e[31m\e\
    [31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Not found:"
  stdout: ''
  timestamp: 1660009870
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val numStr : String = num.toUpperCase\n\
    \        val numStrArray = numStr.toCharArray\n        val n = numStr.length\n\
    \        var count = 0\n        for(i <- 0 until n) {\n            val c = numStrArray(i)\n\
    \            if(c == 'A') {\n                count += 1\n            }\n     \
    \       else if(c == 'B') {\n                count += 3\n            }\n     \
    \       else if(c == 'C') {\n                count += 5\n            }\n     \
    \       else if(c == 'D') {\n                count += 7\n            }\n     \
    \       else if(c == 'E') {\n                count += 11\n            }\n    \
    \        else if(c == 'F') {\n                count += 13\n            }\n   \
    \         else {\n                count += c\n            }\n        }\n     \
    \   count\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8u8pmd8u.scala:57)\n\tat Problem.main(tmp8u8pmd8u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009871
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Your code here\n        val\
    \ nums = num.toCharArray.filterNot(s => ('A'<= s ) && (s <= 'F'))\n        val\
    \ numsOfDigits : Array[Int] = nums.map(x => x + '0' - 'A'.toInt)\n        numsOfDigits.length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaeudb5s.scala:32)\n\tat Problem.main(tmpkaeudb5s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        if (num.length == 0) {\n   \
    \         return 0\n        }\n        var n = 0\n        for (v <- num.toCharArray)\
    \ {\n            n += v.toLong match {\n                case a if a%2==0 => (0L)\n\
    \                case b if (b%2==0) => (1L)\n                case c if (c%2==0)\
    \ => (2L)\n                case d if (d%2==0) => (3L)\n                case e\
    \ if (e%2==0) => (4L)\n                case f if (f%2==0) => (5L)\n          \
    \      case g if (g%2==0) => (6L)\n                case h if (h%2==0) => (7L)\n\
    \                case i if (i%2==0) => (8L)\n                case j if (j%2==0)\
    \ => (9L)\n                case k if (k%2==0) => (10L)\n                case l\
    \ if (l%2==0) => (11L)\n                case m if (m%2==0) => (12L)\n        \
    \        case n if (n%2==0) => (13L)\n                case o if (o%2==0) => (14L)\n\
    \                case p if (p%2==0) => (15L)\n                case q if (q%2==0)\
    \ => (16L)\n                case r if (r%2==0) => (17L)\n                case\
    \ s if (s%2==0) => (18L)\n                case t if (t%2==0) => (19L)\n      \
    \          case u if (u%2==0) => (20L)\n                case v if (v%2==0) =>\
    \ (21L)\n                case w if (w%2==0) => (22L)\n                case x if\
    \ (x%2==0) => (23L)\n                case y if (y%2==0) => (24L)\n           \
    \     case z if (z%2==0) => (25L)\n                case A if (A%2==0) => (26L)\n\
    \                case B if (B%2==0) => (27L)\n                case C if (C%2==0)\
    \ => (28L)\n                case D if (D%2==0) => (29L)\n                case\
    \ E if (E%2==0) => (30L)\n                case F if (F%2==0) => (31L)\n      \
    \          case x => 0\n            }\n        }\n        n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_7m2ww0q.scala:31:14 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            n += v.toLong \e[33mmatch\e[0m {\n\e[31m\e\
    [31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp_7m2ww0q.scala:58:21 ------------------------\e[0m\e[0m\n\e[31m58 |\e\
    [0m                \e[33mcase\e[0m A \e[33mif\e[0m (A%\e[31m2\e[0m==\e[31m0\e\
    [0m) => (\e[31m26L\e[0m)\n\e[31m\e[31m   |\e[0m                     ^\e[0m\n\e\
    [31m   |\e[0m                     Not found: A\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp_7m2ww0q.scala:58:27 ------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m                \e[33mcase\e[0m A \e[33mif\e[0m (A%\e\
    [31m2\e[0m==\e[31m0\e[0m) => (\e[31m26L\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \                  ^\e[0m\n\e[31m   |\e[0m                           Not found:\
    \ A\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_7m2ww0q.scala:59:21\
    \ ------------------------\e[0m\e[0m\n\e[31m59 |\e[0m                \e[33mcase\e\
    [0m B \e[33mif\e[0m (B%\e[31m2\e[0m==\e[31m0\e[0m) => (\e[31m27L\e[0m)\n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ Not found: B\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_7m2ww0q.scala:59:27\
    \ ------------------------\e[0m\e[0m\n\e[31m59 |\e[0m                \e[33mcase\e\
    [0m B \e[33mif\e[0m (B%\e[31m2\e[0m==\e[31m0\e[0m) => (\e[31m27L\e[0m)\n\e[31m\e\
    [31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m              \
    \             Not found: B\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp_7m2ww0q.scala:60:21 ------------------------\e[0m\e[0m\n\e[31m60 |\e\
    [0m                \e[33mcase\e[0m C \e[33mif\e[0m (C%\e[31m2\e[0m==\e[31m0\e\
    [0m) => (\e[31m28L\e[0m)\n\e[31m\e[31m   |\e[0m       "
  stdout: ''
  timestamp: 1660009870
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        def isPrime(num : Long, i :\
    \ Int) : Boolean = {\n            if (i <= 0) false\n            val upper = num.toString.toUpperCase\n\
    \            val upperDigit = upper.toCharArray()(i)\n            val upper2 =\
    \ upper.toCharArray()(i-1)\n            if (upperDigit == upper2) true\n     \
    \       else (upperDigit == ('0' | upper2))\n        }\n\n        def primeDigits(num\
    \ : Long, i : Int) : Long = {\n            if (num == 0) 0\n            else {\n\
    \                val upper = num.toString.toUpperCase\n                val upperDigit\
    \ = upper.toCharArray()(i)\n                if (isPrime(num, i)) primeDigits(num.toString.toLong,\
    \ i) + 1\n                else primeDigits(num.toString.toLong, i) * 10 + upperDigit\n\
    \            }\n        }\n        val total = 0\n        val numStr = toDigits(num)\n\
    \        numStr.foreach { digit =>\n            total += primeDigits(numStr.length,\
    \ digit)\n        }\n        total.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmysg5d0k.scala:45:21 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mnumStr\e[0m = toDigits(num)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                Not found: toDigits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- [E129]\
    \ Potential Issue Warning: /tmp/tmpmysg5d0k.scala:27:24 ----------------\e[0m\e\
    [0m\n\e[33m27 |\e[0m            \e[33mif\e[0m (i <= \e[31m0\e[0m) \e[31mfalse\e\
    [0m\n\e[33m\e[33m   |\e[0m                        ^^^^^\e[0m\n\e[33m   |\e[0mA\
    \ pure expression does nothing in statement position; you may be omitting necessary\
    \ parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 warning found\n1 error found\n"
  stdout: ''
  timestamp: 1660009868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        def hexToDec(str: String) :\
    \ Long = {\n            val arr = str.split('')\n            var sum = 0\n   \
    \         arr.map { x =>\n                val y = x.toInt\n                if\
    \ (y == 17) 17\n                else if (y == 10) 10\n                else sum\
    \ + y\n            }\n        }\n        def getHexDigits(str: String): List[String]\
    \ = {\n            val arr = str.split('')\n            val res = new ArrayBuffer[String]()\n\
    \            arr.foreach { x =>\n                val y = x.toInt\n           \
    \     if (y != 17 && y != 10) res += x.toString\n            }\n            res.toList\n\
    \        }\n        val digits = getHexDigits(num)\n        val hexToDec_arr =\
    \ digits.map(hexToDec).toList\n        val res = hexToDec_arr.count(_ == 2)\n\
    \        (1l -> res)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpndr4tcif.scala:27:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = str.split('')\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m \
    \                               empty character literal\n\e[31m\e[31m-- [E018]\
    \ Syntax Error: /tmp/tmpndr4tcif.scala:28:20 ---------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            \e[33mvar\e[0m \e[36msum\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       expression expected but \e[31m=\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpndr4tcif.scala:37:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = str.split('')\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m \
    \                               empty character literal\n\e[31m\e[31m-- [E018]\
    \ Syntax Error: /tmp/tmpndr4tcif.scala:38:20 ---------------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m            \e[33mval\e[0m \e[36mres\e[0m = \e[33mnew\e[0m\
    \ \e[35mArrayBuffer\e[0m[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m         \
    \           ^\e[0m\n\e[31m   |\e[0m                    expression expected but\
    \ \e[31m=\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpndr4tcif.scala:28:12\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mvar\e[0m\
    \ \e[36msum\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e\
    [31m   |\e[0m            Not found: 'var\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpndr4tcif.scala:33:21 ------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m                \e[33melse\e[0m sum + y\n\e[31m\e[31m   |\e\
    [0m                     ^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ sum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] No"
  stdout: ''
  timestamp: 1660009874
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // TODO: Write your code here\n\
    \        val hexNum = num.toCharArray\n        val hexKey = new mutable.HashMap[Int,\
    \ Int]()\n        var count = 0\n        for(i <- 0 until hexNum.length) {\n \
    \           val hexVal = hexNum(i)\n            hexKey.getOrElseUpdate(hexVal.toInt,\
    \ 0)\n            count += 1\n        }\n        count\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbqkeatkv.scala:28:25 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhexKey\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009869
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val input = num.toLowerCase\
    \ // make sure input will be lowercase\n        val isHex = input.matches(\"\"\
    \"^[0-9A-F]*$\"\"\")\n        val numChars = input.length\n        // find first\
    \ and last hex character index\n        val firstHex = input.indexOf('A')\n  \
    \      val lastHex = input.length - 1\n        // the prime numbers are between\
    \ first and last hex chars\n        val primes = findPrimes(firstHex, lastHex).asInstanceOf[List[Long]]\n\
    \        // a dictionary to count frequency of each prime char\n        val freq\
    \ = input.sliding(2).map(ch => ch to 1).groupBy(_._1).map(x => x._1 to x._2.size)\n\
    \        // prime chars which has less than two frequencies will be excluded\n\
    \        val countFreq = freq.filter(_._2 < 2)\n        val hexFreq = countFreq.filter(_._2\
    \ > 0)\n        // add the prime numbers whose frequencies are more than 2\n \
    \       val addPrimes = primes.filterNot(x => hexFreq.contains(x))\n        val\
    \ hexKey = hexFreq.map(x => hexFreq.size - hexFreq.count(_ == x)).sum\n      \
    \  // if the input has only one hexadecimal digit, return it as 1\n        if\
    \ (numChars == 1) {\n            hexKey += hexKey((\"1\")) // if the input is\
    \ only one hexadecimal digit, add it\n        }\n        // add prime chars whose\
    \ frequencies are more than 2\n        addPrimes\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe4o3ozq2.scala:33:21 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = findPrimes(firstHex,\
    \ lastHex).asInstanceOf[\e[35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: findPrimes\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe4o3ozq2.scala:35:52\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mfreq\e\
    [0m = input.sliding(\e[31m2\e[0m).map(\e[36mch\e[0m => ch to \e[31m1\e[0m).groupBy(_._1).map(\e\
    [36mx\e[0m => x._1 to x._2.size)\n\e[31m\e[31m   |\e[0m                      \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \    Found:    (\e[31m1\e[0m : Int)\n\e[31m   |\e[0m                         \
    \  Required: scala.collection.Factory[Char, Any]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009874
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var numDigit = num.length\n\
    \        var hexNum: Long = 0L\n        var hexDig: Char = 'A'\n\n        for\
    \ (i <- 0 until numDigit) {\n            if (num(i) == 'A') { hexDig = 'A'; hexNum\
    \ = hexNum * 16L }\n            else if (num(i) == 'B') { hexDig = 'B'; hexNum\
    \ = hexNum * 16L }\n            else if (num(i) == 'C') { hexDig = 'C'; hexNum\
    \ = hexNum * 16L }\n            else if (num(i) == 'D') { hexDig = 'D'; hexNum\
    \ = hexNum * 16L }\n            else if (num(i) == 'E') { hexDig = 'E'; hexNum\
    \ = hexNum * 16L }\n            else if (num(i) == 'F') { hexDig = 'F'; hexNum\
    \ = hexNum * 16L }\n            else if (num(i) == hexDig) {\n               \
    \ hexNum = hexNum * 16L\n                hexDig = 'A'\n            }\n       \
    \     else {\n                hexNum = hexNum * 16L\n            }\n        }\n\
    \        return hexNum\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpazb5btb_.scala:48)\n\tat Problem.main(tmpazb5btb_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009875
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var sum = 0\n        for(i <-\
    \ num.toCharArray) sum = sum + (i.toLong % 2 == 0 ? i : i ^ 1)\n        sum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpplo781j8.scala:27:73 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mfor\e[0m(i <- num.toCharArray) sum = sum\
    \ + (i.toLong % \e[31m2\e[0m == \e[31m0\e[0m ? i : \e[35mi\e[0m \e[35m^\e[0m \e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \                                Not found: type ^\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpplo781j8.scala:27:65 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mfor\e[0m(i <- num.toCharArray) sum = sum\
    \ + (i.toLong % \e[31m2\e[0m == \e[31m0\e[0m ? i : \e[35mi\e[0m \e[35m^\e[0m \e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                    ^^^\e[0m\n\e[31m   |\e[0m                               \
    \           value ? is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660009874
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Write your code here\n  \
    \      val list = new mutable.ListBuffer[Long]()\n        for (i <- 0 to num.length-1){\n\
    \            if (num(i).toInt == 0 || num(i).toInt == 1){\n                list\
    \ += num(i).toLong\n            } else {\n                val a = num(i).toInt\n\
    \                val b = num(i+1).toInt\n                val p = a*10 + b\n  \
    \              \n                for (x <- 2 until p){\n                    if\
    \ (p%x == 0) list += x*10\n                }\n            }\n        }\n     \
    \   list.size\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9rv5pngs.scala:27:23 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009870
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val numAsList = num.toList\n\
    \        val primes = mutable.Set[Long]()\n        def countPrimes(num : Int)\
    \ : Long = {\n            if (num == 0)\n                0\n            else if\
    \ (num % 2 == 0)\n                countPrimes(num/2) + 1\n            else if\
    \ (num % 2 == 1)\n                countPrimes(num/2) + 1\n            else\n \
    \               primes.add(num)\n                countPrimes(num/2)\n        }\n\
    \        val primesLen = primes.size\n        numAsList.foreach(countPrimes(_))\n\
    \        primes.size - primesLen + 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyurau_cv.scala:27:21 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = mutable.Set[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009870
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hex = num.replaceAll(\"\
    [^A-F0-9]\",\"\")\n        if(hex.size == 0) 1\n        else {\n            val\
    \ hexDigits = hex.split(\"\").map(x => x.toInt)\n            // hexDigits now\
    \ contains a list of all digits in hexadecimal num\n            val primes = hexDigits.filter(x\
    \ => x >= 0 && x <= 16).map(x => (x / 16) rem 2).toSet\n            // primes\
    \ now contains all prime numbers in hexDigits\n            val maxPrime = hexDigits.filter(x\
    \ => x >= 0 && x <= 16).map(x => (x / 16) rem 2).reduce((x, y) => x < y ? x :\
    \ y)\n            // maxPrime now contains the largest prime number in hexDigits\n\
    \            val hexToDigits = hexDigits - primes - maxPrime\n            // hexToDigits\
    \ now contains the prime numbers in hexadecimal digits in order\n            val\
    \ key = 0\n            for(hexToDigit <- hexToDigits)\n                key +=\
    \ hexToDigit * primes.find(hexToDigit == _).map(x => hexToDigit * x).reduce((x,\
    \ y) => x < y ? x : y)\n            key\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzpq9ydua.scala:31:84 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36mprimes\e[0m = hexDigits.filter(\e\
    [36mx\e[0m => x >= \e[31m0\e[0m && x <= \e[31m16\e[0m).map(\e[36mx\e[0m => (x\
    \ / \e[31m16\e[0m) rem \e[31m2\e[0m).toSet\n\e[31m\e[31m   |\e[0m            \
    \                                                               ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        value rem is not a\
    \ member of Int\n\e[31m\e[31m-- Error: /tmp/tmpzpq9ydua.scala:31:90 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36mprimes\e[0m = hexDigits.filter(\e\
    [36mx\e[0m => x >= \e[31m0\e[0m && x <= \e[31m16\e[0m).map(\e[36mx\e[0m => (x\
    \ / \e[31m16\e[0m) rem \e[31m2\e[0m).toSet\n\e[31m\e[31m   |\e[0m            \
    \                                                                            \
    \  ^\e[0m\n\e[31m   |\e[0m                                          No ClassTag\
    \ available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                          \
    \                where:    B is a type variable\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpzpq9ydua.scala:33:86 ------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m            \e[33mval\e[0m \e[36mmaxPrime\e[0m = hexDigits.filter(\e[36mx\e\
    [0m => x >= \e[31m0\e[0m && x <= \e[31m16\e[0m).map(\e[36mx\e[0m => (x / \e[31m16\e\
    [0m) rem \e[31m2\e[0m).reduce((\e[36mx\e[0m, \e[36my\e[0m) => x < y ? x : \e[35my\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                                  \
    \                           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                         value rem is not a member of Int\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpzpq9ydua.scala:33:92 -----------------------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36mmaxPrime\e[0m = hexDigits.filter(\e\
    [36mx\e[0m => x >= \e[31m0\e[0m && x <= \e[31m16\e[0m).map(\e[36mx\e[0m => (x\
    \ / \e[31m16\e[0m) rem \e[31m2\e[0m).reduce((\e[36mx\e[0m, \e[36my\e[0m) => x\
    \ < y ? x : \e[35my\e[0m)\n\e[31m\e[31m   |\e[0m                             \
    \                                                               ^\e[0m\n\e[31m\
    \  "
  stdout: ''
  timestamp: 1660009876
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var count = 0L\n        for\
    \ (xx <- num.toCharArray) {\n            val x = math.pow(16, num.length - xx)\n\
    \            if (x % num.toInt == 0) count++\n        }\n        count\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxfefgnk6.scala:29:43 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m (x % num.toInt == \e[31m0\e\
    [0m) count++\n\e[31m\e[31m   |\e[0m                                          \
    \ ^\e[0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        if (num.length != 16) {\n  \
    \          throw new Exception(\"Bad input, must have the length of 16\")\n  \
    \      }\n\n        val digits = new mutable.HashSet[Long]()\n        val primes\
    \ = new mutable.HashSet[Long]()\n\n        val hex = num.toCharArray.map(_.toLong).map(x\
    \ => x % 16).toList\n        val hexString = hex.toList\n        // Convert each\
    \ char to its decimal representation from 0-9\n        val hexDec = hexString.map(x\
    \ => x + 48).reverse\n        val hexDecString = hexDec.toList\n        // Convert\
    \ each hexadecimal number to a String\n        val hexString = hexDecString.reverse\n\
    \        // Add the digits\n        hexString.foreach(x => digits.add(x))\n  \
    \      // Add the primes\n        for (x1 <- 0 to hexString.length - 2) {\n  \
    \          val x3 = hexString(2 * x1 + 1)\n            if ((hexString(2 * x1 +\
    \ 2) == x3) && (x1 != hexString.length - 2)) {\n                primes.add(x1)\n\
    \            }\n        }\n        // Add the prime numbers less than the hexadecimal\
    \ number.\n        // For example if the hexadecimal number is \"AB\", then prime\
    \ numbers are \n        // 3, 5, 7, 11, 13\n        val primeStrings = primes.toList\n\
    \        var prime = 0\n        val isPrime = hexString.foreach(x => if (prime\
    \ == 0) primeStrings.foreach(y => prime += if (x % y == 0) 1 else 0))\n\n    \
    \    return digits.size + prime\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6kgl29tf.scala:54:96 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e[36misPrime\e[0m = hexString.foreach(\e\
    [36mx\e[0m => \e[33mif\e[0m (prime == \e[31m0\e[0m) primeStrings.foreach(\e[36my\e\
    [0m => prime += \e[33mif\e[0m (x % y == \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                                    \
    \                                                            ^^\e[0m\n\e[31m \
    \  |\e[0m                                        expression expected but \e[31mif\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6kgl29tf.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhexString\e[0m = hexDecString.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhexString is already defined as \e[33mvalue\e[0m \e[35mhexString\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp6kgl29tf.scala:30:25 ------------------------\e[0m\e[0m\n\
    \e[31m30 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = \e[33mnew\e[0m mutable.HashSet[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp6kgl29tf.scala:31:25 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = \e[33mnew\e\
    [0m mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009874
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val digits = hexToInt(num)\n\
    \        val length = digits.length\n        // count the number of prime numbers\n\
    \        val primes = \n            for (i <- 0 until length if isPrime(digits(i)))\n\
    \            yield digits(i)\n        primes.sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnj0gbovw.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = hexToInt(num)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                Not found: hexToInt\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpnj0gbovw.scala:30:40 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m            \e[33mfor\e[0m (i <- \e[31m0\e[0m until length\
    \ \e[33mif\e[0m isPrime(digits(i)))\n\e[31m\e[31m   |\e[0m                   \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \              Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009873
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var count = 0\n        var digit\
    \ = num.charAt(0)\n        for (i <- 0 until num.length-1) {\n            digit\
    \ = num.charAt(i)\n            if (digit >= '0' && digit <= '9') {\n         \
    \       val digitValue = digit.toLong\n                if (digitValue < 10) {\n\
    \                    if (digitValue % 2 == 0 && digitValue % 3 == 0 && digitValue\
    \ % 5 == 0) {\n                        count = count + 1\n                   \
    \ }\n                }\n            }\n        }\n        count + 1\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcvssmcck.scala:43)\n\tat Problem.main(tmpcvssmcck.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009877
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hex = num.toLong\n     \
    \   var sum = 0\n        // Count the number of digits less than 16\n        var\
    \ sumOfDigits = hex.filter(_ < 16)\n        while(sumOfDigits.nonEmpty) {\n  \
    \          val digit = sumOfDigits.head\n            // If the number is not a\
    \ product of only 2 and 3, add it to the sum\n            if(!isPrime(digit) ||\
    \ !isPrime(digit * digit))\n                sum += digit\n            sumOfDigits\
    \ = sumOfDigits.tail\n        }\n        sum.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4geywfts.scala:29:30 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mvar\e[0m \e[36msumOfDigits\e[0m = hex.filter(_\
    \ < \e[31m16\e[0m)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value filter is not a member of\
    \ Long\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4geywfts.scala:33:16 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mif\e[0m(!isPrime(digit) || !isPrime(digit\
    \ * digit))\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val numList = num.grouped(4).toList\n\
    \        var result = 0\n        for (i <- 0 until numList.length) {\n       \
    \     result += isPrime(numList(i))\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwsc0xesu.scala:29:19 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            result += isPrime(numList(i))\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpwsc0xesu.scala:29:22 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m            result += isPrime(numList(i))\n\e[31m\e[31m   |\e[0m          \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: isPrime\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var count = 3\n        var hexDigit\
    \ = 0\n        var isPrime = true\n        var isUpper = false\n        var isDig\
    \ = false\n        var isAlpha = false\n        for (char <- num.toCharArray)\
    \ {\n            hexDigit += Character.toInt(char)\n        }\n        isUpper\
    \ = hexDigit > 0xFF\n        isDig = (hexDigit >= 0) && (hexDigit <= 9)\n    \
    \    isAlpha = (hexDigit >= 0) && (hexDigit <= 0xF)\n        var isDigit = (hexDigit\
    \ >= 0) && (hexDigit <= 9)\n        if (isDigit && !isAlpha) {\n            count\
    \ = hexDigit + 1\n        }\n        if (isUpper && !isDig) {\n            count\
    \ = hexDigit + 1\n        }\n        if (isAlpha && !isDig) {\n            count\
    \ = hexDigit + 1\n        }\n        if (!isDig && !isUpper && !isAlpha) {\n \
    \           count = hexDigit + 1\n        }\n        val digitList = scala.collection.mutable.ListBuffer[Int]()\n\
    \        if (hexDigit >= 0xA) {\n            digitList += 0xA\n        }\n   \
    \     if (hexDigit >= 0xB) {\n            digitList += 0xB\n        }\n      \
    \  if (hexDigit >= 0xC) {\n            digitList += 0xC\n        }\n        if\
    \ (hexDigit >= 0xD) {\n            digitList += 0xD\n        }\n        if (hexDigit\
    \ >= 0xE) {\n            digitList += 0xE\n        }\n        if (hexDigit >=\
    \ 0xF) {\n            digitList += 0xF\n        }\n        digitList.foreach {\
    \ hexDigit =>\n            if (isPrime) {\n                isPrime = hexDigit\
    \ % 2 != 0\n                if (isPrime) {\n                    val digit = hexDigit\
    \ / 2\n                    if (digit == 0 || digit == 1) {\n                 \
    \       isPrime = true\n                    } else {\n                       \
    \ isPrime = false\n                    }\n                }\n            }\n \
    \       }\n        return count\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5qu55j8a.scala:33:21 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            hexDigit += Character.toInt(char)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp5qu55j8a.scala:33:34 ------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m            hexDigit += Character.toInt(char)\n\e[31m\e[31m   |\e[0m \
    \                       ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toInt is not\
    \ a member of object Character, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val key = new scala.collection.mutable.MutableList[Long]()\n\
    \        var index = 0\n        num match {\n            case hexKey if hexKey.isEmpty\
    \ => 0\n            case hexKey => hexKey.length match {\n                case\
    \ hexKey.length if hexKey.forall(_.isDigit) => hexKey.count(digitToLong)\n   \
    \             case hexKey.length if hexKey.forall(_.isLetter) => hexKey.count(letterToLong)\n\
    \                case hexKey.length if hexKey.forall(_.isUpper) => hexKey.count(upperToLong)\n\
    \                case _ => throw new IllegalArgumentException(s\"${hexKey} is\
    \ not hexadecimal number\")\n            }\n        }\n        return key.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg5lpvclk.scala:26:47 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mkey\e[0m = \e[33mnew\e[0m\
    \ scala.collection.mutable.MutableList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            type MutableList is not a member of scala.collection.mutable\n\e\
    [31m\e[31m-- [E135] Type Error: /tmp/tmpg5lpvclk.scala:31:28 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33mcase\e[0m hexKey.length \e[33mif\e\
    [0m hexKey.forall(_.isDigit) => hexKey.count(digitToLong)\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \   Stable identifier required, but hexKey.length found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpg5lpvclk.scala:31:79 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m                \e[33mcase\e[0m hexKey.length \e[33mif\e[0m\
    \ hexKey.forall(_.isDigit) => hexKey.count(digitToLong)\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                        \
    \          Not found: digitToLong\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E135] Type Error:\
    \ /tmp/tmpg5lpvclk.scala:32:28 -----------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m                \e[33mcase\e[0m hexKey.length \e[33mif\e[0m hexKey.forall(_.isLetter)\
    \ => hexKey.count(letterToLong)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Stable identifier required, but hexKey.length\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg5lpvclk.scala:32:80 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                \e[33mcase\e[0m hexKey.length \e[33mif\e\
    [0m hexKey.forall(_.isLetter) => hexKey.count(letterToLong)\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                    \
    \             Not found: letterToLong\n"
  stdout: ''
  timestamp: 1660009878
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Your code goes here\n   \
    \     // Your code goes here\n        // Your code goes here\n        // Your\
    \ code goes here\n        // Your code goes here\n        // Your code goes here\n\
    \        // Your code goes here\n        0\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpirhxkw7s.scala:36)\n\tat Problem.main(tmpirhxkw7s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexArray = num.toCharArray.flatMap\
    \ { x =>\n            if(x.toInt > 9 || x.toInt < 0)\n                throw new\
    \ IllegalArgumentException(\n                    \"The argument is not hexadecimal\
    \ number\")\n            else if(x.toInt == 0)\n                throw new IllegalArgumentException(\n\
    \                    \"The argument is not hexadecimal number\")\n           \
    \ else if(x.toInt == 1)\n                throw new IllegalArgumentException(\n\
    \                    \"The argument is not hexadecimal number\")\n           \
    \ else x\n        }\n        val primes = List(2,3,5,7,11,13,17,19,23,29,31,37,41,\n\
    \                          43,47,53,59,61,67,71,73,79,83,89,97)\n        val primesCount\
    \ = primes.toList.length\n        val hexCount = hexArray.toList.length\n    \
    \    val hexPrimesCount = hexArray.toList.count(x => primes.contains(x))\n   \
    \     val hexPrimes = hexArray.toList.filter { x =>\n            primes.contains(x)\n\
    \        }\n        val hexPrimesCount = hexArray.toList.count(x => primes.contains(x))\n\
    \        val hexPrimes = hexArray.toList.filter { x =>\n            primes.contains(x)\n\
    \        }\n        val result = primes.foldLeft(0)(_+hexPrimesCount)\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm_r1nxrd.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mhexPrimesCount\e[0m = hexArray.toList.count(\e\
    [36mx\e[0m => primes.contains(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhexPrimesCount is already defined as \e[33mvalue\e[0m \e[35mhexPrimesCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpm_r1nxrd.scala:47:12 ---------------------------\e[0m\e[0m\n\e\
    [31m47 |\e[0m        \e[33mval\e[0m \e[36mhexPrimes\e[0m = hexArray.toList.filter\
    \ { \e[36mx\e[0m =>\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mhexPrimes\
    \ is already defined as \e[33mvalue\e[0m \e[35mhexPrimes\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m48 |\e[0m            primes.contains(x)\n\e[31m49\
    \ |\e[0m        }\n\e[31m\e[31m-- Error: /tmp/tmpm_r1nxrd.scala:37:9 ------------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m\
    \   |\e[0mno given instance of type Char => Iterable[B] was found for parameter\
    \ asIterable of \e[33mmethod\e[0m \e[35mflatMap\e[0m in \e[33mclass\e[0m \e[35mArrayOps\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mwhere:    B is a type variable\n\e[31m\e\
    [31m-- [E086] Syntax Error: /tmp/tmpm_r1nxrd.scala:50:40 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = primes.foldLeft(\e\
    [31m0\e[0m)(_+hexPrimesCount)\n\e[31m\e[31m   |\e[0m                         \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Wrong number of parameters, expected: 2\n4 errors found\n"
  stdout: ''
  timestamp: 1660009879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexKey = num.toInt\n   \
    \     val primes = primes(hexKey)\n        val lenOfHexKey = hexKey.length\n \
    \       // Find the first prime number.\n        var isPrime = true\n        for\
    \ (prime <- primes) {\n            if (lenOfHexKey == prime.length)\n        \
    \        isPrime = false\n            if (hexKey.length == prime.length) {\n \
    \               if (hexKey.charAt(lenOfHexKey) == 'A') {\n                   \
    \ if (hexKey.charAt(lenOfHexKey+2) == 'A')\n                        hexKey.charAt(lenOfHexKey+2)\
    \ = 'B'\n                    else\n                        hexKey.charAt(lenOfHexKey+2)\
    \ = 'A'\n                }\n                if (hexKey.charAt(lenOfHexKey) ==\
    \ 'C')\n                    hexKey.charAt(lenOfHexKey) = 'D'\n            }\n\
    \        }\n        if (primes.isEmpty)\n            0\n        else\n       \
    \     primes.find(_ == lenOfHexKey).get.asInstanceOf[Long]\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptw_zlah8.scala:27:21 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = primes(hexKey)\n\
    \e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m            \
    \         Recursive \e[33mvalue\e[0m \e[35mprimes\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptw_zlah8.scala:28:33 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlenOfHexKey\e[0m = hexKey.length\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value length is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val num = num.toUpperCase //\
    \ make sure input string is uppercase\n        def hexDigit(hex : Int) : Int =\
    \ hex % 16 // get the hexadecimal digit\n        val primes = mutable.ArrayBuffer(\
    \ // store prime numbers in an ArrayBuffer \n            2l, 3l, 5l, 7l, 11l,\
    \ 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l,\
    \ 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l,\
    \ 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l,\
    \ 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l,\
    \ 293l, 297l, 301l, 307l, 311l, 313l, 317l, 331l, 337l, 347l, 349l, 353l, 359l,\
    \ 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l, 431l, 433l, 439l,\
    \ 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l, 503l, 509l, 521l,\
    \ 523l, 529l, 531l, 537l, 543l, 549l, 551l, 557l, 563l, 569l, 571l, 577l, 587l,\
    \ 593l, 599l, 601l, 607l, 613l, 617l, 619l, 631l, 637l, 641l, 643l, 647l, 653l,\
    \ 659l, 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l,\
    \ 751l, 757l, 761l, 767l, 773l, 787l, 797l, 803l, 809l, 811l, 817l, 821l, 823l,\
    \ 827l, 829l, 831l, 833l, 839l, 843l, 849l, 851l, 857l, 863l, 871l, 877l, 883l,\
    \ 889l, 893l, 901l, 907l, 911l, 919l, 931l, 937l, 941l, 947l, 953l, 967l, 971l,\
    \ 977l, 983\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqicsov4n.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqicsov4n.scala:26:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mnum\e[0m = num.toUpperCase \e[34m// make sure input string is uppercase\e\
    [0m\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m          \
    \        Recursive \e[33mvalue\e[0m \e[35mnum\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpqicsov4n.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = mutable.ArrayBuffer(\
    \ \e[34m// store prime numbers in an ArrayBuffer \e[0m\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqicsov4n.scala:30:5\
    \ ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val s = num.trim\n        if(s.length\
    \ == 0) return 1\n        val numsHash = s.toInt.map(i => i + ((i % 2) + 1)).toMap\n\
    \        val maxPrime = 2L\n        def primesHash(p : Long) : Long = {\n    \
    \        val res = if (numsHash.get(p) > 0) {\n                val res = primesHash(p\
    \ / 2)\n                numsHash.remove(p)\n                res\n            }\
    \ else {\n                0\n            }\n            res + p\n        }\n \
    \       primesHash(maxPrime)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpezuj0ajn.scala:28:31 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mnumsHash\e[0m = s.toInt.map(\e\
    [36mi\e[0m => i + ((i % \e[31m2\e[0m) + \e[31m1\e[0m)).toMap\n\e[31m\e[31m   |\e\
    [0m                       ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \     value map is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660009881
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        def isPrime(n: BigInt) : Boolean\
    \ = {\n            // Check whether n is prime\n            if (n < 2) false\n\
    \            else {\n                var isPrime = true\n                for (d\
    \ <- 2 to ceil(sqrt(n).toInt) by 2) {\n                    if (n % d == 0) {\n\
    \                        isPrime = false\n                        break\n    \
    \                }\n                }\n                if (isPrime) true\n   \
    \             else false\n            }\n        }\n        val numList = num.split(\"\
    \").toList\n        // The prime digits of numList is 2, 3, 5, 7, 11, 13, 17...\n\
    \        // So, numList.filter(_ % 2 == 0) is for 2, 3, 5, 7, B (=decimal 11),\
    \ D (=decimal 13).\n        // numList.filter(_ % 2 == 1) is for 1, 3, 7, 11,\
    \ B (=decimal 13), D (=decimal 17).\n        // numList.filter(_ % 2 == 0) | numList.filter(_\
    \ % 2 == 1) is for 2, 5, 7, 11, B (=decimal 11), D (=decimal 13).\n        val\
    \ primes = numList.filter(isPrime)\n        // primes is List(2, 3, 5, 7, 11,\
    \ 13, 17)\n        // primes.toSet is Set(2, 3, 5, 7, 11)\n        // primes.toSet\
    \ - primes.toSet is Set(2)\n        // primes.toSet.mkString.toInt == primes.toSet.map(_.toString.toInt).sum\n\
    \        // primes.toSet.map(_ * 2 + 1).sum == primes.toSet.map(_ * 2 + 1).sum\n\
    \        val primesSet = primes.toSet\n        primesSet.size * primesSet.toSet.size\
    \ - primesSet.count(_ > 2)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_d3o2kth.scala:31:41\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                \e[33mfor\e[0m\
    \ (d <- \e[31m2\e[0m to ceil(sqrt(n).toInt) by \e[31m2\e[0m) {\n\e[31m\e[31m \
    \  |\e[0m                                         ^\e[0m\n\e[31m   |\e[0m    \
    \                                     Found:    (n : BigInt)\n\e[31m   |\e[0m\
    \                                         Required: Double\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp_d3o2kth.scala:34:24 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_d3o2kth.scala:46:36\
    \ --------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mprimes\e\
    [0m = numList.filter(isPrime)\n\e[31m\e[31m   |\e[0m                         \
    \           ^\e[0m\n\e[31m   |\e[0m                                    Found:\
    \    (n : String)\n\e[31m   |\e[0m                                    Required:\
    \ BigInt\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_d3o2kth.scala:53:68\
    \ --------------------\e[0m\e[0m\n\e[31m53 |\e[0m        primesSet.size * primesSet.toSet.size\
    \ - primesSet.count(_ > \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                 \
    \                                                   ^\e[0m\n\e[31m   |\e[0m  \
    \                                                   Found:    (\e[31m2\e[0m :\
    \ Int)\n\e[31m   |\e[0m                                                     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Count how many times the\
    \ key repeats\n        val count = num.length.grouped(2).filter{ _1.length ==\
    \ _2.length }.size\n        val primes : Long = num.length rem 2 match{\n    \
    \        case 0 => 1\n            case n => 2 to (n - 1) map (n => (num.length\
    \ / n).toLong).sum\n        }\n        (count * primes).toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp39r6zkqy.scala:27:31 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcount\e[0m = num.length.grouped(\e\
    [31m2\e[0m).filter{ _1.length == _2.length }.size\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    value\
    \ grouped is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp39r6zkqy.scala:28:39\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mprimes\e[0m : \e[35mLong\e[0m = num.length rem \e[31m2\e[0m \e[33mmatch\e\
    [0m{\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                            value rem is not a member of Int\n\e\
    [31m\e[31m-- [E081] Type Error: /tmp/tmp39r6zkqy.scala:30:40 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mcase\e[0m n => \e[31m2\e[0m to (n -\
    \ \e[31m1\e[0m) map (n => (num.length / n).toLong).sum\n\e[31m\e[31m   |\e[0m\
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \             Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m       \
    \                   I could not infer the type of the parameter n.\n3 errors found\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Your code here.\n       \
    \ // Return Long.MaxValue if num is empty.\n        val nums = num.split(\"(?<=\\\
    \\G.{3})\").toList.map(_.toInt)\n        var count = 0\n        nums.foreach{n\
    \ =>\n            var flag = false\n            for(i <- 2 until n by 2){\n  \
    \              if(n % i == 0) {\n                    flag = true\n           \
    \         break\n                }\n            }\n            if(!flag)\n   \
    \             count = count + 1\n        }\n        \n        count match {\n\
    \            case 6  => 2L\n            case 5  => 3L\n            case 4  =>\
    \ 5L\n            case 3  => 7L\n            case 2  => 11L\n            case\
    \ 1  => 13L\n            case 0  => 0L\n            case _ => count\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzb1iy9yn.scala:35:20 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexToBin = num foldLeft(Map[Char,\
    \ String]()) { case (map, ch) => (map + (ch -> (ch.toInt % 2))) }\n        val\
    \ binToHex = hexToBin.values.map(x => (x.toHexString)).mkString(\"0\")\n     \
    \   binToHex.length\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp3xoldgb5.scala:26:59 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mhexToBin\e[0m = num foldLeft(Map[\e\
    [35mChar\e[0m, \e[35mString\e[0m]()) { \e[33mcase\e[0m (map, ch) => (map + (ch\
    \ -> (ch.toInt % \e[31m2\e[0m))) }\n\e[31m\e[31m   |\e[0m                    \
    \                                       ^\e[0m\n\e[31m   |\e[0m   Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ x$1 of expanded function:\n\e[31m   |\e[0m   x$1 => \n\e[31m   |\e[0m     x$1\e\
    [33m match \e[0m\n\e[31m   |\e[0m       {\n\e[31m   |\e[0m         \e[33mcase\
    \ \e[0m(map, ch) => \n\e[31m   |\e[0m           (map + (ch -> (ch.toInt % 2)))\n\
    \e[31m   |\e[0m       }.\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3xoldgb5.scala:26:78\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mhexToBin\e[0m = num foldLeft(Map[\e[35mChar\e[0m, \e[35mString\e[0m]()) {\
    \ \e[33mcase\e[0m (map, ch) => (map + (ch -> (ch.toInt % \e[31m2\e[0m))) }\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                    ^^^\e[0m\n\e[31m   |\e[0m                               \
    \                           Not found: map\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp3xoldgb5.scala:27:32 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbinToHex\e[0m = hexToBin.values.map(\e\
    [36mx\e[0m => (x.toHexString)).mkString(\e[31m\"0\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m                       ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value values\
    \ is not a member of ((String, Char) => String) => String\n3 errors found\n"
  stdout: ''
  timestamp: 1660009882
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Create a set that stores\
    \ all prime numbers and a variable that counts the number of digits in num \n\
    \        var primes = Set.empty[Long]\n        var count = 0\n        for(c <-\
    \ num) {\n            if(primes.contains(c.toLong)) {\n                count +=\
    \ 1\n            } else {\n                primes += c.toLong\n            }\n\
    \        }\n        primes.size\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1apkg3ot.scala:39)\n\tat Problem.main(tmp1apkg3ot.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val numList = num.split(\"\"\
    ).filter(_.isDigit).map(_.toLong).toList\n        val lastDigit = numList.last\n\
    \        if(lastDigit < 10 || lastDigit > 15) {\n            return 0\n      \
    \  }\n        val lastDigitValue = lastDigit - 1\n        val numList2 = numList.dropRight(1)\n\
    \        val numList3 = numList2.filter( x => (numList2.length - x) > 1)\n   \
    \     val numList4 = numList3.filter( x => x.toString.toLong % lastDigitValue\
    \ == 0)\n        numList4.size\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphe7urdlh.scala:26:45 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mnumList\e[0m = num.split(\e\
    [31m\"\"\e[0m).filter(_.isDigit).map(_.toLong).toList\n\e[31m\e[31m   |\e[0m \
    \                                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                              value isDigit is not a member of String\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val bits = num.toCharArray.map(_.toInt)\n\
    \        val num2bits = num :: bits\n        val primes: mutable.Set[Long] = {\n\
    \            var isPrime = false\n            var numToCheck = num2bits\n    \
    \        var i = 3\n            while(i <= bits.length) {\n                val\
    \ test = numToCheck % i\n                if (test == 0) isPrime = true\n     \
    \           else \n                    if(isPrime == true) primes += test\n  \
    \                  numToCheck = (numToCheck / i).toLong\n                i +=\
    \ 1\n            }\n            primes\n        }\n        val ret = (primes.length\
    \ / 8).toLong\n        ret\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmped8cpcfu.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mnum2bits\e[0m = num :: bits\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           value :: is not a member of Array[Int]\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmped8cpcfu.scala:28:20 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m: mutable.Set[\e\
    [35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var n = 0\n        var digitCount\
    \ = 0\n        var primeCount = 0\n        val len = num.length\n        for (i\
    \ <- 0 until len) {\n            val key = num(i)\n            digitCount += 1\n\
    \            if ((key.toChar() == 'A' || key.toChar() == 'B' || key.toChar() ==\
    \ 'C' || key.toChar() == 'D' || key.toChar() == 'E' || key.toChar() == 'F') &&\
    \ key.toUpperCase != 'A' && key.toUpperCase != 'B' && key.toUpperCase != 'C' &&\
    \ key.toUpperCase != 'D' && key.toUpperCase != 'E' && key.toUpperCase != 'F')\
    \ {\n                val keyUpper = key.toUpperCase // uppercase letter\n    \
    \            val keyLower = key.toLowerCase // lowercase letter\n            \
    \    var isPrime = true\n                if (keyUpper >= 'A' && keyUpper <= 'F')\
    \ {\n                    if (keyUpper >= '0' && keyUpper <= '9') {\n         \
    \               primeCount += 0 // not prime if less than a digit\n          \
    \              primeCount += 1 // prime if more than a digit (including 0)\n \
    \                   } else {\n                        primeCount += 0 // not prime\
    \ if less than a digit\n                        primeCount += 0 // prime if more\
    \ than a digit (including 0)\n                    }\n                } else {\n\
    \                    if (keyUpper >= '0' && keyUpper <= '9') {\n             \
    \           primeCount += 0 // not prime if less than a digit\n              \
    \          primeCount += 0 // prime if more than a digit (including 0)\n     \
    \               } else {\n                        primeCount += 0 // not prime\
    \ if less than a digit\n                        primeCount += 0 // prime if more\
    \ than a digit (including 0)\n                    }\n                }\n     \
    \       }\n            if (keyLower == 'A' || keyLower == 'B' || keyLower == 'C'\
    \ || keyLower == 'D' || keyLower == 'E' || keyLower == 'F') {\n              \
    \  primeCount += 0 // not prime if less than a digit\n                primeCount\
    \ += 0 // prime if more than a digit (including 0)\n            }\n        }\n\
    \        n = digitCount\n        n = n + primeCount\n        n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpcst064b2.scala:33:21 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mif\e[0m ((key.toChar() == \e[31m'A'\e\
    [0m || key.toChar() == \e[31m'B'\e[0m || key.toChar() == \e[31m'C'\e[0m || key.toChar()\
    \ == \e[31m'D'\e[0m || key.toChar() == \e[31m'E'\e[0m || key.toChar() == \e[31m'F'\e\
    [0m) && key.toUpperCase != \e[31m'A'\e[0m && key.toUpperCase != \e[31m'B'\e[0m\
    \ && key.toUpperCase != \e[31m'C'\e[0m && key.toUpperCase != \e[31m'D'\e[0m &&\
    \ key.toUpperCase != \e[31m'E'\e[0m && key.toUpperCase != \e[31m'F'\e[0m) {\n\e\
    [31m\e[31m   |\e[0m                 ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \        \e[33mmethod\e[0m \e[35mtoChar\e[0m in \e[33mclass\e[0m \e[35mChar\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpcst064b2.scala:34:35 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m                \e[33mval\e[0m \e[36mkeyUpper\e[0m = key.toUpperCase \e[34m//\
    \ uppercase letter\e[0m\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcst064b2.scala:35:35\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                \e[33mval\e\
    [0m \e[36mkeyLower\e[0m = key.toLowerCase \e[34m// lowercase letter\e[0m\n\e[31m\e\
    [31m   |\e[0m                               ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toLowerCase is not a member of Char\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpcst064b2.scala:55:16 ------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m            \e[33mif\e[0m (keyLower == \e[31m'A'\e[0m\
    \ || keyLower == \e[31m'B'\e[0m || keyLower == \e[31m'C'\e[0m || keyLower == \e\
    [31m'D'\e[0m || keyLower == \e[31m'E'\e[0m || keyLower == \e[31m'F'\e[0m) {\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \    Not found: keyLower\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009886
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val numOfDigits = num.length\n\
    \        var n = 0\n        val primesSet = mutable.Set[Long]()\n        val hexDigits\
    \ = \"ABCDEF\".toSet\n        hexDigits.foreach {\n            c =>\n        \
    \        val hexValue = num.toLong\n                n = hexValue * java.lang.Long.parseInt(\"\
    11\".toChar) + n\n                // If there is a prime, add it to the set.\n\
    \                // If not, move to the next digit.\n                while(n /\
    \ hexValue > 1) {\n                    primesSet += hexValue\n               \
    \     hexValue += 1\n                }\n        }\n        primesSet.count(_ >\
    \ num)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"\
    )) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7qahsqak.scala:28:24 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mprimesSet\e[0m = mutable.Set[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp7qahsqak.scala:33:46 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                n = hexValue * java.lang.Long.parseInt(\e\
    [31m\"11\"\e[0m.toChar) + n\n\e[31m\e[31m   |\e[0m                           \
    \    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue parseInt is not a member\
    \ of object Long - did you mean Long.parseLong?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp7qahsqak.scala:33:60 ------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m                n = hexValue * java.lang.Long.parseInt(\e[31m\"11\"\e\
    [0m.toChar) + n\n\e[31m\e[31m   |\e[0m                                       \
    \                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       value toChar is not a member of String\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp7qahsqak.scala:38:29 ------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m                    hexValue += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m  \
    \                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Long - did you mean hexValue.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660009885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var sum = 0\n        var i =\
    \ num.length\n        var k = num.length\n        while (i >= 1){\n          \
    \  var remainder = num.charAt(i-1) - 'A'\n            if (remainder >= 2) {\n\
    \                sum = sum + remainder\n            }\n            i = i - 1\n\
    \            k = k - 1\n        }\n        var remainder = num.charAt(0) - 'A'\n\
    \        if (remainder >= 2) {\n            sum = sum + remainder\n        }\n\
    \        return sum\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmt1xd1_p.scala:44)\n\tat Problem.main(tmpmt1xd1_p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexList = num.split(\"\\\
    \\B\") //split by non hexa chars\n        val hexNums = hexList.map { x => parseHex(x).toLong\
    \ }.toList\n        hexNums.map(x => isPrime(x) ? x : 1l).sum\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbw0822rb.scala:27:41 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mhexNums\e[0m = hexList.map\
    \ { \e[36mx\e[0m => parseHex(x).toLong }.toList\n\e[31m\e[31m   |\e[0m       \
    \                                  ^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                             Not found: parseHex\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpbw0822rb.scala:27:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mhexNums\e[0m = hexList.map\
    \ { \e[36mx\e[0m => parseHex(x).toLong }.toList\n\e[31m\e[31m   |\e[0m       \
    \                                                      ^\e[0m\n\e[31m   |\e[0m\
    \                                          No ClassTag available for B\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m                                          where:  \
    \  B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660009886
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        if (num.length == 0 || num.head\
    \ != 'A' && num.head != 'B' && num.head != 'C'\n            && num.head != 'D'\
    \ && num.head != 'E' && num.head != 'F') {\n            return 0\n        }\n\
    \        var count = 0\n        var lastDigit = 0\n        var index = 0\n   \
    \     for (i <- num.indices) {\n            if (num(i) > '9') {\n            \
    \    if (lastDigit == 4) {\n                    lastDigit = 0\n              \
    \  } else {\n                    lastDigit += 1\n                }\n         \
    \   }\n            if (num(i) <= '9') {\n                lastDigit += 1\n    \
    \        }\n            if (lastDigit % 2 == 1) {\n                lastDigit +=\
    \ 2\n            }\n            if (lastDigit > 9) {\n                lastDigit\
    \ = 0\n            }\n            count += 1\n            if (lastDigit % 2 ==\
    \ 1) {\n                lastDigit += 2\n            }\n            if (lastDigit\
    \ > 9) {\n                lastDigit = 0\n            }\n            count += 1\n\
    \            if (lastDigit % 2 == 1) {\n                lastDigit += 2\n     \
    \       }\n            if (lastDigit > 9) {\n                lastDigit = 0\n \
    \           }\n            count += 1\n            if (lastDigit % 2 == 1) {\n\
    \                lastDigit += 2\n            }\n            if (lastDigit > 9)\
    \ {\n                lastDigit = 0\n            }\n            count += 1\n  \
    \          if (lastDigit % 2 == 1) {\n                lastDigit += 2\n       \
    \     }\n            if (lastDigit > 9) {\n                lastDigit = 0\n   \
    \         }\n            count += 1\n        }\n        count\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_mw00fc7.scala:83)\n\tat Problem.main(tmp_mw00fc7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_.toInt)\n\
    \        val res = mutable.ArrayBuffer.empty[Long]\n        val n = hex.length\n\
    \        val primes = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n   \
    \     val factors = mutable.ArrayBuffer.empty[Long]\n        \n        // Get\
    \ all prime numbers in one pass.\n        primes += 2\n        while (primes.nonEmpty\
    \ && primes.head <= n) {\n            while (hex(i).toLong !in primes) {\n   \
    \             factors += hex(i).toLong\n                i += 1\n            }\n\
    \            primes -= hex(i).toLong\n            i += 1\n        }\n        //\
    \ Get all factors in one pass.\n        while (factors.nonEmpty && factors.head\
    \ <= n) {\n            factors += hex(i).toLong\n            i += 1\n        }\n\
    \        // Get the hexadecimal digits that is primes.\n        var hexPrimes\
    \ = primes.filter(p => hex(p) > 0)\n        while (hexPrimes.nonEmpty && hexPrimes.head\
    \ <= n) {\n            hexPrimes -= hexPrimes.head\n            i += 1\n     \
    \   }\n        // The hexadecimal digits that is primes are now removed from hexPrimes.\n\
    \        \n        // Now hexPrimes is the set of prime numbers that are not factors\
    \ of the \n        // input. \n        // All the hex digits that are prime can\
    \ be divided by all the factors \n        // of input. So that all hex digits\
    \ that are prime in the input are \n        // divided equally by every hex digit\
    \ that is prime in the input.\n        // The hexadecimal digits that is not prime\
    \ can be divided by every hex \n        // digit that is prime in the input. So\
    \ all hex digits that are not \n        // prime in the input will be divided\
    \ equally by every hex digit that is \n        // prime in the input.\n      \
    \  val factorsSet = factors.toSet\n        // Now calculate the prime factors\
    \ of each hex digit.\n        hexPrimes.foreach { prime => \n            factorsSet.filter(_\
    \ % prime == 0).foreach(factors => factors += prime)\n        }\n        // Calculate\
    \ the total of prime factors for each hex digit.\n        // Add the primes and\
    \ factors into the result. \n        hexPrimes.zipWithIndex.filter(_._1 % 2 ==\
    \ 1).foreach { \n            case (prime, i) => res ++= prime :: factors.take(i)\n\
    \        }\n        res.sum\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpucm78qjn.scala:36:43 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mwhile\e[0m (hex(i).toLong !in primes)\
    \ {\n\e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e\
    [31m   |\e[0m                                       expression expected but \e\
    [31m')'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpucm78qjn.scala:27:18\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mres\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpucm78qjn.scala:29:21\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mprimes\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpucm78qjn.scala:31:22\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mfactors\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpucm78qjn.scala:36:33\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mwhile\e\
    [0m (hex(i).toLong !in primes) {\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   value ! is not a member of Long\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hl = num.toLong\n      \
    \  var count = 0\n        for (h <- 0 until hl) count += (hl-h)%16 == 0L\n   \
    \     count\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpod6j66eg.scala:28:26\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mfor\e[0m (h <-\
    \ \e[31m0\e[0m until hl) count += (hl-h)%\e[31m16\e[0m == \e[31m0L\e[0m\n\e[31m\e\
    [31m   |\e[0m                          ^^\e[0m\n\e[31m   |\e[0m              \
    \            Found:    (hl : Long)\n\e[31m   |\e[0m                          Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpod6j66eg.scala:28:36\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mfor\e[0m (h\
    \ <- \e[31m0\e[0m until hl) count += (hl-h)%\e[31m16\e[0m == \e[31m0L\e[0m\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                  value += is not a member of Int - did you mean Int.!=?\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val numList = num.split(\"\\\
    \\s\")\n        val numList = numList.filter(_.isDigit)\n        var total = 0l\n\
    \        var digit = 0\n        for (i <- numList) {\n            total += i.toLong\n\
    \            if (i % 2 == 0) {\n                digit += 1\n                if\
    \ (digit >= 3) {\n                    return total\n                }\n      \
    \      }\n            digit = 0\n        }\n        return total\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmxtz7jl6.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mnumList\e[0m = numList.filter(_.isDigit)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mnumList is already defined as \e[33mvalue\e[0m \e[35mnumList\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpmxtz7jl6.scala:32:18 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m            \e[33mif\e[0m (i % \e[31m2\e[0m == \e[31m0\e[0m) {\n\e[31m\e[31m\
    \   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0mvalue % is not a member of\
    \ String, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mThe following import might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val count = new mutable.ListBuffer[Int]()\n\
    \        num match {\n            case hexNum if hexNum.length==0 => 0\n     \
    \       case hexNum if hexNum.length==1 => 1\n            case hexNum if hexNum.length==2\
    \ => 2\n            case hexNum if hexNum.length==3 => 2\n            case hexNum\
    \ if hexNum.length==4 => 3\n            case hexNum if hexNum.length==5 => 3\n\
    \            case hexNum if hexNum.length==6 => 4\n            case hexNum if\
    \ hexNum.length==7 => 5\n            case hexNum if hexNum.length==8 => 5\n  \
    \          case hexNum if hexNum.length==9 => 6\n            case hexNum if hexNum.length==10\
    \ => 6\n            case hexNum if hexNum.length==11 => 7\n            case hexNum\
    \ if hexNum.length==12 => 7\n            case hexNum if hexNum.length==13 => 7\n\
    \            case hexNum if hexNum.length==14 => 8\n            case hexNum if\
    \ hexNum.length==15 => 8\n            case hexNum if hexNum.length==16 => 8\n\
    \            case hexNum if hexNum.length==17 => 9\n            case hexNum if\
    \ hexNum.length==18 => 9\n            case hexNum if hexNum.length==19 => 10\n\
    \            case hexNum if hexNum.length==20 => 10\n            case hexNum if\
    \ hexNum.length==21 => 11\n            case hexNum if hexNum.length==22 => 11\n\
    \            case hexNum if hexNum.length==23 => 11\n            case hexNum if\
    \ hexNum.length==24 => 12\n            case hexNum if hexNum.length==25 => 12\n\
    \            case hexNum if hexNum.length==26 => 12\n            case hexNum if\
    \ hexNum.length==27 => 13\n            case hexNum if hexNum.length==28 => 13\n\
    \            case hexNum if hexNum.length==29 => 13\n            case hexNum if\
    \ hexNum.length==30 => 14\n            case hexNum if hexNum.length==31 => 14\n\
    \            case hexNum if hexNum.length==32 => 14\n            case hexNum if\
    \ hexNum.length==33 => 15\n            case hexNum if hexNum.length==34 => 15\n\
    \            case hexNum if hexNum.length==35 => 15\n            case hexNum if\
    \ hexNum.length==36 => 16\n            case hexNum if hexNum.length==37 => 16\n\
    \            case hexNum if hexNum.length==38 => 16\n            case hexNum if\
    \ hexNum.length==39 => 16\n            case hexNum if hexNum.length==40 => 16\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjezbeh1g.scala:80:0 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjezbeh1g.scala:26:24\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mcount\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpjezbeh1g.scala:79:1 ---------------------\e[0m\e[0m\n\e[31m79\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpjezbeh1g.scala:70:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m70 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009891
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val length = num.length\n  \
    \      if (length == 0)\n            return 0\n        val primes = num.filter(x\
    \ => Character.isLetter(x) && x != \"A\" && x != \"B\" && x != \"C\" && x != \"\
    D\" && x != \"E\" && x != \"F\").map(x => BigInt(x.toUpperCase)).toSet\n     \
    \   val sum = 0\n        for (i <- 2 until length) {\n            val num = num.substring(i,\
    \ i + 1)\n            val prime = primes.find(p => p.toString.toInt == num.toString.toInt)\n\
    \            if (prime != null)\n                sum += prime\n        }\n   \
    \     sum\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpzljj_fs_.scala:29:62 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = num.filter(\e\
    [36mx\e[0m => Character.isLetter(x) && x != \e[31m\"A\"\e[0m && x != \e[31m\"\
    B\"\e[0m && x != \e[31m\"C\"\e[0m && x != \e[31m\"D\"\e[0m && x != \e[31m\"E\"\
    \e[0m && x != \e[31m\"F\"\e[0m).map(\e[36mx\e[0m => BigInt(x.toUpperCase)).toSet\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types Char and String cannot\
    \ be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpzljj_fs_.scala:29:74\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mprimes\e[0m = num.filter(\e[36mx\e[0m => Character.isLetter(x)\
    \ && x != \e[31m\"A\"\e[0m && x != \e[31m\"B\"\e[0m && x != \e[31m\"C\"\e[0m &&\
    \ x != \e[31m\"D\"\e[0m && x != \e[31m\"E\"\e[0m && x != \e[31m\"F\"\e[0m).map(\e\
    [36mx\e[0m => BigInt(x.toUpperCase)).toSet\n\e[31m\e[31m   |\e[0m            \
    \                                                              ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types Char and String cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmpzljj_fs_.scala:29:86 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = num.filter(\e\
    [36mx\e[0m => Character.isLetter(x) && x != \e[31m\"A\"\e[0m && x != \e[31m\"\
    B\"\e[0m && x != \e[31m\"C\"\e[0m && x != \e[31m\"D\"\e[0m && x != \e[31m\"E\"\
    \e[0m && x != \e[31m\"F\"\e[0m).map(\e[36mx\e[0m => BigInt(x.toUpperCase)).toSet\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                              ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of\
    \ types Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpzljj_fs_.scala:29:98 -----------------------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = num.filter(\e[36mx\e\
    [0m => Character.isLetter(x) && x != \e[31m\"A\"\e[0m && x != \e[31m\"B\"\e[0m\
    \ && x != \e[31m\"C\"\e[0m && x != \e[31m\"D\"\e[0m && x != \e[31m\"E\"\e[0m &&\
    \ x != \e[31m\"F\"\e[0m).map(\e[36mx\e[0m => BigInt(x.toUpper"
  stdout: ''
  timestamp: 1660009892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var result = 0L\n        for\
    \ (i <- num.substring(1, num.length).split(\"(?<=\\\\G..)\".r)) {\n          \
    \  result += hexDigits(i)\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps2hkb6fl.scala:27:66\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mfor\e[0m (i <-\
    \ num.substring(\e[31m1\e[0m, num.length).split(\e[31m\"(?<=\\\\G..)\"\e[0m.r))\
    \ {\n\e[31m\e[31m   |\e[0m                                                   \
    \  ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     Found:\
    \    scala.util.matching.Regex\n\e[31m   |\e[0m                              \
    \       Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmps2hkb6fl.scala:28:19 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m            result += hexDigits(i)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Long - did you mean\
    \ Long.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps2hkb6fl.scala:28:22\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            result += hexDigits(i)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                   Not found: hexDigits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009890
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        def hexDigit(digit: Int) : Boolean\
    \ = {\n            // digit > 9 => return false\n            if (digit > 9) {\n\
    \                return false\n            }\n            // digit > 5 => return\
    \ false\n            if (digit > 5) {\n                return false\n        \
    \    }\n            // digit > 3 => return false\n            if (digit > 3) {\n\
    \                return false\n            }\n            // digit > 1 => return\
    \ false\n            if (digit > 1) {\n                return false\n        \
    \    }\n            // digit > 0 => return true\n            return true\n   \
    \     }\n        val arr = num.toCharArray.map(_.toInt)\n        val hexDigitArr\
    \ = arr.filterNot(hexDigit)\n        val hexDigitArr = hexDigitArr.toSeq\n   \
    \     val hexDigitArr = hexDigitArr.distinct\n        val hexDigitArr = hexDigitArr.takeWhile(hexDigit(_))\n\
    \        hexDigitArr.size\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0rvt1__q.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mhexDigitArr\e[0m = hexDigitArr.toSeq\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhexDigitArr is already defined as \e[33mvalue\e[0m \e[35mhexDigitArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0rvt1__q.scala:49:12 ---------------------------\e[0m\e[0m\n\e\
    [31m49 |\e[0m        \e[33mval\e[0m \e[36mhexDigitArr\e[0m = hexDigitArr.distinct\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhexDigitArr is already defined as \e[33mvalue\e[0m \e[35mhexDigitArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0rvt1__q.scala:50:12 ---------------------------\e[0m\e[0m\n\e\
    [31m50 |\e[0m        \e[33mval\e[0m \e[36mhexDigitArr\e[0m = hexDigitArr.takeWhile(hexDigit(_))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhexDigitArr is already defined as \e[33mvalue\e[0m \e[35mhexDigitArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1660009887
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val lnum = num.toLong\n    \
    \    val nums = Array.ofDim[Char](num.length + 1)\n        \n        nums(0) =\
    \ \"0\"\n        \n        val p = lnum / 3\n        val q = lnum % 3\n      \
    \  \n        nums(1) = lnum match {\n            case 0 => \"0\"\n           \
    \ case 1 => \"1\"\n            case 2 => \"2\"\n            case 3 => \"3\"\n\
    \            case 4 => \"4\"\n            case 5 => \"5\"\n            case 6\
    \ => \"6\"\n            case 7 => \"7\"\n            case 8 => \"8\"\n       \
    \     case 9 => \"9\"\n            case 10 => \"A\"\n            case 11 => \"\
    B\"\n            case 12 => \"C\"\n            case 13 => \"D\"\n            case\
    \ 14 => \"E\"\n            case 15 => \"F\"\n            case x => x.toChar\n\
    \        }\n        \n        val i = Array.ofDim[Char](nums.length)\n       \
    \ \n        var j = 0\n        \n        // We go through the digits, each time\
    \ checking if they are prime or not\n        // until we reach a prime (we don't\
    \ need to go through the whole number).\n        // If it is a prime, we add it\
    \ to the array nums\n        // If it is not a prime, we skip it\n        // We\
    \ stop when the number becomes larger than lnum (we stopped checking before\n\
    \        // reaching a prime).\n        while(j < nums.length-1) {\n         \
    \   \n            if((p * q) % nums(j) == 0)\n                nums(j+1) = \"0\"\
    \n            else\n                nums(j+1) = nums(j+1) match {\n          \
    \          case 0 => \"0\"\n                    case 1 => \"1\"\n            \
    \        case 2 => \"2\"\n                    case 3 => \"3\"\n              \
    \      case 4 => \"4\"\n                    case 5 => \"5\"\n                \
    \    case 6 => \"6\"\n                    case 7 => \"7\"\n                  \
    \  case 8 => \"8\"\n                    case 9 => \"9\"\n                    case\
    \ 10 => \"A\"\n                    case 11 => \"B\"\n                    case\
    \ 12 => \"C\"\n                    case 13 => \"D\"\n                    case\
    \ 14 => \"E\"\n                    case 15 => \"F\"\n                    case\
    \ x => x.toChar\n                }\n                \n            if((p * q) >\
    \ lnum)\n                break\n            \n            j+=1\n        }\n  \
    \      \n        val n = \"0\"\n        var nk = -1\n        var kk = 0\n    \
    \    \n        // We start counting from 2 because 0 is the first hexadecimal\
    \ digit\n        // which is not prime\n        for(kk <- 2 until nums.length-1)\
    \ {\n            \n            if(nums(kk) > lnum)\n                break\n  \
    \          \n            val k : Int = 0\n            \n            // We start\
    \ at 0 because 0 is not a prime and we do not need to check it \n            //\
    \ with any of the \n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5cmdoqbg.scala:121:0 ---------------------------\e\
    [0m\e[0m\n\e[31m121 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5cmdoqbg.scala:29:18\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m        nums(\e[31m0\e[0m) =\
    \ \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m                  ^^^\e[0m\n\e[31m  \
    \ |\e[0m                  Found:    (\e[32m\"0\"\e[0m : String)\n\e[31m   |\e\
    [0m                  Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp5cmdoqbg.scala:35:22 --------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m            \e[33mcase\e[0m \e[31m0\e[0m => \e[31m\"0\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                      ^^^\e[0m\n\e[31m   |\e[0m                 \
    \     Found:    (\e[32m\"0\"\e[0m : String)\n\e[31m   |\e[0m                 \
    \     Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5cmdoqbg.scala:36:22\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mcase\e[0m \e\
    [31m1\e[0m => \e[31m\"1\"\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^\e\
    [0m\n\e[31m   |\e[0m                      Found:    (\e[32m\"1\"\e[0m : String)\n\
    \e[31m   |\e[0m                      Required: Char\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp5cmdoqbg.scala:37:22 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mcase\e[0m \e[31m2\e[0m => \e[31m\"\
    2\"\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e[31m   |\e[0m\
    \                      Found:    (\e[32m\"2\"\e[0m : String)\n\e[31m   |\e[0m\
    \                      Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp5cmdoqbg.scala:38:22 --------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m            \e[33mcase\e[0m \e[31m3\e[0m => \e[31m\"3\"\e\
    [0m\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m"
  stdout: ''
  timestamp: 1660009895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val primes = scala.collection.mutable.ArrayBuffer(2,3,5,7)\n\
    \        val nonPrimes = scala.collection.mutable.ArrayBuffer(11,13,17,19,23,29,31,37,41,43,47)\n\
    \        val letters = scala.collection.mutable.ArrayBuffer(A,B,C,D,E,F)\n   \
    \     val decimals = scala.collection.mutable.ArrayBuffer(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47)\n\
    \        var count = 2\n        for (c <- num.toCharArray) {\n            if (letters.contains(c))\
    \ {\n                if (decimals.contains(c)) {\n                    if (primes.contains(count))\
    \ {\n                        count += 1\n                    } else {\n      \
    \                  nonPrimes += count\n                        count = 0\n   \
    \                 }\n                } else {\n                    nonPrimes +=\
    \ count\n                    count = 0\n                }\n            } else\
    \ {\n                if (decimals.contains(c)) {\n                    count +=\
    \ 1\n                } else {\n                    nonPrimes += count\n      \
    \              count = 0\n                }\n            }\n        }\n      \
    \  nonPrimes.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8oddejdn.scala:28:59 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mletters\e[0m = scala.collection.mutable.ArrayBuffer(A,B,C,D,E,F)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \   ^\e[0m\n\e[31m   |\e[0m                                                  \
    \         Not found: A\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8oddejdn.scala:28:61\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mletters\e[0m = scala.collection.mutable.ArrayBuffer(A,B,C,D,E,F)\n\e[31m\e\
    [31m   |\e[0m                                                             ^\e\
    [0m\n\e[31m   |\e[0m                                                         \
    \   Not found: B\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8oddejdn.scala:28:63\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mletters\e[0m = scala.collection.mutable.ArrayBuffer(A,B,C,D,E,F)\n\e[31m\e\
    [31m   |\e[0m                                                               ^\e\
    [0m\n\e[31m   |\e[0m                                                         \
    \   Not found: C\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8oddejdn.scala:28:65\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mletters\e[0m = scala.collection.mutable.ArrayBuffer(A,B,C,D,E,F)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \ ^\e[0m\n\e[31m   |\e[0m                                                    \
    \        Not found: D\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8oddejdn.scala:28:69\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mletters\e[0m = scala.collection.mutable.ArrayBuffer(A,B,C,D,E,F)"
  stdout: ''
  timestamp: 1660009893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        def hexToInt(s : String) : Int\
    \ = {\n            val digits = Iterator.from(s).takeWhile(_.isDigit)\n      \
    \      val digitPairs = digits.length / 2\n            val result = digits\n \
    \               .grouped(digitPairs)\n                .foldLeft(0)((res, pair)\
    \ => res + pair.toChar.asDigit(0) * pair)\n            res % 1000\n        }\n\
    \        val digits = Iterator.from(num).takeWhile(_.isDigit)\n        val digitPairs\
    \ = digits.length / 2\n        val result = digits\n            .grouped(digitPairs)\n\
    \            .foldLeft(0)((res, pair) => res + pair.toChar.asDigit(0) * pair)\n\
    \        res % 1000\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk6o9b5t6.scala:31:55 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                .foldLeft(\e[31m0\e[0m)((res, pair) =>\
    \ res + pair.toChar.asDigit(\e[31m0\e[0m) * pair)\n\e[31m\e[31m   |\e[0m     \
    \                                             ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \    value toChar is not a member of Seq[Char] - did you mean pair.toMap?\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpk6o9b5t6.scala:32:12 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            res % \e[31m1000\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^\e[0m\n\e[31m   |\e[0m            Not found: res\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk6o9b5t6.scala:38:51 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            .foldLeft(\e[31m0\e[0m)((res, pair) => res\
    \ + pair.toChar.asDigit(\e[31m0\e[0m) * pair)\n\e[31m\e[31m   |\e[0m         \
    \                                     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ toChar is not a member of Seq[Char] - did you mean pair.toMap?\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpk6o9b5t6.scala:39:8 -------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        res % \e[31m1000\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^\e[0m\n\e[31m   |\e[0m        Not found: res\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val primes = new mutable.HashSet[Long]()\n\
    \        var count = 0\n        for(a <- num .toCharArray){\n            val number\
    \ = a.toLong\n            if(number == 1){\n                primes += number\n\
    \                count += 2\n            }else{\n                if(number % 2\
    \ == 0 || number % 3 == 0){\n                    primes += number\n          \
    \          count += 2\n                }\n                else if(primes.contains(number)){\n\
    \                    primes += number\n                    count += 2\n      \
    \          }\n                else{\n                    count += 1\n        \
    \        }\n            }\n        }\n        count\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfw8dxiza.scala:26:25 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = \e[33mnew\e\
    [0m mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // TODO: \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0qvbmokb.scala:25:38\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mhexKey\e\
    [0m(\e[36mnum\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m  \
    \ |\e[0m                                      ^\e[0m\n\e[31m   |\e[0m        \
    \                              Found:    Unit\n\e[31m   |\e[0m               \
    \                       Required: Long\n\e[31m26 |\e[0m        \e[34m// TODO:\
    \ \e[0m\n\e[31m27 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        def hexDigit(x: Int): Int =\
    \ if (x >= 0 && x <= 9) x else x - 10 + 26\n        def hexChar(x: Int): Int =\
    \ if (x >= 0 && x <= 9) x else x - 10 + 26\n        val hexCharSet = scala.collection.mutable.Set(hexChar('A'),\
    \ hexChar('B'), hexChar('C'), hexChar('D'), hexChar('E'), hexChar('F'))\n    \
    \    val hexDigitSet = scala.collection.mutable.Set(hexDigit('A'), hexDigit('B'),\
    \ hexDigit('C'), hexDigit('D'), hexDigit('E'), hexDigit('F'))\n        val hexChar2Set\
    \ = scala.collection.mutable.Set(hexChar('A'), hexChar('B'), hexChar('C'), hexChar('D'),\
    \ hexChar('E'), hexChar('F'), hexChar('A'), hexChar('B'), hexChar('C'), hexChar('D'),\
    \ hexChar('E'), hexChar('F'), hexChar('A'), hexChar('B'), hexChar('C'), hexChar('D'),\
    \ hexChar('E'), hexChar('F'))\n        val hexDigit2Set = scala.collection.mutable.Set(hexDigit('A'),\
    \ hexDigit('B'), hexDigit('C'), hexDigit('D'), hexDigit('E'), hexDigit('F'))\n\
    \        val chars = num.toCharArray\n        var numDigits = 0\n        var numChars\
    \ = 0\n        var numHexDigits = 0\n        var numHexChars = 0\n        var\
    \ numHexDigit2s = 0\n        var numHexChar2s = 0\n        for (i <- chars) {\n\
    \            val x = hexDigit(i)\n            numDigits += x\n            numChars\
    \ += if (hexDigitSet contains x) 1 else 0\n            numHexDigits += x\n   \
    \         numHexChars += if (hexCharSet contains x) 1 else 0\n            numHexDigit2s\
    \ += if (hexDigit2Set contains x) 1 else 0\n            numHexChar2s += if (hexChar2Set\
    \ contains x) 1 else 0\n        }\n        (numDigits, numChars, numHexDigits,\
    \ numHexChars, numHexDigit2s, numHexChar2s)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp4okwgbz_.scala:42:24 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            numChars += \e[33mif\e[0m (hexDigitSet contains\
    \ x) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        \
    \                ^^\e[0m\n\e[31m   |\e[0m                        expression expected\
    \ but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp4okwgbz_.scala:44:27 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m            numHexChars += \e[33mif\e[0m (hexCharSet contains x) \e[31m1\e\
    [0m \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                      \
    \     ^^\e[0m\n\e[31m   |\e[0m                           expression expected but\
    \ \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp4okwgbz_.scala:45:29\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m            numHexDigit2s\
    \ += \e[33mif\e[0m (hexDigit2Set contains x) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m                             ^^\e[0m\n\e[31m   |\e[0m\
    \                             expression expected but \e[31mif\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp4okwgbz_.scala:46:28\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m            numHexChar2s\
    \ += \e[33mif\e[0m (hexChar2Set contains x) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m                            ^^\e[0m\n\e[31m   |\e[0m\
    \                            expression expected but \e[31mif\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4okwgbz_.scala:42:21 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            numChars += \e[33mif\e[0m (hexDigitSet contains\
    \ x) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int "
  stdout: ''
  timestamp: 1660009895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexString = num.trim\n \
    \       if (hexString.length == 0) 0\n        else {\n            val (num, hexString1)\
    \ = hexString.split(\"(?!^)\").unzip\n            val num2 = num.toInt\n     \
    \       val (hexString2, hexString3) = hexString1.split(\"(?!^)\").unzip\n   \
    \         val hexString4 = hexString2.trim\n            val hexString5 = hexString3.trim\n\
    \            // num1 can be divided by 3 or 5 or 7 or 11 or 13 or 17 or 19 or\
    \ 23\n            // num2 can be divided by 3 or 5 or 7 or 11 or 13 or 17 or 19\
    \ or 23\n            // so num1 * num2 < hexString4, hexString5 can be divided\
    \ by 3 or 5 or 7 or 11 or 13 or 17 or 19 or 23\n            val hexString6 = hexString4.trim\n\
    \            if (num2 * num2 < hexString6 || hexString5 == \"\" || hexString5\
    \ == \"A\" || hexString5 == \"B\" || hexString5 == \"C\" || hexString5 == \"D\"\
    \ || hexString5 == \"E\" || hexString5 == \"F\") num2 * num2\n            else\
    \ {\n                val hexString7 = hexString5.trim\n                val hexString8\
    \ = hexString7.trim\n                val hexString9 = hexString8.trim\n      \
    \          if (hexString9.length == 0) num2 * num2\n                else {\n \
    \                   val hexString10 = hexString9.trim\n                    val\
    \ hexString11 = hexString10.trim\n                    val hexString12 = hexString11.trim\n\
    \                    val hexString13 = hexString12.trim\n                    if\
    \ (hexString13.length == 0) num2 * num2\n                    else {\n        \
    \                val hexString14 = hexString13.trim\n                        val\
    \ hexString15 = hexString14.trim\n                        val hexString16 = hexString15.trim\n\
    \                        val hexString17 = hexString16.trim\n                \
    \        val hexString18 = hexString17.trim\n                        if (hexString18.length\
    \ == 0) num2 * num2\n                        else {\n                        \
    \    val hexString19 = hexString18.trim\n                            val hexString20\
    \ = hexString19.trim\n                            val hexString21 = hexString20.trim\n\
    \                            val hexString22 = hexString21.trim\n            \
    \                val hexString23 = hexString22.trim\n                        \
    \    val hexString24 = hexString23.trim\n                            val hexString25\
    \ = hexString24.trim\n                            val hexString26 = hexString25.trim\n\
    \                            val hexString27 = hexString26.trim\n            \
    \                val hexString28 = hexString27.trim\n                        \
    \    val hexString29\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2xbqieq7.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2xbqieq7.scala:80:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m80 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- Error: /tmp/tmp2xbqieq7.scala:29:66\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \     \e[33mval\e[0m (num, hexString1) = hexString.split(\e[31m\"(?!^)\"\e[0m).unzip\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \          ^\e[0m\n\e[31m   |\e[0mno given instance of type String => (A1, A2)\
    \ was found for parameter asPair of \e[33mmethod\e[0m \e[35munzip\e[0m in \e[33mclass\e\
    [0m \e[35mArrayOps\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mwhere:    A1 is a type\
    \ variable\n\e[31m   |\e[0m          A2 is a type variable\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmp2xbqieq7.scala:29:17 ---------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m            \e[33mval\e[0m (num, hexString1) = hexString.split(\e\
    [31m\"(?!^)\"\e[0m).unzip\n\e[31m\e[31m   |\e[0m                 ^\e[0m\n\e[31m\
    \   |\e[0m                 Recursive \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2xbqieq7.scala:29:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e\
    [0m (num, hexString1) = hexString.split(\e[31m\"(?!^)\"\e[0m).unzip\n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   Recursive \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2xbqieq7.scala:31:17 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m (hexString2, hexString3) =\
    \ hexString1.split(\e[31m\"(?!^)\"\e[0m).unzip\n\e[31m\e[31m   |\e[0m        \
    \         ^\e[0m\n\e[31m   |\e[0m                 Recursive \e[33mvalue\e[0m \e\
    [35m$2$"
  stdout: ''
  timestamp: 1660009895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val key = mutable.HashSet[Int]()\n\
    \        var counter = 2\n        val hexChars = \"0123456789ABCDEF\"\n      \
    \  val stringChars = num.toCharArray\n        stringChars foreach { c =>\n   \
    \         val i = hexChars.indexOf(c)\n            if(i != -1)\n             \
    \   key.add(i)\n        }\n        while(key.nonEmpty && counter <= hexChars.length)\
    \ {\n            val next = hexChars(key.toSet.next)\n            if(!stringChars.contains(next))\
    \ {\n                counter += 1\n            }\n        }\n        key.toSet.count()\
    \ match {\n            case 0 => 0\n            case _ => (counter - 2)\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"\
    )) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr9aozsh1.scala:26:18 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mkey\e[0m = mutable.HashSet[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var prime : Long = 0\n     \
    \   var counter : Long = 1\n        for (i <- 0 to (hexNum.length - 1)) {\n  \
    \          val hex = hexNum(i).toChar\n            if (hex >= '0' && hex <= '9')\
    \ {\n                prime *= counter\n                prime += hex.toLong\n \
    \               counter += 1\n            }\n            else {\n            \
    \    counter += 1\n            }\n        }\n        prime\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6a51ks2c.scala:28:24 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m to (hexNum.length\
    \ - \e[31m1\e[0m)) {\n\e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Not found: hexNum\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp6a51ks2c.scala:29:22 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mhex\e[0m = hexNum(i).toChar\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                Not found: hexNum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        def isPrime(num: Long, divisor:\
    \ Long) : Boolean = {\n            val sqrt = (num * num + divisor * divisor)\
    \ / 2L\n            divisor <= 1L || sqrt <= 1L || sqrt % divisor != 0L\n    \
    \    }\n        val hexDigits = num.toCharArray.map(_ => hexValue(_)).toList\n\
    \        var primeCount = 0\n        var prime = 0L\n        for (hexDigit <-\
    \ hexDigits) {\n            prime = hexValue(hexDigit)\n            if (isPrime(prime,\
    \ 2L)) {\n                primeCount += 1\n            }\n        }\n        prime\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpm8wt0cux.scala:30:58 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhexDigits\e[0m = num.toCharArray.map(_\
    \ => hexValue(_)).toList\n\e[31m\e[31m   |\e[0m                              \
    \                            ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => hexValue(_$2).\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpm8wt0cux.scala:30:49 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhexDigits\e[0m = num.toCharArray.map(_\
    \ => hexValue(_)).toList\n\e[31m\e[31m   |\e[0m                              \
    \                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \                      Not found: hexValue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpm8wt0cux.scala:34:20 ------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m            prime = hexValue(hexDigit)\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ hexValue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009894
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val primes = mutable.Buffer[Long]()\n\
    \        // You have been tasked to write a function that receives \n        //\
    \ a hexadecimal number as a string and counts the number of hexadecimal \n   \
    \     // digits that are primes (prime number, or a prime, is a natural number\
    \ \n        // greater than 1 that is not a product of two smaller natural numbers).\n\
    \        // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E,\
    \ F.\n        // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n        // So you\
    \ have to determine a number of the following digits: 2, 3, 5, 7, \n        //\
    \ B (=decimal 11), D (=decimal 13).\n        // Note: you may assume the input\
    \ is always correct or empty string, \n        // and symbols A,B,C,D,E,F are\
    \ always uppercase.\n        // Examples:\n        // >>> hexKey((\"AB\"))\n \
    \       // (1l)\n        // >>> hexKey((\"1077E\"))\n        // (2l)\n       \
    \ // >>> hexKey((\"ABED1A33\"))\n        // (4l)\n        // >>> hexKey((\"123456789ABCDEF0\"\
    ))\n        // (6l)\n        // >>> hexKey((\"2020\"))\n        // (2l)\n\n  \
    \      def isPrime(i: Long, primes: List[Long]): Boolean = {\n            primes.contains(i)\n\
    \        }\n        def isPrime(i: Long): Boolean = {\n            if (primes.contains(i))\n\
    \            {\n                true\n            }\n            else\n      \
    \      {\n                var test2 = i/2\n                while (test2 > 1)\n\
    \                {\n                    if (isPrime(test2, primes)) \n       \
    \             {\n                        return true\n                    }\n\
    \                    else\n                    {\n                        test2\
    \ -= 1\n                    }\n                }\n            }\n            return\
    \ false\n        }\n        def isPrime(i: Long, primes: mutable.Buffer[Long])\
    \ : Boolean = {\n            primes.contains(i)\n        }\n\n        // You have\
    \ been tasked to write a function that receives \n        // a hexadecimal number\
    \ as a string and counts the number of hexadecimal \n        // digits that are\
    \ primes (prime number, or a prime, is a natural number \n        // greater than\
    \ 1 that is not a product of two smaller natural numbers).\n        // Hexadecimal\
    \ digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n        // Prime\
    \ numbers are 2, 3, 5, 7, 11, 13, 17,...\n        // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n        // B (=decimal 11),\
    \ D (=decimal 13).\n        // Note: you may assume the input is always correct\
    \ or empty string, \n        // and symbols A,B,C,D,E,F are always uppercase.\n\
    \        // Examples:\n        // >>> hexKey((\"AB\"))\n        // (1\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy2txcal4.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mdef\e[0m \e[36misPrime\e[0m(\e[36mi\e[0m:\
    \ \e[35mLong\e[0m): \e[35mBoolean\e[0m = {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\
    \e[31m   |\e[0misPrime is already defined as \e[33mmethod\e[0m \e[35misPrime\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m53 |\e[0m         \
    \   \e[33mif\e[0m (primes.contains(i))\n\e[31m54 |\e[0m            {\n\e[31m55\
    \ |\e[0m                \e[31mtrue\e[0m\n\e[31m56 |\e[0m            }\n\e[31m57\
    \ |\e[0m            \e[33melse\e[0m\n\e[31m58 |\e[0m            {\n\e[31m59 |\e\
    [0m                \e[33mvar\e[0m \e[36mtest2\e[0m = i/\e[31m2\e[0m\n\e[31m60\
    \ |\e[0m                \e[33mwhile\e[0m (test2 > \e[31m1\e[0m)\n\e[31m61 |\e\
    [0m                {\n\e[31m62 |\e[0m                    \e[33mif\e[0m (isPrime(test2,\
    \ primes)) \n\e[31m63 |\e[0m                    {\n\e[31m64 |\e[0m           \
    \             \e[33mreturn\e[0m \e[31mtrue\e[0m\n\e[31m65 |\e[0m             \
    \       }\n\e[31m66 |\e[0m                    \e[33melse\e[0m\n\e[31m67 |\e[0m\
    \                    {\n\e[31m68 |\e[0m                        test2 -= \e[31m1\e\
    [0m\n\e[31m69 |\e[0m                    }\n\e[31m70 |\e[0m                }\n\e\
    [31m71 |\e[0m            }\n\e[31m72 |\e[0m            \e[33mreturn\e[0m \e[31mfalse\e\
    [0m\n\e[31m73 |\e[0m        }\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy2txcal4.scala:74:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m74 |\e[0m        \e[33mdef\e[0m\
    \ \e[36misPrime\e[0m(\e[36mi\e[0m: \e[35mLong\e[0m, \e[36mprimes\e[0m: mutable.Buffer[\e\
    [35mLong\e[0m]) : \e[35mBoolean\e[0m = {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\
    \e[31m   |\e[0misPrime is already defined as \e[33mmethod\e[0m \e[35misPrime\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m75 |\e[0m         \
    \   primes.contains(i)\n\e[31m76 |\e[0m        }\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpy2txcal4.scala:26:21 ------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = mutable.Buffer[\e[35mLon"
  stdout: ''
  timestamp: 1660009897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Convert string to array of\
    \ characters:\n        var numArr = num.toCharArray.filterNot(Character.isDigit).toArray\n\
    \        \n        // Find primes less than or equal to numArr\n        var numPrimes\
    \ = 0\n        var i = 2\n        var primes = mutable.ArrayBuffer(2, 3, 5, 7,\
    \ 11, 13, 17, 19)\n        var primeCount = primes.length\n        while (i *\
    \ i < numArr.length && primeCount > 0) {\n            if (numArr(i * i) == numArr(i))\
    \ {\n                primeCount -= 1\n            } else {\n                primes\
    \ += primeCount\n                primeCount -= 1\n            }\n            i\
    \ += 2\n        }\n\n        // Find digits in primes\n        var digits = primes.filter(_\
    \ % numArr(0) == 0).length\n        for (prime <- primes) {\n            digits\
    \ += numArr.filterNot(_ == numArr(0)).filter(_ % prime == 0).length\n        }\n\
    \        \n        // Return count\n        digits.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdpag88m9.scala:32:21 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m \e[36mprimes\e[0m = mutable.ArrayBuffer(\e\
    [31m2\e[0m, \e[31m3\e[0m, \e[31m5\e[0m, \e[31m7\e[0m, \e[31m11\e[0m, \e[31m13\e\
    [0m, \e[31m17\e[0m, \e[31m19\e[0m)\n\e[31m\e[31m   |\e[0m                    \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hex = num.toCharArray.map(_\
    \ - 48).toList\n        val bitSet = hex.foldLeft(0) { (s, b) => s << 1 + b }\n\
    \        val primeBits = primeBitSet\n        val resultBits = hex.foldLeft(0)\
    \ { (s, b) => s << 1 + primeBits(b) }\n        resultBits % hex.size + 1\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb1vmr_us.scala:28:24 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mprimeBits\e[0m = primeBitSet\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                        Not found: primeBitSet\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var count = 0\n        var digits\
    \ = num.toCharArray()\n        for( i <- 0 until digits.length ) {\n         \
    \   if( i % 2 == 0 ) {\n                if( digits(i) == 'A' || digits(i) == 'B'\
    \ ) {\n                    count += 1\n                }\n                else\
    \ if( digits(i) == 'D' || digits(i) == 'E' ) {\n                    count += 1\n\
    \                }\n                else {\n                    count += 0\n \
    \               }\n            }\n        }\n        count\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4ujz9lnm.scala:45)\n\tat Problem.main(tmp4ujz9lnm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009898
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        import scala.util.parsing.combinator._\n\
    \        val digits = num.grouped(2).map(_.toChar)\n        val charMap = Map(\n\
    \            \"A\"->1, \"B\"->2, \"C\"->3, \"D\"->4, \"E\"->5, \"F\"->6\n    \
    \    )\n        val len = digits.length\n        val sumOfDigits = digits map\
    \ {x => if (charMap.get(x) != null) 1 \n        else charMap.get(x) match { case\
    \ 0 => 2 }\n        }.reduceLeft(_ + _)\n        val hexCount = num.length % 2\n\
    \        val totalDigits = hexCount * 2 + len\n        val totalNum = digits.length\
    \ + sumOfDigits + (hexCount * hexCount)\n        if (totalNum >= totalDigits)\
    \ 0\n        else num.length.toLong / totalNum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpunpcvz19.scala:26:26 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mimport\e[0m scala.util.parsing.combinator._\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \     value parsing is not a member of util - did you mean util.Sorting?\n\e[31m\e\
    [31m-- [E049] Reference Error: /tmp/tmpunpcvz19.scala:27:21 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = num.grouped(\e\
    [31m2\e[0m).map(_.toChar)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\
    \e[31m   |\e[0mReference to num is ambiguous,\n\e[31m   |\e[0mit is both defined\
    \ in \e[33mmethod\e[0m \e[35mhexKey\e[0m\n\e[31m   |\e[0mand imported subsequently\
    \ by import (<error value parsing is not a member of util - did you mean util.Sorting?>#\n\
    \e[31m   |\e[0m  combinator\n\e[31m   |\e[0m : <error value parsing is not a member\
    \ of util - did you mean util.Sorting?>)._\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E049]\
    \ Reference Error: /tmp/tmpunpcvz19.scala:35:23 ------------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mhexCount\e[0m = num.length %\
    \ \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                       ^^^\e[0m\n\e[31m \
    \  |\e[0mReference to num is ambiguous,\n\e[31m   |\e[0mit is both defined in\
    \ \e[33mmethod\e[0m \e[35mhexKey\e[0m\n\e[31m   |\e[0mand imported subsequently\
    \ by import (<error value parsing is not a member of util - did you mean util.Sorting?>#\n\
    \e[31m   |\e[0m  combinator\n\e[31m   |\e[0m : <error value parsing is not a member\
    \ of util - did you mean util.Sorting?>)._\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E049]\
    \ Reference Error: /tmp/tmpunpcvz19.scala:39:13 ------------------------\e[0m\e\
    [0m\n\e[31m39 |\e[0m        \e[33melse\e[0m num.length.toLong / totalNum\n\e[31m\e\
    [31m   |\e[0m             ^^^\e[0m\n\e[31m   |\e[0mReference to num is ambiguous,\n\
    \e[31m   |\e[0mit is both defined in \e[33mmethod\e[0m \e[35mhexKey\e[0m\n\e[31m\
    \   |\e[0mand imported subsequently by import (<error value parsing is"
  stdout: ''
  timestamp: 1660009896
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        def isPrime(n : Int) : Boolean\
    \ = {\n            var isPrime = false\n            while (n > 1) {\n        \
    \        if (n % 2 == 0) {\n                    isPrime = true\n             \
    \       n = n + 1\n                } else {\n                    if (n == 3) {\n\
    \                        isPrime = true\n                        break\n     \
    \               } else if (n % 2 == 1) {\n                        isPrime = false\n\
    \                        break\n                    }\n                    n =\
    \ n / 2\n                }\n            }\n            isPrime\n        }\n  \
    \      val numAsIntArray = num.split(\"\").toList.toArray.map(_.toInt)\n     \
    \   val result = 0L\n        for (i <- 0 until numAsIntArray.length-1) {\n   \
    \         val n1 = numAsIntArray(i)\n            val n2 = numAsIntArray(i+1)\n\
    \            val isPrime = isPrime(n1)\n            if (isPrime) {\n         \
    \       val n3 = numAsIntArray(i+2)\n                val n4 = numAsIntArray(i+3)\n\
    \                if (n4 != 0) {\n                    val n5 = numAsIntArray(i+4)\n\
    \                    val n6 = numAsIntArray(i+5)\n                    if (n6 !=\
    \ 0) {\n                        val n7 = numAsIntArray(i+6)\n                \
    \        val n8 = numAsIntArray(i+7)\n                        if (n8 != 0) {\n\
    \                            val n9 = numAsIntArray(i+8)\n                   \
    \         val n10 = numAsIntArray(i+9)\n                            val n11 =\
    \ numAsIntArray(i+10)\n                            val n12 = numAsIntArray(i+11)\n\
    \                            val n13 = numAsIntArray(i+12)\n                 \
    \           val n14 = numAsIntArray(i+13)\n                            val n15\
    \ = numAsIntArray(i+14)\n                            val n16 = numAsIntArray(i+15)\n\
    \                            val n17 = numAsIntArray(i+16)\n                 \
    \           val n18 = numAsIntArray(i+17)\n                            val n19\
    \ = numAsIntArray(i+18)\n                            val n20 = numAsIntArray(i+19)\n\
    \                            val n21 = numAsIntArray(i+20)\n                 \
    \           val n22 = numAsIntArray(i+21)\n                            val n23\
    \ = numAsIntArray(i+22)\n                            val n24 = numAsIntArray(i+23)\n\
    \                            val n25 = numAsIntArray(i+24)\n                 \
    \           val n26 = numAsIntArray(i+25)\n                            val n27\
    \ = numAsIntArray(i+26)\n                            val n28 = numAsIntArray(i+27)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_bel2tkf.scala:92:0 ----------------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp_bel2tkf.scala:31:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                   \
    \ n = n + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                    Reassignment to val n\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp_bel2tkf.scala:35:24 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_bel2tkf.scala:38:24\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                        break\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmp_bel2tkf.scala:40:22 -----------------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m                    n = n / \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment\
    \ to val n\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_bel2tkf.scala:47:8\
    \ ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m until numAsIntArray.length-\e[31m1\e[0m) {\n\e[31m\e[31m   |\e\
    [0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m    \
    \    Required: Long\n\e[31m48 |\e[0m            \e[33mval\e[0m \e[36mn1\e[0m =\
    \ numAsIntArray(i)\n\e[31m49 |\e[0m            \e[33mval\e[0m \e[36mn2\e[0m =\
    \ numAsIntArray(i+\e[31m1\e[0m)\n\e[31m50 |\e[0m            \e[33mval\e[0m \e\
    [36misPrime\e[0m = isPri"
  stdout: ''
  timestamp: 1660009900
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Your code here\n        var\
    \ count = 0\n        // Convert string to array, then to string\n        num.toString.toArray().toList.filterNot(x\
    \ => x.toString.toChar.isDigit).filterNot(x => x.toString.toChar.isLetter).foreach\
    \ { x =>\n            // If the char is number, add it to count\n            if\
    \ (x.toString.toChar.isDigit) {\n                count += 1\n            }\n \
    \       }\n        count + (if (num.isEmpty || num.toString.toChar == 'F') 2 else\
    \ 0)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"\
    )) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp20lvbret.scala:29:28 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        num.toString.toArray().toList.filterNot(\e[36mx\e\
    [0m => x.toString.toChar.isDigit).filterNot(\e[36mx\e[0m => x.toString.toChar.isLetter).foreach\
    \ { \e[36mx\e[0m =>\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmissing argument for parameter tag of \e[33mmethod\e[0m \e[35mtoArray\e\
    [0m in \e[33mclass\e[0m \e[35mStringOps\e[0m: (\e[33mimplicit \e[0mtag: scala.reflect.ClassTag[B]):\
    \ Array[B]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp20lvbret.scala:35:49\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        count + (\e[33mif\e\
    [0m (num.isEmpty || num.toString.toChar == \e[31m'F'\e[0m) \e[31m2\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  value toChar is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1660009899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val digits = num.split(\"\"\
    ).toList\n        val numKeySet = digits.length + 1 toSet\n        for (d <- digits)\
    \ {\n            if (!numKeySet.contains(d.toInt)) {\n                numKeySet.add(d.toInt)\n\
    \            }\n        }\n        val numKeySetSize = numKeySet.toSet.size\n\
    \        val hexKeySet = numKeySet.toSet map (_ % 10).toSet\n        val hexKeySetSize\
    \ = hexKeySet.toSet.size\n        numKeySet.toSet map { _ => (numKeySetSize -\
    \ hexKeySetSize) }.toList\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpopr58fpo.scala:27:47 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mnumKeySet\e[0m = digits.length\
    \ + \e[31m1\e[0m toSet\n\e[31m\e[31m   |\e[0m                                \
    \               ^\e[0m\n\e[31m   |\e[0m                                      \
    \ expression expected but \e[31mfor\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val digits = num.toList\n  \
    \      val charArray = digits.toArray\n        val numString = new String(charArray).replaceAll(\"\
    0\", \"\").replaceAll(\"A\", \"\")\n        val hexDigitsArray = numString.toList.toArray.grouped(4).toList\n\
    \        val primes = hexDigitsArray.filter(_ > 1).filter(_ % 2 == 0).map(_ *\
    \ 2)\n        val numHexDigitsToSum = hexDigitsArray.size - primes.size\n    \
    \    val sum = hexDigitsArray.reduceLeft(_ + _)\n        numHexDigitsToSum * hexDigitsArray.size\
    \ * (hexDigitsArray.size - 1) * sum / sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph_iqb2kx.scala:30:45 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = hexDigitsArray.filter(_\
    \ > \e[31m1\e[0m).filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).map(_ * \e[31m2\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                           ^^^\e[0m\n\e[31m\
    \   |\e[0mvalue > is not a member of Array[Char], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import\
    \ math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmph_iqb2kx.scala:30:59 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = hexDigitsArray.filter(_\
    \ > \e[31m1\e[0m).filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).map(_ * \e[31m2\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^\e[0m\n\e[31m   |\e[0mvalue % is not a member of Array[Char], but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe\
    \ following import might make progress towards fixing the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m\
    \   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph_iqb2kx.scala:30:75\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mprimes\e[0m = hexDigitsArray.filter(_ > \e[31m1\e[0m).filter(_ % \e[31m2\e\
    [0m == \e[31m0\e[0m).map(_ * \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \                                                             ^^^\e[0m\n\e[31m\
    \   |\e[0mvalue * is not a member of Array[Char], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n"
  stdout: ''
  timestamp: 1660009903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        require(num.length == hexDigits.length,\
    \ \n            s\"Error: input length must be exactly ${hexDigits.length}\")\n\
    \n        var hex : Long = 0\n        for(i <- 0 until num.length) {\n       \
    \     val n = num(i)\n            hex = hex + hexDigits.indexOf(n)\n        }\n\
    \        hex\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqe_xpd35.scala:26:30 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        require(num.length == hexDigits.length, \n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: hexDigits\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqe_xpd35.scala:27:52 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[31ms\"Error: input length must be exactly\
    \ \e[0m${hexDigits.length}\e[31m\"\e[0m)\n\e[31m\e[31m   |\e[0m              \
    \                                      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                             Not found: hexDigits\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqe_xpd35.scala:32:24 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            hex = hex + hexDigits.indexOf(n)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \               Not found: hexDigits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009898
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexKeys : mutable.Set[String]\
    \ = mutable.Set(\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"\
    , \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\")\n        val hexKeysLength\
    \ = hexKeys.size\n        val hexNum = hexKeys.toSet.diff(hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet\
    \ + hexKeys.toSet + hexKeys.toSet + hexKeys.toSet \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8ayk1gtz.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8ayk1gtz.scala:26:22\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mhexKeys\e[0m : mutable.Set[\e[35mString\e[0m] = mutable.Set(\e[31m\"0\"\e\
    [0m, \e[31m\"1\"\e[0m, \e[31m\"2\"\e[0m, \e[31m\"3\"\e[0m, \e[31m\"4\"\e[0m, \e\
    [31m\"5\"\e[0m, \e[31m\"6\"\e[0m, \e[31m\"7\"\e[0m, \e[31m\"8\"\e[0m, \e[31m\"\
    9\"\e[0m, \e[31m\"A\"\e[0m, \e[31m\"B\"\e[0m, \e[31m\"C\"\e[0m, \e[31m\"D\"\e\
    [0m, \e[31m\"E\"\e[0m, \e[31m\"F\"\e[0m)\n\e[31m\e[31m   |\e[0m              \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8ayk1gtz.scala:26:44\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mhexKeys\e[0m : mutable.Set[\e[35mString\e[0m] = mutable.Set(\e[31m\"0\"\e\
    [0m, \e[31m\"1\"\e[0m, \e[31m\"2\"\e[0m, \e[31m\"3\"\e[0m, \e[31m\"4\"\e[0m, \e\
    [31m\"5\"\e[0m, \e[31m\"6\"\e[0m, \e[31m\"7\"\e[0m, \e[31m\"8\"\e[0m, \e[31m\"\
    9\"\e[0m, \e[31m\"A\"\e[0m, \e[31m\"B\"\e[0m, \e[31m\"C\"\e[0m, \e[31m\"D\"\e\
    [0m, \e[31m\"E\"\e[0m, \e[31m\"F\"\e[0m)\n\e[31m\e[31m   |\e[0m              \
    \                              ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp8ayk1gtz.scala:29:5 ---------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009901
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexString = num.filter(x\
    \ => x.isHexDigit).mkString.toLong\n        val bits = hexString.toCharArray\n\
    \        val bitCount = bits.length\n        val keyDigits = bitCount(2)\n   \
    \     val hexDigits = bitCount(3)\n        val newBits = new Array[String](bitCount)\n\
    \        val result = new Array[Boolean](keyDigits)\n        val primes = Array(2,\
    \ 3, 5, 7, 11, 13, 17)\n        var i = 1\n        while (i < bitCount) {\n  \
    \          if (bits(i) == 'A' || bits(i) == 'B') { \n                val hexAtoi\
    \ = (hexString.toLong - hexString.toLong * hexDigits(2)) / 2\n               \
    \ val hexAtoj = (hexString.toLong - hexString.toLong * hexDigits(3)) / 3\n   \
    \             val hexAtok = hexString.toLong - hexString.toLong * hexDigits(4)\
    \ / 4\n                val hexAtol = hexString.toLong - hexString.toLong * hexDigits(5)\
    \ / 5\n                val hexAtom = hexString.toLong - hexString.toLong * hexDigits(6)\
    \ / 6\n                val hexAton = hexString.toLong - hexString.toLong * hexDigits(7)\
    \ / 7\n                val hexAtoo = hexString.toLong - hexString.toLong * hexDigits(8)\
    \ / 8\n                val hexAtop = hexString.toLong - hexString.toLong * hexDigits(9)\
    \ / 9\n                val hexAtoq = hexString.toLong - hexString.toLong * hexDigits(10)\
    \ / 10\n                val hexAtor = hexString.toLong - hexString.toLong * hexDigits(11)\
    \ / 11\n                val hexAtos = hexString.toLong - hexString.toLong * hexDigits(12)\
    \ / 12\n                val hexAtot = hexString.toLong - hexString.toLong * hexDigits(13)\
    \ / 13\n                val hexAtou = hexString.toLong - hexString.toLong * hexDigits(14)\
    \ / 14\n                val hexAtov = hexString.toLong - hexString.toLong * hexDigits(15)\
    \ / 15\n                val hexAtow = hexString.toLong - hexString.toLong * hexDigits(16)\
    \ / 16\n                val hexAtox = hexString.toLong - hexString.toLong * hexDigits(17)\
    \ / 17\n                val hexAtoy = hexString.toLong - hexString.toLong * hexDigits(18)\
    \ / 18\n                val hexAto\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmped1qryvw.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmped1qryvw.scala:66:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m66 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmped1qryvw.scala:26:42 ------------------------\e[0m\e[0m\n\
    \e[31m26 |\e[0m        \e[33mval\e[0m \e[36mhexString\e[0m = num.filter(\e[36mx\e\
    [0m => x.isHexDigit).mkString.toLong\n\e[31m\e[31m   |\e[0m                  \
    \                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \            value isHexDigit is not a member of Char\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmped1qryvw.scala:27:29 ------------------------\e[0m\e[0m\n\
    \e[31m27 |\e[0m        \e[33mval\e[0m \e[36mbits\e[0m = hexString.toCharArray\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                   value toCharArray is not a member of Long\n\e[33m\e[33m--\
    \ Warning: /tmp/tmped1qryvw.scala:56:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m56 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660009904
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var total = 0L\n        val\
    \ numLength = num.length\n        for(i <- 0 until numLength) {\n            val\
    \ d = num(i).toInt\n            for(j <- 0 until d) {\n                total +=\
    \ (if(isPrime(j)) j.toLong else 0L)\n            }\n        }\n        total\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmu7bkzzo.scala:31:22 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                total += (\e[33mif\e[0m(isPrime(j)) j.toLong\
    \ \e[33melse\e[0m \e[31m0L\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                value += is not a member of Long - did you\
    \ mean Long.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmu7bkzzo.scala:31:29\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                total +=\
    \ (\e[33mif\e[0m(isPrime(j)) j.toLong \e[33melse\e[0m \e[31m0L\e[0m)\n\e[31m\e\
    [31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                       Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val numArray = num.toCharArray()\n\
    \        val charArray = numArray.map(_.toUpperCase)\n        val hexArray = charArray.map(x=>\
    \ (x.toLong, x.toLong % 16L))\n        var count = 0L\n        var i = hexArray.size\
    \ - 1\n        var j = 0\n        while (i>=0){\n            count += hexArray(i)._1\n\
    \            i -= 1\n            j+=1\n        }\n        count += hexArray(j)._1\n\
    \        count\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6xnfjvke.scala:27:39 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcharArray\e[0m = numArray.map(_.toUpperCase)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               value toUpperCase is not a member\
    \ of Char\n\e[31m\e[31m-- Error: /tmp/tmp6xnfjvke.scala:27:51 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcharArray\e[0m = numArray.map(_.toUpperCase)\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0m                                          No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                    \
    \      where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660009905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val ns: StringBuffer = new StringBuffer(num)\n\
    \        val str: List[Char] = ns.getChars().toList\n        val len = str.length\n\
    \        val primes = List[Long](2,3,5,7,11,13,17,19)\n        val map: mutable.Map[Long,\
    \ Long] = mutable.Map[Long, Long]()\n        val maps: mutable.Map[Long, Long]\
    \ = mutable.Map[Long, Long]()\n        def checkPrime(prime : Long) : Boolean\
    \ = {\n            prime in primes\n        }\n        def checkPrime2(prime :\
    \ Long) : Boolean = {\n            prime in primes.reverse\n        }\n      \
    \  def checkPrime3(prime : Long) : Boolean = {\n            for (x <- primes.takeWhile(checkPrime)){\n\
    \                if (prime == x) {\n                    true\n               \
    \ } else if (prime != x && prime < x){\n                    false\n          \
    \      } else if (prime > x){\n                    prime > x\n               \
    \ }\n            }\n        }\n        for(i <- 0 until len){\n            val\
    \ val = str.apply(i)\n            val dec = str.apply(i).toInt\n            val\
    \ numDigits = str.length\n            val digit = dec % 10\n            val power\
    \ = dec / 10\n            if (checkPrime(power)) {\n                map(power)\
    \ += 1\n                if (map.contains(power)) {\n                    maps(power)\
    \ += 1\n                }\n                if(!map.contains(power) && !maps.contains(power))\
    \ {\n                    map(power) += 1\n                    if (map.contains(power))\
    \ {\n                        maps(power) += 1\n                    }\n       \
    \         }\n            }\n        }\n        val nn = str\n        for(x <-\
    \ primes){\n            val num = x\n            val primesNum = nn.filterNot(x\
    \ => x == num)\n            val primesNum2 = primesNum.filterNot(x => x == num)\n\
    \            val primesNum3 = primesNum2.filterNot(x => x == num)\n          \
    \  if (checkPrime2(primesNum2) == checkPrime3(primesNum3)){\n                return\
    \ x\n            }\n        }\n        return 0l\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpph4gbrse.scala:50:16 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m            \e[33mval\e[0m \e[33mval\e[0m = str.apply(i)\n\
    \e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m               \
    \ pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpph4gbrse.scala:27:41\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mstr\e[0m: \e[35mList\e[0m[\e[35mChar\e[0m] = ns.getChars().toList\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mnot enough arguments for \e[33mmethod\e[0m \e[35mgetChars\e[0m in \e\
    [33mclass\e[0m \e[35mStringBuffer\e[0m: (x$0: Int, x$1: Int, x$2: Array[Char],\
    \ x$3: Int): Unit\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpph4gbrse.scala:30:17\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mmap\e[0m: mutable.Map[\e[35mLong\e[0m, \e[35mLong\e[0m] = mutable.Map[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                 ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpph4gbrse.scala:30:43 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m: mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m] = mutable.Map[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpph4gbrse.scala:31:18\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mmaps\e[0m: mutable.Map[\e[35mLong\e[0m, \e[35mLong\e[0m] = mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation ava"
  stdout: ''
  timestamp: 1660009905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val digits = num.map(x => x.toChar)\n\
    \        val hexa = digits.map(x => x.toInt)\n        val primes = primes().toList\n\
    \        val result = hexa.zip(primes).map{case (h,p) => if (p == 1) (h,1) else\
    \ (h,0) }.countBy{case (h,c) => c}\n        result.maxBy(_._1)._1\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n \
    \   assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5e8n7ir2.scala:28:21 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = primes().toList\n\
    \e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m            \
    \         Recursive \e[33mvalue\e[0m \e[35mprimes\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5e8n7ir2.scala:29:87 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = hexa.zip(primes).map{\e\
    [33mcase\e[0m (h,p) => \e[33mif\e[0m (p == \e[31m1\e[0m) (h,\e[31m1\e[0m) \e[33melse\e\
    [0m (h,\e[31m0\e[0m) }.countBy{\e[33mcase\e[0m (h,c) => c}\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue countBy is not a member of IndexedSeq[(Int, Int)] -\
    \ did you mean IndexedSeq[(Int, Int)].count?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009904
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val arr = num.split(\"(?!^)(?=\\\
    \\d)\").map(_.toLong).toArray\n        var count = 0\n        for (x<-arr) {\n\
    \            // only consider even numbers\n            if (x%2 == 0)\n      \
    \          count += 1\n        }\n        \n        // first check if num is a\
    \ prime\n        var count = 0\n        for (i<-0 until arr.length) {\n      \
    \      // only consider even numbers\n            if (arr(i) % 2 == 0)\n     \
    \           count += 1\n        }\n        \n        // now check if num is prime\n\
    \        if (count == 0) {\n            // count the number of odd numbers in\
    \ arr\n            var count = 0\n            for (x<-0 until arr.length) {\n\
    \                // only consider odd numbers\n                if (arr(x) % 2\
    \ == 1)\n                    count += 1\n            }\n            // if the\
    \ count is odd, num is a prime\n            if (count % 2 == 1)\n            \
    \    count += 2\n        }\n        // return the count as a long\n        count.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps2ef5usm.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mvar\e[0m \e[36mcount\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcount is already\
    \ defined as \e[33mvariable\e[0m \e[35mcount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n1 error found\n"
  stdout: ''
  timestamp: 1660009902
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // 1. We must convert the hexadecimal\
    \ string to decimal string, \n        // by appending 0x to it (\"AB\" => \"0xAB\"\
    ), then convert it to \n        // a byte array.\n        // 2. Let's use groupBy\
    \ and filter method of collections, \n        // where groupBy will group all\
    \ elements with the same value, \n        // and filter will keep only those elements\
    \ that satisfy the given \n        // predicate function.\n        // 3. Since\
    \ we want to keep only the primes, we must apply some \n        // kind of filter\
    \ to remove all the non-primes elements, and \n        // finally return the length\
    \ of the resulting collection.\n        // 4. We use toList to convert it into\
    \ a mutable list. The toList \n        // method will convert the mutable list\
    \ to immutable list, and return \n        // it.\n        num.toByteArray().grouped(4).filter(i\
    \ => {\n            // 5. We use the isPrime method of scala.math library to \n\
    \            // determine if a number is prime or not.\n            isPrime(i._1)\n\
    \        }).map(i => {\n            // 6. In the map method, we need to convert\
    \ the byte array to \n            // a decimal string, and return a tuple with\
    \ the string and \n            // the number as a long.\n            val str =\
    \ i._1.toString(16)\n            str.substring(str.length-1)\n        }).toList.length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbp31vp3l.scala:39:12 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        num.toByteArray().grouped(\e[31m4\e[0m).filter(\e\
    [36mi\e[0m => {\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        value toByteArray is not a member of String\n1 error found\n"
  stdout: ''
  timestamp: 1660009903
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val list = num.chars.toList\n\
    \        var count : Int = 0\n        var i : Int = 0\n        var j : Int = 0\n\
    \        var prime = 0\n        while(i < list.length) {\n            prime =\
    \ (prime == 0) || (prime == 1) || (list(i).toUpperCase == \"A\") || (list(i).toUpperCase\
    \ == \"B\") || (list(i).toUpperCase == \"C\") || (list(i).toUpperCase == \"D\"\
    ) || (list(i).toUpperCase == \"E\") || (list(i).toUpperCase == \"F\")\n      \
    \      if(list(i).toUpperCase == \"0\") count++\n            if(prime == true\
    \ && list.take(i).toUpperCase == \"2\") count++\n            i = i + 1\n     \
    \   }\n        count = count + 1\n        return count\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpdr70uc15.scala:33:50 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mif\e[0m(list(i).toUpperCase == \e[31m\"\
    0\"\e[0m) count++\n\e[31m\e[31m   |\e[0m                                     \
    \             ^\e[0m\n\e[31m   |\e[0m                                        expression\
    \ expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpdr70uc15.scala:26:29 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mlist\e[0m = num.chars.toList\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value\
    \ toList is not a member of java.util.stream.IntStream\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpdr70uc15.scala:32:20 --------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m            prime = (prime == \e[31m0\e[0m) || (prime == \e\
    [31m1\e[0m) || (list(i).toUpperCase == \e[31m\"A\"\e[0m) || (list(i).toUpperCase\
    \ == \e[31m\"B\"\e[0m) || (list(i).toUpperCase == \e[31m\"C\"\e[0m) || (list(i).toUpperCase\
    \ == \e[31m\"D\"\e[0m) || (list(i).toUpperCase == \e[31m\"E\"\e[0m) || (list(i).toUpperCase\
    \ == \e[31m\"F\"\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Found:    Boolean\n\e[31m   |\e[0m   \
    \                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        import java.lang._\n       \
    \ val chars = num.toCharArray\n        // Count each prime digits count\n    \
    \    var count = 0\n        var prev = 0\n        for(i <- 0 until chars.length\
    \ - 1){\n            if(chars(i).toInt == prev){\n                count += 1\n\
    \            } else {\n                count = 0\n                prev = chars(i).toInt\n\
    \            }\n        }\n        val count = chars.length * 2 - 1 - count\n\
    \        val key = num.toLong * count / chars.length\n        key\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n \
    \   assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg6xzveo3.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mcount\e[0m = chars.length\
    \ * \e[31m2\e[0m - \e[31m1\e[0m - count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcount is already defined as \e[33mvariable\e[0m \e[35mcount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1660009901
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var n = 0\n        for (i <-\
    \ 0 until num.length - 1)\n            n += num.charAt(i).toInt.toLong\n     \
    \   if (num.length == 0) 0\n        else {\n            var prime = primes\n \
    \           for (i <- 0 until prime.length - 1)\n                if (n / prime(i).productDiv\
    \ <= 1) n /= prime(i)\n            n\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxmm93_a4.scala:28:14 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            n += num.charAt(i).toInt.toLong\n\e[31m\e\
    [31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpxmm93_a4.scala:31:24 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m            \e[33mvar\e[0m \e[36mprime\e[0m = primes\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: primes\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009905
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // TODO: Your code here\n  \
    \      return 0\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpygibrq3v.scala:30)\n\tat Problem.main(tmpygibrq3v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val num = num.toUpperCase\n\n\
    \        val primes = List(2, 3, 5, 7, 11, 13, 17, 19)\n        val primesCount\
    \ = primes.size\n\n        var hexDigits = 0 \n        var hexVal = 0\n      \
    \  var hexPrime = 0\n        val hexArray = num.toCharArray.map { c =>\n     \
    \       hexVal = hexVal + (c * scala.util.pow(2, hexDigits))\n            hexDigits\
    \ = hexDigits + 1\n        }\n\n        val countPrime = hexArray.count(_ == 2)\n\
    \        val countPrime2 = hexArray.count(_ == 3)\n        val countPrime3 = hexArray.count(_\
    \ == 5)\n        val countPrime4 = hexArray.count(_ == 7) \n        val countPrime5\
    \ = hexArray.count(_ == 11) \n        val countPrime6 = hexArray.count(_ == 13)\n\
    \        val countPrime7 = hexArray.count(_ == 17)\n        val countPrime8 =\
    \ hexArray.count(_ == 19)\n\n        if(countPrime == primesCount) {\n       \
    \     hexVal = hexVal - primesCount\n        }\n        if(countPrime2 == primesCount)\
    \ {\n            hexVal = hexVal - primesCount\n        }\n        if(countPrime3\
    \ == primesCount) {\n            hexVal = hexVal - primesCount\n        }\n  \
    \      if(countPrime4 == primesCount) {\n            hexVal = hexVal - primesCount\n\
    \        }\n        if(countPrime5 == primesCount) {\n            hexVal = hexVal\
    \ - primesCount\n        }\n        if(countPrime6 == primesCount) {\n       \
    \     hexVal = hexVal - primesCount\n        }\n        if(countPrime7 == primesCount)\
    \ {\n            hexVal = hexVal - primesCount\n        }\n        if(countPrime8\
    \ == primesCount) {\n            hexVal = hexVal - primesCount\n        }\n\n\
    \        hexVal\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjlicsaqd.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mnum\e[0m = num.toUpperCase\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35mnum\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009904
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var numList = num.toList\n \
    \       val prime = List(2,3,5,7,11,13,17,19)\n        var count = 0\n       \
    \ for (i <- 0 until numList.size) {\n            var num2 = numList(i)\n     \
    \       for(j <- 0 until prime.size) {\n                if(num2 % prime(j) ==\
    \ 0) {\n                    num2 /= prime(j)\n                    count += 1\n\
    \                    break\n                }\n            }\n        }\n    \
    \    count + numList.size\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaknz21vk.scala:33:25 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                    num2 /= prime(j)\n\e[31m\e[31m  \
    \ |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ /= is not a member of Char - did you mean Char.!=?\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpaknz21vk.scala:35:20 ------------------------\e[0m\e[0m\n\
    \e[31m35 |\e[0m                    break\n\e[31m\e[31m   |\e[0m              \
    \      ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Return value should be Long,\
    \ an arbitrary precision (64-bit) integer.\n        val map = mutable.Map.empty[Long,\
    \ Int]\n        for (i <- 0 until num.length)\n            map += num.charAt(i)\
    \ -> 1\n        \n        // Prime number is a natural number greater than 1 that\
    \ is not a product \n        // of two smaller natural numbers, therefore any\
    \ prime number can have the \n        // same number of digits as the hexadecimal\
    \ number. \n        val primes = map.filter { case (_, v) => v > 1 }.keys\n  \
    \      val primeNum = primes.head\n        val hexCount = map.getOrElse(primeNum,\
    \ 0)\n        \n        // The hexadecimal number must be an exact power of two\n\
    \        val hexBase = hexCount / hexCount.getOrElse(BigInt(2), 1)\n        val\
    \ hexBase2 = hexBase / hexBase.getOrElse(BigInt(2), 1)\n        val hexBase3 =\
    \ hexBase2 / hexBase2.getOrElse(BigInt(2), 1)\n        val hexBase4 = hexBase3\
    \ / hexBase3.getOrElse(BigInt(2), 1)\n        \n        if (hexCount % hexCount.getOrElse(BigInt(2),\
    \ 1) == 0)\n            (hexCount + hexBase4) / hexBase4.getOrElse(BigInt(2),\
    \ 1)\n        else\n            0\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpojg4j0pu.scala:27:18 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = mutable.Map.empty[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009904
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val keyMap : mutable.Map[Int,\
    \ Long] = mutable.Map(\n                0 -> 2,\n                1 -> 2,\n   \
    \             2 -> 3,\n                3 -> 3,\n                4 -> 5,\n    \
    \            5 -> 7,\n                6 -> 11,\n                7 -> 13,\n   \
    \             8 -> 17,\n                9 -> 19\n        )\n        val newKey\
    \ = num.toLong\n        val result = 0\n        for (x <- num.toLong - 1) {\n\
    \            if (x < 9) {\n                if (keyMap(x) == 2) {\n           \
    \         result += newKey % 10\n                    newKey /= 10\n          \
    \      }\n            }\n            else if (x == 9) {\n                if (keyMap(x)\
    \ == 2) {\n                    result += newKey % 10\n                    newKey\
    \ /= 10\n                }\n            }\n            else {\n              \
    \  if (keyMap(x) == 2) {\n                    result += newKey % 10\n        \
    \            newKey /= 10\n                }\n            }\n        }\n     \
    \   result\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1deqsxyq.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mkeyMap\e[0m : mutable.Map[\e\
    [35mInt\e[0m, \e[35mLong\e[0m] = mutable.Map(\n\e[31m\e[31m   |\e[0m         \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1deqsxyq.scala:26:46\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mkeyMap\e[0m : mutable.Map[\e[35mInt\e[0m, \e[35mLong\e[0m] = mutable.Map(\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                              Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1deqsxyq.scala:40:18\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mfor\e[0m (x\
    \ <- num.toLong - \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  value foreach is not a member of Long\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val key = mutable.BitSet()\n\
    \        num.foreach(x => {\n            if (x.toChar.toUpperCase() == 'A') key.xor(x('a')\
    \ - 'A' + 10)\n            if (x.toChar.toUpperCase() == 'B') key.xor(x('b') -\
    \ 'A' + 10)\n            if (x.toChar.toUpperCase() == 'C') key.xor(x('c') - 'A'\
    \ + 10)\n            if (x.toChar.toUpperCase() == 'D') key.xor(x('d') - 'A' +\
    \ 10)\n            if (x.toChar.toUpperCase() == 'E') key.xor(x('e') - 'A' + 10)\n\
    \            if (x.toChar.toUpperCase() == 'F') key.xor(x('f') - 'A' + 10)\n \
    \       })\n        val result: Long = key.count()\n        return result\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwvlsbiey.scala:26:18 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mkey\e[0m = mutable.BitSet()\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpwvlsbiey.scala:28:25 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m            \e[33mif\e[0m (x.toChar.toUpperCase() == \e[31m'A'\e[0m) key.xor(x(\e\
    [31m'a'\e[0m) - \e[31m'A'\e[0m + \e[31m10\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value toUpperCase\
    \ is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwvlsbiey.scala:29:25\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mif\e[0m\
    \ (x.toChar.toUpperCase() == \e[31m'B'\e[0m) key.xor(x(\e[31m'b'\e[0m) - \e[31m'A'\e\
    [0m + \e[31m10\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                value toUpperCase is not a member of Char\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwvlsbiey.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m (x.toChar.toUpperCase() ==\
    \ \e[31m'C'\e[0m) key.xor(x(\e[31m'c'\e[0m) - \e[31m'A'\e[0m + \e[31m10\e[0m)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                value toUpperCase is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpwvlsbiey.scala:31:25 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m            \e[33mif\e[0m (x.toChar.toUpperCase() == \e[31m'D'\e\
    [0m) key.xor(x(\e[31m'd'\e[0m) - \e[31m'A'\e[0m + \e[31m10\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \       value toUpperCase is not a member of Char\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpwvlsbiey.scala:32:25 ------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m            \e[33mif\e[0m (x.toChar.toUpperCase() == \e[31m'E'\e[0m) key.xor(x(\e\
    [31m'e'\e[0m) - \e[31m'A'\e[0m + \e[31m10\e[0m)\n\e[31m\e[31m   |\e[0m    "
  stdout: ''
  timestamp: 1660009910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var n = 0L\n        // TODO:\
    \ Write code here\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw7fzahi_.scala:28:5\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        num.toLong.filter(_ >= '0')\
    \ map { hex =>\n            // If the hexadecimal digit is a valid hexadecimal\
    \ digit, \n            // return its count. Otherwise, return 0.\n           \
    \ if (hex >= '0' && hex <= '9') {\n                val digitCount = hex.toInt\n\
    \                if (digitCount > 0 && digitCount <= 6) {\n                  \
    \  if (digitCount > 2) {\n                        if (digitCount > 5) {\n    \
    \                        if (digitCount > 7) {\n                             \
    \   return digitCount\n                            } else {\n                \
    \                return 0\n                            }\n                   \
    \     } else {\n                            if (digitCount > 3) {\n          \
    \                      return digitCount\n                            } else {\n\
    \                                return 0\n                            }\n   \
    \                     }\n                    } else {\n                      \
    \  if (digitCount > 2) {\n                            if (digitCount > 5) {\n\
    \                                return digitCount\n                         \
    \   } else {\n                                return 0\n                     \
    \       }\n                        } else {\n                            if (digitCount\
    \ > 2) {\n                                return digitCount\n                \
    \            } else {\n                                return 0\n            \
    \                }\n                        }\n                    }\n       \
    \         }\n            } else {\n                return 0\n            }\n \
    \       }.sum\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9l8fg804.scala:26:19 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        num.toLong.filter(_ >= \e[31m'0'\e[0m) map {\
    \ \e[36mhex\e[0m =>\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        value filter is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660009910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // First split the number into\
    \ its digits.\n        var numDigits = num.toString.toList.reverse.map(_.toInt).reverse\n\
    \        var primes : mutable.Set[Int] = mutable.Set.empty\n        \n       \
    \ // For each digit, check if it is prime and add its position to \n        //\
    \ the set.\n        numDigits.zipWithIndex.foreach { case (digit, idx) => \n \
    \           if (isPrime(digit) && (primes.contains(idx) || primes.isEmpty)) primes\
    \ += idx\n        }\n        // Count the number of primes found.\n        numDigits.count(_\
    \ == 2)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"\
    )) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyv4i_oog.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m \e[36mprimes\e[0m : mutable.Set[\e\
    [35mInt\e[0m] = mutable.Set.empty\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpyv4i_oog.scala:28:40 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m \e[36mprimes\e[0m : mutable.Set[\e\
    [35mInt\e[0m] = mutable.Set.empty\n\e[31m\e[31m   |\e[0m                     \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpyv4i_oog.scala:33:16 ------------------------\e[0m\e[0m\n\e[31m33 |\e\
    [0m            \e[33mif\e[0m (isPrime(digit) && (primes.contains(idx) || primes.isEmpty))\
    \ primes += idx\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toChar).mkString.toLong\n\
    \        hex.reverse match {\n            case 0 => \"0\"\n            case a\
    \ => \"0123456789ABCDEF\".indexOf(a.toChar)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm27c1njb.scala:27:12 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        hex.reverse \e[33mmatch\e[0m {\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value reverse is not\
    \ a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm27c1njb.scala:28:22\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mcase\e[0m \e\
    [31m0\e[0m => \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m                      ^^^\e\
    [0m\n\e[31m   |\e[0m                      Found:    (\e[32m\"0\"\e[0m : String)\n\
    \e[31m   |\e[0m                      Required: Long\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009912
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val chars = num.toCharArray\n\
    \        var count = 0\n        var hex = 0\n        for(i <- 0 until chars.length)\
    \ {\n            val c = chars(i)\n            if((c >= '0' && c <= '9') || (c\
    \ >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')) {\n                count += 1\
    \ \n                val hd = hex % 10\n                hex += c - '0'\n      \
    \          if(hd < 9) {\n                    hex = 0\n                }\n    \
    \        }\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpok_pd3zq.scala:43)\n\tat Problem.main(tmpok_pd3zq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009912
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val primes = mutable.Set[Long]()\n\
    \        // The function should count the prime digits (i.e. the numbers of \n\
    \        // hexadecimal digits that are primes) and return the result.\n     \
    \   def countHexPrimes(hexNum : String) : Long = {\n            val hex = hexNum.map(x\
    \ => if (x == 'A' || x == 'B' || x == 'C' || x == 'D' || x == 'E' || x == 'F')\
    \ x else Character.toUpperCase(x)).mkString\n            val hexArray = hex.toCharArray\n\
    \            val hexString = new String(hexArray)\n            val charArray =\
    \ hexString.toCharArray\n            var count = 0\n            val primeDigits\
    \ = hexString.map(x => x match {\n                case x if x % 2 == 0 => true\n\
    \                case x => false\n            }).filter(x => x).map(x => x match\
    \ {\n                case false => x + 2\n                case true => x - 2\n\
    \            }).toArray\n            var hexDigits = new collection.mutable.ArrayBuffer[Char]()\n\
    \            hexDigits.append(hexNum)\n            while (hexDigits.nonEmpty)\
    \ {\n                hexDigits.clear()\n                for (i <- hexDigits.indices.reverse)\
    \ {\n                    hexDigits.append(hexDigits.take(i + 1).last)\n      \
    \          }\n                hexDigits.append(hexDigits.last)\n             \
    \   for (i <- hexDigits.indices) {\n                    hexDigits.append(hexDigits.take(i\
    \ + 1).last)\n                }\n                primeDigits.zip(hexDigits).foreach\
    \ { case (prime, hexDigit) =>\n                    if (!primeDigits.contains(hexDigit.toInt))\n\
    \                        primes.add(prime)\n                }\n              \
    \  hexDigits.clear()\n            }\n            primes.size\n        }\n    \
    \    val num = num.replaceAll(\"\\\\D\", \"\")\n        val numArray = num.toCharArray\n\
    \        val numString = new String(numArray)\n        val charArray = numString.toCharArray\n\
    \        var hexNumber = 0\n        var count = 0\n        var hexDigits = collection.mutable.ArrayBuffer[Char]()\n\
    \        for (i <- charArray) {\n            if (hexNumber > 9) {\n          \
    \      hexNumber += hexNumber(hexDigits)\n                hexDigits = collection.mutable.ArrayBuffer[Char]()\n\
    \                count = 0\n            }\n            if (Character.isDigit(hexNumber(hexDigits)))\
    \ {\n                count += 1\n                hexNumber += hexNumber(hexDigits)\n\
    \                hexDigits = collection.mutable.ArrayBuffer[Char]()\n        \
    \    }\n            hexDigits.append(i)\n        }\n        hexNumber + hexNumber(hexDigits)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiq2tnba9.scala:26:21 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = mutable.Set[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpiq2tnba9.scala:39:32 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                \e[33mcase\e[0m \e[31mfalse\e[0m => x\
    \ + \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                              ^^^\e[0m\n\
    \e[31m   |\e[0mvalue + is not a member of Boolean, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpiq2tnba9.scala:40:31 ------------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m                \e[33mcase\e[0m \e[31mtrue\e[0m => x - \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m                             ^^^\e[0m\n\e[31m\
    \   |\e[0mvalue - is not a member of Boolean, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- Error: /tmp/tmpiq2tnba9.scala:41:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            }).toArray\n\e[31m\e[31m   |\e[0m       \
    \               ^\e[0m\n\e[31m   |\e[0m                      No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                      where:    B is\
    \ a type variable\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpiq2t"
  stdout: ''
  timestamp: 1660009916
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexDigits = \"abcdef0123456789ABCDEF\"\
    \n        val hexValue = num.map(c => hexDigits.indexOf(c)).sum\n        val hexDigitsLength\
    \ = hexDigits.length\n        val hexValueString = hexValue.toString\n       \
    \ val hexValueLength = hexValueString.length\n        val primes = mutable.ArrayBuffer.empty[Int]\n\
    \        (0 to hexValueLength - 1).foreach {\n            if (hexValueString.charAt(_)\
    \ == '1') {\n                primes += hexDigitsLength\n            }\n      \
    \  }\n        primes.length\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphvzzcotn.scala:31:21 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E081] Type Error: /tmp/tmphvzzcotn.scala:33:38 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mif\e[0m (hexValueString.charAt(_) ==\
    \ \e[31m'1'\e[0m) {\n\e[31m\e[31m   |\e[0m                                   \
    \   ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m   I could not infer the type of the parameter _$1 of expanded function:\n\
    \e[31m   |\e[0m   _$1 => hexValueString.charAt(_$1) == \e[31m'1'\e[0m.\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hex = num.map(_.toInt)\n\
    \        val a = hex(0)\n        val b = hex(2)\n        val c = hex(4)\n    \
    \    val d = hex(6)\n        val e = (hex(0))\n        val f = (hex(2))\n    \
    \    val g = (hex(4))\n        val h = (hex(6))\n        val l = hex(0)\n    \
    \    val m = (hex(0))\n        val n = (hex(2))\n        val o = (hex(4))\n  \
    \      val p = (hex(6))\n        val q = (hex(0))\n        val r = (hex(2))\n\
    \        val s = (hex(4))\n        val t = (hex(6))\n        val u = (hex(0))\n\
    \        val v = (hex(2))\n        val x = (hex(4))\n        val y = (hex(6))\n\
    \        val z = (hex(0))\n        val hex2 = hex(1)\n        val hex3 = hex(2)\n\
    \        val hex5 = hex(5)\n        val hex7 = hex(7)\n        val hex9 = hex(9)\n\
    \        val hexB = hex(11)\n        val hexD = hex(13)\n        val hexE = hex(17)\n\
    \        val hexF = hex(19)\n        var hexArray = Array[Int](hex, hex2, hex3,\
    \ hex5, hex7, hex9, hexB, hexD, hexE, hexF)\n        val primes = primesOf(hexArray.length)\n\
    \        var primeCount = 0\n        var primeDigit = 0\n        var primeIndex\
    \ = 0\n        for (prime <- primes) {\n            primeDigit = 0\n         \
    \   primeIndex = 0\n            for (hex <- hexArray) {\n                if (hex\
    \ > prime) {\n                    primeDigit += 1\n                    if (primeDigit\
    \ == prime) {\n                        break\n                    }\n        \
    \        }\n            }\n            if (primeDigit == prime) {\n          \
    \      primeCount += 1\n            }\n        }\n        primeCount\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvtpmg24d.scala:58:34\
    \ --------------------\e[0m\e[0m\n\e[31m58 |\e[0m        \e[33mvar\e[0m \e[36mhexArray\e\
    [0m = Array[\e[35mInt\e[0m](hex, hex2, hex3, hex5, hex7, hex9, hexB, hexD, hexE,\
    \ hexF)\n\e[31m\e[31m   |\e[0m                                  ^^^\e[0m\n\e[31m\
    \   |\e[0m                                  Found:    (hex : IndexedSeq[Int])\n\
    \e[31m   |\e[0m                                  Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpvtpmg24d.scala:59:21 ------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = primesOf(hexArray.length)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                Not found: primesOf\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009913
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val map = new mutable.HashMap[String,\
    \ Long]()\n        for(num <- num.toCharArray.map(x => x.toLong)){\n         \
    \   if (map.contains(num.toString)){\n                map(num.toString) +=1\n\
    \            }else{\n                map.put(num.toString,1)\n            }\n\
    \        }\n        for(num <- map.keys){\n            val prime = num.indexOf('2')\n\
    \            if(prime == -1 || prime == 0){\n                map.remove(num)\n\
    \            }\n        }\n        map.size\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv_l5w5ai.scala:26:22 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009911
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Your code here.\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8fpo5x02.scala:25:38\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mhexKey\e\
    [0m(\e[36mnum\e[0m : \e[35mString\e[0m) : \e[35mLong\e[0m = {\n\e[31m\e[31m  \
    \ |\e[0m                                      ^\e[0m\n\e[31m   |\e[0m        \
    \                              Found:    Unit\n\e[31m   |\e[0m               \
    \                       Required: Long\n\e[31m26 |\e[0m        \e[34m// Your code\
    \ here.\e[0m\n\e[31m27 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009913
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val chars = num.toCharArray\n\
    \        val n = chars.length\n        val a = Array.fill(n)(0)\n        for (i\
    \ <- 0 to n-1){\n            val b = chars(i).toLong\n            a(i) = a(i)\
    \ ++ b\n        }\n        val b = Array.fill(n)(0)\n        for (i <- 0 to n-1){\n\
    \            val c = a(i) % 2\n            b(i) = b(i) ++ c\n        }\n     \
    \   b.sum\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp64_bnly6.scala:31:24 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            a(i) = a(i) ++ b\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                   value ++ is\
    \ not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp64_bnly6.scala:36:24\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            b(i) = b(i) ++\
    \ c\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                value ++ is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660009915
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexList = num.toList\n \
    \       val keys = hexList.map(x => x.toInt)\n        val keySet = keys.toSet\n\
    \        val primeKeys = for {\n            key <- keySet\n            if (key.equals(key\
    \ / 2) || key.equals(key * 3) || key.equals(key * 5) || key.equals(key * 7) ||\
    \ key.equals(key * 11))\n        } yield key\n        val result = 0\n       \
    \ primeKeys.foreach { key =>\n            if (hexList.map(x => x.toInt).contains(key))\
    \ result += key\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4mrhd100.scala:35:64 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mif\e[0m (hexList.map(\e[36mx\e[0m =>\
    \ x.toInt).contains(key)) result += key\n\e[31m\e[31m   |\e[0m               \
    \                                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \            value += is not a member of Int - did you mean result.!=?\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009916
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var i = 0\n        var count\
    \ = 0\n        val l = (num.length).asInstanceOf[Int]\n        for (i <- 0 until\
    \ l) {\n            val x = (hexDigit(num(i).toChar)).asInstanceOf[Int]\n    \
    \        if (x == 0) count = count + 1\n            else {\n                val\
    \ p = primes(x)\n                count = count + (p.size > 1)\n            }\n\
    \        }\n        count * l\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp61s_5ovv.scala:30:21 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e[36mx\e[0m = (hexDigit(num(i).toChar)).asInstanceOf[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: hexDigit\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp61s_5ovv.scala:33:24 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                \e[33mval\e[0m \e[36mp\e[0m = primes(x)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                    Not found: primes\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009911
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // convert decimal string to\
    \ binary string\n        val binary = num.map(c => c.toInt % 2).toList.mkString\n\
    \        // calculate the binary equivalent of the number\n        val hex = Integer.parseInt(binary,\
    \ 2)\n        // count the primes\n        val primes = hex.toSet.filter(_ % 2\
    \ != 0) // even\n        // convert to decimal string\n        val decimal = primes.foldLeft(0)(_\
    \ + 2)\n        return hex.asInstanceOf[Long] * (hex.asInstanceOf[Long] * 16)\
    \ + decimal\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv8mcncl4.scala:31:25 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = hex.toSet.filter(_\
    \ % \e[31m2\e[0m != \e[31m0\e[0m) \e[34m// even\e[0m\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value toSet is\
    \ not a member of Int - did you mean hex.toInt?\n1 error found\n"
  stdout: ''
  timestamp: 1660009915
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Use '2' as base to convert\
    \ a string to number\n        num.toLong(2).asInstanceOf[Long]\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpe2gkyiqw.scala:27:12 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        num.toLong(\e[31m2\e[0m).asInstanceOf[\e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \e\
    [33mmethod\e[0m \e[35mtoLong\e[0m in \e[33mclass\e[0m \e[35mStringOps\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009912
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val len = num.length\n     \
    \   val chars = (num ++ num).chars.toList\n        chars.map(c => (c + 'A').toInt\
    \ % 26).distinct.toList.length\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiglp8smu.scala:27:39 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mchars\e[0m = (num ++ num).chars.toList\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m              value toList is not a member of java.util.stream.IntStream\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009916
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexList = num.toString.toCharArray.filterNot(_.isDigit)\n\
    \        var numPrime = 0\n        var numPow = 0\n        for(hex <- hexList)\
    \ {\n            numPrime += hexToInt(hex)\n            numPow += hexToInt(hex)\n\
    \        }\n        (hexList.count(x => isPrime(hexToInt(x))) == (numPrime * numPow)\
    \ / hexList.size)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc_8_cxnm.scala:30:21 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            numPrime += hexToInt(hex)\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is\
    \ not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpc_8_cxnm.scala:30:24 ------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m            numPrime += hexToInt(hex)\n\e[31m\e[31m   |\e[0m         \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found:\
    \ hexToInt\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc_8_cxnm.scala:31:19\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            numPow += hexToInt(hex)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpc_8_cxnm.scala:31:22 ------------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m            numPow += hexToInt(hex)\n\e[31m\e[31m   |\e[0m    \
    \                  ^^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ hexToInt\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc_8_cxnm.scala:33:28\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        (hexList.count(\e\
    [36mx\e[0m => isPrime(hexToInt(x))) == (numPrime * numPow) / hexList.size)\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                           Not found: isPrime\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpc_8_cxnm.scala:33:36 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        (hexList.count(\e[36mx\e[0m => isPrime(hexToInt(x)))\
    \ == (numPrime * numPow) / hexList.size)\n\e[31m\e[31m   |\e[0m              \
    \                      ^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \            Not found: hexToInt\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanati"
  stdout: ''
  timestamp: 1660009917
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val length = num.length\n  \
    \      val digits = mutable.HashSet[Int]()\n        val count = mutable.HashSet[Long]()\n\
    \        for (i <- 0 until length) {\n            val chr = num(i).toUpperCase\
    \ // in case the char was an uppercase letter\n            digits += (if (chr\
    \ == \"A\") 0 else 1)\n            digits += (if (chr == \"B\") 2 else 1)\n  \
    \          digits += (if (chr == \"C\") 4 else 1)\n            digits += (if (chr\
    \ == \"D\") 6 else 1)\n            digits += (if (chr == \"E\") 8 else 1)\n  \
    \          digits += (if (chr == \"F\") 10 else 1)\n        }\n        for (i\
    \ <- digits) {\n            for (j <- 0 until i) {\n                if (digits(j\
    \ + i) == 2) {\n                    count.+= 2\n                }\n          \
    \      if (digits(j + i) == 3) {\n                    count.+= 3\n           \
    \     }\n                if (digits(j + i) == 5) {\n                    count.+=\
    \ 5\n                }\n                if (digits(j + i) == 7) {\n          \
    \          count.+= 7\n                }\n            }\n        }\n        val\
    \ num = count.length\n        count.length\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp9mxd894y.scala:41:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                    count.+= \e[31m2\e[0m\n\e[31m\e[31m\
    \   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m               \
    \      end of statement expected but integer literal found\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp9mxd894y.scala:44:29 -----------------------------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m                    count.+= \e[31m3\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                             ^\e[0m\n\e[31m   |\e[0m                 \
    \    end of statement expected but integer literal found\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp9mxd894y.scala:47:29 -----------------------------------------\e[0m\e\
    [0m\n\e[31m47 |\e[0m                    count.+= \e[31m5\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                             ^\e[0m\n\e[31m   |\e[0m                 \
    \    end of statement expected but integer literal found\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp9mxd894y.scala:50:29 -----------------------------------------\e[0m\e\
    [0m\n\e[31m50 |\e[0m                    count.+= \e[31m7\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                             ^\e[0m\n\e[31m   |\e[0m                 \
    \    end of statement expected but integer literal found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp9mxd894y.scala:28:20 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mcount\e[0m = mutable.HashSet[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp9mxd894y.scala:27:21 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = mutable.HashSet[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n6 errors found\n"
  stdout: ''
  timestamp: 1660009913
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // base case\n        if(num.isEmpty)\
    \ 0\n        else {\n            // count the number of digits, starting at 0\n\
    \            var digits = 0\n            // loop to count the digits\n       \
    \     for(i <- num.toCharArray )\n            {\n                // if the digit\
    \ is between '0' and '9', it is an ASCII digit \n                // and therefore\
    \ a hex digit\n                if((i>=48) && (i<=57)) digits+=1\n            \
    \    // if the digit is between 'A' and 'F', it is a hexadecimal \n          \
    \      // digit and therefore a hex digit\n                else if((i>=65) &&\
    \ (i<=70)) digits+=1\n                // if the digit is between 'a' and 'f',\
    \ it is a hexadecimal \n                // digit and therefore a hex digit\n \
    \               else if((i>=97) && (i<=102)) digits+=1\n                // any\
    \ other digits are considered a hex digit, so...\n                else digits+=1\n\
    \            }\n            // return number of hex digits \n            return\
    \ digits\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxosxl9ve.scala:51)\n\tat Problem.main(tmpxosxl9ve.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009917
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hexDigits = num.toCharArray.map(_.toInt)\n\
    \        var count = 0L\n        for(i <- 0 until hexDigits.length) {\n      \
    \      val num = hexDigits(i) * hexDigits(i) + hexDigits(i+1)\n            val\
    \ isPrime = num % 2 == 0\n            val numToAdd = hexDigits(i) + hexDigits(i+1)\n\
    \            if(isPrime && (numToAdd < hexDigits.length ||\n                 \
    \           (hexDigits(i) == hexDigits(i+1)))) {\n                count += 1L\n\
    \            }\n        }\n        count + 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length\
    \ 2\n\tat Problem$.hexKey$$anonfun$1(tmp552cj__9.scala:29)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.hexKey(tmp552cj__9.scala:36)\n\
    \tat Problem$.main(tmp552cj__9.scala:40)\n\tat Problem.main(tmp552cj__9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009919
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        def isPrime(n : Int) : Boolean\
    \ = {\n            for{\n                i <- 2 until math.ceil(math.sqrt(n))\n\
    \            } yield n % i == 0\n        }\n        val isEven = num.length %\
    \ 2 == 0\n        val isHex = num.toCharArray.map(c => ('A' <= c && c <= 'F')).forall(!_)\n\
    \        val isDecimal = num.toCharArray.map(c => ('0' <= c && c <= '9')).forall(!_)\n\
    \        if(isEven && isHex && isDecimal) return 1\n        if(num.length == 0)\
    \ return 0\n        val hexKey = num.toCharArray.map(c => ('A' <= c && c <= 'F')).count(!_)\n\
    \        if(hexKey == 3) return 1\n        if(hexKey == 5) return 2\n        if(hexKey\
    \ == 7) return 3\n        if(hexKey == 11) return 4\n        if(hexKey == 13)\
    \ return 5\n        if(hexKey == 17) return 6\n        if(hexKey == 19) return\
    \ 7\n        return 0\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpatev3v4c.scala:28:38\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                i <- \e[31m2\e\
    [0m until math.ceil(math.sqrt(n))\n\e[31m\e[31m   |\e[0m                     \
    \        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \      Found:    Double\n\e[31m   |\e[0m                             Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009918
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        if (num.isEmpty) 0\n       \
    \ else {\n            val numMap = num.toCharArray.map(c => (c).toLong)\n    \
    \        val hexNum = numMap.toList.sortBy(a => a).reverse\n            val hexNumList\
    \ = hexNum.map(a => (a & 0xF).toLong)\n            val hexNumMap = hexNumList.toMap\n\
    \            val hexNumArray = hexNumList.toArray\n            val hexNumArrayList\
    \ = hexNumArray.toList.sortBy(a => a).reverse\n            val hexNumArrayMap\
    \ : Map[Long, Int] = hexNumArrayList.foldLeft[Map[Long, Int]](Map())(\n      \
    \          a => {\n                    val key = a.toLong\n                  \
    \  val value = hexNumMap.getOrElse(key, 0)\n                    a + (key -> value)\n\
    \                }\n            )\n            val hexNumArrayMapList = hexNumArrayMap.map(a\
    \ => a._1 -> a._2)\n            val twosIndex = hexNumArrayMap.filter(_._1 ==\
    \ 2).map(_._2)\n            val zerosIndex = hexNumArrayMap.filter(_._1 == 0).map(_._2)\n\
    \            val prime = hexNumArrayMapList.getOrElse(hexNumArrayMapList(0).toLong,\
    \ 0)\n            val nonPrime = hexNumArrayMapList\n                .filter(a\
    \ => a._1 -> a._2 != prime)\n                .map(a => a._1 -> a._2)\n       \
    \         .toList\n                .toMap\n            val primeList = nonPrime.filter(_._1\
    \ == prime).toList\n            val nonPrimeMap = nonPrime.foldLeft[Map[Long,\
    \ Int]](Map())(\n                a => {\n                    val key = a.toLong\n\
    \                    val value = primeList.count(b => b._1 == key)\n         \
    \           a + (key -> value)\n                }\n            )\n           \
    \ val primeArray = primeList.map(_._1).toArray\n            val primeArrayList\
    \ = primeArray.sortBy(a => a).reverse\n            val primeArrayMap : Map[Long,\
    \ Int] = primeArrayList.foldLeft[Map[Long, Int]](Map())(\n                a =>\
    \ {\n                    val key = a.toLong\n                    val value = hexNumArrayMap.getOrElse(key,\
    \ 0)\n                    a + (key -> value)\n                }\n            )\n\
    \            val primeArrayMapList = primeArrayMap.map(a => a._1 -> a._2)\n  \
    \          val nonPrimeArray = nonPrime.filter(a => a._1 -> a._2 != prime).toList\n\
    \            val nonPrimeArrayMap = nonPrime.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnteyvi78.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpnteyvi78.scala:81:0 ----------------------------\e[0m\e[0m\n\e[31m81\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- Error: /tmp/tmpnteyvi78.scala:31:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36mhexNumMap\e[0m = hexNumList.toMap\n\
    \e[31m\e[31m   |\e[0m                                            ^\e[0m\n\e[31m\
    \   |\e[0m                                       Cannot prove that Long <:< (K,\
    \ V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                       where:\
    \    K is a type variable\n\e[31m   |\e[0m                                   \
    \              V is a type variable\n\e[31m   |\e[0m                         \
    \              .\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpnteyvi78.scala:35:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                \e[36ma\e\
    [0m => {\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m       \
    \         Wrong number of parameters, expected: 2\n\e[31m36 |\e[0m           \
    \         \e[33mval\e[0m \e[36mkey\e[0m = a.toLong\n\e[31m37 |\e[0m          \
    \          \e[33mval\e[0m \e[36mvalue\e[0m = hexNumMap.getOrElse(key, \e[31m0\e\
    [0m)\n\e[31m38 |\e[0m                    a + (key -> value)\n\e[31m39 |\e[0m \
    \               }\n\e[31m\e[31m-- Error: /tmp/tmpnteyvi78.scala:46:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                .filter(a => a._1 -> a._2 != prime)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m    Values of types (Long, Int) and Int cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpnteyvi78.scala:52:18 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m                \e[36ma\e[0m => {\n\e[31m\e[31m   |\e\
    [0m                ^\e[0m\n\e[31m   |\e[0m                Wrong number of parameters,\
    \ expected: 2\n\e[31m53 |\e[0m           "
  stdout: ''
  timestamp: 1660009921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val digits = num.toCharArray\n\
    \        val prime = scala.collection.mutable.MutableList(2l)\n        val hex\
    \ = scala.collection.mutable.MutableList(2l)\n        val hexStr = scala.collection.mutable.MutableList(2l)\n\
    \        // The number has 6 digits, and it's an even number (hexKey(\"0xAB\"\
    ) is 0L)\n        if (digits.length == 6) {\n            if (digits(0) == '0')\
    \ {\n                hex.push(digits(1))\n                hex.push(digits(2))\n\
    \                hex.push(digits(3))\n                hex.push(digits(4))\n  \
    \              hex.push(digits(5))\n                hex.push(digits(6))\n    \
    \            hex.push(digits(7))\n            } else {\n                hex.push(digits(0))\n\
    \                hex.push(digits(1))\n                hex.push(digits(2))\n  \
    \              hex.push(digits(3))\n                hex.push(digits(4))\n    \
    \            hex.push(digits(5))\n            }\n            hexStr.clear()\n\
    \            hexStr.push(digits(0)+digits(1)+digits(2)+digits(3)+digits(4)+digits(5))\n\
    \            hexStr.push(digits(6)+digits(7))\n            hexStr.push(digits(8)+digits(9))\n\
    \            hexStr.push(digits(10)+digits(11)+digits(12))\n            hexStr.push(digits(13)+digits(14)+digits(15))\n\
    \            // Find the prime number\n            for (hexNum <- hexStr) {\n\
    \                val hexNumInt = hexNum.toInt\n                var primeIndex\
    \ = 0\n                primeIndex = hex.indexWhere(hexNum => hexNumInt%hexNum\
    \ == 0)\n                if (primeIndex == -1) {\n                    prime.push(hexNumInt)\n\
    \                }\n            }\n            val hexStrInt = hexStr.toInt\n\
    \            var primeIndex = 0\n            primeIndex = hexStr.indexWhere(hexNum\
    \ => hexStrInt%hexNum == 0)\n            if (primeIndex == -1) {\n           \
    \     prime.push(hexStrInt)\n            }\n            prime.count()\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"\
    )) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps4_fehdz.scala:27:45 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mprime\e[0m = scala.collection.mutable.MutableList(\e\
    [31m2l\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           value MutableList is not a member of scala.collection.mutable\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps4_fehdz.scala:28:43 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhex\e[0m = scala.collection.mutable.MutableList(\e\
    [31m2l\e[0m)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           value MutableList is not a member of scala.collection.mutable\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps4_fehdz.scala:29:46 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mhexStr\e[0m = scala.collection.mutable.MutableList(\e\
    [31m2l\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           value MutableList is not a member of scala.collection.mutable\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps4_fehdz.scala:31:8 ---------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mif\e[0m (digits.length == \e[31m6\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\
    \e[31m   |\e[0m        Required: Long\n\e[31m   |\e[0m        Maybe you are missing\
    \ an else part for the conditional?\n\e[31m32 |\e[0m            \e[33mif\e[0m\
    \ (digits(\e[31m0\e[0m) == \e[31m'0'\e[0m) {\n\e[31m33 |\e[0m                hex.push(digits(\e\
    [31m1\e[0m))\n\e[31m34 |\e[0m                hex.push(digits(\e[31m2\e[0m))\n\e\
    [31m35 |\e[0m                hex.push(digits(\e[31m3\e[0m))\n\e[31m36 |\e[0m \
    \               hex.push(digits(\e[31m4\e[0m))\n\e[31m37 |\e[0m              \
    \  hex.push(digits(\e[31m5\e[0m))\n\e[31m38 |\e[0m                hex.push(digits(\e\
    [31m6\e[0m))\n\e[31m39 |\e[0m                hex.push(digits(\e[31m7\e[0m))\n\e\
    [31m40 |\e[0m            } \e[33melse\e[0m {\n\e[31m41 |\e[0m                hex.push(digits(\e\
    [31m0\e[0m))\n\e[31m42 |\e[0m              "
  stdout: ''
  timestamp: 1660009920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val strList = num.split(\"\\\
    \\\").toList\n        if(strList.length == 0){\n            return 1l\n      \
    \  }\n        val count2 = strList.foldLeft(0l){ (count, v) => {\n           \
    \ if(v.nonEmpty){\n                val isPrime = v.head.toInt % 2 == 0\n     \
    \           if(isPrime){\n                    val isOdd = v.head.toInt % 3 ==\
    \ 0\n                    if(isOdd){\n                        val isEven = v.head.toInt\
    \ % 4 == 0\n                        if(isEven){\n                            count\
    \ + 1\n                        }\n                        else{\n            \
    \                count + 1\n                        }\n                    }\n\
    \                    else{\n                        count + 1\n              \
    \      }\n                }\n                else{\n                    count\
    \ + 1\n                }\n            }\n            else{\n                count\
    \ + 1\n            }\n        }}\n        val result = count2 % 8\n        if(result\
    \ == 0){\n            1l\n        }\n        else{\n            result\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"\
    )) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.regex.PatternSyntaxException: Unexpected internal error near\
    \ index 1\n\\\n\tat java.base/java.util.regex.Pattern.error(Pattern.java:2028)\n\
    \tat java.base/java.util.regex.Pattern.compile(Pattern.java:1789)\n\tat java.base/java.util.regex.Pattern.<init>(Pattern.java:1430)\n\
    \tat java.base/java.util.regex.Pattern.compile(Pattern.java:1069)\n\tat java.base/java.lang.String.split(String.java:3153)\n\
    \tat java.base/java.lang.String.split(String.java:3199)\n\tat Problem$.hexKey(tmpxhf38vvo.scala:26)\n\
    \tat Problem$.main(tmpxhf38vvo.scala:65)\n\tat Problem.main(tmpxhf38vvo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val count = new scala.collection.mutable.HashMap[Int,\
    \ Int]();\n        var n = 0;\n        val maxDigit = Character.getNumericValue(num.charAt(0));\n\
    \        // count the digit in the string\n        for (i <- 0 until num.length\
    \ -1) {\n            if (Character.getNumericValue(num.charAt(i)) == maxDigit\
    \ - 1) {\n                n = n + 1;\n            } else {\n                count\
    \ = count + (n -> 1)\n                n = 0;\n            }\n        }\n     \
    \   // count the digit in the last string\n        if (n != 0) {\n           \
    \ count = count + (n -> 1)\n        }\n        // print the count\n        println(count.toList)\n\
    \        val prime = count.filter{case(key, value) => key % 2 == 0 && value >\
    \ 1}\n        println(prime)\n        prime.toList.map(x => x._1).toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n\
    \    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) ==\
    \ (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpgotxuzgv.scala:34:22 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                count = count + (n -> \e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Reassignment to val count\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpgotxuzgv.scala:40:18 -----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            count = count + (n -> \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \      Reassignment to val count\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpgotxuzgv.scala:46:36 --------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m        prime.toList.map(\e[36mx\e[0m => x._1).toList\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    List[Int]\n\e[31m   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009922
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val n = num.length\n       \
    \ var count = 0L\n        val m = num.drop(1).mkString\n        val d = num.dropRight(1).mkString\n\
    \        val f = d.toDouble\n        val f2 = math.pow(10, 8) - f2\n        val\
    \ x = f.toLong\n        for (i <- 0 until n) {\n            var t = x * f2\n \
    \           while (t >= m) {\n                t -= m\n                count +=\
    \ 1\n            }\n        }\n        count + n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp828633vk.scala:31:35 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mf2\e[0m = math.pow(\e[31m10\e\
    [0m, \e[31m8\e[0m) - f2\n\e[31m\e[31m   |\e[0m                               \
    \    ^\e[0m\n\e[31m   |\e[0m                                   Recursive \e[33mvalue\e\
    [0m \e[35mf2\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009918
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        if (num.isEmpty) {\n       \
    \     return 0L\n        }\n\n        def isPrime(n: Int): Boolean = { // Returns\
    \ whether n is a prime or not\n            val primes = mutable.ArrayBuffer(2,\
    \ 3, 5, 7)\n            primes.filter(_.isDefinedAt(n)).forall(p => p < n)\n \
    \       }\n\n        def count(n: Int): Long = { // Count how many hexadecimal\
    \ digits there are in a given number\n            def hexDigit(n: Int): Int =\
    \ { // Returns how many hexadecimal digits there are in a given number\n     \
    \           val tmp = n / 16\n                if (tmp % 2 == 0) {\n          \
    \          (tmp - 1) + hexDigit(tmp / 2)\n                } else {\n         \
    \           (tmp - 1) + 1\n                }\n            }\n            hexDigit(n)\
    \ * hexDigit(n / 16)\n        }\n\n        def primeCount(n: Int): Long = { //\
    \ Count how many hexadecimal digits there are in a given number\n            def\
    \ hexDigit(n: Int): Int = { // Returns how many hexadecimal digits there are in\
    \ a given number\n                val tmp = n / 16\n                if (tmp %\
    \ 2 == 0) {\n                    (tmp - 1) + hexDigit(tmp / 2)\n             \
    \   } else {\n                    (tmp - 1) + 1\n                }\n         \
    \   }\n            hexDigit(n) * hexDigit(n / 16)\n        }\n\n        val num\
    \ = num.toCharArray\n        val hexDigits: mutable.ArrayBuffer[Int] = mutable.ArrayBuffer(0)\
    \ // the hex digits\n        var count = 0L\n\n        for (i <- num) {\n    \
    \        val curr = i\n            hexDigits(count) = curr\n            count\
    \ += 1\n        }\n\n        for (hexDigit <- hexDigits) {\n            if (isPrime(hexDigit))\
    \ {\n                count += 1L\n            }\n        }\n\n        count *\
    \ primeCount(num)\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj9o3uzgm.scala:61:12 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mvar\e[0m \e[36mcount\e[0m = \e[31m0L\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcount is\
    \ already defined as \e[33mmethod\e[0m \e[35mcount\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpj9o3uzgm.scala:59:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m\
    \ \e[36mnum\e[0m = num.toCharArray\n\e[31m\e[31m   |\e[0m                  ^\e\
    [0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35mnum\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj9o3uzgm.scala:31:25\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m\
    \ \e[36mprimes\e[0m = mutable.ArrayBuffer(\e[31m2\e[0m, \e[31m3\e[0m, \e[31m5\e\
    [0m, \e[31m7\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpj9o3uzgm.scala:60:23 ------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mhexDigits\e[0m: mutable.ArrayBuffer[\e\
    [35mInt\e[0m] = mutable.ArrayBuffer(\e[31m0\e[0m) \e[34m// the hex digits\e[0m\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpj9o3uzgm.scala:60:50 ------------------------\e[0m\e\
    [0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mhexDigits\e[0m: mutable.ArrayBuffer[\e\
    [35mInt\e[0m] = mutable.ArrayBuffer(\e[31m0\e[0m) \e[34m// the hex digits\e[0m\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Not found:\
    \ mutable\n"
  stdout: ''
  timestamp: 1660009923
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val digits = num.grouped(4).toList\n\
    \        val hexDigits = digits.map(d => if (d.toString.toLowerCase() == 'a')\
    \ (6) else d.toString.toInt).toSet\n        val numDigits = digits.size\n    \
    \    val hexDigitDigits = hexDigits.size * hexDigits.size\n        val primeDigits\
    \ = (hexDigitDigits/(numDigits*hexDigitDigits)).toLong\n        val primeDigitDigits\
    \ = primeDigits.size * primeDigits.size\n        hexDigitDigits + primeDigits\
    \ + hexDigits + primeDigits + hexDigitDigits\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) ==\
    \ (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\"\
    )) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp8iytrz8c.scala:27:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mhexDigits\e[0m = digits.map(\e\
    [36md\e[0m => \e[33mif\e[0m (d.toString.toLowerCase() == \e[31m'a'\e[0m) (\e[31m6\e\
    [0m) \e[33melse\e[0m d.toString.toInt).toSet\n\e[31m\e[31m   |\e[0m          \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Values of types String and Char cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8iytrz8c.scala:31:43 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mprimeDigitDigits\e[0m =\
    \ primeDigits.size * primeDigits.size\n\e[31m\e[31m   |\e[0m                 \
    \              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \       value size is not a member of Long\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmp8iytrz8c.scala:32:37 -----------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        hexDigitDigits + primeDigits + hexDigits + primeDigits + hexDigitDigits\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m+\e[0m in \e\
    [33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\
    \e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e\
    [0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short):\
    \ Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0m (x: String): String\n\
    \e[31m   |\e[0mmatch arguments ((hexDigits : Set[Int]))\n3 errors found\n"
  stdout: ''
  timestamp: 1660009924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val list = num.toLong.map(_.toByte)\n\
    \        val prime = list.zipWithIndex.filter(_._2 == 1).map(_._1).drop(1)\n \
    \       var count = 0L\n        val primeList = prime.toList\n        primeList.foreach{\
    \ number => if (list.contains(number)) count+=1}\n        count\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppl9uex20.scala:26:30 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = num.toLong.map(_.toByte)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                  value map is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660009923
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val s = num.toInt\n        if\
    \ (s == 0)\n            return 0\n        var primes : Long = 0\n        var isPrime\
    \ : Boolean = true\n        val digits = Array.from(num)\n        var d = 0\n\
    \        digits(0) = (digits(0).toInt + 1) % 16\n        val primes = findPrimes(digits.length)\n\
    \        val length = digits.length\n        while (primes.isDefined) {\n    \
    \        val p = primes.get\n            if (isPrime && d == 0) {\n          \
    \      d += p\n            }\n            if (d < p) {\n                d += p\n\
    \                isPrime = true\n            } else if (d > p) {\n           \
    \     isPrime = false\n                d -= p\n            } else {\n        \
    \        d += p\n            }\n            val newDigits = Array.from(digits)\n\
    \            val digitToAdd = d\n            newDigits(digitToAdd) = (newDigits(digitToAdd).toInt\
    \ + 1) % 16\n            val newString = newDigits.map(_ + 48).mkString\n    \
    \        val newLength = newString.length\n            if (newLength != length\
    \ && (newString.toInt == digits(0).toInt) || (newString.toInt == digits(digitToAdd).toInt))\
    \ {\n                primes = Some(digitToAdd)\n            }\n        }\n   \
    \     return primes.getOrElse(0)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3rvtfr4o.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = findPrimes(digits.length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mprimes is already defined as \e[33mvariable\e[0m \e[35mprimes\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp3rvtfr4o.scala:33:20 --------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        digits(\e[31m0\e[0m) = (digits(\e[31m0\e[0m).toInt + \e[31m1\e\
    [0m) % \e[31m16\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Found:    Int\n\e[31m   |\e[0m       \
    \             Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp3rvtfr4o.scala:36:22 ------------------------\e[0m\e[0m\n\e[31m36 |\e\
    [0m        \e[33mwhile\e[0m (primes.isDefined) {\n\e[31m\e[31m   |\e[0m      \
    \         ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               value isDefined\
    \ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3rvtfr4o.scala:37:27\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m\
    \ \e[36mp\e[0m = primes.get\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value get is not a member of Long\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3rvtfr4o.scala:52:36 --------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m            newDigits(digitToAdd) = (newDigits(digitToAdd).toInt\
    \ + \e[31m1\e[0m) % \e[31m16\e[0m\n\e[31m\e[31m   |\e[0m                     \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                   Found:    Int\n\e[31m   |\e[0m           \
    \                         Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp3rvtfr4o.scala:56:29 ---------------"
  stdout: ''
  timestamp: 1660009925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        //write your code here\n   \
    \     val digits = num.takeWhile(Character.isDigit)\n        val hexNum = digits.foldLeft(0){\n\
    \            (sum,c) => sum + Integer.parseInt(c) \n        }\n        val primes\
    \ = primeFactors(hexNum)\n        val factors = primes.filter{ n => hexNum % n\
    \ == 0}\n        factors.foldLeft(0){\n            (sum,c) => sum + c\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\"\
    )) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4po9fqj2.scala:29:46\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            (\e[36msum\e[0m,\e\
    [36mc\e[0m) => sum + Integer.parseInt(c) \n\e[31m\e[31m   |\e[0m             \
    \                                 ^\e[0m\n\e[31m   |\e[0m                    \
    \                          Found:    (c : Char)\n\e[31m   |\e[0m             \
    \                                 Required: String\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4po9fqj2.scala:31:21 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mprimes\e[0m = primeFactors(hexNum)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                    Not found: primeFactors\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val hex = num.replaceAll(\"\
    [^0-9a-zA-Z]\", \" \")\n        val hexArray = hex.split(\" \").map(_.toInt)\n\
    \        val hexPrimeCount = hexPrimes(hexArray.length)\n        hexPrimeCount.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp950oy6ac.scala:28:28 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhexPrimeCount\e[0m = hexPrimes(hexArray.length)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                            Not found: hexPrimes\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009922
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Count the number of possible\
    \ hexadecimal digits. \n        val hexLength = hexDigits.length\n        val\
    \ hexNumbers = num.toList\n        // Convert each hexadecimal digit to decimal\n\
    \        val hexNumbersBig = hexNumbers.map{ x => hexDigits.indexOf(x).toLong\
    \ }\n        // Calculate the decimal value of each hexadecimal digit\n      \
    \  val hexNumbersDecimal = hexNumbersBig.map(x => x / hexLength)\n        // Calculate\
    \ the sum of the decimal value of each hexadecimal digit. \n        // A prime\
    \ number is a hexadecimal number whose decimal value is equal to \n        //\
    \ 0 or 1, but not to 2 or 3\n        val sumOfHexNumbersDecimal = hexNumbersDecimal.sum\n\
    \        // Find all the prime numbers whose decimal value equals to 0 or 1\n\
    \        val primeNumbers = List(2,3,5,7,11,13,17,19)\n            .filter( x\
    \ => sumOfHexNumbersDecimal == 0 || sumOfHexNumbersDecimal == 1 )\n          \
    \  .filter( x => primeNumbers.indexOf(x) != 0 ) \n        // Return the number\
    \ of primes whose decimal value is equals to 0 or 1\n        primeNumbers.length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphe1v161f.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mhexLength\e[0m = hexDigits.length\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                       Not found: hexDigits\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmphe1v161f.scala:30:49 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhexNumbersBig\e[0m = hexNumbers.map{\
    \ \e[36mx\e[0m => hexDigits.indexOf(x).toLong }\n\e[31m\e[31m   |\e[0m       \
    \                                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                              Not found: hexDigits\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphe1v161f.scala:32:57 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhexNumbersDecimal\e[0m =\
    \ hexNumbersBig.map(\e[36mx\e[0m => x / hexLength)\n\e[31m\e[31m   |\e[0m    \
    \                                                   ^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ / is not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmphe1v161f.scala:36:58 -----------------------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msumOfHexNumbersDecimal\e\
    [0m = hexNumbersDecimal.sum\n\e[31m\e[31m   |\e[0m                           \
    \                               ^\e[0m\n\e[31m   |\e[0mambiguous given insta"
  stdout: ''
  timestamp: 1660009924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val nums = num.trim.toIntArray\n\
    \        val key = nums(0)\n        val hexNum = num.substring(1)\n        var\
    \ numOfZeros = 0\n        val digits = hexNum.toList\n        // loop through\
    \ the digits\n        for(i <- 0 until digits.length) {\n            // if the\
    \ digit is 0, increment the number of 0's in the number \n            // of 0's\
    \ in the hexNum\n            if(digits(i) == 0) {\n                numOfZeros\
    \ += 1\n            }\n            // if the digit is greater than or equal to\
    \ 0 and less than \n            // the number of the hexadecimal digits, add one\
    \ to the number\n            if(digits(i) >= key && digits(i) <= numOfZeros) {\n\
    \                numOfZeros += 1\n            }\n        }\n        // return\
    \ the number of the hexadecimal digits that are prime\n        return numOfZeros\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpysxvh4f2.scala:26:28 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = num.trim.toIntArray\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                   value toIntArray is not a member of String\n1 error found\n"
  stdout: ''
  timestamp: 1660009924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val nums = num.split(\"\\\\\
    s\").toList\n        val prime = nums.filter(x => x.toUpperCase != \"0\").map(x\
    \ => nums(nums.indexOf(x)))\n        val hexDigit = primes.filter(x => x.toUpperCase\
    \ != \"0\").map(x => prime(primes.indexOf(x)))\n        nums.zip(hexDigit).filter(x\
    \ => x._1.toUpperCase != \"0\").map(x => x._2 + x._1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"\
    1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"\
    2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpya5obbmc.scala:28:23 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhexDigit\e[0m = primes.filter(\e\
    [36mx\e[0m => x.toUpperCase != \e[31m\"0\"\e[0m).map(\e[36mx\e[0m => prime(primes.indexOf(x)))\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                  Not found: primes\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpya5obbmc.scala:29:78 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m        nums.zip(hexDigit).filter(\e[36mx\e[0m => x._1.toUpperCase\
    \ != \e[31m\"0\"\e[0m).map(\e[36mx\e[0m => x._2 + x._1)\n\e[31m\e[31m   |\e[0m\
    \                                                                         ^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of Nothing, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009925
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Write your code here.\n \
    \       val list = num.toList\n        var primeCounter = 0L\n        for (i <-\
    \ 0 until list.size){\n          val digit = list.apply(i)\n          val hexDigit\
    \ = digit % 16\n          if(hexDigit < 2 || hexDigit > 9){\n            throw\
    \ new IllegalArgumentException(s\"Digit $digit is not valid.\")\n          }\n\
    \          if(primeCounter % 2 == 0 && hexDigit < 12){\n            primeCounter\
    \ += 1\n          }\n          else if(primeCounter % 2 == 1 && hexDigit < 13){\n\
    \            primeCounter += 1\n          }\n          else if(hexDigit == 12){\n\
    \            primeCounter += 2\n          }\n          else if(hexDigit == 13){\n\
    \            primeCounter += 3\n          }\n        }\n        primeCounter\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IllegalArgumentException: Digit A is not valid.\n\tat Problem$.hexKey$$anonfun$1(tmpdclq9q01.scala:33)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.hexKey(tmpdclq9q01.scala:47)\n\
    \tat Problem$.main(tmpdclq9q01.scala:51)\n\tat Problem.main(tmpdclq9q01.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009926
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // The first letter will be\
    \ uppercase.\n        val digit = num(0)\n        // The rest can be anything\
    \ except 'A'...'F', '0'...'9', \n        // except 'A'...'F', the second letter.\n\
    \        val digits = num.subString(1,num.length-1).toString.toCharArray.dropWhile(digit\
    \ != ('A' | 'B' | 'C' | 'D' | 'E' | 'F')).map(x=>x.toInt)\n        // We only\
    \ consider prime numbers of length 2 through 9.\n        val digits = digits to\
    \ (9 to digits.length).filter(x=>digits(x) == 2)\n        // Then we just check\
    \ the primes we calculated before.\n        val sum = digits.foldLeft((0l,0)){\n\
    \            case ((sum,count),digit) => sum._1+digit._1 -> sum._1+digit._1 ->\
    \ count\n            case ((sum,count),_)       => sum -> count\n        }._1\n\
    \        return sum\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8lgmn9_k.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = digits to\
    \ (\e[31m9\e[0m to digits.length).filter(\e[36mx\e[0m=>digits(x) == \e[31m2\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdigits is already defined as \e[33mvalue\e[0m \e[35mdigits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp8lgmn9_k.scala:30:25 ------------------------\e[0m\e[0m\n\
    \e[31m30 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = num.subString(\e[31m1\e\
    [0m,num.length-\e[31m1\e[0m).toString.toCharArray.dropWhile(digit != (\e[31m'A'\e\
    [0m | \e[31m'B'\e[0m | \e[31m'C'\e[0m | \e[31m'D'\e[0m | \e[31m'E'\e[0m | \e[31m'F'\e\
    [0m)).map(\e[36mx\e[0m=>x.toInt)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m value subString is not a member of String - did you mean\
    \ num.substring?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        import scala.math._\n      \
    \  def hexaToInt(h:String) : Int = {\n            val digits = h.split(\"\")\n\
    \            var sum = 0\n            for(i <- 0 until digits.length)\n      \
    \          sum = sum * 16 + digits(i).toInt\n            sum\n        }\n    \
    \    val n = hexaToInt(num)\n        val m = n.toString.toLong\n        val isPrime\
    \ = {\n            import scala.math._\n            def isPrime(x : BigInt) :\
    \ Boolean = {\n                val q = BigInt(2)\n                val i = BigInt(2)\n\
    \                val r = BigInt(2)\n                val x = BigInt(x)\n      \
    \          val y = BigInt(2)\n                val n = BigInt(2)\n            \
    \    var counter = BigInt(0)\n                while(i <= n) {\n              \
    \      val a = BigInt(x.pow(i))\n                    val b = BigInt(y.pow(i))\n\
    \                    val c = a.mod(b)\n                    val q = q.mult(c)\n\
    \                    val r = r.mul(x.pow(i))\n                    val s = r.mod(q)\n\
    \                    val x = q\n                    val y = r\n              \
    \      if(s.equals(BigInt(0)))\n                        counter = counter + 1\n\
    \                    i = i + 1\n                }\n                counter ==\
    \ 0\n            }\n            isPrime(m) && isPrime(m)\n        }\n        (1l\
    \ until m).count(isPrime).toLong\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpr_8oi2cl.scala:42:31 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                \e[33mval\e[0m \e[36mx\e[0m = BigInt(x)\n\
    \e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m  \
    \                             Recursive \e[33mvalue\e[0m \e[35mx\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpr_8oi2cl.scala:50:28\
    \ ---------------------------\e[0m\e[0m\n\e[31m50 |\e[0m                    \e\
    [33mval\e[0m \e[36mq\e[0m = q.mult(c)\n\e[31m\e[31m   |\e[0m                 \
    \           ^\e[0m\n\e[31m   |\e[0m                            Recursive \e[33mvalue\e\
    [0m \e[35mq\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpr_8oi2cl.scala:51:28 ---------------------------\e[0m\e[0m\n\e[31m51\
    \ |\e[0m                    \e[33mval\e[0m \e[36mr\e[0m = r.mul(x.pow(i))\n\e\
    [31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m       \
    \                     Recursive \e[33mvalue\e[0m \e[35mr\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpr_8oi2cl.scala:57:22 -----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m                    i = i + \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \    Reassignment to val i\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpr_8oi2cl.scala:63:27 --------------------\e[0m\e[0m\n\e[31m63\
    \ |\e[0m        (\e[31m1l\e[0m until m).count(isPrime).toLong\n\e[31m\e[31m  \
    \ |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \              Found:    (isPrime : Boolean)\n\e[31m   |\e[0m                \
    \           Required: Long => Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660009925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        val map = mutable.HashMap[String,\
    \ Long]()\n        var count = 0\n        val hex = num.toCharArray\n        hex.foreach\
    \ { c =>\n            if(isPrime(c)) {\n                count += 1\n         \
    \       map += c -> map.getOrElse(c, 0) + 1\n            }\n        }\n      \
    \  count\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcv8l_ffz.scala:26:18 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpcv8l_ffz.scala:30:15 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m(isPrime(c)) {\n\e[31m\e[31m\
    \   |\e[0m               ^^^^^^^\e[0m\n\e[31m   |\e[0m               Not found:\
    \ isPrime\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        var count = 0\n        var prime\
    \ = 0\n        var primes = scala.collection.mutable.Set.empty[Int]\n        for\
    \ (i <- num.toCharArray) {\n            val charInt = i.toInt\n            if\
    \ (charInt < 0 || charInt.toString != \"A\") {\n                count += 1\n \
    \               prime += (charInt - 'A')\n                primes += charInt\n\
    \            }\n        }\n        if (primes.size == 0) {\n            return\
    \ count\n        }\n        var count = 0\n        var isPrime = true\n      \
    \  var prime2 = primes.head\n        var prime3 = primes.tail.head\n        while\
    \ (prime2 != 1) {\n            if (prime2 % prime3 == 0) {\n                prime3\
    \ += 1\n            } else {\n                isPrime = false\n            }\n\
    \            prime2 /= 10\n        }\n        while (!isPrime) {\n           \
    \ prime3 = prime3 + 1\n            prime2 = prime2 * 3 + 1\n            if (prime2\
    \ > prime3) {\n                isPrime = false\n            }\n        }\n   \
    \     if (prime2 == 1) {\n            prime2 = primes.head\n        }\n      \
    \  count += prime2\n        if (prime3 == 2 || prime3 == 3 || prime3 == 5 || prime3\
    \ == 7 || prime3 == 11 || prime3 == 13) {\n            count += 1\n        }\n\
    \        return count\n    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"\
    AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"\
    ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"\
    123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\"\
    )) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpngzoq910.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mvar\e[0m \e[36mcount\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcount is already\
    \ defined as \e[33mvariable\e[0m \e[35mcount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n1 error found\n"
  stdout: ''
  timestamp: 1660009924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n        // Your code here\n        val\
    \ numOfDigits = hexToInt(num)\n        var count = 0\n        var primeNumber\
    \ = 1\n        for (i <- 0 to numOfDigits - 1) {\n            var prime = false\n\
    \            var testNumber = hexToInt(num).toInt\n            while (testNumber\
    \ > 0) {\n                prime = true\n                testNumber %/= primeNumber\n\
    \            }\n            if (prime) {\n                count += 1\n       \
    \     }\n            primeNumber *= primeNumber\n        }\n        (count / 2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(hexKey((\"AB\")) ==\
    \ (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n    assert(hexKey((\"ABED1A33\"\
    )) == (4l));\n    assert(hexKey((\"2020\")) == (2l));\n    assert(hexKey((\"123456789ABCDEF0\"\
    )) == (6l));\n    assert(hexKey((\"112233445566778899AABBCCDDEEFF00\")) == (12l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd99hs4rr.scala:27:26 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mnumOfDigits\e[0m = hexToInt(num)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          Not found: hexToInt\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpd99hs4rr.scala:32:29 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mvar\e[0m \e[36mtestNumber\e[0m = hexToInt(num).toInt\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                             Not found: hexToInt\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You have been tasked to write a function that receives \n    // a\
    \ hexadecimal number as a string and counts the number of hexadecimal \n    //\
    \ digits that are primes (prime number, or a prime, is a natural number \n   \
    \ // greater than 1 that is not a product of two smaller natural numbers).\n \
    \   // Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n\
    \    // Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    // So you have to determine\
    \ a number of the following digits: 2, 3, 5, 7, \n    // B (=decimal 11), D (=decimal\
    \ 13).\n    // Note: you may assume the input is always correct or empty string,\
    \ \n    // and symbols A,B,C,D,E,F are always uppercase.\n    // Examples:\n \
    \   // >>> hexKey((\"AB\"))\n    // (1l)\n    // >>> hexKey((\"1077E\"))\n   \
    \ // (2l)\n    // >>> hexKey((\"ABED1A33\"))\n    // (4l)\n    // >>> hexKey((\"\
    123456789ABCDEF0\"))\n    // (6l)\n    // >>> hexKey((\"2020\"))\n    // (2l)\n\
    \    def hexKey(num : String) : Long = {\n       val digits = num.toCharArray\n\
    \       if (digits.isEmpty) {\n           0l\n       } else {\n           val\
    \ n = digits.length\n           val m = digits.length / 2\n           val p =\
    \ 2\n           val counter = new scala.collection.mutable.HashMap[Char, Long]()\n\
    \           for (i <- 2 to n) {\n               val flag = i % 2 != 0\n      \
    \         if (flag) {\n                   if (counter.get(digits(i)) > 0) {\n\
    \                       counter.put(digits(i), (counter.get(digits(i)).asInstanceOf[Long]\
    \ + 1L))\n                   } else {\n                       counter.put(digits(i),\
    \ (1L))\n                   }\n               }\n           }\n           val\
    \ result = counter.values.toList.foldLeft(0l) { (sum, v) =>\n               val\
    \ m = v * p + 2\n               if (m <= n) {\n                   sum + m\n  \
    \             } else {\n                   sum\n               }\n           }\n\
    \           result\n       }\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(hexKey((\"AB\")) == (1l));\n    assert(hexKey((\"1077E\")) == (2l));\n\
    \    assert(hexKey((\"ABED1A33\")) == (4l));\n    assert(hexKey((\"2020\")) ==\
    \ (2l));\n    assert(hexKey((\"123456789ABCDEF0\")) == (6l));\n    assert(hexKey((\"\
    112233445566778899AABBCCDDEEFF00\")) == (12l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphm9xaad4.scala:37:46 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                   \e[33mif\e[0m (counter.get(digits(i))\
    \ > \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue > is not a member of Option[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660009926
