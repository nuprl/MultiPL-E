name: HumanEval_142_sum_squares
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // \"\n    // This function will take a list of integers. For all entries in\
  \ the list, the function shall square the integer entry if its index is a \n   \
  \ // multiple of 3 and will cube the integer entry if its index is a multiple of\
  \ 4 and not a multiple of 3. The function will not \n    // change the entries in\
  \ the list whose indexes are not a multiple of 3 or 4. The function shall then return\
  \ the sum of all entries. \n    // Examples:\n    // >>> lst\n    // List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong)\n    // >>> lst\n    // List[Long]()\n    // >>> lst\n \
  \   // List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong, -5l.toLong)\n \
  \   def sumSquares(lst : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sumSquares((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong))) == (6l));\n    assert(sumSquares((List[Long](1l.toLong,\
  \ 4l.toLong, 9l.toLong))) == (14l));\n    assert(sumSquares((List[Long]())) == (0l));\n\
  \    assert(sumSquares((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong,\
  \ 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))) == (9l));\n    assert(sumSquares((List[Long](-1l.toLong,\
  \ -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong, -1l.toLong,\
  \ -1l.toLong))) == (-3l));\n    assert(sumSquares((List[Long](0l.toLong))) == (0l));\n\
  \    assert(sumSquares((List[Long](-1l.toLong, -5l.toLong, 2l.toLong, -1l.toLong,\
  \ -5l.toLong))) == (-126l));\n    assert(sumSquares((List[Long](-56l.toLong, -99l.toLong,\
  \ 1l.toLong, 0l.toLong, -2l.toLong))) == (3030l));\n    assert(sumSquares((List[Long](-1l.toLong,\
  \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, -1l.toLong)))\
  \ == (0l));\n    assert(sumSquares((List[Long](-16l.toLong, -9l.toLong, -2l.toLong,\
  \ 36l.toLong, 36l.toLong, 26l.toLong, -20l.toLong, 25l.toLong, -40l.toLong, 20l.toLong,\
  \ -4l.toLong, 12l.toLong, -26l.toLong, 35l.toLong, 37l.toLong))) == (-14196l));\n\
  \    assert(sumSquares((List[Long](-1l.toLong, -3l.toLong, 17l.toLong, -1l.toLong,\
  \ -15l.toLong, 13l.toLong, -1l.toLong, 14l.toLong, -14l.toLong, -12l.toLong, -5l.toLong,\
  \ 14l.toLong, -14l.toLong, 6l.toLong, 13l.toLong, 11l.toLong, 16l.toLong, 16l.toLong,\
  \ 4l.toLong, 10l.toLong))) == (-1448l));\n    }\n\n}\n"
completions: ["        var sum = 0\n        var numSquares = 0\n        lst.foreach(x\
    \ => {\n            if (x % 3 == 0) {\n                numSquares += 1\n     \
    \           sum += x * x\n            }\n            else if (x % 4 == 0) {\n\
    \                numSquares += 1\n                sum += x * x\n            }\n\
    \            else {\n                sum += x\n            }\n        })\n   \
    \     sum", "        // Your code here\n        lst.foldLeft(0L) { (sum, entry)\
    \ =>\n            val num : Long = if (entry % 3 == 0) (entry*entry) else (entry*entry)\n\
    \            val n2 : Long = if (entry % 4 == 0) (entry*entry) else (entry*entry)\n\
    \            val n3 : Long = if (entry % 4 == 0) (entry*entry) else (entry*entry)\n\
    \            val n4 : Long = if (entry % 3 == 0) (entry*entry) else (entry*entry)\n\
    \            val sum2 : Long = if (entry % 2 == 0) (entry*entry) else (entry*entry)\n\
    \            val sum3 : Long = if (entry % 3 == 0) (entry*entry) else (entry*entry)\n\
    \            val sum4 : Long = if (entry % 4 == 0) (entry*entry) else (entry*entry)\n\
    \            val sum5 : Long = if (entry % 5 == 0) (entry*entry) else (entry*entry)\n\
    \            sum + num + n2 + n3 + n4 + sum2 + sum3 + sum4 + sum5\n        }",
  "        val sum = 0\n        lst.foreach { elem =>\n            if (elem.toInt\
    \ % 3 == 0) {\n                sum += elem\n            }\n            if (elem.toInt\
    \ % 4 == 0) {\n                sum += elem\n            }\n        }\n       \
    \ sum", "        val res = new mutable.ListBuffer[Long]()\n        lst.foreach{i\
    \ =>\n            if(i%3 != 0) res += i*i\n            else if(i%4 != 0) res +=\
    \ i*i*i\n            else res += i\n        }\n        res.sum", "        // Write\
    \ your code here\n        val indexMap = mutable.Map[Int, Int]()\n        var\
    \ sum = 0L\n        lst.foreach( x => \n            if(indexMap.getOrElse(x,0)\
    \ == 0) sum = sum + x\n            else {\n                val index = indexMap.getOrElse(x,\
    \ 0) % 3 //get the index \n                val newIndex = index + (x - index)\
    \ //the new index\n                val newIndex = newIndex % 4 //get the new index\n\
    \                indexMap(newIndex) = indexMap.getOrElse(newIndex, 0) + 1\n  \
    \              sum = Math.pow(sum, 2) + x\n            })\n        sum", "   \
    \     val m = mutable.ListBuffer[Long]()\n        lst.foreach((index: Long) =>\
    \ {\n            if (index % 3 == 0) {\n                m += index\n         \
    \   } else if (index % 4 == 0) {\n                m += index\n            } else\
    \ if (index % 3 != 0 && index % 4 != 0) {\n                m += index\n      \
    \      }\n        })\n        m.sum", "        var ans = 0.0\n        for ( x\
    \ <- lst ) \n        ans = ans + x * x\n        ans", "        // your code here\n\
    \        var ans = 0\n        var i = 0\n        while (i < lst.size) {\n    \
    \        ans = ans + lst.get (i) * lst.get (i) * lst.get (i) + lst.get (i) * lst.get\
    \ (i) * lst.get (i) * lst.get (i) \n            i = i + 1\n        }\n       \
    \ return ans", "        val s = mutable.ListBuffer.empty[Long]\n        for (i\
    \ <- lst.indices) s += lst(i).toLong * lst(i).toLong * lst(i).toLong\n       \
    \ s.sum", "        // 1\n        val res : MutableList[Long] = mutable.ArrayBuffer.empty[Long]\n\
    \        for (i <- 0 until lst.size) {\n            val x = lst(i)\n         \
    \   if (x % 3 == 0) res += x * x\n            if (x % 4 == 0) res += x * x\n \
    \           if (x % 4 != 0 && x % 3 != 0) res += x * x\n        }\n        res.sum",
  "        var list2 = lst.filter(_ % 3 == 0)\n        var list3 = lst.filter(_ %\
    \ 4 == 0)\n        var sum = 0l\n        if(list2.isEmpty) list2.foreach(x =>\
    \ sum += x)\n        if(list3.isEmpty) list3.foreach(x => sum += x)\n        sum",
  "        var sum = 0\n        for (i<- 0 until (lst.length)) {\n            val\
    \ square = lst(i).toLong\n            sum += if (isMultipleOfThree(i) && isMultipleOfFour(i))\
    \ square * square else square\n        }\n        sum", "        val lstCopy =\
    \ lst.copy()\n        lstCopy.foreach(x => if (x % 3 == 0 || x % 4 == 0)\n   \
    \         lstCopy.updated(x, x * x * x)\n        else lstCopy.updated(x, x * x\
    \ * x)) \n        lstCopy.sum", "        val l2 = lst.filter( i => i % 3 == 0\
    \ ).map( i => i * i )\n        val l3 = lst.filter( i => i % 4 == 0 ).map( i =>\
    \ i * i )\n        l2.addAll(l3)", "        lst\n            .map(x => if (x %\
    \ 3 == 0) x * x else x * x * x)\n            .filter(x => x % 4 != 0)\n      \
    \      .sum", "        // 1\n        def isMultipleOf3(x: Long) : Boolean = x%3==0\n\
    \        // 2\n        def isMultipleOf4(x: Long) : Boolean = x%4==0\n       \
    \ \n        val list = mutable.ListBuffer(0)\n        lst.foreach(x => {\n   \
    \         // 3\n            if(isMultipleOf3(x) && lst.isDefinedAt(x){\n     \
    \           // 4\n                if(isMultipleOf4(x) && lst.isDefinedAt(x+3){\n\
    \                    list += x*x\n                }\n                else{\n \
    \                   list += x*x*x\n                }\n            }\n        \
    \    else{\n                list += x*x*x\n            }\n        })\n       \
    \ list.toList.sum", "        var listOfSquares : List[Long] = List()\n       \
    \ var listOfCubes : List[Long] = List()\n        for (i <- 0 until lst.size) {\n\
    \            if (i%3 == 0) listOfSquares += lst(i)\n            if (i%4 == 0)\
    \ listOfCubes += lst(i)\n        }\n        lst.map {x =>\n            if (x%4\
    \ == 0) x*x else x*x*x\n        }.sum", "        // Create an empty list and add\
    \ the first element to the list\n        var sum = 0l\n        sum += lst.head\
    \ \n        // Loop through the list and add all the other elements to the list\n\
    \        for ( i <- 1 until lst.length ) {\n            sum += lst(i)\n      \
    \  }\n        return sum", "        var sum = 0\n        for (i <- lst) {\n  \
    \          if (i % 3 == 0) sum += i\n            if (i % 4 == 0) sum += i * i\n\
    \            else sum = sum + i\n        }\n        sum", "        def isMultipleOf3(i:\
    \ Long) : Boolean = i % 3 == 0\n        def isMultipleOf4(i: Long) : Boolean =\
    \ i % 4 == 0\n        lst.foreach{ x => if(isMultipleOf4(x) || isMultipleOf3(x))\
    \ x *= 2 else x *= 3 }\n        lst.sum", "        // Code goes here\n       \
    \ def addTo(i: Int, acc: Long) : Long = {\n            if (i%3 == 0 || i%4 ==\
    \ 0) acc\n            else addTo(i, acc * i)\n        }\n        val result: mutable.Long\
    \ = mutable.Long(0)\n        lst.foreach(x => result = addTo(x.toInt, result))\n\
    \        result.sum", "        val nums = mutable.ListBuffer[Long]()\n       \
    \ // use forall to return false if an element is not even\n        lst.forall\
    \ { n =>\n            if (n % 3 == 0) nums += n\n            if (n % 4 == 0) nums\
    \ += n * n\n            nums.sum\n        }", "        val lists = lst groupBy\
    \ { _ % 3 }\n        val list4 = lists map { case (idx, items) =>\n          \
    \  if(idx%4==0) items.map(x => x*x) else items\n        }\n        val list3 =\
    \ lists map { case (idx, items) =>\n            if(idx%3==0) items.map(x => x*x)\
    \ \n            else items\n        }\n        list3.reduce(_+_) + list4.reduce(_+_)",
  "        var sum = 0\n        for (i<-lst.indices) {\n            sum += lst(i)\
    \ * lst(i)\n            if (i%3 != 0) {\n                sum += lst(i) * lst(i)\n\
    \            }\n            sum += lst(i)\n        }\n        sum", "        var\
    \ sum = 0L\n        for (i <- 0 until lst.size) {\n            val index = i /\
    \ 3\n            val mult = i % 3\n            if (mult == 0 || (mult != 0 &&\
    \ index == 1 || index == 2)) {\n                sum += lst(i)\n            }\n\
    \        }\n        return sum", "        val numOfInside = 3 :: 4 :: 0 :: Nil\n\
    \        val numOfOutside = lst.filter( i => numOfInside.contains(i))\n      \
    \  numOfOutside.foldLeft(0l) {\n            (acc,x) => acc + (if (x % 3 == 0)\
    \ x * x else x * x * x)\n        }", "        var sum = 0l\n        for (i <-\
    \ 0 until lst.size) {\n            if (i%3==0 || i%4==0) {\n                sum\
    \ = sum + lst(i)\n            }\n        }\n        sum", "        var sum = 0\n\
    \        // TODO: Write your logic here\n        for (i <- lst.indices) {\n  \
    \          if (lst(i) % 3 == 0 || lst(i) % 4 == 0) {\n                lst(i) =\
    \ lst(i) * lst(i)\n                sum += lst(i)\n            }\n        }\n \
    \       return sum", "        // Write your code here\n        var sum = 0\n \
    \       var count = 0\n        var newList = []\n        for (i<- 0 until lst.size)\
    \ {\n            if (i % 3 == 0 || i % 4 == 0) {\n                sum += lst(i)\n\
    \                count += 1\n            } else {\n                newList +=\
    \ lst(i)\n            }\n        }\n        if (count != 0) {\n            sum\
    \ = sum + newList.sum\n        }\n        sum", "        // Your code here\n \
    \       if (lst.forall(i => i % 3 == 0 && i % 4 == 0))\n            lst map (i\
    \ => i * i)\n        else\n            lst map (i => i * i) filter (i => i % 3\
    \ != 0 || i % 4 != 0)", "        val count = lst.size\n        var sum = 0L\n\
    \        var n = 1L\n        for (n in 1 to count) {\n            if (n % 4 ==\
    \ 0 && !(n % 3 == 0))\n                sum += n * n\n            else if (n %\
    \ 3 == 0)\n                sum += n * n * n\n        }\n        sum", "      \
    \  lst.foreach{\n            case i if (i % 3 == 0 || i % 4 == 0) => lst(i) =\
    \ i * i\n            case i if (i % 3 == 0) => lst(i) = i * i\n            case\
    \ i if (i % 4 == 0) => lst(i) = i * i\n            case i => lst(i) = i * i\n\
    \        }\n        lst.reduceLeftOption(_ + _).getOrElse(0)", "        // Write\
    \ your code here\n        var sum = lst.foldLeft(0L){case (sum, curr) => sum +\
    \ curr*curr}\n        val listWith3and4 = (0 until lst.size).filter(_ % 3 == 0\
    \ || _ % 4 == 0)\n        listWith3and4.foreach(x => sum = sum + lst.apply(x))\n\
    \        sum", "        // This map function will return all entries in the list\
    \ whose index are multiples of 3\n        // We start off with a mutable list\
    \ to store our entries in\n        val entries = mutable.MutableList[Long]()\n\
    \        // This map function will return all entries in the list whose index\
    \ are multiples of 4\n        val entries2 = mutable.MutableList[Long]()\n   \
    \     // This map function will square the integer entries and add them to the\
    \ mutable list\n        lst.foreach(x => {\n            if(x % 3 == 0) {\n   \
    \             entries.add(x)\n            } else if(x % 4 == 0) {\n          \
    \      entries2.add(x)\n            }\n        })\n        // This is our return\
    \ variable\n        var returnSum = 0L\n        // We go through all our entries\
    \ and add them all together to the return variable\n        entries.foreach(x\
    \ => {\n            returnSum = returnSum + x\n        })\n        // We go through\
    \ all our entries and add them all together to the return variable\n        entries2.foreach(x\
    \ => {\n            returnSum = returnSum + x\n        })\n        // We return\
    \ the return sum\n        returnSum", "        var sum = 0\n        for (i<-lst;i!=lst.length-1)\
    \ {\n            if (i%4==0) {\n                sum = sum + i*i\n            }\
    \ else if (i%3==0) {\n                sum = sum + i*i*i\n            } else {\n\
    \                sum = sum + i*i*i*i\n            }\n        }\n        sum",
  "        var sum = 0\n        val numOfElements = lst.size\n        lst.foreach(element\
    \ => {\n            if (element % 3 == 0 && element % 4 == 0)\n              \
    \  sum = sum + element\n            if (element % 3 == 0)\n                sum\
    \ = sum + element * element\n            if (element % 4 == 0)\n             \
    \   sum = sum + element * element * element\n        })\n        return sum",
  "        val newlst = lst.filterNot(_%4==0) // remove multiples of 4\n        newlst.map(_*_)",
  "        val squares = mutable.Map[Long, Long]()\n        // use mutable map to\
    \ store all squared entries and sum of squares \n        for(i <- 0 until lst.size)\
    \ {\n            val curSquare = (lst(i)*lst(i)).toLong\n            squares +=\
    \ (lst(i) -> curSquare)\n        }\n        // sum all squared entries and store\
    \ in result\n        val sums = squares.values.sum\n        squares.values.sum",
  "        lst.map { x =>\n            if (x % 3 == 0 || x % 4 == 0) \n          \
    \      x * x\n            else if (x % 3 == 0 || x % 4 == 1)\n               \
    \ x * x * x\n            else if (x % 3 == 1)\n                x * x * x * x\n\
    \            else\n                x * x * x * x * x\n        }.sum", "      \
    \  val result = new mutable.ListBuffer[Long]()\n        for (l: Long <- lst)\n\
    \            if ((l % 3 == 0) || (l % 4 == 0)) result += l\n        lst.toList\
    \ ++ result.toList", "        var sum = 0l\n        for (x <- lst) {\n       \
    \     if (x % 3 == 0 || x % 4 == 0) {\n                sum += 1l\n           \
    \ }\n            else {\n                sum += x * x\n            }\n       \
    \ }\n        sum", "        val mutableList = mutable.ListBuffer[Long]()\n   \
    \     lst.map{\n            x => if(x % 3 == 0) mutableList += x*x\n         \
    \   else if(x % 4 == 0) mutableList += x*x*x\n            else mutableList +=\
    \ x*x*x*x\n        }.sum", "        var i = 0\n        var total = 0l\n      \
    \  while(i < lst.size) {\n            if(lst(i).isMultipleOfFour) {\n        \
    \        lst(i) = lst(i) * lst(i)\n            } else if(lst(i).isMultipleOfThree)\
    \ {\n                lst(i) = lst(i) * lst(i)\n            } else {\n        \
    \        total += lst(i)\n            }\n            i += 1\n        }\n     \
    \   total", "        val numIndexes = lst.zipWithIndex.filter{ case (i: Long,\
    \ idx: Int) => idx % 3 != 0 && idx % 4 != 0}.length\n        val numEven = lst.zipWithIndex.filter{\
    \ case (i: Long, idx: Int) => idx % 3 == 0 && idx % 4 != 0}.length\n        val\
    \ numOdd = lst.zipWithIndex.filter{ case (i: Long, idx: Int) => idx % 3 == 1 &&\
    \ idx % 4 != 0}.length\n        numIndexes match {\n            case 0 => lst.length\n\
    \            case 1 => lst(0) + (lst(0) * (lst(0) * (lst(0) * lst(0))))\n    \
    \        case 2 => lst(0) + (lst(0) * (lst(0) * (lst(0) * (lst(0) * lst(0)))))\n\
    \            case _ => lst(0) + (lst(0) * (lst(0) * (lst(0) * (lst(0) * lst(0)\
    \ * (lst(0) * lst(0))))))\n        }", "        val sq = mutable.ListBuffer.empty[Long]\n\
    \        lst.foreach{x => \n            val m3 = if (x%3==0) x^2 else x\n    \
    \        val m4 = if (x%4==0) x^2 else x\n            sq += m3\n            sq\
    \ += m4\n        }\n        sq.sum", "        // Your code here\n        var sum\
    \ = 0\n        lst.foreach{ \n            x => \n                if(x%3==0){\n\
    \                    x =x*x\n                    sum += x\n                }else\
    \ if(x%4==0){\n                    x =x*x\n                    sum += x\n    \
    \            }else{\n                    sum += x\n                }\n       \
    \ }\n        return sum", "        val res = lst.foldLeft(0l) { (acc, elem) =>\
    \ acc.updated(elem*elem+elem) }\n        res.sum", "        // Your code here\n\
    \        lst.foldLeft(0l) { (a, b) => b + b + a }", '        // Write your code
    here', "        lst.foldLeft(0l) {\n            ((sum: Long, elem: Long) => sum\
    \ + (elem * elem))\n        }", "        // First we create a mutable list of\
    \ Ints, we will use it to store our results, and we initialize it by putting in\
    \ \n        // zeroes\n        val res = mutable.ListBuffer[Int]()\n        //\
    \ We will keep track of the running total using the sums var which we will add\
    \ to each time we square or cube an element\n        val sums = mutable.ListBuffer[Int]()\n\
    \        // We will use the for loop to go through every element in the list\n\
    \        for(i <- 0 until lst.length)\n            // If the element is a multiple\
    \ of 3 or 4\n            if((i % 3) == 0 || i % 4 == 0)\n                // We\
    \ square the element\n                res += (i * i)\n            // Otherwise,\
    \ if the element is a multiple of 3\n            else if(i % 3 == 0)\n       \
    \         // We cube the element\n                res += (i * i * i)\n       \
    \     // Otherwise, if the element is a multiple of 4\n            else if(i %\
    \ 4 == 0)\n                // We square the element\n                res += (i\
    \ * i)\n            // Otherwise, we put a zero since we cannot do anything to\
    \ this element\n            else\n                res += 0\n            // We\
    \ want to add every number to the running total\n            sums += res\n\n \
    \       // We will then add every number in the sums list to the sum of all running\
    \ totals\n        sums.sum", "        lst.foldLeft(0l) {(sum, entry) =>\n    \
    \        if (sum == 0) entry\n            else (entry * entry) + (sum * sum)\n\
    \        }", "        val squaresMap = mutable.Map[Long, Int]()\n        val cubesMap\
    \ = mutable.Map[Long, Int]()\n        lst.foreach{\n            (i, cnt) =>\n\
    \                cnt match {\n                    case 3 => squaresMap += i ->\
    \ cnt\n                    case 4 => cubesMap += i -> cnt\n                  \
    \  case _ => ()\n                }\n        }\n        val sum = (squaresMap.values.sum\
    \ + cubesMap.values.sum) + squaresMap.keySet.sum\n        sum", "        // Initialize\
    \ a mutable sum, initialized to 0.\n        var sum = 0L\n\n        // Declare\
    \ an iterator on the list\n        val it = lst.iterator\n\n        // Iterate\
    \ through the list, squaring and summing if the index is a multiple of 3\n   \
    \     for (i <- 0 to lst.length - 1) {\n            val cur = it(i)\n        \
    \    if (i % 3 == 0)\n                sum += cur * cur\n            if (i % 4\
    \ == 0)\n                sum += cur * cur\n        }\n        // Return the sum\n\
    \        sum", "        var sum = 0\n        lst.foreach(x => {\n            if(x\
    \ % 3 == 0) {\n                sum *= x\n            }\n            if(x % 4 ==\
    \ 0) {\n                sum += x * x\n            }\n        })\n        return\
    \ sum", "        val lst2 = lst.map(x => if(x % 3 == 0 && x % 4 == 0) x * x *\
    \ x else x * x * x * x)\n        lst.foldLeft(0L)((a, b) => a + b + lst2(a % lst2.length))",
  "        val result = new mutable.ArrayBuffer[Long]()\n        lst.foreach{ i =>\n\
    \            if(i % 3 == 0){\n                result += i.toLong * i.toLong\n\
    \            }else if(i % 4 == 0){\n                result += i.toLong * i.toLong\n\
    \            }else{\n                result += i.toLong\n            }\n     \
    \   }\n        result.sum", '        // Complete the function', "        var sum\
    \ : Long = 0\n        var count = 0\n        lst.foreach { entry =>\n        \
    \    if (count % 4 == 0) sum += entry\n            else if (count % 3 == 0) if\
    \ (entry % 3 == 0) sum += entry * entry\n            else if (entry % 4 == 0)\
    \ sum += entry * entry * entry\n            else sum += entry * entry * entry\n\
    \            count += 1\n        }\n        sum", "       //Function to do squares\n\
    \       def square(x :Long): Long = x*x\n       //Function to do cubes\n     \
    \  def cube(x :Long): Long = x*x*x\n       //Function to do even numbers\n   \
    \    def evens(x :Long): Long = if(x%2==0) x else 0\n       //Function to do odd\
    \ numbers\n       def odds(x :Long): Long = if(x%2==1) x else 0\n       //Function\
    \ to do sum of squares\n       def sumSquare(a: List[Long]) : Long = a.reduce(0L){_\
    \ + _}\n       //Function to do sum of cubes\n       def sumCube(a: List[Long])\
    \ : Long = a.reduce(0L){_ + _ + _}\n       //Function to do sum of even numbers\n\
    \       def sumEven(a: List[Long]) : Long = a.reduce(0L){_ + _}\n       //Function\
    \ to do sum of odd numbers\n       def sumOdd(a: List[Long]) : Long = a.reduce(0L){_\
    \ + _}\n       //Function to do sum over odd numbers\n       def sumOddOverOdd(a:\
    \ List[Long]) : Long = a.reduce(0L){_ + _ + _}\n       //Function to do sum over\
    \ even numbers\n       def sumEvenOverEven(a: List[Long]) : Long = a.reduce(0L){_\
    \ + _}\n       //Function to do sum over even numbers\n       def sumEvenOverOdd(a:\
    \ List[Long]) : Long = a.reduce(0L){_ + _ + _}\n       //Function to do sum over\
    \ odd numbers\n       def sumOddOverEven(a: List[Long]) : Long = a.reduce(0L){_\
    \ + _}\n       //Function to do sum over even numbers\n       def sumOddOverOdd(a:\
    \ List[Long]) : Long = a.reduce(0L){_ + _ + _}\n       //Function to do sum over\
    \ even numbers\n       def sumEvenOverEven(a: List[Long]) : Long = a.reduce(0L){_\
    \ + _}\n       //Function to do sum over odd numbers\n       def sumOddOverEven(a:\
    \ List[Long]) : Long = a.reduce(0L){_ + _}\n       //Function to do sum over even\
    \ numbers\n       def sumOddOverOdd(a: List[Long]) : Long = a.reduce(0L){_ + _\
    \ + _}\n       //Function to do sum over ", '        // Your code here', "   \
    \     val retVal = mutable.ListBuffer.empty[Long]\n        for(i <- 0 until lst.length){\
    \ // iterate through list\n            if((lst(i) % 3 == 0) || (lst(i) % 4 ==\
    \ 0)){ // condition for squaring number if its multiple of 3 and cube number if\
    \ its multiple of 4\n                retVal += lst(i) * lst(i)\n            }\n\
    \        }\n        retVal.sum", "        val res: mutable.Set[Long] = mutable.Set()\n\
    \        for (i <- 0 until lst.size) {\n            if (i % 3 == 0) res += lst(i)\n\
    \            else if (i % 4 == 0) res += lst(i)\n            else res += lst(i)^2\n\
    \        }\n        res.sum", "        var sum : Long = 0\n        var lst1 =\
    \ lst\n        for(i <- 0 until lst1.length) {\n            if((i % 3) == 0 &&\
    \ i != 0) sum+=lst1(i)\n            if((i % 4) == 0 && i != 0) sum+=lst1(i)\n\
    \            if((i % 4) == 0 && i != 1) sum+=lst1(i)\n            if((i % 4) ==\
    \ 1 && i != 2) sum+=lst1(i)\n            if((i % 4) == 1 && i != 3) sum+=lst1(i)\n\
    \        }\n        return sum", "        val lstCopy = lst.clone\n        lstCopy.foreach\
    \ {\n        case x => \n            if(x.toInt % 3 == 0) x * x else x * x * x\n\
    \        case _ => \n        }\n        lstCopy.sum", "        def isEven(i :\
    \ Long) : Boolean = {\n            if (i % 2 == 0) \n                true\n  \
    \          else\n                false\n        }\n        val evens : List[Long]\
    \ = lst.filter { i => isEven(i.toInt) }\n        val unEvens : List[Long] = lst.filter\
    \ { i => !isEven(i.toInt) }\n        val sq : List[Long] = evens.map { i => i\
    \ * i }\n        val cube : List[Long] = unEvens.map { i => i * i * i }\n    \
    \    val sumOfEvens : Long = evens.sum\n        val sumOfUnEvens : Long = unEvens.sum\n\
    \        val sumOfCubes : Long = cube.sum\n        val sumOfSums : Long = sq.sum\
    \ + cube.sum\n        val sumOfCubesOfSums : Long = cube.sum + sumOfSums\n   \
    \     val sumOfSumsOfCubes : Long = sumOfSums + sumOfCubes\n        val sumOfCubesOfSumsOfCubes\
    \ : Long = sumOfCubes + sumOfSumsOfCubes\n        sumOfCubesOfSumsOfCubes", " \
    \       // Your code here\n        var sum = 0\n        for (i <- lst) {\n   \
    \         if (i.toLong % 3 == 0) {\n                sum+=i\n            }\n  \
    \          else if (i.toLong % 4 == 0) {\n                sum+=i*i\n         \
    \   }\n            else {\n                sum+=i*i*i\n            }\n       \
    \ }\n        return sum", "        var sum = 0l\n        var sq = 0l\n       \
    \ for(i <- lst.indices) {\n            sum += lst(i)\n            sq = lst(i)\
    \ * lst(i)\n            if(sq % 4 == 0 && sq % 3 == 0)\n                sum -=\
    \ lst(i)\n        }\n        return sum", "        var sum = 0L\n        var isMultipleOfThree\
    \ = false\n        var isMultipleOfFour = false\n        var isMultipleOfNine\
    \ = false\n        var isMultipleOfEleven = false\n        var count = 0\n   \
    \     for(i <- 0 until lst.size) {\n            val elem = lst(i)\n          \
    \  if(elem % 3 == 0) {\n                if(isMultipleOfThree) {\n            \
    \        sum += elem\n                    count += 1\n                }\n    \
    \            else {\n                    sum += elem\n                    isMultipleOfThree\
    \ = true\n                }\n            }\n            else if(elem % 4 == 0)\
    \ {\n                if(isMultipleOfFour) {\n                    sum += elem\n\
    \                    count += 1\n                }\n                else {\n \
    \                   sum += elem\n                    isMultipleOfFour = true\n\
    \                }\n            }\n            else {\n                if(isMultipleOfNine)\
    \ {\n                    sum += elem\n                    count += 1\n       \
    \         }\n                else {\n                    if(isMultipleOfEleven)\
    \ {\n                        sum += elem\n                        count += 1\n\
    \                    }\n                    else {\n                        sum\
    \ += elem\n                        isMultipleOfNine = true\n                 \
    \   }\n                }\n            }\n        }\n        return sum", "   \
    \     var sum = 0\n        for (i <- lst)\n            if (i % 3 == 0 || i % 4\
    \ == 0)\n                sum = sum + i\n            else\n                sum\
    \ = sum * i\n        sum", "        \n        \n        val squared = lst.filter\
    \ { _ % 3 == 0 } \n        val cubed = lst.filter { _ % 4 == 0 } \n        val\
    \ summedSquares = squared.sum\n        val summedCubes = cubed.sum\n        summedSquares\
    \ + summedCubes\n        ", "        var sum = 0\n        lst.foreach { n =>\n\
    \            if (n.toInt % 3 == 0) sum = sum + n.toInt * n\n            else if\
    \ (n.toInt % 4 == 0) sum = sum + n.toInt * n\n            else sum = sum + n.toInt\
    \ * n\n        }\n        return sum", "        var sum = 0L\n        val squared\
    \ = lst.filter(_ % 3 == 0).map(_ * _)\n        val cubed  = lst.filter(_ % 4 ==\
    \ 0).map(_ * _)\n        squared.foreach(sum ++= _)\n        cubed.foreach(sum\
    \ ++= _)\n        sum", "        if (lst.isEmpty) {\n            return 0\n  \
    \      }\n        val lst2 = lst.filter { x => x % 3 == 0 || x % 4 == 0 }\n  \
    \      var sum : Long = 0\n        for (i <- 0 until lst2.size) {\n          \
    \  sum = sum + lst2(i).toLong * lst2(i).toLong\n        }\n        return sum",
  "        var sum = 0\n        var count = 0\n        for(i <- 0 until lst.size)\
    \ {\n            sum += (lst(i) % 3 == 0l) ? lst(i) * lst(i) : lst(i) * lst(i)\n\
    \            count += 1\n        }\n        sum * sum", "        lst.foldLeft(0l){\n\
    \            (total, e) => {\n                total += (if (e.toLong rem 3 ==\
    \ 0L) e * e else (e.toLong rem 4 == 0L) ? e * e * e : e).toLong\n            }\n\
    \        }", "        val count = mutable.ListBuffer.empty[Int]\n        lst.foreach\
    \ {x => if (x%3 == 0 || x%4 == 0) count += 1 }\n        count.sum", "        val\
    \ res: List[Long] = lst.map{ i =>\n            if((i % 3) == 0) {\n          \
    \      i * i\n            }\n            else if((i % 4) == 0){\n            \
    \    i * i\n            }\n            else {\n                i * (i * i)\n \
    \           }\n        }.sum\n        res", "        val newList : mutable.Buffer[Long]\
    \ = mutable.Buffer()\n        lst.foreach{e => \n            if(e%3 == 0 && e%4\
    \ == 0) newList += e * e\n            if(e%4 != 0) newList += e * e\n        \
    \    if(e%3 != 0) newList += e * e\n        }\n        newList.sum", "       \
    \ val squares = mutable.ArrayBuffer[Long]()\n        val cubes = mutable.ArrayBuffer[Long]()\n\
    \        var sum = 0l\n        for (i<-lst; j <- 0 until lst.length)\n       \
    \     if ((i mod 3) == 0) squares.append(lst(i) * lst(i))\n            else if\
    \ ((i mod 4) == 0) cubes.append(lst(i) * lst(i))\n            else sum+=lst(i)\n\
    \        sum", "        //TODO: write your code here\n        lst.foldLeft(0l)\
    \ { (sum, elem) => \n            if(elem % 3 == 0){\n                sum + elem\
    \ * elem \n            } else if(elem % 4 == 0){\n                sum + elem *\
    \ elem * elem\n            } else {\n                sum\n            }\n    \
    \    }", '      lst.map(x => if (x % 3 == 0 || (x % 4 == 0 && x % 3 == 0)) x *
    x else x * x * x).sum', "        // Write your code here.\n        var sum = 0\n\
    \        for (i <- lst) {\n            if (i % 3 == 0) {\n                sum\
    \ = sum + i\n            } else if (i % 4 == 0) {\n                sum = sum +\
    \ i\n            } else {\n                sum = sum * i\n            }\n    \
    \    }\n        sum", "        var sum = 0\n        lst.foreach{ x =>\n      \
    \      val mod3 = x % 3\n            val mod4 = x % 4\n            if (mod3 !=\
    \ 0 || mod4 != 0)\n                sum += x * x\n        }\n        return sum",
  "        val counts = lst.map(x => if (x % 3 == 0) 3*x else 4*x).zipWithIndex.filter(_._2\
    \ % 3 == 0).map(_._1)\n        val sums = counts.sum\n        sums", "       \
    \ // Your code here\n        val counts = mutable.Map[Long, Int]()\n        lst.foreach{x\
    \ => {\n            if ((x % 3) == 0) counts(x+1) = 1\n            else if ((x\
    \ % 4) == 0) counts(x+1) = 2\n            else counts(x+1) = 0\n        }}\n \
    \       lst.map{x => ((counts(x) + 1) * x)}.sum", "        val newList : mutable.ListBuffer[Long]\
    \ = mutable.ListBuffer()\n        for (v <- lst) {\n            if (v % 3 == 0\
    \ || v % 4 == 0) {\n                newList += v\n            }\n        }\n \
    \       val sum = 0\n        for (i <- newList) {\n            sum += i\n    \
    \    }\n        sum.toLong", "        val sum = 0\n        for (i <- lst) {\n\
    \            if (i % 3 == 0) {\n                val square = i * i\n         \
    \       if (i % 4 == 0) {\n                    val cube = i * i * i\n        \
    \            sum += square\n                    sum += cube\n                }\
    \ else {\n                    sum += square\n                }\n            }\
    \ else sum += i * i\n        }\n        return sum", "        var sum = 0l\n \
    \       // If it is a list of Long then we will use the map method of lists. \n\
    \        // For all other data structures, use the foreach method. \n        lst.map(i\
    \ => {\n            // If it is a multiple of 3 then we square it and add it to\
    \ sum. \n            if (i % 3 == 0) {\n                sum += i * i\n       \
    \     }\n            // If it is a multiple of 4 then we cube it and add it to\
    \ sum. \n            else if (i % 4 == 0) {\n                sum += i * i\n  \
    \          }\n            // If it is anything else then we ignore it and do not\
    \ add it to sum.\n            else {\n                // Do nothing\n        \
    \    }\n        }).foldLeft(0l) { (a, v) => a + v }", "        val square = lst.map(\
    \ (n) =>  if (n % 3 == 0 || n % 4 == 0) n * n  else n * n * n )\n        val cube\
    \ = lst.map( (n) =>  if (n % 3 == 0 || n % 4 == 0) n * n * n else n * n * n *\
    \ n )\n        lst.zip(square, cube).map {\n            case (x,y,z) => x + y\
    \ + z\n        }.sum", "       val lstCopy = lst.clone()\n       val sum = 0l\n\
    \       for(x <- lstCopy){\n         if(x % 3 == 0) lstCopy.filter(_ % 3 != 0).map(_\
    \ * _).sum\n         else if(x % 4 == 0) lstCopy.filter(_ % 4 != 0).map(_ * _).sum\n\
    \         else sum += x\n        }\n       sum", "        require(lst != Nil,\
    \ \n            \"The function requires at least one element\")\n        val total\
    \ = 0L\n        var i = 0\n        while(i < lst.size) {\n            if(lst(i)\
    \ % 3 == 0 || lst(i) % 4 == 0)\n            {\n                total += lst(i)\n\
    \            }\n            else if(lst(i) % 3 == 0 && lst(i) % 4 != 0)\n    \
    \        {\n                total += lst(i)*lst(i)\n            }\n          \
    \  else if(lst(i) % 4 == 0 && lst(i) % 3 == 0)\n            {\n              \
    \  total += lst(i)*lst(i)*lst(i)\n            }\n            i += 1\n        }\n\
    \        return total", "        val newLst = lst.filter(_ % 3 == 0).map(_ * _)\n\
    \        val newLst2 = lst.filter(_ % 4 == 0).map(_ * _)\n        newLst.sum +\
    \ newLst2.sum", "        // Write your logic here\n        val len = lst.size\n\
    \        var sum = 0\n        for (i <- 0 until len) {\n            val x = lst(i)\n\
    \            if (i % 3 == 0) {\n                val y = x * x\n              \
    \  sum += y\n            } else if (i % 4 == 0) {\n                val y = x *\
    \ x * x\n                sum += y\n            } else {\n                sum +=\
    \ x\n            }\n        }\n        sum", "        var total = 0L\n       \
    \ var count = 0L\n        for(i <- lst) {\n            if(i%3 != 0 && i%4 != 0)\
    \ {\n                total = total + i\n                count = count + 1\n  \
    \          }\n        }\n        total.toLong", "        var sum = 0l\n      \
    \  for (i<-lst.indices) sum += lst(i)\n        sum", "        val list2 = lst\
    \ map (e => if(e.mod(3) == 0) e*e else e*e)\n        val list3 = list2.filter\
    \ (e => e.mod(4) == 0)\n        list3.sum", '        // TODO', "        if(lst.isEmpty)\
    \ 0\n        else if(lst.exists(_ % 3 == 0)) lst.sum * lst.sum\n        else if(lst.exists(_\
    \ % 4 == 0)) lst.sum * lst.sum\n        else lst.sumSquares(lst.toList)", "  \
    \      var newList: mutable.WrappedArray[Long] = mutable.WrappedArray.empty[Long]\n\
    \        for (i <- 0 until lst.size) {\n            if (i%3 != 0 && i%4 != 0)\
    \ {\n                newList = newList :+ lst(i)\n            }\n        }\n \
    \       val sum = newList.sum\n        if (sum > 0)\n            sum\n       \
    \ else\n            sum + sumSquares(newList)", "        if (lst.isEmpty) 0\n\
    \        else {\n            var list = new mutable.ArrayBuffer[Long]()\n    \
    \        var total = 0\n            var index = 0\n            while (index <\
    \ lst.size) {\n                if (index % 3 == 0 || index % 4 == 0) {\n     \
    \               list += lst(index).toLong\n                    total += lst(index).toLong\
    \ * lst(index).toLong\n                    index += 1\n                } else\n\
    \                    if (index % 3 == 1) {\n                        list += lst(index).toLong\n\
    \                        total += lst(index).toLong * lst(index).toLong\n    \
    \                    index += 1\n                    } else if (index % 3 == 2)\
    \ {\n                        list += lst(index).toLong\n                     \
    \   total += lst(index).toLong * lst(index).toLong\n                        index\
    \ += 1\n                    } else if (index % 4 == 1) {\n                   \
    \     list += lst(index).toLong\n                        total += lst(index).toLong\
    \ * lst(index).toLong\n                        index += 1\n                  \
    \  } else if (index % 4 == 2) {\n                        list += lst(index).toLong\n\
    \                        total += lst(index).toLong * lst(index).toLong\n    \
    \                    index += 1\n                    }\n            }\n      \
    \      list.sum\n        }", "        val lst2 = lst.filter(_%4==0)\n        val\
    \ lst3 = lst.filter(_%4==1)\n        val lst4 = lst.filter(_%4==2)\n        val\
    \ sum = lst2.reduce(_+_) + lst3.reduce(_+_) + lst4.reduce(_+_)\n        sum",
  "        lst.foreach {\n            case i if (i % 3 == 0 || i % 4 == 0) => lst(i)\
    \ = i * i\n            case i => lst(i) = i * i * i\n        }\n        lst.sum",
  "        val result = 0\n        for ( i <- lst) {\n            if(i % 3 == 0) result\
    \ += (i % 3) * (i % 3) \n            if(i % 4 == 0) result += (i % 3) * (i % 3)\
    \ * (i % 3) \n            result += i\n        }\n        result", "        //\
    \ TODO Auto-generated method stub\n        var sum = 0l\n        for(i <- 0 until\
    \ lst.size) {\n            if(i % 3 == 0) {\n                sum *= lst(i)\n \
    \           } else if(i % 4 == 0) {\n                sum *= lst(i)\n         \
    \   } else {\n                sum += lst(i)\n            }\n        }\n      \
    \  sum", "        val squares = mutable.HashSet[Long]()\n        val cubes = mutable.HashSet[Long]()\n\
    \        val result = mutable.ListBuffer[Long]()\n        for (entry <- lst) {\n\
    \            if (entry % 3 == 0 || entry % 4 == 0) squares += entry\n        \
    \    if (entry % 3 == 0) cubes += entry\n        }\n        squares.foreach {\
    \ sq => result += sq * sq }\n        cubes.foreach { cu => result += cu * cu }\n\
    \        lst.length.toLong + result.length", "        var sum = 0L\n        for(i\
    \ <- 0 until lst.size) {\n            sum += if((i%3L==0L || i%4L==0L || i%3L==0L\
    \ || i%4L==0L)) lst(i) else lst(i) * lst(i)\n        }\n        sum", "      \
    \  var sum = 0L\n        for(i <- 0 until lst.length) sum += lst(i) * lst(i)\n\
    \        sum", "        // Your code goes here\n        var sum = 0\n        var\
    \ count = 0\n        var lastIndex = lst.length - 1\n        lst.foreach { x =>\
    \ \n            if ( x % 3 == 0 ) { \n                val square = x * x \n  \
    \              sum += square \n                count += 1\n            } else\
    \ if ( x % 4 == 0 ) {\n                val cube = x * x\n                sum +=\
    \ cube \n                count += 1\n            } else if ( (x % 3 != 0) & (x\
    \ % 4 != 0) ) {\n                val diff = x - lastIndex \n                sum\
    \ += diff * diff \n                count += 1\n            }\n            lastIndex\
    \ = x \n        }\n        sum", "        var sum : Long = 0\n        var i =\
    \ 0\n        while (i < lst.size) {\n            if (lst(i) % 3 == 0) {\n    \
    \            sum+ = lst(i) * lst(i)\n                i += 1\n            } else\
    \ if (lst(i) % 4 == 0) {\n                sum+ = lst(i) * lst(i)\n           \
    \     i += 1\n            } else {\n                sum += lst(i)\n          \
    \      i += 1\n            }\n        }\n        sum", "        val sum = 0\n\
    \        lst.foreach { entry =>\n            if (entry % 3 == 0)\n           \
    \     sum + entry * entry\n            if (entry % 4 == 0)\n                sum\
    \ + entry * entry\n        }\n        sum", '        // TODO: Complete this function',
  "        require(!lst.isEmpty)\n        require(!lst.contains(-1) && lst.contains(-5))\n\
    \        val sum = 0L\n        for (i <- lst.indices) {\n            if (i % 3\
    \ == 0) {\n                sum += lst(i)\n            }\n            if (i % 4\
    \ == 0) {\n                sum += lst(i)\n            }\n        }\n        sum",
  "        val sqm = new scala.collection.mutable.ListBuffer[Long]()\n        lst.map(x\
    \ => \n            if (x % 3 == 0) sqm += x*x \n            else if ((x % 4 ==\
    \ 0) || (x % 3 == 0)) sqm += x*x*x \n            else sqm += x*x*x*x )\n     \
    \   sqm.sum", "        val m = lst.take(3).foldLeft(0)((x,y) => (x*x+y*y))\n \
    \       lst.takeWhile(_%3 != 0).map(x => (x*x*x)).sum + lst.takeWhile(_%4 != 0).map(x\
    \ => (x*x*x)).sum + m", "        var result = 1l.toLong\n        lst.foreach{\n\
    \            x => {\n                if(x%4 == 0)\n                    result\
    \ = result * x\n                else if(x%4 == 1)\n                    result\
    \ = result * x*x\n                else\n                    result = result *\
    \ x*x*x\n            }\n        }\n        result", "        if (lst == Nil)\n\
    \            return 0L\n        val n = lst.size\n        val ls = lst.takeWhile{i\
    \ => i % 3 == 0}\n        val ln = lst.dropWhile{i => i % 3 == 0}\n        val\
    \ ls2 = ls.takeWhile{i => i % 4 == 0}\n        val ln2 = ln.dropWhile{i => i %\
    \ 4 == 0}\n        val final = ls2.map(_ * _) + ln2.map(_ * _)\n        lst.zip(final).sum",
  '        // Write your code here', "        val res = mutable.ListBuffer.empty[Long]\n\
    \        for {\n            i <- lst\n            mod = i % 3\n        } yield\
    \ {\n            if (mod != 0) {\n                res += i * i * i\n         \
    \   } else if (mod != 1) {\n                res += i * i\n            } else if\
    \ (mod != 2) {\n                res += i\n            }\n        }\n        res.sum",
  "        val newList : mutable.Set[Long] = mutable.Set.empty[Long]\n        lst.foreach\
    \ {\n            i => if (i.toLong % 3 == 0) newList += i * i.toLong else if (i.toLong\
    \ % 4 == 0) newList += i * i.toLong else newList += i.toLong }\n        newList.sum",
  "        val lstInt = lst.map {\n        case i if i % 3 == 0 || i % 4 == 0 => i\n\
    \        case i => i.toInt", "        \n        // Your code goes here\n     \
    \   lst.foreach { i => if (i % 3 == 0 || i % 4 == 0) i = i * i else i = i * i\
    \ * i }\n        lst.sum", "        var sum : Long = 0\n        var count3 : Int\
    \ = 0\n        var count4 : Int = 0\n        var square = lst.map(x => if(x %\
    \ 3 == 0) x*x else x*x*x)\n        square = square.filter(x => x % 4 != 0)\n \
    \       square = square.filter(x => x % 3 != 0)\n        for(i <- 0 until square.length)\
    \ sum = sum + square(i)\n        sum", "        val numOfMultiple3 = (0 until\
    \ lst.size).filter(x => (x % 3) == 0).sum\n        val numOfMultiple4 = (0 until\
    \ lst.size).filter(x => (x % 4) == 0).sum\n        val sum = (0 until lst.size).sum\n\
    \        lst.foreach { x =>\n            val isMultiple3 = x % 3 == 0\n      \
    \      val isMultiple4 = x % 4 == 0\n            if(isMultiple3 && isMultiple4)\n\
    \                sum + x // this isn't needed since this would just be multiplied\
    \ by 4\n            else if(isMultiple3)\n                sum + x * x\n      \
    \      else if(isMultiple4)\n                sum + x * x * x\n            else\n\
    \                sum\n        }\n        sum + numOfMultiple3 * numOfMultiple4",
  "        // Your code goes here\n        val sums = mutable.Map[Long, Long]()\n\
    \        lst.foreach {\n          i =>\n            val index = i / 3\n      \
    \      if (index.toInt == 0 && i % 3 != 0) {\n              sums += i -> i * i\n\
    \            } else {\n              if (index.toInt % 4 == 0) {\n           \
    \     sums += i -> i * i * i\n              } else {\n                sums +=\
    \ i -> i * i * i\n              }\n            }\n        }\n        sums.values.sum",
  "        var sum = 0L\n        for ( i <- lst; if (i % 3 == 0 || i % 4 == 0) ) sum\
    \ += i\n        sum", "        def isMultiple(i : Long, mul : Long) : Boolean\
    \ = {\n            val div = i % mul\n            return div != 0\n        }\n\
    \        val sqr = lst.map(x => x * x)\n        val mod = lst.filter(x => isMultiple(x,\
    \ 3)).map(x => x * x)\n        val mod4 = lst.filter(x => isMultiple(x, 4)).map(x\
    \ => x * x)\n        val sum = lst.map(x => x * x).sum\n        sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum\
    \ + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum + sum", " \
    \       var sum = 0\n        for (i <- lst)\n            if (i % 3 == 0 || i %\
    \ 4 == 0)\n                sum += i\n            else\n                sum +=\
    \ i * i\n        sum", "      lst match {\n        case Nil => 0\n        case\
    \ x :: xs =>\n            val sum: Long = x.toLong match {\n              case\
    \ i if i % 3 == 0 => i * i\n              case i if i % 4 == 0 => i * i\n    \
    \          case _ => 0\n            }\n            lst.filter(_ % 3 == 0 || _\
    \ % 4 == 0).foreach(x => sum += x)\n            sum\n      }", "        // Write\
    \ your solution here\n        lst.filter(_ % 3 == 0 || _ % 4 == 0).map(x => (x\
    \ * x)).sum", "        val result = (0l).asInstanceOf[Long]\n        lst.foreach(i\
    \ => if(i%4==0) result += i*i else result += i*i*i)\n        result", '        //
    Complete the function here', "        val n = lst.size\n        lst.foldLeft(0.0)\
    \ { case (sum, a) =>\n            if (a % 3 == 0 && a % 4 == 0) (sum + a * a)\n\
    \            else if (a % 3 == 0) (sum + a * a * a)\n            else if (a %\
    \ 4 == 0) (sum + a * a * a * a)\n            else sum\n        }", "       lst\
    \ match {\n          case Nil => 0L\n          case _ => {\n             val map\
    \ = mutable.HashMap()\n             for (i <- lst) \n                if (i%3==0L)\
    \ map(3L) = map(3L) + i\n                else map(i%4L) = map(i%4L) + i\n    \
    \         map.values.sum\n          }\n       }", "        lst.zipWithIndex.flatMap\
    \ {\n        case (value, index) if (index % 3 == 0 || index % 4 == 0) =>\n  \
    \          value + value * value\n        case value => List()\n        }.sum",
  "        lst.map(x => {\n            if(x % 3 == 0 && x % 4 == 0) x * x\n      \
    \      else if(x % 3 == 0) x * x * x\n            else x * x * x * x\n       \
    \ }).sum", "        val squares = lst.map(i => if (i % 3 == 0) i*i else i*i*i)\n\
    \        val cubes = lst.map(i => if (i % 4 == 0) i*i*i else i*i*i*i)\n      \
    \  squares.sum + cubes.sum", "        // TODO: \n        val res = mutable.ListBuffer.empty[Long]()\n\
    \        lst.foreach(x => {\n            val mult = if (x % 3 == 0) 3 else 4\n\
    \            if (x % mult == 0) res += x * x\n        })\n        res.foldLeft(0)(_\
    \ + _)", "        var sum = 0\n        var counter = 3\n        val listWithCounter\
    \ = lst.filter {\n            i => i % counter == 0\n        }\n        listWithCounter.foreach{\n\
    \            i => if (i % counter == 0) sum += i * i\n            counter += 4\n\
    \        }\n        sum", "        val lst2 = lst filter { x => x % 3 == 0 ||\
    \ (x % 4 == 0 && x % 3 != 0) } \n        lst2.foldLeft(0l)( (acc,x) => acc + x\
    \ * x )", "        var total = 0L\n        for (i <- 0 until lst.size) {\n   \
    \         if (i % 3 == 0) total += lst(i)\n            if (i % 4 == 0) total +=\
    \ lst(i)\n            else lst(i) = total\n        }\n        total", "      \
    \  val m = mutable.ListBuffer[Long]()\n        for(i <- lst if i % 3 == 0){\n\
    \            m.append(i * i)\n        }\n        for(i <- lst if i % 4 == 0){\n\
    \            m.append(i * i * i)\n        }\n        m.sum", "        val n =\
    \ lst.length\n        val sum = 0\n        for(i <- 1 to n)\n            if (i%3\
    \ == 0 && i%4 == 0)\n                sum += lst(i)\n                else if (i%3\
    \ == 0)\n                    sum += lst(i) * lst(i)\n                else if (i%4\
    \ == 0)\n                    sum += lst(i) * lst(i) * lst(i)\n               \
    \ else\n                    sum += lst(i) * lst(i) * lst(i) * lst(i)\n       \
    \ sum", "        // write your logic here\n        lst.map {\n            case\
    \ i if (i % 3 == 0) => i * i\n            case i if (i % 4 == 0) => i * i\n  \
    \          case i => i\n        }.sum", "        // 1\n        val isMultipleOf3\
    \ = lst.map(i => i % 3) == 0\n        // 2\n        val isMultipleOf4 = lst.map(i\
    \ => i % 4) == 0\n        // 3\n        val updatedList = lst.filter(i => (i %\
    \ 3 != 0) && (i % 4 != 0))\n        // 4\n        updatedList.foldLeft(0)((x,\
    \ y) => x + y * y)", "        val n = lst.size\n        val sum = 0\n        var\
    \ sq = 0\n        var i = 0\n        while(i < n) {\n          val x = lst(i)\n\
    \          if(x % 3 == 0 || x % 4 == 0) {\n            sum = sum + x\n       \
    \   } else {\n            sq = sq + (x * x)\n          }\n          i += 1\n \
    \       }\n        sq + sum\n      }", "        var sum = 0L\n        var square\
    \ = 0\n        var cube = 0\n        for (i <- 0 until lst.size) {\n         \
    \   if (i%3 == 0 && i%4 != 0) {\n                square = lst.apply(i) * lst.apply(i)\n\
    \            } else if (i%4 == 0 && i%3 != 0) {\n                cube = lst.apply(i)\
    \ * lst.apply(i)\n            } else {\n                sum += lst.apply(i)\n\
    \            }\n        }\n        sum + square + cube", "        // TODO: complete\
    \ the function here\n        val newList = lst.map(x => if (x % 3 == 0) x * x\
    \ else x * x * x).filter(_ % 4 != 0)\n        lst.zipWithIndex.filter(_._1 % 3\
    \ != 0).map(_._2).toList + lst.zipWithIndex.filter(_._1 % 4 != 0).map(_._2).toList",
  "        var sum = 0\n        lst.foreach{ elem =>\n            if(elem.toInt %\
    \ 3 == 0) elem *= elem\n            if(elem.toInt % 4 == 0) elem *= elem\n   \
    \         sum += elem\n        }\n        sum", '        // Your code here', '        //
    Your code here!', "        // TODO: Your code here\n        // Your solution\n\
    \        val totalSquares = lst.filter{ x => x % 3 == 0 || x % 4 == 0 }.map {\
    \ x => x * x }.sum\n        val totalCubes = lst.filter{ x => x % 3 == 0 || x\
    \ % 4 == 0 }.map { x => x * x * x }.sum\n        totalSquares + totalCubes", '        lst.foldLeft(0)((a,
    b) => a + b * b)', "        var result : Long = 0\n        // For every element\
    \ in list, if index is multiple of 3, square, if index is multiple of 4, cube,\
    \ otherwise ignore.\n        lst.foreach{\n            i =>\n                if((i\
    \ % 3) ==0) result += i * i\n                if((i % 4) == 0) result -= i * i\
    \ * i\n                if((i % 4) != 0 && (i % 3) != 0) result -= i * i * i\n\
    \        }\n        result", "        // Write your code here\n        lst.foldLeft(0l)\
    \ {\n            (sum, element) => sum + element * element\n        }", "    \
    \    val count = lst.size\n        var sum = 0\n        for (i<- 0 to count-1)\
    \ {\n            val index = i % 3\n            if (index == 0) sum += lst(i)\n\
    \            else if (index == 1) sum += lst(i) * lst(i)\n            else if\
    \ (index == 2) sum += lst(i) * lst(i) * lst(i)\n        }\n        sum", "   \
    \     require(!lst.isEmpty, \"Cannot sum an empty list\")\n        val result:\
    \ List[Long] = List.empty[Long]\n        for(i <- 0 until lst.size){\n       \
    \     val a = lst(i).toInt\n            val b = a * 2\n            val c = b *\
    \ 2\n            val d = c * 2\n            val e = d * 2\n            val f =\
    \ e * 2\n            val g = f * 2\n            val h = g * 2\n            val\
    \ i = h * 2\n            val j = i * 2\n            val k = j * 2\n          \
    \  val l = k * 2\n            val m = l * 2\n            val n = m * 2\n     \
    \       val o = n * 2\n            val p = o * 2\n            val q = p * 2\n\
    \            val r = q * 2\n            val s = r * 2\n            val t = s *\
    \ 2\n            val u = t * 2\n            val v = u * 2\n            val w =\
    \ v * 2\n            val x = w * 2\n            val y = x * 2\n            val\
    \ z = y * 2\n            val a2 = a.toLong\n            val b2 = b.toLong\n  \
    \          val c2 = c.toLong\n            val d2 = d.toLong\n            val e2\
    \ = e.toLong\n            val f2 = f.toLong\n            val g2 = g.toLong\n \
    \           val h2 = h.toLong\n            val i2 = i.toLong\n            val\
    \ j2 = j.toLong\n            val k2 = k.toLong\n            val l2 = l.toLong\n\
    \            val m2 = m.toLong\n            val n2 = n.toLong\n            val\
    \ o2 = o.toLong\n            val p2 = p.toLong\n            val q2 = q.toLong\n\
    \            val r2 = r.toLong\n            val s2 = s.toLong\n            val\
    \ t2 = t.toLong\n            val u2 = u.toLong\n            val v2 = v.toLong\n\
    \            val w2 = w.toLong\n            val x2 = x.toLong\n            val\
    \ y2 = y.toLong\n            val z2 = z.toLong\n            result += a2 + b2\
    \ + c2 + d2 + e2 + f2 + g2 + h2 + i2 + j2 + k2 + l2 + m2 + n2 + o2 + p2 + q2 +\
    \ r2 + s2 + t2 + u2 + v2 + w2 + x2 + y2 + z2\n        }\n        result.foldLeft(0l)\
    \ { (acc, value) => acc + value }", "        // Your solution goes here\n    \
    \    var sum = 0l\n        for (i <- 0 until lst.length){\n            if ((i\
    \ mod 3) == 0) sum += lst(i) * lst(i)\n            if((i mod 4) == 0) sum += lst(i)\
    \ * lst(i)\n            else sum += lst(i)\n        }\n        sum", "       \
    \ // TODO: write your code in here\n        lst.map(x => if (x % 3 == 0 && x %\
    \ 4 == 0) x * x else if (x % 3 == 0) x * x * x else x * x * x * x).sum", "   \
    \     // Your code here\n        lst.foldLeft(0) { (acc,val) => acc + if (val\
    \ % 3 == 0 && val % 4 != 0) val * val else val * val * val }", "        // Write\
    \ your code here\n        val result = 0\n\n        // if lst is empty\n     \
    \   if(lst.isEmpty) {\n            result = 0\n        } else {\n            //\
    \ if first entry is a multiple of 3 \n            if(lst(0).isMultipleOfThree)\
    \ {\n                result =lst(0).doubleValue * lst(0).doubleValue\n       \
    \         // for every other entry in the list except the first \n           \
    \     for(i <- 1 to lst.size - 1) {\n                    // if index i is a multiple\
    \ of 3 \n                    if(lst(i).isMultipleOfThree) {\n                \
    \        result = result + lst(i).doubleValue * lst(i).doubleValue\n         \
    \           } else\n                    // if index i is a multiple of 4 \n  \
    \                  if(lst(i).isMultipleOfFour) {\n                        result\
    \ = result + lst(i).doubleValue * lst(i).doubleValue\n                    }\n\
    \                }\n            }\n            // if first entry is not a multiple\
    \ of 3 \n            else {\n                result =lst(0).doubleValue * lst(0).doubleValue\n\
    \                // for every other entry in the list except the first \n    \
    \            for(i <- 1 to lst.size - 1) {\n                    // if index i\
    \ is a multiple of 3 \n                    if(!lst(i).isMultipleOfThree) {\n \
    \                       result = result + lst(i).doubleValue * lst(i).doubleValue\n\
    \                    } else\n                    // if index i is a multiple of\
    \ 4 \n                    if(!lst(i).isMultipleOfFour) {\n                   \
    \     result = result + lst(i).doubleValue * lst(i).doubleValue\n            \
    \        }\n                }\n            }\n        }\n\n        return result.toLong",
  "        var sum = 0\n        var counter = 0\n\n        for (i <- lst.indices)\
    \ {\n            // \"\n            // If the integer index i is even (i is even),\
    \ we perform an operation on its value (i).\n            // If the integer index\
    \ i is odd, we perform an operation on its value (i) * i.\n            if (i%2\
    \ == 0) {\n                // \"\n                // We square the integer entry\
    \ at index i.\n                // \"\n                sum += i.toLong * i\n  \
    \          }\n            // \"\n            // If the integer index i is even\
    \ and i is not a multiple of 3, then we perform an operation on its value (i).\n\
    \            // If the integer index i is odd and not a multiple of 4, then we\
    \ perform an operation on its value (i) * i.\n            if (i%2 == 1 && i%3\
    \ == 0){\n                // \"\n                // We cube the integer entry\
    \ at index i.\n                // \"\n                sum += i.toLong * i\n  \
    \          }\n            // \"\n            // If the integer index i is even\
    \ and i is a multiple of 3 and i is not a multiple of 4, then we perform an operation\
    \ on its value (i).\n            // If the integer index i is odd and i is a multiple\
    \ of 4 and i is not a multiple of 3, then we perform an operation on its value\
    \ (i) * i.\n            if (i%2 == 1 && i%4 == 0 && !(i%3 == 0)){\n          \
    \      // \"\n                // We cube the integer entry at index i.\n     \
    \           // \"\n                sum += i.toLong * i\n            }\n      \
    \      // \"\n            // If the integer index i is not even and i is a multiple\
    \ of 3 then we perform an operation on its value (i).\n            // If the integer\
    \ index i is not even and i is a multiple of 4 and not a multiple of 3, then we\
    \ perform an operation on its value (i) * i.\n            if (i%2 != 0 && i%3\
    \ == 0){\n                // \"\n                // We cube the integer entry\
    \ at index i.\n                // \"\n                sum += i.toLong * i\n  \
    \          }\n            // \"\n            // If the integer index i is not\
    \ even and i is a multiple of 4 then we perform an operation on its value (i).\n\
    \            // If the integer index i is not even and i is a multiple of 3 and\
    \ not a multiple of 4, then we perform an operation on its value (i) * i.\n  \
    \          if (i%2 != 0 && i%4 == 0 && !(i%3 == 0)){\n                // \"\n\
    \                // We cube the integer entry at index i.\n                //\
    \ \"\n                sum += i.toLong * i\n            }\n            // \"\n\
    \            // We increment the counter by 1.\n            counter += 1\n   \
    \     }\n        // \"\n        // We return the sum of all entries in the list\
    \ whose indexes are not a multiple of 3 or 4 as long", "        var sum = 0L;\n\
    \        var square = 0L;\n        for(i <- 0 until lst.size) {\n            val\
    \ index = i\n            if (index % 3 == 0L) {\n                square += lst(i)\n\
    \            }\n            if (index % 4 == 0L) {\n                sum += lst(i)\n\
    \            }\n        }\n        return sum", "        val result = 0\n    \
    \    for (i <- 0 until lst.size) {\n            val isMultipleOf3 = (i % 3 ==\
    \ 0)\n            val isMultipleOf4 = (i % 4 == 0)\n            val isMultipleOf3And4\
    \ = isMultipleOf3 && isMultipleOf4\n            val isNotMultipleOf3And4 = !(isMultipleOf3\
    \ && isMultipleOf4)\n            if (isMultipleOf3And4 || isNotMultipleOf3And4)\
    \ {\n                result += lst(i)\n            }\n        }\n        result",
  "        // Initialize two collections -- one for divisors below 3 and the other\
    \ for divisors above 4.\n        val divsBelow3 = mutable.ArrayBuffer(3l.toLong)\n\
    \        val divsAbove4 = mutable.ArrayBuffer(4l.toLong)\n        // Iterate through\
    \ each entry in the list\n        lst.foreach(i => \n        {\n            //\
    \ If the current entry is a multiple of 3, then add it to the divisors below 3\n\
    \            if (i % 3l.toLong == 0)\n                divsBelow3 += i\n      \
    \      // Else, if the current entry is a multiple of 4, then add it to the divisors\
    \ above 4\n            else if (i % 4l.toLong == 0)\n                divsAbove4\
    \ += i\n            // Else, if the current entry is not a multiple of either\
    \ 3 or 4, then simply append it to the list\n            else\n              \
    \  lst += i\n        }) \n        // Calculate the sum of all entries in lst that\
    \ are multiples of either 3 or 4 and return the result\n        divsBelow3.sum\
    \ + divsAbove4.sum", "        lst.toList.zipWithIndex.map {\n            case\
    \ (l, i) => \n                if (i % 3 == 0) l * l else l * l * l\n        }.sum",
  "        // Only change code below this line\n        lst.foldLeft(0.0l) {\n   \
    \       (total, num) => total + (if (num.toInt%3 != 0) num*num else num*num*num)\n\
    \        }\n        // Only change code above this line", "        // Your code\
    \ here\n        val map = new mutable.HashMap[Long, Int]()\n        lst.zipWithIndex.foreach{case\
    \ (el, idx) => if (idx % 3 == 0 && idx % 4 == 0) map.put(el, el * el) else map.put(el,\
    \ el * el * el)}\n        map.values.sum", "        var sum: Long = 0\n      \
    \  for(i <- lst){\n            sum += (i * i)\n        }\n        sum", "    \
    \    // Your code here\n        val result = mutable.ArrayBuffer.empty[Long]\n\
    \        lst.foreach{ i =>\n            if (i % 3 == 0)\n                result\
    \ = result :+ i * i\n            else if (i % 4 == 0)\n                result\
    \ = result :+ i * i * i\n            else\n                result = result :+\
    \ i * i * i * i\n        }\n        result.sum", "        var result : Long =\
    \ 0\n        lst.foreach{ \n            case i : Long if i % 3 == 0 => result\
    \ += (math.pow(i,2))\n            case i : Long if i % 4 == 0 => result += (math.pow(i,3))\n\
    \            case i : Long if i % 3 != 0 || i % 4 != 0 => result += i\n      \
    \  }\n        result", "        // Write code here\n        var sum = 0\n    \
    \    var sumOfAllEntries = 0\n\n        for ( i <- lst.indices) {\n          \
    \  if (i % 3 == 0) {\n                sum += lst(i)\n            } else if (i\
    \ % 4 == 0) {\n                sum += lst(i)\n            } else if (i % 3 ==\
    \ 0 && i % 4 == 0) {\n                sum += lst(i)\n            }\n         \
    \   sumOfAllEntries += lst(i)\n        }\n        return sumOfAllEntries", " \
    \       def sumSquared(x : Long, i : Int) : Long = {\n            val n = x %\
    \ i\n            if (n != 0) n * x + sumSquared(x, n) else x\n        }\n    \
    \    val result = lst.zipWithIndex.foldLeft(0L)((a, b) => a + sumSquared(b._1,\
    \ b._2))\n        result", "        var sum = 0\n        for ( i <- lst) {\n \
    \           if ( i%3 != 0 ) {\n                sum += i\n            } else if\
    \ ( i%4 != 0 ) {\n                sum += i\n            } else {\n           \
    \     sum += i*i\n            }\n        }\n        sum", "        lst.foldLeft(0l)\
    \ {\n            (sum, index) => sum + index.toLong * index.toLong\n        }",
  "        var sum = 0L\n        // TODO Your code goes here\n        for ( i <- lst\
    \ ) {\n            if ( i % 3 == 0 ) {\n                sum += 1L\n          \
    \  } else {\n                sum *= i\n            }\n        }\n        return\
    \ sum", "        lst.foreach(x =>\n            if ((x % 3) == 0) println((x *\
    \ x).toLong)\n            else if ((x % 4) == 0) println((x * x).toLong)\n   \
    \         else println((x * x).toLong)\n            )\n        println(\"The sum\
    \ of all entries is : \" + lst.sum)", "        val ls = lst.filter(_ % 3 != 0\
    \ && _ % 4 != 0)\n        val sumOfSquare = ls.map { x => x * x }.sum\n      \
    \  lst.filter(_ % 3 != 0 && _ % 4 != 0).map(_ => x * x).sum + sumOfSquare", " \
    \       lst.foldLeft(0l) {\n            (a, b) => (a + b) * (a + b)\n        }",
  "        // Write your code here.\n        lst.foldLeft(0L)( (acc,x) => if(x % 3\
    \ == 0) acc + (x * x) else (acc + (x * x * x)) )", "        // TODO: Your code\
    \ here\n        val sqList = new mutable.ListBuffer[Long]()\n        val cuList\
    \ = new mutable.ListBuffer[Long]()\n        lst.foreach((x, i) => {\n        \
    \    if (i % 3 == 0) {\n                sqList += x*x\n            } else if (i\
    \ % 4 == 0) {\n                cuList += x*x\n            } else {\n         \
    \       sqList += x\n                cuList += x\n            }\n        })\n\
    \        sqList.sum\n        cuList.sum", "        // Write your solution here\n\
    \        var total : Long = 0\n        lst.foreach {\n            case (x: Int)\
    \ => if (x % 3 == 0) x*x else x*x*x\n            case (x: Long) => if (x % 4 ==\
    \ 0) x*x else x*x*x\n            case _ => total += x\n        }\n        total",
  "        var total = 0L\n        var sum = 0L\n        for (i<- 0 until lst.size)\
    \ {\n            val x = lst(i)\n            if (x % 3 == 0 && x % 4 == 0) {\n\
    \                total += x\n            } else {\n                sum += x\n\
    \            }\n        }\n        total += sum\n        return total", "    \
    \    var sum = 0\n        for (i <- 0 until lst.length) {\n            if (i mod\
    \ 3 == 0) {\n                sum += i * i\n            }\n            if (i mod\
    \ 4 == 0) {\n                sum += i * i * i\n            }\n        }\n    \
    \    sum", "        val list = mutable.ListBuffer.empty[Long]\n        var sum\
    \ = 0\n        lst.foreach(x => if((x % 3) ==0) list+=x; else if((x % 4) ==0)\
    \ list+=x*x; else list+=x*x*x)\n        list.foreach(x => sum = sum + x)\n   \
    \     sum", "        val lsq = lst.filter(_%3 != 0 || _%4 != 0)\n        val ls3\
    \ = lst.filter(_%3 ==0)\n        val ls4 = lst.filter(_%4 == 0)\n        ls3.map{x\
    \ => x*x}.reduce(_ + _)\n        ls4.map{x => x*x}.reduce(_ + _)\n        lsq.map{x\
    \ => x*x}.reduce(_ + _)", "        val sum = 0l\n        for (i <- 0 until lst.size)\
    \ {\n            if (i % 3 == 0 || i % 4 == 0) {\n                sum += lst(i)\n\
    \            }\n        }\n        sum", "        var sum = 0\n        var square\
    \ = 0\n        lst.foreach {\n            i =>\n                // if index mod\
    \ 4 == 0\n                if (i % 4 == 0) {\n                    square += i\n\
    \                    // if index mod 3 == 0\n                } else if (i % 3\
    \ == 0) {\n                    square += i * i\n                } else {\n   \
    \                 sum += i\n                }\n        }\n        return sum +\
    \ square", '        ', "        var sum = 0\n        for( i <- 0 until lst.size\
    \ ) {\n            var squares: Long = 0\n            if( lst(i) % 3 == 0 ) {\n\
    \                squares = lst(i) * lst(i)\n            } else {\n           \
    \     squares = lst(i) * lst(i)\n            }\n            sum += squares\n \
    \       }\n        sum", "      var lst1 = lst.filter( i => (i % 3 != 0))\n  \
    \    var lst2 = lst.filter( i => (i % 4 != 0))\n      var lst3 = lst.filter( i\
    \ => ((i % 3 != 0) && (i % 4 != 0)))\n      var res = new mutable.ListBuffer[Long]()\n\
    \      lst1.foreach( i => res += i * i)\n      lst2.foreach( i => res += i * i)\n\
    \      lst3.foreach( i => res += i * i)\n      res.toList.reduce( _ + _)", " \
    \       val n = lst.size\n        var sum = 0\n        for (i <- 0 until n) {\n\
    \            if (i %% 3 == 0 || i %% 4 == 0 || i % 3 != 0 || i % 4 != 0) {\n \
    \               sum += lst(i)\n            }\n        }\n        return sum",
  "        val newList = mutable.ListBuffer[Long]()\n        val sum = 0\n\n     \
    \   lst.foreach(x => {\n            val y = x * x\n            val z = x * y\n\
    \            if (z % 4 == 0) newList += z\n            if (y % 3 == 0) newList\
    \ += y\n            if (x % 3 == 0) newList += x\n            if (x % 4 == 0)\
    \ newList += x\n            if (y % 4 == 0) newList += y\n        })\n\n     \
    \   val newList = newList.toList\n        newList.foldLeft(0)((a, b) => a + b)",
  "        val sumOfSquares = lst.map { entry =>\n            entry match {\n    \
    \            case x if (x % 3) == 0 =>  x * x\n                case x if (x %\
    \ 4) == 0 => x * x * x\n                case _ => entry\n            }\n     \
    \   }.sum\n        \n        sumOfSquares", "        val sum : Long = 0\n    \
    \    for (i <- lst.indices) {\n            if (i % 3 == 0 & i % 4 == 0) {\n  \
    \              sum += lst(i)\n            } else {\n                lst(i) *=\
    \ lst(i)\n            }\n        }\n        return sum", "        // Write your\
    \ code here.\n        if (lst.isEmpty) return 0\n        var sum = 0\n       \
    \ for (i <- 0 until lst.size) {\n            if (i % 3 == 0 && i % 4 == 0) sum\
    \ += lst(i)\n            else if (i % 3 == 0) sum += lst(i)\n            else\
    \ if (i % 4 == 0) sum *= lst(i)\n            else sum *= lst(i)\n        }\n \
    \       sum", "        lst.foldLeft(0l) { (sum, el) =>\n            if (el %%\
    \ 3 == 0 || el %% 4 == 0) sum + (el * el)\n            else sum\n        }", " \
    \       var result = 0.0\n        for (i <- lst.indices) {\n            result\
    \ += lst(i)\n        }\n        return result", "        var sum = 0L\n      \
    \  val mut = mutable.ListBuffer(lst)\n        mut.map(x => sum += x match {\n\
    \            case 0 => x\n            case x if (x % 3 == 0) => x * x\n      \
    \      case x if (x % 4 == 0) => x * x * x\n            case x => x\n        }).foreach\
    \ { x => println(x) }\n        sum", "        val newList = lst filter { x =>\
    \ x % 3 == 0 || x % 4 == 0 } map {\n            x => x * x\n        }\n      \
    \  val sum = newList.sum\n        sum"]
stop_tokens:
- "\n    }\n"
