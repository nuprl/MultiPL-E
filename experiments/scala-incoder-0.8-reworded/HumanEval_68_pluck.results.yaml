language: scala
name: HumanEval_68_pluck
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) List()\
    \ \n        else {\n            var min = arr.head\n            var index = arr.indexOf(min)\n\
    \            var minIndex = 0\n            while (min % 2 == 0 && index != -1)\
    \ {\n                min += 1\n                index = arr.indexOf(min, index)\n\
    \                minIndex += 1\n            }\n            return arr.drop(index).toList\
    \ ++ List(min)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnexd56of.scala:44)\n\tat Problem.main(tmpnexd56of.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n      val m = arr.toMap\n \
    \     val ev = m.filter {\n        case (v,k) => v % 2 == 0\n      }\n      val\
    \ min = ev.minBy { case (_,v) => v }.key\n      ev.filter { case (_,v) => v ==\
    \ min }.keys.toList\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpq2ezw51v.scala:30:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m      \e[33mval\e[0m \e[36mm\e[0m = arr.toMap\n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     Cannot prove that Long <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m    \
    \                   where:    K is a type variable\n\e[31m   |\e[0m          \
    \                       V is a type variable\n\e[31m   |\e[0m                \
    \       .\n1 error found\n"
  stdout: ''
  timestamp: 1660010062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if(arr.isEmpty) List();\n\
    \        else {\n            val evens : (Long, Long) = (arr.filter(_%2==0).toList.min,\
    \ arr.minIndex)\n            arr.takeWhile(_%2==0).filter(_%2==0).takeWhile(_\
    \ < evens._1).take(evens._1 - arr.minIndex).sortWith(_ < evens._1).take(1).map(_\
    \ + evens._1)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmzryrcl6.scala:32:75 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mevens\e[0m : (\e[35mLong\e\
    [0m, \e[35mLong\e[0m) = (arr.filter(_%\e[31m2\e[0m==\e[31m0\e[0m).toList.min,\
    \ arr.minIndex)\n\e[31m\e[31m   |\e[0m                                       \
    \                                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                  value minIndex is not a member of List[Long]\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpmzryrcl6.scala:33:93 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            arr.takeWhile(_%\e[31m2\e[0m==\e[31m0\e[0m).filter(_%\e\
    [31m2\e[0m==\e[31m0\e[0m).takeWhile(_ < evens._1).take(evens._1 - arr.minIndex).sortWith(_\
    \ < evens._1).take(\e[31m1\e[0m).map(_ + evens._1)\n\e[31m\e[31m   |\e[0m    \
    \                                                                            \
    \         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            value\
    \ minIndex is not a member of List[Long]\n\e[31m\e[31m-- [E086] Syntax Error:\
    \ /tmp/tmpmzryrcl6.scala:33:112 --------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m            arr.takeWhile(_%\e[31m2\e[0m==\e[31m0\e[0m).filter(_%\e[31m2\e\
    [0m==\e[31m0\e[0m).takeWhile(_ < evens._1).take(evens._1 - arr.minIndex).sortWith(_\
    \ < evens._1).take(\e[31m1\e[0m).map(_ + evens._1)\n\e[31m\e[31m   |\e[0m    \
    \                                                                            \
    \                                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                       Wrong number of parameters, expected: 2\n3 errors found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var res = mutable.ArrayBuffer[Long]()\n\
    \        var index = 0\n        var minIndex = 0\n        var smallestValue =\
    \ 0\n\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 ==\
    \ 0) {\n                if (smallestValue == 0) {\n                    smallestValue\
    \ = arr(i)\n                    minIndex = i\n                }\n            }\
    \ else if (smallestValue != 0) {\n                if (smallestValue > arr(i))\
    \ {\n                    minIndex = index\n                    smallestValue =\
    \ arr(i)\n                }\n            }\n            index += 1\n        }\n\
    \n        if (smallestValue == 0) {\n            return arr\n        }\n\n   \
    \     res += smallestValue\n        res += minIndex\n        return res.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3nyn8qjb.scala:30:18 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mvar\e[0m \e[36mres\e[0m = mutable.ArrayBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp3nyn8qjb.scala:38:39 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                    smallestValue = arr(i)\n\e[31m\e\
    [31m   |\e[0m                                    ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                    Found:    Long\n\e[31m   |\e[0m         \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp3nyn8qjb.scala:44:39 --------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m                    smallestValue = arr(i)\n\e[31m\e[31m \
    \  |\e[0m                                    ^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                Found:    Long\n\e[31m   |\e[0m             \
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val map = mutable.Map.empty[Long,\
    \ Long]\n        for (i <- 0 until arr.length) {\n            val currentValue\
    \ = arr(i)\n            val currentIndex = i\n            if (map.contains(currentValue))\
    \ {\n                val prevIndex = map(currentValue)\n                if (prevIndex\
    \ < currentIndex) {\n                    map.put(currentValue, currentIndex)\n\
    \                }\n            }\n            else {\n                map.put(currentValue,\
    \ currentIndex)\n            }\n        }\n        val keys = map.keys\n     \
    \   if (keys.length == 0) {\n            return []\n        }\n        if (keys.length\
    \ == 1) {\n            return (keys.head, map.getOrElse(keys.head))\n        }\n\
    \        val minValue = keys.min\n        val minIndex = 0\n        var minEvenIndex\
    \ = false\n        val currentKey = minValue\n        for (i <- 0 until keys.length)\
    \ {\n            if (key(i) == currentKey) {\n                if (i % 2 == 0)\
    \ {\n                    if (minEvenIndex == false) {\n                      \
    \  minEvenIndex = i\n                    }\n                    minEvenIndex =\
    \ true\n                }\n                else {\n                    if (minEvenIndex\
    \ == true && minEvenIndex < i) {\n                        minEvenIndex = i\n \
    \                   }\n                }\n            }\n            else {\n\
    \                if (minEvenIndex == true && minEvenIndex < i) {\n           \
    \         minEvenIndex = i\n                }\n            }\n        }\n    \
    \    (keys.find(_ == minValue).getOrElse(List[Long]()), map(minValue), minEvenIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2e927iwd.scala:46:20 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m            \e[33mreturn\e[0m []\n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    an identifier\
    \ expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2e927iwd.scala:47:8\
    \ ----------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        }\n\e[31m\e[31m\
    \   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        '=>' expected, but '}' found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2e927iwd.scala:30:18 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = mutable.Map.empty[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2e927iwd.scala:49:19 --------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m            \e[33mreturn\e[0m (keys.head, map.getOrElse(keys.head))\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    (Nothing, Nothing)\n\e[31m  \
    \ |\e[0m                   Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp2e927iwd.scala:56:16 ------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m            \e[33mif\e[0m (key(i) == currentKey) {\n\e\
    [31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m                Not\
    \ found: key\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2e927iwd.scala:59:39\
    \ --------------------\e[0m\e[0m\n\e[31m59 |\e[0m                        minEvenIndex\
    \ = i\n\e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e\
    [31m   |\e[0m                                       Found:    (i : Int)\n\e[31m\
    \   |\e[0m                                       Required: Boolean\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation avail"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n      if (arr.isEmpty)\n  \
    \      List[]\n      else if (arr.size < 2)\n        List(arr(0))\n      else\
    \ {\n        val (smallest, idx) = arr.minBy(_.toLong) % arr.size\n        val\
    \ rem = arr.take(idx)\n        val rem = rem.sortBy(_.toLong).take(2).map { case\
    \ (x, _) => x }\n        rem match {\n          case Nil => Nil\n          case\
    \ x :: xs => List(smallest, idx) :: pluck(xs)\n        }\n      }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwx71ykx3.scala:31:13 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        List[]\n\e[31m\e[31m   |\e[0m             ^\e\
    [0m\n\e[31m   |\e[0m             an identifier expected, but ']' found\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpwx71ykx3.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mrem\e[0m = rem.sortBy(_.toLong).take(\e\
    [31m2\e[0m).map { \e[33mcase\e[0m (x, _) => x }\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mrem is already defined as \e[33mvalue\e[0m \e[35mrem\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwx71ykx3.scala:36:27 --------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \        \e[33mval\e[0m \e[36mrem\e[0m = arr.take(idx)\n\e[31m\e[31m   |\e[0m\
    \                           ^^^\e[0m\n\e[31m   |\e[0m                        \
    \   Found:    (idx : Any)\n\e[31m   |\e[0m                           Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwx71ykx3.scala:40:30\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m          \e[33mcase\e[0m x ::\
    \ xs => List(smallest, idx) :: pluck(xs)\n\e[31m\e[31m   |\e[0m              \
    \            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \   Found:    List[Any]\n\e[31m   |\e[0m                          Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val res = new mutable.LinkedList[Long]()\n\
    \        val m = arr.size\n        var min = arr(0)\n        var index = -1\n\
    \        for(i <- 0 until m) {\n            if(arr(i).toLong % 2 == 0){\n    \
    \            if(arr(i) > min){\n                    min = arr(i)\n           \
    \         index = i\n                }\n            }\n        }\n        if(index\
    \ < 0){\n            res ++= arr\n        }else{\n            res += min\n   \
    \         res += index\n        }\n        res.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqqm79dr5.scala:30:22 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = \e[33mnew\e[0m\
    \ mutable.LinkedList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m               \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val s = arr.groupBy(x\
    \ => (x % 2).toInt).mapValues(x => x.min.toLong)\n        s.map(x => arr(x._1))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjp7u1ffj.scala:31:13\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        s.map(\e[36mx\e[0m =>\
    \ arr(x._1))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    scala.collection.View[Long]\n\e[31m   |\e[0m     \
    \   Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010064
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var smalest_value :\
    \ Long = -1\n        var smalest_index : Int = -1\n        var index = 0\n   \
    \     arr.zipWithIndex.foreach { case (item, index) =>\n            if (item >\
    \ 0 && item % 2 == 0) {\n                if (smalest_value < 0 || smalest_value\
    \ < item) {\n                    smalest_value = item\n                    smalest_index\
    \ = index\n                }\n            }\n        }\n        arr.zipWithIndex.foreach\
    \ { case (item, index) =>\n            if (item > 0 && item % 2 == 0) {\n    \
    \            if (smalest_value < 0 || smalest_value < item) {\n              \
    \      smalest_value = item\n                    smalest_index = index\n     \
    \           }\n            }\n        }\n        if (smalest_value == -1 || arr.isEmpty)\
    \ {\n            return Nil\n        } else {\n            val smalest_node :\
    \ Long = arr[smalest_index]\n            arr.zipWithIndex.foreach { case (item,\
    \ index) =>\n                if (item > 0 && item % 2 == 0) {\n              \
    \      if (smalest_value < 0 || smalest_value < item) {\n                    \
    \    smalest_value = item\n                        smalest_index = index\n   \
    \                 }\n                }\n            }\n            val smalest_node_in_list\
    \ : Long = arr[smalest_index]\n            val smalest_node_in_list_index : Int\
    \ = arr.lastIndexWhere(item => item == smalest_node_in_list)\n            val\
    \ smalest_node_in_list_value : Long = arr[smalest_node_in_list_index]\n      \
    \      return List(smalest_value, smalest_index, smalest_node_in_list_index, smalest_node_in_list_value)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmg0z48oo.scala:52:42 ------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m            \e[33mval\e[0m \e[36msmalest_node\e[0m :\
    \ \e[35mLong\e[0m = arr[\e[35msmalest_index\e[0m]\n\e[31m\e[31m   |\e[0m     \
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                      Not found: type smalest_index\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmg0z48oo.scala:61:50 ------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m            \e[33mval\e[0m \e[36msmalest_node_in_list\e\
    [0m : \e[35mLong\e[0m = arr[\e[35msmalest_index\e[0m]\n\e[31m\e[31m   |\e[0m \
    \                                                 ^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                           Not found: type smalest_index\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmg0z48oo.scala:63:56\
    \ ------------------------\e[0m\e[0m\n\e[31m63 |\e[0m            \e[33mval\e[0m\
    \ \e[36msmalest_node_in_list_value\e[0m : \e[35mLong\e[0m = arr[\e[35msmalest_node_in_list_index\e\
    [0m]\n\e[31m\e[31m   |\e[0m                                                  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \        Not found: type smalest_node_in_list_index\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val arr1 = arr.map(_.toLong)\n\
    \        val res = arr1.groupBy(x => x % 2)\n        val smallestEvenValue = res.minBy(x\
    \ => x._1)._1\n        val indexes = res.filter(x => x._1 == smallestEvenValue).map(x\
    \ => x._2)\n        val minValue = res.minBy(x => x._1)._2\n        val arr2 =\
    \ arr1.filter(x => x != minValue)\n        if (arr2.isEmpty) {\n            Nil\n\
    \        }\n        else {\n            (smallestEvenValue, indexes)\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp4nv_9jqa.scala:35:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36marr2\e[0m = arr1.filter(\e\
    [36mx\e[0m => x != minValue)\n\e[31m\e[31m   |\e[0m                          \
    \          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types Long and List[Long]\
    \ cannot be compared with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp4nv_9jqa.scala:40:12 --------------------\e[0m\e[0m\n\e[31m40 |\e[0m\
    \            (smallestEvenValue, indexes)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m       Found:    (Long, scala.collection.immutable.Iterable[List[Long]])\n\
    \e[31m   |\e[0m       Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if(arr.isEmpty) {\n\
    \            return List.empty\n        }\n        var smallest = 0\n        var\
    \ smallestIndex = 0\n        for(i <- 0 until arr.length) {\n            if((arr(i)\
    \ % 2) != 0) {\n                if(smallest != arr(i)) {\n                   \
    \ smallest = arr(i)\n                    smallestIndex = i\n                }\n\
    \            }\n        }\n        smallestIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphajqas6j.scala:38:34\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m                    smallest\
    \ = arr(i)\n\e[31m\e[31m   |\e[0m                               ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                               Found:    Long\n\e[31m   |\e[0m  \
    \                             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmphajqas6j.scala:43:8 ---------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        smallestIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (smallestIndex : Int)\n\e[31m   |\e[0m \
    \       Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val m = arr.map(_ %\
    \ 2).toSet\n        val l = arr.size\n        if(l == 0) List() else arr.zip(m).foldLeft((0,List())){\n\
    \            case ((s, m), i) => if(m) (i.toLong, m) else (s, i+1)\n        }._2.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz2nf14l2.scala:33:35\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mcase\e[0m ((s,\
    \ m), i) => \e[33mif\e[0m(m) (i.toLong, m) \e[33melse\e[0m (s, i+\e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m\
    \                                   Found:    (m : List[Nothing])\n\e[31m   |\e\
    [0m                                   Required: Boolean\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpz2nf14l2.scala:33:41 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mcase\e[0m ((s, m), i) => \e[33mif\e\
    [0m(m) (i.toLong, m) \e[33melse\e[0m (s, i+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong\
    \ is not a member of (Long, Long), but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz2nf14l2.scala:33:62\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mcase\e\
    [0m ((s, m), i) => \e[33mif\e[0m(m) (i.toLong, m) \e[33melse\e[0m (s, i+\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                                  \
    \           ^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of (Long, Long), but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val nums = arr.map{v\
    \ =>\n            if(v%2 == 0) v else -1\n        }.toList\n        val min_odd\
    \ = nums.min\n        if(min_odd < 0)\n            return List[]\n        if(nums.contains(min_odd))\n\
    \            return List(min_odd, nums.index(min_odd))\n        val indexes =\
    \ nums.zip(nums.drop(1)).filter(x => x._1 % 2 == 0).map{x =>\n            if(x._2\
    \ > min_odd) x._2 else -1\n        }\n        return List(min_odd, indexes.find(x\
    \ => x >= 0)).getOrElse(List())\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjngpj8jh.scala:35:24 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mreturn\e[0m List[]\n\e[31m\e[31m  \
    \ |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                      \
    \  an identifier expected, but ']' found\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpjngpj8jh.scala:37:38 ------------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m            \e[33mreturn\e[0m List(min_odd, nums.index(min_odd))\n\e[31m\e\
    [31m   |\e[0m                                 ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \  value index is not a member of List[Long] - did you mean nums.indexOf?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpjngpj8jh.scala:41:56 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mreturn\e[0m List(min_odd, indexes.find(\e\
    [36mx\e[0m => x >= \e[31m0\e[0m)).getOrElse(List())\n\e[31m\e[31m   |\e[0m   \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m               value getOrElse is not a member of List[Matchable]\n3\
    \ errors found\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val result = mutable.ListBuffer.empty[Long]\n\
    \        arr.foreach{node =>\n            arr.foreach{ currNode =>\n         \
    \       if (node % 2 == 0) {\n                    result.add((currNode, currNode\
    \ % 2))\n                }\n            }\n        }\n        if (result.isEmpty)\
    \ {\n            arr.toList\n        } else {\n            val sortedList = new\
    \ Array[Long](result.size)\n            result.toArray.foreach(x => sortedList(x._1)\
    \ = x._2)\n            sortedList\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5m029th9.scala:30:21 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp5m029th9.scala:43:12 --------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            sortedList\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (sortedList : Array[Long])\n\
    \e[31m   |\e[0m            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010063
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val ans = arr.foldLeft[List[Long]](Nil)((list,e)\
    \ => {\n          val index = list.indexOf(e)\n          index match {\n     \
    \       case -1 => list :+ e\n            case _ =>\n              val minIndex\
    \ = (list.indexOf((e % 2 ==0)) * 2 + 1) max 0\n              list :+ ((e % 2 ==\
    \ 0) ? e : list.take(minIndex).max)\n          }\n        })\n        ans.filter(x\
    \ => x % 2 == 0).map(x => x / 2)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp41f4bkra.scala:36:51 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m              list :+ ((e % \e[31m2\e[0m == \e[31m0\e\
    [0m) ? e : list.take(minIndex).max)\n\e[31m\e[31m   |\e[0m                   \
    \                                ^\e[0m\n\e[31m   |\e[0m                     \
    \                        ')' expected, but '(' found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp41f4bkra.scala:36:36 ------------------------\e[0m\e[0m\n\
    \e[31m36 |\e[0m              list :+ ((e % \e[31m2\e[0m == \e[31m0\e[0m) ? e :\
    \ list.take(minIndex).max)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       value ? is not a member of Boolean\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010063
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var smallest_value\
    \ : Long = arr(0)\n        var smallest_index : Int = 0\n        var index : Int\
    \ = 0\n        var i = 0\n        var j = 0\n        var temp_array : List[Long]\
    \ = arr\n        while (i < temp_array.length) {\n            var val : Long =\
    \ temp_array(i)\n            if(i+1 < temp_array.length) {\n                val\
    \ next_val : Long = temp_array(i+1)\n                if((val % 2) == 0) {\n  \
    \                  smallest_value = val if (smallest_value < val) else smallest_value\n\
    \                    smallest_index = i+1 if (smallest_value < val) else smallest_index\n\
    \                    val temp = j\n                    for (j <- i+1 until temp_array.length)\
    \ {\n                        temp_array(i) = temp_array(j)\n                 \
    \       temp_array(j) = smallest_value\n                        val temp_val :\
    \ Long = temp_array(j)\n                        if (temp_val < smallest_value)\
    \ {\n                            smallest_value = temp_val\n                 \
    \           smallest_index = temp\n                        }\n               \
    \     }\n                }\n                i+=2;\n            }\n           \
    \ else {\n                smallest_value = val if (smallest_value < val) else\
    \ smallest_value\n                smallest_index = i+1 if (smallest_value < val)\
    \ else smallest_index\n                val temp = j\n                for (j <-\
    \ i+1 until temp_array.length) {\n                    temp_array(i) = temp_array(j)\n\
    \                    temp_array(j) = smallest_value\n                    val temp_val\
    \ : Long = temp_array(j)\n                    if (temp_val < smallest_value) {\n\
    \                        smallest_value = temp_val\n                        smallest_index\
    \ = temp\n                    }\n                }\n            }\n          \
    \  i += 1\n        }\n        val result: List[Long] = temp_array\n        smallest_value\
    \ = temp_array(0)\n        smallest_index = temp_array.indexOf(0)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp18snadi6.scala:37:16 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mvar\e[0m \e[33mval\e[0m : Long = temp_array(i)\n\
    \e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m               \
    \ pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp18snadi6.scala:40:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                \e[33mif\e\
    [0m((\e[33mval\e[0m % \e[31m2\e[0m) == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                    ^^^\e[0m\n\e[31m   |\e[0m                    expression expected\
    \ but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp18snadi6.scala:41:37 ---------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m                    smallest_value = \e[33mval\e[0m \e[33mif\e[0m (smallest_value\
    \ < \e[33mval\e[0m) \e[33melse\e[0m smallest_value\n\e[31m\e[31m   |\e[0m    \
    \                                 ^^^\e[0m\n\e[31m   |\e[0m                  \
    \                   expression expected but \e[31mval\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmp18snadi6.scala:42:41 -----------------------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                    smallest_index = i+\e[31m1\e[0m \e\
    [33mif\e[0m (smallest_value < \e[33mval\e[0m) \e[33melse\e[0m smallest_index\n\
    \e[31m\e[31m   |\e[0m                                         ^^\e[0m\n\e[31m\
    \   |\e[0m                                end of statement expected but 'if' found\n\
    \e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp18snadi6.scala:57:33 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m                smallest_value = \e[33mval\e[0m \e[33mif\e\
    [0m (smallest_value < \e[33mval\e[0m) \e[33melse\e[0m smallest_value\n\e[31m\e\
    [31m   |\e[0m                                 ^^^\e[0m\n\e[31m   |\e[0m      \
    \                           expression expected but \e[31mval\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available wh"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        require(arr.nonEmpty,\
    \ \"arr is empty\")\n        val newArr: List[Long] = new mutable.LinkedList[Long]()\n\
    \        var index : Int = 0\n        var sum : Long = 0\n        for(i <- 0 until\
    \ arr.length){\n            sum += arr(i)\n            if (sum % 2 == 0 && sum\
    \ > 0) {\n                newArr += arr(i)\n                index += 1\n     \
    \       }\n        }\n        if (newArr.isEmpty) {\n            return []\n \
    \       } else {\n            require(index > 0, \"index is zero\")\n        \
    \    require(index == newArr(0), \"index is zero\")\n            return newArr\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu_14khie.scala:42:20 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mreturn\e[0m []\n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    an identifier\
    \ expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu_14khie.scala:43:8\
    \ ----------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        } \e[33melse\e\
    [0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        '=>' expected,\
    \ but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu_14khie.scala:31:37\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mnewArr\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m mutable.LinkedList[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu_14khie.scala:37:23\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                newArr +=\
    \ arr(i)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        value += is not a member of List[Long] - did you mean newArr.!=?\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010063
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val res = new mutable.ListBuffer[Long]()\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i).isEven) {\n \
    \               res += arr(i)\n                arr.updated(i, arr.delete(i))\n\
    \            }\n        }\n        res.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw528vvu7.scala:30:22 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m               \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw528vvu7.scala:32:23\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mif\e[0m\
    \ (arr(i).isEven) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                value isEven is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpw528vvu7.scala:34:35 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                arr.updated(i, arr.delete(i))\n\e[31m\e\
    [31m   |\e[0m                               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                             value delete is not a member of List[Long]\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val minEven = arr.min(_%2\
    \ == 0).getOrElse(0)\n        val index = arr.indexOf(minEven)\n        val value\
    \ = arr(index)\n        arr.take(index) ++ List(value -> index).filter(identity).map\
    \ {\n            x => (x.get._1, x.get._2)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpkwv7xnpn.scala:30:30 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mminEven\e[0m = arr.min(_%\e\
    [31m2\e[0m == \e[31m0\e[0m).getOrElse(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \           Wrong number of parameters, expected: 2\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpkwv7xnpn.scala:33:55 --------------------\e[0m\e[0m\n\
    \e[31m33 |\e[0m        arr.take(index) ++ List(value -> index).filter(identity).map\
    \ {\n\e[31m\e[31m   |\e[0m                                                   \
    \    ^\e[0m\n\e[31m   |\e[0m                                             Found:\
    \    (x : (Long, Int))\n\e[31m   |\e[0m                                      \
    \       Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpkwv7xnpn.scala:34:20 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m            \e[36mx\e[0m => (x.get._1, x.get._2)\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^\e[0m\n\e[31m   |\e[0m                  value get is not\
    \ a member of (Long, Int)\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkwv7xnpn.scala:34:30\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[36mx\e[0m\
    \ => (x.get._1, x.get._2)\n\e[31m\e[31m   |\e[0m                            ^^^^^\e\
    [0m\n\e[31m   |\e[0m                            value get is not a member of (Long,\
    \ Int)\n4 errors found\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        def checkEven(x : Long)\
    \ : Boolean = {\n            x % 2 == 0\n        }\n        val evens = arr.filter(checkEven)\n\
    \        var result = (0 until arr.size).foldLeft((arr.size, arr.head.asInstanceOf[Long]))\
    \ { case ((size, i), x) => (x, i) }\n        result match {\n            case\
    \ (_, 0) => List()\n            case (_, 0) => List()\n            case (size,\
    \ x) => {\n                if (evens.exists(checkEven)) {\n                  \
    \  evens.foldLeft((size, x)) { case ((size, i), x) => {\n                    \
    \    if (i % 2 == 0) {\n                            (i, x)\n                 \
    \       } else {\n                            (size, x)\n                    \
    \    }\n                    }}\n                } else if (size == arr.size) {\n\
    \                    (size, x)\n                } else {\n                   \
    \ List()\n                }\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn2xws9we.scala:42:29\
    \ --------------------\e[0m\e[0m\n\e[31m42 |\e[0m                            (i,\
    \ x)\n\e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m\
    \                             Found:    (i : Long)\n\e[31m   |\e[0m          \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpn2xws9we.scala:48:20 --------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m                    (size, x)\n\e[31m\e[31m   |\e[0m                 \
    \   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Found:    (Int, Long)\n\
    \e[31m   |\e[0m                    Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var minValue : Long\
    \ = arr(0).toLong;\n        var minIndex : Int = -1;\n        var index : Int\
    \ = -1;\n        var smallestEven : Long = arr(0).toLong\n        var minIndex\
    \ : int = -1;\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2l == smallestEven) {\n                if (minIndex == -1) {\n           \
    \         minIndex = i\n                }\n                if (arr(i) < minValue)\
    \ {\n                    minValue = arr(i)\n                    minIndex = i\n\
    \                }\n            }\n        }\n        if (minIndex == -1) {\n\
    \            List[Long]()\n        } else {\n            List(minValue, minIndex)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmyafbf0_.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mvar\e[0m \e[36mminIndex\e[0m : \e[35mint\e\
    [0m = -\e[31m1\e[0m;\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mminIndex is already defined as \e[33mvariable\e[0m \e[35mminIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1660010056
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val sorted_arr = arr.sorted\n\
    \        val smalest_value = sorted_arr(0)\n        val smallest_index = arr.indexOf(\
    \ smalest_value)\n        if(smallest_index == -1) List()\n        else List(\
    \ smalest_value, smallest_index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp086xv038.scala:38)\n\tat Problem.main(tmp086xv038.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var result: List[Long]\
    \ = Nil\n        var maxV = 0\n        var nodeMaxV = 0\n        var maxI = 0\n\
    \        var nodeMaxI = 0\n        for (i <- 0 until arr.length){\n          \
    \  val v = arr(i)\n            if (v > maxV){ maxV = v; maxI = i}\n          \
    \  if (v >= nodeMaxV){\n                if (v > nodeMaxV){nodeMaxV = v; nodeMaxI\
    \ = i}\n            }\n        }\n        result = (nodeMaxI until arr.length)\n\
    \        result.map((x) => if (x == maxI) maxV else x).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2yd284po.scala:37:34\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mif\e[0m (v\
    \ > maxV){ maxV = v; maxI = i}\n\e[31m\e[31m   |\e[0m                        \
    \          ^\e[0m\n\e[31m   |\e[0m                                  Found:   \
    \ (v : Long)\n\e[31m   |\e[0m                                  Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2yd284po.scala:39:45\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m                \e[33mif\e[0m\
    \ (v > nodeMaxV){nodeMaxV = v; nodeMaxI = i}\n\e[31m\e[31m   |\e[0m          \
    \                                   ^\e[0m\n\e[31m   |\e[0m                  \
    \                           Found:    (v : Long)\n\e[31m   |\e[0m            \
    \                                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp2yd284po.scala:42:18 --------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        result = (nodeMaxI until arr.length)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                  Found:    Range\n\e[31m   |\e[0m                  Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2yd284po.scala:43:54\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m        result.map((\e[36mx\e\
    [0m) => \e[33mif\e[0m (x == maxI) maxV \e[33melse\e[0m x).toList\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m \
    \       Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        def checkNodes(nodes\
    \ : List[Long], index : List[Long]) : List[Long] = {\n            val smalest_value\
    \ = if (nodes.size > 0) nodes.head else 0\n            val smalest_index = if\
    \ (nodes.size > 0) index else 0\n            if (smalest_value == 0l) {\n    \
    \            List[Long]()\n            } else if (smalest_value % 2 == 0) {\n\
    \                checkNodes(nodes.tail, smalest_index::smalest_value)\n      \
    \      } else {\n                checkNodes(nodes.tail, smalest_index)\n     \
    \       }\n        }\n        checkNodes(arr, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaudr6pkr.scala:36:52 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                checkNodes(nodes.tail, smalest_index::smalest_value)\n\
    \e[31m\e[31m   |\e[0m                                                    ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        value :: is not a\
    \ member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaudr6pkr.scala:38:39\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m                checkNodes(nodes.tail,\
    \ smalest_index)\n\e[31m\e[31m   |\e[0m                                      \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                   Found:\
    \    (smalest_index : Matchable)\n\e[31m   |\e[0m                            \
    \       Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpaudr6pkr.scala:41:24 --------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m        checkNodes(arr, \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \               ^\e[0m\n\e[31m   |\e[0m                        Found:    (\e[31m0\e\
    [0m : Int)\n\e[31m   |\e[0m                        Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010080
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) List(-1).toList\n\
    \        var smallest_value = arr(0l)\n        var smallest_index = -1\n     \
    \   var smallest_index = 0\n        var even_value = 0l\n        var i = 0\n \
    \       for (i <- arr.indices) {\n            if (arr(i).toLong % 2 == 0) {\n\
    \                even_value = arr(i)\n            }\n            if (arr(i) <\
    \ smallest_value) {\n                smallest_value = arr(i)\n               \
    \ smallest_index = i\n            } else if (arr(i) < smallest_value && arr(i).toLong\
    \ % 2 == 0) {\n                smallest_index = i\n            }\n        }\n\
    \        if (smallest_index == -1) {\n            smallest_index = -1\n      \
    \  }\n        even_value = even_value.toLong\n        List(smallest_value, smallest_index).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpursbfut6.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e[0m \e[36msmallest_index\e[0m = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0msmallest_index is already defined as \e[33mvariable\e[0m \e[35msmallest_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpursbfut6.scala:31:33 --------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m        \e[33mvar\e[0m \e[36msmallest_value\e[0m = arr(\e[31m0l\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                 ^^\e[0m\n\e[31m  \
    \ |\e[0m                                 Found:    (\e[31m0L\e[0m : Long)\n\e\
    [31m   |\e[0m                                 Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpursbfut6.scala:51:45 --------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        List(smallest_value, smallest_index).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m\
    \        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010081
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val result: List[Long]\
    \ = new mutable.ListBuffer[Long]()\n        arr.foreach{\n          x =>\n   \
    \       if(x % 2 == 0 && x != 0){\n            result += x\n          }\n    \
    \    }\n        arr.size\n        if(result.isEmpty){\n          result.add(0)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdvnv0agp.scala:30:37 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                                     ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                     Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdvnv0agp.scala:34:19 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            result += x\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not a member of List[Long]\
    \ - did you mean result.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdvnv0agp.scala:39:17\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m          result.add(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue add\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660010082
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) {\n\
    \            return List()\n        }\n        val m = 0l\n        val result\
    \ = new Array[Long](arr.length)\n        var i = 0\n        while (i < arr.length)\
    \ {\n            if (arr(i).mod(2) == 0) {\n                m = arr(i)\n     \
    \           break\n            }\n            i += 1\n        }\n        var j\
    \ = 0\n        while (j < arr.length) {\n            if (arr(j).mod(2) == 0) {\n\
    \                if (m == arr(j)) {\n                    result(i) = arr(j)\n\
    \                } else {\n                    val temp = m\n                \
    \    m = arr(j)\n                    result(i) = temp\n                }\n   \
    \             break\n            }\n            j += 1\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6m2_h9nj.scala:37:23 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mif\e[0m (arr(i).mod(\e[31m2\e[0m) ==\
    \ \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue mod is not a member of Long, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp6m2_h9nj.scala:38:18\
    \ -----------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                m =\
    \ arr(i)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Reassignment to val m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp6m2_h9nj.scala:39:16 ------------------------\e[0m\e\
    [0m\n\e[31m39 |\e[0m                break\n\e[31m\e[31m   |\e[0m             \
    \   ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6m2_h9nj.scala:45:23 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            \e[33mif\e[0m (arr(j).mod(\e[31m2\e[0m) ==\
    \ \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue mod is not a member of Long, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp6m2_h9nj.scala:50:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m50 |\e[0m                   \
    \ m = arr(j)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Reassignment to val m\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6m2_h9nj.scala:53:16 ------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m                "
  stdout: ''
  timestamp: 1660010088
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val arr = arr.toList.sorted\n\
    \        val even = arr.dropWhile(x => x % 2 == 0).toList\n        if (even.isEmpty)\
    \ arr.toList\n        else even.head\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_yuj9mch.scala:30:18 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList.sorted\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n      val sorted = arr.sorted\n\
    \      val even = sorted.filter(_ % 2 == 0)\n      val odd  = sorted.filter(_\
    \ % 2 != 0)\n      if (even.isEmpty) odd else even.headOption\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp3roc5ey.scala:33:38\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m      \e[33mif\e[0m (even.isEmpty)\
    \ odd \e[33melse\e[0m even.headOption\n\e[31m\e[31m   |\e[0m                 \
    \                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \          Found:    \e[1m\e[31mOption\e[0m[Long]\n\e[31m   |\e[0m           \
    \                      Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var evenNum = arr.head\n\
    \        var evenIndex = 0\n        var evenValue = 0\n        var smalest = 0\n\
    \        var smalest_value = 0\n        var smalest_index = 0\n        var i =\
    \ 0\n        var j = 0\n        \n        for(i <- arr.length) {\n           \
    \ if(arr(i) % 2 == 0) {\n                evenNum = arr(i)\n                evenIndex\
    \ = i\n                evenValue = arr(i).asInstanceOf[Long]\n               \
    \ for(j <- i + 1) {\n                    if(arr(j) % 2 == 0) {\n             \
    \           if(evenValue < arr(j).asInstanceOf[Long]) {\n                    \
    \        evenValue = arr(j).asInstanceOf[Long]\n                            evenIndex\
    \ = j\n                        }\n                    }\n                }\n \
    \               if(evenValue < smalest_value) {\n                    smalest_value\
    \ = evenValue\n                    smalest_index = evenIndex\n               \
    \     smalest = evenNum\n                }\n            }\n        }\n       \
    \ return smalest.asInstanceOf[List[Long]] :: smalest_index.asInstanceOf[List[Long]]\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjpqlew1g.scala:39:17 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mfor\e[0m(i <- arr.length) {\n\e[31m\e[31m\
    \   |\e[0m                 ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 value\
    \ foreach is not a member of Int\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjpqlew1g.scala:59:35\
    \ --------------------\e[0m\e[0m\n\e[31m59 |\e[0m        \e[33mreturn\e[0m smalest.asInstanceOf[\e\
    [35mList\e[0m[\e[35mLong\e[0m]] :: smalest_index.asInstanceOf[\e[35mList\e[0m[\e\
    [35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e\
    [0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m               Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010087
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val minIndex = arr.zipWithIndex.minBy(_._1)._1\n\
    \        val smalest = arr.filter(_._1 == minIndex)\n        if (smalest.length\
    \ == 0) arr.toList\n        else smalest.head._2.map(i => arr(i)).toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfb79rd94.scala:31:35 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest\e[0m = arr.filter(_._1\
    \ == minIndex)\n\e[31m\e[31m   |\e[0m                                 ^^^^\e[0m\n\
    \e[31m   |\e[0m                                 value _1 is not a member of Long\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfb79rd94.scala:33:26 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33melse\e[0m smalest.head._2.map(i => arr(i)).toList\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \       value _2 is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660010089
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        arr.foldLeft((Int.MinValue,\
    \ 0l)) { (a, v) => v match {\n            case 0 => (a._1, a._2)\n           \
    \ case i if (i < a._1) => (i, v)\n            case _ => (a._1, v)\n        }}._2\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpspigaeou.scala:32:37\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mcase\e[0m i\
    \ \e[33mif\e[0m (i < a._1) => (i, v)\n\e[31m\e[31m   |\e[0m                  \
    \                   ^\e[0m\n\e[31m   |\e[0m                                  \
    \   Found:    (i : Long)\n\e[31m   |\e[0m                                    \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010088
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var even = 0\n    \
    \    var idx = 0\n        arr.sortWith(_ < _)\n        arr.zipWithIndex.foreach\
    \ { case (value, index) =>\n            if (value % 2 == 0) {\n              \
    \  even = value\n                idx = index\n            }\n        }\n     \
    \   if (even != 0)\n            arr.take(idx).reverse\n        else\n        \
    \    arr.toList\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3x56xaes.scala:35:23\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m                even = value\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                 Found:    (value : Long)\n\e[31m   |\e[0m                  \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010088
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val n = arr.length\n\
    \        val result = new Array[Long](n)\n        for(i <- 0 until n) {\n    \
    \        val k = arr(i)\n            val index = if (k % 2 == 0) (n - i - 1) else\
    \ i\n            if (k % 2 == 0 && index < result(0)) result(0) = k\n        \
    \    else if (k % 2 == 0 && index > result(0)) result(index) = k\n        }\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1vtbyi1z.scala:38:8\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010088
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        require(arr.length\
    \ == 100)\n        var result = new mutable.ArrayBuffer[Long]()\n        var index\
    \ = 0\n        var smallestEven = arr.head\n        var smallestIndex = 0\n  \
    \      var index = 0\n        while (smallestEven.isDefined && (index < arr.length))\
    \ {\n            if (arr(index) %% 2 == 0) {\n                if (smallestEven.get()\
    \ <= arr(index)) {\n                    smallestEven.set(arr(index))\n       \
    \             smallestIndex = 0\n                } else {\n                  \
    \  if (smallestIndex < index) {\n                        smallestIndex = index\n\
    \                    }\n                }\n            }\n            index +=\
    \ 1\n        }\n        val tempIndex = smallestIndex\n        val tempEven =\
    \ smallestEven.get\n        smallestEven.set(arr(tempIndex))\n        smallestIndex\
    \ += 1\n        if (tempEven != 0) {\n            result += (tempEven.toLong,\
    \ tempIndex.toLong)\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprrz12i8w.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mvar\e[0m \e[36mindex\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mindex is already\
    \ defined as \e[33mvariable\e[0m \e[35mindex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprrz12i8w.scala:31:25\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmprrz12i8w.scala:36:28 ------------------------\e[0m\e[0m\n\e[31m36 |\e\
    [0m        \e[33mwhile\e[0m (smallestEven.isDefined && (index < arr.length)) {\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m               value isDefined is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmprrz12i8w.scala:37:27 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m            \e[33mif\e[0m (arr(index) %% \e[31m2\e[0m == \e\
    [31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value %% is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmprrz12i8w.scala:38:33 ------------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m                \e[33mif\e[0m (smallestEven.get() <= arr(index))\
    \ {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    value get is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmprrz12i8w.scala:39:33 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    smallestEven.set(arr(index))\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    value set is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmprrz12i8w"
  stdout: ''
  timestamp: 1660010091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var smallest_even :\
    \ Long = -1\n        var smallest_even : Long = -1\n        var smallest_index\
    \ : Long = -1\n        var index = 0\n        var even_index = 0\n        var\
    \ new_arr = new ArrayBuffer[Long]()\n        for(i <- 0 until arr.length) {\n\
    \            if(arr(i) % 2 == 0) {\n                even_index += 1\n        \
    \        if(even_index == smallest_even) {\n                    smallest_even\
    \ = even_index\n                    smallest_index = index\n                }\n\
    \            }\n            else {\n                index += 1\n             \
    \   new_arr += arr(i)\n            }\n        }\n        if(smallest_even != -1)\
    \ {\n            return new_arr ++ List(smallest_even, smallest_index)\n     \
    \   }\n        return List()\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdkx3p0o4.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m \e[36msmallest_even\e[0m : \e\
    [35mLong\e[0m = -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallest_even is already defined as \e[33mvariable\e[0m \e\
    [35msmallest_even\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpdkx3p0o4.scala:50:19 --------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m            \e[33mreturn\e[0m new_arr ++ List(smallest_even,\
    \ smallest_index)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    scala.collection.mutable.ArrayBuffer[Long]\n\
    \e[31m   |\e[0m                   Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010089
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n      val n = arr.size\n  \
    \    if (n == 0) List()\n      else if (n % 2 == 1) arr.minBy(_.toInt) match {\n\
    \        case Some(x) => List(x.toLong, arr.indexOf(x))\n        case None =>\
    \ List()\n      }\n      else arr.minBy(_.toInt) match {\n        case Some(x)\
    \ => List(x.toLong, arr.indexOf(x))\n        case None => pluck(arr.drop(arr.indexOf(0).toInt))\n\
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcp8fz69g.scala:33:31 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mcase\e[0m Some(x) => List(x.toLong, arr.indexOf(x))\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue toLong is not a member of Any, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcp8fz69g.scala:34:13\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mcase\e[0m None\
    \ => List()\n\e[31m\e[31m   |\e[0m             ^^^^\e[0m\n\e[31m   |\e[0m    \
    \         Found:    None.type\n\e[31m   |\e[0m             Required: Long\n\e\
    [31m   |\e[0m             pattern type is incompatible with expected type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcp8fz69g.scala:37:31\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mcase\e[0m Some(x)\
    \ => List(x.toLong, arr.indexOf(x))\n\e[31m\e[31m   |\e[0m                   \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member of Any,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpcp8fz69g.scala:38:13 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mcase\e[0m None => pluck(arr.drop(arr.indexOf(\e\
    [31m0\e[0m).toInt))\n\e[31m\e[31m   |\e[0m             ^^^^\e[0m\n\e[31m   |\e\
    [0m             Found:    None.type\n\e[31m   |\e[0m"
  stdout: ''
  timestamp: 1660010090
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        def pluck_helper(arr\
    \ : List[Long]) : List[Long] = {\n            if (arr.isEmpty)\n             \
    \   Nil\n            else {\n                var next_node : Long = arr.head\n\
    \                var head : Long = arr.head\n                for (i <- 1 to arr.size)\
    \ {\n                    if (arr(i) %2 == 0) {\n                        if (next_node\
    \ < arr(i)) {\n                            next_node = arr(i)\n              \
    \              head = i\n                        }\n                    }\n  \
    \              }\n                (next_node, head)\n            }\n        }\n\
    \        pluck_helper(arr)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpos140m7c.scala:44:16\
    \ --------------------\e[0m\e[0m\n\e[31m44 |\e[0m                (next_node, head)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \               Found:    (Long, Long)\n\e[31m   |\e[0m                Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010089
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // write your code\
    \ here\n        \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp11j9jwr_.scala:29:47\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m    \e[33mdef\e[0m \e[36mpluck\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \ ^\e[0m\n\e[31m   |\e[0m                                               Found:\
    \    Unit\n\e[31m   |\e[0m                                               Required:\
    \ List[Long]\n\e[31m30 |\e[0m        \e[34m// write your code here\e[0m\n\e[31m31\
    \ |\e[0m        \n\e[31m32 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010088
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val nodes : Map[Long,\
    \ List[Long]] = arr.foldLeft(Map[Long, List[Long]]()) {\n            case (acc,\
    \ val) => {\n                val node = acc\n                val idx = val\n \
    \               if (node == null || node.isEmpty) {\n                    acc +\
    \ (val -> (List[Long]()))\n                } else if (val % 2 == 0) {\n      \
    \              val val = node.minBy(x => x._1)\n                    if (node.contains(val._1))\
    \ {\n                        if (val._1 < idx) node.remove(val._1) else node(val._1)\
    \ = List(idx)\n                    } else {\n                        node(val._1)\
    \ = List(idx)\n                    }\n                } else {\n             \
    \       node + (val -> List(0))\n                }\n            }\n        }\n\
    \        nodes.keys.toList.sortBy(x => nodes.getOrElse(x, List[Long]()).minBy(y\
    \ => y._1)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp821kj9h_.scala:31:23 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mcase\e[0m (acc, \e[33mval\e[0m) =>\
    \ {\n\e[31m\e[31m   |\e[0m                       ^^^\e[0m\n\e[31m   |\e[0m   \
    \                    pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E018]\
    \ Syntax Error: /tmp/tmp821kj9h_.scala:33:26 ---------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m                \e[33mval\e[0m \e[36midx\e[0m = \e[33mval\e\
    [0m\n\e[31m\e[31m   |\e[0m                          ^^^\e[0m\n\e[31m   |\e[0m\
    \                          expression expected but \e[31mval\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp821kj9h_.scala:46:13 --------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m            }\n\e[31m\e[31m   |\e[0m             ^\e\
    [0m\n\e[31m   |\e[0m             Found:    Unit\n\e[31m   |\e[0m             Required:\
    \ scala.collection.mutable.Map[Long, List[Long]]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp821kj9h_.scala:48:84 ------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        nodes.keys.toList.sortBy(\e[36mx\e[0m => nodes.getOrElse(x,\
    \ List[\e[35mLong\e[0m]()).minBy(\e[36my\e[0m => y._1)).toList\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \              ^^^^\e[0m\n\e[31m   |\e[0m                                    \
    \    value _1 is not a member of Long\n\e[31m\e[31m-- Error: /tmp/tmp821kj9h_.scala:48:87\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m48 |\e[0m       \
    \ nodes.keys.toList.sortBy(\e[36mx\e[0m => nodes.getOrElse(x, List[\e[35mLong\e\
    [0m]()).minBy(\e[36my\e[0m => y._1)).toList\n\e[31m\e[31m   |\e[0m           \
    \                                                                            ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33"
  stdout: ''
  timestamp: 1660010091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min_even: Long\
    \ = arr(0)\n        var min_index: Long = 0\n        var even_values: List[Long]\
    \ = Nil\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 ==\
    \ 0 && (min_even < arr(i) || min_even < arr(i)))\n                even_values\
    \ ::= arr(i)\n            if (arr(i) % 2 == 0 && min_even < arr(i)) {\n      \
    \          min_even = arr(i)\n                min_index = i\n            }\n \
    \       }\n        if (even_values.isEmpty) {\n            Nil\n        } else\
    \ {\n            var even_value: Long = even_values(0)\n            var even_index_list:\
    \ List[Long] = Nil\n            for (i <- 0 until even_values.length)\n      \
    \          if (even_values(i) == even_value) {\n                    even_index_list\
    \ ::= even_values(i)\n                }\n            (min_even, min_index, even_index_list)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwg47sll_.scala:50:12\
    \ --------------------\e[0m\e[0m\n\e[31m50 |\e[0m            (min_even, min_index,\
    \ even_index_list)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mLong\e[0m\e\
    [1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mLong\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m\
    \ \e[0mList[Long]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m            Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010089
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        arr.sortWith((a, b)\
    \ => a.toLong > b.toLong)\n        var index = 0\n        var smalest_value =\
    \ arr(0) // start with the smallest value\n        while (index < arr.length)\
    \ {\n            var value = arr(index).toLong\n            if (value % 2 == 0)\
    \ {\n                if (value < smalest_value) smalest_value = value\n      \
    \      } else {\n                smalest_value = value // no even number found,\
    \ so we do not need to check the following nodes\n            }\n            index\
    \ += 1\n        }\n        val answer = arr(arr.length - 1).toLong - smalest_value\n\
    \        if (answer < 0) answer.toLong // we did not find a value that even, so\
    \ return -1\n        else answer.toLong :: 0 // return [ smalest_value, its index\
    \ ]\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphp29lmbx.scala:43:31\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mif\e[0m (answer\
    \ < \e[31m0\e[0m) answer.toLong \e[34m// we did not find a value that even, so\
    \ return -1\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Found:    Long\n\e[31m   |\e[0m  \
    \                      Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e\
    [32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphp29lmbx.scala:44:27\
    \ ------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33melse\e[0m answer.toLong\
    \ :: \e[31m0\e[0m \e[34m// return [ smalest_value, its index ]\e[0m\n\e[31m\e\
    [31m   |\e[0m                           ^^^^\e[0m\n\e[31m   |\e[0m           \
    \                value :: is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660010090
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val arr = arr.sortWith(_\
    \ < _)\n        val evens = arr.filter(_ % 2 == 0).sortWith(_ < _)\n        val\
    \ vals = evens.reverse.takeWhile(_ < arr.head)\n        if(evens.isEmpty) arr.toList\n\
    \        else vals.reverse.takeWhile(_ < arr.head).toList :+ arr.head\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpv_gkfc8k.scala:30:18 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010080
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = arr(0)\n\
    \        var min_idx = -1\n        var min_index = -1;\n        var even_value\
    \ = false;\n        var min_even_value = -1l\n        for (i <- arr.indices) {\n\
    \            if (arr(i) % 2 == 0) {\n                if (arr(i) < min_even_value)\
    \ {\n                    min_even_value = arr(i)\n                    min_idx\
    \ = i\n                } else if (arr(i) == min_even_value) {\n              \
    \      min_index = i\n                }\n            }\n            if (arr(i)\
    \ < min) {\n                even_value = true;\n                min = arr(i)\n\
    \                min_idx = i\n            }\n        }\n        if (even_value)\
    \ {\n            arr.updated(min_idx, arr(min_idx))\n        }\n        if (arr.length\
    \ == 0) arr.updated(min_idx, arr(min_idx))\n        if (arr.length == 1) arr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl4i2uxyo.scala:54:8\
    \ ---------------------\e[0m\e[0m\n\e[31m54 |\e[0m        \e[33mif\e[0m (arr.length\
    \ == \e[31m1\e[0m) arr\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m   |\e[0m        Maybe you are missing an else part for the conditional?\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010084
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens : List[Long]\
    \ = arr.filter(_%2 == 0).toList\n        val smalest_value = (evens.min).getOrElse(0l)\n\
    \        val smallest_index =\n            evens.indexOf((smallest_value, smallest_even_value)\
    \ => smallest_value == smallest_even_value)\n        if (smallest_index == -1)\
    \ return List()\n        evens.take(smallest_index + 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjqec4vxk.scala:31:40 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmalest_value\e[0m = (evens.min).getOrElse(\e\
    [31m0l\e[0m)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            value getOrElse is not a member\
    \ of Long\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpjqec4vxk.scala:33:27 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            evens.indexOf((\e[36msmallest_value\e[0m,\
    \ \e[36msmallest_even_value\e[0m) => smallest_value == smallest_even_value)\n\e\
    [31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m             Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m     \
    \        I could not infer the type of the parameter smallest_value.\n\e[31m\e\
    [31m-- [E081] Type Error: /tmp/tmpjqec4vxk.scala:33:43 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            evens.indexOf((\e[36msmallest_value\e[0m,\
    \ \e[36msmallest_even_value\e[0m) => smallest_value == smallest_even_value)\n\e\
    [31m\e[31m   |\e[0m                                           ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Missing parameter type\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m        I could not infer the type of the parameter smallest_even_value.\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var minEvenValue :\
    \ Long = -1\n        var minEvenIndex = 0\n        var i : Int = 0\n        for\
    \ (node <- arr) {\n            if (node % 2 == 0) {\n                if (minEvenValue\
    \ == -1 || node < minEvenValue) {\n                    minEvenValue = node\n \
    \                   minEvenIndex = i\n                }\n            }\n     \
    \       i += 1\n        }\n        minEvenIndex == 0 ? arr.empty : arr(minEvenIndex,1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpidj0qhs_.scala:42:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        minEvenIndex == \e[31m0\e[0m ? arr.empty : \e\
    [35marr\e[0m(minEvenIndex,\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \        end of statement expected but '(' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpidj0qhs_.scala:42:26 ------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m        minEvenIndex == \e[31m0\e[0m ? arr.empty : \e[35marr\e[0m(minEvenIndex,\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e\
    [0m                        value ? is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660010091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) List()\n\
    \        else arr.sortWith(_.value < _.value)\n            .map(i => if (i.value\
    \ % 2 == 0) i.value else i.value % 2)\n            .find(_._2 == 0)\n        \
    \    .map(_._1)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0terxdry.scala:31:28 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33melse\e[0m arr.sortWith(_.value < _.value)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                         value value is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp0terxdry.scala:32:28 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            .map(i => \e[33mif\e[0m (i.value % \e[31m2\e\
    [0m == \e[31m0\e[0m) i.value \e[33melse\e[0m i.value % \e[31m2\e[0m)\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 value value is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp0terxdry.scala:32:46 ------------------------\e[0m\e[0m\n\
    \e[31m32 |\e[0m            .map(i => \e[33mif\e[0m (i.value % \e[31m2\e[0m ==\
    \ \e[31m0\e[0m) i.value \e[33melse\e[0m i.value % \e[31m2\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                            ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                     value value is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp0terxdry.scala:32:59 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            .map(i => \e[33mif\e[0m (i.value % \e[31m2\e\
    [0m == \e[31m0\e[0m) i.value \e[33melse\e[0m i.value % \e[31m2\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     value value is not a\
    \ member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0terxdry.scala:33:20\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            .find(_._2 ==\
    \ \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e\
    [0mvalue _2 is not a member of Nothing, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might fix the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import concurrent.duration.durationToPair\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0terxdry.scala:34:19\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            .map(_._1)\n\e\
    [31m\e[31m   |\e[0m"
  stdout: ''
  timestamp: 1660010104
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evenValues = arr.filter(_%2\
    \ == 0)\n        if (evenValues.isEmpty) return List()\n        val evenValueList\
    \ = evenValues.toList.sortWith(_.value < _.value)\n        if (evenValueList.size\
    \ < 2) return List()\n        evenValueList.head._2\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgv1wm79j.scala:32:57 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mevenValueList\e[0m = evenValues.toList.sortWith(_.value\
    \ < _.value)\n\e[31m\e[31m   |\e[0m                                          \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \   value value is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpgv1wm79j.scala:34:27 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        evenValueList.head._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value _2 is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660010104
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val n = arr.size\n\
    \        val evens = arr.filter( x => x % 2 == 0 ).toList\n        val evensSet\
    \ = evens.toSet\n        val smallestIndex = arr.indexWhere( x => x % 2 == 0 ).min\n\
    \        val smallestValues = evens.filter(x => x % 2 == 0)\n        val indexOfSmallest\
    \ = arr.indexWhere( x => x % 2 == 0 ).min\n        if(smallestIndex == indexOfSmallest)\
    \ {\n            return List( smallestValue, smallestIndex )\n        }\n    \
    \    if(evensSet.size == 1) {\n            return List( smallestValue, smallestIndex\
    \ )\n        }\n        val index = Array.fill(n)(evens.indexOf( x => x % 2 ==\
    \ 0 )).min\n        return List( smallestValues(index), smallestIndex )\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpst45y4um.scala:37:25 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mreturn\e[0m List( smallestValue, smallestIndex\
    \ )\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                         Not found: smallestValue\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpst45y4um.scala:37:40 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mreturn\e[0m List( smallestValue, smallestIndex\
    \ )\n\e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    (smallestIndex\
    \ : Int => Int)\n\e[31m   |\e[0m                                  Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpst45y4um.scala:40:25\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m            \e[33mreturn\e\
    [0m List( smallestValue, smallestIndex )\n\e[31m\e[31m   |\e[0m              \
    \           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ smallestValue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpst45y4um.scala:40:40\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m            \e[33mreturn\e[0m\
    \ List( smallestValue, smallestIndex )\n\e[31m\e[31m   |\e[0m                \
    \                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                 Found:    (smallestIndex : Int => Int)\n\e[31m   |\e[0m    \
    \                              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E081] Type Error: /tmp/tmpst45y4um.scala:42:49 -----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = Array.fill(n)(evens.indexOf(\
    \ \e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m )).min\n\e[31m\e[31m   |\e\
    [0m                                             "
  stdout: ''
  timestamp: 1660010107
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        def partition(arr :\
    \ List[Long], v : Long) : List[Long] = {\n            val index = if (arr.isEmpty)\
    \ 0 else arr.head\n            val value = arr.head\n            arr.tail.foldLeft((index,\
    \ value)) { case ((index, v), v) => if (v % 2 == 0) (v + 1, v) else if (v < v)\
    \ (v + 1, index) else if (v > v) (v + 1, index) }\n        }\n        val min\
    \ = partition(arr, arr.head)\n        if (min.head == min.tail)\n            min.head\
    \ :: Nil\n        else\n            min.head :: min.tail\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E005] Naming Error: /tmp/tmpo3hn5jjw.scala:33:66 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            arr.tail.foldLeft((index, value)) { \e[33mcase\e\
    [0m ((index, v), v) => \e[33mif\e[0m (v % \e[31m2\e[0m == \e[31m0\e[0m) (v + \e\
    [31m1\e[0m, v) \e[33melse\e[0m \e[33mif\e[0m (v < v) (v + \e[31m1\e[0m, index)\
    \ \e[33melse\e[0m \e[33mif\e[0m (v > v) (v + \e[31m1\e[0m, index) }\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \  ^\e[0m\n\e[31m   |\e[0m                                           duplicate\
    \ pattern variable: v\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo3hn5jjw.scala:33:135\
    \ -------------------\e[0m\e[0m\n\e[31m33 |\e[0m            arr.tail.foldLeft((index,\
    \ value)) { \e[33mcase\e[0m ((index, v), v) => \e[33mif\e[0m (v % \e[31m2\e[0m\
    \ == \e[31m0\e[0m) (v + \e[31m1\e[0m, v) \e[33melse\e[0m \e[33mif\e[0m (v < v)\
    \ (v + \e[31m1\e[0m, index) \e[33melse\e[0m \e[33mif\e[0m (v > v) (v + \e[31m1\e\
    [0m, index) }\n\e[31m\e[31m   |\e[0m                                         \
    \                                                                            \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \      Found:    Unit\n\e[31m   |\e[0m                 Required: (Long, Long)\n\
    \e[31m   |\e[0m                 Maybe you are missing an else part for the conditional?\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpo3hn5jjw.scala:36:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mif\e[0m (min.head == min.tail)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of types\
    \ Long and List[Long @uncheckedVariance] cannot be compared with == or !=\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010105
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Write your code\
    \ here.\n        val arr2 = arr.toSet\n        var minIndex = 0\n        var maxValue\
    \ = 0\n        var min = Long.MaxValue\n        for(i <- 0 until arr.length){\n\
    \            val value = arr(i)\n            if(value % 2 == 0) {\n          \
    \      minIndex = i\n                maxValue = value\n                min = Long.MaxValue\n\
    \            }\n            else if(value < maxValue){\n                minIndex\
    \ = i\n                maxValue = value\n                min = Long.MaxValue\n\
    \            }\n            else if(value == maxValue){\n                if(value\
    \ < min){ min = value }\n                else{\n                    if(value >\
    \ max){\n                        maxIndex = i\n                        maxValue\
    \ = value\n                        max = Long.MaxValue\n                    }\n\
    \                    else{\n                        if(max == Long.MaxValue){\n\
    \                            minIndex = i\n                            maxValue\
    \ = value\n                            min = Long.MaxValue\n                 \
    \       }\n                    }\n                }\n            }\n        }\n\
    \        if(arr.length == 0) {return Nil}\n        if(arr.length == 1){return\
    \ List(arr(0))}\n        val minValues = arr.toArray.filter(v => v % 2 == 0).sortBy(v\
    \ => v).toList\n        val minIndexes = minValues.indices.filter(_ => minValues(_)\
    \ < min).sortBy(_ => minValues(_)).toList\n        val index = minIndexes.head\n\
    \        val value = minValues(index)\n        if(value < minValues.last){\n \
    \           val newArr = ArrayBuffer.empty[Long]\n            var lastElement\
    \ = arr(arr.length - 1)\n            newArr ++= arr2.toList.filter(v => v != lastElement)\n\
    \            newArr ++= minIndexes.map(i => arr(i))\n            return newArr\n\
    \        }\n        else{\n            val newArr = ArrayBuffer.empty[Long]\n\
    \            for(i <- 0 until arr.length-1){\n                if(arr(i) != value\
    \ && arr(i) != arr2(arr(i))) {\n                    val newArr = ArrayBuffer.empty[Long]\n\
    \                    var lastElement = arr(arr.length - 1)\n                 \
    \   newArr ++= arr2.toList.filter(v => v != lastElement)\n                   \
    \ newArr ++= minIndexes.map(i => arr(i))\n                    return newArr\n\
    \                }\n            }\n            return Nil\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpimqefslh.scala:39:27\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m                maxValue = value\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                         Found:    (value : Long)\n\e[31m   |\e[0m          \
    \                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpimqefslh.scala:44:27 --------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m                maxValue = value\n\e[31m\e[31m   |\e[0m              \
    \             ^^^^^\e[0m\n\e[31m   |\e[0m                           Found:   \
    \ (value : Long)\n\e[31m   |\e[0m                           Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpimqefslh.scala:50:29 -----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                    \e[33mif\e[0m(value > max){\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m>\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float):\
    \ Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\
    \e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m\
    \   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments ((Int, Int) => Int)\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpimqefslh.scala:51:24 ------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                        maxIndex = i\n\e[31m\e[31m  \
    \ |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \         Not found: maxIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpimqefslh.scala:52:35 --------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m                        maxValue = value\n\e[31m\e[31m   |\e[0m      \
    \                             ^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \               Found"
  stdout: ''
  timestamp: 1660010114
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // write your code\
    \ in Scala\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvrvxucz_.scala:29:47\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m    \e[33mdef\e[0m \e[36mpluck\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = {\n\e[31m\e[31m   |\e[0m                                              \
    \ ^\e[0m\n\e[31m   |\e[0m                                               Found:\
    \    Unit\n\e[31m   |\e[0m                                               Required:\
    \ List[Long]\n\e[31m30 |\e[0m        \e[34m// write your code in Scala\e[0m\n\e\
    [31m31 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010107
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var result = arr.toVector\n\
    \        if (arr.isEmpty || arr.toVector.min % 2 != 0) {\n            result =\
    \ List()\n        }\n        else {\n            var index = 0\n            for\
    \ (i <- arr.indices) {\n                if (arr(i) % 2 == 0) {\n             \
    \       index += 1\n                }\n            }\n            var smallest_value\
    \ = arr(arr.length)\n            for (i <- arr.indices) {\n                if\
    \ (arr(i) % 2 == 0) {\n                    if (smallest_value < arr(i)) {\n  \
    \                      smallest_value = arr(i)\n                        index\
    \ = i\n                    }\n                }\n            }\n            result\
    \ = List()\n            for (i <- 0 until arr.size) {\n                if (arr(i)\
    \ == smallest_value) {\n                    result = result :+ smallest_value.toLong\n\
    \                }\n            }\n        }\n        result.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp292nuzba.scala:32:25\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            result = List()\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \              Found:    List[Nothing]\n\e[31m   |\e[0m                     Required:\
    \ Vector[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp292nuzba.scala:50:25\
    \ --------------------\e[0m\e[0m\n\e[31m50 |\e[0m            result = List()\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \              Found:    List[Nothing]\n\e[31m   |\e[0m                     Required:\
    \ Vector[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010110
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var picked = 0\n  \
    \      var pickedNode = 0\n        var pickedIndex = 0\n        var evenValue\
    \ = 0\n        var evenIndex = 0\n        for(i <- 0 until arr.length){\n    \
    \        if(arr(i) %2 == 0 && arr(i) > evenValue){\n                evenValue\
    \ = arr(i)\n                evenIndex = i\n            }\n            if(arr(i)\
    \ == evenValue && i < arr.length){\n                picked = i + 1\n         \
    \       pickedNode = evenIndex\n                pickedIndex = evenIndex\n    \
    \        }\n        }\n        if(arr.length > 0){\n            pickedNode = pickedNode\
    \ + 1\n            pickedIndex = pickedIndex + 1\n        }\n        if(picked\
    \ == 0){\n            return List()\n        }\n        else{\n            pickedIndex\
    \ -= 1\n        }\n        return List(pickedValue, pickedIndex)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg8zz9ur4.scala:37:31\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m                evenValue = arr(i)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Found:    Long\n\e[31m   |\e[0m                 \
    \           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpg8zz9ur4.scala:56:20 ------------------------\e[0m\e[0m\n\e[31m56 |\e\
    [0m        \e[33mreturn\e[0m List(pickedValue, pickedIndex)\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not\
    \ found: pickedValue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010110
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n       def minEvenIndex(a :\
    \ Long, b : Long) : Int = {\n           val m = (a + b) / 2;\n           if (m\
    \ % 2 == 0) a else b\n       }\n\n       val evens = new mutable.HashSet[Long]()\n\
    \       var index = 0\n       arr.filter(_ % 2 == 0).foreach { e => evens.add(e)\
    \ }\n       val list = arr.filter(_ % 2 == 0).map(_ => e).toList\n       val evenSet\
    \ = new mutable.HashSet[Long](evens)\n       val result  = list.sorted.takeWhile(_\
    \ % 2 == 0).takeWhile(_ < evenSet.min).zipWithIndex.filter(_._2 % 2 == 0).map(_._1).headOption\n\
    \       if(result != None) result.map(_+1).toList\n       else Nil\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn57vgfti.scala:32:27\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m           \e[33mif\e[0m (m %\
    \ \e[31m2\e[0m == \e[31m0\e[0m) a \e[33melse\e[0m b\n\e[31m\e[31m   |\e[0m   \
    \                        ^\e[0m\n\e[31m   |\e[0m                           Found:\
    \    (a : Long)\n\e[31m   |\e[0m                           Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn57vgfti.scala:32:34 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m           \e[33mif\e[0m (m % \e[31m2\e[0m == \e[31m0\e\
    [0m) a \e[33melse\e[0m b\n\e[31m\e[31m   |\e[0m                              \
    \    ^\e[0m\n\e[31m   |\e[0m                                  Found:    (b : Long)\n\
    \e[31m   |\e[0m                                  Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpn57vgfti.scala:35:23 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m       \e[33mval\e[0m \e[36mevens\e[0m = \e[33mnew\e\
    [0m mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn57vgfti.scala:38:50\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m       \e[33mval\e[0m \e\
    [36mlist\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).map(_ => e).toList\n\
    \e[31m\e[31m   |\e[0m                                                  ^\e[0m\n\
    \e[31m   |\e[0m                                                  Not found: e\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn57vgfti.scala:39:25\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m       \e[33mval\e[0m \e\
    [36mevenSet\e[0m = \e[33mnew\e[0m mutable.HashSet[\e[35mLong\e[0m](evens)\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                     Not found: mutable\n"
  stdout: ''
  timestamp: 1660010114
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val len = arr.length\n\
    \        val evens = arr.filter(x => x.toString.contains(\"even\"))\n        val\
    \ min = evens.minBy(_.toString).head\n        val evensIndex = evens.map(x =>\
    \ x.indexOf(min)).toArray\n        val evensArray = evensIndex.toArray\n     \
    \   evensArray.maxBy(x => x).headOption\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo0myh06m.scala:32:42 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = evens.minBy(_.toString).head\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  value head is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpo0myh06m.scala:33:42 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mevensIndex\e[0m = evens.map(\e\
    [36mx\e[0m => x.indexOf(min)).toArray\n\e[31m\e[31m   |\e[0m                 \
    \                       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \             value indexOf is not a member of Long\n\e[31m\e[31m-- Error: /tmp/tmpo0myh06m.scala:33:63\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m33 |\e[0m       \
    \ \e[33mval\e[0m \e[36mevensIndex\e[0m = evens.map(\e[36mx\e[0m => x.indexOf(min)).toArray\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \       ^\e[0m\n\e[31m   |\e[0m                                          No ClassTag\
    \ available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                          \
    \                where:    B is a type variable\n3 errors found\n"
  stdout: ''
  timestamp: 1660010114
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) List[Long]()\n\
    \        var min : Long = arr.head\n        var i : Int = 0\n        var odds\
    \ : List[Long] = Nil\n        var evens : List[Long] = Nil\n        var evensIndex\
    \ : List[Long] = Nil\n        var oddsIndex : List[Long] = Nil\n        var minIndex\
    \ : Int = arr.length\n\n        while (i < arr.length) {\n            if (arr(i)\
    \ % 2 == 0) {\n                evens = evens ::: List(i)\n                evensIndex\
    \ = evensIndex ::: List(i)\n            } else {\n                odds = odds\
    \ ::: List(i)\n                oddsIndex = oddsIndex ::: List(i)\n           \
    \ }\n            i += 2\n        }\n        if (evens.isEmpty) odds\n        else\
    \ {\n            val smalest_value = (evens.min) match {\n                case\
    \ i: Int => arr(i)\n                case j: Long => arr(j)\n            }\n  \
    \          if (evensIndex.contains(smalest_value)) {\n                oddsIndex.find(_.toLong\
    \ == smalest_value) match {\n                    case Some(smalest_index) => smalest_index\n\
    \                    case None => 0\n                }\n            } else {\n\
    \                minIndex\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0ui9zhkx.scala:41:24\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m                evens = evens\
    \ ::: List(i)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Found:    List[\e[1m\e[31mAnyVal\e\
    [0m]\n\e[31m   |\e[0m                        Required: List[\e[1m\e[32mLong\e\
    [0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0ui9zhkx.scala:42:29\
    \ --------------------\e[0m\e[0m\n\e[31m42 |\e[0m                evensIndex =\
    \ evensIndex ::: List(i)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Found:    List[\e[1m\e[31mAnyVal\e\
    [0m]\n\e[31m   |\e[0m                             Required: List[\e[1m\e[32mLong\e\
    [0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0ui9zhkx.scala:44:23\
    \ --------------------\e[0m\e[0m\n\e[31m44 |\e[0m                odds = odds :::\
    \ List(i)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\
    \e[31m   |\e[0m                       Required: List[\e[1m\e[32mLong\e[0m]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0ui9zhkx.scala:45:28\
    \ --------------------\e[0m\e[0m\n\e[31m45 |\e[0m                oddsIndex = oddsIndex\
    \ ::: List(i)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Found:    List[\e[1m\e[31mAnyVal\e\
    [0m]\n\e[31m   |\e[0m                            Required: List[\e[1m\e[32mLong\e\
    [0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0ui9zhkx.scala:53:36\
    \ --------------------\e[0m\e[0m\n\e[31m53 |\e[0m                \e[33mcase\e\
    [0m j: Long => arr(j)\n\e[31m\e[31m   |\e[0m                      "
  stdout: ''
  timestamp: 1660010117
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min_even_value\
    \ : Long = -1\n        var min_value : Long = Long.MaxValue\n        var min_node\
    \ : Long = 0\n        var index : Long = -1\n        var i = 0\n        while(i\
    \ < arr.length) {\n            if(arr(i) % 2 == 0) {\n                if(min_even_value\
    \ < 0 || arr(i) < min_value) {\n                    min_even_value = arr(i)\n\
    \                    min_value = arr(i)\n                    min_node = i\n  \
    \                  index = i\n                }\n                i += 1\n    \
    \        } else {\n                i += 1\n            }\n        }\n        if(min_even_value\
    \ < 0) return Array[Long]()\n        if(min_node == arr.length - 1) return Array(min_even_value,\
    \ index)\n        if(min_node == 0) return Array(min_even_value, index)\n    \
    \    val new_arr = Array[Long](min_even_value, index)\n        for(i <- 0 until\
    \ arr.length - 1) {\n            if(arr(i) % 2 == 0) {\n                if(arr(i)\
    \ > min_value) {\n                    min_value = arr(i)\n                   \
    \ index = i\n                }\n            }\n        }\n        for(i <- 0 until\
    \ arr.length - 1) {\n            if(arr(i) % 2 == 0) {\n                if(arr(i)\
    \ > min_value) {\n                    new_arr += arr(i)\n                }\n \
    \           }\n        }\n        new_arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_p1obee4.scala:48:38\
    \ --------------------\e[0m\e[0m\n\e[31m48 |\e[0m        \e[33mif\e[0m(min_even_value\
    \ < \e[31m0\e[0m) \e[33mreturn\e[0m Array[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                     Found:    \e[1m\e[31mArray\e[0m[Long]\n\e\
    [31m   |\e[0m                                      Required: \e[1m\e[32mList\e\
    [0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_p1obee4.scala:49:51\
    \ --------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33mif\e[0m(min_node\
    \ == arr.length - \e[31m1\e[0m) \e[33mreturn\e[0m Array(min_even_value, index)\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                              Found:    \e\
    [1m\e[31mArray\e[0m[Long]\n\e[31m   |\e[0m                                   \
    \           Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp_p1obee4.scala:50:38 --------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mif\e[0m(min_node == \e[31m0\e[0m) \e[33mreturn\e\
    [0m Array(min_even_value, index)\n\e[31m\e[31m   |\e[0m                      \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                  Found:    \e[1m\e[31mArray\e[0m[Long]\n\e[31m   |\e[0m    \
    \                             Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_p1obee4.scala:63:28 ------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m                    new_arr += arr(i)\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value += is\
    \ not a member of Array[Long] - did you mean new_arr.!=?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp_p1obee4.scala:67:8 ---------------------\e[0m\e\
    [0m\n\e[31m67"
  stdout: ''
  timestamp: 1660010116
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var retVal = new Array[Long](arr.length);\n\
    \        var index = 0;\n        var minVal = Long.MaxValue;\n        var minIndex\
    \ = 0;\n        for (elem <- arr) {\n            if (elem.toInt % 2 == 0 && elem.toInt\
    \ < minVal) {\n                minVal = elem.toInt\n                minIndex =\
    \ index\n            } else if (elem.toInt % 2 == 0 && elem.toInt == minVal) {\n\
    \                retVal(index) = elem.toInt\n            }\n            index+=1\n\
    \        }\n        retVal(minIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqrey3j8p.scala:43:14\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m        retVal(minIndex)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    Long\n\e[31m   |\e[0m        Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e\
    [0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010111
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var maxEvenIndex =\
    \ 0\n        var maxEvenValue = arr(0)\n        var maxIndex = 0\n        var\
    \ tempArr = arr\n        for (i <- 0 until arr.length) {\n            if (arr(i)\
    \ % 2 == 0) {\n                if (maxEvenValue > arr(i)) {\n                \
    \    maxEvenValue = arr(i)\n                    maxEvenIndex = i\n           \
    \     }\n                else {\n                    maxEvenValue = arr(i)\n \
    \                   maxEvenIndex = i\n                }\n            }\n     \
    \   }\n        tempArr = tempArr filter { x =>\n            if (x % 2 == 0) {\n\
    \                if (x == maxEvenValue) {\n                    tempArr.indexOf(maxEvenIndex)\
    \ < tempArr.lastIndexOf(maxEvenIndex)\n                }\n                else\
    \ {\n                    x == maxEvenValue\n                }\n            }\n\
    \            else {\n                x == maxEvenValue\n            }\n      \
    \  }\n        tempArr\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg3s7xli_.scala:62)\n\tat Problem.main(tmpg3s7xli_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010116
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val indexMap = arr.groupBy(x\
    \ => x % 2l.toLong).map(x => (x._1.head, x._2.head)).toMap\n        arr.sortWith(_.toLong\
    \ % 2l.toLong < 0).headOption.getOrElse(arr :+ 0l.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7vj5w4c7.scala:30:70 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mindexMap\e[0m = arr.groupBy(\e\
    [36mx\e[0m => x % \e[31m2l\e[0m.toLong).map(\e[36mx\e[0m => (x._1.head, x._2.head)).toMap\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \         ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                    \
    \  value head is not a member of Long\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp7vj5w4c7.scala:31:21\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        arr.sortWith(_.toLong\
    \ % \e[31m2l\e[0m.toLong < \e[31m0\e[0m).headOption.getOrElse(arr :+ \e[31m0l\e\
    [0m.toLong)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Wrong number of parameters, expected:\
    \ 2\n2 errors found\n"
  stdout: ''
  timestamp: 1660010113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val newArr: List[Long]\
    \ = new scala.collection.mutable.ArrayList[Long]()\n        newArr ++= arr.map(i\
    \ => (i, i))\n        val evenArray = arr.filter(i => (i % 2) == 0)\n        evenArray.sortWith(_.compare(_.toLong)\
    \ < 0)\n        if(evenArray.size == 0) newArr else evenArray(0)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8im5dp1f.scala:30:62 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mnewArr\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = \e[33mnew\e[0m scala.collection.mutable.ArrayList[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m              type ArrayList is not a member of scala.collection.mutable\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8im5dp1f.scala:31:15 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        newArr ++= arr.map(\e[36mi\e[0m => (i, i))\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       value ++= is\
    \ not a member of List[Long] - did you mean newArr.++?\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmp8im5dp1f.scala:33:27 ---------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m        evenArray.sortWith(_.compare(_.toLong) < \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Wrong number of parameters, expected:\
    \ 2\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8im5dp1f.scala:34:53 --------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m(evenArray.size == \e[31m0\e[0m)\
    \ newArr \e[33melse\e[0m evenArray(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                        Found:    Long\n\e[31m   |\e[0m     \
    \                                       Required: \e[1m\e[32mList\e[0m\e[1m\e\
    [32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010114
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evenList = arr.filter(_\
    \ % 2 == 0).toList\n        if (evenList.size > 0) {\n            val minIndex\
    \ : Int = (evenList.filter(_ % 2 == 1).min)\n            val smalestValue : Long\
    \ = (evenList.toSet + minIndex).min\n            val pickedNode : List[Long] =\
    \ arr.filter(_ == smalestValue).toList\n            pickedNode\n        } else\
    \ {\n            Nil\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnad6_q_v.scala:32:34\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e\
    [36mminIndex\e[0m : \e[35mInt\e[0m = (evenList.filter(_ % \e[31m2\e[0m == \e[31m1\e\
    [0m).min)\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    Long\n\e[31m \
    \  |\e[0m                                  Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpnad6_q_v.scala:33:69 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36msmalestValue\e[0m :\
    \ \e[35mLong\e[0m = (evenList.toSet + minIndex).min\n\e[31m\e[31m   |\e[0m   \
    \                                                                  ^\e[0m\n\e\
    [31m   |\e[0mNo implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mwhere:    B is a type variable with constraint >: B\n\e[31m   |\e[0m..\n\e\
    [31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e\
    [35mB\e[0m](\n\e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[B]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[B].\n2 errors found\n"
  stdout: ''
  timestamp: 1660010115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if(arr.isEmpty) return\
    \ arr\n        var min_value = math.min(arr)\n        for(i <- 0 until arr.size)\
    \ {\n            if(arr(i) % 2 == 0) arr(i) = min_value\n            if(arr(i)\
    \ == min_value) min_value += 1\n        }\n        if(min_value == 1) arr.remove(0)\n\
    \        else arr\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpccozz2ub.scala:31:29 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m \e[36mmin_value\e[0m = math.min(arr)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((arr : List[Long]))\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpccozz2ub.scala:33:32\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mif\e[0m(arr(i)\
    \ % \e[31m2\e[0m == \e[31m0\e[0m) arr(i) = min_value\n\e[31m\e[31m   |\e[0m  \
    \                              ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpccozz2ub.scala:36:31 ------------------------\e[0m\e[0m\n\
    \e[31m36 |\e[0m        \e[33mif\e[0m(min_value == \e[31m1\e[0m) arr.remove(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue remove is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660010116
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var arrs = arr.toSet\n\
    \        while(arrs.nonEmpty){\n            var minVal = arrs.min\n          \
    \  arrs = arrs - minVal\n            arrs.map( _ + minVal )\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_l45hxt1.scala:31:8\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mwhile\e[0m(arrs.nonEmpty){\n\
    \e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\e\
    [31m   |\e[0m        Required: List[Long]\n\e[31m32 |\e[0m            \e[33mvar\e\
    [0m \e[36mminVal\e[0m = arrs.min\n\e[31m33 |\e[0m            arrs = arrs - minVal\n\
    \e[31m34 |\e[0m            arrs.map( _ + minVal )\n\e[31m35 |\e[0m        }\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010114
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // write your code\
    \ here\n        val result = new mutable.ListBuffer[Long]\n        arr.foreach\
    \ { n =>\n            if (n % 2 == 0) {\n                result.append(n)\n  \
    \          }\n        }\n        if (result.isEmpty || result.size < 2) {\n  \
    \          ListBuffer.empty\n        } else {\n            result.sortWith((x,\
    \ y) => x % 2 == y % 2)\n            result.toList\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp70bszrt1.scala:31:25 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m               \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp70bszrt1.scala:38:12\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m            ListBuffer.empty\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \      Found:    scala.collection.mutable.ListBuffer[A]\n\e[31m   |\e[0m     \
    \       Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m            where:\
    \    A is a type variable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010114
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        def findSmallest(arr\
    \ : List[Long], pick : Long) : List[Long] = {\n            if (arr.isEmpty) {\n\
    \                if (pick == 0) List(pick)\n                else {\n         \
    \           pick\n                }\n            } else {\n                arr.zipWithIndex.map(l\
    \ => (l._2 + l._1, l._1))\n                    .sortWith((x, y) => x._1 < y._1)\n\
    \                    .map(x => (x._2 % 2 != 0) ? x._1 : x._2)\n              \
    \      .headOption\n                    .map(l => findSmallest(arr.filter(x =>\
    \ x % 2 != 0), l))\n            }\n        }\n        findSmallest(arr, 0).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppfp5nswb.scala:34:20\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m                    pick\n\e\
    [31m\e[31m   |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m            \
    \        Found:    (pick : Long)\n\e[31m   |\e[0m                    Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppfp5nswb.scala:39:57\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                    .map(x\
    \ => (x._2 % \e[31m2\e[0m != \e[31m0\e[0m) ? x._1 : x._2)\n\e[31m\e[31m   |\e\
    [0m                                                       ^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                 type _2 is not a member of (Long, Long)\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppfp5nswb.scala:39:46 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    .map(x => (x._2 % \e[31m2\e[0m !=\
    \ \e[31m0\e[0m) ? x._1 : x._2)\n\e[31m\e[31m   |\e[0m                        \
    \      ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              value\
    \ ? is not a member of Boolean\n3 errors found\n"
  stdout: ''
  timestamp: 1660010118
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val indexSet = arr\
    \ groupBy {_.toInt} mapValues { _.toList }\n        var index = 0\n        var\
    \ index = indexSet.values.toArray.sortWith(compare(_, 0))(index) match {\n   \
    \         case a if a.size < a.length =>\n                val index = a.indexWhere(_\
    \ => a.contains(0))\n                val value = a(0)\n                if (indexSet.contains(value))\n\
    \                    a\n                else\n                    List[Long](value,\
    \ index)\n            case _ =>\n                List[Long]()\n        }\n   \
    \     var value = 0\n        index = indexSet.values.toArray.sortWith(compare(_,\
    \ 0))(index) match {\n            case a if a.size < a.length =>\n           \
    \     value = a(0)\n            case _ =>\n                List[Long]()\n    \
    \    }\n        if (indexSet.contains(value)) {\n            val list = indexSet.get(value).map(v\
    \ => List(v)).toList\n            indexSet.remove(value)\n            List(list.toVector)\n\
    \        }\n        else\n            List()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpr8j0njlm.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m \e[36mindex\e[0m = indexSet.values.toArray.sortWith(compare(_,\
    \ \e[31m0\e[0m))(index) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\
    \e[31m   |\e[0mindex is already defined as \e[33mvariable\e[0m \e[35mindex\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m33 |\e[0m            \e[33mcase\e\
    [0m a \e[33mif\e[0m a.size < a.length =>\n\e[31m34 |\e[0m                \e[33mval\e\
    [0m \e[36mindex\e[0m = a.indexWhere(_ => a.contains(\e[31m0\e[0m))\n\e[31m35 |\e\
    [0m                \e[33mval\e[0m \e[36mvalue\e[0m = a(\e[31m0\e[0m)\n\e[31m36\
    \ |\e[0m                \e[33mif\e[0m (indexSet.contains(value))\n\e[31m37 |\e\
    [0m                    a\n\e[31m38 |\e[0m                \e[33melse\e[0m\n\e[31m39\
    \ |\e[0m                    List[\e[35mLong\e[0m](value, index)\n\e[31m40 |\e\
    [0m            \e[33mcase\e[0m _ =>\n\e[31m41 |\e[0m                List[\e[35mLong\e\
    [0m]()\n\e[31m42 |\e[0m        }\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpr8j0njlm.scala:44:49\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        index = indexSet.values.toArray.sortWith(compare(_,\
    \ \e[31m0\e[0m))(index) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m            \
    \                                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                             Wrong number of parameters, expected: 2\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpr8j0njlm.scala:46:25 --------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                value = a(\e[31m0\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^\e[0m\n\e[31m   |\e[0m                 \
    \       Found:    Long\n\e[31m   |\e[0m                        Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr8j0njlm.scala:48:26\
    \ --------------------\e[0m\e[0m\n\e[31m48 |\e[0m                List[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Found:    Li"
  stdout: ''
  timestamp: 1660010118
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var flag : Boolean\
    \ = true\n        var index : Int = 0\n        var flag1 = true\n        var index1\
    \ = 1\n        var arr1 = arr\n        while (arr1.nonEmpty) {\n            var\
    \ smallest_value : Long = arr1.min\n            var smallest_index : Int = arr1.indexOf(min)\n\
    \            smallest_value = smallest_value % 2\n            if (flag1 && flag)\
    \ {\n                flag1 = false\n                index = index1\n         \
    \   }\n            if (smallest_value == 0 && smallest_index != -1) {\n      \
    \          flag = false\n                index = index1\n            } else if\
    \ (smallest_value == 0 && smallest_index == -1) {\n                flag = true\n\
    \                index1 = index\n            } else if (smallest_value % 2 ==\
    \ 0) {\n                arr1 = arr1.removeAt(smallest_index)\n               \
    \ arr1 = arr1.removeAt(smallest_index)\n                arr1 = arr1.removeAt(smallest_index)\n\
    \                arr1 = arr1.removeAt(smallest_index)\n                arr1 =\
    \ arr1.removeAt(smallest_index)\n                arr1 = arr1.removeAt(smallest_index)\n\
    \            } else {\n                arr1 = arr1.removeAt(smallest_index)\n\
    \                arr1 = arr1.removeAt(smallest_index)\n                arr1 =\
    \ arr1.removeAt(smallest_index)\n                arr1 = arr1.removeAt(smallest_index)\n\
    \                arr1 = arr1.removeAt(smallest_index)\n                arr1 =\
    \ arr1.removeAt(smallest_index)\n            }\n        }\n        arr.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbnardudy.scala:50:28 ------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                arr1 = arr1.removeAt(smallest_index)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       value removeAt is not a member of List[Long]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpbnardudy.scala:51:28 ------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                arr1 = arr1.removeAt(smallest_index)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       value removeAt is not a member of List[Long]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpbnardudy.scala:52:28 ------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m                arr1 = arr1.removeAt(smallest_index)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       value removeAt is not a member of List[Long]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpbnardudy.scala:53:28 ------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m                arr1 = arr1.removeAt(smallest_index)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       value removeAt is not a member of List[Long]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpbnardudy.scala:54:28 ------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m                arr1 = arr1.removeAt(smallest_index)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       value removeAt is not a member of List[Long]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpbnardudy.scala:55:28 ------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m                arr1 = arr1.removeAt(smallest_index)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       value removeAt is not a member of List[Long]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpbnardudy.scala:57:28 ------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m                arr1 = arr1.removeAt(smallest_index)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010120
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min_even_count\
    \ = 0\n        var min_even_index = -1\n        arr.foldLeft((0,-1)){\n      \
    \      case ((even_count, even_index), node) =>\n                if (even_count\
    \ == min_even_count) {\n                    if (even_index < min_even_index)\n\
    \                        min_even_index = even_index\n                }\n    \
    \            else {\n                    if (even_count > min_even_count)\n  \
    \                      (min_even_count, min_even_index) = (even_count, even_index)\n\
    \                }\n                (node)\n        }\n        if (min_even_count\
    \ == min_even_count)\n            List()\n        else\n            (arr.take(min_even_index),\
    \ min_even_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6tlncjfl.scala:40:57 -----------------------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                        (min_even_count, min_even_index)\
    \ = (even_count, even_index)\n\e[31m\e[31m   |\e[0m                          \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \           end of statement expected but '=' found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp6tlncjfl.scala:42:17 --------------------\e[0m\e[0m\n\
    \e[31m42 |\e[0m                (node)\n\e[31m\e[31m   |\e[0m                 ^^^^\e\
    [0m\n\e[31m   |\e[0m                 Found:    (node : Long)\n\e[31m   |\e[0m\
    \                 Required: (Int, Int)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp6tlncjfl.scala:47:12 --------------------\e[0m\e\
    [0m\n\e[31m47 |\e[0m            (arr.take(min_even_index), min_even_index)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            Found:    \e[1m\e[31m(\e[0mList[Long]\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m    \
    \        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010129
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) List(Long.MaxValue)\n\
    \        if (arr.isEmpty && arr(0) == Long.MaxValue) List()\n        var arr1\
    \ = arr filter (_ % 2 == 0)\n        arr1 foreach (n => { val temp = arr1.filter(_\
    \ != n)\n                          if (temp.length < arr1.length) {\n        \
    \                      arr1 = temp :: arr1\n                          } else arr1\
    \ = temp})\n        arr1(0)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpshl1s_kq.scala:35:37\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m                            \
    \  arr1 = temp :: arr1\n\e[31m\e[31m   |\e[0m                                \
    \     ^^^^\e[0m\n\e[31m   |\e[0m                                     Found:  \
    \  (temp : List[Long])\n\e[31m   |\e[0m                                     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpshl1s_kq.scala:37:12\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m        arr1(\e[31m0\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e\
    [32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010130
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_.toLong\
    \ % 2 == 0).sortBy(_.toLong).reverse\n        evens.head.asInstanceOf[Long] %\
    \ 2 == 0 ? evens.toList :\n            evens.takeWhile(x => x.asInstanceOf[Long]\
    \ % 2 == 0).sortBy(_.toLong).reverse.take(1).asInstanceOf[List[Long]]\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpxf9f5vr5.scala:32:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            evens.takeWhile(\e[36mx\e[0m => x.asInstanceOf[\e\
    [35mLong\e[0m] % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_.toLong).reverse.take(\e\
    [31m1\e[0m).asInstanceOf[\e[35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e\
    [0m                           ^\e[0m\n\e[31m   |\e[0m                        \
    \   end of statement expected but '(' found\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpxf9f5vr5.scala:31:47 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m        evens.head.asInstanceOf[\e[35mLong\e[0m] % \e[31m2\e[0m == \e[31m0\e\
    [0m ? evens.toList :\n\e[31m\e[31m   |\e[0m                                  \
    \           ^^^\e[0m\n\e[31m   |\e[0m                                        \
    \  value ? is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660010127
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val indexMap = arr.zipWithIndex.toMap\n\
    \        val smalest_vals = arr.filter(_ % 2 == 0)\n        if (smalest_vals.isEmpty)\
    \ {\n            return Array[Long]()\n        }\n        val smalest_val = smalest_vals.sortBy(-_).head\n\
    \        val index = (smalest_vals, indexMap.get(smalest_val)).last\n        return\
    \ index match {\n            case (v, i) => Array[Long](smalest_val, i)\n    \
    \        case _ => Array[Long]()\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbkzanyvq.scala:33:19\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mreturn\e[0m\
    \ Array[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    \e[1m\e[31mArray\e[0m[Long]\n\
    \e[31m   |\e[0m                   Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbkzanyvq.scala:38:52 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mcase\e[0m (v, i) => Array[Long](smalest_val,\
    \ i)\n\e[31m\e[31m   |\e[0m                                                  \
    \  ^\e[0m\n\e[31m   |\e[0m                                                   \
    \ Found:    (i : Any)\n\e[31m   |\e[0m                                       \
    \             Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpbkzanyvq.scala:39:22 --------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m            \e[33mcase\e[0m _ => Array[Long]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \   Found:    \e[1m\e[31mArray\e[0m[Long]\n\e[31m   |\e[0m                   \
    \   Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010134
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val result: List[Long]\
    \ = new ArrayList[Long]\n        val min_value: List[Long] = arr\n        .sortWith((x,\
    \ y) => x < y)\n        .map((x) => if (x % 2 == 0) x else -1)\n        .takeWhile(_\
    \ >= 0)\n        .filter(_ % 2 == 0)\n        .sortWith(_ < _)\n        .map((_\
    \ + 1l))\n        .takeWhile(_ < arr.length)\n        .map((_ + 1l))\n       \
    \ .takeWhile(x => x < arr.length)\n        .filter(_ < arr.length)\n        .map((_\
    \ + 1l))\n        .takeWhile(x => x < arr.length)\n        .filter(_ < arr.length)\n\
    \        .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n        .filter(_\
    \ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n\
    \        .filter(_ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x\
    \ => x < arr.length)\n        .filter(_ < arr.length)\n        .map((_ + 1l))\n\
    \        .takeWhile(x => x < arr.length)\n        .filter(_ < arr.length)\n  \
    \      .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n        .filter(_\
    \ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n\
    \        .filter(_ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x\
    \ => x < arr.length)\n        .filter(_ < arr.length)\n        .map((_ + 1l))\n\
    \        .takeWhile(x => x < arr.length)\n        .filter(_ < arr.length)\n  \
    \      .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n        .filter(_\
    \ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n\
    \        .filter(_ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x\
    \ => x < arr.length)\n        .filter(_ < arr.length)\n        .map((_ + 1l))\n\
    \        .takeWhile(x => x < arr.length)\n        .filter(_ < arr.length)\n  \
    \      .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n        .filter(_\
    \ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x => x < arr.length)\n\
    \        .filter(_ < arr.length)\n        .map((_ + 1l))\n        .takeWhile(x\
    \ => x < arr.length)\n        .filter(_ < arr.length)\n        .map((_ + 1\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo3z0wbhd.scala:91:4 ----------------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo3z0wbhd.scala:30:37\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mArrayList\e\
    [0m[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                                  \
    \   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     Not found:\
    \ type ArrayList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo3z0wbhd.scala:91:5\
    \ ---------------------\e[0m\e[0m\n\e[31m91 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010132
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val m = arr.foldLeft(Option(Long.MaxValue))((v,\
    \ el) => if (v.get < el) Some(el) else None);\n        if(m.isEmpty)\n       \
    \     List()\n        else\n            m.get.map((el, i) => if (i % 2 == 0)\n\
    \                el\n            else\n                el.toLong)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgxe12gmy.scala:34:18 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            m.get.map((\e[36mel\e[0m, \e[36mi\e[0m) =>\
    \ \e[33mif\e[0m (i % \e[31m2\e[0m == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value map is not a member\
    \ of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010133
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var cur = arr(0)\n\
    \        var i = 0\n        var res : List[Long] = Nil\n\n        while (i < arr.length)\
    \ {\n            if (cur % 2 == 0) {\n                if (i != arr.length && arr(i+1)\
    \ == cur) {\n                    i += 1\n                } else if (i == arr.length)\
    \ {\n                    res.append(cur)\n                    i += 1\n       \
    \         } else {\n                    res.append(cur)\n                    i\
    \ += 1\n                    cur = arr(i)\n                }\n            } else\
    \ {\n                i += 1\n            }\n        }\n        if (i == arr.length)\
    \ {\n            res.append(cur)\n        }\n        return res\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm29i7loc.scala:39:24 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    res.append(cur)\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue append is not a member\
    \ of List[Long] - did you mean List[Long].appended?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpm29i7loc.scala:42:24 ------------------------\e[0m\e[0m\n\
    \e[31m42 |\e[0m                    res.append(cur)\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue append is not a member\
    \ of List[Long] - did you mean List[Long].appended?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpm29i7loc.scala:51:16 ------------------------\e[0m\e[0m\n\
    \e[31m51 |\e[0m            res.append(cur)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue append is not a member of List[Long] - did you mean\
    \ List[Long].appended?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010134
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val even_values = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).toArray\n        val first_value : Long = even_values(0)\n\
    \        val max_value_index : Int = arr.indexWhere(x => x == first_value)\n \
    \       val value = even_values(max_value_index)\n        val index: List[Long]\
    \ = List(first_value, max_value_index)\n        if (even_values.size == 1) {\n\
    \            return index\n        } else {\n            val even_values_with_index\
    \ = even_values.map(_ -> arr.indexOf(_)).toMap\n            val first_value_with_index\
    \ = even_values_with_index(1)\n            val max_value_index_with_index = even_values_with_index(max_value_index)\n\
    \            return List(first_value_with_index, max_value_index_with_index)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpj7gi_0fr.scala:38:57 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e[0m \e[36meven_values_with_index\e\
    [0m = even_values.map(_ -> arr.indexOf(_)).toMap\n\e[31m\e[31m   |\e[0m      \
    \                                                   ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 Wrong number of parameters, expected:\
    \ 1\n\e[31m\e[31m-- Error: /tmp/tmpj7gi_0fr.scala:38:77 -----------------------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e[0m \e[36meven_values_with_index\e\
    [0m = even_values.map(_ -> arr.indexOf(_)).toMap\n\e[31m\e[31m   |\e[0m      \
    \                                                                       ^\e[0m\n\
    \e[31m   |\e[0m                                          No ClassTag available\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                    \
    \      where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660010135
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        arr.foldRight(List[Long]())((x,\
    \ y) => if (x%2==0) y else x)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcfnvds6q.scala:30:65\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        arr.foldRight(List[\e\
    [35mLong\e[0m]())((\e[36mx\e[0m, \e[36my\e[0m) => \e[33mif\e[0m (x%\e[31m2\e[0m==\e\
    [31m0\e[0m) y \e[33melse\e[0m x)\n\e[31m\e[31m   |\e[0m                      \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                          Found:    (x : Long)\n\e[31m   |\e\
    [0m                                                    Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010135
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val len = arr.length\n\
    \        var smallest = arr(0)\n        var smallest_index = -1\n        var next_node\
    \ = 0\n        var i = 1 // counter\n        while (i < len) {\n            val\
    \ item = arr(i)\n            if (item % 2 == 0) {\n                smallest =\
    \ item\n                smallest_index = i\n                next_node = i + 1\n\
    \            }\n            i += 1\n        }\n        if (smallest_index != -1)\
    \ smallest_index\n        else arr.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd4eiq_8t.scala:44:34\
    \ --------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mif\e[0m (smallest_index\
    \ != -\e[31m1\e[0m) smallest_index\n\e[31m\e[31m   |\e[0m                    \
    \              ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \        Found:    (smallest_index : Int)\n\e[31m   |\e[0m                   \
    \               Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010135
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val list = arr.sorted\n\
    \        var res = new List[Long]()\n        var index = 0\n        var picked\
    \ = 0\n        var even = list.reduceLeft{ (a, e) =>\n            if (even) {\n\
    \                picked = 0\n                even = false\n                index\
    \ = 0\n                a = e\n                e\n            } else {\n      \
    \          if (a < e) {\n                    picked = e\n                    even\
    \ = true\n                    index = index + 1\n                    e\n     \
    \           } else if (a == e) {\n                    picked = e\n           \
    \         even = true\n                    index = index + 1\n               \
    \     e\n                } else {\n                    picked = e\n          \
    \          even = true\n                    index = index + 1\n              \
    \      e\n                }\n            }\n        }\n        res ::= picked\n\
    \        res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpav17vlcf.scala:35:16 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mif\e[0m (even) {\n\e[31m\e[31m   |\e\
    [0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e[33mvariable\e\
    [0m \e[35meven\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpav17vlcf.scala:37:16 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m                even = \e[31mfalse\e[0m\n\e[31m\e[31m   |\e[0m       \
    \         ^\e[0m\n\e[31m   |\e[0m                Recursive \e[33mvariable\e[0m\
    \ \e[35meven\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpav17vlcf.scala:39:18 -----------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m                a = e\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\
    \e[31m   |\e[0m                Reassignment to val a\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpav17vlcf.scala:43:29 --------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    picked = e\n\e[31m\e[31m   |\e[0m\
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \     Found:    (e : Long)\n\e[31m   |\e[0m                             Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpav17vlcf.scala:44:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m                    even\
    \ = \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m \
    \  |\e[0m                    Recursive \e[33mvariable\e[0m \e[35meven\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpav17vlcf.scala:48:29\
    \ --------------------\e[0m\e[0m\n\e[31m48 |\e[0m                    picked =\
    \ e\n\e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m\
    \                             Foun"
  stdout: ''
  timestamp: 1660010138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val (val, idx) = arr.foldLeft((-1L,\
    \ -1)) { case ((val, idx), nextVal) =>\n            val (nextVal, nextIdx) = nextVal.zipWithIndex.max\n\
    \            val (nextVal, nextIdx) = nextVal match {\n                case (_,\
    \ -1) => nextVal, 0\n                case (_, 0) => (nextVal, nextIdx)\n     \
    \           case (v, i) => (v, i + 1)\n            }\n            (nextVal, nextIdx)\n\
    \        }\n        arr match {\n            case Nil => Nil\n            case\
    \ head :: tail => head :: tail.filter(i => i % 2 == 0).sortWith(_ < _).reverse.takeWhile(i\
    \ => i < idx).reverse.toList\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp0udz3kkn.scala:30:13 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m (\e[33mval\e[0m, idx) = arr.foldLeft((-\e\
    [31m1L\e[0m, -\e[31m1\e[0m)) { \e[33mcase\e[0m ((\e[33mval\e[0m, idx), nextVal)\
    \ =>\n\e[31m\e[31m   |\e[0m             ^^^\e[0m\n\e[31m   |\e[0m            \
    \ pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp0udz3kkn.scala:30:58\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ (\e[33mval\e[0m, idx) = arr.foldLeft((-\e[31m1L\e[0m, -\e[31m1\e[0m)) { \e[33mcase\e\
    [0m ((\e[33mval\e[0m, idx), nextVal) =>\n\e[31m\e[31m   |\e[0m               \
    \                                           ^^^\e[0m\n\e[31m   |\e[0m        \
    \                                                pattern expected\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmp0udz3kkn.scala:33:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                \e[33mcase\e[0m (_, -\e[31m1\e[0m) =>\
    \ nextVal, \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                               \
    \        ^\e[0m\n\e[31m   |\e[0m                                 end of statement\
    \ expected but ',' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0udz3kkn.scala:31:17\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m (nextVal, nextIdx) = nextVal.zipWithIndex.max\n\e[31m\e[31m   |\e[0m     \
    \            ^\e[0m\n\e[31m   |\e[0m                 Recursive \e[33mvalue\e[0m\
    \ \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp0udz3kkn.scala:31:26 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m            \e[33mval\e[0m (nextVal, nextIdx) = nextVal.zipWithIndex.max\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   Recursive \e[33mvalue\e[0m \e[35m$1$\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-expl"
  stdout: ''
  timestamp: 1660010131
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        arr.sortBy(x => x.toInt)\n\
    \        arr.zipWithIndex.filter(_._2 % 2 == 1).map(_._1).headOption.getOrElse(arr.headOption)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxmz9vuwt.scala:31:77\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        arr.zipWithIndex.filter(_._2\
    \ % \e[31m2\e[0m == \e[31m1\e[0m).map(_._1).headOption.getOrElse(arr.headOption)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Matchable\n\e[31m   |\e[0m        Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010137
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var index = 0\n   \
    \     var pluck_val = arr(0) // start with the first node to compare\n       \
    \ var pluck_val_index = 0 // this is used for the first node in the list\n   \
    \     for (i <- 1 until arr.length){\n            if(arr(i) % 2 == 0) \n     \
    \       { // if we have an even value\n                if(pluck_val > arr(i)){\
    \ // if we are still getting the highest value\n                    pluck_val\
    \ = arr(i)\n                    pluck_val_index = i\n                }\n     \
    \       }\n            else\n            { // if we have an odd value\n      \
    \          if(pluck_val < arr(i)){ // if we are still getting the lowest value\n\
    \                    pluck_val = arr(i)\n                    pluck_val_index =\
    \ i\n                }\n            }\n        }\n        var pluck_val_return\
    \ = List.empty[Long]\n        if(pluck_val != 0) // if we found a value\n    \
    \    {\n            pluck_val_return = List(pluck_val, pluck_val_index)\n    \
    \    }\n        return pluck_val_return\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_xfzbmah.scala:57)\n\tat Problem.main(tmp_xfzbmah.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010140
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        require(arr.length\
    \ > 0)\n        var index = 0\n        var largest = 0\n        var result = []\n\
    \        for (i<- 0 until arr.length) {\n            if (arr(i) % 2 != 0) {\n\
    \                if (arr(i) > largest) {\n                    largest = arr(i)\n\
    \                    index = i\n                } else if (arr(i) == largest)\
    \ {\n                    if (index < i) index = i\n                }\n       \
    \     }\n        }\n        if (index >= 0) result.add(largest)\n        result.add(index)\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4hnycz2n.scala:33:22 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m = []\n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   an identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp4hnycz2n.scala:34:0 ----------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mfor\e[0m (i<- \e[31m0\e[0m until arr.length) {\n\e[31m\e\
    [31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m'=>' expected, but 'end of statement' found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4hnycz2n.scala:37:33 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                    largest = arr(i)\n\e[31m\e[31m  \
    \ |\e[0m                              ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                   Found:    Long\n\e[31m   |\e[0m                          \
    \    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4hnycz2n.scala:44:31\
    \ ------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mif\e[0m (index\
    \ >= \e[31m0\e[0m) result.add(largest)\n\e[31m\e[31m   |\e[0m                \
    \        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue add is not a member of Null, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m  import collection.convert.ImplicitConversions.buffer AsJavaList\n\e\
    [31m   |\e[0m  import collection.convert.ImplicitConversions.mutableSet AsJavaSet\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.set asScala\n\e\
    [31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.buffer AsJavaList\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.mutableSet\
    \ AsJavaSet\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.set\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.mutableSeq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.set\
    \ AsJavaSet\n\e[31m   |\e[0m  import collection.convert.Im"
  stdout: ''
  timestamp: 1660010139
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // base case\n    \
    \    if(arr.isEmpty) return List()\n        // get smallest even value\n     \
    \   val even = arr.filter(_ % 2 == 0).toList.min\n        // get smallest even\
    \ index\n        val index = arr.indexOf(0)\n        // get new array by removing\
    \ odd value\n        arr.filter(_ % 2 != 0).zipWithIndex.filter(_._1 == even).map(_._2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqdyy42a5.scala:40)\n\tat Problem.main(tmpqdyy42a5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010141
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val set = arr.map(n\
    \ => (n % 2, n)).distinct\n\n        if (set.size == 0) return Nil\n        else\
    \ if (set.size == 1) return set._1\n        else if (set.size == 2) return if\
    \ (set._1 <= set._2) set._1 else {\n            val i = arr.lastIndexWhere(x =>\
    \ set._1 == (x % 2 ==0l))\n            if (i != -1) set._2 else set._1\n     \
    \   }\n        else {\n            val i = arr.lastIndexWhere(x => set._1 == (x\
    \ % 2 ==0l))\n            if (i != -1) set._1 else set.last\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpip61upc3.scala:33:43 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (set.size == \e\
    [31m1\e[0m) \e[33mreturn\e[0m set._1\n\e[31m\e[31m   |\e[0m                  \
    \                     ^^^^^^\e[0m\n\e[31m   |\e[0m                          value\
    \ _1 is not a member of List[(Long, Long)]\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpip61upc3.scala:34:47 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33melse\e[0m \e[33mif\e[0m (set.size == \e[31m2\e[0m) \e[33mreturn\e\
    [0m \e[33mif\e[0m (set._1 <= set._2) set._1 \e[33melse\e[0m {\n\e[31m\e[31m  \
    \ |\e[0m                                           ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          value _1 is not a member of List[(Long, Long)]\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpip61upc3.scala:34:65 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (set.size == \e\
    [31m2\e[0m) \e[33mreturn\e[0m \e[33mif\e[0m (set._1 <= set._2) set._1 \e[33melse\e\
    [0m {\n\e[31m\e[31m   |\e[0m                                                 \
    \            ^^^^^^\e[0m\n\e[31m   |\e[0m                          value _1 is\
    \ not a member of List[(Long, Long)]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpip61upc3.scala:35:48\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m\
    \ \e[36mi\e[0m = arr.lastIndexWhere(\e[36mx\e[0m => set._1 == (x % \e[31m2\e[0m\
    \ ==\e[31m0l\e[0m))\n\e[31m\e[31m   |\e[0m                                   \
    \         ^^^^^^\e[0m\n\e[31m   |\e[0m                          value _1 is not\
    \ a member of List[(Long, Long)]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpip61upc3.scala:36:29\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m\
    \ (i != -\e[31m1\e[0m) set._2 \e[33melse\e[0m set._1\n\e[31m\e[31m   |\e[0m  \
    \                       ^^^^^^\e[0m\n\e[31m   |\e[0m                         value\
    \ _2 is not a member of List[(Long, Long)]\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpip61upc3.scala:36:41 ------------------------\e[0m\e[0m\n\e[31m36 |\e\
    [0m            \e[33mif\e[0m (i != -\e[31m1\e[0m) set._2 \e[33melse\e[0m se"
  stdout: ''
  timestamp: 1660010141
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = arr(0).toLong\n\
    \        var minIndex = 0\n        var maxIndex = 0\n        for(i <- 0 until\
    \ arr.length) {\n            if(arr(i).toLong == min) {\n                minIndex\
    \ = i\n                max = arr(i)\n            }else if(arr(i).toLong == max)\
    \ {\n                maxIndex = i\n            }\n        }\n        if(minIndex\
    \ == maxIndex) {\n            List();\n        }else if(minIndex < maxIndex) {\n\
    \            List (arr[minIndex], arr[minIndex+1])\n        }else{\n         \
    \   List (arr[maxIndex], arr[maxIndex-1])\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3vdy9y9t.scala:36:25\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m                max = arr(i)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                Found:    Long\n\e[31m   |\e[0m                      Required:\
    \ (Int, Int) => Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp3vdy9y9t.scala:37:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m37 |\e[0m       \
    \     }\e[33melse\e[0m \e[33mif\e[0m(arr(i).toLong == max) {\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of types\
    \ Long and (Int, Int) => Int cannot be compared with == or !=\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp3vdy9y9t.scala:44:22 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m            List (arr[\e[35mminIndex\e[0m], arr[\e[35mminIndex+\e\
    [31m1\e[0m])\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: type minIndex\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp3vdy9y9t.scala:44:45 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m            List (arr[\e[35mminIndex\e[0m], arr[\e[35mminIndex+\e\
    [31m1\e[0m])\n\e[31m\e[31m   |\e[0m                                          \
    \   ^\e[0m\n\e[31m   |\e[0m                                             Not found:\
    \ type +\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3vdy9y9t.scala:46:22\
    \ ------------------------\e[0m\e[0m\n\e[31m46 |\e[0m            List (arr[\e\
    [35mmaxIndex\e[0m], arr[\e[35mmaxIndex-\e[31m1\e[0m])\n\e[31m\e[31m   |\e[0m \
    \                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: type maxIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3vdy9y9t.scala:46:45\
    \ ------------------------\e[0m\e[0m\n\e[31m46 |\e[0m            List (arr[\e\
    [3"
  stdout: ''
  timestamp: 1660010141
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var nodeMap = mutable.Map[Long,\
    \ List[Long]]()\n        var nodeList = new ListBuffer[Long]()\n        for(i\
    \ <- arr.iterator){\n            val node = i\n            if(!nodeMap.contains(node)){\n\
    \                nodeMap.put(node, new ListBuffer[Long])\n            }\n    \
    \        nodeMap.get(node) += i\n        }\n        for(node <- nodeMap.keys){\n\
    \            val buffer = nodeMap.get(node)\n            val smallestValue = buffer.min\n\
    \            if(smallestValue == 0){\n                nodeList += smallestValue\n\
    \            }else{\n                buffer.remove(0)\n                if(buffer.isEmpty){\n\
    \                    nodeList += smallestValue\n                }else{\n     \
    \               val smallestIndex = buffer.indexOf(0)\n                    nodeList\
    \ += smallestValue\n                    nodeList += smallestIndex.toLong\n   \
    \             }\n            }\n        }\n        if(nodeList.isEmpty){\n   \
    \         nodeList += 0\n        }\n        nodeList.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy7qwk6t8.scala:30:22 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mvar\e[0m \e[36mnodeMap\e[0m = mutable.Map[\e\
    [35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m    \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010133
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evenNodes = arr.filter(x\
    \ => x.toInt % 2 == 0)\n        val smallest = evenNodes.minBy(x => x.toInt)\n\
    \        val largest = evenNodes.maxBy(x => x.toInt)\n        val indices = evenNodes.zipWithIndex.filter\
    \ { case (v, i) => v % 2 == 0 && v < smallest }.map(x => x._2).sortBy(x => x).reverse\n\
    \        if(indices.size > 0) {\n            List((largest, indices.get(0)))\n\
    \        } else {\n            List[Long]()\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpls2f_i13.scala:35:35 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            List((largest, indices.get(\e[31m0\e[0m)))\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m      value get is not a member of List[Int] - did you mean indices.seq?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010140
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ arr\n        var max_index = 0\n        var max_value = 0\n        for(i <-\
    \ 0 until arr.length) {\n            val cur_value = arr(i)\n            if(cur_value\
    \ % 2 == 0 && cur_value <= max_value) {\n                max_index = i\n     \
    \           max_value = cur_value\n            }\n        }\n        val out_arr\
    \ = arr.filter(_ % 2 == 0).sortWith(_ < _).map(i => arr(i))\n        out_arr(max_index)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwx59hdqh.scala:37:28\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m                max_value = cur_value\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                            Found:    (cur_value : Long)\n\e[31m   |\e[0m \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpwx59hdqh.scala:40:74 --------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mout_arr\e[0m = arr.filter(_ %\
    \ \e[31m2\e[0m == \e[31m0\e[0m).sortWith(_ < _).map(\e[36mi\e[0m => arr(i))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                ^\e[0m\n\e[31m   |\e[0m                                     \
    \               Found:    (i : Long)\n\e[31m   |\e[0m                        \
    \                            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpwx59hdqh.scala:41:15 --------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m        out_arr(max_index)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: \e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010142
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val map = new mutable.HashMap[(Long,\
    \ Int), Long]\n        arr.foreach(x => map += ((x, map.getOrElse((x, -1), 0)\
    \ + 1))\n        )\n        val max = map.maxBy(_._2._2)\n        if (max._2._2\
    \ != 0) map.get((max._1, max._2))\n        else map.get(max._1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgu4rs2aq.scala:30:22 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[(\e[35mLong\e[0m, \e[35mInt\e[0m), \e[35mLong\e[0m]\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010135
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evenValues = arr.filter(i\
    \ => i % 2 == 0)\n        if(evenValues.isEmpty) return Nil\n        evenValues.minBy(i\
    \ => i)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphmrrip_1.scala:32:8\
    \ ---------------------\e[0m\e[0m\n\e[31m32 |\e[0m        evenValues.minBy(\e\
    [36mi\e[0m => i)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: \e[1m\e\
    [32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010142
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val s = arr.sortWith((a,\
    \ b) => math.abs(a - b))\n        s.takeWhile((x, i) => i % 2 == 0) // the second\
    \ arg is index\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpafzdvgcz.scala:30:47\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36ms\e\
    [0m = arr.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => math.abs(a - b))\n\e[31m\e\
    [31m   |\e[0m                                       ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                       Found:    Long\n\e[31m   |\e\
    [0m                                       Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E086] Syntax Error: /tmp/tmpafzdvgcz.scala:31:27 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        s.takeWhile((\e[36mx\e[0m, \e[36mi\e[0m) => i\
    \ % \e[31m2\e[0m == \e[31m0\e[0m) \e[34m// the second arg is index\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  Wrong number of parameters, expected: 1\n2 errors found\n"
  stdout: ''
  timestamp: 1660010147
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) List[Long]()\n\
    \        else if (arr.isEmpty) List[Long]()\n        else arr.sortWith(_ < _)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpddmc_myd.scala:35)\n\tat Problem.main(tmpddmc_myd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010154
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var ans = List[Long]()\n\
    \        var smallestValue = arr(0)\n        var smallestIndex = 0\n\n       \
    \ for (i <- arr.indices) {\n            if(smallestValue < arr(i)) {\n       \
    \         smallestValue = arr(i)\n                smallestIndex = i\n        \
    \    }\n        }\n\n        if (smallestValue == 0) ans = List(0)\n        else\
    \ ans = List(smallestValue, smallestIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb3vxixtw.scala:41:36\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mif\e[0m (smallestValue\
    \ == \e[31m0\e[0m) ans = List(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m           \
    \                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \            Found:    Unit\n\e[31m   |\e[0m                                Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb3vxixtw.scala:42:17\
    \ --------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33melse\e[0m ans =\
    \ List(smallestValue, smallestIndex)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    Unit\n\e[31m   |\e[0m             Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010153
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val arr = arr.toSet\n\
    \        val len = arr.size\n        var minIndex = 0\n        var minValue =\
    \ arr(0).toLong\n        var minArray = arr.toList\n        while (len > 0) {\n\
    \            val curValue = arr(len - 1).toLong\n            var index = len -\
    \ 1\n            while (index >= 0 && arr(index).toLong > curValue) {\n      \
    \          minArray = arr.drop(index).toList\n                index -= 1\n   \
    \         }\n            if (index < 0) {\n                minArray = arr.toList\n\
    \            }\n            if (arr(index).toLong < minValue || (arr(index).toLong\
    \ == minValue && index < minIndex)) {\n                minIndex = index\n    \
    \            minValue = arr(index).toLong\n            }\n            len -= 1\n\
    \        }\n        minArray\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzdeey0aj.scala:30:18 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toSet\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010144
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n      var min = Long.MaxValue\n\
    \      var index = 0\n      for(i <- 0 until arr.length){\n        val curr =\
    \ arr(i)\n        if(curr.toInt % 2 == 0){\n          min = Math.min(min, curr)\n\
    \          index = i\n        }\n      }\n      List(min, index)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9jorbydp.scala:44)\n\tat Problem.main(tmp9jorbydp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010158
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        arr.sortWith(_ < _)\n\
    \        val evenIndex = arr.indexOf(_ % 2 == 0)\n        if(evenIndex < arr.length)\
    \ arr.lift(evenIndex) else List().reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpylhzukee.scala:31:36 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevenIndex\e[0m = arr.indexOf(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \               ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$3 of expanded\
    \ function:\n\e[31m   |\e[0m   _$3 => _$3 % 2 == 0.\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpylhzukee.scala:32:43 --------------------\e[0m\e[0m\n\
    \e[31m32 |\e[0m        \e[33mif\e[0m(evenIndex < arr.length) arr.lift(evenIndex)\
    \ \e[33melse\e[0m List().reverse\n\e[31m\e[31m   |\e[0m                      \
    \             ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \             Found:    \e[1m\e[31mOption\e[0m[Long]\n\e[31m   |\e[0m        \
    \                           Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010153
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        arr.toList.sortBy(_.toLong).map(arr(_).toLong).distinct().toList.groupBy(_.toLong).map(_.min).flatMap(_.find(_.toLong\
    \ % 2 == 0)).map(x => List(x.toLong,arr.indexOf(x)).filterNot(_ == 0).map(x =>\
    \ (x.toLong, x)))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpap5xhniv.scala:30:44\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        arr.toList.sortBy(_.toLong).map(arr(_).toLong).distinct().toList.groupBy(_.toLong).map(_.min).flatMap(_.find(_.toLong\
    \ % \e[31m2\e[0m == \e[31m0\e[0m)).map(\e[36mx\e[0m => List(x.toLong,arr.indexOf(x)).filterNot(_\
    \ == \e[31m0\e[0m).map(\e[36mx\e[0m => (x.toLong, x)))\n\e[31m\e[31m   |\e[0m\
    \                                            ^\e[0m\n\e[31m   |\e[0m         \
    \                                   Found:    (_$2 : Long)\n\e[31m   |\e[0m  \
    \                                          Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010154
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) {\n\
    \            return []\n        }\n        var smalest_value : Long = -1L\n  \
    \      var index : Long = -1L\n        var ans : List[Long] = Nil\n        var\
    \ tmp : List[Long] = Nil\n        var index = 0\n        var value : Long = 0L\n\
    \        for (i <- 0 until arr.length) {\n            value = arr(i)\n       \
    \     if (value < smalest_value) {\n                smalest_value = value\n  \
    \              index = i\n            }\n            if (value == smalest_value)\
    \ {\n                tmp = arr.slice(i + 1)\n                if (index < tmp.length)\
    \ {\n                    index = tmp.length\n                }\n             \
    \   if (tmp(index) % 2 == 0) {\n                    ans = tmp.slice(1, index).toList\n\
    \                }\n            }\n        }\n        return ans\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4hsinj0b.scala:31:20 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mreturn\e[0m []\n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    an identifier\
    \ expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4hsinj0b.scala:32:8\
    \ ----------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        }\n\e[31m\e[31m\
    \   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        '=>' expected, but '}' found\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4hsinj0b.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mvar\e[0m \e[36mindex\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mindex is already\
    \ defined as \e[33mvariable\e[0m \e[35mindex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- Error: /tmp/tmp4hsinj0b.scala:46:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                tmp = arr.slice(i + \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing\
    \ argument for parameter until of \e[33mmethod\e[0m \e[35mslice\e[0m in \e[33mclass\e\
    [0m \e[35mList\e[0m: (from: Int, until: Int): List[Long]\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4hsinj0b.scala:50:24 --------------------\e[0m\e\
    [0m\n\e[31m50 |\e[0m                \e[33mif\e[0m (tmp(index) % \e[31m2\e[0m ==\
    \ \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Found:    (index : Long)\n\e[31m   |\e[0m\
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4hsinj0b.scala:51:39 --------------------\e[0m\e\
    [0m\n\e[31m51 |\e[0m                    ans = tmp.slice(\e[31m1\e[0m, index).toList\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                       Found:    (index : Long)\n\e\
    [31m   |\e[0m                                       Required: "
  stdout: ''
  timestamp: 1660010156
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val smalest_value :\
    \ Long  = arr.min\n        val index_of_smalest_value = arr.indexOf( smalest_value)\n\
    \        val smalest_value_with_index = smalest_value + index_of_smalest_value\n\
    \        arr.filter(_ % 2 == 0).filter(_ < smalest_value_with_index).map(_ + index_of_smalest_value)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8xogt68y.scala:36)\n\tat Problem.main(tmp8xogt68y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010159
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val result = mutable.ListBuffer.empty[Long]\n\
    \        arr.sortWith( (a,b) => a > b)\n        for ( (n, i) in arr.zipWithIndex.toList\
    \ ) if (n % 2 == 0) result.+= n\n        if (result.isEmpty) result else result.sortWith(\
    \ (a,b) => a < b)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpze3br5bj.scala:32:50 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mfor\e[0m ( (n, i) in arr.zipWithIndex.toList\
    \ ) \e[33mif\e[0m (n % \e[31m2\e[0m == \e[31m0\e[0m) result.+= n\n\e[31m\e[31m\
    \   |\e[0m                                                  ^^\e[0m\n\e[31m  \
    \ |\e[0m                                           '<-' expected, but 'if' found\n\
    \e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpze3br5bj.scala:33:35 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mif\e[0m (result.isEmpty) result \e[33melse\e\
    [0m result.sortWith( (\e[36ma\e[0m,\e[36mb\e[0m) => a < b)\n\e[31m\e[31m   |\e\
    [0m                                   ^^^^\e[0m\n\e[31m   |\e[0m             \
    \                      expression expected but \e[31melse\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpze3br5bj.scala:30:21 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpze3br5bj.scala:32:77 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mfor\e[0m ( (n, i) in arr.zipWithIndex.toList\
    \ ) \e[33mif\e[0m (n % \e[31m2\e[0m == \e[31m0\e[0m) result.+= n\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \          ^\e[0m\n\e[31m   |\e[0mvalue withFilter is not a member of Null, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m  import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions"
  stdout: ''
  timestamp: 1660010159
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var minVal = arr(0)\n\
    \        var minIndex = 0\n        var minIndexInner = 1\n\n        var index\
    \ = 0\n        var evenArray = arr.filter(_ % 2 == 0)\n\n        evenArray.foreach{\n\
    \            if(minVal > _){\n                minVal = _\n                minIndex\
    \ = index\n                minIndexInner = minIndexInner+1\n            }\n  \
    \      }\n\n        arr.filter(!evenArray.contains(_)).sortBy(_ % 2 == 0).take(minIndexInner).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpoa88fbx_.scala:38:24 -----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mif\e[0m(minVal > _){\n\e[31m\e[31m\
    \   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m   Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => minVal > _$2.\n\e[31m\e\
    [31m-- [E081] Type Error: /tmp/tmpoa88fbx_.scala:39:25 -----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                minVal = _\n\e[31m\e[31m   |\e[0m   \
    \                      ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$3\
    \ of expanded function:\n\e[31m   |\e[0m   _$3 => minVal = _$3.\n2 errors found\n"
  stdout: ''
  timestamp: 1660010151
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        def getSmallestIndex(nodes:\
    \ List[Long], index : Int) : List[Long] = {\n            if (nodes == null) null\n\
    \            else {\n                val smallestNode = nodes.head\n         \
    \       if (smallestNode % 2 == 0) smallestNode :: smallestIndex\n           \
    \     else smallestNode :: getSmallestIndex(nodes.tail, smallestIndex + 1)\n \
    \           }\n        }\n        val smallestIndex = -1\n        val smallestNode\
    \ = arr(0)\n        val res = (0 until arr.size).map { i => getSmallestIndex(arr,\
    \ i + 1) }\n        if (res.nonEmpty) {\n            val minIndex = res.minBy(_.size)\n\
    \            val pluckedValue = arr(minIndex.size)\n            res(minIndex)\
    \ match {\n                case null => null\n                case _ => (pluckedValue,\
    \ minIndex.size)\n            }\n        }\n        else {\n            null\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkvdfalqm.scala:34:56 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                \e[33mif\e[0m (smallestNode % \e[31m2\e\
    [0m == \e[31m0\e[0m) smallestNode :: smallestIndex\n\e[31m\e[31m   |\e[0m    \
    \                                                    ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                         value :: is not a member\
    \ of Int\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkvdfalqm.scala:44:16\
    \ --------------------\e[0m\e[0m\n\e[31m44 |\e[0m            res(minIndex) \e\
    [33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                Found:    (minIndex : List[Long])\n\e[31m   |\e[0m  \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpkvdfalqm.scala:46:26 --------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m                \e[33mcase\e[0m _ => (pluckedValue, minIndex.size)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Found:    (Long, Int)\n\e[31m   |\e[0m\
    \                          Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010159
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        def pickEvenIndex(i:\
    \ Int): Int = if (arr(i) %2 == 0) i else i + 2\n        val evenList = arr.filter(i\
    \ => i % 2 == 0).sortWith(_ < _)\n        evenList.toList.map(pickEvenIndex)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp31gcz5ep.scala:32:28\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        evenList.toList.map(pickEvenIndex)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                            Found:    \e[1m\e[31mInt\e[0m => Long\n\e\
    [31m   |\e[0m                            Required: \e[1m\e[32mLong\e[0m => Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010156
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n       val res = arr.groupBy(x\
    \ => (x%2 ==0)).mapValues(_.sortBy(x => x)).toList\n       res.sortBy(x=>x._2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpaz04xkdx.scala:31:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m       res.sortBy(\e[36mx\e[0m=>x._2)\n\e[31m\e[31m \
    \  |\e[0m                          ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for List[Long]..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m    scala.math.Ordering.comparatorToOrdering[\e[35mList[Long]\e[0m](\n\
    \e[31m   |\e[0m      /* missing */summon[java.util.Comparator[List[Long]]]\n\e\
    [31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[List[Long]].\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mThe following import might fix the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\e[31m   |\e[0m\n1\
    \ error found\n"
  stdout: ''
  timestamp: 1660010159
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        if (evens.isEmpty) return emptyList[Long]\n \
    \       evens.headOption.map { x => arr.indexOf(x.toLong, arr.indexOf(x.toLong)\
    \ + 1) }.getOrElse(arr.indexOf(evens.head.toLong))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4hvpma15.scala:31:34 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mif\e[0m (evens.isEmpty) \e[33mreturn\e\
    [0m emptyList[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                        \
    \          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                  Not\
    \ found: emptyList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4hvpma15.scala:32:96\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        evens.headOption.map\
    \ { \e[36mx\e[0m => arr.indexOf(x.toLong, arr.indexOf(x.toLong) + \e[31m1\e[0m)\
    \ }.getOrElse(arr.indexOf(evens.head.toLong))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Int\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010160
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var index = 0;\n  \
    \      var smallest = arr(0) match {\n            case _ if arr(0) % 2 == 0 =>\
    \ 1\n            case _ if arr(0) % 2 == 1 => 2\n            case _ => 0\n   \
    \     }\n        var result: mutable.List[Long] = mutable.List();\n        var\
    \ index = arr(0)\n        for (x <- arr) {\n            if (x % 2 == 0) {\n  \
    \              if (smallest == 0) {\n                    smallest = 1;\n     \
    \           }\n                if (x < smallest) {\n                    smallest\
    \ = x;\n                    index = 0;\n                }\n            }\n   \
    \         if (x % 2 == 1) {\n                if (smallest == 1) {\n          \
    \          smallest = 2;\n                }\n                if (x < smallest)\
    \ {\n                    smallest = x;\n                    index = 1;\n     \
    \           }\n            }\n        }\n        if (smallest == 0) {\n      \
    \      result = mutable.List();\n        } else {\n            result = mutable.List(smallest,\
    \ index);\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv5lqpm84.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mvar\e[0m \e[36mindex\e[0m = arr(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mindex\
    \ is already defined as \e[33mvariable\e[0m \e[35mindex\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv5lqpm84.scala:36:20\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mvar\e[0m \e\
    [36mresult\e[0m: mutable.List[\e[35mLong\e[0m] = mutable.List();\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv5lqpm84.scala:36:41\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mvar\e[0m \e\
    [36mresult\e[0m: mutable.List[\e[35mLong\e[0m] = mutable.List();\n\e[31m\e[31m\
    \   |\e[0m                                         ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                         Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv5lqpm84.scala:44:31 --------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                    smallest = x;\n\e[31m\e[31m   |\e\
    [0m                               ^\e[0m\n\e[31m   |\e[0m                    \
    \           Found:    (x : Long)\n\e[31m   |\e[0m                            \
    \   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv5lqpm84.scala:53:31\
    \ --------------------\e[0m\e[0m\n\e[31m53 |\e[0m                    smallest\
    \ = x;\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e\
    [0m                               Found:    (x : Long)\n\e[31m   |\e[0m      \
    \                         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[3"
  stdout: ''
  timestamp: 1660010162
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val ans = mutable.Buffer[Long]()\n\
    \        val index = 0\n\n        for(x <- arr) {\n            if(x.toInt % 2\
    \ == 0) {\n                ans += x\n            }\n        }\n        ans.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdmau2sy7.scala:30:18 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mans\e[0m = mutable.Buffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010155
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val even = arr.filter(i\
    \ => i % 2 == 0).sortWith(_ < _)\n        val zero = arr.filter(i => i % 2 ==\
    \ 0).sortWith(_ < _).head\n        even.find(i => i % 2 == 0).map(i => (i, even.indexWhere(_\
    \ == i))).toList match {\n            case Nil => zero\n            case List(i\
    \ @ _, _) => i\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprlnm83zb.scala:33:24\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mcase\e[0m Nil\
    \ => zero\n\e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\e[31m   |\e\
    [0m                        Found:    (zero : Long)\n\e[31m   |\e[0m          \
    \              Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmprlnm83zb.scala:34:35 --------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m            \e[33mcase\e[0m List(i @ _, _) => i\n\e[31m\e[31m   |\e[0m\
    \                                   ^\e[0m\n\e[31m   |\e[0m                  \
    \                 Found:    (i : (Long, Int))\n\e[31m   |\e[0m               \
    \                    Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010164
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var ans = List[Long]()\n\
    \        var node = 0\n        var minVal = arr(0)\n        var minIndex = 0\n\
    \        for (i<- 0 until arr.length) {\n            if (arr(i) % 2 == 0) {\n\
    \                if (arr(i) < minVal) {\n                    minVal = arr(i)\n\
    \                    minIndex = i\n                }\n            }\n        }\n\
    \        ans += minVal\n        ans += minIndex\n        return ans\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvzjhi98l.scala:42:12 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        ans += minVal\n\e[31m\e[31m   |\e[0m        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m    value += is not a member of List[Long] - did you mean\
    \ List[Long].!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvzjhi98l.scala:43:12\
    \ ------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        ans += minIndex\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a\
    \ member of List[Long] - did you mean List[Long].!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010163
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val m = arr.takeWhile(_\
    \ % 2 == 0).sortBy(_ % 2).head\n        if (m.isEven) {\n            arr.map {\
    \ n => n }.takeWhile(_ > m).takeWhile(n => n % 2 == 0).sortBy(_ % 2).head\n  \
    \      } else {\n            arr.map { n => n }.takeWhile(_ >= m).takeWhile(n\
    \ => n % 2 == 0).sortBy(_ % 2).head\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpchcohkuy.scala:31:14 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mif\e[0m (m.isEven) {\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value isEven is not a\
    \ member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpchcohkuy.scala:32:89\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            arr.map { \e[36mn\e\
    [0m => n }.takeWhile(_ > m).takeWhile(\e[36mn\e[0m => n % \e[31m2\e[0m == \e[31m0\e\
    [0m).sortBy(_ % \e[31m2\e[0m).head\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    Long\n\e[31m   |\e[0m            Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpchcohkuy.scala:34:90 --------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            arr.map { \e[36mn\e[0m => n }.takeWhile(_\
    \ >= m).takeWhile(\e[36mn\e[0m => n % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_ %\
    \ \e[31m2\e[0m).head\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    Long\n\e[31m   |\e[0m            Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010164
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var nodes : List[Long]\
    \ = Nil\n        var minIndex : Long = 0\n        var minVal : Long = 0l\n   \
    \     var minEven : Boolean = false\n        for(i <- 0 until arr.length) {\n\
    \            if(arr(i) %2 == 0) {\n                if(minEven) {\n           \
    \         minVal = arr(i)\n                    minIndex = i\n                \
    \    minEven = false\n                }\n                else {\n            \
    \        minEven = true\n                }\n            }\n            else {\n\
    \                if(minEven) {\n                    minVal = arr(i)\n        \
    \            minIndex = i\n                    minEven = false\n             \
    \   }\n                else {\n                    minEven = true\n          \
    \      }\n            }\n        }\n        if(minEven) {\n            nodes =\
    \ arr.toList\n        }\n        else {\n            nodes = arr.sortWith(_.compareTo(_)\
    \ < 0).toList\n        }\n        nodes.head\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp382fb8re.scala:62:14\
    \ --------------------\e[0m\e[0m\n\e[31m62 |\e[0m        nodes.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\e\
    [31m   |\e[0m        Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e\
    [32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010163
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0){\n\
    \            return []\n        }\n        var min_value : Long = arr.head\n \
    \       var min_index : int = 1\n        var index_set = List[Int]()\n       \
    \ for (i <- 0 until arr.length){\n            if (arr(i) % 2 == 0){\n        \
    \        if (arr(i) < min_value){\n                    min_value = arr(i)\n  \
    \                  min_index = i\n                    index_set = []\n       \
    \         }\n            }\n            index_set ::= i\n        }\n        var\
    \ new_list = []\n        for (i <- 0 until index_set.length){\n            new_list\
    \ ::= (min_value, min_index + i - 1)\n        }\n        if (index_set.length\
    \ == 0){\n            new_list = []\n        }\n        new_list\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiz7hfba3.scala:31:20 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mreturn\e[0m []\n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    an identifier\
    \ expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiz7hfba3.scala:32:8\
    \ ----------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        }\n\e[31m\e[31m\
    \   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        '=>' expected, but '}' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiz7hfba3.scala:41:33 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                    index_set = []\n\e[31m\e[31m   |\e\
    [0m                                 ^\e[0m\n\e[31m   |\e[0m                  \
    \               an identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpiz7hfba3.scala:42:16 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m                }\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e\
    [31m   |\e[0m                '=>' expected, but '}' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpiz7hfba3.scala:46:24 ---------------------------\e[0m\e\
    [0m\n\e[31m46 |\e[0m        \e[33mvar\e[0m \e[36mnew_list\e[0m = []\n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       an identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpiz7hfba3.scala:47:0 ----------------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m until index_set.length){\n\e\
    [31m\e[31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m'=>' expected, but 'end of statement'\
    \ found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiz7hfba3.scala:51:24 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m            new_list = []\n\e[31m\e[31m   |\e[0m    \
    \                    ^\e[0m\n\e[31m   |\e[0m                        an identifier\
    \ expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiz7hfba3.scala:52:8\
    \ ----------------------------\e[0m\e[0m\n\e[31m52 |\e[0m        }\n\e[31m\e[31m\
    \   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        '=>' expected, but '}' found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiz7hfba3.scala:34:24 --"
  stdout: ''
  timestamp: 1660010164
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val n = arr.length\n\
    \        if (n == 0) List()\n        if (n % 2 == 1) arr(n)\n        else {\n\
    \            var min = arr(n/2).toLong\n            var min_index = 0\n      \
    \      for (i <- n / 2 + 1 until n) {\n                if (arr(i) %2 == 0) {\n\
    \                    if (min > arr(i))\n                        min = arr(i)\n\
    \                    min_index = i\n                }\n            }\n       \
    \     List((min.toLong, min_index))\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpggn8ldre.scala:32:27\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mif\e[0m (n % \e\
    [31m2\e[0m == \e[31m1\e[0m) arr(n)\n\e[31m\e[31m   |\e[0m                    \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m                        Found:    Long\n\e[31m\
    \   |\e[0m                        Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e\
    [0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpggn8ldre.scala:43:17 --------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m            List((min.toLong, min_index))\n\e[31m\e[31m   |\e[0m     \
    \            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:\
    \    \e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e\
    [1m\e[31m)\e[0m\n\e[31m   |\e[0m                 Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010165
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Write your code\
    \ here\n        def swap(a : Long, b : Long) : Unit = {\n            val t = a\n\
    \            a = b\n            b = t\n        }\n        val min_val = arr(0)\n\
    \        val min_idx = 1\n        for( i <- 0 until arr.length ) {\n         \
    \   if(arr(i) % 2 == 0) {\n                swap(arr(i), min_val)\n           \
    \     swap(min_idx, i)\n            }\n        }\n        List(min_val, min_idx)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpgduovxzy.scala:33:14 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            a = b\n\e[31m\e[31m   |\e[0m            ^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val a\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpgduovxzy.scala:34:14 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            b = t\n\e[31m\e[31m   |\e[0m            ^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val b\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010162
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var m = arr.sortBy(-_)\n\
    \        val l = (m.length >>> 1).toInt\n        val k = (m.length / l).toInt\n\
    \        m.take(l).zipWithIndex.foldLeft(List[Long]()) { (acc, el) =>\n      \
    \      if (el._2 % 2 == 0) {\n                acc.reverse.push(el._1)\n      \
    \      } else {\n                acc.reverse.push(el._1)\n                acc.reverse.push(el._2)\n\
    \            }\n        }.map(_.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp71uut7o_.scala:35:28 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                acc.reverse.push(el._1)\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue push is\
    \ not a member of List[Long] - did you mean List[Long].last?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp71uut7o_.scala:37:28 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m                acc.reverse.push(el._1)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue push is not a member\
    \ of List[Long] - did you mean List[Long].last?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp71uut7o_.scala:38:28 ------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m                acc.reverse.push(el._2)\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue push is not a member of\
    \ List[Long] - did you mean List[Long].last?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evenValues = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smallestIndex = arr.indexOfMax( x => x %\
    \ 2 == 0)\n        val smalestValue = evenValues.min\n        val newArr: List[Long]\
    \ = arr.filterNot(x => x % 2 == 0).filter(x => x % 2 == 0)\n        newArr\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpluniqihn.scala:31:32 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmallestIndex\e[0m = arr.indexOfMax(\
    \ \e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue indexOfMax\
    \ is not a member of List[Long] - did you mean arr.indexOf?\n1 error found\n"
  stdout: ''
  timestamp: 1660010173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val arr = arr.sorted\n\
    \        val evens = arr.filter(_%2 == 0).sortBy(-_)\n        if(evens.length\
    \ == 0 || arr.length == 0)\n            List()\n        else\n            evens.head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpav4jx44t.scala:30:18 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sorted\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010167
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val map = mutable.TreeMap[Long,\
    \ Int]()\n        var index = 0\n        var smallest = 0L\n        arr.foreach(l\
    \ => {\n            if(map.contains(l)) {\n                smallest = map.get(l).getOrElse(0L)\n\
    \            } else {\n                map.put(l, index+1)\n            }\n  \
    \          index += 1\n        })\n        if(map.isEmpty) return List()\n   \
    \     val keys = map.keys.sorted\n        if(keys.isEmpty) List()\n        else\
    \ {\n            val indexMap = keys.zipWithIndex\n            val smalest = keys.get(keys.indexOf((smallest+1).toInt)).getOrElse(smallest+1).toInt\n\
    \            val smalestValue = keys.get(keys.indexOf(smalest)).getOrElse(smalest).toLong\n\
    \            return List(smalestValue.toLong, indexMap.get(smalest).getOrElse(0).toInt)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp44pwexmp.scala:30:18 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = mutable.TreeMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010169
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) List()\n\
    \        val map = arr.toSet.toList\n        val sorted = arr.sortWith((a, b)\
    \ => a.toLong > b.toLong)\n        val even = sorted.filter(_%2 == 0).takeWhile(_\
    \ <= sorted.last.toLong).toList\n        val idx = sorted.toList.zipWithIndex.find(t\
    \ => t._2 == even(0)).getOrElse(sorted.last)\n        List(sorted.last, idx)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnxvnqb47.scala:35:26\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        List(sorted.last, idx)\n\
    \e[31m\e[31m   |\e[0m                          ^^^\e[0m\n\e[31m   |\e[0m     \
    \                     Found:    (idx : Matchable)\n\e[31m   |\e[0m           \
    \               Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var minValue = arr.sortWith(_\
    \ < _).head\n        var minIndex = 0\n        var evenIndex = 0\n        var\
    \ evenMax = 0\n        var minIndex = 0\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) % 2 == 0){\n                if (evenIndex < evenMax)\
    \ {\n                    minValue = arr(i)\n                    minIndex = i\n\
    \                    evenIndex = 0\n                    evenMax = 0\n        \
    \        }\n                else {\n                    evenIndex += 1\n     \
    \               evenMax = evenIndex\n                }\n            }\n      \
    \  }\n        if (evenIndex == 0){\n            return Nil\n        }\n      \
    \  else {\n            return List(minValue, minIndex)\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn6r3um7t.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mvar\e[0m \e[36mminIndex\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mminIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1660010171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var even_values = mutable.ArrayBuffer.empty[Long]\n\
    \        var even_index = mutable.ArrayBuffer.empty[Long]\n        var lowest_index\
    \ = mutable.ArrayBuffer.empty[Long]\n\n        var i = 0\n        for(i <- 0 until\
    \ arr.length) {\n            if (arr(i) % 2 == 0) {\n                even_values\
    \ += arr(i)\n                even_index += i\n            } else if (even_values.nonEmpty\
    \ && even_values.last == arr(i)) {\n                lowest_index += (even_index.last\
    \ + 1)\n            } else if (even_values.nonEmpty && even_values.last != arr(i))\
    \ {\n                lowest_index += (even_index.last + 1)\n                even_index\
    \ += (even_index.last + 1)\n                even_values += arr(i)\n          \
    \  } else {\n                even_values += arr(i)\n                even_index\
    \ += i\n            }\n        }\n        even_values.toList.sortWith(_ < _)\n\
    \        even_index.toList.sortWith(_ < _)\n        if (even_values.nonEmpty)\
    \ {\n            even_values.last\n        } else {\n            0\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvshzk2n2.scala:30:26 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mvar\e[0m \e[36meven_values\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpvshzk2n2.scala:31:25 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m \e[36meven_index\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpvshzk2n2.scala:32:27 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m \e[36mlowest_index\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvshzk2n2.scala:55:12 --------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m            \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m     \
    \       ^\e[0m\n\e[31m   |\e[0m            Found:    (\e[31m0\e[0m : Int)\n\e\
    [31m   |\e[0m            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        def minIndex( node\
    \ : Long ): Int = {\n            // find the smallest even number and its index\
    \ from arr\n            val minValue = min(arr(0 until arr.length).filter(x =>\
    \ x % 2 ==  0 ))\n            val index = arr.indexOf(minValue)\n            if(\
    \ index == arr.length - 1 )\n                -1\n            else\n          \
    \      index\n        }\n\n        arr.head :: minIndex(arr.head) ++ arr.tail.filter(x\
    \ => x % 2 ==  0 )\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4vyhoysm.scala:32:35\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e\
    [36mminValue\e[0m = min(arr(\e[31m0\e[0m until arr.length).filter(\e[36mx\e[0m\
    \ => x % \e[31m2\e[0m ==  \e[31m0\e[0m ))\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                     Found:    Range\n\e[31m   |\e[0m                       \
    \            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp4vyhoysm.scala:40:39 ------------------------\e[0m\e[0m\n\e[31m40 |\e\
    [0m        arr.head :: minIndex(arr.head) ++ arr.tail.filter(\e[36mx\e[0m => x\
    \ % \e[31m2\e[0m ==  \e[31m0\e[0m )\n\e[31m\e[31m   |\e[0m                   \
    \ ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    value ++ is not\
    \ a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if(arr.isEmpty || arr.size\
    \ <= 0) {\n            return arr\n        }\n        // Sort list\n        val\
    \ sortedArr = arr.toArray.sortWith((x,y) => x.toLong == y.toLong)\n        //\
    \ Get minimum even value\n        var minEven = sortedArr(0)\n        // If there\
    \ are multiple values, then get the smallest index\n        var minIndex = -1\n\
    \        var i = 0\n        while(i < sortedArr.length) {\n            if(sortedArr(i)\
    \ % 2 == 0) {\n                if(minEven.compareToDouble(sortedArr(i)) < 0.0)\
    \ {\n                    minEven = sortedArr(i)\n                    minIndex\
    \ = i\n                }\n                i += 1\n            } else {\n     \
    \           i += 1\n            }\n        }\n        // Create result list\n\
    \        val resultArr: List[Long] = Array(minEven.toLong, minIndex)\n       \
    \ // Return result\n        return resultArr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0z5ma78h.scala:42:27 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                \e[33mif\e[0m(minEven.compareToDouble(sortedArr(i))\
    \ < \e[31m0.0\e[0m) {\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   value compareToDouble is not a member of\
    \ Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0z5ma78h.scala:52:41\
    \ --------------------\e[0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mresultArr\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = Array(minEven.toLong, minIndex)\n\e[31m\e\
    [31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Found:    \e[1m\e[31mArray\e\
    [0m[Long]\n\e[31m   |\e[0m                                    Required: \e[1m\e\
    [32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010179
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val smalest_value =\
    \ 0\n        val smalest_index = 0\n        for (i <- 0 until arr.size) {\n  \
    \          if (arr(i) % 2 == 0) {\n                if (smalest_value < arr(i))\
    \ {\n                    smalest_value = arr(i)\n                    smalest_index\
    \ = i\n                }\n            }\n        }\n        if (smalest_value\
    \ == 0) {\n            return Nil\n        }\n        smalest_index match {\n\
    \            case 0 => List(smalest_value)\n            case _ => List(smalest_value,\
    \ smalest_index)\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2bug2768.scala:35:39\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m                    smalest_value\
    \ = arr(i)\n\e[31m\e[31m   |\e[0m                                    ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Found:    Long\n\e[31m\
    \   |\e[0m                                    Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp2bug2768.scala:36:34 -----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    smalest_index = i\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Reassignment to val smalest_index\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010178
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        def pickEven(arr :\
    \ List[Long], pick : List[Long]) : List[Long] = {\n            if(arr.isEmpty)\
    \ {\n                return pick\n            }\n            var curr : Long =\
    \ 0\n            val indexes = mutable.ListBuffer.empty[Int]\n            for(i\
    \ <- 0 until arr.length) {\n                if(arr(i) % 2 == 0) {\n          \
    \          curr = arr(i)\n                    indexes.add(i)\n               \
    \ }\n            }\n            if(indexes.isEmpty) {\n                return\
    \ pickEven(arr, pick)\n            }\n            val min = indexes(0)\n     \
    \       val minIndex = indexes(0)\n            var i = 0\n            for(i <-\
    \ 0 until arr.length) {\n                if(arr(i) == min) {\n               \
    \     if(i < minIndex) {\n                        minIndex = i\n             \
    \       }\n                }\n            }\n            val picked = pickEven(arr.drop(minIndex),\
    \ pick)\n            if(minIndex == picked.length) {\n                return picked\n\
    \            }\n            picked ++ pickEven(arr.take(minIndex), pick)\n   \
    \     }\n        pickEven(arr, List.empty[Long])\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9m3zesx3.scala:35:26 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mindexes\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp9m3zesx3.scala:51:33 -----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                        minIndex = i\n\e[31m\e[31m  \
    \ |\e[0m                        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Reassignment to val minIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010175
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Write your code\
    \ here\n        if(arr.isEmpty || arr.length < 1){\n            return arr.toList\n\
    \        }\n        var index = 0\n        var min_even = 0\n        var min_index\
    \ = 0\n        for(a <- arr){\n            if(a%2 == 0){\n                min_even\
    \ = a\n                min_index = a\n            }\n        }\n        for(a\
    \ <- arr){\n            if(a%2 != 0 && a < min_even){\n                min_even\
    \ = a\n                min_index = a\n            }\n        }\n        return\
    \ Array[Long](min_even.toLong, min_index).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyebqej8l.scala:39:27\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m                min_even = a\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Found:    (a : Long)\n\e[31m   |\e[0m                  \
    \         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyebqej8l.scala:40:28\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m                min_index = a\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       Found:    (a : Long)\n\e[31m   |\e[0m                \
    \            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpyebqej8l.scala:45:27 --------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m                min_even = a\n\e[31m\e[31m   |\e[0m                  \
    \         ^\e[0m\n\e[31m   |\e[0m                           Found:    (a : Long)\n\
    \e[31m   |\e[0m                           Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpyebqej8l.scala:46:28 --------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                min_index = a\n\e[31m\e[31m   |\e[0m\
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \   Found:    (a : Long)\n\e[31m   |\e[0m                            Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010183
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n      var list = new mutable.MutableList[Long]()\n\
    \      var index = 0\n      var smalest_value = arr(0).toLong\n      var new_array\
    \ = new List[Long]()\n      for(i <- 0 until arr.length) {\n        val value\
    \ = arr(i)\n        if(value.toLong == smalest_value) {\n          index += 1\n\
    \          if(index == arr.length) {\n            list.+= new_array\n        \
    \    break\n          }\n        } else {\n          index = 0\n          smalest_value\
    \ = value.toLong\n          new_array += arr(i)\n        }\n      }\n      if(arr.isEmpty)\
    \ {\n        list.+=(new_array)\n      }\n      list\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp362pt8a5.scala:30:21 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m      \e[33mvar\e[0m \e[36mlist\e[0m = \e[33mnew\e[0m\
    \ mutable.MutableList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp362pt8a5.scala:45:20\
    \ ------------------------\e[0m\e[0m\n\e[31m45 |\e[0m          new_array += arr(i)\n\
    \e[31m\e[31m   |\e[0m          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value +=\
    \ is not a member of List[Long] - did you mean List[Long].!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010181
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var minIndex = 0\n\
    \        var maxIndex = 0\n        var minVal = arr(0)\n        var maxVal = arr(0)\n\
    \        var evenCount = 1\n        var index = 0\n        for ((i, _, _) <- arr.zipWithIndex)\
    \ {\n            if (i % 2 != 0) {\n                if (minVal > arr(i)) {\n \
    \                   minVal = arr(i)\n                    minIndex = i\n      \
    \          }\n            }\n            else if (i % 2 == 0) {\n            \
    \    if (minVal > arr(i)) {\n                    minVal = arr(i)\n           \
    \         minIndex = i\n                }\n                else {\n          \
    \          if (maxVal < arr(i)) {\n                        maxVal = arr(i)\n \
    \                       maxIndex = i\n                    }\n                }\n\
    \                evenCount += 1\n            }\n        }\n        if (evenCount\
    \ == 0) {\n            List[Long]()\n        }\n        else if (evenCount ==\
    \ arr.length) {\n            List[Long](maxVal, maxIndex)\n        }\n       \
    \ else {\n            List[Long](minVal, minIndex)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq9x_m22t.scala:37:18 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mif\e[0m (i % \e[31m2\e[0m != \e[31m0\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0mvalue %\
    \ is not a member of Any, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq9x_m22t.scala:38:33\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m                \e[33mif\e[0m\
    \ (minVal > arr(i)) {\n\e[31m\e[31m   |\e[0m                                 ^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    (i : Any)\n\e[31m\
    \   |\e[0m                                 Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq9x_m22t.scala:39:33 --------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    minVal = arr(i)\n\e[31m\e[31m   |\e\
    [0m                                 ^\e[0m\n\e[31m   |\e[0m                  \
    \               Found:    (i : Any)\n\e[31m   |\e[0m                         \
    \        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq9x_m22t.scala:40:31\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m                    minIndex\
    \ = i\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e\
    [0m                               Found:    (i : Any)\n\e[31m   |\e[0m       \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpq9x_m22t.scala:43:23 ------------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (i % \e[31m2\e[0m\
    \ == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m\
    \   |\e[0mvalue % is not a member of Any, but could be made "
  stdout: ''
  timestamp: 1660010187
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val even = arr.filter(v\
    \ => v % 2 == 0).toList\n        val min = even.min(implicitly[Ordering[Long]]).asInstanceOf[Long]\n\
    \        even.filter( v => v == min)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_4dzu97v.scala:35)\n\tat Problem.main(tmp_4dzu97v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010187
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evensMap = arr.groupBy(_\
    \ % 2 == 0).mapValues(_.length).toMap\n        val smallestIndexValue = arr.minBy(_\
    \ % 2 == 0)._2\n        val index = arr.indexOf(smallestIndexValue)\n        val\
    \ evensValues = evensMap.values\n        if(index < evensValues.size)\n      \
    \      evensMap.get(smallestIndexValue)\n        else\n            evensValues.take(index).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprh9e0xel.scala:31:55 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmallestIndexValue\e[0m\
    \ = arr.minBy(_ % \e[31m2\e[0m == \e[31m0\e[0m)._2\n\e[31m\e[31m   |\e[0m    \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                value _2 is not a member of Long\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmprh9e0xel.scala:35:24 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            evensMap.get(smallestIndexValue)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            Found:    Option[Int]\n\e[31m   |\e[0m            Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprh9e0xel.scala:37:36\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            evensValues.take(index).reverse\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue reverse is not a member of Iterable[Int] - did you mean Iterable[Int].reversed?\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010186
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Your code here\n\
    \        if(arr.isEmpty) {\n            throw new IllegalArgumentException(\"\
    Not found\")\n        }\n        var min = 0L\n        var max = 0L\n        var\
    \ index = 0\n        var indexMin = 0\n        var indexMax = 0\n        var i\
    \ = 0\n        var flag = false\n        while(i < arr.length) {\n           \
    \ index = arr(i)\n            if(flag) {\n                max = 0L\n         \
    \       min = index\n                indexMax = 0\n                indexMin =\
    \ 0\n                flag = false\n            }\n            if(index < min)\
    \ {\n                min = index\n            }\n            if(index > max) {\n\
    \                max = index\n            }\n            i += 1\n        }\n \
    \       if(min == max) {\n            return List()\n        }\n        var tempArr\
    \ = [min.toLong, min.toInt]\n        while(i < arr.length) {\n            index\
    \ = arr(i)\n            if(index < min) {\n                tempArr += index.toLong\n\
    \                index += index.toInt\n                flag = true\n         \
    \   }\n            i += 1\n        }\n        while(i < arr.length) {\n      \
    \      index = arr(i)\n            if(index > max) {\n                tempArr\
    \ += index.toLong\n                index += index.toInt\n                flag\
    \ = true\n            }\n            i += 1\n        }\n        return tempArr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpry45ezim.scala:61:26 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mvar\e[0m \e[36mtempArr\e[0m = [min.toLong,\
    \ min.toInt]\n\e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m  \
    \ |\e[0m                          ']' expected, but '.' found\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmpry45ezim.scala:62:0 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mwhile\e[0m(i < arr.length) {\n\e[31m\e\
    [31m   |\e[0m^^^^^\e[0m\n\e[31m   |\e[0m'=>' expected, but 'end of statement'\
    \ found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpry45ezim.scala:42:23\
    \ --------------------\e[0m\e[0m\n\e[31m42 |\e[0m            index = arr(i)\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \          Found:    Long\n\e[31m   |\e[0m                    Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpry45ezim.scala:63:23\
    \ --------------------\e[0m\e[0m\n\e[31m63 |\e[0m            index = arr(i)\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \          Found:    Long\n\e[31m   |\e[0m                    Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpry45ezim.scala:65:24\
    \ ------------------------\e[0m\e[0m\n\e[31m65 |\e[0m                tempArr +=\
    \ index.toLong\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue += is not a member of Null, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.set\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions"
  stdout: ''
  timestamp: 1660010190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val sorted = arr.toList.sortBy(_.toLong).reverse\n\
    \        sorted.foldLeft[List[Long]](List[Long]()){ (acc, x) => \n           \
    \ var index = 0\n            while (index < acc.length && x % 2 == 0) index +=\
    \ 2\n            val v = acc.toList.take(index)\n            val result = if (acc.length\
    \ == 0 || v.length < v(0).toLong) v else v(0)\n            (acc.length -> result)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvra2s3i3.scala:36:13\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            (acc.length -> result)\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \            Found:    (Int, Matchable)\n\e[31m   |\e[0m             Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010185
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        arr.sortWith((x, y)\
    \ => x % 2 == y % 2)\n        arr.filter(_ % 2 == 0).takeWhile(_ < arr.head).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp57znvh9k.scala:34)\n\tat Problem.main(tmp57znvh9k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var ans = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        var ans_idx = scala.collection.mutable.ListBuffer.empty[Int]\n      \
    \  var evens : Set[Long] = scala.collection.mutable.Set[Long]()\n        arr.foreach(x\
    \ => {\n            val i = arr.indexOf(x)\n            if (i % 2 == 0) evens.add(x)\n\
    \            ans += x\n            ans_idx += i\n        })\n        if (ans.isEmpty)\
    \ ans\n        else {\n            val smallers = evens.toList\n            val\
    \ small = smallers.head\n            smallers.foreach(x => ans.remove(x))\n  \
    \          ans += small\n            ans_idx.push(evens.index(small))\n      \
    \  }\n        ans :: ans_idx\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp35fega02.scala:43:45\
    \ --------------------\e[0m\e[0m\n\e[31m43 |\e[0m            smallers.foreach(\e\
    [36mx\e[0m => ans.remove(x))\n\e[31m\e[31m   |\e[0m                          \
    \                   ^\e[0m\n\e[31m   |\e[0m                                  \
    \           Found:    (x : Long)\n\e[31m   |\e[0m                            \
    \                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp35fega02.scala:45:20 ------------------------\e[0m\e[0m\n\e[31m45 |\e\
    [0m            ans_idx.push(evens.index(small))\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue push is not a member of scala.collection.mutable.ListBuffer[Int]\
    \ - did you mean scala.collection.mutable.ListBuffer[Int].last?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp35fega02.scala:45:31 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            ans_idx.push(evens.index(small))\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue index\
    \ is not a member of collection.mutable.Set[Long] - did you mean collection.mutable.Set[Long].find?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp35fega02.scala:47:12 ------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        ans :: ans_idx\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue :: is not a member of scala.collection.mutable.ListBuffer[Int]\
    \ - did you mean scala.collection.mutable.ListBuffer[Int].+:?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        arr.foldLeft((List[Long](0l,\
    \ -1l), 0l)) {\n          case ((acc, index), value) =>\n            if (value\
    \ % 2 == 0)\n              (List(value, index), acc + 1)\n            else\n \
    \             (acc, index)\n        }._1.filter(_ > 0)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4oehoeiz.scala:33:39 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m              (List(value, index), acc + \e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660010189
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Write your code\
    \ here\n        if(arr.isEmpty) {\n            return Array[Long]()\n        }\n\
    \n        val odd = arr.filter(_%2 == 0).toList\n        val smallestEven = odd.sortWith(_\
    \ < _) match {\n            case Nil => smallestEven\n            case head ::\
    \ tail => head\n        }\n\n        if(smallestEven.isEmpty) {\n            return\
    \ Array[Long]()\n        }\n        val index = smallestEven.indexOf(0)\n    \
    \    if(index < smallestEven.size){\n            return Array(smallestEven(0).toLong,\
    \ index.toLong)\n        }else{\n            return Array[Long]()\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpygxn8s4o.scala:32:19\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mreturn\e[0m\
    \ Array[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    \e[1m\e[31mArray\e[0m[Long]\n\
    \e[31m   |\e[0m                   Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpygxn8s4o.scala:37:24 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mcase\e[0m Nil => smallestEven\n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       Recursive \e[33mvalue\e[0m \e[35msmallestEven\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpygxn8s4o.scala:42:19 --------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mreturn\e[0m Array[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                 Found:    \e[1m\e[31mArray\e[0m[Long]\n\e[31m   |\e[0m     \
    \              Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpygxn8s4o.scala:48:19 --------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m            \e[33mreturn\e[0m Array[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                 Found:    \e[1m\e[31mArray\e[0m[Long]\n\e[31m   |\e[0m     \
    \              Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010189
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) List();\n\
    \        else {\n            var smallest_even_value = 0;\n            var smallest_index\
    \ = 0;\n            for (val n <- arr) {\n                if (n.toInt%2==0) {\n\
    \                    if (smallest_even_value==0) smallest_even_value = n; else\
    \ smallest_index = n;\n                }\n            }\n            if (smallest_even_value==0)\
    \ List();\n            else List(smallest_even_value, smallest_index);\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp7cqjjcti.scala:34:17 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mfor\e[0m (\e[33mval\e[0m n <- arr)\
    \ {\n\e[31m\e[31m   |\e[0m                 ^^^\e[0m\n\e[31m   |\e[0m         \
    \        pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp7cqjjcti.scala:34:31 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m            \e[33mfor\e[0m (\e[33mval\e[0m n <- arr) {\n\e[31m\e[31m \
    \  |\e[0m                               ^\e[0m\n\e[31m   |\e[0m              \
    \                 '<-' expected, but '{' found\n\e[31m\e[31m-- [E020] Syntax Error:\
    \ /tmp/tmp7cqjjcti.scala:40:12 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m            \e[33melse\e[0m List(smallest_even_value, smallest_index);\n\
    \e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            \e[33myield\e\
    [0m or \e[33mdo\e[0m expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp7cqjjcti.scala:38:13 ------------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m            }\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e[0mvalue\
    \ withFilter is not a member of Null, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\
    \e[31m   |\e[0m  import collection.conv"
  stdout: ''
  timestamp: 1660010191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var minVal : Long =\
    \ arr(0)\n        var minIndex : Long = 0\n        var i : Long = 1\n        var\
    \ list : List[Long] = Nil\n\n        // Find the smallest even value in the array\n\
    \        while (i < arr.length && arr(i) rem 2 != 0) {\n            val currentVal\
    \ = arr(i)\n            if (currentVal < minVal) {\n                minIndex =\
    \ i\n                minVal = currentVal\n            }\n            i += 1\n\
    \        }\n\n        // If there are more values smaller than the smallest even\
    \ value, pick the smallest index value\n        if (minVal != 0) {\n         \
    \   if (arr.length == i) {\n                list = List(minVal)\n            }\
    \ else {\n                list = List(minVal, minIndex)\n            }\n     \
    \   } else {\n            list = Nil\n        }\n        list\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb8rvwkzn.scala:36:37\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mwhile\e[0m (i <\
    \ arr.length && arr(i) rem \e[31m2\e[0m != \e[31m0\e[0m) {\n\e[31m\e[31m   |\e\
    [0m                                     ^\e[0m\n\e[31m   |\e[0m              \
    \                       Found:    (i : Long)\n\e[31m   |\e[0m                \
    \                     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpb8rvwkzn.scala:37:33 --------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m            \e[33mval\e[0m \e[36mcurrentVal\e[0m = arr(i)\n\e[31m\e[31m\
    \   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m           \
    \                      Found:    (i : Long)\n\e[31m   |\e[0m                 \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // your code goes here\n\
    \        if(arr.isEmpty || arr.head == 0l) {\n            return []\n        }\n\
    \        val smalest_value = arr.head \n        val index_arr = arr.toList.map(i\
    \ => (i, i)).toList\n        val smalest_index_arr = index_arr.filter(x => x._1.toLong\
    \ %2 == 0).sortBy(x => x._1)\n        if(smalest_index_arr.length == 1) {\n  \
    \          smalest_index_arr.get._1 \n        } else if(smalest_index_arr.length\
    \ > 1) {\n            smalest_index_arr.toList.head._1\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn86k0wwp.scala:32:20 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mreturn\e[0m []\n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    an identifier\
    \ expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn86k0wwp.scala:33:8\
    \ ----------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        }\n\e[31m\e[31m\
    \   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        '=>' expected, but '}' found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn86k0wwp.scala:38:30 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            smalest_index_arr.get._1 \n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue get is not\
    \ a member of List[(Long, Long)] - did you mean smalest_index_arr.seq?\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpn86k0wwp.scala:39:15 --------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m(smalest_index_arr.length\
    \ > \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e\
    [0m               Found:    Unit\n\e[31m   |\e[0m               Required: List[Long]\n\
    \e[31m   |\e[0m               Maybe you are missing an else part for the conditional?\n\
    \e[31m40 |\e[0m            smalest_index_arr.toList.head._1\n\e[31m41 |\e[0m \
    \       }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010192
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) return\
    \ List()\n        var smallest_value = 0\n        var smallest_index = 0\n   \
    \     var index = 0\n        var even_value_count = arr.filter(_%2 == 0).length\n\
    \        var smalest_value = arr.min\n        while (smallest_value == smalest_value\
    \ && index <  arr.length) {\n            smallest_value += 2\n            smallest_index\
    \  += index\n            index += 1\n        }\n        while(even_value_count\
    \ > 0 && smallest_value == smalest_value && index <  arr.length) {\n         \
    \   even_value_count-=arr.filter(_%2 == 0).length\n            smallest_value\
    \ += 2\n            smallest_index  += index\n            index += 1\n       \
    \ }\n        if(even_value_count == 0){\n            if (smallest_value == smalest_value)\
    \ return List()\n            else\n            List(smalest_value, smallest_index)\n\
    \        }\n        else{\n            smallest_value += 2\n            smallest_index\
    \  += index\n            while(smallest_value < smalest_value) {\n           \
    \     smallest_value += 2\n                smallest_index  += index\n        \
    \        index += 1\n            }\n            List(smalest_value, smallest_index)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpehptyc27.scala:64)\n\tat Problem.main(tmpehptyc27.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        require(arr.length\
    \ < 10000)\n        val minEvenValueIndex =\n            arr.groupBy(x => x %\
    \ 2).toSeq\n                .map(x => (x._2, x._1.indexOfMin))\n             \
    \   .toList\n                .map(x => (x._1, x._2)).minBy(x => x._1)\n      \
    \          .getOrElse(List(1L, 0L))\n        val minEvenValue =\n            arr.indexOf(minEvenValueIndex.getOrElse(List(1L,\
    \ 0L)))\n                .toLong\n        minEvenValueIndex.getOrElse(List(1L,\
    \ 0L))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9odby0m8.scala:33:38 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                .map(x => (x._2, x._1.indexOfMin))\n\e\
    [31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                value indexOfMin is not a member of\
    \ Long\n\e[31m\e[31m-- Error: /tmp/tmp9odby0m8.scala:35:56 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                .map(x => (x._1, x._2)).minBy(x => x._1)\n\
    \e[31m\e[31m   |\e[0m                                                        ^\e\
    [0m\n\e[31m   |\e[0mNo implicit Ordering defined for List[Long]..\n\e[31m   |\e\
    [0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e\
    [35mList[Long]\e[0m](\n\e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[List[Long]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[List[Long]].\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\e[31m\
    \   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        arr.foldLeft((0l, 0l))\
    \ { (a,b) =>\n            val nodeValue = a._1\n            if (nodeValue % 2\
    \ == 0) {\n                if (b._1 < nodeValue) {\n                    (a, b)\n\
    \                } else {\n                    (b, nodeValue)\n              \
    \  }\n            } else {\n                (a, b)\n            }\n        }._1\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4nt_huc9.scala:33:22 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                \e[33mif\e[0m (b._1 < nodeValue) {\n\e\
    [31m\e[31m   |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m            \
    \        value _1 is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp4nt_huc9.scala:34:21 --------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m                    (a, b)\n\e[31m\e[31m   |\e[0m                    \
    \ ^\e[0m\n\e[31m   |\e[0m                     Found:    (a : (Long, Long))\n\e\
    [31m   |\e[0m                     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp4nt_huc9.scala:39:17 --------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                (a, b)\n\e[31m\e[31m   |\e[0m       \
    \          ^\e[0m\n\e[31m   |\e[0m                 Found:    (a : (Long, Long))\n\
    \e[31m   |\e[0m                 Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var result = ListBuffer[Long]()\n\
    \        var index_of_smallest_value = -1\n\n        // Find the smallest value\
    \ among all even values, then pluck it out\n        for (value <- arr.filter(_\
    \ % 2 == 0).toSorted) {\n            index_of_smallest_value = arr.indexOf(value)\n\
    \            if ((index_of_smallest_value < 0) && (index_of_smallest_value < result.length))\
    \ {\n                result = result ++ List(value)\n            }\n        }\n\
    \        return result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7_9zj88s.scala:34:45 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mfor\e[0m (value <- arr.filter(_ % \e[31m2\e\
    [0m == \e[31m0\e[0m).toSorted) {\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toSorted is not a member of List[Long] - did you mean\
    \ List[Long].sorted?\n1 error found\n"
  stdout: ''
  timestamp: 1660010198
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n      if(arr.isEmpty) List[]\n\
    \      else if(arr.head % 2 == 0) arr.takeRight(arr.size - 2).minBy(_.toInt).toList\n\
    \      else arr.sortBy(_ % 2).takeWhile(_ > 0).reverse.map(_.toInt).minBy(_ %\
    \ 2).toList\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5abpdvc2.scala:30:27 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m      \e[33mif\e[0m(arr.isEmpty) List[]\n\e[31m\e[31m\
    \   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m                 \
    \          an identifier expected, but ']' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp5abpdvc2.scala:31:76 ------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m      \e[33melse\e[0m \e[33mif\e[0m(arr.head % \e[31m2\e[0m == \e[31m0\e\
    [0m) arr.takeRight(arr.size - \e[31m2\e[0m).minBy(_.toInt).toList\n\e[31m\e[31m\
    \   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m         value toList is not a member of Long - did you mean\
    \ Long.toInt?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5abpdvc2.scala:32:80\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m      \e[33melse\e[0m arr.sortBy(_\
    \ % \e[31m2\e[0m).takeWhile(_ > \e[31m0\e[0m).reverse.map(_.toInt).minBy(_ % \e\
    [31m2\e[0m).toList\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           value toList is not a member of Int - did you mean\
    \ Int.toInt?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val nodes = (arr.map(_.toLong).sorted).distinct.toList\n\
    \        var pickedNode = null\n        var pickedIndex = 0\n        for (i <-\
    \ 0 until nodes.length) {\n            if (pickedIndex == 0) {\n             \
    \   if (node(i) % 2 == 0) {\n                    pickedNode = i\n            \
    \        pickedIndex = i\n                }\n            } else if (pickedIndex\
    \ != i) {\n                if (node(i) == pickedNode) {\n                    pickedIndex\
    \ = i\n                } else {\n                    pickedNode = pickedIndex\n\
    \                    pickedIndex = i\n                }\n            }\n     \
    \   }\n        pickedNode match {\n            case 0 => List() //if there are\
    \ no even numbers\n            case i => List(pickedNode, pickedIndex)\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp81ah81vk.scala:35:20 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33mif\e[0m (node(i) % \e[31m2\e[0m\
    \ == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                    ^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: node\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp81ah81vk.scala:36:33 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    pickedNode = i\n\e[31m\e[31m   |\e\
    [0m                                 ^\e[0m\n\e[31m   |\e[0m                  \
    \               Found:    (i : Int)\n\e[31m   |\e[0m                         \
    \        Required: Null\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp81ah81vk.scala:40:20\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                \e[33mif\e\
    [0m (node(i) == pickedNode) {\n\e[31m\e[31m   |\e[0m                    ^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: node\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp81ah81vk.scala:43:33 --------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    pickedNode = pickedIndex\n\e[31m\e\
    [31m   |\e[0m                                 ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                 Found:    (pickedIndex : Int)\n\e[31m   |\e\
    [0m                                 Required: Null\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmp81ah81vk.scala:49:17 -----------------------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m            \e[33mcase\e[0m \e[31m0\e[0m => List() \e\
    [34m//if there are no even numbers\e[0m\n\e[31m\e[31m   |\e[0m               \
    \  ^\e[0m\n\e[31m   |\e[0m           Values of types Int and Null cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp81ah81vk.scala:50:27\
    \ --------------------\e[0m\e[0m\n\e[31m50 |\e[0m            \e[33mcase\e[0m i\
    \ ="
  stdout: ''
  timestamp: 1660010201
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val minIndexMap = arr.zipWithIndex.minBy(_._1)\
    \ // nodes with smallest value\n        arr.filter(node => node.toLong % 2 ==\
    \ 0L).map(node => minIndexMap.getOrElse(node, node))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3cksz9i4.scala:31:74 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        arr.filter(\e[36mnode\e[0m => node.toLong % \e\
    [31m2\e[0m == \e[31m0L\e[0m).map(\e[36mnode\e[0m => minIndexMap.getOrElse(node,\
    \ node))\n\e[31m\e[31m   |\e[0m                                              \
    \                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \         value getOrElse is not a member of (Long, Int)\n1 error found\n"
  stdout: ''
  timestamp: 1660010201
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var minEvenValue :\
    \ Long = 0\n        var minIndex = 0\n        var evenCount = 0\n        var i\
    \ = 0\n        while (i < arr.length) {\n            if (arr(i) % 2 == 0) {\n\
    \                evenCount += 1\n                if (minEvenValue < arr(i)) {\n\
    \                    minEvenValue = arr(i)\n                    minIndex = i\n\
    \                }\n                i += 1\n            }\n            else {\n\
    \                i += 1\n            }\n        }\n        if (evenCount == 0)\
    \ {\n            return List()\n        }\n        else {\n            var evenIndex\
    \ = 0\n            var evenMinValue = 0\n            var evenCount2 = 0\n    \
    \        var evenMinIndex = 0\n            i = 0\n            while (i < arr.length)\
    \ {\n                if (arr(i) % 2 == 0) {\n                    evenCount2 +=\
    \ 1\n                    if (evenMinValue < arr(i)) {\n                      \
    \  evenMinValue = arr(i)\n                        evenMinIndex = i\n         \
    \           }\n                }\n                else {\n                   \
    \ i += 1\n                }\n            }\n            var evenMinIndex = -1\n\
    \            var evenMinValue = -1\n            if (evenCount2 == 1) {\n     \
    \           evenIndex = evenMinIndex\n                evenMinValue = evenMinValue\n\
    \            }\n            else if (evenCount == evenCount2) {\n            \
    \    while (evenIndex < arr.length) {\n                    if (evenIndex == evenMinIndex)\
    \ {\n                        if (evenMinValue < arr(evenIndex)) {\n          \
    \                  evenMinValue = arr(evenIndex)\n                           \
    \ evenMinIndex = evenIndex\n                        }\n                    }\n\
    \                    evenIndex += 1\n                }\n            }\n      \
    \      else if (evenCount == evenCount2 - 1) {\n                while (evenIndex\
    \ < arr.length) {\n                    if (evenIndex == evenMinIndex) {\n    \
    \                    if (evenMinValue < arr(evenIndex)) {\n                  \
    \          evenMinValue = arr(evenIndex)\n                            evenMinIndex\
    \ = evenIndex\n                        }\n                    }\n            \
    \        evenIndex += 1\n                }\n                while (evenIndex <\
    \ arr.length) {\n                    if (evenIndex == evenMinIndex) {\n      \
    \                  if (evenMinValue < arr(evenIndex)) {\n                    \
    \        evenMinValue = arr(evenIndex)\n                            evenMinIndex\
    \ = evenIndex\n                        }\n                    }\n            \
    \        evenIndex += 1\n                }\n            }\n            else if\
    \ (evenCount == evenCount2 - 2) {\n                while (evenIndex < arr.length)\
    \ {\n                    if (evenIndex == evenMinIndex) {\n                  \
    \      if (evenMinValue < arr(evenIndex)) {\n                            evenMinValue\
    \ = arr(evenIndex)\n                            evenMinIndex = evenIndex\n   \
    \                     }\n                    }\n                    evenIndex\
    \ += 1\n                }\n                while (evenIndex < arr.length) {\n\
    \                    if (evenIndex == evenMinIndex) {\n                      \
    \  if (evenMinValue < arr(evenIndex)) {\n                            evenMinValue\
    \ = arr(evenIndex)\n                            evenMinIndex = evenIndex\n   \
    \                     }\n                    }\n                    evenIndex\
    \ += 1\n                }\n                while (evenIndex < \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl2w6xdp3.scala:124:34 --------------------------\e\
    [0m\e[0m\n\e[31m124 |\e[0m                \e[33mwhile\e[0m (evenIndex < \n\e[31m\e\
    [31m    |\e[0m                                  ^\e[0m\n\e[31m    |\e[0m     \
    \                             expression expected but \e[31m'}'\e[0m found\n\e\
    [31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl2w6xdp3.scala:138:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m138 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161]\
    \ Naming Error: /tmp/tmpl2w6xdp3.scala:68:16 ---------------------------\e[0m\e\
    [0m\n\e[31m68 |\e[0m            \e[33mvar\e[0m \e[36mevenMinIndex\e[0m = -\e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mevenMinIndex is already defined as \e[33mvariable\e[0m \e[35mevenMinIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl2w6xdp3.scala:69:16 ---------------------------\e[0m\e[0m\n\e\
    [31m69 |\e[0m            \e[33mvar\e[0m \e[36mevenMinValue\e[0m = -\e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mevenMinValue\
    \ is already defined as \e[33mvariable\e[0m \e[35mevenMinValue\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpl2w6xdp3.scala:60:42 --------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \                        evenMinValue = arr(i)\n\e[31m\e[31m   |\e[0m        \
    \                               ^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                      Found:    Long\n\e[31m   |\e[0m                       \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpl2w6xdp3.scala:78:46 --------------------\e[0m\e[0m\n\e[31m78\
    \ |\e[0m                            evenMinValue"
  stdout: ''
  timestamp: 1660010207
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        arr.sorted\n      \
    \      .map(i => (i , arr indexOf(i)))\n            .filter(_._2.isDefined)\n\
    \            .map { case (index , value) => (value , index) }\n            .head\n\
    \            .getOrElse(List[Long]())\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnw6iuz4x.scala:32:25 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            .filter(_._2.isDefined)\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \  value isDefined is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660010203
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Write your code\
    \ here\n        val smallest = arr.minBy { x => x % 2 }.head\n        val count\
    \ = arr.count(_ % 2 == smallest % 2)\n        if (count <= 1) {\n            List(smallest)\n\
    \        } else {\n            arr.filter(x => x % 2 == smallest % 2).minBy {\
    \ x => x }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc0c028fh.scala:31:48 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = arr.minBy\
    \ { \e[36mx\e[0m => x % \e[31m2\e[0m }.head\n\e[31m\e[31m   |\e[0m           \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \          value head is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpc0c028fh.scala:36:12 --------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            arr.filter(\e[36mx\e[0m => x % \e[31m2\e[0m == smallest %\
    \ \e[31m2\e[0m).minBy { \e[36mx\e[0m => x }\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            Found:    Long\n\e[31m   |\e[0m            Required: \e[1m\e[32mList\e\
    [0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010206
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val len = arr.size\n\
    \        if (len == 0) List() else {\n            val mVal = arr.min\n       \
    \     val mIdx = arr.indexWhere(_ == mVal)\n            val odd = arr.takeWhile(x\
    \ => x % 2 == 0).toSet\n            val smalest = arr.filter(x => x % 2 == 0).min\n\
    \            if (odd.isEmpty) {\n                if (mIdx >= 0) List(mVal, mIdx)\
    \ else List()\n            } else List(smalest, mIdx)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe3ljbtm1.scala:43)\n\tat Problem.main(tmpe3ljbtm1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010211
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_%2\
    \ == 0L)\n        if(evens.isEmpty) List(arr.head)\n        else evens.minBy(x\
    \ => x)._2\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprvaw_5ts.scala:32:33 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m evens.minBy(x => x)._2\n\e[31m\e\
    [31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \      value _2 is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010208
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // write your code\
    \ here\n        var resultSet = TreeSet[Long]()\n        var smallest = arr(0)\
    \ // the value at the lowest index\n        var smallestIndex = -1\n        for(\
    \ i <- 0 until arr.length) {\n            if(arr(i) % 2 == 0){ // if the index\
    \ is even\n                if(resultSet.contains(smallest)) { // if we've already\
    \ found a smallest index for this value\n                    // return the smallest\
    \ value with that index\n                    smallestIndex = i\n             \
    \   } else {\n                    resultSet += smallest\n                }\n \
    \           }\n            smallest += arr(i) // add the new value to the smallest\
    \ number\n        }\n        // if we found a smallest index for this value, return\
    \ it\n        if(smallestIndex != -1) {\n            resultSet.contains(smallest)\n\
    \        } else {\n            // otherwise, if we didn't find an even index return\
    \ empty list\n            resultSet.toList == List(false)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnxr40kdh.scala:47:30\
    \ --------------------\e[0m\e[0m\n\e[31m47 |\e[0m            resultSet.contains(smallest)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Found:    Boolean\n\e[31m   |\e[0m            Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnxr40kdh.scala:50:12\
    \ --------------------\e[0m\e[0m\n\e[31m50 |\e[0m            resultSet.toList\
    \ == List(\e[31mfalse\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    Boolean\n\e[31m   |\e[0m           \
    \ Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010211
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evenValues = arr.filter(num\
    \ => num.toInt % 2 == 0).toSet\n        if(evenValues.isEmpty) {\n           \
    \ List[Long]()\n        }\n        else {\n            val smallestIndex = evenValues.min\n\
    \            val smallestValue = evenValues(smallestIndex)\n            List(smallestValue,\
    \ smallestIndex)\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq0x17ka0.scala:37:17\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            List(smallestValue,\
    \ smallestIndex)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                 Found:    (smallestValue : Boolean)\n\e[31m   |\e\
    [0m                 Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010209
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        arr.zipWithIndex.sortBy(_._1).takeWhile(n\
    \ => n._2 % 2 == 0).map(_._1).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1bjwy6z4.scala:33)\n\tat Problem.main(tmp1bjwy6z4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n      val n = arr.size\n  \
    \    val minEven = arr.minBy { n => n % 2 == 0 }\n      val minEvenIndex = arr.indexWhere(_.toLong\
    \ == minEven)\n      val (smalest_val, smalest_idx) = if (minEvenIndex == -1)\
    \ (minEven, 0) else (minEven, minEvenIndex)\n      (arr.filter(_.toLong == smalest_val).map(_.toLong),\
    \ minEvenIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1y5yinra.scala:34:6\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m      (arr.filter(_.toLong ==\
    \ smalest_val).map(_.toLong), minEvenIndex)\n\e[31m\e[31m   |\e[0m      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m      Found:    \e[1m\e[31m(\e[0mList[Long]\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m    \
    \  Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010211
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Your code here\n\
    \        val res = mutable.ArrayBuffer.empty[Long]\n        val size = arr.size\n\
    \        arr.zipWithIndex.foreach {\n            case (el, index) => {\n     \
    \           if (el % 2 == 0) {\n                    res.+=el\n               \
    \ }\n            }\n        }\n        res.sortWith(_ < _)\n        res.headOption\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpji4_v4su.scala:36:28 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    res.+=el\n\e[31m\e[31m   |\e[0m \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \  expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpji4_v4su.scala:31:18 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010205
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var index = -1\n  \
    \      var value = arr.head\n        var temp = []\n        arr.foreach(x => {\n\
    \            if (x % 2 == 0) {\n                if (index == -1) {\n         \
    \           index = x\n                } else {\n                    if (value\
    \ < arr[index]) {\n                        value = arr[index]\n              \
    \          index = x\n                    }\n                }\n            }\n\
    \        })\n        if (arr.isEmpty) return temp\n        else if (value == arr.head)\
    \ {\n            temp.add(index)\n            return temp\n        } else {\n\
    \            val result = Array(value, index + 1)\n            temp.add(index)\n\
    \            return result\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj93u8e0q.scala:32:20 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m \e[36mtemp\e[0m = []\n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    an\
    \ identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj93u8e0q.scala:33:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        arr.foreach(\e\
    [36mx\e[0m => {\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m'=>' expected,\
    \ but 'end of statement' found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj93u8e0q.scala:36:28\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m                    index = x\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       Found:    (x : Long)\n\e[31m   |\e[0m                \
    \            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpj93u8e0q.scala:38:36 ------------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m                    \e[33mif\e[0m (value < arr[\e[35mindex\e[0m]) {\n\e[31m\e\
    [31m   |\e[0m                                    ^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                   Not found: type index\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpj93u8e0q.scala:39:36 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                        value = arr[\e[35mindex\e[0m]\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                    Not found: type index\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj93u8e0q.scala:40:32 --------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                        index = x\n\e[31m\e[31m   |\e\
    [0m                                ^\e[0m\n\e[31m   |\e[0m                   \
    \             Found:    (x : Long)\n\e[31m   |\e[0m                          \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer exp"
  stdout: ''
  timestamp: 1660010216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var min = arr.min\n\
    \        var index = arr.indexOf(min)\n        var even_values = arr.filter(_%2\
    \ == 0)\n        if (arr.isEmpty) {\n            return List().asInstanceOf[List[Long]]\n\
    \        }\n        while (even_values.nonEmpty) {\n            var even_value\
    \ = even_values.min()\n            if (even_values.contains(even_value)) {\n \
    \               val current_index = even_values.indexOf(even_value)\n        \
    \        if (current_index < index) {\n                    index = current_index\n\
    \                }\n            }\n            even_values = even_values.filter(_%2\
    \ == 0)\n        }\n        List((min.toLong, index)).asInstanceOf[List[Long]]\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpxi51s33q.scala:37:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mvar\e[0m \e[36meven_value\e[0m = even_values.min()\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmissing argument for parameter ord of \e[33mmethod\e[0m \e[35mmin\e\
    [0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m: (\e[33mimplicit \e[0mord:\
    \ Ordering[B]): Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010208
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val odd = arr.filter(_%2\
    \ == 0).toList\n        val even = arr.filter(_%2 == 1).toList\n        val smallest\
    \ = odd.sortWith(_ < _).toList\n        val smallest_idx = even.indexOf(smallest(0))\n\
    \        List(smallest(0), smallest_idx)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm1mamts9.scala:37)\n\tat Problem.main(tmpm1mamts9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        def getSmallestEvenValue(arr\
    \ : List[Long]) : List[Long] = {\n            val smalest_value = arr(0)\n   \
    \         var index = 0\n            arr.foreach{\n                if (it.even)\
    \ {\n                    val value_to_be_compare = it\n                    if\
    \ (value_to_be_compare < smalest_value) {\n                        smalest_value\
    \ = value_to_be_compare\n                        index = arr.indexOf(value_to_be_compare)\n\
    \                    }\n                }\n            }\n            List(smalest_value,\
    \ index)\n        }\n        val smalest_value, smalest_value_and_index = getSmallestEvenValue(arr)\n\
    \        if (arr.isEmpty) {\n            List()\n        } else {\n          \
    \  arr.indexWhere(i => i.even == smalest_value) match {\n                case\
    \ Some(index) => List(smalest_value, smalest_value_and_index, index.toLong)\n\
    \                case None => List()\n            }\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpboo6oh8e.scala:34:20 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                \e[33mif\e[0m (it.even) {\n\e[31m\e[31m\
    \   |\e[0m                    ^^\e[0m\n\e[31m   |\e[0m                    Not\
    \ found: it\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpboo6oh8e.scala:35:46\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                    \e[33mval\e\
    [0m \e[36mvalue_to_be_compare\e[0m = it\n\e[31m\e[31m   |\e[0m               \
    \                               ^^\e[0m\n\e[31m   |\e[0m                     \
    \                         Not found: it\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpboo6oh8e.scala:37:38 -----------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m                        smalest_value = value_to_be_compare\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Reassignment to val smalest_value\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpboo6oh8e.scala:48:34\
    \ ------------------------\e[0m\e[0m\n\e[31m48 |\e[0m            arr.indexWhere(\e\
    [36mi\e[0m => i.even == smalest_value) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e\
    [0m                                ^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                  value even is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpboo6oh8e.scala:49:87 ------------------------\e[0m\e[0m\n\
    \e[31m49 |\e[0m                \e[33mcase\e[0m Some(index) => List(smalest_value,\
    \ smalest_value_and_index, index.toLong)\n\e[31m\e[31m   |\e[0m              \
    \                                                                   ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of Any, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31"
  stdout: ''
  timestamp: 1660010216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var index = 0\n   \
    \     var smallest_even_value = -1\n        var result: List[Long] = Nil\n\n \
    \       arr.foreach( n => if (n % 2 == 0 && smallest_even_value == -1 || n < smallest_even_value)\
    \ {\n                if (smallest_even_value == -1) {\n                    smallest_even_value\
    \ = n\n                    index = n\n                } else if (smallest_even_value\
    \ != -1) {\n                    smallest_even_value = n\n                    index\
    \ = smallest_even_value\n                }\n                else {\n         \
    \           smallest_even_value = n\n                    index = n\n         \
    \       }\n            })\n        if (smallest_even_value == -1) {\n        \
    \    return Nil\n        } else if (smallest_even_value != -1) {\n           \
    \ result.append((smallest_even_value, index))\n        } else {\n            result.append((smallest_even_value,\
    \ index))\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn_0ef3c8.scala:36:42\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m                    smallest_even_value\
    \ = n\n\e[31m\e[31m   |\e[0m                                          ^\e[0m\n\
    \e[31m   |\e[0m                                          Found:    (n : Long)\n\
    \e[31m   |\e[0m                                          Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn_0ef3c8.scala:37:28 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                    index = n\n\e[31m\e[31m   |\e[0m\
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \   Found:    (n : Long)\n\e[31m   |\e[0m                            Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn_0ef3c8.scala:39:42\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m                    smallest_even_value\
    \ = n\n\e[31m\e[31m   |\e[0m                                          ^\e[0m\n\
    \e[31m   |\e[0m                                          Found:    (n : Long)\n\
    \e[31m   |\e[0m                                          Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn_0ef3c8.scala:43:42 --------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    smallest_even_value = n\n\e[31m\e\
    [31m   |\e[0m                                          ^\e[0m\n\e[31m   |\e[0m\
    \                                          Found:    (n : Long)\n\e[31m   |\e\
    [0m                                          Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn_0ef3c8.scala:44:28 --------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                    index = n\n\e[31m\e[31m   |\e[0m\
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \   Found:    (n : Long)\n\e[31m   |\e[0m               "
  stdout: ''
  timestamp: 1660010217
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val indexMap = mutable.Map[Long,\
    \ Long]()\n        val indexMap = mutable.Map[Long, Long]()\n        var evenArr\
    \ : List[Long] = null\n        for(i <- 0 until arr.length) {\n            val\
    \ n = arr(i)\n            if(i == arr.length - 1 || (n % 2 != 0)) {\n        \
    \        evenArr :+ n\n                indexMap.put(arr(i), i)\n            }\
    \ else if((n % 2 == 0) && evenArr == null) {\n                evenArr :+ n\n \
    \               indexMap.put(arr(i), i)\n            }\n        }\n        if(evenArr.isEmpty\
    \ && indexMap.isEmpty) {\n            return List[Long]()\n        } else {\n\
    \            return evenArr.toList.sortBy(x => x).zipWithIndex.toList.filter(x\
    \ => x._2 < x._1).map(x => x._2)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbfuokxz3.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mindexMap\e[0m = mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mindexMap is already defined as \e[33mvalue\e[0m \e[35mindexMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpbfuokxz3.scala:30:23 ------------------------\e[0m\e[0m\n\
    \e[31m30 |\e[0m        \e[33mval\e[0m \e[36mindexMap\e[0m = mutable.Map[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010210
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val minValue = arr.min\n\
    \        val maxValue = arr.max\n        val evenNodes = arr.filter(_ % 2 == 0).distinct\n\
    \        val smalestEvenNode = evenNodes.min\n\n        // return an empty list\
    \ if the input array is empty\n        if(arr.isEmpty)\n            return (List[Long]())\n\
    \n        // return the node with the smallest even value if it exists\n     \
    \   if(evenNodes.contains(smalestEvenNode))\n            return (smalestEvenNode,\
    \ arr.indexOf(smalestEvenNode))\n\n        // return an empty list if there is\
    \ no even value in this list\n        if(evenNodes.isEmpty)\n            return\
    \ (List[Long]())\n\n        // find the smallest even value in the remaining nodes\
    \ in the array\n        val indexOfSmallestEven = evenNodes.indexOf(smalestEvenNode)\n\
    \        val smallestValueAtIndex = arr.take(indexOfSmallestEven).min\n\n    \
    \    // return the node at the index\n        return (smallestValueAtIndex, arr.indexOf(smallestValueAtIndex))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps_sjw1n0.scala:41:19\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m            \e[33mreturn\e[0m\
    \ (smalestEvenNode, arr.indexOf(smalestEvenNode))\n\e[31m\e[31m   |\e[0m     \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                   Found:    (Long, Int)\n\e[31m   |\e[0m            \
    \       Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmps_sjw1n0.scala:52:15 --------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m        \e[33mreturn\e[0m (smallestValueAtIndex, arr.indexOf(smallestValueAtIndex))\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Found:    (Long, Int)\n\e[31m   |\e[0m    \
    \           Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010220
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0)\
    \ {\n            return []\n        }\n        var minVal : Long = arr(0).toLong\n\
    \        var minIndex = 0\n        var index = 0\n        for (i <- arr.indices)\
    \ {\n            var val : Long = arr(i).toLong\n            if (val < minVal)\
    \ {\n                minVal = val\n                minIndex = i\n            }\
    \ else if (val == minVal) {\n                if (index == minIndex) {\n      \
    \              return Array[Long](minVal, minIndex)\n                }\n     \
    \           index++\n            }\n        }\n        return Array[Long](minVal,\
    \ minIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpassod432.scala:31:20 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mreturn\e[0m []\n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    an identifier\
    \ expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpassod432.scala:32:8\
    \ ----------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        }\n\e[31m\e[31m\
    \   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        '=>' expected, but '}' found\n\
    \e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpassod432.scala:37:16 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mvar\e[0m \e[33mval\e[0m : Long = arr(i).toLong\n\
    \e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m               \
    \ pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpassod432.scala:38:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            \e[33mif\e\
    [0m (\e[33mval\e[0m < minVal) {\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\
    \e[31m   |\e[0m                expression expected but \e[31mval\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpassod432.scala:39:25\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                minVal\
    \ = \e[33mval\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\e\
    [31m   |\e[0m                         expression expected but \e[31mval\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpassod432.scala:41:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m            } \e[33melse\e\
    [0m \e[33mif\e[0m (\e[33mval\e[0m == minVal) {\n\e[31m\e[31m   |\e[0m        \
    \               ^^^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpassod432.scala:45:23 ---------------------------\e[0m\e[0m\n\e[31m45\
    \ |"
  stdout: ''
  timestamp: 1660010221
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var smalest_value :\
    \ Long = arr(0)\n        var smalest_index : int = 0\n        var index = 0\n\
    \        for(elem <- arr) {\n            if(elem.toLong % 2 == 0) {\n        \
    \        if(elem < smalest_value) {\n                    smalest_value = elem\n\
    \                    smalest_index = index\n                }\n              \
    \  index += 1\n            }\n        }\n        if(arr.isEmpty) List(smalest_value,\
    \ smalest_index)\n        else Array(smalest_value, smalest_index)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpspfeazcy.scala:31:28 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m \e[36msmalest_index\e[0m : \e\
    [35mint\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                           \
    \ ^^^\e[0m\n\e[31m   |\e[0m                            Not found: type int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010215
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val min = arr.min\n\
    \        val even = arr.filter(_%2 == 0).sortBy(-_).head\n        arr.filter(_\
    \ != even).filter(i => i % 2 == 0).sortBy(-_).head match {\n            case i\
    \ if i % 2 == 0 => List(even, arr.indexOf(i))\n            case i if i == min\
    \ => List(even, arr.indexOf(i))\n            case _ => List()\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4inhc_gr.scala:39)\n\tat Problem.main(tmp4inhc_gr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010226
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val sorted_arr = arr.sortWith(\
    \ (a,b) => a < b)\n        if(sorted_arr.isEmpty) {\n            return List[]\n\
    \        }\n        val smallest_even_val = sorted_arr(0)\n        val smallest_even_node_index\
    \ = arr.indexWhere(elem => elem == smallest_even_val)\n        val even_node_index\
    \ = smallest_even_node_index + 1\n        if(smallest_even_val % 2 == 0) {\n \
    \           // If the smallest even value can be divided by 2, then we found a\
    \ node.\n            // Therefore we should pick this node as our result.\n  \
    \          return List(sorted_arr(even_node_index))\n        } else {\n      \
    \      // If the smallest even value is not divided by 2, then we need to search\n\
    \            // the list again. We pick the smallest even value that divided by\
    \ 2 and add it.\n            // As a result, we'll pick the node which has the\
    \ smallest even value divided by 2.\n            val sorted_arr_2 = arr.sortWith(\
    \ (a,b) => a < b)\n            val smallest_even_val_2 = sorted_arr_2(0)\n   \
    \         val smallest_even_node_index_2 = arr.indexWhere(elem => elem == smallest_even_val_2)\n\
    \            val even_node_index_2 = smallest_even_node_index_2 + 1\n        \
    \    val smallest_even_val_2_by_2 = smallest_even_val_2 / 2\n            val even_node_index_2_by_2\
    \ = even_node_index_2 + 1\n            val smallest_even_val_2_by_2_even_node_index\
    \ = arr.indexWhere(elem => elem == smallest_even_val_2_by_2)\n            val\
    \ even_node_index_2_by_2_even_node_index = smallest_even_val_2_by_2_even_node_index\
    \ + 1\n            val even_node_index_2_by_2_even_val = arr[even_node_index_2_by_2_even_node_index]\n\
    \            val smallest_even_val_2_by_2_even_node_index = arr.indexWhere(elem\
    \ => elem == smallest_even_val_2_by_2_even_val)\n            val even_node_index_2_by_2_even_node_index_by_2\
    \ = arr[smallest_even_val_2_by_2_even_node_index_by_2]\n            return List(sorted_arr(even_node_index),\
    \ sorted_arr(even_node_index_by_2), sorted_arr(even_node_index_2_by_2), sorted_arr(even_node_index_2_by_2_even_node_index),\
    \ sorted_arr(even_node_index_2_by_2_even_node_index_by_2))\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkjrzkxu5.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mreturn\e[0m List[]\n\e[31m\e[31m  \
    \ |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                      \
    \  an identifier expected, but ']' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpkjrzkxu5.scala:54:16 ---------------------------\e[0m\e[0m\n\e[31m54\
    \ |\e[0m            \e[33mval\e[0m \e[36msmallest_even_val_2_by_2_even_node_index\e\
    [0m = arr.indexWhere(\e[36melem\e[0m => elem == smallest_even_val_2_by_2_even_val)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallest_even_val_2_by_2_even_node_index is already defined\
    \ as \e[33mvalue\e[0m \e[35msmallest_even_val_2_by_2_even_node_index\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpkjrzkxu5.scala:53:54 ------------------------\e[0m\e[0m\n\e[31m53 |\e\
    [0m            \e[33mval\e[0m \e[36meven_node_index_2_by_2_even_val\e[0m = arr[\e\
    [35meven_node_index_2_by_2_even_node_index\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: type even_node_index_2_by_2_even_node_index\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkjrzkxu5.scala:55:66\
    \ ------------------------\e[0m\e[0m\n\e[31m55 |\e[0m            \e[33mval\e[0m\
    \ \e[36meven_node_index_2_by_2_even_node_index_by_2\e[0m = arr[\e[35msmallest_even_val_2_by_2_even_node_index_by_2\e\
    [0m]\n\e[31m\e[31m   |\e[0m                                                  \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m           Not found: type smallest_even_val_2_by_2_even_node_index_by_2\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Fo"
  stdout: ''
  timestamp: 1660010216
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var flag = 0\n    \
    \    var temp = 0\n        var min = 0\n        var nodes: List[Long] = Nil\n\
    \        var index: List[Long] = Nil\n        for(i <- 0 to arr.length - 1 ){\n\
    \            if(arr(i) % 2 == 0){\n                if(arr(i) < min || i == 0){\n\
    \                    min = arr(i)\n                    index = List(i)\n     \
    \               temp = 0\n                }else if(arr(i) > min){\n          \
    \          min = arr(i)\n                    index = List(i)\n               \
    \     temp = 1\n                }\n            }\n        }\n        nodes = index\
    \ :: nodes\n        if(arr.length == 0){\n            nodes = Nil\n        }else\
    \ if(temp == 0){\n            nodes = Nil\n        }else{\n            nodes.sortWith(_\
    \ < _)\n        }\n        return nodes\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7fj44adw.scala:38:29\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m                    min = arr(i)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7fj44adw.scala:42:29\
    \ --------------------\e[0m\e[0m\n\e[31m42 |\e[0m                    min = arr(i)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7fj44adw.scala:48:16\
    \ --------------------\e[0m\e[0m\n\e[31m48 |\e[0m        nodes = index :: nodes\n\
    \e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m             \
    \   Found:    (index : List[Long])\n\e[31m   |\e[0m                Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010225
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var smallestOdd : Long\
    \ = 0\n        var smallestIndex : Int = 0\n        var evenSmallestValue : Boolean\
    \ = false\n        var evenSmallestIndex : Int = 0\n        var oddSmallestValue\
    \ : Boolean = false\n        var oddSmallestIndex : Int = 0\n        var index\
    \ : Int = 0\n        arr.zipWithIndex.foreach { case (node, index) => {\n    \
    \        if (node.toLong % 2l.toLong == 0l.toLong) {\n                if (evenSmallestValue\
    \ == false)\n                    evenSmallestValue = true\n                evenSmallestIndex\
    \ = index\n            }\n            else {\n                if (oddSmallestValue\
    \ == false)\n                    oddSmallestValue = true\n                oddSmallestIndex\
    \ = index\n            }\n        }}\n        if (evenSmallestValue)\n       \
    \     smallestOdd = evenSmallestIndex\n        if (oddSmallestValue)\n       \
    \     smallestOdd = oddSmallestIndex\n        smallestIndex = 0\n        arr.zipWithIndex.foreach\
    \ { case (node, index) => {\n            if (node.toLong % 2l.toLong == 0l.toLong)\
    \ {\n                if (smallestOdd != 0l.toLong && smallestOdd < node.toLong)\n\
    \                    smallestOdd = node.toLong\n                smallestIndex\
    \ = index\n            }\n        }}\n        if (smallestOdd != 0l.toLong)\n\
    \            arr.take(smallestIndex).toList\n        else\n            List()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeq1dzibx.scala:67)\n\tat Problem.main(tmpeq1dzibx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010226
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        def evenOdd(i : Long)\
    \ : List[Long] = {\n            if (i % 2 == 0) {\n                List(i.toLong,\
    \ i.toLong.toInt)\n            }\n            else {\n                List(i.toLong,\
    \ i.toLong.toInt)\n            }\n        }\n        val arr = arr.toList\n  \
    \      var smallestValue = arr.head\n        var smallestIndex = 0\n        var\
    \ evenValue = 0\n        var evenIndex = 0\n        for(i <- arr.indices) {\n\
    \            val listEvenOdd = evenOdd(arr(i))\n            if (listEvenOdd.head\
    \ == smallestValue) {\n                evenValue = listEvenOdd.head\n        \
    \        evenIndex = i\n            }\n            else {\n                if\
    \ (evenValue == smallestValue) {\n                    smallestValue = listEvenOdd.head\n\
    \                    smallestIndex = i\n                }\n            }\n   \
    \     }\n        List(smallestValue, evenIndex, smallestIndex.toLong)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpu9pec66o.scala:38:18 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010218
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val res = mutable.LinkedList[Long]()\n\
    \        var lowest = arr.min\n        var index = 0\n        var counter = 0\n\
    \        var curr = 0\n        for (i <- 0 until arr.length) {\n            counter\
    \ += 1\n            if (arr(i).toLong % 2 == 0) {\n                curr = arr(i)\n\
    \                if (lowest < curr) {\n                    lowest = curr\n   \
    \                 index = i\n                }\n            }\n        }\n   \
    \     res += lowest\n        res += index\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf2ssd1xz.scala:30:18 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = mutable.LinkedList[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpf2ssd1xz.scala:38:26 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                curr = arr(i)\n\e[31m\e[31m   |\e[0m\
    \                       ^^^^^^\e[0m\n\e[31m   |\e[0m                       Found:\
    \    Long\n\e[31m   |\e[0m                       Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010225
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var index = 0\n   \
    \     var smallestEven = -1\n        var largestEven = -1\n        for(i <- 0\
    \ until arr.length) {\n            if(arr(i) % 2 == 0) {\n                if(smallestEven\
    \ == -1) {\n                    smallestEven = i\n                } else {\n \
    \                   if(smallestEven == i)\n                        smallestEven\
    \ = i\n                    else if(smallestEven == 0)\n                      \
    \  smallestEven = -1\n                }\n            } else {\n              \
    \  if(largestEven == -1) {\n                    largestEven = i\n            \
    \    } else {\n                    if(largestEven == i)\n                    \
    \    largestEven = i\n                    else if(largestEven == 0)\n        \
    \                largestEven = -1\n                }\n            }\n        }\n\
    \        val ret = List[Long](smallestEven, index).toList\n        if(ret.isEmpty)\
    \ {\n            ret.empty\n        } else {\n            if(ret(0) != 0 && ret(1)\
    \ != 0) {\n                val temp = ret(0)\n                ret(0) = ret(1)\n\
    \                ret(1) = temp\n            }\n            ret.asInstanceOf[List[Long]]\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9rhqwotv.scala:60:16 ------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m                ret(\e[31m0\e[0m) = ret(\e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is\
    \ not a member of List[Long] - did you mean ret.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp9rhqwotv.scala:61:16 ------------------------\e[0m\e\
    [0m\n\e[31m61 |\e[0m                ret(\e[31m1\e[0m) = temp\n\e[31m\e[31m   |\e\
    [0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of\
    \ List[Long] - did you mean ret.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010228
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var evenVal : Long\
    \ = 0\n        var evenIndex : Long = 0\n        var smalest_value : Long = 0\n\
    \        var smalest_index : Long = 0\n        var minVal : Long = arr(0)\n  \
    \      var minIndex : Long = 0\n        for ( val value : Long <- arr ) {\n  \
    \          if( value % 2 == 0) {\n                if(evenVal == 0) {\n       \
    \             evenVal = value\n                    evenIndex = minIndex\n    \
    \            } else {\n                    if( value < evenVal ) {\n         \
    \               evenVal = value\n                        evenIndex = minIndex\n\
    \                    }\n                }\n            } else {\n            \
    \    if(evenVal != 0) {\n                    if( value < evenVal ) {\n       \
    \                 smalest_value = evenVal\n                        smalest_index\
    \ = evenIndex\n                    }\n                    evenVal = 0\n      \
    \              evenIndex = 0\n                }\n            }\n            minVal\
    \ = value \n            if( minVal < minIndex) {\n                minIndex = minVal\n\
    \            }\n        }\n        if( evenVal != 0) {\n            if( evenVal\
    \ < minVal ) {\n                smalest_value = evenVal\n                smalest_index\
    \ = evenIndex\n            }\n            evenVal = 0\n            evenIndex =\
    \ 0\n        }\n        if( minIndex < arr.length) {\n            if( arr.isEmpty\
    \ ) {\n                return []\n            }\n            arr.take(minIndex).foreach(\
    \ elem => arr(minIndex) = elem )\n            arr.drop(minIndex+1)\n        }\n\
    \        arr\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpduqag_4s.scala:36:14 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mfor\e[0m ( \e[33mval\e[0m value : Long\
    \ <- arr ) {\n\e[31m\e[31m   |\e[0m              ^^^\e[0m\n\e[31m   |\e[0m   \
    \           pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpduqag_4s.scala:36:40 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mfor\e[0m ( \e[33mval\e[0m value : Long <- arr ) {\n\e[31m\e\
    [31m   |\e[0m                                        ^\e[0m\n\e[31m   |\e[0m \
    \                                       '<-' expected, but '{' found\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmpduqag_4s.scala:72:24 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m                \e[33mreturn\e[0m []\n\e[31m\e[31m  \
    \ |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                      \
    \  an identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpduqag_4s.scala:73:12 ---------------------------\e[0m\e[0m\n\e[31m73\
    \ |\e[0m            }\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0m\
    \            '=>' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpduqag_4s.scala:78:4 ----------------------------\e[0m\e[0m\n\e[31m78\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e[0m    '<-' expected,\
    \ but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpduqag_4s.scala:61:9\
    \ -------------------------\e[0m\e[0m\n\e[31m61 |\e[0m        }\n\e[31m\e[31m\
    \   |\e[0m         ^\e[0m\n\e[31m   |\e[0mvalue withFilter is not a member of\
    \ Null, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.Impl"
  stdout: ''
  timestamp: 1660010230
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evensMap = arr.zipWithIndex.filter{\
    \ _._2.toLong % 2 == 0 }.map{case (item, index) => (index, _)}.toMap\n       \
    \ val evensMapKeys = evensMap.keys.toList.sortBy(_._1)\n        val smallestIndex\
    \ = evensMapKeys.head\n        val smalest_value = evensMap(smallestIndex)._2.toLong\n\
    \        if(arr.isEmpty) List(smalest_value.toLong)\n        else {\n        \
    \    val remainingList = arr.filterNot(evensMapKeys.contains(_))\n           \
    \ if(remainingList.isEmpty) List(smalest_value.toLong)\n            else {\n \
    \               val smallestIndexAndSmalest_value = evensMap(remainingList.head).toList\n\
    \                smallestIndexAndSmalest_value.sortBy(_._1).take(1).reverse :+\
    \ smalest_value.toLong\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmppi_pcd6k.scala:30:105 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevensMap\e[0m = arr.zipWithIndex.filter{\
    \ _._2.toLong % \e[31m2\e[0m == \e[31m0\e[0m }.map{\e[33mcase\e[0m (item, index)\
    \ => (index, _)}.toMap\n\e[31m\e[31m   |\e[0m                                \
    \                                                                         ^\e\
    [0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \   I could not infer the type of the parameter _$2 of expanded function:\n\e\
    [31m   |\e[0m   _$2 => (index, _$2).\n\e[31m\e[31m-- Error: /tmp/tmppi_pcd6k.scala:30:114\
    \ ----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e\
    [33mval\e[0m \e[36mevensMap\e[0m = arr.zipWithIndex.filter{ _._2.toLong % \e[31m2\e\
    [0m == \e[31m0\e[0m }.map{\e[33mcase\e[0m (item, index) => (index, _)}.toMap\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                          ^\e[0m\n\e[31m   |\e\
    [0m                                        Cannot prove that Any <:< (K, V)\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m                                        where: \
    \   K is a type variable\n\e[31m   |\e[0m                                    \
    \              V is a type variable\n\e[31m   |\e[0m                         \
    \               .\n2 errors found\n"
  stdout: ''
  timestamp: 1660010229
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var evenVals: List[Long]\
    \ = arr.filter(f => (f % 2) == 0).sortBy(f => f).toList\n        var index = arr.indexOf(0)\n\
    \        var temp = 0\n        var res = [0, index]\n        while (evenVals.nonEmpty\
    \ && (evenVals.head % 2) == 0) {\n            temp = evenVals.head\n         \
    \   evenVals = evenVals.tail\n            index = index + 1\n            res =\
    \ [temp, index]\n        }\n        if (evenVals.isEmpty) res\n        else res\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppdngejx4.scala:33:19 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e[0m \e[36mres\e[0m = [\e[31m0\e[0m,\
    \ index]\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m    \
    \               an identifier expected, but integer literal found\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmppdngejx4.scala:34:0 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mwhile\e[0m (evenVals.nonEmpty && (evenVals.head\
    \ % \e[31m2\e[0m) == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m^^^^^\e[0m\n\e[31m\
    \   |\e[0m'=>' expected, but 'end of statement' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmppdngejx4.scala:39:8 ----------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        }\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m \
    \       '=>' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmppdngejx4.scala:35:28 --------------------\e[0m\e[0m\n\e[31m35 |\e[0m\
    \            temp = evenVals.head\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    Long\n\e[31m   |\e[0m       \
    \            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010227
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var smallest_even_value\
    \ : Long = 0\n        var smallest_even_index : Long = 0\n        for (i <- arr.indices)\
    \ {\n            if (arr(i) %2 == 0) {\n                if(smallest_even_index\
    \ < i) smallest_even_index = i\n                smallest_even_value += arr(i)\n\
    \            }\n        }\n        if (smallest_even_value == 0) return List()\n\
    \        return List(smallest_even_value, smallest_even_index)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7kfd93em.scala:42)\n\tat Problem.main(tmp7kfd93em.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010233
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n      val map = new mutable.HashMap[Long,\
    \ Long]()\n      for (i <- 0 until arr.length)\n        map += (arr(i) -> i)\n\
    \      val result = arr.toList.sortBy(-_).filter(_ % 2 == 0).takeWhile(_ % 2 ==\
    \ 0)\n      val index = result.indexOf(0)\n      if(index == -1)\n        []\n\
    \      else\n        (result - index).map(_ - index).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuz6ma_eb.scala:36:9 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        []\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e\
    [31m   |\e[0m         an identifier expected, but ']' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpuz6ma_eb.scala:37:6 ----------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m      \e[33melse\e[0m\n\e[31m\e[31m   |\e[0m      ^^^^\e[0m\n\
    \e[31m   |\e[0m      '=>' expected, but 'else' found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpuz6ma_eb.scala:30:20 ------------------------\e[0m\e[0m\n\
    \e[31m30 |\e[0m      \e[33mval\e[0m \e[36mmap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010227
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val nm = arr.zipWithIndex.toMap\n\
    \        var smallest = arr.head\n        var smallestIdx = 0\n\n        for (idx\
    \ <- 0 until arr.length) {\n            if (nm.get((arr(idx) >> 1) & 1).toOption.isDefined)\
    \ {\n                if (smallest > arr(idx)) {\n                    smallest\
    \ = arr(idx)\n                    smallestIdx = idx\n                }\n     \
    \       }\n        }\n        List(smallest, smallestIdx)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaplsv8v7.scala:35:44 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mif\e[0m (nm.get((arr(idx) >> \e[31m1\e\
    [0m) & \e[31m1\e[0m).toOption.isDefined) {\n\e[31m\e[31m   |\e[0m            \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \  value toOption is not a member of Option[Int]\n1 error found\n"
  stdout: ''
  timestamp: 1660010232
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty)\n\
    \            return []\n        // sort the list to find the smallest even\n \
    \       var minVal : Long = arr.head\n        var minIndex : Int = 0\n       \
    \ for (i <- 0 until arr.length)\n            if (arr(i) % 2 == 0 && arr(i) < minVal)\n\
    \                minVal = arr(i)\n                minIndex = i\n\n        // then\
    \ find the node with smallest even value\n        var result : List[Long] = List(minVal)\n\
    \        if (minIndex > 0) {\n            // use the index\n            result\
    \ = result :+ arr(minIndex).toLong\n        } else {\n            // the smallest\
    \ even number in the array is 0\n            result = result :+ 0l.toLong\n  \
    \      }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp58apg3re.scala:31:20 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mreturn\e[0m []\n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    an identifier\
    \ expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp58apg3re.scala:33:8\
    \ ----------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mminVal\e[0m : \e[35mLong\e[0m = arr.head\n\e[31m\e[31m   |\e[0m      \
    \  ^^^\e[0m\n\e[31m   |\e[0m        '=>' expected, but unindent found\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010227
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        def even(l: Long) =\
    \ l%2 == 0\n        val lsmalest = arr.filter(even).sortBy(x => x).head\n    \
    \    arr.filter(even).indexOf(lsmalest)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0ew0pgpq.scala:32:32\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        arr.filter(even).indexOf(lsmalest)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m        Found:    Int\n\e[31m   |\e[0m        Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010231
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val arr = arr.toList\n\
    \        if(arr.isEmpty) Nil\n        else if(arr.head.isMultipleOf(2)) arr filter\
    \ { _%2==0 }\n        else {\n            val result = Nil\n            val minValue\
    \ = arr.head\n            val minIndex = 0\n            val minEvenValue = 0\n\
    \            for(i <- 0 until arr.length) {\n                if(arr(i).isMultipleOf(2))\
    \ minEvenValue = arr(i)\n                if(arr(i) < minValue) minValue = arr(i)\n\
    \                if((arr(i) & 1) == 0) minIndex = i\n            }\n         \
    \   if(minEvenValue != 0){\n                result += (minValue -> minIndex)\n\
    \            }\n            result\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpw4wmjc_j.scala:30:18 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpw4wmjc_j.scala:39:56 -----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                \e[33mif\e[0m(arr(i).isMultipleOf(\e\
    [31m2\e[0m)) minEvenValue = arr(i)\n\e[31m\e[31m   |\e[0m                    \
    \                       ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                              Reassignment to val minEvenValue\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpw4wmjc_j.scala:40:47 -----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                \e[33mif\e[0m(arr(i) < minValue) minValue\
    \ = arr(i)\n\e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Reassignment to val\
    \ minValue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpw4wmjc_j.scala:41:47\
    \ -----------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                \e[33mif\e\
    [0m((arr(i) & \e[31m1\e[0m) == \e[31m0\e[0m) minIndex = i\n\e[31m\e[31m   |\e\
    [0m                                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                    Reassignment to val minIndex\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw4wmjc_j.scala:44:23 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                result += (minValue -> minIndex)\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is\
    \ not a member of object scala.collection.immutable.Nil - did you mean result.!=?\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660010234
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smalest_val = evens.min\n        val smalest_idx\
    \ = evens.indexOf(smalest_val)\n        if (smalest_idx == 0) evens.toList\n \
    \       else if (smalest_idx == evens.length) evens.take(evens.length-1)\n   \
    \     else evens.take(smalest_idx).drop(smalest_idx).map(x => (x, smalest_idx)).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfsusqzpe.scala:35:82\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m evens.take(smalest_idx).drop(smalest_idx).map(x\
    \ => (x, smalest_idx)).toList\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    List[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m]\n\e[31m   |\e[0m   \
    \          Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010234
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val result = arr.zipWithIndex.filter(_._2\
    \ % 2 == 0).map(_._1).sortWith((a, b) => math.signum(a) - math.signum(b))\n  \
    \      if (result.length > 0) {\n            result.headOption\n        } else\
    \ {\n            Array[Long]()\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwzyu3hvp.scala:30:89\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = arr.zipWithIndex.filter(_._2 % \e[31m2\e[0m == \e[31m0\e[0m).map(_._1).sortWith((\e\
    [36ma\e[0m, \e[36mb\e[0m) => math.signum(a) - math.signum(b))\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                                    Found:    Long\n\e[31m  \
    \ |\e[0m                                                       Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwzyu3hvp.scala:32:19\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            result.headOption\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \       Found:    \e[1m\e[31mOption\e[0m[Long]\n\e[31m   |\e[0m            Required:\
    \ \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpwzyu3hvp.scala:34:12 --------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m            Array[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    \e[1m\e[31mArray\e\
    [0m[Long]\n\e[31m   |\e[0m            Required: \e[1m\e[32mList\e[0m[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010237
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n      val smalest_even = arr.filter(e\
    \ => e % 2 == 0).min\n      val smalest_index = (arr(arr.indexWhere(e => e % 2\
    \ == 0)) - smalest_even).toInt\n      smalest_even :: smalest_index :: arr.filterNot(e\
    \ => e % 2 == 0).map(e => e - smalest_even).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwfbgk1fl.scala:32:6\
    \ ---------------------\e[0m\e[0m\n\e[31m32 |\e[0m      smalest_even :: smalest_index\
    \ :: arr.filterNot(\e[36me\e[0m => e % \e[31m2\e[0m == \e[31m0\e[0m).map(\e[36me\e\
    [0m => e - smalest_even).toList\n\e[31m\e[31m   |\e[0m      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m      Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e\
    [0m      Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val ans = mutable.ArrayBuffer.empty[Long]\n\
    \        val evens = arr.filter(_ % 2 == 0).zipWithIndex.sortBy(-_._1).takeWhile(_._1\
    \ <= arr.length).map(_._1)\n        if(evens.nonEmpty) {\n            ans += evens.head\n\
    \            ans += evens.takeWhile(_._1 < arr.length).map(arr(_))\n        }\n\
    \        ans\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5wkkd4tr.scala:30:18 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mans\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010232
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Your code here\n\
    \        val result = new mutable.LinkedList[Long]\n        arr.foreach(i => {\n\
    \            if(i % 2 == 0 && i % 2 != 0) {\n                result.add(i)\n \
    \           }\n        })\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoejf4gt5.scala:31:25 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.LinkedList[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m               \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010231
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => (x % 2) == 0)\n        val smalest_value = evens.min\n        var i = 0\n\
    \        var out: List[Long] = null\n        var index = -1\n        while(i <\
    \ evens.length) {\n            val elm = evens(i)\n            if(elm == smalest_value)\
    \ {\n                if(out == null) {\n                    out = arr.filter(_\
    \ != smalest_value)\n                    index = i\n                } else if(out.length\
    \ == 0) {\n                    out = arr.filter(_ != smalest_value)\n        \
    \            index = i\n                } else if(elm < out.min) {\n         \
    \           out = arr.filter(_ != smalest_value)\n                    index =\
    \ i\n                } else if(elm < out(index)) {\n                    index\
    \ = i\n                } else {\n                    index -= 1\n            \
    \    }\n            } else if(elm < smalest_value) {\n                out = arr.filter(_\
    \ != smalest_value)\n                index = i\n            } else if(elm < out(index))\
    \ {\n                index = i\n            } else {\n                index -=\
    \ 1\n            }\n            i += 1\n        }\n        if(out == null) out\
    \ = new List\n        out\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E042] Type Error: /tmp/tmp2_21pzdl.scala:62:34 -----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mif\e[0m(out == \e[31mnull\e[0m) out = \e\
    [33mnew\e[0m \e[35mList\e[0m\n\e[31m\e[31m   |\e[0m                          \
    \        ^^^^\e[0m\n\e[31m   |\e[0m                             List is abstract;\
    \ it cannot be instantiated\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010234
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var idx = 0\n     \
    \   var even_value = 0\n        val result = arr.zipWithIndex.filter { case (x,\
    \ y) => if (x.toInt%2 == 0) x.toInt >= x.toInt/2 else false }\n        var smallest_value\
    \ = min(arr)\n        val smalest_value = arr(arr.indexOf(smallest_value)).toLong\n\
    \        smallest_value = arr(arr.indexOf(smallest_value)).toInt\n        val\
    \ idx = arr.indexOf(smallest_value)\n        while (idx<arr.length && arr(idx).toInt%2==0)\
    \ {\n            idx+=1\n        }\n        val even_value_idx = arr.indexOf(smallest_value)\n\
    \        if (even_value_idx>=even_value){\n            val even_value_idx = arr.indexOf(smallest_value)\n\
    \            val even_value_idx = arr.indexOf(smallest_value)\n            even_value\
    \ = arr(even_value_idx).toLong\n        }\n        if (arr.isEmpty){\n       \
    \     return List();\n        }\n        if (even_value==0){\n            if (idx<arr.length){\n\
    \                val even_value_idx = arr.indexOf(smallest_value)\n          \
    \      even_value = arr(even_value_idx).toLong\n            }\n            if\
    \ (smallest_value >= arr.indexOf(arr.max)){\n                val even_value_idx\
    \ = arr.indexOf(smallest_value)\n                even_value = arr(even_value_idx).toLong\n\
    \            }\n        }\n        if (even_value<arr.length){\n            even_value\
    \ = arr(even_value_idx).toLong\n        }\n        if (even_value<arr.length){\n\
    \            even_value = arr(even_value_idx).toLong\n        }\n        if (arr.length>0){\n\
    \            if (even_value>=0){\n                if (even_value<arr.length){\n\
    \                    even_value = arr(even_value_idx).toLong\n               \
    \ }\n            }\n            if (even_value<arr.length){\n                even_value\
    \ = arr(even_value_idx).toLong\n            }\n            if (even_value>=0){\n\
    \                if (even_value<arr.length){\n                    even_value =\
    \ arr(even_value_idx).toLong\n                }\n            }\n        }\n  \
    \      if (arr.length>0){\n            if (even_value>=0){\n                if\
    \ (even_value<arr.length){\n                    even_value = arr(even_value_idx).toLong\n\
    \                }\n            }\n            if (even_value<arr.length){\n \
    \               even_value = arr(even_value_idx).toLong\n            }\n     \
    \       if (even_value>=0){\n                if (even_value<arr.length){\n   \
    \                 even_value = arr(even_value_idx).toLong\n                }\n\
    \            }\n        }\n        result(even_value).toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo5gqq4j4.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36midx\e[0m = arr.indexOf(smallest_value)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0midx is already defined as \e[33mvariable\e[0m \e[35midx\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpo5gqq4j4.scala:33:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e\
    [0m \e[36msmallest_value\e[0m = min(arr)\n\e[31m\e[31m   |\e[0m              \
    \               ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((arr : List[Long]))\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo5gqq4j4.scala:43:16 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            \e[33mval\e[0m \e[36meven_value_idx\e[0m\
    \ = arr.indexOf(smallest_value)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0meven_value_idx is already defined as \e[33mvalue\e[0m \e[35meven_value_idx\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpo5gqq4j4.scala:44:45 --------------------\e[0m\e[0m\n\
    \e[31m44 |\e[0m            even_value = arr(even_value_idx).toLong\n\e[31m\e[31m\
    \   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         Found:    Long\n\e[31m   |\e[0m                  \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo5gqq4j4.scala:52:49\
    \ --------------------\e[0m\e[0m\n\e[31m52 |\e[0m                even_valu"
  stdout: ''
  timestamp: 1660010240
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        // Your code here\n\
    \        if(arr.isEmpty) List();\n        val result = arr.foldLeft(List[Long]())((res,\
    \ node) => {\n            val index = res.indexOf(node);\n            if(index\
    \ >= 0 && node.toInt % 2 == 0) res :+ node;\n            else res\n        });\n\
    \        if(result.isEmpty) List()\n        else result.sortBy(l => l).toList\
    \ // get the smallest even value and index\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu2fnzpew.scala:41)\n\tat Problem.main(tmpu2fnzpew.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var minEvenVal = 0\n\
    \        var minIndex = 0\n        var oddValFound = false\n        var evenValFound\
    \ = false\n        var foundVal = Long.MinValue\n        arr.foreach(elem => if\
    \ (!evenValFound && elem % 2 == 0) {\n            evenValFound = true\n      \
    \      foundVal = elem\n        }\n        else if (!oddValFound && elem % 2 !=\
    \ 0) {\n            oddValFound = true\n            foundVal = elem\n        }\n\
    \        else if (evenValFound && oddValFound && (elem < minEvenVal)) {\n    \
    \        minEvenVal = elem\n            minIndex = arr.indexOf(foundVal)\n   \
    \     }\n        else if (evenValFound && (elem < minEvenVal)) {\n           \
    \ minEvenVal = elem\n            minIndex = arr.indexOf(foundVal)\n        }\n\
    \        else if (oddValFound && (elem < minEvenVal)) {\n            minEvenVal\
    \ = elem\n            minIndex = arr.indexOf(foundVal)\n        }\n        else\
    \ {\n            minEvenVal = 0\n            minIndex = 0\n        }\n       \
    \ return arr.drop(minIndex)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpggfv9t2s.scala:59:8 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mreturn\e[0m arr.drop(minIndex)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        ')' expected, but 'return'\
    \ found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpggfv9t2s.scala:44:25\
    \ --------------------\e[0m\e[0m\n\e[31m44 |\e[0m            minEvenVal = elem\n\
    \e[31m\e[31m   |\e[0m                         ^^^^\e[0m\n\e[31m   |\e[0m     \
    \                    Found:    (elem : Long)\n\e[31m   |\e[0m                \
    \         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpggfv9t2s.scala:48:25\
    \ --------------------\e[0m\e[0m\n\e[31m48 |\e[0m            minEvenVal = elem\n\
    \e[31m\e[31m   |\e[0m                         ^^^^\e[0m\n\e[31m   |\e[0m     \
    \                    Found:    (elem : Long)\n\e[31m   |\e[0m                \
    \         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpggfv9t2s.scala:52:25\
    \ --------------------\e[0m\e[0m\n\e[31m52 |\e[0m            minEvenVal = elem\n\
    \e[31m\e[31m   |\e[0m                         ^^^^\e[0m\n\e[31m   |\e[0m     \
    \                    Found:    (elem : Long)\n\e[31m   |\e[0m                \
    \         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010239
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        require(arr.size <=\
    \ 10000)\n        require(arr.forall(_ >= 0))\n        require(arr.forall(_ %\
    \ 2 == 0))\n\n        var minEl = -1\n        var minIndex = -1\n        var evenIndex\
    \ = -1\n        for((elm, index) <- arr.zip(0 until arr.length)){\n          \
    \  if(elm % 2 == 0){\n                if(minEl < 0 || elm > minEl)\n         \
    \           minEl = elm\n                minIndex = index\n            }else{\n\
    \                if(minIndex < 0 || elm < minEl)\n                    minIndex\
    \ = index\n            }\n        }\n        val res = List(minEl, minIndex)\n\
    \        arr filter (_ != minEl) filter (_ != minIndex)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9e0nxf22.scala:40:28\
    \ --------------------\e[0m\e[0m\n\e[31m40 |\e[0m                    minEl = elm\n\
    \e[31m\e[31m   |\e[0m                            ^^^\e[0m\n\e[31m   |\e[0m   \
    \                         Found:    (elm : Long)\n\e[31m   |\e[0m            \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010241
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var smalest_value =\
    \ arr.head\n        var smallest_index = 0\n        var smallest_value = arr.head\n\
    \        var index_of_smallest_value = 0\n\n        for(i <- 0 until arr.length\
    \ - 1) {\n            if(arr.apply(i) % 2 == 0) {\n                if(smallest_value\
    \ > arr.apply(i)) {\n                    index_of_smallest_value = i\n       \
    \             smallest_value = arr.apply(i)\n                }\n            }\n\
    \        }\n        smalest_value = smallest_value\n        smallest_index = index_of_smallest_value\n\
    \        arr.drop(smallest_index)\n\n        return arr.take(smallest_index)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc5vspjok.scala:50)\n\tat Problem.main(tmpc5vspjok.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010242
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val minIndex : mutable.Map[Long,\
    \ Long] = mutable.Map[Long, Long]()\n        val minIndexVal : Long = Long.MaxValue\n\
    \        arr.foreach(e => minIndex(e) match {\n            case 0 => minIndexVal\
    \ = 0\n            case v => minIndexVal > v match {\n                case true\
    \ => minIndexVal += 1\n                case false => minIndexVal = v\n       \
    \     }\n        })\n\n        val evenValues : mutable.Set[Long] = mutable.Set()\n\
    \        arr.foreach(e => evenValues(e) match {\n            case true => evenValues\
    \ += e\n            case false => evenValues += 0\n        })\n        if (evenValues.size\
    \ == 0) Nil\n        else {\n            evenValues.find(ev => ev % 2 == 0)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw89lfiil.scala:30:23 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mminIndex\e[0m : mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m] = mutable.Map[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpw89lfiil.scala:30:49 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mminIndex\e[0m : mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m] = mutable.Map[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                 Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpw89lfiil.scala:33:34\
    \ -----------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mcase\e\
    [0m \e[31m0\e[0m => minIndexVal = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      Reassignment\
    \ to val minIndexVal\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw89lfiil.scala:35:41\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                \e[33mcase\e\
    [0m \e[31mtrue\e[0m => minIndexVal += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m    \
    \                         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         value +=\
    \ is not a member of Long - did you mean minIndexVal.!=?\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpw89lfiil.scala:36:42 -----------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m                \e[33mcase\e[0m \e[31mfalse\e[0m => minIndexVal\
    \ = v\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Reassignment to val minIndexVal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling wi"
  stdout: ''
  timestamp: 1660010241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var max_index = 0;\n\
    \        var max_value = arr(0);\n        var result: List[Long] = Nil\n     \
    \   for(i <- arr.indices) {\n            val curr = arr(i)\n            if(i %\
    \ 2 == 0) {\n                if (curr < max_value) {\n                    max_value\
    \ = curr\n                    max_index = i\n                }\n            }\
    \ else {\n                if (curr == max_value) {\n                    max_index\
    \ = i\n                }\n            }\n        }\n        if(arr.isEmpty ||\
    \ max_index == 0) {\n            result = []\n        } else {\n            result\
    \ = arr.take(max_index + 1)\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwao_n_vj.scala:47:22 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m            result = []\n\e[31m\e[31m   |\e[0m      \
    \                ^\e[0m\n\e[31m   |\e[0m                      an identifier expected,\
    \ but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwao_n_vj.scala:48:8\
    \ ----------------------------\e[0m\e[0m\n\e[31m48 |\e[0m        } \e[33melse\e\
    [0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        '=>' expected,\
    \ but '}' found\n2 errors found\n"
  stdout: ''
  timestamp: 1660010238
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        def getSmallestEven(arr:\
    \ List[Long], index: Int): Option[Long] = {\n            var smallestEven = None\n\
    \            for(i <- 0 until arr.length) if(arr(i) % 2 == 0) smallestEven = Some(arr(i))\n\
    \            if(smallestEven.isDefined) Some(smallestEven.get)\n            else\
    \ getSmallestEven(arr.tail, index+1)\n        }\n        getSmallestEven(arr.takeWhile(_\
    \ != 0), 0)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl2n0ztiz.scala:32:80\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mfor\e[0m(i\
    \ <- \e[31m0\e[0m until arr.length) \e[33mif\e[0m(arr(i) % \e[31m2\e[0m == \e\
    [31m0\e[0m) smallestEven = Some(arr(i))\n\e[31m\e[31m   |\e[0m               \
    \                                                             ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                    Found:    Some[Long]\n\
    \e[31m   |\e[0m                                                    Required: None.type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl2n0ztiz.scala:36:23\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m        getSmallestEven(arr.takeWhile(_\
    \ != \e[31m0\e[0m), \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mOption\e[0m[Long]\n\e[31m   |\e\
    [0m        Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010242
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val ans = arr.groupBy(x\
    \ => (x % 2 == 0)).maxBy(x => x._2)\n        ans.headOption.toList.sortBy(x =>\
    \ x._2)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmps1c_zswc.scala:30:65 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mans\e[0m = arr.groupBy(\e\
    [36mx\e[0m => (x % \e[31m2\e[0m == \e[31m0\e[0m)).maxBy(\e[36mx\e[0m => x._2)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering defined for List[Long]..\n\
    \e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e\
    [35mList[Long]\e[0m](\n\e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[List[Long]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[List[Long]].\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\e[31m\
    \   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660010242
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty) List[Long]()\n\
    \        val ans = arr.sortBy(_ % 2)\n        ans.head % 2 == 0 match {\n    \
    \        case true  => ans.reverse.drop(1).reverse\n            case false =>\
    \ ans\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyxo3gduh.scala:38)\n\tat Problem.main(tmpyxo3gduh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010242
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        var index = 0\n   \
    \     var index_max = 0\n        var smalest_value = 0\n        var smalest_value_count\
    \ = 0\n        var smalest_value_count_index = 0\n        for (i <- arr.indices)\
    \ {\n            if (arr(i) % 2 == 0) {\n                smalest_value = arr(i)\n\
    \                smalest_value_count = smalest_value_count + 1\n             \
    \   if (smalest_value_count > smalest_value_count_index) {\n                 \
    \   index = i\n                    smalest_value_count_index = smalest_value_count\n\
    \                }\n            }\n        }\n        if (smalest_value_count\
    \ == 0) {\n            return Nil\n        }\n        var smalest_value_index\
    \ = index\n        var smalest_value_index_count = 0\n        for (i <- arr.indices)\
    \ {\n            if (arr(i) % 2 == 0) {\n                if (smalest_value_count\
    \ == smalest_value_index_count) {\n                    if (arr(i) == smalest_value)\
    \ {\n                        return arr(index..i)\n                    }\n   \
    \             }\n                smalest_value_index = i\n                smalest_value_index_count\
    \ = smalest_value_index_count + 1\n            }\n        }\n        return Nil\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6zu0npr5.scala:54:41 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m                        \e[33mreturn\e[0m arr(index..i)\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                                   an identifier expected, but '.' found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6zu0npr5.scala:37:35 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                smalest_value = arr(i)\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                         Found:    Long\n\e[31m   |\e[0m                    \
    \            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010242
