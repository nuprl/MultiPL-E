language: scala
name: HumanEval_156_int_to_mini_roman
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var ret = \"\"\n        var i = 0\n        var j = 0\n        var n = 0\n\
    \n        while (i <= number.toInt) {\n            j = number.toInt - i\n\n  \
    \          n = number\n            while (j > (n%10)) {\n                n /=\
    \ 10\n                j /= 10\n            }\n            n += j\n\n         \
    \   while (n > 1000) {\n                ret += \"M\"\n                n /= 100\n\
    \            }\n            while (n > 900) {\n                ret += \"CM\"\n\
    \                n /= 100\n            }\n            while (n > 400) {\n    \
    \            ret += \"D\"\n                n /= 100\n            }\n         \
    \   while (n > 100) {\n                ret += \"CD\"\n                n /= 100\n\
    \            }\n            while (n > 90) {\n                ret += \"C\"\n \
    \               n /= 100\n            }\n            while (n > 40) {\n      \
    \          ret += \"XC\"\n                n /= 100\n            }\n          \
    \  while (n > 10) {\n                ret += \"L\"\n                n /= 100\n\
    \            }\n            while (n > 5) {\n                ret += \"XL\"\n \
    \               n /= 100\n            }\n            while (n > 1) {\n       \
    \         ret += \"X\"\n                n /= 100\n            }\n            while\
    \ (n > 1) {\n                ret += \"I\"\n                n /= 100\n        \
    \    }\n\n            ret += n\n            ret += \"\"\n            i += 1\n\
    \        }\n        return ret\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0qcabmuz.scala:23:16\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            n = number\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                Found:\
    \    (number : Long)\n\e[31m   |\e[0m                Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roms = new mutable.HashMap[Int, String]()\n        val ones = \"I V\
    \ X L C D M S \"\n        val tens = \"X L C D M \"\n        val hundreds = \"\
    C D M \"\n        val thousands = \"M S \"\n        for (i <- 1L to 1000) {\n\
    \            val n = number / (i.toDouble)\n            roms += (i.toLong -> if(n\
    \ > 0) tens.dropRight(1) else ones.dropRight(1))\n            number -= i * i.toDouble\n\
    \        }\n        for (i <- 1L to 1000) {\n            val n = number / (i.toDouble)\n\
    \            roms += (i.toLong -> if(n > 0) hundreds.dropRight(1) else thousands.dropRight(1))\n\
    \            number -= i * i.toDouble\n        }\n        val res = roms map {case\
    \ (num, rom) => (num toString + rom) } reduce (_.concat)\n        if(res.equals(\"\
    \")) \"\" else res.toLower\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpnoewbjjr.scala:22:33 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            roms += (i.toLong -> \e[33mif\e[0m(n > \e\
    [31m0\e[0m) tens.dropRight(\e[31m1\e[0m) \e[33melse\e[0m ones.dropRight(\e[31m1\e\
    [0m))\n\e[31m\e[31m   |\e[0m                                 ^^\e[0m\n\e[31m \
    \  |\e[0m                                 expression expected but \e[31mif\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpnoewbjjr.scala:27:33\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            roms += (i.toLong\
    \ -> \e[33mif\e[0m(n > \e[31m0\e[0m) hundreds.dropRight(\e[31m1\e[0m) \e[33melse\e\
    [0m thousands.dropRight(\e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                \
    \                 ^^\e[0m\n\e[31m   |\e[0m                                 expression\
    \ expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpnoewbjjr.scala:15:23 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mroms\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mInt\e[0m, \e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnoewbjjr.scala:23:19\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            number -= i *\
    \ i.toDouble\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value -= is not a member of Long - did you mean number.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpnoewbjjr.scala:28:19 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            number -= i * i.toDouble\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not\
    \ a member of Long - did you mean number.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var numeral = \"\"\n        for(i <- 1 to number) {\n            numeral\
    \ += miniRoman(number)\n        }\n        numeral.toLowerCase()\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpue6kevp9.scala:16:22\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m(i <- \e\
    [31m1\e[0m to number) {\n\e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      Found:    (number : Long)\n\e[31m   |\e[0m\
    \                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpue6kevp9.scala:17:20 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m            numeral += miniRoman(number)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of String - did you mean String.!=?\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpue6kevp9.scala:17:23 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m            numeral += miniRoman(number)\n\e[31m\e[31m   |\e[0m           \
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found:\
    \ miniRoman\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = romanMap(number)(0)\n        var result : String = \"\"\n  \
    \      for(i <- 0 until roman.length){\n            if(roman(i) == 1) result =\
    \ result + roman(i)\n            else if(roman(i) == 2) result = result + \"i\"\
    \n            else if(roman(i) == 3) result = result + \"ii\"\n            else\
    \ if(roman(i) == 4) result = result + \"iii\"\n            else if(roman(i) ==\
    \ 5) result = result + \"iv\"\n            else if(roman(i) == 6) result = result\
    \ + \"v\"\n            else if(roman(i) == 7) result = result + \"vi\"\n     \
    \       else if(roman(i) == 8) result = result + \"vii\"\n            else if(roman(i)\
    \ == 9) result = result + \"viii\"\n            else if(roman(i) == 10) result\
    \ = result + \"ix\"\n            else if(roman(i) == 11) result = result + \"\
    x\"\n            else if(roman(i) == 12) result = result + \"xi\"\n          \
    \  else if(roman(i) == 13) result = result + \"xii\"\n            else if(roman(i)\
    \ == 14) result = result + \"xiii\"\n            else result = result + \"xiii\"\
    \n        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps6khd1mv.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mroman\e[0m = romanMap(number)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    Not found: romanMap\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = \"MCMXCIV\"\n        val romanNums = roman.map(_.toInt)\n  \
    \      var miniRoman = \"-1\"\n        for((r,n) <- romanNums zip number if n\
    \ < 0){\n            miniRoman = r + miniRoman\n        }\n        for((r,n) <-\
    \ romanNums zip number if n >= 0){\n            miniRoman = n + miniRoman\n  \
    \      }\n        return miniRoman.substring(1, miniRoman.length)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnn1glt1c.scala:18:35\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mfor\e[0m((r,n)\
    \ <- romanNums zip number \e[33mif\e[0m n < \e[31m0\e[0m){\n\e[31m\e[31m   |\e\
    [0m                                   ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                        Found:    (number : Long)\n\e[31m   |\e[0m          \
    \                         Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpnn1glt1c.scala:18:47 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mfor\e[0m((r,n) <- romanNums zip number\
    \ \e[33mif\e[0m n < \e[31m0\e[0m){\n\e[31m\e[31m   |\e[0m                    \
    \                         ^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of\
    \ Nothing, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\
    \e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\
    \e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\
    \e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m  import Char.char2int\n\
    \e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnn1glt1c.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mfor\e[0m((r,n)\
    \ <- romanNums zip number \e[33mif\e[0m n >= \e[31m0\e[0m){\n\e[31m\e[31m   |\e\
    [0m                                   ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                        Found:    (number : Long)\n\e[31m   |\e[0m          \
    \                         Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpnn1glt1c.scala:21:47 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mfor\e[0m((r,n) <- romanNums zip number\
    \ \e[33"
  stdout: ''
  timestamp: 1660010695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanMap = new mutable.HashMap[Long, String]()\n        romanMap (1000)\
    \ =\"M\"\n        romanMap (900) =\"CM\"\n        romanMap (500) =\"D\"\n    \
    \    romanMap (400) =\"CD\"\n        romanMap (100) =\"C\"\n        romanMap (90)\
    \ =\"XC\"\n        romanMap (50) =\"L\"\n        romanMap (40) =\"XL\"\n     \
    \   romanMap (10) =\"X\"\n        romanMap (9) =\"IX\"\n        romanMap (5) =\"\
    V\"\n        romanMap (4) =\"IV\"\n        romanMap (1) =\"I\"\n        val number\
    \ = number%100\n        var roman = \"\"\n        while(number != 0){\n      \
    \      val digit = number%10;\n            roman += romanMap(digit)\n        \
    \    number /= 10;\n        }\n        roman.lowercase\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6f64m8ub.scala:15:27 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mromanMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mLong\e[0m, \e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp6f64m8ub.scala:29:21 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36mnumber\e[0m = number%\e[31m100\e[0m\n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ Recursive \e[33mvalue\e[0m \e[35mnumber\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp6f64m8ub.scala:36:14 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        roman.lowercase\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value lowercase is not a member\
    \ of String\n3 errors found\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val r = new scala.collection.mutable.StringBuilder()\n        var n = (number\
    \ / 1000l).toInt\n        var m = number % 1000l\n        var num = 0l\n     \
    \   var isNeg = (number < 0l)\n        var i = 1l\n        while(m > 1000) {\n\
    \            m = m / 1000l\n            num += 1l\n        }\n        while(n\
    \ > 1) {\n            if(n % 10 == 0) {\n                m.toString.toCharArray.foreach(\
    \ c => r += c.toString.toUpperCase)\n                r += m.toString.toUpperCase\n\
    \                m = m / 10l\n                num -= 1\n            } else if(n\
    \ % 10 == 1) {\n                r += m.toString.toUpperCase\n                m\
    \ = m / 10l\n                num -= 1\n            } else {\n                r\
    \ += m.toString.toUpperCase\n                m = m / 10l\n                num\
    \ -= 1\n            }\n            n -= 1\n        }\n        if(isNeg) r += \"\
    -\"\n        r += num.toString\n        r.toString.toLowerCase\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7tr8d0pb.scala:27:58\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m                m.toString.toCharArray.foreach(\
    \ \e[36mc\e[0m => r += c.toString.toUpperCase)\n\e[31m\e[31m   |\e[0m        \
    \                                                  ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                        Found:\
    \    String\n\e[31m   |\e[0m                                                 \
    \       Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7tr8d0pb.scala:28:21\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                r += m.toString.toUpperCase\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Found:    String\n\e[31m   |\e[0m             \
    \        Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7tr8d0pb.scala:32:21\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m                r += m.toString.toUpperCase\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Found:    String\n\e[31m   |\e[0m             \
    \        Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7tr8d0pb.scala:36:21\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m                r += m.toString.toUpperCase\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Found:    String\n\e[31m   |\e[0m             \
    \        Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7tr8d0pb.scala:42:23\
    \ --------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mif\e[0m(isNeg)\
    \ r += \e[31m\"-\"\e[0m\n\e[31m\e[31m   |\e[0m                       ^^^\e[0m\n\
    \e[31m   |\e[0m                       Found:    (\e"
  stdout: ''
  timestamp: 1660010694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def miniRoman(x : int, maxium : int) : String = {\n            val result\
    \ = \"\"\n            val a = scala.math.pow( 10, x )\n            val b = scala.math.pow(\
    \ 10, maxium )\n            for( i <- 1 to maxium ) {\n                if( i %\
    \ 2 != 0 ) {\n                    result += scala.math.floor( x % b ) / b\n  \
    \              }\n                x /= a\n            }\n            return result\n\
    \        }\n        return miniRoman(number, 1000)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw26yesqd.scala:15:26 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mdef\e[0m \e[36mminiRoman\e[0m(\e[36mx\e\
    [0m : \e[35mint\e[0m, \e[36mmaxium\e[0m : \e[35mint\e[0m) : \e[35mString\e[0m\
    \ = {\n\e[31m\e[31m   |\e[0m                          ^^^\e[0m\n\e[31m   |\e[0m\
    \                          Not found: type int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpw26yesqd.scala:15:40 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mdef\e[0m \e[36mminiRoman\e[0m(\e[36mx\e\
    [0m : \e[35mint\e[0m, \e[36mmaxium\e[0m : \e[35mint\e[0m) : \e[35mString\e[0m\
    \ = {\n\e[31m\e[31m   |\e[0m                                        ^^^\e[0m\n\
    \e[31m   |\e[0m                                        Not found: type int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw26yesqd.scala:21:27\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m                    result\
    \ += scala.math.floor( x % b ) / b\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of String - did you mean\
    \ result.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman: Set[Char] = Set( 'I', 'IV', 'V', 'IX', 'XL', 'XC' );\n      \
    \  val digits: Set[Int] = Set(1, 5, 10, 50, 100, 500, 1000, 5000);\n        val\
    \ numerals: Map[Int, String] = Map(\n            1 -> \"I\",\n            5 ->\
    \ \"V\",\n            10 -> \"X\",\n            50 -> \"L\",\n            100\
    \ -> \"C\",\n            500 -> \"D\",\n            1000 -> \"M\",\n         \
    \   5000 -> \"C\"\n        );\n        val result = roman.map( x => digits.contains(\
    \ x.toInt ) match {\n            case true => numerals(x.toInt)\n            case\
    \ false => x.toString\n        }).mkString\n        result.toLowerCase\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpq2t3t_ae.scala:15:41 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mroman\e[0m: \e[35mSet\e\
    [0m[\e[35mChar\e[0m] = Set( \e[31m'I'\e[0m, \e[31m'IV\e[0m', \e[31m'V'\e[0m, \e\
    [31m'IX\e[0m', \e[31m'XL\e[0m', \e[31m'XC\e[0m' );\n\e[31m\e[31m   |\e[0m    \
    \                                     ^\e[0m\n\e[31m   |\e[0msymbol literal 'IV\
    \ is no longer supported,\n\e[31m   |\e[0muse a string literal \"IV\" or an application\
    \ Symbol(\"IV\") instead,\n\e[31m   |\e[0mor enclose in braces '{IV} if you want\
    \ a quoted expression.\n\e[31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n\e[31m\e[31m-- Error: /tmp/tmpq2t3t_ae.scala:15:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m15 |\e[0m       \
    \ \e[33mval\e[0m \e[36mroman\e[0m: \e[35mSet\e[0m[\e[35mChar\e[0m] = Set( \e[31m'I'\e\
    [0m, \e[31m'IV\e[0m', \e[31m'V'\e[0m, \e[31m'IX\e[0m', \e[31m'XL\e[0m', \e[31m'XC\e\
    [0m' );\n\e[31m\e[31m   |\e[0m                                            ^\e\
    [0m\n\e[31m   |\e[0m                                            unclosed character\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpq2t3t_ae.scala:15:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mroman\e[0m: \e[35mSet\e\
    [0m[\e[35mChar\e[0m] = Set( \e[31m'I'\e[0m, \e[31m'IV\e[0m', \e[31m'V'\e[0m, \e\
    [31m'IX\e[0m', \e[31m'XL\e[0m', \e[31m'XC\e[0m' );\n\e[31m\e[31m   |\e[0m    \
    \                                                   ^\e[0m\n\e[31m   |\e[0m  \
    \                                            unclosed character literal\n\e[31m\e\
    [31m-- Error: /tmp/tmpq2t3t_ae.scala:15:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mroman\e[0m: \e[35mSet\e\
    [0m[\e[35mChar\e[0m] = Set( \e[31m'I'\e[0m, \e[31m'IV\e[0m', \e[31m'V'\e[0m, \e\
    [31m'IX\e[0m', \e[31m'XL\e[0m', \e[31m'XC\e[0m' );\n\e[31m\e[31m   |\e[0m    \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                              unclosed character literal\n\
    4 errors foun"
  stdout: ''
  timestamp: 1660010689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = scala.collection.mutable.StringBuilder()\n        var i = 3\n\
    \        while(i > 0 && number > 0){\n            roman += intToMiniRoman(number\
    \ % i)\n            i /= 100\n            number /= 100\n        }\n        roman.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu7bsweth.scala:18:35\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            roman += intToMiniRoman(number\
    \ % i)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    String\n\e[31m   |\e[0m   \
    \                  Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpu7bsweth.scala:20:19 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m            number /= \e[31m100\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value /= is not a member of Long - did you mean\
    \ number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     //  Represent number as string array of (numeral, value)\n        val numberStringArray\
    \ = (1l..number).map(i => s\"${i}${i}\").toArray\n        // Calculate string\
    \ array of (denominator, numerators)\n        val numeratorsStringArray = (1l..number).map(i\
    \ => s\"${i}\").toArray\n        val sum : Int = numeratorsStringArray.map(_.length).sum\n\
    \        val numeratorsStringBuilder = Stream.concat(Stream.from(0)(numeratorsStringArray),\
    \ numeratorsStringArray.tail).map(_ + \"\").toArray\n        val denominatorsStringBuilder\
    \ = Stream.from(0)(numeratorsStringArray.map(_.length).toArray).map(_ + \"\").toArray\n\
    \        val numeratorsStringBuilderToArray = Stream.from(numeratorsStringBuilder)(_.toArray).toArray\n\
    \        val denominatorsStringBuilderToArray = Stream.from(denominatorsStringBuilder)(_.toArray).toArray\n\
    \        val numeratorsStringBuilderToArrayLength = numeratorsStringBuilderToArray.length\n\
    \        val denominatorsStringBuilderToArrayLength = denominatorsStringBuilderToArray.length\n\
    \        val numberStringBuilderLength = numberStringArray.length\n        //\
    \ Calculate numerators and denominators from string arrays\n        var numerators\
    \ : Array[String] = null\n        var denominators : Array[String] = null\n  \
    \      numerators = numeratorsStringBuilderToArray.slice(0, numeratorsStringBuilderToArrayLength).map(x\
    \ => x.padTo(sum, \"0\") + x)\n        denominators = denominatorsStringBuilderToArray.slice(0,\
    \ denominatorsStringBuilderToArrayLength).map(x => x.padTo(sum, \"0\") + x)\n\
    \        val numeratorsLength = numerators.length\n        val denominatorsLength\
    \ = denominators.length\n        // Remove leading zeros from numerators and denominators\n\
    \        var numeratorsLength = numeratorsLength\n        var denominatorsLength\
    \ = denominatorsLength\n        while (numeratorsLength > 0 && numerators(numeratorsLength\
    \ - 1) == \"\") numeratorsLength = numeratorsLength - 1\n        while (denominatorsLength\
    \ > 0 && denominators(denominatorsLength - 1) == \"\") denominatorsLength = denominatorsLength\
    \ - 1\n        val minLength = min(numeratorsLength, denominatorsLength)\n   \
    \     val newNumerators = numerators.slice(0, minLength)\n        val newDenominators\
    \ = denominators.slice(0, minLength)\n        // Determine new denominators and\
    \ numerators from new denominators\n        var newDenominatorsLength = newDenominators.length\n\
    \        var newNumeratorsLength = newNumerators.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpranglu4a.scala:16:36 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnumberStringArray\e[0m =\
    \ (\e[31m1l\e[0m..number).map(\e[36mi\e[0m => \e[31ms\"\e[0m${i}${i}\e[31m\"\e\
    [0m).toArray\n\e[31m\e[31m   |\e[0m                                    ^\e[0m\n\
    \e[31m   |\e[0m                                   an identifier expected, but\
    \ '.' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpranglu4a.scala:18:40\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mnumeratorsStringArray\e[0m = (\e[31m1l\e[0m..number).map(\e[36mi\e[0m\
    \ => \e[31ms\"\e[0m${i}\e[31m\"\e[0m).toArray\n\e[31m\e[31m   |\e[0m         \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \             an identifier expected, but '.' found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpranglu4a.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mvar\e[0m \e[36mnumeratorsLength\e[0m = numeratorsLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mnumeratorsLength is already defined as \e[33mvalue\e[0m \e[35mnumeratorsLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpranglu4a.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mvar\e[0m \e[36mdenominatorsLength\e[0m = denominatorsLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mdenominatorsLength is already defined as \e[33mvalue\e[0m \e[35mdenominatorsLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpranglu4a.scala:20:66 --------------------\e[0m\e[0m\n\
    \e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnumeratorsStringBuilder\e[0m = Stream.concat(Stream.from(\e\
    [31m0\e[0m)(numeratorsStringArray), numeratorsStringArray.tail).map(_ + \e[31m\"\
    \"\e[0m).toArray\n\e[31m\e[31m   |\e[0m                                   "
  stdout: ''
  timestamp: 1660010695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val num = number.toInt\n        // the length of roman numeral string\n\
    \        val romanLength = 1\n        val romanString = new Array[Char](romanLength)\n\
    \        val romanStringMutable = mutable.ArrayBuffer(romanString)\n        val\
    \ romanValues = mutable.ArrayBuffer(\n            (100, \"M\"),\n            (90,\
    \ \"CM\"),\n            (50, \"D\"),\n            (40, \"CD\"),\n            (10,\
    \ \"C\"),\n            (9, \"XC\"),\n            (5, \"L\"),\n            (4,\
    \ \"XL\"),\n            (1, \"X\")\n            )\n        val romanValueIndex\
    \ = romanValues.length - 1\n\n        val divisor = num / romanValueIndex\n  \
    \      romanStringMutable(0) = if (divisor > 0) romanValues(romanValueIndex -\
    \ divisor)\n            else \"M\"\n        num %= romanValueIndex\n\n       \
    \ val remainder = num % romanValueIndex\n        romanStringMutable(1) = if (remainder\
    \ > 0) romanValues(remainder)\n            else \"M\"\n        romanString.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd7wkczl5.scala:19:33 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mromanStringMutable\e[0m\
    \ = mutable.ArrayBuffer(romanString)\n\e[31m\e[31m   |\e[0m                  \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \ Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd7wkczl5.scala:20:26\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mromanValues\e[0m = mutable.ArrayBuffer(\n\e[31m\e[31m   |\e[0m           \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd7wkczl5.scala:36:12\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        num %= romanValueIndex\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        value %= is not\
    \ a member of Int - did you mean num.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romans = Map(\n            1 -> \"I\",\n            5 -> \"V\",\n  \
    \          10 -> \"X\",\n            50 -> \"L\",\n            100 -> \"C\",\n\
    \            500 -> \"D\",\n            1000 -> \"M\"\n        )\n        val\
    \ roman = romans.values.drop(romans.indexOf(romans.max)).last\n        val numString\
    \ = number.toString.toInt\n        val romanNum = romans(numString).take(roman.length)\n\
    \        val result = roman.zip(romanNum).map(x => x._1 + x._2).mkString(\"\"\
    )\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpalpzcfa4.scala:24:46 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mroman\e[0m = romans.values.drop(romans.indexOf(romans.max)).last\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue indexOf is not a member of scala.collection.mutable.Map[Int,\
    \ String]\n1 error found\n"
  stdout: ''
  timestamp: 1660010693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Convert the number to String and collect results in a list\n        val\
    \ numberString = number.toString\n        val result = numberString.dropRightWhile(_\
    \ <= '1').dropWhile(_ <= '0').takeWhile(_ != '0')\n        // Convert the list\
    \ to a string, return it in lowercase\n        return result.mkString.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprhxctjn3.scala:17:34 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = numberString.dropRightWhile(_\
    \ <= \e[31m'1'\e[0m).dropWhile(_ <= \e[31m'0'\e[0m).takeWhile(_ != \e[31m'0'\e\
    [0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     value dropRightWhile is not a member\
    \ of String\n1 error found\n"
  stdout: ''
  timestamp: 1660010691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman : ListBuffer[Char] = new ListBuffer[Char]()\n        // We first\
    \ convert the number to a string\n        var numberString = number.toString\n\
    \        var index = 0\n        while(index < numberString.length) {\n       \
    \     val c = numberString(index)\n            if (c == '0') {\n             \
    \   roman.append('I')\n            } else if (c == '1') {\n                roman.append('V')\n\
    \            } else if (c == '5') {\n                roman.append('X')\n     \
    \       } else if (c == '9') {\n                roman.append('IX')\n         \
    \   } else {\n                roman.append(c)\n            }\n            index\
    \ += 1\n        }\n        val miniRoman = roman.mkString\n        miniRoman.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp2zvs2q6l.scala:28:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                roman.append(\e[31m'IX\e[0m')\n\e[31m\e\
    [31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m         \
    \                       unclosed character literal\n\e[31m\e[31m-- Error: /tmp/tmp2zvs2q6l.scala:28:29\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \         roman.append(\e[31m'IX\e[0m')\n\e[31m\e[31m   |\e[0m               \
    \              ^\e[0m\n\e[31m   |\e[0msymbol literal 'IX is no longer supported,\n\
    \e[31m   |\e[0muse a string literal \"IX\" or an application Symbol(\"IX\") instead,\n\
    \e[31m   |\e[0mor enclose in braces '{IX} if you want a quoted expression.\n\e\
    [31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2zvs2q6l.scala:28:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                roman.append(\e\
    [31m'IX\e[0m')\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mappend\e\
    [0m in \e[33mtrait\e[0m \e[35mBuffer\e[0m with types\n\e[31m   |\e[0m (elems:\
    \ Char*): (roman : collection.mutable.ListBuffer[Char])\n\e[31m   |\e[0m (elem:\
    \ Char): (roman : collection.mutable.ListBuffer[Char])\n\e[31m   |\e[0mmatch arguments\
    \ (Symbol)\n3 errors found\n"
  stdout: ''
  timestamp: 1660010689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romans = mutable.Map.empty[Long, String]\n\n        while(number > 0)\
    \ {\n            romans(number) = romans.getOrElse(number, \"\")\n           \
    \ number = number / 100\n\n        }\n        romans.map { case (k, v) => k +\
    \ \"M\" + v }\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnjcx22d_.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mromans\e[0m = mutable.Map.empty[\e\
    [35mLong\e[0m, \e[35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpnjcx22d_.scala:19:19 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            number = number / \e[31m100\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \   Reassignment to val number\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanArray = Array(\"\", \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\"\
    , \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\")\n        val romanToIntArray\
    \ = romanArray.zip(romanArray).map(c => (c.getInt(0), c.getInt(1))).toArray\n\
    \        val integer = BigInt(number)\n        val numeral = romanToIntArray.map(i\
    \ => integer.getAndRemainder(BigInt(i._2))).toList.reverse.foldLeft(\"\")(_ +\
    \ _ + _)\n        numeral.toLowerCase + numeral(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6v2zoqy2.scala:16:69 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mromanToIntArray\e[0m = romanArray.zip(romanArray).map(\e\
    [36mc\e[0m => (c.getInt(\e[31m0\e[0m), c.getInt(\e[31m1\e[0m))).toArray\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \   ^^^^^^^^\e[0m\n\e[31m   |\e[0m                        value getInt is not\
    \ a member of (String, String)\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6v2zoqy2.scala:16:82\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mromanToIntArray\e[0m = romanArray.zip(romanArray).map(\e[36mc\e[0m => (c.getInt(\e\
    [31m0\e[0m), c.getInt(\e[31m1\e[0m))).toArray\n\e[31m\e[31m   |\e[0m         \
    \                                                                       ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        value getInt is not a member of (String,\
    \ String)\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6v2zoqy2.scala:18:55\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mnumeral\e[0m = romanToIntArray.map(\e[36mi\e[0m => integer.getAndRemainder(BigInt(i._2))).toList.reverse.foldLeft(\e\
    [31m\"\"\e[0m)(_ + _ + _)\n\e[31m\e[31m   |\e[0m                             \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \            value getAndRemainder is not a member of BigInt\n\e[31m\e[31m-- [E051]\
    \ Reference Error: /tmp/tmp6v2zoqy2.scala:18:71 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mnumeral\e[0m = romanToIntArray.map(\e\
    [36mi\e[0m => integer.getAndRemainder(BigInt(i._2))).toList.reverse.foldLeft(\e\
    [31m\"\"\e[0m)(_ + _ + _)\n\e[31m\e[31m   |\e[0m                             \
    \                                          ^^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous\
    \ overload. The overloaded alternatives of \e[33mmethod\e[0m \e[35mapply\e[0m\
    \ in \e[33mobject\e[0m \e[35mBigInt\e[0m with types\n\e[31m   |\e[0m (x: java.math.BigInteger):\
    \ BigInt\n\e[31m   |\e[0m (x: String): BigInt\n\e[31m   |\e[0m (x: Array[Byte]):\
    \ BigInt\n\e[31m   |\e[0m (l: Long): BigInt\n\e[31m   |\e[0m (i: Int): BigInt"
  stdout: ''
  timestamp: 1660010694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = List(\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\"\
    , \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\"\
    , \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\"\
    , \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXI\", \"XXII\"\
    , \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"\
    XXX\")\n        val romanNum = List(\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\"\
    , \"DC\", \"DCC\", \"DCCC\", \"CM\", \"M\", \"MM\", \"MMM\")\n        val string\
    \ = \"\"\n        if (number > 999) {\n            throw new IllegalArgumentException(\"\
    number must be less than or equal to 999\")\n        } else {\n            number\
    \ match {\n                case i if i <= 100 => string += roman(number/100) +\
    \ \"V\"\n                case i if i <= 500 => string += roman(number/1000) +\
    \ \"IX\"\n                case i if i <= 1000 => string += roman(number/100) +\
    \ \"X\"\n                case _ => throw new IllegalArgumentException(\"number\
    \ must be between 1 and 999\")\n            }\n        }\n        return string.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp29o5eiay.scala:22:45 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mcase\e[0m i \e[33mif\e[0m i <=\
    \ \e[31m100\e[0m => string += roman(number/\e[31m100\e[0m) + \e[31m\"V\"\e[0m\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            value += is not a member of String - did you mean string.!=?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp29o5eiay.scala:22:54 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mcase\e[0m i \e[33mif\e[0m i <=\
    \ \e[31m100\e[0m => string += roman(number/\e[31m100\e[0m) + \e[31m\"V\"\e[0m\n\
    \e[31m\e[31m   |\e[0m                                                      ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                      Found:\
    \    Long\n\e[31m   |\e[0m                                                   \
    \   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp29o5eiay.scala:23:45\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33mcase\e\
    [0m i \e[33mif\e[0m i <= \e[31m500\e[0m => string += roman(number/\e[31m1000\e\
    [0m) + \e[31m\"IX\"\e[0m\n\e[31m\e[31m   |\e[0m                              \
    \        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ String - did you mean string.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp29o5eiay.scala:23:54 --------------------\e[0m\e[0m\n\e[31m23 |\e[0m\
    \                \e[33mcase\e[0m i \e[33mif\e[0m i <= \e[31m500\e[0m => string\
    \ += roman(number/\e[31m1000\e[0m) + \e[31m\"IX\"\e[0m\n\e[31m\e[31m   |\e[0m\
    \                                                      ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                      Found:    Long\n\
    \e[31m   |\e[0m                                                      Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp29o5eiay.scala:24:46\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mcase\e\
    ["
  stdout: ''
  timestamp: 1660010694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val result = new StringBuilder\n        val numerals = Array(\"\", \"c\"\
    , \"d\", \"l\", \"x\", \"c\", \"l\")\n        val letters = Array(\"\", \"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\")\n        var index\
    \ = 0\n        var current = number % 1000\n        while(current > 0) {\n   \
    \         if(current > 999) {\n                index += 3\n                current\
    \ = current / 1000\n            } else {\n                index += 2\n       \
    \         current = current / 100\n            }\n            result.append(letters(index))\
    \ // append this letter\n            result.append(numerals(current)) // append\
    \ this numeral\n        }\n        return result.toString()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4guodkfd.scala:29:35\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            result.append(numerals(current))\
    \ \e[34m// append this numeral\e[0m\n\e[31m\e[31m   |\e[0m                   \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    (current : Long)\n\e[31m   |\e[0m                             \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanArray = new Array[String](11)\n        romanArray(0) =\"M\";romanArray(1)\
    \ =\"C\";romanArray(2) =\"L\";romanArray(3) =\"X\";romanArray(4) =\"V\";romanArray(5)\
    \ =\"I\";romanArray(6) =\"D\";romanArray(7) =\"M\";romanArray(8) =\"C\";romanArray(9)\
    \ =\"L\";romanArray(10) =\"X\";\n        val index = number / 1000\n        val\
    \ romanIndex = number % 1000\n        romanArray(romanIndex)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsri07n9l.scala:19:19\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        romanArray(romanIndex)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \              Found:    (romanIndex : Long)\n\e[31m   |\e[0m                \
    \   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010692
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = mutable.ListBuffer.empty[String]\n        var i = 0\n      \
    \  while (i < number) {\n            var val = number\n            while (val\
    \ > 0) {\n                val remainder = val % 10\n                roman.append(remainder)\n\
    \                val val /= 10\n            }\n            i += 1\n        }\n\
    \        return roman.toString.toLowerCase\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmphveakbzr.scala:18:16 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mvar\e[0m \e[33mval\e[0m = number\n\e\
    [31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m                pattern\
    \ expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphveakbzr.scala:19:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mwhile\e\
    [0m (\e[33mval\e[0m > \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                 \
    \  ^^^\e[0m\n\e[31m   |\e[0m                   expression expected but \e[31mval\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphveakbzr.scala:20:32\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m                \e[33mval\e\
    [0m \e[36mremainder\e[0m = \e[33mval\e[0m % \e[31m10\e[0m\n\e[31m\e[31m   |\e\
    [0m                                ^^^\e[0m\n\e[31m   |\e[0m                 \
    \               expression expected but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E032] Syntax Error: /tmp/tmphveakbzr.scala:22:20 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mval\e[0m \e[33mval\e[0m /= \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m      \
    \              pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmphveakbzr.scala:15:20 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mroman\e[0m = mutable.ListBuffer.empty[\e[35mString\e\
    [0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def miniRoman(n : Long) : String = {\n            if(n >= 1000000000l) miniRoman(n\
    \ / 1000000000l) + 'M'\n            else if(n >= 1000000l) miniRoman(n / 1000000l)\
    \ + 'CM'\n            else if(n >= 1000l) miniRoman(n / 1000l) + 'CD'\n      \
    \      else if(n >= 100l) miniRoman(n / 100l) + 'XC'\n            else if(n >=\
    \ 10l) miniRoman(n / 10l) + 'L'\n            else miniRoman(n % 10) + 'X'\n  \
    \      }\n        val arr = mutable.ArrayBuffer.empty[(Int, String)]\n       \
    \ var i = number\n        while(i >= 1) {\n            arr += ((i / 10, miniRoman(i\
    \ % 10)))\n            i /= 10\n        }\n        arr.toSeq.reverse.map(x =>\
    \ x._2).mkString.toLowerCase\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpshaitrhy.scala:17:64 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m(n >= \e[31m1000000l\e\
    [0m) miniRoman(n / \e[31m1000000l\e[0m) + \e[31m'CM\e[0m'\n\e[31m\e[31m   |\e\
    [0m                                                                ^\e[0m\n\e\
    [31m   |\e[0m                                              unclosed character\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpshaitrhy.scala:17:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m(n >= \e[31m1000000l\e\
    [0m) miniRoman(n / \e[31m1000000l\e[0m) + \e[31m'CM\e[0m'\n\e[31m\e[31m   |\e\
    [0m                                                             ^\e[0m\n\e[31m\
    \   |\e[0msymbol literal 'CM is no longer supported,\n\e[31m   |\e[0muse a string\
    \ literal \"CM\" or an application Symbol(\"CM\") instead,\n\e[31m   |\e[0mor\
    \ enclose in braces '{CM} if you want a quoted expression.\n\e[31m   |\e[0mFor\
    \ now, you can also `import language.deprecated.symbolLiterals` to accept\n\e\
    [31m   |\e[0mthe idiom, but this possibility might no longer be available in the\
    \ future.\n\e[31m\e[31m-- Error: /tmp/tmpshaitrhy.scala:18:58 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m(n >= \e[31m1000l\e\
    [0m) miniRoman(n / \e[31m1000l\e[0m) + \e[31m'CD\e[0m'\n\e[31m\e[31m   |\e[0m\
    \                                                          ^\e[0m\n\e[31m   |\e\
    [0m                                              unclosed character literal\n\e\
    [31m\e[31m-- Error: /tmp/tmpshaitrhy.scala:19:56 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m(n >= \e[31m100l\e\
    [0m) miniRoman(n / \e[31m100l\e[0m) + \e[31m'XC\e[0m'\n\e[31m\e[31m   |\e[0m \
    \                                                       ^\e[0m\n\e[31m   |\e[0m\
    \                                              unclosed character literal\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpshaitrhy.scala:23:18 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = mutable.ArrayBuffer.empty[(\e\
    [35mInt\e[0m, \e["
  stdout: ''
  timestamp: 1660010688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number < 1 || number > 1000l) throw new RuntimeException(\"number out\
    \ of range\")\n        var romanNumber = \"I\"\n        var previousValue = 0\n\
    \        while (number > 0) {\n            var currentValue = number % 100l\n\
    \            var currentSymbol = romanNumber.charAt(romanNumber.length - 1)\n\
    \            var currentPreviousValue = previousValue % 10l\n            previousValue\
    \ = currentValue\n            romanNumber += currentSymbol\n            number\
    \ -= currentValue\n            var nextValue = currentValue * 100l\n         \
    \   var nextSymbol = romanNumber.charAt(romanNumber.length - 1)\n            var\
    \ nextPreviousValue = previousValue * 10l\n            previousValue = nextValue\n\
    \            romanNumber += nextSymbol\n            number -= nextValue\n    \
    \    }\n        return romanNumber\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptuut_nrp.scala:22:28\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            previousValue = currentValue\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                            Found:    (currentValue : Long)\n\e[31m   |\e[0m\
    \                            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmptuut_nrp.scala:24:19 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            number -= currentValue\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmptuut_nrp.scala:28:28 --------------------\e[0m\e[0m\n\e[31m28 |\e[0m\
    \            previousValue = nextValue\n\e[31m\e[31m   |\e[0m                \
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            Found:\
    \    (nextValue : Long)\n\e[31m   |\e[0m                            Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptuut_nrp.scala:30:19\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            number -= nextValue\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ -= is not a member of Long - did you mean number.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = number.toRoman\n        val chars = roman.split('')\n      \
    \  val index = chars.indexOf(\"i\");\n        val newChars = chars.filterNot(_\
    \ == \"i\")\n        val numString = \"\" + chars(0).toInt + chars(1).toInt +\
    \ chars(2).toInt + chars(3).toInt +\n            chars(4).toInt + chars(5).toInt\
    \ + chars(6).toInt + chars(7).toInt + chars(8).toInt + chars(9).toInt;\n     \
    \   val newNum = numString + chars(index)\n        newChars.mkString(\"\") + newNum.toLower\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpo9o274wc.scala:16:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mchars\e[0m = roman.split('')\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m \
    \                               empty character literal\n\e[31m\e[31m-- [E018]\
    \ Syntax Error: /tmp/tmpo9o274wc.scala:17:18 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = chars.indexOf(\e\
    [31m\"i\"\e[0m);\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e\
    [0m                  expression expected but \e[31m=\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo9o274wc.scala:15:27 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mroman\e[0m = number.toRoman\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    value toRoman is not a member of Long\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpo9o274wc.scala:17:8 -------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = chars.indexOf(\e\
    [31m\"i\"\e[0m);\n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e[31m   |\e[0m     \
    \   Not found: 'val\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \   var currentChar = scala.util.Try(number.toString).getOrElse(\"I\")\n     \
    \ var numOfChars = 0\n      var roman = \"\"\n      var lastChar = \"\"\n    \
    \  while(currentChar.length >= 1){\n        lastChar = currentChar\n        if(currentChar\
    \ >= 1000000000000l)\n          currentChar = scala.util.Try(currentChar.toString.dropRight(9)).getOrElse(\"\
    \")\n        roman = roman.dropRight(1)\n        roman = roman + lastChar\n  \
    \      numOfChars = numOfChars + 1\n      }\n      while(numOfChars > 0){\n  \
    \      roman = roman + currentChar\n        currentChar = scala.util.Try(currentChar.toString.dropRight(1)).getOrElse(\"\
    \")\n        numOfChars = numOfChars - 1\n      }\n      roman = roman.dropRight(1)\n\
    \      return roman\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvmz16an3.scala:21:26\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m(currentChar\
    \ >= \e[31m1000000000000l\e[0m)\n\e[31m\e[31m   |\e[0m                       \
    \   ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          Found:    (\e\
    [31m1000000000000L\e[0m : Long)\n\e[31m   |\e[0m                          Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romans = Map(1000 -> \"M\", 900  -> \"CM\", 500  -> \"D\", 400  -> \"\
    CD\", 100  -> \"C\", 90   -> \"XC\", 50   -> \"L\", 40   -> \"XL\", 10   -> \"\
    X\", 9    -> \"IX\", 5    -> \"V\", 4    -> \"IV\", 1    -> \"I\")\n        val\
    \ n = number\n        val roman = \"\"\n        var remainder = n\n        while\
    \ (n > 0) {\n            roman += romans(n % 100l)\n            n /= 100l\n  \
    \      }\n        remainder = remainder % 10\n        romans += (remainder, \"\
    X\")\n        (romans.reverse mkString \"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeu7lsvg8.scala:20:18 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            roman += romans(n % \e[31m100l\e[0m)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of String - did you mean roman.!=?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpeu7lsvg8.scala:20:28 --------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m            roman += romans(n % \e[31m100l\e[0m)\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      Found:    Long\n\e[31m   |\e[0m                       \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeu7lsvg8.scala:21:14\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            n /= \e[31m100l\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ /= is not a member of Long - did you mean n.!=?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpeu7lsvg8.scala:24:19 --------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m        romans += (remainder, \e[31m\"X\"\e[0m)\n\e[31m\e[31m \
    \  |\e[0m                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \ Found:    (remainder : Long)\n\e[31m   |\e[0m                   Required: (Int,\
    \ String)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeu7lsvg8.scala:24:30\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        romans += (remainder,\
    \ \e[31m\"X\"\e[0m)\n\e[31m\e[31m   |\e[0m                              ^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    (\e[32m\"X\"\e[0m\
    \ : String)\n\e[31m   |\e[0m                              Required: (Int, String)\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeu7lsvg8.scala:25:16\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        (romans.reverse mkString\
    \ \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m         ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue reve"
  stdout: ''
  timestamp: 1660010704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var numerals = scala.collection.mutable.ListBuffer.empty[String]\n     \
    \   var i = 0\n        var isDigit = true\n        var isUpper = false\n     \
    \   var isOdd = false\n        while(number != 0) {\n            val x = number\
    \ % 10\n            if(x != 0) {\n                numerals += if (isUpper) x.toString()\
    \ else x.toString.toLowerCase()\n                number /= 10\n            }\n\
    \            else {\n                numerals += if (isUpper) x.toString() else\
    \ x.toString.toLowerCase()\n                if(isOdd) {\n                    numerals\
    \ += \"i\"\n                }\n                else {\n                    numerals\
    \ += \"c\"\n                }\n                isDigit = false\n             \
    \   isUpper = false\n                isOdd = true\n                number /= 10\n\
    \            }\n        }\n        numerals.reverse.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpig8gd6qj.scala:23:28 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                numerals += \e[33mif\e[0m (isUpper) x.toString()\
    \ \e[33melse\e[0m x.toString.toLowerCase()\n\e[31m\e[31m   |\e[0m            \
    \                ^^\e[0m\n\e[31m   |\e[0m                            expression\
    \ expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpig8gd6qj.scala:27:28 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m                numerals += \e[33mif\e[0m (isUpper) x.toString() \e[33melse\e\
    [0m x.toString.toLowerCase()\n\e[31m\e[31m   |\e[0m                          \
    \  ^^\e[0m\n\e[31m   |\e[0m                            expression expected but\
    \ \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpig8gd6qj.scala:24:23\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                number /=\
    \ \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m              value /= is not a member of Long - did you mean number.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpig8gd6qj.scala:37:23 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                number /= \e[31m10\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value /=\
    \ is not a member of Long - did you mean number.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // TODO: fill in the code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpixwzym19.scala:14:49\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m    \e[33mdef\e[0m \e[36mintToMiniRoman\e\
    [0m(\e[36mnumber\e[0m : \e[35mLong\e[0m) : \e[35mString\e[0m = {\n\e[31m\e[31m\
    \   |\e[0m                                                 ^\e[0m\n\e[31m   |\e\
    [0m                                                 Found:    Unit\n\e[31m   |\e\
    [0m                                                 Required: String\n\e[31m15\
    \ |\e[0m        \e[34m// TODO: fill in the code here\e[0m\n\e[31m16 |\e[0m   \
    \ }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number == 0 || number == 1) {\n            return \"i\"\n        }\n\
    \        if (number == 12) {\n            return \"xix\"\n        }\n        if\
    \ (number < 1000 || number > 9999) {\n            throw new IllegalArgumentException(\"\
    Invalid number \" + number)\n        }\n        var sum : Int = 0\n        val\
    \ str = new StringBuilder\n        for (i <- 1 until number) {\n            if\
    \ (number % i == 0) {\n                sum += i\n                str.append(intToMiniRoman(i))\n\
    \            }\n        }\n        if (sum < number) {\n            str.append(\"\
    vi\")\n        } else {\n            str.append(\"ix\")\n        }\n        str.result()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwdmgk7hc.scala:26:26\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m1\e[0m until number) {\n\e[31m\e[31m   |\e[0m                        \
    \  ^^^^^^\e[0m\n\e[31m   |\e[0m                          Found:    (number : Long)\n\
    \e[31m   |\e[0m                          Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val digits = scala.math.pow(_ , number)\n        val firstDigits = scala.math.pow(10.0,\
    \ number)\n        val result = (scala.math.round(firstDigits) to scala.math.round(digits)).\n\
    \            map{f => if(f == 0) \"0\"\n            else scala.math.pow(f, number).asInstanceOf[Int].toString}.\n\
    \            mkString(\"\")\n        result.toLower\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpptc1j9uj.scala:17:66 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = (scala.math.round(firstDigits)\
    \ to scala.math.round(digits)).\n\e[31m\e[31m   |\e[0m                       \
    \                                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35mround\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double): Long\n\e[31m\
    \   |\e[0m (x: Float): Int\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0mmatch\
    \ arguments ((digits : Double => Double))\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpptc1j9uj.scala:21:15 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m        result.toLower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        value toLower is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1660010703
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val ones   = Set(\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\")\n        val tens   = Set(\"x\", \"xx\", \"xxx\")\n      \
    \  val hundreds = Set(\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\",\
    \ \"dccc\", \"cm\")\n        val thous = Set(\"t\")\n        val thousands = Set(\"\
    m\", \"mm\", \"mmm\", \"mxxx\")\n        val millions = Set(\"mmm\", \"mmmm\"\
    , \"xxxm\")\n        val billions = Set(\"bbbb\", \"bab\", \"bba\")\n        val\
    \ trillions = Set(\"bbbbb\", \"bbaa\", \"babb\", \"babba\", \"bbaab\", \"bbbab\"\
    )\n        val quadrillions = Set(\"bbaaab\", \"bbaabb\", \"babbab\", \"babbabb\"\
    , \"babbabba\", \"babbabbab\")\n        val quintillions = Set(\"bbbbbab\", \"\
    babbabbb\", \"babbabbab\", \"babbabbabb\", \"babbabbabba\", \"babbabbabbab\")\n\
    \        val sextillions = Set(\"bbbbbabab\", \"babbabbabb\", \"babbabbabbab\"\
    , \"babbabbabbabb\", \"babbabbabbabba\", \"babbabbabbabbab\")\n        val septillions\
    \ = Set(\"bbbbbbbabb\", \"babbbbabba\", \"babbbbabbabbab\", \"babbbbabbabbabb\"\
    , \"babbbbabbabbaba\", \"babbbbabbabbabb\")\n        val octillions = Set(\"bbbbbbbabab\"\
    , \"babbbbabbabb\", \"babbbbabbabbab\", \"babbbbabbabbabb\", \"babbbbabbabbaba\"\
    , \"babbbbabbabbabb\")\n        val nonillions = Set(\"bbbbbbb\", \"babbbb\",\
    \ \"babbbba\", \"babbbbab\", \"babbbbabb\", \"babbbbabba\", \"babbbbabbabbab\"\
    )\n        val decillions = Set(\"bbbbbbbb\", \"bbbbbab\", \"bbbbbabb\", \"bbbbbabba\"\
    , \"bbbbbabbab\", \"bbbbbabbab\", \"bbbbbabbabb\", \"bbbbbbbbbb\")\n        val\
    \ undecillions = Set(\"bbbbbbbbbb\", \"bbbbbbbbbbb\", \"bbbbbbbbbbba\", \"bbbbbbbbbbbb\"\
    , \"bbbbbbbbbbbbb\", \"bbbbbbbbbbbbba\", \"bbbbbbbbbbbbbab\")\n        val unoctillions\
    \ = Set(\"bbbbbbbbbbab\", \"bbbbbbbbbbbab\", \"bbbbbbbbbbbabb\", \"bbbbbbbbbbbabba\"\
    , \"bbbbbbbbbbbabbab\", \"bbbbbbbbbbbabbabb\", \"bbbbbbbb\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp7_of6_fe.scala:31:142 ----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36munoctillions\e[0m = Set(\e\
    [31m\"bbbbbbbbbbab\"\e[0m, \e[31m\"bbbbbbbbbbbab\"\e[0m, \e[31m\"bbbbbbbbbbbabb\"\
    \e[0m, \e[31m\"bbbbbbbbbbbabba\"\e[0m, \e[31m\"bbbbbbbbbbbabbab\"\e[0m, \e[31m\"\
    bbbbbbbbbbbabbabb\"\e[0m, \"bbbbbbbb\n\e[31m\e[31m   |\e[0m                  \
    \                                                                            \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                            unclosed string literal\n\e[31m\e\
    [31m-- Error: /tmp/tmp7_of6_fe.scala:33:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp7_of6_fe.scala:32:5 ---------------------\e[0m\e[0m\n\e[31m32 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp7_of6_fe.scala:33:4 -------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m\
    \    Not found: bbbbbbbbdef\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val arr = Array(1l, 5l, 10l, 50l, 100l, 500l, 1000l)\n        val miniRoman\
    \ = arr(number).toString.dropRight(1)\n        miniRoman\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd71zm0gg.scala:16:28\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mminiRoman\e\
    [0m = arr(number).toString.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                        ^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \    Found:    (number : Long)\n\e[31m   |\e[0m                            Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010703
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = \"\"\n        var base = 1000l\n        while (number > base)\
    \ {\n            number -= base\n            result = result + \"M\"\n       \
    \     base = 1000l\n        }\n        base = 1000l\n        var digits = mutable.ArrayBuffer.empty[Long]\n\
    \        var num = 0L\n        while (number > 0) {\n            digits = digits\
    \ :+ num % base\n            num = num / base\n            base = 1000l\n    \
    \    }\n        for (number <- digits) {\n            result = result + romanNumerals.get(number).toString.toLowerCase\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu5zq7fn8.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            number -= base\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu5zq7fn8.scala:23:21\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e\
    [36mdigits\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Write your code here\n        var numStr = \"\"\n        var i = 0\n\
    \        var last = 0\n        var numCount = 0\n        while(number > 0) {\n\
    \            numCount += number % 10\n            number = number / 10\n     \
    \       i += 1\n            num = number % 10\n            if(last == 0) {\n \
    \               numStr += num\n            }\n            else if(last != 1) {\n\
    \                numStr += numStr(num)\n            }\n            else if(numCount\
    \ == 0) {\n                last = 1\n                numStr += numStr(num)\n \
    \           }\n            else if(numCount == 1) {\n                last = num\n\
    \                numStr += numStr(num)\n            }\n            else if(numCount\
    \ == 2) {\n                last = 1\n                numStr += numStr(num)\n \
    \           }\n            else {\n                numStr += numStr(num)\n   \
    \         }\n        }\n        if(numCount == 0 && numStr.length < 4) {\n   \
    \         while(numStr.length < 4) {\n                numStr += \"0\"\n      \
    \      }\n        }\n        else if(numCount == 1 && numStr.length < 3) {\n \
    \           while(numStr.length < 3) {\n                numStr += \"0\"\n    \
    \        }\n        }\n        if(numStr.length == 1) {\n            numStr +=\
    \ numStr(num)\n        }\n        else if(numStr.length != 0) {\n            while(numStr.length\
    \ > 0) {\n                numStr += \"0\"\n            }\n        }\n        return\
    \ numStr\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmolt0973.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            numCount += number % \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpmolt0973.scala:22:19 -----------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m            number = number / \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to\
    \ val number\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmolt0973.scala:24:12\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            num = number\
    \ % \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m\
    \            Not found: num\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpmolt0973.scala:26:23 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m                numStr += num\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of String - did you mean\
    \ String.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmolt0973.scala:26:26\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                numStr +=\
    \ num\n\e[31m\e[31m   |\e[0m                          ^^^\e[0m\n\e[31m   |\e[0m\
    \                          Not found: num\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpmolt0973.scala:29:23 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m                numStr += numStr(num)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpmolt0973.scala:29:33 ------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                numStr += numStr(num)\n\e[31m\e[31m   |\e[0m         \
    \                        ^^"
  stdout: ''
  timestamp: 1660010706
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result: String = \"\"\n        val romans = List(\n            \"I\"\
    ,\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\",\n            \"X\"\
    ,\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\",\n            \"C\"\
    ,\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\",\n            \"M\"\
    \n        )\n        var numberString = number.toString\n        var numDigits\
    \ = numberString.length\n        var currentNumber = 1\n        var currentResult\
    \ = \"\"\n        var romanIndex: Int = romans.indexOf(\"M\")\n        while (currentNumber\
    \ <= numDigits) {\n            if (numDigits > 9) {\n                romanIndex\
    \ = romans.indexOf(\"M\")\n            }\n            val temp = currentNumber\
    \ % 10\n            val nextTemp = currentNumber / 10\n            currentResult\
    \ = romans(romanIndex) + romans(romanIndex + 1) + romans(romanIndex + 2) + romans(romanIndex\
    \ + 3)\n            if (currentResult != romans(romanIndex) && currentResult !=\
    \ romans(romanIndex + 1) && currentResult != romans(romanIndex + 2) && currentResult\
    \ != romans(romanIndex + 3)) {\n                currentResult = romans(romanIndex\
    \ + 1) + romans(romanIndex + 2) + romans(romanIndex + 3)\n            }\n    \
    \        if (temp != 0) {\n                currentResult += \"M\"\n          \
    \      currentNumber += 1\n            }\n            if (nextTemp != 0) {\n \
    \               currentResult += \"M\"\n                currentNumber += nextTemp\n\
    \            }\n            numDigits -= 1\n        }\n        result = currentResult\n\
    \        return result.toLowerCase()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 28\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.intToMiniRoman(tmprfibpk4x.scala:33)\n\tat Problem$.main(tmprfibpk4x.scala:51)\n\
    \tat Problem.main(tmprfibpk4x.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romList = mutable.ListBuffer(\"\")\n        for (i <- 0 until number)\
    \ {\n            romList += \"M\"\n        }\n        for (i <- number until 1000)\
    \ {\n            romList += \"CM\"\n            romList += getRomanNumberForNumber(i)\n\
    \        }\n        val reversed = romList.reverse\n        val result = reversed.mkString(\"\
    \")\n        result.substring(1, result.length).toLowerCase\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpozz4y3wo.scala:15:22 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mromList\e[0m = mutable.ListBuffer(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpozz4y3wo.scala:16:26 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m until number)\
    \ {\n\e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          Found:    (number : Long)\n\e[31m   |\e[0m      \
    \                    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if(number < 1 || number > 1000) {\n            throw new java.lang.NumberFormatException(\"\
    Invalid roman-number \"+number);\n        }\n        if(number == 1)\n       \
    \     return \"I\";\n        val roman = scala.collection.mutable.ListBuffer[String]()\n\
    \        val baseMap: Map[Int, Int] = Map(1 -> \"I\", 5 -> \"V\", 10 -> \"X\"\
    , 50 -> \"L\", 100 -> \"C\", 500 -> \"D\", 1000 -> \"M\");\n        val digitMap:\
    \ Map[Int, Int] = Map(1 -> 1, 5 -> 5, 10 -> 10, 50 -> 50, 100 -> 100, 500 -> 500,\
    \ 1000 -> 1000);\n        while(number > 0) {\n            if(number % 1000 ==\
    \ 0) {\n                roman.append(baseMap(number % 100));\n               \
    \ number /= 1000;\n                continue;\n            }\n            val remainder\
    \ = number % 10;\n            number /= 10;\n            roman.append(baseMap(remainder));\n\
    \        }\n        roman.toList.sortWith(_.compareTo(\"I\") > 0).mkString(\"\
    _\")\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqgzwzpow.scala:21:46\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbaseMap\e\
    [0m: \e[35mMap\e[0m[\e[35mInt\e[0m, \e[35mInt\e[0m] = Map(\e[31m1\e[0m -> \e[31m\"\
    I\"\e[0m, \e[31m5\e[0m -> \e[31m\"V\"\e[0m, \e[31m10\e[0m -> \e[31m\"X\"\e[0m,\
    \ \e[31m50\e[0m -> \e[31m\"L\"\e[0m, \e[31m100\e[0m -> \e[31m\"C\"\e[0m, \e[31m500\e\
    [0m -> \e[31m\"D\"\e[0m, \e[31m1000\e[0m -> \e[31m\"M\"\e[0m);\n\e[31m\e[31m \
    \  |\e[0m                                              ^^^\e[0m\n\e[31m   |\e\
    [0m                                              Found:    (\e[32m\"I\"\e[0m :\
    \ String)\n\e[31m   |\e[0m                                              Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqgzwzpow.scala:21:56\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbaseMap\e\
    [0m: \e[35mMap\e[0m[\e[35mInt\e[0m, \e[35mInt\e[0m] = Map(\e[31m1\e[0m -> \e[31m\"\
    I\"\e[0m, \e[31m5\e[0m -> \e[31m\"V\"\e[0m, \e[31m10\e[0m -> \e[31m\"X\"\e[0m,\
    \ \e[31m50\e[0m -> \e[31m\"L\"\e[0m, \e[31m100\e[0m -> \e[31m\"C\"\e[0m, \e[31m500\e\
    [0m -> \e[31m\"D\"\e[0m, \e[31m1000\e[0m -> \e[31m\"M\"\e[0m);\n\e[31m\e[31m \
    \  |\e[0m                                                        ^^^\e[0m\n\e\
    [31m   |\e[0m                                                Found:    (\e[32m\"\
    V\"\e[0m : String)\n\e[31m   |\e[0m                                          \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqgzwzpow.scala:21:67\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbaseMap\e\
    [0m: \e[35mMap\e[0m[\e[35mInt\e[0m, \e[35mInt\e[0m] = Map(\e[31m1\e[0m -> \e[31m\"\
    I\"\e[0m, \e[31m5\e[0m -> \e[31m\"V\"\e[0m, \e[31m10\e[0m -> \e[31m\"X\"\e[0m,\
    \ \e[31m50\e[0m -> \e[31m\"L\"\e[0m, \e[31m100\e[0m -> \e[31m\"C\"\e[0m, \e[31m500\e\
    [0m -> \e[31m\"D\"\e[0m, \e[31m1000\e[0m -> \e[31m\"M\"\e[0m);\n\e[31m\e[31m \
    \  |\e[0m                                                                   ^^^\e\
    [0m\n\e[31m   |\e[0m                                                Found:   \
    \ (\e[32m"
  stdout: ''
  timestamp: 1660010708
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if(number < 1000)\n        {\n            val roman: String = intToMiniRomanHelper(number)\n\
    \            roman.toLowerCase\n        }\n        else\n        {\n         \
    \   val roman: String = intToMiniRomanHelper(number%1000)\n            roman.toLowerCase\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzixp0lq9.scala:17:32 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mroman\e[0m: \e[35mString\e\
    [0m = intToMiniRomanHelper(number)\n\e[31m\e[31m   |\e[0m                    \
    \            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \          Not found: intToMiniRomanHelper\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpzixp0lq9.scala:22:32 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mroman\e[0m: \e[35mString\e\
    [0m = intToMiniRomanHelper(number%\e[31m1000\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                          Not found: intToMiniRomanHelper\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = new collection.mutable.MutableList[String]()\n        var currentNumber\
    \ = number\n        while (currentNumber != 0) {\n            roman += currentNumber\
    \ % 10 + roman[roman.length-1]\n            currentNumber = currentNumber / 10\n\
    \        }\n        return roman.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplv_qsd78.scala:15:43 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mroman\e[0m = \e[33mnew\e\
    [0m collection.mutable.MutableList[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            type MutableList is not a member of scala.collection.mutable\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = scala.collection.mutable.MutableList[String]()\n        val\
    \ romanNum = number\n        while(romanNum > 0){\n            if(romanNum % 1000\
    \ < 10)roman.append(\"M\")\n            if(romanNum % 1000 <= 10 && romanNum %\
    \ 1000 > 10)roman.append(\"CM\")\n            if(romanNum % 1000 < 10 && romanNum\
    \ % 1000 > 9)roman.append(\"D\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 8)roman.append(\"CD\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 7)roman.append(\"C\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 6)roman.append(\"XC\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 5)roman.append(\"L\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 4)roman.append(\"XL\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 3)roman.append(\"X\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 2)roman.append(\"IX\")\n            if(romanNum % 1000 <= 10 && romanNum\
    \ % 1000 > 1)roman.append(\"V\")\n            if(romanNum % 1000 > 0)roman.append(\"\
    IV\")\n            romanNum = romanNum / 1000\n        }\n        roman.reverse.mkString.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8s55f3lc.scala:15:45 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mroman\e[0m = scala.collection.mutable.MutableList[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           value MutableList is not a member of scala.collection.mutable\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp8s55f3lc.scala:30:21 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            romanNum = romanNum / \e[31m1000\e[0m\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            Reassignment to val romanNum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romans = List(\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"\
    X\",\"IX\",\"V\",\"IV\",\"I\")\n        val index = 0\n        val numerals =\
    \ scala.collection.mutable.ListBuffer.empty[String]\n        while {\n       \
    \     number >= roman => numerals.clear()\n            number >= roman && index\
    \ < romans.length => numerals.append (romans(index))\n            number >= roman\
    \ && index >= romans.length + 1 => numerals.append (romans(romans.length + 1))\n\
    \            number >= roman && index <= romans.length - 1 => numerals.append\
    \ (romans(index))\n            number < roman => numerals.clear()\n          \
    \  number < roman && index < romans.length => numerals.append (romans(index))\n\
    \            number < roman && index >= romans.length + 1 => numerals.append (romans(romans.length\
    \ + 1))\n            number < roman && index <= romans.length - 1 => numerals.append\
    \ (romans(index))\n        }\n        numerals.toList.sortWith(_.compareTo(_)\
    \ < 0).map(_.toString).toLowerCase \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp7ia7c4iz.scala:19:19 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            number >= roman => numerals.clear()\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            not\
    \ a legal formal parameter\n\e[31m\e[31m-- Error: /tmp/tmp7ia7c4iz.scala:20:28\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m       \
    \     number >= roman && index < romans.length => numerals.append (romans(index))\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            not a legal formal parameter\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp7ia7c4iz.scala:21:28 -----------------------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m            number >= roman && index >= romans.length + \e\
    [31m1\e[0m => numerals.append (romans(romans.length + \e[31m1\e[0m))\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            not a legal formal parameter\n\e[31m\e[31m-- Error: /tmp/tmp7ia7c4iz.scala:22:28\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \     number >= roman && index <= romans.length - \e[31m1\e[0m => numerals.append\
    \ (romans(index))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            not a legal formal parameter\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp7ia7c4iz.scala:23:19 -----------------------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            number < roman => numerals.clear()\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            not a legal\
    \ formal parameter\n\e[31m\e[31m-- Error: /tmp/tmp7ia7c4iz.scala:24:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            number < roman && index < romans.length =>\
    \ numerals.append (romans(index))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            not a legal formal parameter\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp7ia7c4iz.scala:25:27 -----------------------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m            number < roman && index >"
  stdout: ''
  timestamp: 1660010702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Use a mutable array to store each digit of the roman numeral.\n     \
    \   // Initialize each digit to its correct index in the array.\n        // TODO:\
    \ Consider using a different data structure to store each digit in the array.\n\
    \        // The array is too small to store the longest possible roman numeral,\
    \ so we need a different one.\n        var romanNumeral = new mutable.Array[String](100)\n\
    \        var position : Int = -1\n\n        // Iterate through the digits.\n \
    \       while(number != 0) {\n            // Set the position of the current digit\
    \ to its correct index in the array.\n            position = number % 10\n\n \
    \           // Add the digit to the array.\n            romanNumeral += romanDigits(position)\n\
    \n            // Divide number by 10 to get its last digit.\n            number\
    \ /= 10\n        }\n\n        // Return romanNumeral as a string.\n        romanNumeral.mkString.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpymb1da_4.scala:19:31 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mromanNumeral\e[0m = \e[33mnew\e\
    [0m mutable.Array[\e[35mString\e[0m](\e[31m100\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                             ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpymb1da_4.scala:25:23 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            position = number % \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m \
    \                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \  Found:    Long\n\e[31m   |\e[0m                       Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpymb1da_4.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            number /= \e[31m10\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean number.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = number.toString.toList\n        val index = roman.indexOf(0)\n\
    \        roman.init\n        while(index != -1) {\n            if(roman(index)\
    \ >= 60 && roman(index) <= 90)\n                roman(index) = roman(index) -\
    \ 55\n            else if(roman(index) >= 90 && roman(index) <= 100)\n       \
    \         roman(index) = roman(index) - 45\n            else if(roman(index) >=\
    \ 100)\n                roman(index) = roman(index) - 40\n            index =\
    \ roman.indexOf(0)\n        }\n        roman.mkString.toLowerCase\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo__lspfr.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                roman(index) = roman(index) - \e[31m55\e\
    [0m\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0mvalue update\
    \ is not a member of List[Char] - did you mean roman.updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpo__lspfr.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                roman(index) = roman(index) - \e[31m45\e\
    [0m\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0mvalue update\
    \ is not a member of List[Char] - did you mean roman.updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpo__lspfr.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                roman(index) = roman(index) - \e[31m40\e\
    [0m\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0mvalue update\
    \ is not a member of List[Char] - did you mean roman.updated?\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpo__lspfr.scala:25:18 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            index = roman.indexOf(\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \      Reassignment to val index\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = \"\"\n        var result = 0\n        number match {\n     \
    \       case n if (n > 0) => {\n                val nums = n.toString.toInt\n\
    \                val numsString = nums.map(n => n.toString).mkString(\"\")\n \
    \               val rem = nums.last\n                result += rem * Math.pow(10,\
    \ nums.size - 1)\n                while (result >= 1000) {\n                 \
    \   roman = (result / 1000).toString.toInt.toString + roman\n                \
    \    result %= 1000\n                }\n                result += numsString\n\
    \                roman = roman.substring(0, roman.length - 1)\n            }\n\
    \            case _ => {\n                roman = \"\"\n                result\
    \ = 0\n            }\n        }\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbhfxh8mi.scala:20:38 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33mval\e[0m \e[36mnumsString\e[0m\
    \ = nums.map(\e[36mn\e[0m => n.toString).mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                 ^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                             value map is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpbhfxh8mi.scala:21:31 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mval\e[0m \e[36mrem\e[0m = nums.last\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          value last is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660010706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number < 1 || number > 1000) {\n            throw new RuntimeException(\"\
    Illegal argument: \" + number)\n        }\n        val romans = scala.collection.mutable.ArrayBuffer.empty[String]\n\
    \        for (i <- 1 until number) {\n            val value = number % i\n   \
    \         val roman = if (value >= 10)\n                romans append \"M\"\n\
    \            else romans append if (value < 10)\n                \"C\"\n     \
    \       else value else \"D\"\n            romans append roman\n            number\
    \ /= i\n        }\n        romans.toSeq.toString.toLowerCase\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp00rvd_ab.scala:23:31 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33melse\e[0m romans append \e[33mif\e\
    [0m (value < \e[31m10\e[0m)\n\e[31m\e[31m   |\e[0m                           \
    \    ^^\e[0m\n\e[31m   |\e[0m                               expression expected\
    \ but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp00rvd_ab.scala:25:12\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m25 |\e[0m       \
    \     \e[33melse\e[0m value \e[33melse\e[0m \e[31m\"D\"\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^\e[0m\n\e[31m   |\e[0m            end of statement expected\
    \ but 'else' found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp00rvd_ab.scala:19:26\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m1\e[0m until number) {\n\e[31m\e[31m   |\e[0m                        \
    \  ^^^^^^\e[0m\n\e[31m   |\e[0m                          Found:    (number : Long)\n\
    \e[31m   |\e[0m                          Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmp00rvd_ab.scala:26:19 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            romans append roman\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mappend\e[0m in \e[33mtrait\e[0m \e[35mBuffer\e[0m\
    \ with types\n\e[31m   |\e[0m (elems: String*): (romans : scala.collection.mutable.ArrayBuffer[String])\n\
    \e[31m   |\e[0m (elem: String): (romans : scala.collection.mutable.ArrayBuffer[String])\n\
    \e[31m   |\e[0mmatch arguments ((roman : scala.collection.mutable.ArrayBuffer[String]))\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp00rvd_ab.scala:27:19 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            number /= i\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member of\
    \ Long - did you mean number.!=?\n\e[33m\e[33m-- [E129] Potential Issue Warning:\
    \ /tmp/tmp00rvd_ab.scala:24:16 --------"
  stdout: ''
  timestamp: 1660010708
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = mutable.Set(\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"\
    L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\")\n        val factors = scala.math.pow(2,\
    \ number.toInt).toInt\n        var sum = 0\n        for (i <- 1 to factors) {\n\
    \            sum += roman.iterator.filter(roman.contains((i / i.toDouble).toInt)).last\n\
    \        }\n        sum.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzokqw5u7.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mroman\e[0m = mutable.Set(\e\
    [31m\"M\"\e[0m, \e[31m\"CM\"\e[0m, \e[31m\"D\"\e[0m, \e[31m\"CD\"\e[0m, \e[31m\"\
    C\"\e[0m, \e[31m\"XC\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"XL\"\e[0m, \e[31m\"X\"\e\
    [0m, \e[31m\"IX\"\e[0m, \e[31m\"V\"\e[0m, \e[31m\"IV\"\e[0m, \e[31m\"I\"\e[0m)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010705
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val result = number match {\n            case 1 => s\"x\"\n            case\
    \ 2 => s\"l\"\n            case 3 => s\"c\"\n            case 4 => s\"xl\"\n \
    \           case 5 => s\"xc\"\n            case 6 => s\"xxl\"\n            case\
    \ 7 => s\"xxxl\"\n            case 9 => s\"xlc\"\n            case 10 => s\"xc\"\
    \n            case 12 => s\"lx\"\n            case 14 => s\"lxx\"\n          \
    \  case 16 => s\"lxxx\"\n            case 21 => s\"xc\"\n            case 22 =>\
    \ s\"x\"\n            case 23 => s\"xl\"\n            case 24 => s\"l\"\n    \
    \        case 25 => s\"c\"\n            case 26 => s\"xxl\"\n            case\
    \ 27 => s\"xxxl\"\n            case 28 => s\"xlc\"\n            case 30 => s\"\
    xc\"\n            case 31 => s\"x\"\n            case 32 => s\"lx\"\n        \
    \    case 33 => s\"lxx\"\n            case 34 => s\"lxxx\"\n            case 35\
    \ => s\"xc\"\n            case 36 => s\"x\"\n            case 37 => s\"xl\"\n\
    \            case 38 => s\"l\"\n            case 39 => s\"c\"\n            case\
    \ 40 => s\"xxl\"\n            case 41 => s\"xxxl\"\n            case 42 => s\"\
    xlc\"\n            case 50 => s\"xc\"\n            case 51 => s\"x\"\n       \
    \     case 52 => s\"lx\"\n            case 53 => s\"lxx\"\n            case 54\
    \ => s\"lxxx\"\n            case 55 => s\"xc\"\n            case 56 => s\"x\"\n\
    \            case 57 => s\"xl\"\n            case 58 => s\"l\"\n            case\
    \ 59 => s\"c\"\n            case 60 => s\"xxl\"\n            case 61 => s\"xxxl\"\
    \n            case 62 => s\"xlc\"\n            case 70 => s\"xc\"\n          \
    \  case 71 => s\"x\"\n            case 72 => s\"lx\"\n            case 73 => s\"\
    lxx\"\n            case 74 => s\"lxxx\"\n            case 75 => s\"xc\"\n    \
    \        case 76 => s\"x\"\n            case 77 => s\"xl\"\n            case 78\
    \ => s\"l\"\n            case 79 => s\"c\"\n            case 80 => s\"xxl\"\n\
    \            case 81 => s\"xxxl\"\n            case 82 => s\"xlc\"\n         \
    \   case 90 => s\"xc\"\n            case 91 => s\"x\"\n            case 92 =>\
    \ s\"lx\"\n            case 93 => \n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmputtve79f.scala:98:0 ----------------------------\e\
    [0m\e[0m\n\e[31m98 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmputtve79f.scala:97:1\
    \ ---------------------\e[0m\e[0m\n\e[31m97 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmputtve79f.scala:80:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m80 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1660010711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romans = Map( 1  -> \"I\",\n                         5  -> \"V\",\n\
    \                         10 -> \"X\",\n                         50 -> \"L\",\n\
    \                         100 -> \"C\",\n                         500 -> \"D\"\
    ,\n                         1000 -> \"M\")\n        val numerals = romans.collect\
    \ { case (roman, numeral) => numeral.charAt(0) -> roman }\n        val romanString\
    \ = \"\"\n        val remainder = number % 1000;\n        (1 to 10).foreach {\
    \ number =>\n            romanString += if (number in numerals) numerals(number)\
    \ else \"\"\n        }\n        romanString += (if (remainder >= 5000) romans(remainder)\
    \ else \"\")\n        romanString.toLower\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3x8bm2wi.scala:26:27 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            romanString += \e[33mif\e[0m (number in numerals)\
    \ numerals(number) \e[33melse\e[0m \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m    \
    \                       ^^\e[0m\n\e[31m   |\e[0m                           expression\
    \ expected but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp3x8bm2wi.scala:26:24 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m            romanString += \e[33mif\e[0m (number in numerals) numerals(number)\
    \ \e[33melse\e[0m \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m       value += is not a member of String - did you mean romanString.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3x8bm2wi.scala:28:20 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        romanString += (\e[33mif\e[0m (remainder >= \e\
    [31m5000\e[0m) romans(remainder) \e[33melse\e[0m \e[31m\"\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       value += is not a\
    \ member of String - did you mean romanString.!=?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp3x8bm2wi.scala:28:54 --------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m        romanString += (\e[33mif\e[0m (remainder >= \e[31m5000\e\
    [0m) romans(remainder) \e[33melse\e[0m \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                                      ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                            Found:    (remainder : Long)\n\
    \e[31m   |\e[0m                                            Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3x8bm2wi.scala:29:20 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        romanString.toLower\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value toLower is not a\
    \ member of String\n5 errors found\n"
  stdout: ''
  timestamp: 1660010715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romans = scala.collection.mutable.ListBuffer[String]()\n        var\
    \ i = number\n        while (i >= 1000) {\n            romans += ((i / 1000).map(i\
    \ => String.valueOf(i)).mkString(\"\"))\n            i -= 1000\n        }\n  \
    \      romans += ((i).map(i => String.valueOf(i)).mkString(\"\"))\n        romans.reverse.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpugrfxr3u.scala:18:34 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            romans += ((i / \e[31m1000\e[0m).map(\e[36mi\e\
    [0m => String.valueOf(i)).mkString(\e[31m\"\"\e[0m))\n\e[31m\e[31m   |\e[0m  \
    \                     ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \    value map is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpugrfxr3u.scala:21:23 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m        romans += ((i).map(\e[36mi\e[0m => String.valueOf(i)).mkString(\e[31m\"\
    \"\e[0m))\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                   value map is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660010715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if(number < 1l) throw new IllegalArgumentException(\"Number too small: \"\
    \ + number)\n        val nums = List(\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"\
    L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\")\n        var roman = \"\"\n      \
    \  var lastDigit = 0\n        while(number > 0l) {\n            roman += nums(lastDigit)\n\
    \            if(number % 10 == 0) lastDigit += 1\n            number /= 10\n \
    \       }\n        roman\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc5xehoog.scala:22:19 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            number /= \e[31m10\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean number.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numberString = number.toString.toString.trim\n        val roman = scala.collection.mutable.Map[Int,\
    \ String]()\n        for (number <- numberString.split(\"\"))\n            if\
    \ (number.length == 1)\n                roman += number -> \"m\" // m\n      \
    \      else if (number.length == 2 && number >= 10)\n                roman +=\
    \ number -> \"c\" // c\n            else if (number.length == 3 && number >= 100)\n\
    \                roman += number -> \"d\" // d\n            else if (number.length\
    \ == 3 && number >= 10)\n                roman += number -> \"x\" // x\n     \
    \       else if (number.length == 4 && number >= 1000)\n                roman\
    \ += number -> \"l\" // l\n            else if (number.length == 5 && number >=\
    \ 10000)\n                roman += number -> \"c\" // c\n            else if (number.length\
    \ == 6 && number >= 100000)\n                roman += number -> \"d\" // d\n \
    \           else if (number.length == 7 && number >= 1000000)\n              \
    \  roman += number -> \"x\" // x\n            else if (number.length == 8 && number\
    \ >= 10000000)\n                roman += number -> \"l\" // l\n            else\
    \ if (number.length == 9 && number >= 1000000000)\n                roman += number\
    \ -> \"c\" // c\n            else\n                roman += number -> \"i\" //\
    \ i\n        val min = roman.toList.minBy(_._1)._1\n        val max = roman.toList.maxBy(_._1)._1\n\
    \        roman.toList\n            .filter(number => (number >= min && number\
    \ <= max))\n            .map(x => x._1 + x._2)\n            .mkString(\"\", \"\
    m\", \"c\", \"d\", \"x\", \"l\", \"c\", \"d\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7rvzadb4.scala:19:25\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                roman += number\
    \ -> \e[31m\"m\"\e[0m \e[34m// m\e[0m\n\e[31m\e[31m   |\e[0m                 \
    \        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         Found:  \
    \  (\e[1m\e[31mString\e[0m, String)\n\e[31m   |\e[0m                         Required:\
    \ (\e[1m\e[32mInt\e[0m, String)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp7rvzadb4.scala:20:53 --------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (number.length == \e[31m2\e\
    [0m && number >= \e[31m10\e[0m)\n\e[31m\e[31m   |\e[0m                       \
    \                              ^^\e[0m\n\e[31m   |\e[0m                      \
    \                              Found:    (\e[31m10\e[0m : Int)\n\e[31m   |\e[0m\
    \                                                    Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7rvzadb4.scala:21:25 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                roman += number -> \e[31m\"c\"\e[0m \e\
    [34m// c\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Found:    (\e[1m\e[31mString\e[0m, String)\n\
    \e[31m   |\e[0m                         Required: (\e[1m\e[32mInt\e[0m, String)\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7rvzadb4.scala:22:53\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33melse\e[0m \e\
    [33mif\e[0m (number.length == \e[31m3\e[0m && number >= \e[31m100\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                     ^^^\e[0m\n\e\
    [31m   |\e[0m                                                   Found:    (\e\
    [31m100\e[0m : Int)\n\e[31m   |\e[0m                                         \
    \          Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`"
  stdout: ''
  timestamp: 1660010719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = mutable.Buffer.empty[String]\n        for(i <- 1 to number){\n\
    \            roman.append(romans(i-1) + romans(i%10));\n        }\n        roman.toString().toLowerCase()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8jvnakux.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mroman\e[0m = mutable.Buffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp8jvnakux.scala:16:22 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m(i <- \e[31m1\e[0m to number){\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                Found:    (number : Long)\n\e[31m   |\e[0m                  \
    \    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010712
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number <= 1000) roman(number);\n        else intToMiniRoman(number/100)\
    \ + roman(number%100);\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpawx7eo8d.scala:15:28 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mif\e[0m (number <= \e[31m1000\e[0m) roman(number);\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^\e[0m\n\e[31m   |\e[0m \
    \                           Not found: roman\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpawx7eo8d.scala:16:42 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33melse\e[0m intToMiniRoman(number/\e[31m100\e\
    [0m) + roman(number%\e[31m100\e[0m);\n\e[31m\e[31m   |\e[0m                  \
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \                 Not found: roman\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010710
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numStr = (number % 10L).map(\"M\" -> 10, \"D\" -> 5, \"C\" -> 1, \"\
    L\" -> 0, \"X\" -> 10, \"V\" -> 5, \"I\" -> 1).getOrElse(\"\")\n        val result:\
    \ List[String] = for (n <- numStr) yield \"M\" + n.tail\n        (result.map(_.toLowerCase\
    \ + _).mkString(\"\")).capitalize\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa411oopi.scala:15:36 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnumStr\e[0m = (number %\
    \ \e[31m10L\e[0m).map(\e[31m\"M\"\e[0m -> \e[31m10\e[0m, \e[31m\"D\"\e[0m -> \e\
    [31m5\e[0m, \e[31m\"C\"\e[0m -> \e[31m1\e[0m, \e[31m\"L\"\e[0m -> \e[31m0\e[0m,\
    \ \e[31m\"X\"\e[0m -> \e[31m10\e[0m, \e[31m\"V\"\e[0m -> \e[31m5\e[0m, \e[31m\"\
    I\"\e[0m -> \e[31m1\e[0m).getOrElse(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \    value map is not a member of Long\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpa411oopi.scala:17:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        (result.map(_.toLowerCase\
    \ + _).mkString(\e[31m\"\"\e[0m)).capitalize\n\e[31m\e[31m   |\e[0m          \
    \          ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Wrong number\
    \ of parameters, expected: 1\n2 errors found\n"
  stdout: ''
  timestamp: 1660010714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNum = number.toString.map(_.toInt).sorted\n        val miniRomanNum\
    \ = mutable.Buffer.empty[String]\n        var count = 0\n        for (x <- romanNum)\
    \ {\n            if (x == 1) {\n                miniRomanNum += romanNum(count)\n\
    \                count += 1\n            } else {\n                miniRomanNum\
    \ += romanNum(count) + romanNum(count+1).toLowerCase\n                count +=\
    \ 1\n            }\n        }\n        miniRomanNum.toList.toString.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy41hqhaz.scala:16:27 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mminiRomanNum\e[0m = mutable.Buffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = mutable.LinkedHashMap[(Long, Int), (Long, String)]()\n     \
    \   roman.put(1l, roman(number))\n        roman.put(5l, roman(number))\n     \
    \   roman.put(10l, roman(number))\n        roman.put(50l, roman(number))\n   \
    \     roman.put(100l, roman(number))\n        roman.put(500l, roman(number))\n\
    \        roman.put(1000l, roman(number))\n        return roman(number)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpahuvanpo.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mroman\e[0m = mutable.LinkedHashMap[(\e\
    [35mLong\e[0m, \e[35mInt\e[0m), (\e[35mLong\e[0m, \e[35mString\e[0m)]()\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010711
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = \"\"\n        var romanDigitCount = 0\n        var base = 0\n\
    \        val firstDigit = number / 100\n        val secondDigit = number % 100\n\
    \        val firstRomanDigits = List(\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\"\
    , \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\")\n        val secondRomanDigits\
    \ = List(\"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"\
    X\", \"XI\", \"XII\")\n        while (romanDigitCount < firstDigit.toInt) {\n\
    \            roman = romanDigits + roman\n            romanDigitCount += 1\n \
    \       }\n        roman = romanDigits + roman\n        romanDigitCount += 1\n\
    \        while (romanDigitCount < secondDigit.toInt) {\n            roman = romanDigits\
    \ + roman\n            romanDigitCount += 1\n        }\n        roman = firstRomanDigits\
    \ + roman\n        romanDigitCount += 2\n        while (romanDigitCount < secondRomanDigits.size)\n\
    \            roman = romanDigits + roman\n            romanDigitCount += 1\n \
    \       base = 100\n        while (romanDigitCount > 0)\n            roman = romanDigits\
    \ + roman\n            romanDigitCount -= 1\n        roman = roman.reverse\n \
    \       if (roman.startsWith(\"M\"))\n            roman = roman.drop(1)\n    \
    \    if (roman.startsWith(\"CM\"))\n            roman = roman.drop(2)\n      \
    \  if (roman.startsWith(\"D\"))\n            roman = roman.drop(2)\n        if\
    \ (roman.startsWith(\"CD\"))\n            roman = roman.drop(3)\n        if (roman.startsWith(\"\
    C\"))\n            roman = roman.drop(3)\n        if (roman.startsWith(\"X\"))\n\
    \            roman = roman.drop(3)\n        if (roman.startsWith(\"XL\"))\n  \
    \          roman = roman.drop(4)\n        if (roman.startsWith(\"L\"))\n     \
    \       roman = roman.drop(4)\n        if (roman.startsWith(\"V\"))\n        \
    \    roman = roman.drop(4)\n        if (roman.startsWith(\"IV\"))\n          \
    \  roman = roman.drop(5)\n        if (roman.startsWith(\"I\"))\n            roman\
    \ = roman.drop(5)\n        if (roman.startsWith(\"I\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpf6rc_67f.scala:64:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m        \e[33mif\e[0m (roman.startsWith(\"I\n\e[31m\e\
    [31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m            \
    \                 unclosed string literal\n\e[31m\e[31m-- Error: /tmp/tmpf6rc_67f.scala:66:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m66 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but '=' found\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpf6rc_67f.scala:23:20 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            roman = romanDigits + roman\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \      Not found: romanDigits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpf6rc_67f.scala:26:16 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        roman = romanDigits + roman\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Not found: romanDigits\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpf6rc_67f.scala:29:20 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            roman = romanDigits + roman\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \      Not found: romanDigits\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpf6rc_67f.scala:32:33 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m        roman = firstRomanDigits + roman\n\e[31m\e[31m   |\e[0m           \
    \     ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[String],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards"
  stdout: ''
  timestamp: 1660010716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number < 1) throw new IllegalArgumentException(\"number must be positive\"\
    )\n        if (number > 1000) throw new IllegalArgumentException(\"number must\
    \ be <= 1000\")\n        val miniRoman = mutable.StringBuilder()\n        // The\
    \ \"i\" suffix is used for \"i\".\n        val suffix = \"i\"\n        val romanBase\
    \ = Array( \"M\", \"MM\", \"MMM\",\n                                \"D\", \"\
    DD\", \"DDD\",\n                                \"C\", \"CC\", \"CCC\",\n    \
    \                            \"X\", \"XX\", \"XXX\",\n                       \
    \         \"L\", \"LL\", \"LLL\",\n                                \"XL\", \"\
    XXL\", \"XXXL\",\n                                \"V\", \"VV\", \"VVV\",\n  \
    \                              \"I\", \"II\", \"III\",\n                     \
    \           \"XC\", \"XCC\", \"XCCC\",\n                                \"CM\"\
    , \"CMC\", \"CMCC\",\n                                \"IV\", \"IV\", \"IV\",\n\
    \                                \"III\", \"III\", \"IIII\",\n               \
    \                 \"LV\", \"LV\", \"L\",\n                                \"VI\"\
    , \"VII\", \"VIII\",\n                                \"XII\", \"XIII\", \"XIIII\"\
    ,\n                                \"LX\", \"LXX\", \"LXXX\",\n              \
    \                  \"CX\", \"CXX\", \"CXXX\",\n                              \
    \  \"CL\", \"CLL\", \"CLXX\",\n                                \"CLX\", \"CLXX\"\
    , \"CLXXX\",\n                                \"CLE\", \"CLE\", \"CLED\",\n  \
    \                              \"CXL\", \"CXLI\", \"CXLII\",\n               \
    \                 \"CLX\", \"CLX\", \"CLXX\",\n                              \
    \  \"CLXX\", \"CLXX\", \"CLXXX\",\n                                \"CLCX\", \"\
    CLCX\", \"CLCXX\",\n                                \"CLXC\", \"CLXCX\", \"CLXCXX\"\
    ,\n                                \"CLXXC\", \"CLXXCX\", \"CLXXCXX\",\n     \
    \                           \"CLXXXC\", \"CLXXXCX\", \"CLXXXCXX\",\n         \
    \                       \"CMC\", \"CMCC\", \"CMCCC\",\n                      \
    \          \"I\", \"II\", \"III\",\n                                \"III\", \"\
    IIII\", \"IIIII\",\n                                \"IV\", \"IV\", \"IV\",\n\
    \                                \"V\", \"VI\", \"VII\",\n                   \
    \             \"VII\", \"VIII\", \"VIIII\",\n                                \"\
    VIII\", \"VIIII\", \"VIIIII\",\n                                \"VIIII\", \"\
    VIIIII\", \"VIIIIII\",\n                                \"VIIIII\", \"VIIIIII\"\
    , \"VIIIIIII\",\n                                \"VIIIIII\", \"VIIIIIII\", \"\
    VIIIIIIII\",\n                                \"VIIIIIII\", \"VIIIIIIII\", \"\
    VIIIIIIIII\",\n                                \"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpmbd0_33h.scala:58:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m                                \"\n\e[31m\e[31m   |\e\
    [0m                                ^\e[0m\n\e[31m   |\e[0m                   \
    \             unclosed string literal\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpmbd0_33h.scala:57:70\
    \ ---------------------------\e[0m\e[0m\n\e[31m57 |\e[0m                     \
    \           \e[31m\"VIIIIIII\"\e[0m, \e[31m\"VIIIIIIII\"\e[0m, \e[31m\"VIIIIIIIII\"\
    \e[0m,\n\e[31m\e[31m   |\e[0m                                                \
    \                      ^\e[0m\n\e[31m   |\e[0m                           expression\
    \ expected but \e[31merroneous token\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpmbd0_33h.scala:17:24 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mminiRoman\e[0m = mutable.StringBuilder()\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpmbd0_33h.scala:59:5 ---------------------\e[0m\e\
    [0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = \"\"\n        for (i: Long <- 1 to number) {\n            roman\
    \ += intToRoman(i)\n        }\n        roman.toLowerCase()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgei7rd1y.scala:16:29\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m (i: \e\
    [35mLong\e[0m <- \e[31m1\e[0m to number) {\n\e[31m\e[31m   |\e[0m            \
    \                 ^^^^^^\e[0m\n\e[31m   |\e[0m                             Found:\
    \    (number : Long)\n\e[31m   |\e[0m                             Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgei7rd1y.scala:17:18\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m            roman += intToRoman(i)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpgei7rd1y.scala:17:21 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m            roman += intToRoman(i)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: intToRoman\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = scala.collection.mutable.ListBuffer.empty[String]\n        roman.append(scala.math.pow(10,\
    \ (number - 1).toInt).toString)\n        var i = number - 1\n        while(i >\
    \ 0){\n            roman.append(roman.last, roman.last.length)\n            roman.insert(roman.size\
    \ - 1, \"M\")\n            i -= 1\n        }\n        return roman.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp73av6p7.scala:19:37\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            roman.append(roman.last,\
    \ roman.last.length)\n\e[31m\e[31m   |\e[0m                                  \
    \   ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \   Found:    Int\n\e[31m   |\e[0m                                     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val result = new mutable.ListBuffer[Char]()\n        var nums = number.toCharArray\n\
    \        for (i in 0 until nums.length) {\n            val num: Int = nums(i).toInt\n\
    \            val mod = num % 10\n            if (mod <= 3) {\n               \
    \ nums(i) = 'I'\n            } else if (mod == 4) {\n                nums(i) =\
    \ 'V'\n            } else if (mod == 5) {\n                nums(i) = 'X'\n   \
    \         } else {\n                nums(i) = nums(i).toChar\n            }\n\
    \            result += nums(i)\n        }\n        result.toString\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp98oc48cf.scala:17:39 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mfor\e[0m (i in \e[31m0\e[0m until nums.length)\
    \ {\n\e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m\
    \   |\e[0m                                       '<-' expected, but '{' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp98oc48cf.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '<-' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp98oc48cf.scala:15:25\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mChar\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp98oc48cf.scala:16:26 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m        \e[33mvar\e[0m \e[36mnums\e[0m = number.toCharArray\n\e[31m\e[31m \
    \  |\e[0m                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \          value toCharArray is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp98oc48cf.scala:30:9 -------------------------\e[0m\e[0m\n\
    \e[31m30 |\e[0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m   |\e[0mvalue\
    \ withFilter is not a member of Null, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31"
  stdout: ''
  timestamp: 1660010720
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = \"m\"\n        // Many ways to solve this problem. Some less\
    \ elegant, some less efficient.\n        // Here are two:\n        for (d <- 1\
    \ to number) {\n            result += (if (number >= 1000000000L && number <=\
    \ 1000000L) (\"M\") else \"\")\n            result += (if (number >= 10000L &&\
    \ number < 100000L) (\"CM\") else \"\")\n            result += (if (number >=\
    \ 100L && number < 10L) (\"D\") else \"\")\n            result += (if (number\
    \ >= 10L && number < 100L) (\"CD\") else \"\")\n            result += (if (number\
    \ >= 10L && number < 100L) (\"C\") else \"\")\n            result += (if (number\
    \ >= 10L && number < 100L) (\"X\") else \"\")\n            result += (if (number\
    \ >= 100L && number < 1000L) (\"L\") else \"\")\n            result += (if (number\
    \ >= 1000L && number < 10000L) (\"XC\") else \"\")\n            result += (if\
    \ (number >= 10000L && number < 100000L) (\"LX\") else \"\")\n            result\
    \ += (if (number >= 100000L && number < 1000000L) (\"LXX\") else \"\")\n     \
    \       result += (if (number >= 1000000L && number < 1000000000L) (\"LXXX\")\
    \ else \"\")\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl08ux10w.scala:18:23\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mfor\e[0m (d <-\
    \ \e[31m1\e[0m to number) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (number : Long)\n\e[31m \
    \  |\e[0m                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanArray = Array(\"\", \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\"\
    , \"xl\", \"l\", \"ix\", \"iv\", \"x\", \"ix\", \"v\", \"iv\")\n        val romanArray2\
    \ = Array(\"\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"ix\", \"v\", \"iv\")\n\
    \        val romanArray3 = Array(\"\", \"l\", \"ix\", \"v\", \"iv\")\n       \
    \ val romanArray4 = Array(\"\")\n        val romanArray5 = Array(\"\")\n     \
    \   val romanArray6 = Array(\"\")\n\n        def toRoman(num: Long): String =\
    \ {\n            if (num >= 1000) return romanArray6(roundDown(num / (1000 * 1000)))\
    \ + romanArray5(roundDown(num / (1000 * 100 * 10)))\n            if (num >= 900)\
    \ return romanArray5(roundDown(num / (1000 * 100 * 10))) + romanArray4(roundDown(num\
    \ / (1000 * 100)))\n            if (num >= 500) return romanArray4(roundDown(num\
    \ / (1000 * 100))) + romanArray3(roundDown(num / (1000 * 10 * 10)))\n        \
    \    if (num >= 400) return romanArray3(roundDown(num / (1000 * 10 * 10))) + romanArray2(roundDown(num\
    \ / (1000 * 10)))\n            if (num >= 100) return romanArray2(roundDown(num\
    \ / (1000 * 10))) + romanArray1(roundDown(num / (1000)))\n            if (num\
    \ >= 90) return romanArray1(roundDown(num / (1000))) + romanArray1(roundDown(num\
    \ / (1000 * 10)))\n            if (num >= 50) return romanArray1(roundDown(num\
    \ / (1000 * 10))) + romanArray1(roundDown(num / (1000 * 100 * 10)))\n        \
    \    if (num >= 40) return romanArray1(roundDown(num / (1000 * 100 * 10))) + romanArray1(roundDown(num\
    \ / (1000 * 100)))\n            if (num >= 10) return romanArray1(roundDown(num\
    \ / (1000 * 100))) + romanArray1(roundDown(num / (1000 * 10 * 10)))\n        \
    \    if (num >= 9) return romanArray1(roundDown(num / (1000 * 10 * 10))) + romanArray1(roundDown(num\
    \ / (1000 * 10)))\n            if (num >= 5) return romanArray1(roundDown(num\
    \ / (1000 * 10))) + romanArray1(roundDown(num / (1000 * 100 * 10)))\n        \
    \    if (num >= 4) return romanArray1(roundDown(num / (1000 * 100 * 10))) + romanArray1(roundDown\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoy71rsdd.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoy71rsdd.scala:54:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m54 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpoy71rsdd.scala:23:48 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m            \e[33mif\e[0m (num >= \e[31m1000\e[0m) \e[33mreturn\e\
    [0m romanArray6(roundDown(num / (\e[31m1000\e[0m * \e[31m1000\e[0m))) + romanArray5(roundDown(num\
    \ / (\e[31m1000\e[0m * \e[31m100\e[0m * \e[31m10\e[0m)))\n\e[31m\e[31m   |\e[0m\
    \                                                ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                                Not found: roundDown\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoy71rsdd.scala:23:94 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (num >= \e[31m1000\e[0m) \e\
    [33mreturn\e[0m romanArray6(roundDown(num / (\e[31m1000\e[0m * \e[31m1000\e[0m)))\
    \ + romanArray5(roundDown(num / (\e[31m1000\e[0m * \e[31m100\e[0m * \e[31m10\e\
    [0m)))\n\e[31m\e[31m   |\e[0m                                                \
    \                                              ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                                    Not found: roundDown\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoy71rsdd.scala:24:47\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m\
    \ (num >= \e[31m900\e[0m) \e[33mreturn\e[0m romanArray5(roundDown(num / (\e[31m1000\e\
    [0m * \e[31m100\e[0m * \e[31m10\e[0m))) + romanArray4(roundDown(num / (\e[31m1000\e\
    [0m * \e[31m100\e[0m)))\n\e[31m\e[31m   |\e[0m                               \
    \                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \                  Not found: roundDown\n\e[31m   |\e[0m\n\e[31m   |\e[0m l"
  stdout: ''
  timestamp: 1660010720
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = List[String]()\n        roman.push(\"i\", \"ii\", \"iii\", \"\
    iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\")\n        roman.push(\"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\")\n        roman.push(\"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\")\n        roman.push(\"m\"\
    , \"mm\", \"mmm\")\n        roman.foreach(x => {\n            val romanNum = number\
    \ / 1000 * 1000\n            val newNum = number % 1000\n            val newRomanNum\
    \ = romanNum.asInstanceOf[Int]\n            val numOfDigits = newNum.toString.length\n\
    \            val romanDigit = roman(newRomanNum)\n            val newDigit = romanDigit\
    \ + (if (numOfDigits > romanDigit.length) 0 else \"\")\n            roman.insert(newRomanNum,\
    \ newDigit)\n        })\n        roman.reverse.mkString(\"\")\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzbdxlsx7.scala:16:14 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        roman.push(\e[31m\"i\"\e[0m, \e[31m\"ii\"\e[0m,\
    \ \e[31m\"iii\"\e[0m, \e[31m\"iv\"\e[0m, \e[31m\"v\"\e[0m, \e[31m\"vi\"\e[0m,\
    \ \e[31m\"vii\"\e[0m, \e[31m\"viii\"\e[0m, \e[31m\"ix\"\e[0m)\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value push is not a member\
    \ of List[String] - did you mean roman.last?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpzbdxlsx7.scala:17:14 ------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        roman.push(\e[31m\"x\"\e[0m, \e[31m\"xx\"\e[0m, \e[31m\"xxx\"\e\
    [0m, \e[31m\"xl\"\e[0m, \e[31m\"l\"\e[0m, \e[31m\"lx\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value push is not a member of List[String]\
    \ - did you mean roman.last?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzbdxlsx7.scala:18:14\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        roman.push(\e[31m\"\
    c\"\e[0m, \e[31m\"cc\"\e[0m, \e[31m\"ccc\"\e[0m, \e[31m\"cd\"\e[0m, \e[31m\"d\"\
    \e[0m, \e[31m\"dc\"\e[0m, \e[31m\"dcc\"\e[0m, \e[31m\"dccc\"\e[0m, \e[31m\"cm\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value\
    \ push is not a member of List[String] - did you mean roman.last?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpzbdxlsx7.scala:19:14 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        roman.push(\e[31m\"m\"\e[0m, \e[31m\"mm\"\e[0m,\
    \ \e[31m\"mmm\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m   value push is not a member of List[String] - did you mean roman.last?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzbdxlsx7.scala:27:18 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            roman.insert(newRomanNum, newDigit)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value insert is not\
    \ a member of List[String] - did you mean roman.init?\n5 errors found\n"
  stdout: ''
  timestamp: 1660010720
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanList = mutable.ListBuffer[String]()\n        for(i <- 0 until number)\
    \ romanList += i.toString.toLowerCase(Locale.ROOT).romanNumeral\n        romanList.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbc8t6uxx.scala:15:24 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mromanList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbc8t6uxx.scala:16:25 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until number)\
    \ romanList += i.toString.toLowerCase(Locale.ROOT).romanNumeral\n\e[31m\e[31m\
    \   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \           Found:    (number : Long)\n\e[31m   |\e[0m                       \
    \  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \   val roman = collection.mutable.ListBuffer[String]()\n      for (i <- 1 to\
    \ number) {\n        roman += intToMiniRoman(i)\n      }\n      roman.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpriibn143.scala:16:21\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m      \e[33mfor\e[0m (i <- \e\
    [31m1\e[0m to number) {\n\e[31m\e[31m   |\e[0m                     ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                     Found:    (number : Long)\n\e[31m   |\e[0m\
    \                     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // The largest integer you can represent as a Roman numeral is 999.\n  \
    \      // When you're done with the program, don't forget to print the final\n\
    \        // result!\n        if (number > 999) throw new RuntimeException(\"Cannot\
    \ represent number \" + number + \" as a Roman numeral\")\n        // You only\
    \ need to deal with numbers whose first two digits are divisible by 3.\n     \
    \   // All numbers that have a first two digit that isn't divisible by 3 are already\
    \ in Roman numerals.\n        // The remainder of the number is divisible by 3,\
    \ and we know it's between 100 and 900\n        if (number % 3 != 0) return \"\
    NOT AN INTEGER GREATER THAN THAT SORTABLY\"\n        // Get the last two digits\n\
    \        val lastTwoDigits = number % 100\n        // Round the value off to remove\
    \ decimal precision\n        val intValue = number / 100\n        // Convert each\
    \ of the three digits to its Roman numeral\n        val threeToOne = (\"M\" #->\
    \ \"CM\" #-> \"D\" #-> \"CD\" #-> \"C\" #-> \"XC\" #-> \"L\" #-> \"XL\" #-> \"\
    X\" #-> \"IX\" #-> \"V\" #-> \"IV\" #-> \"I\" #-> \"II\")\n        val intPart\
    \ = (threeToOne #-> intValue)\n        // Create the final string\n        var\
    \ result = \"\"\n        result ++= intPart.filter{ case (k,v) => lastTwoDigits\
    \ % v == 0 }.map{ case (k,v) => k.toString }\n        result ++= threeToOne.filter{\
    \ case (k,v) => lastTwoDigits % v != 0 }.map{ case (k,v) => v.toString }\n   \
    \     result ++= intPart.filter{ case (k,v) => lastTwoDigits % v == 0 }.map{ case\
    \ (k,v) => v.toString }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8hdrmvrv.scala:28:30 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mthreeToOne\e[0m = (\e[31m\"\
    M\"\e[0m #-> \e[31m\"CM\"\e[0m #-> \e[31m\"D\"\e[0m #-> \e[31m\"CD\"\e[0m #->\
    \ \e[31m\"C\"\e[0m #-> \e[31m\"XC\"\e[0m #-> \e[31m\"L\"\e[0m #-> \e[31m\"XL\"\
    \e[0m #-> \e[31m\"X\"\e[0m #-> \e[31m\"IX\"\e[0m #-> \e[31m\"V\"\e[0m #-> \e[31m\"\
    IV\"\e[0m #-> \e[31m\"I\"\e[0m #-> \e[31m\"II\"\e[0m)\n\e[31m\e[31m   |\e[0m \
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \    value #-> is not a member of String\n1 error found\n"
  stdout: ''
  timestamp: 1660010718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNum = (10000000000000l).min(number).max(1l).toInt\n        var\
    \ num : String = \"\"\n        var index = 0\n        while(romanNum > 0l){\n\
    \            if(romanNum % 10l == 0l){\n                num += romanNum / 10l.toString\
    \ + \"\"\n            }else{\n                num += romanNum % 10l.toString +\
    \ \"\"\n            }\n            romanNum = romanNum / 10l\n            index++\n\
    \        }\n        while(index > 0){\n            num += \"M\"\n            index--\n\
    \        }\n        num.toLowerCase()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp05x_oe3k.scala:25:19 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            index++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp05x_oe3k.scala:29:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            index--\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp05x_oe3k.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                num += romanNum / \e[31m10l\e[0m.toString\
    \ + \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            value += is not a member of String - did you mean String.!=?\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmp05x_oe3k.scala:20:32 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                num += romanNum / \e[31m10l\e[0m.toString\
    \ + \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m\
    \ \e[35m/\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m\
    \  (x: Double): Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x:\
    \ Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\
    \e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e\
    [0m match arguments (String)\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp05x_oe3k.scala:22:20\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m                num += romanNum\
    \ % \e[31m10l\e[0m.toString + \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m         \
    \       ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of String\
    \ - did you mean String.!=?\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp05x_oe3k.scala:22:32\
    \ -----------------------------\e[0m\e[0m\n\e[31m22 |\e[0m                "
  stdout: ''
  timestamp: 1660010722
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = mutable.Map[Int, String]()\n        val numberString = number.toString\n\
    \        val romanNums = numberString.split(\"(\\\\d+)\".toList)\n        romanNums\
    \ match {\n            case List(xs) => romanNums.tail.foreach { x =>\n      \
    \          if (roman.contains(x.toInt)) {\n                    val oldVal = roman.getOrElse(x.toInt,\
    \ \"\").asInstanceOf[String]\n                    val newVal = oldVal + x\n  \
    \                  roman(x.toInt) = newVal\n                }\n              \
    \  else roman(x.toInt) = x\n            }\n            case _ => throw new Exception(\"\
    Invalid input \" + romanNums.mkString(\"[\", \",\", \"]\"))\n        }\n\n   \
    \     val map = (romanNums zip roman) map {\n            case (romanNum, romanNumber)\
    \ => romanNumber + \"\\\"\" + romanNum + \"\\\"\" -> romanNumber\n        }.toMap\n\
    \n        val sortedMap = map.toSeq.sortBy(_._1).map(_._2).toMap\n\n        val\
    \ romanStrings = sortedMap.map { x => x + \" \" + x }\n\n        val romanList\
    \ = romanStrings.toList.sorted\n        val romanStringsString = romanList.mkString(\"\
    \")\n\n        val romanStringsFinal = romanStringsString.replace(\"x\", \"\"\
    )\n        val romanStringsFinalString = romanStringsFinal.toLowerCase()\n\n \
    \       val result = romanStringsFinalString\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjuu1g345.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mroman\e[0m = mutable.Map[\e\
    [35mInt\e[0m, \e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjuu1g345.scala:17:52 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mromanNums\e[0m = numberString.split(\e\
    [31m\"(\\\\d+)\"\e[0m.toList)\n\e[31m\e[31m   |\e[0m                         \
    \                  ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                      Found:    List[Char]\n\e[31m   |\e[0m                 \
    \                          Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E081] Type Error: /tmp/tmpjuu1g345.scala:31:12 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mcase\e[0m (romanNum, romanNumber) =>\
    \ romanNumber + \e[31m\"\\\"\"\e[0m + romanNum + \e[31m\"\\\"\"\e[0m -> romanNumber\n\
    \e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ x$1 of expanded function:\n\e[31m   |\e[0m   x$1 => \n\e[31m   |\e[0m     x$1\e\
    [33m match \e[0m\n\e[31m   |\e[0m       {\n\e[31m   |\e[0m         \e[33mcase\
    \ \e[0m(romanNum, romanNumber) => \n\e[31m   |\e[0m           romanNumber + \e\
    [32m\"\\\"\"\e[0m + romanNum + \e[32m\"\\\"\"\e[0m -> romanNumber\n\e[31m   |\e\
    [0m       }.\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjuu1g345.scala:31:44\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mcase\e\
    [0m (romanNum, romanNumber) => romanNumber + \e[31m\"\\\"\"\e[0m + romanNum +\
    \ \e[31m\"\\\"\"\e[0m -> romanNumber\n\e[31m\e[31m   |\e[0m                  \
    \                          ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                           Not found: romanNumber\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with "
  stdout: ''
  timestamp: 1660010723
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = mutable.ListBuffer.empty[String]\n        while(number > 0)\
    \ {\n            roman += intToRoman(number%10)\n            number /= 10\n  \
    \      }\n        roman.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzabalj1m.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mroman\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpzabalj1m.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            number /= \e[31m10\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010722
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numString = number.toString\n        if (numString.length <= 0) \"\"\
    \n        else {\n            val max = (math.pow(10, numString.length).toInt)\n\
    \            val vals = mutable.ArrayBuffer.empty[String]\n            for (x\
    \ <- 1 to max) {\n                if (numString % x == 0) {\n                \
    \    val val = numString / x\n                    vals += (val + (if (val == 1)\
    \ \"\" else x)).toString\n                }\n            }\n            vals.mkString(\"\
    \")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpg_uhnkov.scala:22:24 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    \e[33mval\e[0m \e[33mval\e[0m = numString\
    \ / x\n\e[31m\e[31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0m\
    \                        pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E018]\
    \ Syntax Error: /tmp/tmpg_uhnkov.scala:23:29 ---------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m                    vals += (\e[33mval\e[0m + (\e[33mif\e\
    [0m (\e[33mval\e[0m == \e[31m1\e[0m) \e[31m\"\"\e[0m \e[33melse\e[0m x)).toString\n\
    \e[31m\e[31m   |\e[0m                             ^^^\e[0m\n\e[31m   |\e[0m  \
    \                           expression expected but \e[31mval\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg_uhnkov.scala:19:23 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mvals\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpg_uhnkov.scala:21:30 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mif\e[0m (numString % x == \e[31m0\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue % is not a member of String, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\
    \e[31m   |\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660010725
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val intArr = Array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)\n        val\
    \ numArr = Array(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127)\n\
    \        val romanArr = Array(\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"\
    VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"\
    XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\"\
    , \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\"\
    , \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\"\
    , \"XXXIX\")\n        def intToRoman(num: Long) = {\n            def numToInt(num:\
    \ Long): Int = {\n                if (num > 1000 || num < 1) throw new IllegalArgumentException\n\
    \                num.toInt % 100\n            }\n            val sum: Long = intArr.foldLeft(num)\
    \ { (x, y) => x + y }\n            (romanArr(numToInt(sum - number) - 1) + romanArr(numToInt(number))).toLowerCase\n\
    \        }\n        if (number > 1000 || number < 1) throw new IllegalArgumentException\n\
    \        intToRoman(number).replaceAll(\"M\", \"MM\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphordu13s.scala:30)\n\tat Problem.main(tmphordu13s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romans = List(\n            List(\"I\", \"V\", \"X\", \"L\"),\n    \
    \        List(\"XII\", \"VII\", \"XIII\", \"IX\"),\n            List(\"LXXXII\"\
    , \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXIX\"),\n\
    \            List(\"M\", \"CM\", \"D\", \"CD\", \"C\"),\n            List(\"M\"\
    , \"D\", \"CD\", \"C\"),\n            List(\"MMM\", \"MMM\", \"MMMM\", \"MMMMM\"\
    ),\n            List(\"MMMMMM\", \"MMMMMM\", \"MMMMMMM\", \"MMMMMMMM\", \"MMMMMMMMM\"\
    ),\n            List(\"MMMMMMMMM\", \"MMMMMMMMMM\", \"MMMMMMMMMMM\", \"MMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMM\"),\n            List(\"X\", \"XL\", \"L\", \"XC\", \"C\", \"\
    CD\", \"C\", \"XC\", \"C\", \"XL\", \"L\"),\n            List(\"X\", \"XL\", \"\
    L\", \"XC\", \"C\", \"CD\", \"C\", \"XC\", \"C\", \"XL\", \"L\"),\n          \
    \  List(\"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"C\", \"XC\", \"C\", \"\
    XL\", \"L\"),\n            List(\"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"\
    C\", \"XC\", \"C\", \"XL\", \"L\"),\n            List(\"X\", \"XL\", \"L\", \"\
    XC\", \"C\", \"CD\", \"C\", \"XC\", \"C\", \"XL\", \"L\"),\n            List(\"\
    I\", \"IV\", \"III\", \"II\", \"I\"),\n            List(\"IV\", \"III\", \"II\"\
    , \"I\"),\n            List(\"V\", \"VII\", \"VIII\", \"IX\"),\n            List(\"\
    VIII\", \"VII\", \"VIII\", \"X\"),\n            List(\"IX\", \"VIII\", \"VIII\"\
    , \"X\"),\n            List(\"X\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\"\
    , \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"),\n            List(\"XX\"\
    , \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\"),\n            List(\"X\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"\
    XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"),\n            List(\"\
    XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpvszmjwj7.scala:37:62 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            List(\e[31m\"XX\"\e[0m, \e[31m\"XXI\"\e[0m,\
    \ \e[31m\"XXII\"\e[0m, \e[31m\"XXIII\"\e[0m, \e[31m\"XXIV\"\e[0m, \e[31m\"XXV\"\
    \e[0m, \"XXVI\n\e[31m\e[31m   |\e[0m                                         \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \                 unclosed string literal\n\e[31m\e[31m-- Error: /tmp/tmpvszmjwj7.scala:39:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m39 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but '=' found\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvszmjwj7.scala:38:5 ---------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpvszmjwj7.scala:39:4 -------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    Not found: XXVIdef\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010724
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var i = 0\n        var romanNumberString = \"\"\n        var isLast = false\n\
    \        while(number > 0){\n            romanNumberString += romanNumeral(i++).toLowerCase\n\
    \            number -= romanNumeral(i).romanDigitValue\n            isLast = i\
    \ == romanNumeral.size\n        }\n        if (isLast)\n            romanNumberString\
    \ += romanNumeral(i).toLowerCase\n        return romanNumberString\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqmio2pmk.scala:19:49 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            romanNumberString += romanNumeral(i++).toLowerCase\n\
    \e[31m\e[31m   |\e[0m                                                 ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqmio2pmk.scala:19:30\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            romanNumberString\
    \ += romanNumeral(i++).toLowerCase\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of String - did you mean\
    \ String.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqmio2pmk.scala:19:33\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            romanNumberString\
    \ += romanNumeral(i++).toLowerCase\n\e[31m\e[31m   |\e[0m                    \
    \             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \    Not found: romanNumeral\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpqmio2pmk.scala:20:19 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m            number -= romanNumeral(i).romanDigitValue\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqmio2pmk.scala:20:22\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            number -= romanNumeral(i).romanDigitValue\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      Not found: romanNumeral\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpqmio2pmk.scala:21:26 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            isLast = i == romanNumeral.size\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \  "
  stdout: ''
  timestamp: 1660010726
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanList = List(\n            List(\"M\", \"MM\", \"MMM\", \"MMMM\"\
    , \"MMMMM\"),\n            List(\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\"\
    ),\n            List(\"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\"),\n       \
    \     List(\"V\", \"VV\", \"VVV\", \"IV\", \"I\", \"II\"),\n            List(\"\
    I\"),\n            List(\"N\", \"NN\", \"NNN\", \"NNNN\")\n        )\n       \
    \ val roman = romanList.find( x => x.forall(_.contains(number.toString)) ).get\n\
    \        val integer = number.toInt\n        val romanString = (roman.head + roman.drop(1)).mkString(\"\
    \")\n        val romanStringWithN = (romanString.replaceFirst(\"N\", \"M\") +\
    \ roman.drop(1).mkString(\"\"))\n        val romanStringWith0 = romanStringWithN.replaceAll(\"\
    0\", \"\")\n        val romanStringWithI = romanStringWith0.replaceFirst(\"I\"\
    , \"V\")\n        val romanStringWithII = romanStringWithI.replaceFirst(\"II\"\
    , \"VII\")\n        val romanStringWithIII = romanStringWithII.replaceFirst(\"\
    III\", \"VIII\")\n        romanStringWithIII.replaceFirst(\"IIII\", \"IX\").replaceFirst(\"\
    IV\", \"X\")\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: None.get\n\tat scala.None$.get(Option.scala:627)\n\
    \tat scala.None$.get(Option.scala:626)\n\tat Problem$.intToMiniRoman(tmpinrc9ixj.scala:23)\n\
    \tat Problem$.main(tmpinrc9ixj.scala:34)\n\tat Problem.main(tmpinrc9ixj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def isDivisible : Int => Boolean = {\n            val remainder = number\
    \ % 10\n            val isDivisible = remainder == 0\n            if (isDivisible)\
    \ {\n                number / 10\n            } else {\n                false\n\
    \            }\n        }\n\n        // Add zeros until number is evenly divisible\n\
    \        def addZero : Int => Int = {\n            var i = number\n          \
    \  while (isDivisible(i)) {\n                i /= 10\n            }\n        \
    \    i\n        }\n\n        // Add ones to number\n        def addOnes : Int\
    \ => Int = {\n            var i = number\n            while (!isDivisible(i))\
    \ {\n                i = i * 10 + 1\n            }\n            i\n        }\n\
    \n        def addOnesOrZeros : Int => Int = {\n            var i = number\n  \
    \          while (!isDivisible(i)) {\n                i = i * 10 + 1\n       \
    \         i /= 10\n            }\n            i\n        }\n\n        // Remove\
    \ one from number\n        def removeOne : Int => Int = {\n            var i =\
    \ number\n            while (isDivisible(i)) {\n                i /= 10\n    \
    \        }\n            i\n        }\n\n        def getMiniRoman(i : Int) : String\
    \ = {\n            val n1 = addOnesOrZeros(i)\n            val n2 = addOnes(n1)\n\
    \            val n3 = addOnes(n2)\n            val n4 = addOnes(n3)\n        \
    \    val n5 = addOnes(n4)\n            val n6 = addOnes(n5)\n            val n7\
    \ = removeOne(n6)\n            val n8 = removeOne(n7)\n            val n9 = removeOne(n8)\n\
    \            val n10 = addOnes(n9)\n            val n11 = addOnes(n10)\n     \
    \       val n12 = removeOne(n11)\n            val n13 = removeOne(n12)\n     \
    \       val n14 = addOnes(n13)\n            val n15 = addOnes(n14)\n         \
    \   val n16 = removeOne(n15)\n            val n17 = removeOne(n16)\n         \
    \   val n18 = addOnes(n17)\n            val n19 = addOnes(n18)\n            val\
    \ n20 = addOnes(n19)\n            val n21 = removeOne(n20)\n            val n22\
    \ = removeOne(n21)\n            val n23 = addOnes(n22)\n            val n24 =\
    \ addOnes(n23)\n            val n25 = removeOne(n24)\n            val n26 = removeOne(n25)\n\
    \            val n27 = addOnes(n26)\n            val n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp97mg1j2_.scala:90:4 ----------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp97mg1j2_.scala:109:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m109 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp97mg1j2_.scala:19:16 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m                number / \e[31m10\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Found:   \
    \ Long\n\e[31m   |\e[0m                Required: Int => Boolean\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp97mg1j2_.scala:21:16 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[31mfalse\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^\e[0m\n\e[31m   |\e[0m                Found:    (\e[31mfalse\e\
    [0m : Boolean)\n\e[31m   |\e[0m                Required: Int => Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp97mg1j2_.scala:28:31 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mwhile\e[0m (isDivisible(i)) {\n\e[31m\e\
    [31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m          \
    \                     Found:    (i : Long)\n\e[31m   |\e[0m                  \
    \             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp97mg1j2_.scala:31:12 --------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m            i\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0m\
    \            Found:    (i : Long)\n\e[31m   |\e[0m            Required: Int =>\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp97mg1j2_.scala:37:32\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mw"
  stdout: ''
  timestamp: 1660010730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \   val romans    = new mutable.TreeMap[Int, String]()\n      val thousands =\
    \ \"M\"\n      val millions  = \"CM\"\n      val hundreds  = \"D\"\n      val\
    \ thousandss = \"M\"\n      val millionss = \"CM\"\n      val hundredss = \"D\"\
    \n      val tens      = \"CD\"\n      val ones      = \"C\"\n      val tenss =\
    \ \"CD\"\n      val oness = \"C\"\n      var currentRoman = \"\"\n      var currentNumber\
    \ = 0\n      while(number > 0) {\n        currentNumber += 1\n        val romanInt\
    \ = number % 1000\n        if(romanInt > 0) {\n          currentRoman = romans.get\
    \ romanInt\n          if(currentRoman == null) {\n            romans.put(romanInt,\
    \ ones + currentNumber)\n          }\n          number -= romanInt\n        }\n\
    \        if(number % 1000 < 100) {\n          currentRoman = romans.get number\
    \ % 1000\n          number -= number % 1000\n          if(currentRoman == null)\
    \ {\n            romans.put(number % 1000, ones + number / 1000)\n          }\n\
    \        }\n        if(number % 100 < 10) {\n          currentRoman = romans.get\
    \ number % 100\n          number -= number % 100\n          if(currentRoman ==\
    \ null) {\n            romans.put(number % 100, ones + number / 100)\n       \
    \   }\n        }\n        if(number % 10 < 1) {\n          currentRoman = romans.get\
    \ number % 10\n          number -= number % 10\n          if(currentRoman == null)\
    \ {\n            romans.put(number % 10, ones + number / 10)\n          }\n  \
    \      }\n      }\n      romans.values.toList.reverse.mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxzjvoj51.scala:32:44 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m          currentRoman = romans.get romanInt\n\e[31m\e\
    [31m   |\e[0m                                            ^\e[0m\n\e[31m   |\e\
    [0m                                        expression expected but \e[31mif\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpxzjvoj51.scala:39:45\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m39 |\e[0m       \
    \   currentRoman = romans.get number % \e[31m1000\e[0m\n\e[31m\e[31m   |\e[0m\
    \                                             ^\e[0m\n\e[31m   |\e[0m        \
    \             end of statement expected but integer literal found\n\e[31m\e[31m--\
    \ Error: /tmp/tmpxzjvoj51.scala:46:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m          currentRoman = romans.get number % \e[31m100\e\
    [0m\n\e[31m\e[31m   |\e[0m                                             ^\e[0m\n\
    \e[31m   |\e[0m                     end of statement expected but integer literal\
    \ found\n\e[31m\e[31m-- Error: /tmp/tmpxzjvoj51.scala:53:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m          currentRoman = romans.get number % \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m                                             ^\e[0m\n\
    \e[31m   |\e[0m                     end of statement expected but integer literal\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxzjvoj51.scala:15:26 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m      \e[33mval\e[0m \e[36mromans\e[0m    = \e[33mnew\e\
    [0m mutable.TreeMap[\e[35mInt\e[0m, \e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpxzjvoj51.scala:36:17 ------------------------\e[0m\e[0m\n\e[31m36 |\e\
    [0m          number -= romanInt\n\e[31m\e[31m   |\e[0m          ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m          value -= is not a member of Long - did you "
  stdout: ''
  timestamp: 1660010728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Initialize result to empty string\n        var result : String = \"\"\
    \n        // Iterate from right to left (towards minus number) and append a letter\n\
    \        // as long as the number is divisible by 3\n        for(i <- number;\
    \ number >= 3; i -= 3) {\n            result += (number % 3).toChar\n        \
    \    number /= 3\n        }\n        // Append the rest in reverse order\n   \
    \     result ++= number.toCharArray.takeWhile(_ < '3').reverse\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo2eigfnu.scala:19:36 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mfor\e[0m(i <- number; number >= \e[31m3\e\
    [0m; i -= \e[31m3\e[0m) {\n\e[31m\e[31m   |\e[0m                             \
    \       ^\e[0m\n\e[31m   |\e[0m                                    '<-' expected,\
    \ but ';' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo2eigfnu.scala:19:44\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mfor\e[0m(i\
    \ <- number; number >= \e[31m3\e[0m; i -= \e[31m3\e[0m) {\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m       \
    \                                     '<-' expected, but ')' found\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpo2eigfnu.scala:19:17 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mfor\e[0m(i <- number; number >= \e[31m3\e\
    [0m; i -= \e[31m3\e[0m) {\n\e[31m\e[31m   |\e[0m                 ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                 value foreach is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpo2eigfnu.scala:24:15 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        result ++= number.toCharArray.takeWhile(_ < \e\
    [31m'3'\e[0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m        value ++= is not a member of String\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpo2eigfnu.scala:24:26 ------------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m        result ++= number.toCharArray.takeWhile(_ < \e[31m'3'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   value toCharArray is not a member of Long\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660010728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val digits = BigDecimal(number).toBigDecimal.toString().split('')\n    \
    \    val romanNum = BigInteger.valueOf(number.toInt).divide(BigInteger.valueOf(1000))\n\
    \        val miniRoman = \"\"\n        for (digit <- digits) {\n            val\
    \ number = romanNum.multiply(BigInteger.valueOf(10)).add(BigInteger.valueOf(digit))\n\
    \            val num = number.divide(BigInteger.valueOf(1000))\n            miniRoman\
    \ = miniRoman+(if (num.equals(BigInteger.ZERO)) \"M\" else if (num.equals(BigInteger.ONE))\
    \ \"D\" else if (num.equals(BigInteger.TEN)) \"CM\" else if (num.equals(BigInteger.FIFTY))\
    \ \"CD\" else if (num.equals(BigInteger.THIRTY)) \"XC\" else num.toString())\n\
    \        }\n        return miniRoman\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpctav4r27.scala:15:70 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = BigDecimal(number).toBigDecimal.toString().split('')\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \              ^\e[0m\n\e[31m   |\e[0m                                       \
    \          empty character literal\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpctav4r27.scala:16:21\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mromanNum\e[0m = BigInteger.valueOf(number.toInt).divide(BigInteger.valueOf(\e\
    [31m1000\e[0m))\n\e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e\
    [0m                     expression expected but \e[31m=\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpctav4r27.scala:15:40 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = BigDecimal(number).toBigDecimal.toString().split('')\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue toBigDecimal is not a member of BigDecimal - did you mean\
    \ BigDecimal.bigDecimal?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpctav4r27.scala:16:8\
    \ -------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mromanNum\e[0m = BigInteger.valueOf(number.toInt).divide(BigInteger.valueOf(\e\
    [31m1000\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e[31m   |\e[0m      \
    \  Not found: 'val\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val result: List[String] = for {\n            i  <- number /  100\n    \
    \        r <- RomanDigits(i)\n        } yield {\n            val rr = r.mkString\n\
    \            val rs = r.mkString.reverse\n            rr + rs + RomanDigits(number\
    \ - i * 100)\n        }\n        result.minBy(_.length)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprz41jv5_.scala:16:18 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            i  <- number /  \e[31m100\e[0m\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \       value flatMap is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNum: mutable.Queue[String] = mutable.Queue(\"\")\n        val numDigit\
    \ = number.toString().length\n        var i = numDigit - 1\n        while (i >=\
    \ 0) {\n            romanNum.enqueue(number.toString(i))\n            i -= 1\n\
    \        }\n        val romanNumReverse: mutable.Queue[String] = mutable.Queue(\"\
    \")\n        romanNum.dequeueAll()(romanNumReverse)\n        val stringReverse\
    \ = romanNumReverse.reverse().mkString\n        for (item <- stringReverse) {\n\
    \            romanNum.enqueue(item)\n        }\n        val romanNumAsString =\
    \ romanNum.reverse().mkString(\"\")\n        val romanNumAsStringUpper = romanNumAsString.toUpperCase()\n\
    \        val miniRomanNumAsString = romanNumAsStringUpper.dropRight(1)\n     \
    \   return miniRomanNumAsString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfty74gtd.scala:15:22 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mromanNum\e[0m: mutable.Queue[\e\
    [35mString\e[0m] = mutable.Queue(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfty74gtd.scala:15:46\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mromanNum\e[0m: mutable.Queue[\e[35mString\e[0m] = mutable.Queue(\e[31m\"\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m                                              ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                              Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfty74gtd.scala:22:29\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mromanNumReverse\e[0m: mutable.Queue[\e[35mString\e[0m] = mutable.Queue(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpfty74gtd.scala:22:53 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mromanNumReverse\e[0m: mutable.Queue[\e\
    [35mString\e[0m] = mutable.Queue(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \                                                ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                                     Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var remainder = number\n        var result = \"\"\n        while (remainder\
    \ > 0) {\n            remainder -= 1\n            if (remainder >= 1000) {\n \
    \               result += convert(remainder / 1000) + \"k\"\n                remainder\
    \ %= 1000\n            }\n            result += convert(remainder)\n        }\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpakkowjfr.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                result += convert(remainder / \e[31m1000\e\
    [0m) + \e[31m\"k\"\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            value += is not a member of String - did you mean String.!=?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpakkowjfr.scala:20:26 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                result += convert(remainder / \e[31m1000\e\
    [0m) + \e[31m\"k\"\e[0m\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Not found: convert\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpakkowjfr.scala:23:19 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            result += convert(remainder)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpakkowjfr.scala:23:22 ------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            result += convert(remainder)\n\e[31m\e[31m   |\e[0m      \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ convert\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def intToRoman(number : Int) : String = { \n            if (number > 999)\
    \ {\n                return \"999\"\n            }\n            val romans = (100\
    \ to 400 by 10)\n            var result: String = \"\"\n            var remaining:\
    \ Int = number\n            romans.foreach(r => remaining -= r)\n            while\
    \ (remaining >= 10) {\n                result += romans(remaining % 10) + \"\"\
    \n                remaining /= 10\n            }\n            result += romans(remaining\
    \ + \"\")\n            result \n        }\n\n        if (number <= 0) {\n    \
    \        throw new RuntimeException(\"Number cannot be <= 0\")\n        }\n  \
    \      if (number >= 1000) {\n            throw new RuntimeException(\"Number\
    \ cannot be >= 1000\")\n        }\n        val numeral = (0 to number by 10).map(i\
    \ => intToRoman(i))\n        (numeral ++ numeral.drop(1)).mkString\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwyt95vli.scala:27:19 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            result += romans(remaining + \e[31m\"\"\e\
    [0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \     value += is not a member of String - did you mean String.!=?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpwyt95vli.scala:27:29 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            result += romans(remaining + \e[31m\"\"\e\
    [0m)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                             Found:    String\n\e[31m   |\e[0m  \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpwyt95vli.scala:37:28 --------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mnumeral\e[0m = (\e[31m0\e[0m\
    \ to number by \e[31m10\e[0m).map(\e[36mi\e[0m => intToRoman(i))\n\e[31m\e[31m\
    \   |\e[0m                            ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                 Found:    (number : Long)\n\e[31m   |\e[0m                 \
    \           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = \"M\"\n        var digits = \"\"\n        var currentNumber\
    \ = 0l\n        while (currentNumber < number) {\n            currentNumber =\
    \ number / 100l\n            digits = digits() + roman\n            roman = roman(\"\
    x\")\n            roman = roman(\"v\")\n            roman = roman(\"l\")\n   \
    \         roman = roman(\"c\")\n            roman = roman(\"d\")\n           \
    \ roman = roman(\"m\")\n            number = number % 100\n        }\n       \
    \ roman = roman(digits)\n        roman = roman.charAt(0).toLower\n        return\
    \ roman\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp59veyw2a.scala:20:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            digits = digits() + roman\n\e[31m\e[31m \
    \  |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument for\
    \ parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e[0m \e[35mStringOps\e\
    [0m: (i: Int): Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp59veyw2a.scala:21:26\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            roman = roman(\e\
    [31m\"x\"\e[0m)\n\e[31m\e[31m   |\e[0m                          ^^^\e[0m\n\e[31m\
    \   |\e[0m                          Found:    (\e[32m\"x\"\e[0m : String)\n\e\
    [31m   |\e[0m                          Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp59veyw2a.scala:22:26 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            roman = roman(\e[31m\"v\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                          ^^^\e[0m\n\e[31m   |\e[0m             \
    \             Found:    (\e[32m\"v\"\e[0m : String)\n\e[31m   |\e[0m         \
    \                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp59veyw2a.scala:23:26 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            roman = roman(\e[31m\"l\"\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                       ^^^\e[0m\n\e[31m   |\e[0m                          Found:\
    \    (\e[32m\"l\"\e[0m : String)\n\e[31m   |\e[0m                          Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp59veyw2a.scala:24:26\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            roman = roman(\e\
    [31m\"c\"\e[0m)\n\e[31m\e[31m   |\e[0m                          ^^^\e[0m\n\e[31m\
    \   |\e[0m                          Found:    (\e[32m\"c\"\e[0m : String)\n\e\
    [31m   |\e[0m                          Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: "
  stdout: ''
  timestamp: 1660010732
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val nums = Map(\"I\" -> 1, \"V\" -> 5, \"X\" -> 10, \"L\" -> 50, \"C\" ->\
    \ 100, \"D\" -> 500, \"M\" -> 1000)\n        val s = nums.get(number.toInt) match\
    \ {\n            case Some(number) => s\"${number}\"\n            case None  \
    \        => \"none\"\n        }\n        s + \"_\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn7uqhhg_.scala:16:32\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36ms\e\
    [0m = nums.get(number.toInt) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m       \
    \                  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \ Found:    Int\n\e[31m   |\e[0m                         Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def roman(number : Long): String = {\n            def gt(n : Long, n1 :\
    \ Long, n2 : Long): Boolean = {\n                if(n>n1 && n>n2) true else false\n\
    \            }\n            def roman(m : Int, n1 :Long, n2 : Long): String =\
    \ {\n                val res = \"\"\n                val c = m - n1\n        \
    \        if(c>=0) res += roman(c, n1, n2)\n                if(c<0) res += roman(-c,\
    \ n1, n2)\n                res\n            }\n            val x = number%100\n\
    \            val y = number%10\n            if(y>2) roman(y,x,100) ++ roman(y-1,\
    \ x-1,10)\n            else roman(x,100,10)\n        }\n        val n = number\n\
    \        val i = Math.floor(n/100l)\n        val m = n%100l\n        val r = roman(i,\
    \ 100, 10)\n        val o = roman(i, 10, 10)\n        if(m==100 && r==o) r\n \
    \       else r+o\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy8n82ipb.scala:22:29 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mif\e[0m(c>=\e[31m0\e[0m) res +=\
    \ roman(c, n1, n2)\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\
    \e[31m   |\e[0m               value += is not a member of String - did you mean\
    \ res.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy8n82ipb.scala:22:38\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m                \e[33mif\e[0m(c>=\e\
    [31m0\e[0m) res += roman(c, n1, n2)\n\e[31m\e[31m   |\e[0m                   \
    \                   ^\e[0m\n\e[31m   |\e[0m                                  \
    \    Found:    (c : Long)\n\e[31m   |\e[0m                                   \
    \   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy8n82ipb.scala:23:28\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33mif\e\
    [0m(c<\e[31m0\e[0m) res += roman(-c, n1, n2)\n\e[31m\e[31m   |\e[0m          \
    \              ^^^^^^\e[0m\n\e[31m   |\e[0m               value += is not a member\
    \ of String - did you mean res.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpy8n82ipb.scala:23:37 --------------------\e[0m\e[0m\n\e[31m23 |\e[0m\
    \                \e[33mif\e[0m(c<\e[31m0\e[0m) res += roman(-c, n1, n2)\n\e[31m\e\
    [31m   |\e[0m                                     ^^\e[0m\n\e[31m   |\e[0m   \
    \                                  Found:    Long\n\e[31m   |\e[0m           \
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpy8n82ipb.scala:28:26 --------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            \e[33mif\e[0m(y>\e[31m2\e[0m) roman(y,x,\e[31m100\e\
    [0m) ++ roman(y-\e[31m1\e[0m, x-\e[31m1\e[0m,\e[31m10\e[0m)\n\e[31m\e[31m   |\e\
    [0m                          ^\e[0m\n\e[31m   |\e[0m                         \
    \ Found:    (y : Long)\n\e[31m   |\e[0m                          Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- "
  stdout: ''
  timestamp: 1660010732
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // write your code\n        return \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpabkc_jy9.scala:19)\n\tat Problem.main(tmpabkc_jy9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Create a list of characters that will be used as the roman numerals.\n\
    \        val numerals = List.tabulate(8)(_ => \"M\")\n        // Add the letters\
    \ for the corresponding numbers.\n        numerals(number % 100l) :: numerals(number\
    \ % 100l / 10l) :: numerals(number / 10l) :: numerals(number % 10l) :: List.empty\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu0nwff6s.scala:18:103\
    \ -------------------\e[0m\e[0m\n\e[31m18 |\e[0m        numerals(number % \e[31m100l\e\
    [0m) :: numerals(number % \e[31m100l\e[0m / \e[31m10l\e[0m) :: numerals(number\
    \ / \e[31m10l\e[0m) :: numerals(number % \e[31m10l\e[0m) :: List.empty\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                                       Found:    Long\n\e[31m\
    \   |\e[0m                                                          Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu0nwff6s.scala:18:77\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        numerals(number % \e\
    [31m100l\e[0m) :: numerals(number % \e[31m100l\e[0m / \e[31m10l\e[0m) :: numerals(number\
    \ / \e[31m10l\e[0m) :: numerals(number % \e[31m10l\e[0m) :: List.empty\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \                             Found:    Long\n\e[31m   |\e[0m                \
    \                                          Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu0nwff6s.scala:18:44 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        numerals(number % \e[31m100l\e[0m) :: numerals(number\
    \ % \e[31m100l\e[0m / \e[31m10l\e[0m) :: numerals(number / \e[31m10l\e[0m) ::\
    \ numerals(number % \e[31m10l\e[0m) :: List.empty\n\e[31m\e[31m   |\e[0m     \
    \                                       ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                            Found:    Long\n\e[31m   |\e[0m\
    \                                            Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu0nwff6s.scala:18:17 --------------------\e\
    [0m\e[0m\n"
  stdout: ''
  timestamp: 1660010733
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman : String = \"\"\n        var i = 2\n        while(i < (number\
    \ / 1000)){\n            roman += (100 * i) + \"-\" + i\n            i = i + 1\n\
    \        }\n        roman += ((number % 1000) * i)\n        roman = roman.substring(0,\
    \ roman.length - 1)\n        return roman\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_if5wkhx.scala:26)\n\tat Problem.main(tmp_if5wkhx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010733
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number < 1 || number > 1000) throw new IllegalArgumentException(\"invalid\
    \ argument\")\n        val romanList = List(\"M\", \"D\", \"C\", \"L\", \"X\"\
    , \"V\", \"I\")\n        val res = romanList.foldLeft(\"X\")((acc, val) => if\
    \ (val <= number) acc + val + 1 else \"X\")\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpew_mm093.scala:17:48 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = romanList.foldLeft(\e\
    [31m\"X\"\e[0m)((\e[36macc\e[0m, \e[33mval\e[0m) => \e[33mif\e[0m (\e[33mval\e\
    [0m <= number) acc + \e[33mval\e[0m + \e[31m1\e[0m \e[33melse\e[0m \e[31m\"X\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m                                                ^^^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpew_mm093.scala:17:60 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = romanList.foldLeft(\e[31m\"X\"\
    \e[0m)((\e[36macc\e[0m, \e[33mval\e[0m) => \e[33mif\e[0m (\e[33mval\e[0m <= number)\
    \ acc + \e[33mval\e[0m + \e[31m1\e[0m \e[33melse\e[0m \e[31m\"X\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                            ^^^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpew_mm093.scala:17:81 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = romanList.foldLeft(\e[31m\"X\"\
    \e[0m)((\e[36macc\e[0m, \e[33mval\e[0m) => \e[33mif\e[0m (\e[33mval\e[0m <= number)\
    \ acc + \e[33mval\e[0m + \e[31m1\e[0m \e[33melse\e[0m \e[31m\"X\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                 ^^^\e[0m\n\e[31m   |\e[0m                                  \
    \     expression expected but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = mutable.Queue[String]()\n        for (i <- 1 to number) {\n\
    \            val romanNum = numberToRoman(i)\n            roman.addFirst(romanNum)\n\
    \        }\n        roman.pollFirst().toLowerCase + (roman.pollFirst() match {\n\
    \            case \"\" => \"\"\n            case s => s\n        })\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk48zr9bg.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mroman\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpk48zr9bg.scala:16:23 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m (i <- \e[31m1\e[0m to number)\
    \ {\n\e[31m\e[31m   |\e[0m                       ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                       Found:    (number : Long)\n\e[31m   |\e[0m           \
    \            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpk48zr9bg.scala:17:27 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m            \e[33mval\e[0m \e[36mromanNum\e[0m = numberToRoman(i)\n\e[31m\e\
    [31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                         Not found: numberToRoman\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010734
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var results = new Array[String](1000);\n        var numeral = number % 1000;\n\
    \        var divisor = number / 1000;\n        var last = 0;\n        var length\
    \ : Int = 0;\n        while (divisor > 0) {\n            divisor = divisor / 10;\n\
    \            last = last + 1;\n        }\n        results(last) = \"M\"\n    \
    \    divisor = number / 1000;\n        while (divisor > 0) {\n            divisor\
    \ = divisor / 10;\n            last = last + 1;\n        }\n        results(last)\
    \ = \"CM\"\n        divisor = number / 1000;\n        while (divisor > 0) {\n\
    \            divisor = divisor / 10;\n            last = last + 1;\n        }\n\
    \        results(last) = \"D\"\n        divisor = number / 1000;\n        while\
    \ (divisor > 0) {\n            divisor = divisor / 10;\n            last = last\
    \ + 1;\n        }\n        results(last) = \"CD\"\n        divisor = number /\
    \ 1000;\n        while (divisor > 0) {\n            divisor = divisor / 10;\n\
    \            last = last + 1;\n        }\n        results(last) = \"C\"\n    \
    \    divisor = number / 1000;\n        while (divisor > 0) {\n            divisor\
    \ = divisor / 10;\n            last = last + 1;\n        }\n        results(last)\
    \ = \"XC\"\n        divisor = number / 1000;\n        while (divisor > 0) {\n\
    \            divisor = divisor / 10;\n            last = last + 1;\n        }\n\
    \        results(last) = \"L\"\n        divisor = number / 1000;\n        while\
    \ (divisor > 0) {\n            divisor = divisor / 10;\n            last = last\
    \ + 1;\n        }\n        results(last) = \"XL\"\n        divisor = number /\
    \ 1000;\n        while (divisor > 0) {\n            divisor = divisor / 10;\n\
    \            last = last + 1;\n        }\n        results(last) = \"X\"\n    \
    \    divisor = number / 1000;\n        while (divisor > 0) {\n            divisor\
    \ = divisor / 10;\n            last = last + 1;\n        }\n        results(last)\
    \ = \"IX\"\n        divisor = number / 1000;\n        while (divisor > 0) {\n\
    \            divisor = divisor / 10;\n            last = last + 1;\n        }\n\
    \        results(last) = \"V\"\n        divisor = number / 1000;\n        while\
    \ (divisor > 0) {\n            divisor = divisor / 10;\n            last = last\
    \ + 1;\n        }\n        results(last) = \"IV\"\n        divisor = number /\
    \ 1000;\n        while (divisor > 0) {\n            divisor = divisor / 10;\n\
    \            last = last + 1;\n        }\n        results(last) = \"I\"\n    \
    \    divisor = \n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7tv2prj8.scala:97:17 ---------------------------\e\
    [0m\e[0m\n\e[31m97 |\e[0m        divisor = \n\e[31m\e[31m   |\e[0m           \
    \      ^\e[0m\n\e[31m   |\e[0m                 expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def romanToInt(roman: String, i: Int, count: Int) : Int = {\n          \
    \  if (roman == \"\") count\n            else {\n                if (roman ==\
    \ \"I\" && i == 0) i\n                else {\n                    if (roman ==\
    \ \"V\" && i == 1) i + 1\n                    else if (roman == \"X\" && i ==\
    \ 2) i + 3\n                    else romanToInt(roman.dropRight(i), i - 1, count\
    \ + 1)\n                }\n            }\n        }\n        def digitToInt(digit:\
    \ Int) : Int = digit\n        val zero = 0\n        var roman = \"\"\n       \
    \ var remaining = number\n        while(number.isEven) {\n            remaining\
    \ = remaining.dropRight(1)\n            roman = \"M\" + roman\n        }\n   \
    \     while(remaining.isEven) {\n            remaining = remaining.dropRight(1)\n\
    \            roman = roman + \"C\"\n        }\n        remaining = (remaining\
    \ - zero) * 10 + zero\n        var i = zero\n        while(roman.length > 0) {\n\
    \            i = romanToInt(roman, i, 0)\n            roman = roman.dropRight(1)\n\
    \        }\n        roman = roman.toString\n        var i = zero\n        var\
    \ romanNumber = 0\n        while(i < roman.length) {\n            romanNumber\
    \ += digitToInt(roman(i))\n            i = i + 1\n        }\n        roman = roman.dropRight(1)\n\
    \        (romanNumber toString) toLowerCase\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpw_lswv7s.scala:52:29 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        (romanNumber toString) toLowerCase\n\e[31m\e\
    [31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m            \
    \                 expression expected but \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpw_lswv7s.scala:52:42 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        (romanNumber toString) toLowerCase\n\e[31m\e\
    [31m   |\e[0m                                          ^\e[0m\n\e[31m   |\e[0m\
    \                                       expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw_lswv7s.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mi\e[0m = zero\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mi is already defined as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw_lswv7s.scala:30:21\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mwhile\e[0m(number.isEven)\
    \ {\n\e[31m\e[31m   |\e[0m              ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \            value isEven is not a member of Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpw_lswv7s.scala:31:34 ------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m            remaining = remaining.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                      value dropRight is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpw_lswv7s.scala:34:24 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mwhile\e[0m(remaining.isEven) {\n\e[31m\e\
    [31m   |\e[0m              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \  value isEven is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:"
  stdout: ''
  timestamp: 1660010737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if(number > 1000 || number <= 0) {\n            throw new IllegalArgumentException(\"\
    Invalid Arguments\")\n        }\n        var result = \"\"\n        var base =\
    \ 1\n        var digits = \"\"\n        var rem = 0\n        // Loop to obtain\
    \ the last remainder\n        while(number >= base)\n        {\n            rem\
    \ = number % base\n            number = number / base\n            digits = digits\
    \ + rem\n        }\n        if(digits == \"\") {\n            digits = \"0\"\n\
    \        }\n        // Loop to obtain the final roman\n        for(i <- 0 until\
    \ digits.length) {\n            val remainder = digits.charAt(i) - '0'\n     \
    \       val output = rem * base\n            val newOutput = output + remainder\n\
    \            result += Integer.toString(newOutput)\n            base *= 10\n \
    \       }\n        result.toLowerCase\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzltvnkeq.scala:25:18\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m            rem = number % base\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \               Found:    Long\n\e[31m   |\e[0m                  Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpzltvnkeq.scala:26:19 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            number = number / base\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val number\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010736
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val stringToReturn = string.empty\n        val firstTen = number % 10\n\
    \        if (firstTen < 3) {\n            stringToReturn += firstTen.toString\n\
    \        } else if (firstTen < 6) {\n            stringToReturn += \"v\"\n   \
    \     } else if (firstTen < 9) {\n            stringToReturn += \"vi\"\n     \
    \   } else if (firstTen < 12) {\n            stringToReturn += \"i\"\n       \
    \ } else if (firstTen < 15) {\n            stringToReturn += \"x\"\n        }\
    \ else if (firstTen < 17) {\n            stringToReturn += \"l\"\n        } else\
    \ if (firstTen < 20) {\n            stringToReturn += \"c\"\n        } else if\
    \ (firstTen < 24) {\n            stringToReturn += \"d\"\n        } else if (firstTen\
    \ < 27) {\n            stringToReturn += \"h\"\n        } else if (firstTen <\
    \ 30) {\n            stringToReturn += \"m\"\n        } else {\n            stringToReturn\
    \ += \"n\"\n        }\n        val tenToFifteen = number % 100\n        if (tenToFifteen\
    \ < 50) {\n            stringToReturn += \"l\"\n        } else if (tenToFifteen\
    \ < 90) {\n            stringToReturn += \"c\"\n        } else if (tenToFifteen\
    \ < 140) {\n            stringToReturn += \"d\"\n        } else if (tenToFifteen\
    \ < 190) {\n            stringToReturn += \"h\"\n        } else if (tenToFifteen\
    \ < 240) {\n            stringToReturn += \"m\"\n        } else {\n          \
    \  stringToReturn += \"n\"\n        }\n        val fifty = number % 1000\n   \
    \     if (fifty < 500) {\n            stringToReturn += \"l\"\n        } else\
    \ if (fifty < 1000) {\n            stringToReturn += \"c\"\n        } else if\
    \ (fifty < 2000) {\n            stringToReturn += \"d\"\n        } else if (fifty\
    \ < 3000) {\n            stringToReturn += \"h\"\n        } else if (fifty < 4000)\
    \ {\n            stringToReturn += \"m\"\n        } else {\n            stringToReturn\
    \ += \"n\"\n        }\n        stringToReturn\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprycijn6p.scala:15:29 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mstringToReturn\e[0m = string.empty\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: string\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010733
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanTable = scala.collection.mutable.Map[Int, String]()\n        romanTable\
    \ += (0l -> \"i\")\n        romanTable += (1l -> \"ii\")\n        romanTable +=\
    \ (3l -> \"iii\")\n        romanTable += (4l -> \"iv\")\n        romanTable +=\
    \ (5l -> \"v\")\n        romanTable += (6l -> \"vi\")\n        romanTable += (9l\
    \ -> \"vii\")\n        romanTable += (10l -> \"viii\")\n        romanTable +=\
    \ (40l -> \"ix\")\n        romanTable += (50l -> \"x\")\n        romanTable +=\
    \ (90l -> \"xix\")\n        romanTable += (100l -> \"xix\")\n\n        var result\
    \ : String = \"\"\n        var tempString : String = \"\"\n\n        number match\
    \ {\n            case 1l | 9l => return romanTable(number).asInstanceOf[String]\n\
    \            case other => {\n                val value = romanTable(number)\n\
    \                tempString = value.substring(0, value.length-1)\n           \
    \     result = tempString + romanTable(other).asInstanceOf[String]\n         \
    \   }\n        }\n        result.toLower\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnat9xg3s.scala:16:23\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        romanTable += (\e[31m0l\e\
    [0m -> \e[31m\"i\"\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (\e[1m\e[31mLong\e[0m, String)\n\
    \e[31m   |\e[0m                       Required: (\e[1m\e[32mInt\e[0m, String)\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnat9xg3s.scala:17:23\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        romanTable += (\e[31m1l\e\
    [0m -> \e[31m\"ii\"\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (\e[1m\e[31mLong\e[0m, String)\n\
    \e[31m   |\e[0m                       Required: (\e[1m\e[32mInt\e[0m, String)\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnat9xg3s.scala:18:23\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        romanTable += (\e[31m3l\e\
    [0m -> \e[31m\"iii\"\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (\e[1m\e[31mLong\e[0m, String)\n\
    \e[31m   |\e[0m                       Required: (\e[1m\e[32mInt\e[0m, String)\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnat9xg3s.scala:19:23\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        romanTable += (\e[31m4l\e\
    [0m -> \e[31m\"iv\"\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (\e[1m\e[31mLong\e[0m, String)\n\
    \e[31m   |\e[0m                       Required: (\e[1m\e[32mInt\e[0m, String)\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnat9xg3s.scala:20:23\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        romanTable += (\e[31m5l\e\
    [0m -> \e[31m\"v\"\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^\e\
    [0m\n\e[31m"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numStr = number.toString.substring(1,number.toString)\n        val numDigit\
    \ = numStr.length\n        val roman = numStr.groupBy(_ == 'M').mapValues(_.size)\n\
    \                .filter(_._2 > 1).map(_._1).reverse\n        val romStr = \"\"\
    \n        var i = 0\n        var j = 0\n        while(i < numDigit) {\n      \
    \      j += 1\n            val r = roman(j)\n            val c = numStr(i).toLowerCase\n\
    \            if (r > 0) romStr += c + roman(j-1) + \" \"\n            i += r\n\
    \        }\n        val ret = romStr.trim\n        ret = ret.substring(0, ret.length\
    \ - 1)\n        return ret\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp679jf3qe.scala:15:49\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnumStr\e\
    [0m = number.toString.substring(\e[31m1\e[0m,number.toString)\n\e[31m\e[31m  \
    \ |\e[0m                                                 ^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                 Found:    String\n\
    \e[31m   |\e[0m                                                 Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp679jf3qe.scala:18:44\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mroman\e[0m = numStr.groupBy(_ == \e[31m'M'\e[0m).mapValues(_.size)\n\e[31m18\
    \ |\e[0m                .filter(_._2 > \e[31m1\e[0m).map(_._1).reverse\n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0mvalue reverse is not a\
    \ member of scala.collection.View[Boolean] - did you mean scala.collection.View[Boolean].reversed?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp679jf3qe.scala:25:30 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mc\e[0m = numStr(i).toLowerCase\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    value toLowerCase is not a member of Char\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp679jf3qe.scala:26:30 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mif\e[0m (r > \e[31m0\e[0m) romStr +=\
    \ c + roman(j-\e[31m1\e[0m) + \e[31m\" \"\e[0m\n\e[31m\e[31m   |\e[0m        \
    \               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of String - did you mean romStr.!=?\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp679jf3qe.scala:30:12\
    \ -----------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        ret = ret.substring(\e\
    [31m0\e[0m, ret.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val ret\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val n = number.toInt\n        val roman = mutable.MutableList[String]()\n\
    \        val romanNums = List[Long](0, 1000, 900, 500, 400, 100, 90, 50, 40, 10,\
    \ 9, 5, 4, 1)\n        for (romanNum <- romanNums) {\n            if (romanNum\
    \ <= n) roman.append(romanNum.toString)\n            else\n                roman.append(romanNum.toString.substring(0,\
    \ romanNum - n))\n        }\n        roman.reverse.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp03ezs_9q.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mroman\e[0m = mutable.MutableList[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010736
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def intToRoman(num: Int) : String = {\n            val result: StringBuilder\
    \ = new StringBuilder();\n            if (num == 0) result.append(\"0\");\n  \
    \          else while (num > 0) {\n                val roman: String = num % 1000;\n\
    \                num /= 1000;\n                result.append(roman);\n       \
    \     }\n            val numRoman: String = result.toString;\n            val\
    \ int: Int = numRoman.toInt;\n            val str: String = (int + \"\").toLowerCase();\n\
    \            str\n        }\n        val str: String = (number + \"\").toLowerCase;\n\
    \        val numberList: Seq[Long] = str.split('');\n        val numRoman: Seq[String]\
    \ = numberList.map { intToRoman(_) };\n        numRoman.mkString.trim\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmprv5v6k_s.scala:29:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mnumberList\e[0m: \e[35mSeq\e\
    [0m[\e[35mLong\e[0m] = str.split('');\n\e[31m\e[31m   |\e[0m                 \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \                      empty character literal\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmprv5v6k_s.scala:30:20 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mnumRoman\e[0m: \e[35mSeq\e[0m[\e[35mString\e\
    [0m] = numberList.map { intToRoman(_) };\n\e[31m\e[31m   |\e[0m              \
    \      ^\e[0m\n\e[31m   |\e[0m                    expression expected but \e[31m:\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmprv5v6k_s.scala:30:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mnumRoman\e[0m: \e[35mSeq\e[0m[\e[35mString\e[0m] = numberList.map\
    \ { intToRoman(_) };\n\e[31m\e[31m   |\e[0m                                  ^\e\
    [0m\n\e[31m   |\e[0m                                 end of statement expected\
    \ but '=' found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprv5v6k_s.scala:19:36\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                \e[33mval\e[0m\
    \ \e[36mroman\e[0m: \e[35mString\e[0m = num % \e[31m1000\e[0m;\n\e[31m\e[31m \
    \  |\e[0m                                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                    Found:    Int\n\e[31m   |\e[0m          \
    \                          Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmprv5v6k_s.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                num /= \e[31m1000\e[0m;\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                value /=\
    \ is not a member of Int - did you mean num.!=?\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmprv5v6k_s.scala:30:8 -------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mnumRoman\e[0"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Convert int to an array of chars\n        val chars = number.toCharArray\n\
    \        // Make chars mutable (by creating a mutable list\n        val charList\
    \ = chars map (_ -> 1) toList\n        // Loop through the array of chars, adding\
    \ one to each value\n        charList.foreach { case (count, value) =>\n     \
    \       if (count == 1)\n                chars(value) = chars(value) + 1\n   \
    \     }\n        // Return the string with one char per line\n        chars.toList.map(_.toLower).mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4ho4xt20.scala:16:27 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mchars\e[0m = number.toCharArray\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    value toCharArray is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = \"\"\n        var max = 0\n        while (number > 0) {\n  \
    \          if (number > max) {\n                max = number\n               \
    \ roman = roman + romanLetters(number)\n            } else {\n               \
    \ if (number % 10 > 5) {\n                    roman = roman + romanLetters(number\
    \ / 10) + romanLetters(number % 10)\n                } else {\n              \
    \      roman = roman + romanLetters(number / 10) + romanLetters(number % 10) +\
    \ romanLetters(5)\n                }\n            }\n            number = number\
    \ / 10\n        }\n        return roman\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzblgccyu.scala:19:22\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m                max = number\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                Found:    (number : Long)\n\e[31m   |\e[0m                  \
    \    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzblgccyu.scala:20:32\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m                roman = roman\
    \ + romanLetters(number)\n\e[31m\e[31m   |\e[0m                              \
    \  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                Not found:\
    \ romanLetters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzblgccyu.scala:23:36\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                    roman\
    \ = roman + romanLetters(number / \e[31m10\e[0m) + romanLetters(number % \e[31m10\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Not found: romanLetters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzblgccyu.scala:23:64\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                    roman\
    \ = roman + romanLetters(number / \e[31m10\e[0m) + romanLetters(number % \e[31m10\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                                  \
    \              ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \                     Not found: romanLetters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpzblgccyu.scala:25:36 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    roman = roman + romanLetters(number\
    \ / \e[31m10\e[0m) + romanLetters(number % \e[31m10\e[0m) + romanLetters(\e[31m5\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^\e\
    [0m\n\e[31m "
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number == 0) {\n            return \"\"\n        }\n        var roman\
    \ = \"\"\n        var remainder = number\n        var i = 0\n        while (remainder\
    \ >= 1000) {\n            remainder -= 1000\n            roman += romanToChar(1000)\n\
    \        }\n        while (remainder >= 100) {\n            remainder -= 100\n\
    \            roman += romanToChar(100)\n        }\n        while (remainder >=\
    \ 10) {\n            remainder -= 10\n            roman += romanToChar(10)\n \
    \       }\n        roman += romanToChar(remainder)\n        return roman\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmvf85mow.scala:23:18 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            roman += romanToChar(\e[31m1000\e[0m)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpmvf85mow.scala:23:21 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            roman += romanToChar(\e[31m1000\e[0m)\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \           Not found: romanToChar\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpmvf85mow.scala:27:18 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m            roman += romanToChar(\e[31m100\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ String - did you mean String.!=?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmvf85mow.scala:27:21\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            roman += romanToChar(\e\
    [31m100\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: romanToChar\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpmvf85mow.scala:31:18 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            roman += romanToChar(\e[31m10\e[0m)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is\
    \ not a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpmvf85mow.scala:31:21 ------------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m            roman += romanToChar(\e[31m10\e[0m)\n\e[31m\e[31m \
    \  |\e[0m                     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \       Not found: romanToChar\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpmvf85mow.scala:33:14 ------------------------\e[0m\e[0m\n\e[31m33 "
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNum = number map {\n            case i if i <= 1000 => (100 * (i\
    \ - 1)) + i\n            case i if i > 1000 => (i - 100) * 100 + 100\n       \
    \     case _ => 0\n        }\n        romanNum collect {\n            case i if\
    \ i > 0 => (i / 1000).romanNum ++ romanNum(i % 1000)\n        }.mkString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwnimf69v.scala:15:30 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mromanNum\e[0m = number map\
    \ {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                       value map is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = Array.ofDim[String](1000)\n        var index = 0\n        for(i\
    \ <- 0 until roman.length){\n            roman(i) = \"\"\n        }\n        index\
    \ = 1000\n        var i = 0\n        var j = 0\n        while(number > 0){\n \
    \           roman(i) = roman(i-1)+(number/pow(10,j).toDouble).toChar\n       \
    \     number %= pow(10,j).toDouble\n            i = i + 1\n            j = j +\
    \ 1\n        }\n        for(i <- roman.indices) {\n            if(i != roman.size\
    \ - 1) {\n                roman(i) = \"\"\n            }\n        }\n        roman.map(_.replaceAll(\"\
    (?i)^(\\\\d)\", \"I$1\"))\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd8dj81pe.scala:25:19 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            number %= pow(\e[31m10\e[0m,j).toDouble\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ %= is not a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpd8dj81pe.scala:34:8 ---------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m        roman.map(_.replaceAll(\e[31m\"(?i)^(\\\\d)\"\e[0m,\
    \ \e[31m\"I$1\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mArray\e[0m\e[1m\e[31m[\e[0mString\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val bigDecimal = BigDecimal(number.toString.toInt)\n        var str = \"\
    \"\n        for (i <- 0 until bigDecimal.precision) {\n            val a = bigDecimal.intValue()\
    \ % 10\n            val b = bigDecimal.intValue() / 10\n            str +=  if\
    \ (a > 1) romanNumMap(a-1) else romanNumMap(a) //(a - 1) because we want to display\
    \ number before the digit\n            str += if (b > 0) romanNumMap(b) else \"\
    \"\n        }\n        str\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp080a_0sj.scala:20:20 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            str +=  \e[33mif\e[0m (a > \e[31m1\e[0m)\
    \ romanNumMap(a-\e[31m1\e[0m) \e[33melse\e[0m romanNumMap(a) \e[34m//(a - 1) because\
    \ we want to display number before the digit\e[0m\n\e[31m\e[31m   |\e[0m     \
    \               ^^\e[0m\n\e[31m   |\e[0m                    expression expected\
    \ but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp080a_0sj.scala:21:19 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            str += \e[33mif\e[0m (b > \e[31m0\e[0m) romanNumMap(b) \e\
    [33melse\e[0m \e[31m\"\"\e[0m\n\e[31m\e[31m   |\e[0m                   ^^\e[0m\n\
    \e[31m   |\e[0m                   expression expected but \e[31mif\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val lookup = mutable.HashMap[Long, String]()\n        def addLookup(number\
    \ : Long, roman : String) : Unit = {\n            if (lookup.contains(number))\
    \ {\n                lookup(number) = roman\n            } else {\n          \
    \      val string = \"mnop\"\n                for (i <- 0 until string.length)\
    \ {\n                    addLookup(number * 1000 + string.charAt(i), roman)\n\
    \                }\n                lookup.put(number, roman)\n            }\n\
    \        }\n        addLookup(number, \"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2g74idw2.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mlookup\e[0m = mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2g74idw2.scala:27:17 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        addLookup(number, \e[31m\"\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    Unit\n\e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = \"\"\n        var value = 1l\n        while (number >= value)\
    \ {\n            val temp = Math.round(number / value)\n            result = result\
    \ + romanDigit(temp) + romanDigit(number % temp).lower()\n            value =\
    \ value * 10\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpri55u4ym.scala:19:30 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            result = result + romanDigit(temp) + romanDigit(number\
    \ % temp).lower()\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Not found: romanDigit\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpri55u4ym.scala:19:49 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            result = result + romanDigit(temp) + romanDigit(number\
    \ % temp).lower()\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \                 Not found: romanDigit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number == 0) \"0\"\n        else if (number == 1) \"i\"\n        else\
    \ if (number == 2) \"ii\"\n        else if (number == 3) {\n            var temp\
    \ = number.toString.toLower\n            var result = \"v\"\n            var roman\
    \ = \"\"\n            var current = 0\n            var next = 1\n            var\
    \ prev = 1\n            while (next <= temp.length) {\n                prev =\
    \ current\n                current = next\n                next = prev + next\n\
    \                roman = (roman.substring(0, roman.length - 1) + roman.substring(prev\
    \ + 1, next) + roman.substring(current + 1))\n            }\n            result\
    \ = roman\n        }\n        else if (number < 3999) {\n            var temp\
    \ = number.toString.toLower\n            var result = \"m\"\n            var roman\
    \ = \"\"\n            var current = 0\n            var next = 1\n            var\
    \ prev = 1\n            while (next <= temp.length) {\n                prev =\
    \ current\n                current = next\n                next = prev + next\n\
    \                roman = (roman.substring(0, roman.length - 1) + roman.substring(prev\
    \ + 1, next) + roman.substring(current + 1))\n            }\n            result\
    \ = roman\n        }\n        else if (number < 79999) {\n            var temp\
    \ = number.toString.toLower\n            var result = \"c\"\n            var roman\
    \ = \"\"\n            var current = 0\n            var next = 1\n            var\
    \ prev = 1\n            while (next <= temp.length) {\n                prev =\
    \ current\n                current = next\n                next = prev + next\n\
    \                roman = (roman.substring(0, roman.length - 1) + roman.substring(prev\
    \ + 1, next) + roman.substring(current + 1))\n            }\n            result\
    \ = roman\n        }\n        else if (number < 3999000l) {\n            var temp\
    \ = number.toString.toLower\n            var result = \"d\"\n            var roman\
    \ = \"\"\n            var current = 0\n            var next = 1\n            var\
    \ prev = 1\n            while (next <= temp.length) {\n                prev =\
    \ current\n                current = next\n                next = prev + next\n\
    \                roman = (roman.substring(0, roman.length - 1) + roman.substring(prev\
    \ + 1, next) + roman.substring(current + 1))\n            }\n            result\
    \ = roman\n        }\n        else if (number < 79999999l) {\n            var\
    \ temp = number.toString.toLower\n            var result = \"f\"\n           \
    \ var roman = \"\"\n            var current = 0\n            var next = 1\n  \
    \          var prev = 1\n            while (next <= temp.length) {\n         \
    \       prev = current\n                current = next\n                next =\
    \ prev + next\n                roman = (roman.substring(0, roman.length - 1) +\
    \ roman.substring(prev + 1, next) + roman.substring(current + 1))\n          \
    \  }\n            result = roman\n        }\n        else if (number < 99999999l)\
    \ {\n            var temp = number.toString.toLower\n            var \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpqw2fufbm.scala:95:15 ---------------------------\e\
    [0m\e[0m\n\e[31m95 |\e[0m            \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqw2fufbm.scala:115:0 ---------------------------\e\
    [0m\e[0m\n\e[31m115 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqw2fufbm.scala:19:39\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mvar\e[0m\
    \ \e[36mtemp\e[0m = number.toString.toLower\n\e[31m\e[31m   |\e[0m           \
    \            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \    value toLower is not a member of String\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpqw2fufbm.scala:34:39 ------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m            \e[33mvar\e[0m \e[36mtemp\e[0m = number.toString.toLower\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       value toLower is not a member of String\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpqw2fufbm.scala:49:39 ------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m            \e[33mvar\e[0m \e[36mtemp\e[0m = number.toString.toLower\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       value toLower is not a member of String\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpqw2fufbm.scala:64:39 ------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m            \e[33mvar\e[0m \e[36mtemp\e[0m = number.toString.toLower\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       value toLower is not a member of String\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpqw2fufbm.scala:79:39 ------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m            \e[33mvar\e[0m \e[36mtemp\e[0m = number.toString.toLower\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m          "
  stdout: ''
  timestamp: 1660010746
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var output : String = \"\"\n        val roman = List(\"M\",\"CM\",\"D\"\
    ,\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\")\n        var\
    \ lastLetter = \"\"\n        for (number <- 0 to roman.length-1) {\n         \
    \   val value = number % roman.length\n            lastLetter = roman(value)\n\
    \            number -= value\n            output += lastLetter\n        }\n  \
    \      output.toLower\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprsg4zfsc.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            number -= value\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Int - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprsg4zfsc.scala:24:15\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        output.toLower\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value toLower\
    \ is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1660010743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result = \"\"\n        var hundredsPlace = number / 1000\n        var\
    \ remainder = number % 1000\n        var thousandsPlace = remainder / 1000\n \
    \       remainder = remainder % 1000\n        var tensPlace = remainder / 100\n\
    \        remainder = remainder % 100\n        var unitsPlace = remainder / 10\n\
    \        remainder = remainder % 10\n        val tensNum = List(\"c\", \"cc\"\
    , \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"dx\", \"xc\", \"xcc\",\
    \ \"xccc\", \"xx\", \"xdxx\", \"xdccx\",\n                \"xdccr\", \"xdcr\"\
    , \"xdcc\", \"xdccc\", \"xdccr\", \"xdcr\", \"xdcc\", \"xdccc\", \"xdcr\", \"\
    xdcr\", \"xdcc\", \"xdccc\")\n        val unitsNum = List(\"x\", \"c\", \"cc\"\
    , \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"dx\", \"xc\", \"xcc\",\
    \ \"xccc\", \"xx\", \"xdxx\", \"xdccx\",\n                \"xdccr\", \"xdcr\"\
    , \"xdcc\", \"xdccc\", \"xdccr\", \"xdcr\", \"xdcc\", \"xdccc\", \"xdcr\", \"\
    xdcr\", \"xdcc\", \"xdccc\")\n        val hundredsNum = List(\"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"dx\", \"xc\", \"xcc\", \"xccc\"\
    , \"xx\", \"xdxx\", \"xdccx\",\n                \"xdccr\", \"xdcr\", \"xdcc\"\
    , \"xdccc\", \"xdccr\", \"xdcr\", \"xdcc\", \"xdccc\", \"xdcr\", \"xdcr\", \"\
    xdcc\", \"xdccc\")\n\n        var placeHolder = 0\n        \n        // The first\
    \ unit of thousands\n        if(hundredsPlace == 1){\n            result += \"\
    c\"\n        }else if(hundredsPlace == 2){\n            result += \"cc\"\n   \
    \     }else if(hundredsPlace == 3){\n            result += \"ccc\"\n        }else\
    \ if(hundredsPlace == 4){\n            result += \"cd\"\n        }else if(hundredsPlace\
    \ == 5){\n            result += \"dc\"\n        }else if(hundredsPlace == 6){\n\
    \            result += \"dcc\"\n        }else if(hundredsPlace == 7){\n      \
    \      result += \"dccc\"\n        }else if(hundredsPlace == 8){\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp76gndbio.scala:68:0 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp76gndbio.scala:67:1\
    \ ---------------------\e[0m\e[0m\n\e[31m67 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp76gndbio.scala:50:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m50 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1660010745
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if(number < 0 || number > 1000){\n            throw new IllegalArgumentException(\"\
    number must be positive\")\n        }\n        var roman = \"\"\n        var num\
    \ = 0\n        val nums = List(-4, -3, 0, 3, 6, 9, 12, 15)\n        val dens =\
    \ List(1, 4, 9, 10, 40, 50, 90, 100)\n        if(number == 0){\n            return\
    \ roman\n        }\n        while(number > 0){\n            num += 1\n       \
    \     number -= nums(num)\n        }\n        if(num >= 1){\n            roman\
    \ += dens(num)\n        }\n        var lastDen = 1\n        while(lastDen <= num){\n\
    \            roman += dens(lastDen)\n            lastDen += 1\n        }\n   \
    \     roman = roman.substring(0, roman.length - 1)\n        return roman\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxvogx_8a.scala:27:19 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            number -= nums(num)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010744
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Your code here\n        val miniRoman = mutable.StringBuilder.newBuilder\n\
    \        var numStr = number.toString.toInt\n\n        while (number > 0) {\n\
    \            val remainder = number % 1000\n            miniRoman.append(numStr\
    \ % 1000)\n            numStr = Math.floor((number / 1000))\n        }\n     \
    \   miniRoman.toString\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfgs8x74e.scala:16:24 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mminiRoman\e[0m = mutable.StringBuilder.newBuilder\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpfgs8x74e.scala:22:31 --------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m            numStr = Math.floor((number / \e[31m1000\e[0m))\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Found:    Double\n\e[31m   |\e[0m          \
    \           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010744
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number <= 0) \"0\"\n        else if (number < 1000) intToMiniRoman(number\
    \ * 100) + \"x\"\n        else if (number < 5000) intToMiniRoman(number * 500)\
    \ + \"l\"\n        else intToMiniRoman(number * 5) + \"c\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmputhn115u.scala:21)\n\tat Problem.main(tmputhn115u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010746
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number < 1L || number > 1000L) {\n            throw new RuntimeException(\"\
    Invalid input number: \" + number)\n        }\n        var result = \"\"\n   \
    \     var index = 0\n        while(number > 0) {\n            val remainder =\
    \ number % 100\n            number /= 100\n            result += indexToMiniRoman(index)\
    \ + miniRomanToIntMap(remainder)\n        }\n        result.toLowerCase\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgd8kx7hn.scala:22:19 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            number /= \e[31m100\e[0m\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not\
    \ a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpgd8kx7hn.scala:23:19 ------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            result += indexToMiniRoman(index) + miniRomanToIntMap(remainder)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpgd8kx7hn.scala:23:22 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            result += indexToMiniRoman(index) + miniRomanToIntMap(remainder)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      Not found: indexToMiniRoman\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010746
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var rem = number\n        var ret = \"\"\n        var prev = \"\"\n    \
    \    while (rem > 0) {\n            rem -= 1\n            prev += (\"M\" * rem)\
    \ + \" \"\n            if (rem > 1000) {\n                ret += (prev + prev\
    \ + prev + prev + prev + prev)\n            }\n        }\n        ret\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2xjllr6l.scala:20:17 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            prev += (\e[31m\"M\"\e[0m * rem) + \e[31m\"\
    \ \"\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \        value += is not a member of String - did you mean String.!=?\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp2xjllr6l.scala:20:27 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            prev += (\e[31m\"M\"\e[0m * rem) + \e[31m\"\
    \ \"\e[0m\n\e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e[31m  \
    \ |\e[0m                           Found:    (rem : Long)\n\e[31m   |\e[0m   \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010746
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNum = number.toInt\n        var sum = 0\n        var i = 0\n  \
    \      var roman = \"\"\n\n        while(i < romanNum) {\n            val remainder\
    \ = romanNum % 1000\n            sum += remainder\n            roman = roman.dropRight(1)\
    \ +\n                getRoman(remainder) +\n                roman.takeRight(1)\n\
    \            romanNum = romanNum / 1000\n            i += 1\n        }\n     \
    \   roman\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphrlmdvbc.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                getRoman(remainder) +\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Not found:\
    \ getRoman\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphrlmdvbc.scala:26:21\
    \ -----------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            romanNum\
    \ = romanNum / \e[31m1000\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val romanNum\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010744
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if(number == 0) \"0\"\n        else if(number < 0 || number > 1000) \"error\"\
    \n        else romanNumerals(number).map(_.toLower).mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiqo0g4ap.scala:17:13 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33melse\e[0m romanNumerals(number).map(_.toLower).mkString\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \     Not found: romanNumerals\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010744
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val res = \"\"\n        for(i <- number toLong; i >= 1; i = (i / 10).floor)\
    \ {\n            val newnum = i\n            if(newnum % 10 == 1) res += newnum\n\
    \            else\n            if(newnum % 100 > 0)\n                if((newnum\
    \ % 100) == 10 && i == 10)\n                    res += newnum\n              \
    \  else\n                    res += newnum + \"i\"\n            else\n       \
    \         if(newnum % 100 == 10)\n                    res += newnum + \"i\"\n\
    \                else\n                    res += newnum + \"v\"\n        }\n\
    \        if(number < 1)\n            res\n        else\n            res.substring(0,\
    \ res.length - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpt88i0ye2.scala:16:30 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m(i <- number toLong; i >= \e[31m1\e\
    [0m; i = (i / \e[31m10\e[0m).floor) {\n\e[31m\e[31m   |\e[0m                 \
    \             ^\e[0m\n\e[31m   |\e[0m                              expression\
    \ expected but \e[31m';'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpt88i0ye2.scala:16:38 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mfor\e[0m(i <- number toLong; i >= \e[31m1\e[0m; i = (i /\
    \ \e[31m10\e[0m).floor) {\n\e[31m\e[31m   |\e[0m                             \
    \         ^\e[0m\n\e[31m   |\e[0m                                      '<-' expected,\
    \ but ';' found\n2 errors found\n"
  stdout: ''
  timestamp: 1660010745
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var miniRoman = \"\"\n        var remainder = number\n        var remainderAsLong\
    \ = remainder\n        while (remainderAsLong != 0) {\n            var digit =\
    \ remainderAsLong % 10\n            miniRoman = digitToMiniRoman(digit) + miniRoman\n\
    \            remainderAsLong = remainderAsLong / 10\n        }\n        miniRoman\
    \ = miniRoman.trim\n        return miniRoman\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9ng8a9mz.scala:20:24 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            miniRoman = digitToMiniRoman(digit) + miniRoman\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Not found: digitToMiniRoman\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010746
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNumbersMap = Map(\n            (1001l, \"M\"),\n            (1002l,\
    \ \"CM\"),\n            (1003l, \"D\"),\n            (1004l, \"CD\"),\n      \
    \      (1005l, \"C\"),\n            (1006l, \"XC\"),\n            (1007l, \"L\"\
    ),\n            (1008l, \"XL\"),\n            (1009l, \"X\"),\n            (1010l,\
    \ \"IX\"),\n            (1011l, \"V\"),\n            (1012l, \"IV\"),\n      \
    \      (1013l, \"I\")\n        )\n        if (romanNumbersMap.contains(number))\
    \ {\n            romanNumbersMap(number)\n        } else {\n            romanNumbersMap.maxBy(_._1)._1\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn1_3q8w3.scala:33:40\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m            romanNumbersMap.maxBy(_._1)._1\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m            Found:    Long\n\e[31m   |\e[0m            Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanArray = Array(\"\", \"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\"\
    , \"DC\", \"DCC\",\n            \"DCCC\", \"CM\")\n\n        val miniRomanArray\
    \ = romanArray.take(number)\n        val tail = romanArray.drop(number)\n    \
    \    tail.foldLeft[String](\"\") { (a, e) => a.concat(miniRomanArray(e))}\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6t_fdnl1.scala:18:45\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mminiRomanArray\e\
    [0m = romanArray.take(number)\n\e[31m\e[31m   |\e[0m                         \
    \                    ^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \                 Found:    (number : Long)\n\e[31m   |\e[0m                 \
    \                            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp6t_fdnl1.scala:19:35 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mtail\e[0m = romanArray.drop(number)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                   Found:    (number : Long)\n\e[31m \
    \  |\e[0m                                   Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6t_fdnl1.scala:20:70 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        tail.foldLeft[\e[35mString\e[0m](\e[31m\"\"\e\
    [0m) { (\e[36ma\e[0m, \e[36me\e[0m) => a.concat(miniRomanArray(e))}\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \      ^\e[0m\n\e[31m   |\e[0m                                               \
    \   Found:    (e : String)\n\e[31m   |\e[0m                                  \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = new mutable.ListBuffer[String]()\n        var romanArray = Array.fill[Int]((number\
    \ / 1000 + 1).toInt){0}\n        romanArray(0) = number % 1000\n        romanArray\
    \ = romanArray.dropRight(1)\n        romanArray = romanArray.map(_ + 1).map(i\
    \ => number / 1000 - (i * 1000))\n        romanArray = romanArray.map(i => if\
    \ (i < 10) \"I\" + i else (if (i < 100) \"V\" + i else (if (i < 1000) \"X\" +\
    \ i else \"C\" + i)))\n        roman = roman.concat(romanArray).reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp93tk7zko.scala:15:24 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mroman\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp93tk7zko.scala:17:24\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        romanArray(\e[31m0\e\
    [0m) = number % \e[31m1000\e[0m\n\e[31m\e[31m   |\e[0m                       \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        Found:    Long\n\e\
    [31m   |\e[0m                        Required: Int\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp93tk7zko.scala:19:52 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        romanArray = romanArray.map(_ + \e[31m1\e[0m).map(\e\
    [36mi\e[0m => number / \e[31m1000\e[0m - (i * \e[31m1000\e[0m))\n\e[31m\e[31m\
    \   |\e[0m                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                    Found:\
    \    Long\n\e[31m   |\e[0m                                                   \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp93tk7zko.scala:20:53\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        romanArray = romanArray.map(\e\
    [36mi\e[0m => \e[33mif\e[0m (i < \e[31m10\e[0m) \e[31m\"I\"\e[0m + i \e[33melse\e\
    [0m (\e[33mif\e[0m (i < \e[31m100\e[0m) \e[31m\"V\"\e[0m + i \e[33melse\e[0m (\e\
    [33mif\e[0m (i < \e[31m1000\e[0m) \e[31m\"X\"\e[0m + i \e[33melse\e[0m \e[31m\"\
    C\"\e[0m + i)))\n\e[31m\e[31m   |\e[0m                                       \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \                    Found:    String\n\e[31m   |\e[0m                       \
    \                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer expl"
  stdout: ''
  timestamp: 1660010755
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = scala.collection.mutable.ListBuffer[String]()\n        def romanNum(number:Long,roman:scala.collection.mutable.ListBuffer[String]):Unit\
    \ = {\n            number match {\n                case 1l  => roman.append(\"\
    x\")\n                case 10l => roman.append(\"c\")\n                case 100l\
    \ => roman.append(\"d\")\n                case 1000l => roman.append(\"xc\")\n\
    \                case 10000l => roman.append(\"cc\")\n                case 100000l\
    \ => roman.append(\"ccc\")\n                case 1000000l => roman.append(\"cd\"\
    )\n                case 10000000l => roman.append(\"dcc\")\n                case\
    \ 100000000l => roman.append(\"dccc\")\n                case 1000000000l => roman.append(\"\
    cm\")\n                case 10000000000l => roman.append(\"mm\")\n           \
    \     case 100000000000l => roman.append(\"MMM\")\n                case 1000000000000l\
    \ => roman.append(\"MMMM\")\n                case 10000000000000l => roman.append(\"\
    MMMMM\")\n                case 100000000000000l => roman.append(\"MMMMMMM\")\n\
    \                case 1000000000000000l => roman.append(\"MMMMMMMM\")\n      \
    \          case 10000000000000000l => roman.append(\"MMMMMMMMM\")\n          \
    \      case 100000000000000000l => roman.append(\"MMMMMMMMMM\")\n            \
    \    case 1000000000000000000l => roman.append(\"MMMMMMMMMMMM\")\n           \
    \ }\n        }\n        romanNum(number,roman)\n        roman.mkString(\"\")\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "scala.MatchError: 19 (of class java.lang.Long)\n\tat Problem$.romanNum$1(tmpc97xl12i.scala:36)\n\
    \tat Problem$.intToMiniRoman(tmpc97xl12i.scala:39)\n\tat Problem$.main(tmpc97xl12i.scala:43)\n\
    \tat Problem.main(tmpc97xl12i.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = ListBuffer[String]()\n        var index = 2L\n        while(index\
    \ <= number) {\n            roman.append(index % 10l).append(if (index % 100l\
    \ == 0) \"m\" else \"m\")\n            index += 1\n        }\n        roman.reverse.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpmxn7g_zt.scala:18:18 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            roman.append(index % \e[31m10l\e[0m).append(\e\
    [33mif\e[0m (index % \e[31m100l\e[0m == \e[31m0\e[0m) \e[31m\"m\"\e[0m \e[33melse\e\
    [0m \e[31m\"m\"\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mappend\e\
    [0m in \e[33mtrait\e[0m \e[35mBuffer\e[0m with types\n\e[31m   |\e[0m (elems:\
    \ String*): scala.collection.mutable.ListBuffer[String]\n\e[31m   |\e[0m (elem:\
    \ String): scala.collection.mutable.ListBuffer[String]\n\e[31m   |\e[0mmatch arguments\
    \ (Long)\n1 error found\n"
  stdout: ''
  timestamp: 1660010750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def toRoman(num : Int) : String = {\n            val res = \"\"\n      \
    \      def addToRess(num : Int) : Unit = {\n                if (num > 0) {\n \
    \                   res += romanDigit(num)\n                    addToRess(num\
    \ / 10)\n                }\n            }\n            addToRess(num)\n      \
    \      res\n        }\n        val ints = number.toInt\n        if (ints == 0)\
    \ \"\"\n        else {\n            val str = \"\"\n            val roman = intToRoman(ints)\n\
    \            var i = 0\n            while (i < roman.length) {\n             \
    \   str += roman(i)\n                i += 1\n            }\n            str\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpue3_6hbg.scala:19:24 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                    res += romanDigit(num)\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m               value\
    \ += is not a member of String - did you mean res.!=?\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpue3_6hbg.scala:19:27 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m                    res += romanDigit(num)\n\e[31m\e[31m   |\e\
    [0m                           ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \            Not found: romanDigit\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpue3_6hbg.scala:30:24 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m            \e[33mval\e[0m \e[36mroman\e[0m = intToRoman(ints)\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: intToRoman\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpue3_6hbg.scala:33:20 ------------------------\e[0m\e[0m\n\e[31m33 |\e\
    [0m                str += roman(i)\n\e[31m\e[31m   |\e[0m                ^^^^^^\e\
    [0m\n\e[31m   |\e[0m               value += is not a member of String - did you\
    \ mean str.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val intNum = number.toInt\n        val numArray = Array.ofDim[Int](intNum)\n\
    \        for(i <- 0 until numArray.length) {\n            val remainder = intNum\
    \ rem 1000;\n            numArray(i) = remainder.toInt\n            intNum = intNum\
    \ / 1000\n        }\n        val romanArray = Array.ofDim[Int](4)\n        //\
    \ I\n        romanArray(0) = 0\n        // V\n        romanArray(1) = 1\n    \
    \    // X\n        romanArray(2) = 5\n        // L\n        romanArray(3) = 10\
    \ // Hard coded L\n        // Convert array to roman numerals\n        var romanString\
    \ = \"\"\n        for(i <- 0 until romanArray.length) {\n            romanString\
    \ += romanArray(i).toString\n        }\n        romanString.toLowerCase\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjx1ocsry.scala:18:35 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36mremainder\e[0m = intNum\
    \ rem \e[31m1000\e[0m;\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            value rem is not a member of Int\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpjx1ocsry.scala:20:19 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            intNum = intNum / \e[31m1000\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \    Reassignment to val intNum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val res = mutable.Buffer[String]()\n        for {\n            i <- 1 to\
    \ number\n        } yield {\n            val remainder = number % i;\n       \
    \     val n = (number / i).toString.length - 1;\n            val s = if (remainder\
    \ == 0) \"\"\n                else new StringBuilder()\n            s ++= new\
    \ String(new Array[Char](n + 1)) {\n                '0'\n            }\n     \
    \       if (n < 0) s ++= new String(new Array[Char](n + 1)) {\n              \
    \  'z'\n            }\n            s ++= new String(new Array[Char](remainder)\
    \ {\n                'i'\n            })\n            res += s\n        }\n  \
    \      res\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl5svz2sm.scala:15:18 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = mutable.Buffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpl5svz2sm.scala:17:22 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            i <- \e[31m1\e[0m to number\n\e[31m\e[31m\
    \   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \     Found:    (number : Long)\n\e[31m   |\e[0m                      Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl5svz2sm.scala:23:14\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            s ++= \e[33mnew\e\
    [0m \e[35mString\e[0m(\e[33mnew\e[0m \e[35mArray\e[0m[\e[35mChar\e[0m](n + \e\
    [31m1\e[0m)) {\n\e[31m\e[31m   |\e[0m            ^^^^^\e[0m\n\e[31m   |\e[0m \
    \           value ++= is not a member of CharSequence\n\e[31m\e[31m-- [E093] Syntax\
    \ Error: /tmp/tmpl5svz2sm.scala:23:18 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m            s ++= \e[33mnew\e[0m \e[35mString\e[0m(\e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mChar\e[0m](n + \e[31m1\e[0m)) {\n\e[31m\e[31m   |\e[0m\
    \                  ^\e[0m\n\e[31m   |\e[0m           \e[33manonymous class\e[0m\
    \ \e[35mString\e[0m {...} cannot extend \e[33mfinal\e[0m \e[33mclass\e[0m \e[35mString\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl5svz2sm.scala:26:25\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mif\e[0m\
    \ (n < \e[31m0\e[0m) s ++= \e[33mnew\e[0m \e[35mString\e[0m(\e[33mnew\e[0m \e\
    [35mArray\e[0m[\e[35mChar\e[0m](n + \e[31m1\e[0m)) {\n\e[31m\e[31m   |\e[0m  \
    \                     ^^^^^\e[0m\n\e[31m   |\e[0m                       value\
    \ ++= is not a member of CharSequence\n\e[31m\e[31m-- [E093] Syntax Error: /tmp/tmpl5svz2sm.scala:26:29\
    \ ---------------------------\e["
  stdout: ''
  timestamp: 1660010756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numerals = numberToMiniRoman(number).toInt\n        val numList = List.fill(numerals)(\"\
    \").toList\n        numList.map {n => (n % 1000) + 1}.sorted.foreach(x => numList(x\
    \ + 1) = numerals(x))\n        numList.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnjjs9hux.scala:15:23 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnumerals\e[0m = numberToMiniRoman(number).toInt\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                       Not found: numberToMiniRoman\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpnjjs9hux.scala:17:29 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        numList.map {\e[36mn\e[0m => (n % \e[31m1000\e\
    [0m) + \e[31m1\e[0m}.sorted.foreach(\e[36mx\e[0m => numList(x + \e[31m1\e[0m)\
    \ = numerals(x))\n\e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e\
    [31m   |\e[0mvalue % is not a member of String, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpnjjs9hux.scala:17:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        numList.map {\e[36mn\e[0m => (n % \e[31m1000\e\
    [0m) + \e[31m1\e[0m}.sorted.foreach(\e[36mx\e[0m => numList(x + \e[31m1\e[0m)\
    \ = numerals(x))\n\e[31m\e[31m   |\e[0m                                      \
    \          ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mShort\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msorted\e[0m in \e[33mtrait\e[0m\
    \ \e[35mStrictOptimizedSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660010755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result: String = \"\"\n        var base = 1000\n        while(number\
    \ > base) {\n            number -= base\n            result += (base.toChar *\
    \ number).drop(1)\n        }\n        return result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsgw_kqbx.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            number -= base\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsgw_kqbx.scala:19:19\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            result += (base.toChar\
    \ * number).drop(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            value += is not a member of String - did you mean String.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsgw_kqbx.scala:19:45 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            result += (base.toChar * number).drop(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value drop is not a member of Long\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = scala.collection.mutable.ListBuffer.empty[String]\n        roman.append(\"\
    M\")\n        roman.append(\"CM\")\n        roman.append(\"CD\")\n        roman.append(\"\
    C\")\n        roman.append(\"XC\")\n        roman.append(\"L\")\n        roman.append(\"\
    XL\")\n        roman.append(\"X\")\n        roman.append(\"IX\")\n        roman.append(\"\
    V\")\n        roman.append(\"IV\")\n        roman.append(\"I\")\n\n        var\
    \ num = 0\n        val max = math.pow(10, 5)\n        while (number != 0) {\n\
    \            val numString = scala.math.pow(10, math.ceil(math.log10(number)))\n\
    \            val mod10 = number % numString\n            roman.append(roman(math.floor(mod10\
    \ / 10)) + roman(mod10 % 10))\n            number = number - mod10\n         \
    \   num = num + 1\n        }\n        roman.take(roman.length - 1).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpszchvip_.scala:34:41\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m            roman.append(roman(math.floor(mod10\
    \ / \e[31m10\e[0m)) + roman(mod10 % \e[31m10\e[0m))\n\e[31m\e[31m   |\e[0m   \
    \                            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                           Found:    Double\n\e[31m   |\e[0m                \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpszchvip_.scala:34:63 --------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m            roman.append(roman(math.floor(mod10 / \e[31m10\e[0m)) + roman(mod10\
    \ % \e[31m10\e[0m))\n\e[31m\e[31m   |\e[0m                                   \
    \                            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                                        Found:    Double\n\e[31m   |\e[0m   \
    \                                                     Required: Int\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpszchvip_.scala:35:21 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            number = number - mod10\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \    Found:    Double\n\e[31m   |\e[0m                     Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNumbers = Map(\n            (100l, \"M\"), // 100th\n         \
    \   (90l, \"CM\"), // 90th\n            (80l, \"D\"), // 80th\n            (70l,\
    \ \"CD\"), // 70th\n            (60l, \"C\"), // 60th\n            (50l, \"XC\"\
    ), // 50th\n            (40l, \"L\"), // 40th\n            (30l, \"XL\"), // 30th\n\
    \            (20l, \"X\"), // 20th\n            (10l, \"IX\"), // 10th\n     \
    \       (1l, \"V\"), // 1st\n            (-1l, \"IV\"), // -1st\n            (-2l,\
    \ \"I\"), // -2nd\n            (-3l, \"II\"), // -3rd\n            (4l, \"IV\"\
    ), // 4th\n            (5l, \"V\"), // 5th\n            (6l, \"VI\"), // 6th\n\
    \            (7l, \"VII\"), // 7th\n            (8l, \"VIII\"), // 8th\n     \
    \       (9l, \"IX\"), // 9th\n            (10l, \"X\"), // 10th\n            (11l,\
    \ \"X\"), // 11th\n            (12l, \"XL\"), // 12th\n            (13l, \"XC\"\
    ), // 13th\n            (14l, \"L\"), // 14th\n            (15l, \"L\"), // 15th\n\
    \            (16l, \"L\"), // 16th\n            (17l, \"L\"), // 17th\n      \
    \      (18l, \"L\"), // 18th\n            (19l, \"L\"), // 19th\n            (20l,\
    \ \"C\"), // 20th\n            (21l, \"C\"), // 21st\n            (22l, \"C\"\
    ), // 22nd\n            (23l, \"C\"), // 23rd\n            (24l, \"C\"), // 24th\n\
    \            (25l, \"C\"), // 25th\n            (26l, \"C\"), // 26th\n      \
    \      (27l, \"C\"), // 27th\n            (28l, \"C\"), // 28th\n            (29l,\
    \ \"C\"), // 29th\n            (30l, \"C\"), // 30th\n            (31l, \"C\"\
    ), // 31st\n            (32l, \"C\"), // 32nd\n            (33l, \"C\"), // 33rd\n\
    \            (34l, \"C\"), // 34th\n            (35l, \"C\"), // 35th\n      \
    \      (36l, \"XC\"), // 36th\n            (37l, \"C\"), // 37th\n           \
    \ (38l, \"C\"), // 38th\n            (39l, \"C\"), \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfbzzq43a.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpfbzzq43a.scala:66:5 ---------------------\e[0m\e[0m\n\e[31m66 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = \"\"\n        var remainder = number % 1000\n        var remainder1\
    \ = number / 1000\n        var num1 = 1\n        var num2 = 2\n        var num3\
    \ = 3\n        var num4 = 4\n        var num5 = 5\n        var num6 = 6\n    \
    \    var num7 = 7\n        var num8 = 8\n        var num9 = 9\n        var num10\
    \ = 10\n        var num11 = 11\n        var num12 = 12\n        var num13 = 13\n\
    \        var num14 = 14\n        var num15 = 15\n        var num16 = 16\n    \
    \    var num17 = 17\n        var num18 = 18\n        var num19 = 19\n        var\
    \ num20 = 20\n        var num21 = 21\n        var num22 = 22\n        var num23\
    \ = 23\n        var num24 = 24\n        var num25 = 25\n        var num26 = 26\n\
    \        var num27 = 27\n        var num28 = 28\n        var num29 = 29\n    \
    \    var num30 = 30\n        var num31 = 31\n        var num32 = 32\n        var\
    \ num33 = 33\n        var num34 = 34\n        var num35 = 35\n        var num36\
    \ = 36\n        var num37 = 37\n        var num38 = 38\n        var num39 = 39\n\
    \        var num40 = 40\n        var num41 = 41\n        var num42 = 42\n    \
    \    var num43 = 43\n        var num44 = 44\n        var num45 = 45\n        var\
    \ num46 = 46\n        var num47 = 47\n        var num48 = 48\n        var num49\
    \ = 49\n        var num50 = 50\n        var num51 = 51\n        var num52 = 52\n\
    \        var num53 = 53\n        var num54 = 54\n        var num55 = 55\n    \
    \    var num56 = 56\n        var num57 = 57\n        var num58 = 58\n        var\
    \ num59 = 59\n        var num60 = 60\n        var num61 = 61\n        var num62\
    \ = 62\n        var num63 = 63\n        var num64 = 64\n        var num65 = 65\n\
    \        var num66 = 66\n        var num67 = 67\n        var num68 = 68\n    \
    \    var num69 = 69\n        var num70 = 70\n        var num71 = 71\n        var\
    \ num72 = 72\n        var num73 = 73\n        var num74 = 74\n        var num75\
    \ = 75\n        var num76 = 76\n        var num77 = 77\n        var num78 = 78\n\
    \        var num79 = 79\n        var num80 = 80\n        var num81 = 81\n    \
    \    var num82 = 82\n        var num83 = 83\n        var num84 = 84\n        var\
    \ num85 = 85\n        var num\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9zmf5s51.scala:104:4 ---------------------------\e\
    [0m\e[0m\n\e[31m104 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp9zmf5s51.scala:104:5 --------------------\e[0m\e[0m\n\e[31m104 |\e[0m\
    \    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\
    \e[31m    |\e[0m     Required: String\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // write your code\n        val numStr = numToString(number)\n        numStr.takeWhile(_\
    \ != '0')\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi0gmf488.scala:16:21 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnumStr\e[0m = numToString(number)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                   Not found: numToString\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNumbers = scala.collection.mutable.HashMap.empty[Int, String]\n\
    \n        // For each integer, we add up the corresponding \"roman\" numbers\n\
    \        for( x <- number until number + 4 ) romanNumbers += ( x -> romanNumber(x)\
    \ )\n\n        // Then we subtract one, and map that to the roman number equivalent\n\
    \        romanNumbers.map{ case (num, roman) => num - 1 -> roman }.map { case\
    \ (num, roman) => roman }\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdl7t9r68.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mfor\e[0m( x <- number until number + \e\
    [31m4\e[0m ) romanNumbers += ( x -> romanNumber(x) )\n\e[31m\e[31m   |\e[0m  \
    \                                                                 ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Not found:\
    \ romanNumber\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdl7t9r68.scala:21:70\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        romanNumbers.map{ \e\
    [33mcase\e[0m (num, roman) => num - \e[31m1\e[0m -> roman }.map { \e[33mcase\e\
    [0m (num, roman) => roman }\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    scala.collection.mutable.Iterable[String]\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = \"\"\n        val romanTable = Map(\n                (1l, \"\
    i\"), // 1~9\n                (2l, \"ii\"),\n                (3l, \"iii\"),\n\
    \                (4l, \"iv\"),\n                (5l, \"v\"),\n               \
    \ (6l, \"vi\"),\n                (7l, \"vii\"),\n                (8l, \"viii\"\
    ),\n                (9l, \"ix\"),\n                (10l, \"x\"),\n           \
    \     (50l, \"l\"),\n                (100l, \"c\")\n                )\n      \
    \  if (number >= 1l && number <= 9l) {\n            for (x <- 1 to 9) {\n    \
    \            roman += romanTable.getOrElse(number / x, \"\")\n               \
    \ number = number % x\n            }\n        }\n        else if (number >= 10l\
    \ && number < 100l) {\n            roman += romanTable.getOrElse(number / 10,\
    \ \"\")\n            number = number % 10\n            roman += romanTable.getOrElse(number\
    \ / 10, \"\")\n            number = number % 10\n            roman += romanTable.getOrElse(number\
    \ / 10, \"\")\n        }\n        else if (number >= 100l && number < 1000l) {\n\
    \            roman += romanTable.getOrElse(number / 100, \"\")\n            number\
    \ = number % 100\n            roman += romanTable.getOrElse(number / 100, \"\"\
    )\n            number = number % 100\n            roman += romanTable.getOrElse(number\
    \ / 100, \"\")\n            number = number % 100\n        }\n        return roman\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpy6ncj_g0.scala:33:23 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                number = number % x\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val number\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpy6ncj_g0.scala:38:19\
    \ -----------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            number =\
    \ number % \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val number\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpy6ncj_g0.scala:40:19 -----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            number = number % \e[31m10\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  Reassignment to val number\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpy6ncj_g0.scala:45:19 -----------------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m            number = number % \e[31m100\e[0m\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val number\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpy6ncj_g0.scala:47:19\
    \ -----------------------------\e[0m\e[0m\n\e[31m47 |\e[0m            number =\
    \ number % \e[31m100\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val number\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpy6ncj_g0.scala:49:19 -----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m            number = number % \e[31m100\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \   Reassignment to val number\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer "
  stdout: ''
  timestamp: 1660010755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = {\n            val romanMap: Map[Long, String] =\n         \
    \       Map(\n                    1 -> \"i\",\n                    5 -> \"v\"\
    ,\n                    10 -> \"x\",\n                    20 -> \"c\",\n      \
    \              50 -> \"d\",\n                    100 -> \"m\",\n             \
    \       200 -> \"l\",\n                    400 -> \"xl\",\n                  \
    \  800 -> \"xxl\",\n                    1600 -> \"xxxl\",\n                  \
    \  3200 -> \"lxxx\",\n                    6400 -> \"xixx\",\n                \
    \    12800 -> \"lxxxix\",\n                    25600 -> \"xxxixx\",\n        \
    \            51200 -> \"xixxix\",\n                    102400 -> \"lxxxixx\",\n\
    \                    204800 -> \"xxxixxix\",\n                    409600 -> \"\
    xixxixx\",\n                    819200 ->  \"lxxxxi\",\n                    1638400\
    \ -> \"xxxixxii\",\n                    3276800 -> \"xixxixix\",\n           \
    \         6553600 -> \"lxxxxix\",\n                    13107200 -> \"xixxi\",\n\
    \                    26214400 -> \"lxxxxii\",\n                    52428800 ->\
    \ \"xxxxixi\",\n                    104857600 -> \"lxxxxiii\",\n             \
    \       209715200 -> \"xxxxixii\",\n                    419430400 -> \"lxxxxxxxxi\"\
    ,\n                    838860800 -> \"xxxxixxxxxi\",\n                    1677721600\
    \ -> \"lxxxxxxxxxxi\",\n                    3355443200 -> \"xxxxixxxxxxxi\",\n\
    \                    6710886400 -> \"lxxxxxxxxxxxxi\",\n                    13421772800\
    \ -> \"xxxxixxxxxxxxxi\",\n                    26843545600 -> \"lxxxxxxxxxxxxxxi\"\
    ,\n                    53687091200 -> \"xxxxixxxxxxxxxxxi\",\n               \
    \     10737418400 -> \"lxxxxxxxxxxxxxxxxi\",\n                    214748364800\
    \ -> \"xxxxixxxxxxxxxxxxxi\",\n                    429496729600 -> \"lxxxxxxxxxxxxxxxxxxi\"\
    ,\n                    858993459200 -> \"xxxxixxxxxxxxxxxxxxxi\",\n          \
    \          17179869184000L -> \"lxxxxxxxxxxxxxxxxxxxxi\",\n                  \
    \  34359738368000 -> \"xxxxixxxxxxxxxxxxxxxxxi\",\n                    68719476736000L\
    \ -> \"lxxxx\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmplguq94cy.scala:59:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m                    \e[31m68719476736000L\e[0m -> \"\
    lxxxx\n\e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e\
    [31m   |\e[0m                                       unclosed string literal\n\e\
    [31m\e[31m-- Error: /tmp/tmplguq94cy.scala:61:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplguq94cy.scala:79:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m79 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- Error: /tmp/tmplguq94cy.scala:48:20\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m48 |\e[0m       \
    \             \e[31m3355443200\e[0m -> \e[31m\"xxxxixxxxxxxi\"\e[0m,\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \        number too large\n\e[31m\e[31m-- Error: /tmp/tmplguq94cy.scala:49:20\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m49 |\e[0m       \
    \             \e[31m6710886400\e[0m -> \e[31m\"lxxxxxxxxxxxxi\"\e[0m,\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \        number too large\n\e[31m\e[31m-- Error: /tmp/tmplguq94cy.scala:50:20\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m50 |\e[0m       \
    \             \e[31m13421772800\e[0m -> \e[31m\"xxxxixxxxxxxxxi\"\e[0m,\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \         number too large\n\e[31m\e[31m-- Error: /tmp/tmplguq94cy.scala:51:20\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m51 |\e[0m       \
    \             \e[31m26843545600\e[0m -> \e[31m\"lxxxxxxxxxxxxxxi\"\e[0m,\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \         number too large\n\e[31m\e[31m-- Error: /tmp/tmplguq94cy.scala:52:20\
    \ ------------------------------"
  stdout: ''
  timestamp: 1660010763
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romans = mutable.ArrayBuffer(\n            \"M\",\n            \"CM\"\
    ,\n            \"D\",\n            \"CD\",\n            \"C\",\n            \"\
    XC\",\n            \"L\",\n            \"XL\",\n            \"X\",\n         \
    \   \"IX\",\n            \"V\",\n            \"IV\",\n            \"I\")\n   \
    \     var result = \"\"\n        // remove thousands separators, replace them\
    \ with spaces, convert to String\n        romans.foreach{ r =>\n            result\
    \ += number.toString.replace(s\"${r},\", \" \")\n        }\n        // remove\
    \ spaces from result\n        result = result.split(\" \")\n        // remove\
    \ thousands separators, replace them with spaces, convert to String\n        result\
    \ = result.map(x => x.replace(\",\", \"\"))\n        // remove spaces from result\n\
    \        result = result.map(x => x.replace(\" \", \"\"))\n        // remove leading\
    \ zeros\n        result = result.filter(x => x.startsWith(\"0\"))\n        //\
    \ join result into a single string\n        result.mkString(\"\")\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8atljzve.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mromans\e[0m = mutable.ArrayBuffer(\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8atljzve.scala:35:29 --------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        result = result.split(\e[31m\" \"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                 ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:\
    \    \e[1m\e[31mArray\e[0m\e[1m\e[31m[\e[0mString\e[1m\e[31m]\e[0m\n\e[31m   |\e\
    [0m                 Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp8atljzve.scala:37:35 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m        result = result.map(\e[36mx\e[0m => x.replace(\e[31m\"\
    ,\"\e[0m, \e[31m\"\"\e[0m))\n\e[31m\e[31m   |\e[0m                           \
    \      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 value replace\
    \ is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8atljzve.scala:39:35\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        result = result.map(\e\
    [36mx\e[0m => x.replace(\e[31m\" \"\e[0m, \e[31m\"\"\e[0m))\n\e[31m\e[31m   |\e\
    [0m                                 ^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                       value replace is not a member of Char\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp8atljzve.scala:41:38 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        result = result.filter(\e[36mx\e[0m => x.startsWith(\e\
    [31m\"0\"\e[0m))\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                value startsWith is not a\
    \ member of Char\n5 errors found\n"
  stdout: ''
  timestamp: 1660010758
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = \"\"\n        var number = number\n        val value = 0\n \
    \       val count = new mutable.HashMap[Int, Int]()\n        while(number > 0)\
    \ {\n            val remainder = number % 10\n            number /= 10\n     \
    \       value += remainder\n            if(count contains value) {\n         \
    \       count(value)\n                roman = value.toString\n            } else\
    \ {\n                count.put(value,1)\n            }\n        }\n        roman\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppxs2l0v0.scala:16:21 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mvar\e[0m \e[36mnumber\e[0m = number\n\e\
    [31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m              \
    \       Recursive \e[33mvariable\e[0m \e[35mnumber\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppxs2l0v0.scala:18:24 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mcount\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppxs2l0v0.scala:22:18\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            value += remainder\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean value.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val string = (1 to number).map(i => \n            number.toString.charAt(i).toLowerCase).mkString(\"\
    \")\n        val roman =\n            (\"M\"     -> \"MM\"  \n              ,\"\
    D\"     -> \"DD\"  \n              ,\"C\"     -> \"CC\"  \n              ,\"L\"\
    \     -> \"LL\"  \n              ,\"X\"     -> \"XXX\" \n              ,\"V\"\
    \     -> \"VV\"  \n              ,\"I\"     -> \"III\"  \n              ,\"X\"\
    \     -> \"XXX\" \n              ,\"0\"     -> \"0\"   \n              ,\"M\"\
    \     -> \"MMM\"  \n              ,\"D\"     -> \"DDD\"  \n              ,\"C\"\
    \     -> \"CCC\"  \n              ,\"L\"     -> \"LLL\"  \n              ,\"X\"\
    \     -> \"XXXX\"     \n              ,\"V\"     -> \"VVVV\"  \n             \
    \ ,\"I\"     -> \"IIII\"  \n              ,\"X\"     -> \"XXXX\" \n          \
    \    ,\"0\"     -> \"0\"   \n              ,\"M\"     -> \"MMMM\"  \n        \
    \      ,\"D\"     -> \"DDDD\"  \n              ,\"C\"     -> \"CCCC\"  \n    \
    \          ,\"L\"     -> \"LLLL\"  \n              ,\"X\"     -> \"XXXXXX\"  \n\
    \              ,\"V\"     -> \"VVVVV\"  \n              ,\"I\"     -> \"IIIII\"\
    \  \n              ,\"X\"     -> \"XXXXXX\" \n              ,\"0\"     -> \"0\"\
    \   \n              ,\"M\"     -> \"MMMMM\"    \n              ,\"D\"     -> \"\
    DDDDD\"    \n              ,\"C\"     -> \"CCCCC\"    \n              ,\"L\" \
    \    -> \"LLLLL\"    \n              ,\"X\"     -> \"XXXXXXX\"    \n         \
    \     ,\"V\"     -> \"VVVVVV\"    \n              ,\"I\"     -> \"IIIIII\"   \
    \ \n              ,\"X\"     -> \"XXXXXXXX\"    \n              ,\"0\"     ->\
    \ \"0\"   \n              ,\"M\"     -> \"MMMMMMMM\"  \n              ,\"D\" \
    \    -> \"DDDDDDDD\"  \n              ,\"C\"     -> \"CCCCCCCC\"  \n         \
    \     ,\"L\"     -> \"LLLLLLLL\"  \n              ,\"X\"     -> \"XXXXXXXXXX\"\
    \  \n              ,\"V\"     -> \"VVVVVVVVVV\"  \n              ,\"I\"     \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp59th8o3a.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp59th8o3a.scala:15:27 --------------------\e[0m\e[0m\n\e[31m15 |\e[0m\
    \        \e[33mval\e[0m \e[36mstring\e[0m = (\e[31m1\e[0m to number).map(\e[36mi\e\
    [0m => \n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                           Found:    (number : Long)\n\e[31m   |\e[0m\
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp59th8o3a.scala:16:38 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m            number.toString.charAt(i).toLowerCase).mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value toLowerCase is not a member of Char\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp59th8o3a.scala:61:5 ---------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010760
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romans = List(\"c\", \"d\", \"x\", \"l\", \"i\", \"v\", \"i\")\n   \
    \     var ret = \"\"\n        var i = 1\n        while(i < number) {\n       \
    \     ret = romans(number - i) + ret\n            i += 1\n        }\n        val\
    \ lastRoman = romans.last\n        val lastRomanIndex = romans.lastIndexOf[lastRoman]\n\
    \        ret + (romans(lastRomanIndex - 1))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9czxeyg1.scala:19:25\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            ret = romans(number\
    \ - i) + ret\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Found:    Long\n\e[31m   |\e[0m        \
    \                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp9czxeyg1.scala:23:48 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36mlastRomanIndex\e[0m = romans.lastIndexOf[\e[35mlastRoman\e\
    [0m]\n\e[31m\e[31m   |\e[0m                                                ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                               Not found:\
    \ type lastRoman\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010758
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val stringBuffer = new StringBuffer()\n        var count = 1\n        val\
    \ romans = \"M\"\n        val digits = \"CMXLIV\"\n        val vals = List(1,2,3,4,5,6,7,8,9,10,11,12)\n\
    \        val chars = romans ++ digits ++ digits\n        var lastNum = 0\n   \
    \     while(number > 0){\n            val num = number % 100\n            if(num\
    \ < 10)\n                stringBuffer ++= (digits(num)+ count)\n            else\n\
    \                stringBuffer ++= (chars(num % 10)+ count)\n            count\
    \ += vals(num/10)\n            number = num/100\n        }\n        stringBuffer.toLower\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6sc5l76y.scala:25:29 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                stringBuffer ++= (digits(num)+ count)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \              value ++= is not a member of StringBuffer\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp6sc5l76y.scala:25:41 --------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                stringBuffer ++= (digits(num)+ count)\n\e\
    [31m\e[31m   |\e[0m                                         ^^^\e[0m\n\e[31m \
    \  |\e[0m                                         Found:    (num : Long)\n\e[31m\
    \   |\e[0m                                         Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6sc5l76y.scala:27:29 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                stringBuffer ++= (chars(num % \e[31m10\e\
    [0m)+ count)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value ++= is not a member of StringBuffer\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp6sc5l76y.scala:27:40 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                stringBuffer ++= (chars(num % \e[31m10\e\
    [0m)+ count)\n\e[31m\e[31m   |\e[0m                                        ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        Found:    Long\n\e\
    [31m   |\e[0m                                        Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6sc5l76y.scala:28:18 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            count += vals(num/\e[31m10\e[0m)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is\
    \ not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6sc5l76y.scala:28:26 --------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m            count += vals(num/\e[31m10\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                        ^^^^^^\e[0m\n\e[31m   |\e[0m           "
  stdout: ''
  timestamp: 1660010761
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Write your code here.\n        val roman = scala.collection.mutable.Map[Long,\
    \ String]()\n        for (x <- 1L until 1000){\n            val n  = number %\
    \ x\n            number /= x\n            val romanNumber = n  match {\n     \
    \           case 0 => \"0\"\n                case 1 => \"i\"\n               \
    \ case 2 => \"ii\"\n                case 3 => \"iii\"\n                case 4\
    \ => \"iv\"\n                case 5 => \"v\"\n                case 6 => \"vi\"\
    \n                case 7 => \"vii\"\n                case 8 => \"viii\"\n    \
    \            case 9 => \"ix\"\n            }\n            roman += (x -> romanNumber)\n\
    \        }\n        roman.foldLeft(\"\")( (acc, val) => acc + \"[\" + val._2 +\
    \ \"]\" + val._1)\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpuywmp3z9.scala:34:34 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        roman.foldLeft(\e[31m\"\"\e[0m)( (\e[36macc\e\
    [0m, \e[33mval\e[0m) => acc + \e[31m\"[\"\e[0m + \e[33mval\e[0m._2 + \e[31m\"\
    ]\"\e[0m + \e[33mval\e[0m._1)\n\e[31m\e[31m   |\e[0m                         \
    \         ^^^\e[0m\n\e[31m   |\e[0m                                  expression\
    \ expected but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpuywmp3z9.scala:34:54 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        roman.foldLeft(\e[31m\"\"\e[0m)( (\e[36macc\e[0m, \e[33mval\e\
    [0m) => acc + \e[31m\"[\"\e[0m + \e[33mval\e[0m._2 + \e[31m\"]\"\e[0m + \e[33mval\e\
    [0m._1)\n\e[31m\e[31m   |\e[0m                                               \
    \       ^^^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpuywmp3z9.scala:19:19 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m            number /= x\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            value /= is not a member of Long - did you mean number.!=?\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010760
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val ints = number.toInt\n        val romans = List(\"M\", \"CM\", \"D\"\
    , \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\")\n\
    \        val result = (ints % 10l).fold(\"\")(romans append _)\n        val unit\
    \ = (ints / 10l).fold(\"\")(romans append _)\n        val lastUnit = romans.takeRight(1)\n\
    \        val lastResult = romans.dropRight(1)\n        result + (if (unit == \"\
    \") \"I\" else unit) + (if (result != lastResult) lastUnit else \"\")\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdsit5lzf.scala:17:34 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = (ints % \e\
    [31m10l\e[0m).fold(\e[31m\"\"\e[0m)(romans append _)\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \   value fold is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpdsit5lzf.scala:18:32 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m        \e[33mval\e[0m \e[36munit\e[0m = (ints / \e[31m10l\e[0m).fold(\e[31m\"\
    \"\e[0m)(romans append _)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   value fold is not a member of Long\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // Convert the number to a string, using the same number of digits as was\
    \ used to generate the original number.\n        // Convert the strings to upper\
    \ case, then join them together and return the result.\n        val roman : String\
    \ = number.toString.toUpperCase\n        val result : List[String] = roman.split('').map(c\
    \ => if (c == 'X' || c == 'x') 'I' else c).toList\n        result.foldLeft(\"\"\
    ) { (result, c) =>\n            if (c == 'I') result + \"x\" else result + c\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpn1fx6bpu.scala:18:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m : \e[35mList\e\
    [0m[\e[35mString\e[0m] = roman.split('').map(\e[36mc\e[0m => \e[33mif\e[0m (c\
    \ == \e[31m'X'\e[0m || c == \e[31m'x'\e[0m) \e[31m'I'\e[0m \e[33melse\e[0m c).toList\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                                                empty character literal\n\
    \e[31m\e[31m-- Error: /tmp/tmpn1fx6bpu.scala:20:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m (c == \e[31m'I'\e[0m) result\
    \ + \e[31m\"x\"\e[0m \e[33melse\e[0m result + c\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types String and Char\
    \ cannot be compared with == or !=\n2 errors found\n"
  stdout: ''
  timestamp: 1660010763
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = \"\"\n        var next = 0\n        val romanTable = Map(\n\
    \            1 -> \"M\",\n            4 -> \"CM\",\n            5 -> \"D\",\n\
    \            10 -> \"CD\",\n            25 -> \"CCL\",\n            100-> \"CCL\"\
    ,\n            500 -> \"L\",\n            1000 -> \"X\"\n        )\n        while\
    \ (next < number) {\n            roman += romanTable(next % 10)\n            next\
    \ += 1\n        }\n        roman.toLowerCase\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: key not found: 0\n\tat scala.collection.MapOps.default(Map.scala:274)\n\
    \tat scala.collection.MapOps.default$(Map.scala:273)\n\tat scala.collection.AbstractMap.default(Map.scala:405)\n\
    \tat scala.collection.mutable.HashMap.apply(HashMap.scala:425)\n\tat Problem$.intToMiniRoman(tmp03c_cps0.scala:28)\n\
    \tat Problem$.main(tmp03c_cps0.scala:34)\n\tat Problem.main(tmp03c_cps0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = new StringBuilder(\"\");\n        roman.append((number%100).intValue())\n\
    \        roman.append((number/100).intValue())\n        roman.append((number%10).intValue())\n\
    \        roman.append((number/10).intValue())\n        roman.append(0)\n     \
    \   roman.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc5xfhrtr.scala:24)\n\tat Problem.main(tmpc5xfhrtr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNumeralMap = Map(\n            'M' => 1000,\n            'CM' =>\
    \ 900,\n            'D' => 500,\n            'CD' => 400,\n            'C' =>\
    \ 100,\n            'XC' => 90,\n            'L' => 50,\n            'XL' => 40,\n\
    \            'X' => 10,\n            'IX' => 9,\n            'V' => 5,\n     \
    \       'IV' => 4,\n            'I' => 1,\n            'IU' => 3,\n          \
    \  'U' => 1\n        )\n        val intToRomanNumeral = romanNumeralMap.foldLeft(Map.empty[Char,\
    \ Int]) { case (map, entry) =>\n            val key = entry._1.toUpperCase\n \
    \           val value = entry._2\n            val sum = map.getOrElse(key, 0)\n\
    \            map.updated(key, value)\n            map + entry -> sum\n       \
    \ }\n        val mapKey = number match {\n            case i if i > 0 => intToRomanNumeral.keys.toList.sorted\n\
    \            case i if i < 0 => intToRomanNumeral.keySet.sorted\n            case\
    \ i => List()\n        }\n        val mapValue = number match {\n            case\
    \ i if i > 0 => intToRomanNumeral.values.toList.sorted\n            case i if\
    \ i < 0 => intToRomanNumeral.valueSet.sorted\n            case i => List()\n \
    \       }\n        val key = mapKey.sortBy(_).reverse.mkString\n        val value\
    \ = mapValue.sortBy(_).reverse.mkString\n        (key, value)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpq0_xik5z.scala:16:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[31m'M'\e[0m => \e[31m1000\e[0m,\n\e[31m\e\
    [31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m            not a legal formal\
    \ parameter\n\e[31m\e[31m-- Error: /tmp/tmpq0_xik5z.scala:17:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[31m'CM\e[0m' => \e[31m900\e[0m,\n\e[31m\e\
    [31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0msymbol literal 'CM is no longer\
    \ supported,\n\e[31m   |\e[0muse a string literal \"CM\" or an application Symbol(\"\
    CM\") instead,\n\e[31m   |\e[0mor enclose in braces '{CM} if you want a quoted\
    \ expression.\n\e[31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0_xik5z.scala:17:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[31m'CM\e\
    [0m' => \e[31m900\e[0m,\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m  \
    \ |\e[0m               ')' expected, but ' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpq0_xik5z.scala:33:31 ------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m            \e[33mval\e[0m \e[36mkey\e[0m = entry._1.toUpperCase\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      value toUpperCase is not a member of Nothing\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpq0_xik5z.scala:37:12 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            map + entry -> sum\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    \e\
    [1m\e[31m(\e[0mscala.collection.mutable.Map[Char, Int]\e[1m\e[31m,\e[0m\e[1m\e\
    [31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m            Required:\
    \ scala.collection.mutable.Map[Char, Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpq0_xik5z.scala:41:56 ------------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m            \e[33mcase\e[0m i \e[33mif\e[0m "
  stdout: ''
  timestamp: 1660010768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var romanStr = \"\"\n        var numeralStr = \"\"\n        for(i = 1 to\
    \ number.toInt) {\n            // Divide number by 1000, then subtract 1 to get\
    \ numeral\n            // and remainder from division (i.e. floor)\n         \
    \   var numeral = (number / 1000 - 1).toInt\n            var remainder = number\
    \ % 1000\n            numeralStr = romanStr + roman(numeral) + numeralStr\n  \
    \          romanStr = roman(remainder) + romanStr\n        }\n        numeralStr.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9ccndvf7.scala:17:14 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mfor\e[0m(i = \e[31m1\e[0m to number.toInt)\
    \ {\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m              ')'\
    \ expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9ccndvf7.scala:17:35\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mfor\e[0m(i\
    \ = \e[31m1\e[0m to number.toInt) {\n\e[31m\e[31m   |\e[0m                   \
    \                ^\e[0m\n\e[31m   |\e[0m                                   '<-'\
    \ expected, but '{' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9ccndvf7.scala:26:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m \
    \  |\e[0m    ^\e[0m\n\e[31m   |\e[0m    '<-' expected, but '}' found\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9ccndvf7.scala:24:9 -------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m\
    \   |\e[0mvalue foreach is not a member of Null, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.set asScala\n\e\
    [31m   |\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660010768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var miniRoman = \"\"\n        for(i <- 0 to (number/1000)){\n          \
    \  val digit = number/1000*1000+(i*1000-1000)\n            miniRoman = (digit%1000000000L)\
    \ + miniRoman + romanNumeral(digit/1000000000)\n        }\n        miniRoman =\
    \ (number%1000000000L) + miniRoman\n        miniRoman.toLowerCase()\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp21_5a7k_.scala:16:23\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m(i <- \e\
    [31m0\e[0m to (number/\e[31m1000\e[0m)){\n\e[31m\e[31m   |\e[0m              \
    \         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       Found:    Long\n\
    \e[31m   |\e[0m                       Required: Int\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp21_5a7k_.scala:18:58 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            miniRoman = (digit%\e[31m1000000000L\e[0m)\
    \ + miniRoman + romanNumeral(digit/\e[31m1000000000\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                          ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                 Not found: romanNumeral\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = \"\"\n        var lastDigit = 0\n\n        def isDigit(digit\
    \ : Int) : Boolean = {\n            digit < lastDigit\n        }\n\n        while(number\
    \ > 0) {\n            if(isDigit(number % 10)) {\n                roman += (number\
    \ / 10).toString + roman\n            } else {\n                roman += roman\n\
    \                lastDigit = number % 10\n            }\n            number /=\
    \ 10\n        }\n\n        roman.substring(roman.length - 1) + roman\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpihu21jcq.scala:23:23\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m(isDigit(number\
    \ % \e[31m10\e[0m)) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    Long\n\e[31m   |\e[0m   \
    \                    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpihu21jcq.scala:27:28 --------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m                lastDigit = number % \e[31m10\e[0m\n\e[31m\e[31m   |\e\
    [0m                            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \               Found:    Long\n\e[31m   |\e[0m                            Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpihu21jcq.scala:29:19\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            number /= \e\
    [31m10\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value /= is not a member of Long - did you mean number.!=?\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var output : String = \"\"\n        val romans : Map[Long, String] = Map(\n\
    \                100l -> \"M\",\n                500l -> \"D\",\n            \
    \    1000l -> \"C\",\n                5000l -> \"C\",\n                10000l\
    \ -> \"C\",\n                50000l -> \"C\",\n                100000l -> \"C\"\
    ,\n                1000000l -> \"C\",\n                500000l -> \"C\",\n   \
    \             1000000l -> \"C\",\n                10000000l -> \"C\",\n      \
    \          50000000l -> \"C\",\n                100000000l -> \"C\",\n       \
    \         500000000l -> \"C\",\n                1000000000l -> \"C\",\n      \
    \          5000000000l -> \"C\",\n                10000000000l -> \"C\",\n   \
    \             50000000000l -> \"C\",\n                100000000000l -> \"C\",\n\
    \                500000000000l -> \"C\",\n                1000000000000l -> \"\
    C\",\n                5000000000000l -> \"C\",\n                10000000000000l\
    \ -> \"C\",\n                50000000000000l -> \"C\",\n                100000000000000l\
    \ -> \"C\",\n                500000000000000l -> \"C\",\n                1000000000000000l\
    \ -> \"C\",\n                5000000000000000l -> \"C\",\n                1000000000000000000l\
    \ -> \"C\",\n                10000000000000000000l -> \"C\",\n               \
    \ 100000000000000000000l -> \"C\",\n                1000000000000000000000l ->\
    \ \"C\",\n                10000000000000000000000l -> \"C\",\n               \
    \ 100000000000000000000000l -> \"C\",\n                1000000000000000000000000l\
    \ -> \"C\",\n                10000000000000000000000000l -> \"C\",\n         \
    \       100000000000000000000000000l -> \"C\",\n                1000000000000000000000000000l\
    \ -> \"C\",\n                10000000000000000000000000000l -> \"C\",\n      \
    \          100000000000000000000000000000l -> \"C\",\n                1000000000000000000000000000000l\
    \ -> \"C\",\n                10000000000000000000000000000000l -> \"C\",\n   \
    \             100000000000000000000000000000000l -> \"C\",\n                1000000000000000000000000000000000l\
    \ -> \"C\",\n                1000000000000000000000000000000000l -> \"C\",\n \
    \               100000000000000000000000000000000l-> \"C\",\n                1000000000000000000000000000000000l\
    \ -> \"C\",\n                100000000000000000000000000000000l -> \"C\",\n  \
    \              1000000000000000000000000000000000l -> \"C\",\n               \
    \ 100000000000000000000000000000000l -> \"C\",\n                1000000000000000000000000000000000l\
    \ -> \"\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpjj5_b_sx.scala:46:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                \e[31m10000000000000000000l\e[0m -> \e\
    [31m\"C\"\e[0m,\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m\
    \                number too large\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjj5_b_sx.scala:47:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m                \e[31m100000000000000000000l\e\
    [0m -> \e[31m\"C\"\e[0m,\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m\
    \   |\e[0m                ')' expected, but long literal found\n\e[31m\e[31m--\
    \ Error: /tmp/tmpjj5_b_sx.scala:67:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m                \e[31m1000000000000000000000000000000000l\e\
    [0m -> \"\n\e[31m\e[31m   |\e[0m                                             \
    \          ^\e[0m\n\e[31m   |\e[0m                                           \
    \      unclosed string literal\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjj5_b_sx.scala:68:5\
    \ ---------------------\e[0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if(number == 0) return \"\"\n        def miniRoman(num : Int) : String =\
    \ {\n            val base = scala.math.pow(10, num.toInt - 1)\n            val\
    \ val = scala.math.ceil(scala.math.pow(base.toFloat, num)).toInt\n           \
    \ val rem = scala.math.ceil(scala.math.pow(base.toFloat, num - val).toInt)\n \
    \           val miniRoman = if(val < 1000) \"M\" + rem.toString else if(val <\
    \ 900) \"CM\" else if (val < 500) \"D\" + rem.toString else val < 400 else \"\
    CD\" + rem.toString\n            if(val <= 9) return miniRoman\n            if(val\
    \ <= 99) return miniRoman + \"C\"\n            if(val <= 999) return miniRoman\
    \ + \"C\" + rem.toString\n            if(val <= 9999) return miniRoman + \"C\"\
    \ + rem.toString + \"V\"\n            if(val <= 99999) return miniRoman + \"C\"\
    \ + rem.toString + \"V\" + rem.toString\n            if(val <= 999999) return\
    \ miniRoman + \"C\" + rem.toString + \"V\" + rem.toString + \"X\"\n          \
    \  if(val <= 9999999) return miniRoman + \"C\" + rem.toString + \"V\" + rem.toString\
    \ + \"X\" + rem.toString\n            if(val <= 999999999) return miniRoman +\
    \ \"C\" + rem.toString + \"V\" + rem.toString + \"X\" + rem.toString + \"L\"\n\
    \            if(val <= 99999999) return miniRoman + \"C\" + rem.toString + \"\
    V\" + rem.toString + \"X\" + rem.toString + \"L\" + rem.toString\n           \
    \ if(val <= 99999999999) return miniRoman + \"C\" + rem.toString + \"V\" + rem.toString\
    \ + \"X\" + rem.toString + \"L\" + rem.toString + \"I\"\n            if(val <=\
    \ 999999999999) return miniRoman + \"C\" + rem.toString + \"V\" + rem.toString\
    \ + \"X\" + rem.toString + \"L\" + rem.toString + \"I\" + rem.toString\n     \
    \       if(val <= 999999999999999999) return miniRoman + \"C\" + rem.toString\
    \ + \"V\" + rem.toString + \"X\" + rem.toString + \"L\" + rem.toString + \"I\"\
    \ + rem.toString + \"V\"\n            if(val <= 999999999999999999) return miniRoman\
    \ + \"C\" + rem.toString + \"V\" + rem.toString + \"X\" + rem.toString + \"L\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpj352kt29.scala:18:16 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[33mval\e[0m = scala.math.ceil(scala.math.pow(base.toFloat,\
    \ num)).toInt\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m\
    \                pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpj352kt29.scala:19:73 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m            \e[33mval\e[0m \e[36mrem\e[0m = scala.math.ceil(scala.math.pow(base.toFloat,\
    \ num - \e[33mval\e[0m).toInt)\n\e[31m\e[31m   |\e[0m                        \
    \                                                 ^^^\e[0m\n\e[31m   |\e[0m  \
    \                                     expression expected but \e[31mval\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpj352kt29.scala:20:31\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e\
    [0m \e[36mminiRoman\e[0m = \e[33mif\e[0m(\e[33mval\e[0m < \e[31m1000\e[0m) \e\
    [31m\"M\"\e[0m + rem.toString \e[33melse\e[0m \e[33mif\e[0m(\e[33mval\e[0m < \e\
    [31m900\e[0m) \e[31m\"CM\"\e[0m \e[33melse\e[0m \e[33mif\e[0m (\e[33mval\e[0m\
    \ < \e[31m500\e[0m) \e[31m\"D\"\e[0m + rem.toString \e[33melse\e[0m \e[33mval\e\
    [0m < \e[31m400\e[0m \e[33melse\e[0m \e[31m\"CD\"\e[0m + rem.toString\n\e[31m\e\
    [31m   |\e[0m                               ^^^\e[0m\n\e[31m   |\e[0m        \
    \                       expression expected but \e[31mval\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpj352kt29.scala:20:70 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mminiRoman\e[0m = \e\
    [33mif\e[0m(\e[33mval\e[0m < \e[31m1000\e[0m) \e[31m\"M\"\e[0m + rem.toString\
    \ \e[33melse\e[0m \e[33mif\e[0m(\e[33mval\e[0m < \e[31m900\e[0m) \e[31m\"CM\"\e\
    [0m \e[33melse\e[0m \e[33mif\e[0m (\e[33mval\e[0m < \e[31m500\e[0m) \e[31m\"D\"\
    \e[0m + rem.toString \e[33melse\e[0m \e[33mval\e[0m < \e[31m400\e[0m \e[33melse\e\
    [0m \e[31m\"CD\"\e[0m + rem.to"
  stdout: ''
  timestamp: 1660010765
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var numerals = scala.collection.mutable.ListBuffer[String]()\n        while\
    \ (number > 0) {\n            numerals += intToMiniRoman(number % 10)\n      \
    \      number /= 10\n        }\n        numerals.reverse.mkString(\"\").toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplh2qqmnp.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            number /= \e[31m10\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean number.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romans = collection.mutable.ArrayBuffer(\n            \"M\", \"CM\"\
    , \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"\
    I\")\n        val numToRoman =\n            collection.mutable.ArrayBuffer.empty[String]\n\
    \        for {\n            r <- romans\n        } yield {\n            val num\
    \ = number % 10\n            numToRoman += r + numToRoman.length\n           \
    \ number /= 10\n        }\n        numToRoman.toSeq.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4hhb5zvt.scala:24:19 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            number /= \e[31m10\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean number.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val digits = number.toString.reverse\n        var roman = \"\"\n       \
    \ var remainder = 0\n        for(i<- 0 until digits.length){\n            remainder\
    \ = digits(i)-48\n            roman = roman  + remainder+if (i%2==0) \"M\" else\
    \ \"I\"\n        }\n        roman = roman.substring(0, roman.length-1)\n     \
    \   return roman\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp84pq2qoe.scala:20:39 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            roman = roman  + remainder+\e[33mif\e[0m\
    \ (i%\e[31m2\e[0m==\e[31m0\e[0m) \e[31m\"M\"\e[0m \e[33melse\e[0m \e[31m\"I\"\e\
    [0m\n\e[31m\e[31m   |\e[0m                                       ^^\e[0m\n\e[31m\
    \   |\e[0m                                       expression expected but \e[31mif\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \   val letters: mutable.Set[String] = mutable.Set.empty\n      val roman: mutable.Map[String,\
    \ Long] = mutable.Map.empty\n      val minRoman = 1000000\n      number.foreach\
    \ { i =>\n        val romanNum = i * 100\n        if(romanNum < minRoman) minRoman\
    \ = romanNum\n        if(romanNum in roman.keySet) letters add roman(romanNum)\n\
    \        else roman(romanNum) = romanNum\n      }\n      roman.keys.sorted.map(_\
    \ + \" \").mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcwgu4o5f.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m      \e[33mval\e[0m \e[36mletters\e[0m: mutable.Set[\e\
    [35mString\e[0m] = mutable.Set.empty\n\e[31m\e[31m   |\e[0m                  \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcwgu4o5f.scala:15:41 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m      \e[33mval\e[0m \e[36mletters\e[0m: mutable.Set[\e\
    [35mString\e[0m] = mutable.Set.empty\n\e[31m\e[31m   |\e[0m                  \
    \                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpcwgu4o5f.scala:16:17 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m      \e[33mval\e[0m \e[36mroman\e[0m: mutable.Map[\e[35mString\e\
    [0m, \e[35mLong\e[0m] = mutable.Map.empty\n\e[31m\e[31m   |\e[0m             \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                 Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcwgu4o5f.scala:16:45 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m      \e[33mval\e[0m \e[36mroman\e[0m: mutable.Map[\e\
    [35mString\e[0m, \e[35mLong\e[0m] = mutable.Map.empty\n\e[31m\e[31m   |\e[0m \
    \                                            ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpcwgu4o5f.scala:18:13 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m      number.foreach { \e[36mi\e[0m =>\n\e[31m\e[31m\
    \   |\e[0m      ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value foreach is not\
    \ a member of Long\n5 errors found\n"
  stdout: ''
  timestamp: 1660010768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val r = numToRoman _\n        val roman = number.toLong.toRoman\n      \
    \  roman.foldLeft(List[String]()) {\n            case (acc: List[String], digit:\
    \ Int) => digitToRoman _ (digit) :: acc\n            case (acc: List[String],\
    \ digit: Long) => digitToRoman _ (digit) :: acc\n            case (acc: List[String],\
    \ digit: String) => digitToRoman _ (digit) :: acc\n            case (acc: List[String],\
    \ digit: Option[Long]) => digitToRoman _ (digit) :: acc\n            case (acc:\
    \ List[String], digit: Option[Int]) => digitToRoman _ (digit) :: acc\n       \
    \     case (acc: List[String], digit: Option[String]) => digitToRoman _ (digit)\
    \ :: acc\n            case (acc: List[String], _) => acc ::: List(digitToRoman\
    \ _ (digit))\n        }.reverse.mkString.toLowerCase\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpz8e49y5v.scala:18:67 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mcase\e[0m (acc: List[String], digit:\
    \ Int) => digitToRoman _ (digit) :: acc\n\e[31m\e[31m   |\e[0m               \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                                end of statement expected but '(' found\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpz8e49y5v.scala:15:16 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = numToRoman _\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      Not found: numToRoman\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpz8e49y5v.scala:16:34 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m        \e[33mval\e[0m \e[36mroman\e[0m = number.toLong.toRoman\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toRoman is not a member of Long\n3 errors found\n"
  stdout: ''
  timestamp: 1660010767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = List(\n            \"I\", \"V\", \"X\", \"L\", \"C\", \"D\"\
    , \"M\", \"M\", \"C\", \"L\", \"I\",\n            \"X\", \"L\", \"C\", \"D\",\
    \ \"M\", \"M\", \"C\", \"L\", \"I\", \"X\", \"L\",\n            \"C\", \"D\",\
    \ \"M\", \"M\", \"C\", \"L\", \"I\", \"X\", \"L\", \"C\", \"D\",\n           \
    \ \"M\", \"M\", \"C\", \"L\", \"I\", \"X\", \"L\", \"C\", \"D\", \"M\", \"M\"\n\
    \        )\n        val numeral = number % 1000000000000\n        val divisor\
    \ = number / 1000000000000\n        val rem = number % 1000000000000\n       \
    \ if (divisor == 0 && rem == 0) {\n            numeral.map(roman(i => roman(i))).mkString(\"\
    \")\n        } else {\n            numeral.map(roman(i => roman(i))).mkString(\"\
    \") + roman(divisor)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpxla26thj.scala:21:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnumeral\e[0m = number %\
    \ \e[31m1000000000000\e[0m\n\e[31m\e[31m   |\e[0m                            \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               number too\
    \ large\n\e[31m\e[31m-- Error: /tmp/tmpxla26thj.scala:22:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mdivisor\e[0m = number /\
    \ \e[31m1000000000000\e[0m\n\e[31m\e[31m   |\e[0m                            \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               number too\
    \ large\n\e[31m\e[31m-- Error: /tmp/tmpxla26thj.scala:23:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mrem\e[0m = number % \e[31m1000000000000\e\
    [0m\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           number too large\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpxla26thj.scala:25:20 ------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m            numeral.map(roman(\e[36mi\e[0m => roman(i))).mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            value map is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpxla26thj.scala:25:30 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            numeral.map(roman(\e[36mi\e[0m => roman(i))).mkString(\e[31m\"\
    \"\e[0m)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Found:    Int => String\n\e[31m \
    \  |\e[0m                              Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpxla26thj.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            numeral.map(roman(\e[36mi\e[0m => roman(i))).mkString(\e\
    [31m\"\"\e[0m) + roman(divisor)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value map is not a member of Long\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpxla"
  stdout: ''
  timestamp: 1660010771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = scala.collection.mutable.ArrayBuffer.empty[String]\n       \
    \ var i = 1\n        while (number > 0 || roman.isEmpty) {\n            // Add\
    \ next number in sequence\n            var nextValue = number\n            //\
    \ Compare last number in sequence\n            if (roman.isEmpty) {\n        \
    \        roman.append (nextValue)\n            } else {\n                while\
    \ (roman.last <= nextValue) {\n                    roman.append (\"m\")\n    \
    \            }\n                // Add next number in sequence\n             \
    \   roman.append (nextValue)\n            }\n            // Add roman numeral\
    \ symbols for numbers\n            while (i < 10) {\n                var lastValue\
    \ = roman.last\n                if (lastValue == 0) {\n                    break\n\
    \                }\n                val nextValue = roman.last\n             \
    \   roman.append (nextValue)\n                while (nextValue > lastValue) {\n\
    \                    roman.append (\"c\")\n                    nextValue -= 1\n\
    \                }\n                i += 1\n            }\n            // Remove\
    \ last roman numeral symbol\n            roman.last match {\n                case\
    \ x if x > 0 => roman.dropRight(1)\n                case x if x == 0 => roman\n\
    \                case _ => roman\n            }\n            number -= 1\n   \
    \     }\n        roman.toList.sorted match {\n            case Nil => \"\"\n \
    \           case x => x.mkString(\"\")\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqadhtv7l.scala:22:22 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                roman.append (nextValue)\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mappend\e[0m in \e[33mtrait\e[0m \e[35mBuffer\e\
    [0m with types\n\e[31m   |\e[0m (elems: String*): (roman : scala.collection.mutable.ArrayBuffer[String])\n\
    \e[31m   |\e[0m (elem: String): (roman : scala.collection.mutable.ArrayBuffer[String])\n\
    \e[31m   |\e[0mmatch arguments ((nextValue : Long))\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpqadhtv7l.scala:24:37 --------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m                \e[33mwhile\e[0m (roman.last <= nextValue) {\n\e\
    [31m\e[31m   |\e[0m                                     ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     Found:    (nextValue : Long)\n\e\
    [31m   |\e[0m                                     Required: String\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpqadhtv7l.scala:28:22 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                roman.append (nextValue)\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mappend\e[0m in \e[33mtrait\e[0m \e[35mBuffer\e\
    [0m with types\n\e[31m   |\e[0m (elems: String*): (roman : scala.collection.mutable.ArrayBuffer[String])\n\
    \e[31m   |\e[0m (elem: String): (roman : scala.collection.mutable.ArrayBuffer[String])\n\
    \e[31m   |\e[0mmatch arguments ((nextValue : Long))\n\e[31m\e[31m-- Error: /tmp/tmpqadhtv7l.scala:33:20\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m33 |\e[0m       \
    \         \e[33mif\e[0m (lastValue == \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Values of types\
    \ String and Int cannot be compared with == or !=\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpqadhtv7l.scala:34:20 ------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m                    break\n\e[31m\e[31m   |\e"
  stdout: ''
  timestamp: 1660010771
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = List(\n            List(\"M\",\"D\",\"C\"),\n            List(\"\
    D\",\"C\",\"L\"),\n            List(\"C\",\"X\",\"V\")\n        ).flatten\n\n\
    \        val romanResults = roman.map{ romanCharacters =>\n            number\
    \ / romanCharacters.foldLeft(0)(_+_)\n        }\n\n        val romanCharacters\
    \ = roman.map{ romanCharacters =>\n            number % romanCharacters.foldLeft(0)(_+_)\n\
    \        }\n\n        (romanResults zip romanCharacters).map{ case(result, character)\
    \ =>\n            character + result.toString\n        }.mkString(\"\")\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl44gyd2r.scala:34)\n\tat Problem.main(tmpl44gyd2r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010772
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if(number < 0 || number > 1000) throw new Exception(\"Value out of range\"\
    )\n        val digits = number.toString.toCharArray\n        val result = mutable.ArrayBuffer.empty[String]\n\
    \        val remainder = number % 1000\n        var i = 1\n        while (remainder\
    \ >= 1000) {\n            val temp = (remainder % 1000).div(1000)\n          \
    \  result += digits.subseq(i-1, i)\n            digits = digits.tail\n       \
    \     remainder = temp\n            i += 1\n        }\n        result += digits.subseq(i-1,\
    \ i)\n        result + digits.last\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppscb23jp.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmppscb23jp.scala:21:42 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mtemp\e[0m = (remainder\
    \ % \e[31m1000\e[0m).div(\e[31m1000\e[0m)\n\e[31m\e[31m   |\e[0m             \
    \          ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \ value div is not a member of Long\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmppscb23jp.scala:23:19\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            digits =\
    \ digits.tail\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            Reassignment to val digits\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmppscb23jp.scala:24:22 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            remainder = temp\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to\
    \ val remainder\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numString = number.toString\n        val digits = numString.substring(1,\
    \ numString.length - 1)\n        val digitGroups = digits.grouped(3).map { n =>\n\
    \            val digitStr = n.map(_.toString).reverse.foldLeft(\"\")((accum, digit)\
    \ => accum + digit)\n            digitStr + digitStr.charAt(0)\n        }\n  \
    \      val romanStrings = digitGroups.map { num =>\n            val roman = num.chars().takeWhile(_\
    \ < 4).mkString(\"\") + num.charAt(0)\n            roman\n        }\n        romanStrings.filter(_.isLower).mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz0c3jpiy.scala:22:53 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mroman\e[0m = num.chars().takeWhile(_\
    \ < \e[31m4\e[0m).mkString(\e[31m\"\"\e[0m) + num.charAt(\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue mkString is not a member of java.util.stream.IntStream -\
    \ did you mean IntStream.toString?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz0c3jpiy.scala:25:30\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        romanStrings.filter(_.isLower).mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            value isLower is not a member of Nothing\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010773
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val intToRoman = (i: Int) => {\n            val roman = i match {\n    \
    \            case 0 => \"M\"\n                case 1 => \"D\"\n              \
    \  case 2 => \"C\"\n                case 3 => \"X\"\n                case 4 =>\
    \ \"L\"\n                case 5 => \"V\"\n                case 6 => \"I\"\n  \
    \              case _ => \"\"\n            }\n            (roman, i)\n       \
    \ }\n\n        val miniRoman = number.toString.map { i =>\n            (roman(i),\
    \ i)\n        }.toList\n        miniRoman.sortBy((_._1).size).reverse.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps81tj0yf.scala:30:13 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            (roman(i), i)\n\e[31m\e[31m   |\e[0m    \
    \         ^^^^^\e[0m\n\e[31m   |\e[0m             Not found: roman\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmps81tj0yf.scala:32:26 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        miniRoman.sortBy((_._1).size).reverse.mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m\
    \   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$1 of expanded function:\n\e[31m   |\e\
    [0m   _$1 => _$1._1.\n\e[31m\e[31m-- Error: /tmp/tmps81tj0yf.scala:32:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        miniRoman.sortBy((_._1).size).reverse.mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                                     ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660010771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNumeralMap : mutable.Map[Long, String] = mutable.Map.empty[Long,\
    \ String]\n        val intToRomanMap : mutable.Map[Int, String] = mutable.Map.empty[Int,\
    \ String]\n        val intsToRomans : mutable.List[Long] = mutable.List.empty[Long]\n\
    \        val intsToRomansMap : mutable.Map[Int, Long] = mutable.Map.empty[Int,\
    \ Long]\n        val numbersWithRomans : mutable.Set[Long] = mutable.Set.empty[Long]\n\
    \        val numbersWithRomansMap : mutable.Map[Long, Boolean] = mutable.Map.empty[Long,\
    \ Boolean]\n        \n        while(number > 0) {\n            number % 10 match\
    \ {\n                case 0 => romanNumeralMap += (number % 100l, \"M\")\n   \
    \             case 1 => romanNumeralMap += (number % 10l, \"D\")\n           \
    \     case 2 => romanNumeralMap += (number % 10l, \"C\")\n                case\
    \ 3 => romanNumeralMap += (number % 10l, \"L\")\n                case 4 => romanNumeralMap\
    \ += (number % 10l, \"X\")\n                case 5 => romanNumeralMap += (number\
    \ % 10l, \"V\")\n                case 6 => romanNumeralMap += (number % 10l, \"\
    I\")\n            }\n            number /= 10\n        }\n        romanNumeralMap\
    \ foreach {\n            case (k,v) => intToRomanMap += (k.asInstanceOf[Int],\
    \ v)\n        }\n        intToRomanMap.foreach {\n            case (k,v) => intsToRomans\
    \ += k\n        }\n        romanNumeralMap.values.toList foreach {\n         \
    \   case (v,k) => numbersWithRomans += k\n        }\n        \n        val romanNumbers\
    \ : mutable.Set[String] = mutable.Set.empty[String]\n        \n        val strings\
    \ : mutable.Map[Long, String] = mutable.Map.empty[Long, String]\n        val numbersWithStrings\
    \ : mutable.Set[Long] = mutable.Set.empty[Long]\n        numbersWithRomans.toList\
    \ foreach { n =>\n            romanNumbers += v\n        }\n        numbersWithStrings\
    \ += number\n        \n        numbersWithStrings.foreach {\n            case\
    \ i => strings += intsToRomans(i) -> v\n        }\n        strings\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplytwfis0.scala:15:30 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mromanNumeralMap\e[0m : mutable.Map[\e\
    [35mLong\e[0m, \e[35mString\e[0m] = mutable.Map.empty[\e[35mLong\e[0m, \e[35mString\e\
    [0m]\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                              Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmplytwfis0.scala:15:58 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mromanNumeralMap\e[0m : mutable.Map[\e\
    [35mLong\e[0m, \e[35mString\e[0m] = mutable.Map.empty[\e[35mLong\e[0m, \e[35mString\e\
    [0m]\n\e[31m\e[31m   |\e[0m                                                  \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                                       \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmplytwfis0.scala:16:28 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m        \e[33mval\e[0m \e[36mintToRomanMap\e[0m : mutable.Map[\e[35mInt\e[0m,\
    \ \e[35mString\e[0m] = mutable.Map.empty[\e[35mInt\e[0m, \e[35mString\e[0m]\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplytwfis0.scala:16:55 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mintToRomanMap\e[0m : mutable.Map[\e\
    [35mInt\e[0m, \e[35mString\e[0m] = mutable.Map.empty[\e[35mInt\e[0m, \e[35mString\e\
    [0m]\n\e[31m\e[31m   |\e[0m                                                  \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                                          \
    \            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmplytwfis0.scala:17:27 ------------------------\e[0m\e"
  stdout: ''
  timestamp: 1660010773
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanArray = Array(\n            \"\",\n            \"I\",\n       \
    \     \"II\",\n            \"III\",\n            \"IV\",\n            \"V\",\n\
    \            \"VI\",\n            \"VII\",\n            \"VIII\",\n          \
    \  \"IX\",\n            \"X\"\n        )\n        val counter = new mutable.HashMap[Long,\
    \ String]()\n        val roman = new mutable.Stack[String]()\n\n        while\
    \ (number > 0) {\n            val remainder = number % 10\n            number\
    \ /= 10\n            counter(remainder) += 1\n        }\n\n        roman.clear()\n\
    \        counter.foreach { case (counter, romanNumeral) =>\n            roman.append(romanNumeral)\n\
    \            while (counter > 0) {\n                roman.push(\"I\")\n      \
    \          counter -= 1\n            }\n        }\n\n        val miniRoman = roman.toArray.mkString\n\
    \        miniRoman.toUpperCase\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9vjucc1o.scala:28:26 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mcounter\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mLong\e[0m, \e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp9vjucc1o.scala:29:24 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mroman\e[0m = \e[33mnew\e[0m mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp9vjucc1o.scala:33:19 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            number /= \e[31m10\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean number.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010775
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = new mutable.HashMap[Long, String]();\n        roman.put(0l,\
    \ \"i\");\n        roman.put(1l, \"i\");\n        roman.put(2l, \"iix\");\n  \
    \      roman.put(3l, \"iix\");\n        roman.put(4l, \"iix\");\n        roman.put(5l,\
    \ \"iv\");\n        roman.put(6l, \"iv\");\n        roman.put(7l, \"v\");\n  \
    \      roman.put(8l, \"v\");\n        roman.put(9l, \"vi\");\n        roman.put(10l,\
    \ \"vi\");\n        roman.put(11l, \"vii\");\n        roman.put(12l, \"vii\");\n\
    \        roman.put(13l, \"vii\");\n        roman.put(14l, \"vii\");\n        roman.put(15l,\
    \ \"vii\");\n        roman.put(16l, \"vii\");\n        roman.put(17l, \"vii\"\
    );\n        roman.put(18l, \"vii\");\n        roman.put(19l, \"vii\");\n     \
    \   roman.put(20l, \"vi\");\n        roman.put(21l, \"vi\");\n        roman.put(22l,\
    \ \"vi\");\n        roman.put(23l, \"vi\");\n        roman.put(24l, \"v\");\n\
    \        roman.put(25l, \"v\");\n        roman.put(26l, \"v\");\n        roman.put(27l,\
    \ \"v\");\n        roman.put(28l, \"v\");\n        roman.put(29l, \"vi\");\n \
    \       roman.put(30l, \"vi\");\n        roman.put(31l, \"vi\");\n        roman.put(32l,\
    \ \"vi\");\n        roman.put(33l, \"vi\");\n        roman.put(34l, \"vi\");\n\
    \        roman.put(35l, \"vi\");\n        roman.put(36l, \"vi\");\n        roman.put(37l,\
    \ \"vi\");\n        roman.put(38l, \"vi\");\n        roman.put(39l, \"vi\");\n\
    \        roman.put(40l, \"vi\");\n        roman.put(41l, \"vi\");\n        roman.put(42l,\
    \ \"vi\");\n        roman.put(43l, \"vi\");\n        roman.put(44l, \"vi\");\n\
    \        roman\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd8pp0za6.scala:15:24 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mvar\e[0m \e[36mroman\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mLong\e[0m, \e[35mString\e[0m]();\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanNumbers = mutable.ArrayBuffer.empty[String]\n        val romanNumerals\
    \ = mutable.ArrayBuffer.empty[String]\n        romanNumerals += \"M\"\n      \
    \  romanNumerals += \"CM\"\n        romanNumerals += \"D\"\n        romanNumerals\
    \ += \"CD\"\n        romanNumerals += \"C\"\n        romanNumerals += \"XC\"\n\
    \        romanNumerals += \"L\"\n        romanNumerals += \"XL\"\n        romanNumerals\
    \ += \"X\"\n        romanNumerals += \"IX\"\n        romanNumerals += \"V\"\n\
    \        romanNumerals += \"IV\"\n        romanNumerals += \"I\"\n        var\
    \ romanDigits = scala.collection.mutable.ArrayBuffer.empty[String]\n        var\
    \ romanString = \"\"\n        val factors = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        factors += 2\n        factors += 3\n        factors += 5\n        factors\
    \ += 10\n        factors += 50\n        factors += 100\n        factors += 500\n\
    \        factors += 1000\n        while(number > 0) {\n            val currentFactor\
    \ = number % factors\n            number /= factors\n            factors -= currentFactor\n\
    \            romanDigits += romanNumerals(currentFactor)\n        }\n        romanDigits\
    \ ++= romanNumerals.reverse.dropWhile(_.isNotEmpty)\n        romanDigits ++= romanNumerals.reverse.takeWhile(_.isEmpty)\n\
    \        romanDigits ++= romanNumerals.reverse.drop(romanNumerals.length).take(romanNumerals.length)\n\
    \        romanString += romanDigits.reverse.mkString(\"\")\n        return romanString.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplbe9svq8.scala:15:27 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mromanNumbers\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmplbe9svq8.scala:16:28 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mromanNumerals\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmplbe9svq8.scala:42:39 -----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e[0m \e[36mcurrentFactor\e[0m =\
    \ number % factors\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m%\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m\
    \   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch\
    \ arguments ((factors : scala.collection.mutable.ArrayBuffer[Long]))\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmplbe9svq8.scala:43:19 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            number /= factors\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean number.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val miniRomanStrings = List(\n            (\"M\", 1000),\n            (\"\
    CM\", 900),\n            (\"D\", 500),\n            (\"CD\", 400),\n         \
    \   (\"C\", 100),\n            (\"XC\", 90),\n            (\"L\", 50),\n     \
    \       (\"XL\", 40),\n            (\"X\", 10),\n            (\"IX\", 9),\n  \
    \          (\"V\", 5),\n            (\"IV\", 4),\n            (\"I\", 1)\n   \
    \     )\n        // Keep track of the current total and current power\n      \
    \  var totalPower = 1\n        var currentTotal = 0\n        // Convert the number\
    \ into roman numerals using recursion\n        def convertRecursively(numerals\
    \ : List[Long], currentTotal : Long) : String = {\n            // Exit the recursion\
    \ base case (numerals is empty)\n            if (numerals.isEmpty) {\n       \
    \         if (currentTotal > 9) {\n                    return (currentTotal)\n\
    \                } else {\n                    return (currentTotal.toString)\n\
    \                }\n            }\n            // Get the next number in the numeral\
    \ list and convert it\n            var nextNum = numerals.head\n            numerals.head\
    \ = numerals.tail.head\n            currentTotal += nextNum\n            // Recursively\
    \ convert the next number in numerals\n            var nextNumRoman = convertRecursively(numerals.tail,\
    \ currentTotal)\n            // Return the converted number and the remaining\
    \ numeral list\n            return (nextNumRoman + nextNum.toString)\n       \
    \ }\n        // Convert the number into roman numerals using a loop\n        def\
    \ convertLoop(number : Long) : String = {\n            // Keep track of the current\
    \ total and current power\n            var totalPower = 1\n            var currentTotal\
    \ = 0\n            // Convert the number into roman numerals using loop\n    \
    \        while (currentTotal < number) {\n                currentTotal += 2\n\
    \                // Add the next number to the current total\n               \
    \ currentTotal += (number / currentTotal).toInt\n                // Update the\
    \ power\n                totalPower *= 3\n            }\n            // Convert\
    \ the number into roman numerals using recursion\n            var nextNumRoman\
    \ = convertRecursively(List(number), currentTotal)\n            // Return the\
    \ converted number and the remaining numeral list\n            return (nextNumRoman\
    \ + nextNum.toString)\n        }\n        // Return the result from the two methods\n\
    \        val result = convertLoop(number)\n        val expectedResult = miniRomanStrings.foldLeft(\"\
    \")((res, e) => res + e._1)\n        assert(result == expectedResult)\n      \
    \  \"\"\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmytac92d.scala:38:28\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m                    \e[33mreturn\e\
    [0m (currentTotal)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Found:    (currentTotal : Long)\n\
    \e[31m   |\e[0m                            Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpmytac92d.scala:45:26 -----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            numerals.head = numerals.tail.head\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val head\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpmytac92d.scala:46:25 ------------------------\e[0m\e\
    [0m\n\e[31m46 |\e[0m            currentTotal += nextNum\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not a member\
    \ of Long - did you mean currentTotal.!=?\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpmytac92d.scala:68:35 ------------------------\e[0m\e[0m\n\e[31m68 |\e\
    [0m            \e[33mreturn\e[0m (nextNumRoman + nextNum.toString)\n\e[31m\e[31m\
    \   |\e[0m                                   ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                Not found: nextNum\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanList = List(\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\")\n\
    \        val romanMapList = List((\"M\", 1000), (\"D\", 500), (\"C\", 100), (\"\
    L\", 50), (\"X\", 10), (\"V\", 5), (\"I\", 1))\n        val num = number.toInt\n\
    \        val intMap = (romanMapList.reverse zip romanMapList).toMap\n\n      \
    \  val romanStr = (romanList.filter { romanMapList.forall { case (roman, amt)\
    \ => num mod amt == 0 }}).reverse\n        val romanStrList = romanStr.filter\
    \ { romanStr => romanStr != \"I\"}\n        val numOfRomanStr = romanStrList.size\n\
    \        val intNum = num - numOfRomanStr\n        val intMapReverse = intMap.reverse\n\
    \        val intMapStr = (intMapReverse._2 zip intMapReverse._1).filter { case\
    \ (roman, amt) => numOfRomanStr mod amt == 0 }.reverse\n        val intMapStrList\
    \ = intMapStr.filter { intMapStr => intMapStr != \"I\"}\n        val intMapStrListSize\
    \ = (intMapStrList.length + 1)/2\n        val intMapStrListLength = intMapStrList.length\n\
    \        val intMapStrListOffset = intMapStrList.length - (intMapStrListSize -\
    \ 1)\n        val intMapStrListOffsetOffset = (intMapStrListOffset + intMapStrListOffset)/2\n\
    \        val intMapStrListOffsetLen = intMapStrListOffset - intMapStrListOffsetOffset\n\
    \        val intMapStrListLen = intMapStrListLength - intMapStrListOffsetLen\n\
    \        val intMapStrListLenLen = intMapStrListLen / 2\n        val intMapStrListLenLen\
    \ = intMapStrListLen - (intMapStrListLenLen-1)\n        val intMapStrListLenOffset\
    \ = intMapStrListLen - (intMapStrListLenLen-1)\n        val intMapStrListLenOffsetOffset\
    \ = intMapStrListLenOffset - intMapStrListLenLen\n        val intMapStrListLenOffsetLen\
    \ = intMapStrListLenOffset - intMapStrListLenOffsetOffset\n        val intMapStrListLenOffsetLenOffset\
    \ = intMapStrListLenOffsetLen - intMapStrListLenOffsetOffset\n        val intMapStrListLenOffsetLen\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsl5pz44u.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsl5pz44u.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintMapStrListLenLen\e[0m = intMapStrListLen - (intMapStrListLenLen-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintMapStrListLenLen is already defined as \e[33mvalue\e[0m\
    \ \e[35mintMapStrListLenLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpsl5pz44u.scala:20:90 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mromanStr\e[0m = (romanList.filter\
    \ { romanMapList.forall { \e[33mcase\e[0m (roman, amt) => num mod amt == \e[31m0\e\
    [0m }}).reverse\n\e[31m\e[31m   |\e[0m                                       \
    \                                               ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ mod is not a member of Int, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.int2bigInt\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsl5pz44u.scala:24:35 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mintMapReverse\e[0m = intMap.reverse\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue reverse is not a member of Map[(String, Int), (String, Int)] -\
    \ did you mean intMap.reversed?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsl5pz44u.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010779
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var nStr = \"\"\n        var i = number.toInt\n\n        // Convert i to\
    \ the corresponding Roman numeral\n        while (i>0)\n        {\n          \
    \  nStr = String.valueOf(i%10)+nStr\n            i = (i/10).toInt\n        }\n\
    \n        // Convert to lowercase\n        nStr.toLowerCase()\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3our8pbf.scala:29)\n\tat Problem.main(tmp3our8pbf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = mutable.ArrayBuffer(\"\",\"M\",\"CM\",\"D\",\"CD\",\"C\",\"\
    XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\")\n        val decimal = number\
    \ / 1000d\n        val num = number % 1000d\n        if (num == 0) roman(0)\n\
    \        else {\n            var n = (num / 100d).toInt\n            roman(n)\
    \ = roman(n-1) + \"H\"\n        }\n        roman(n+1).reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\"\
    )));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyu30lmsj.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mroman\e[0m = mutable.ArrayBuffer(\e\
    [31m\"\"\e[0m,\e[31m\"M\"\e[0m,\e[31m\"CM\"\e[0m,\e[31m\"D\"\e[0m,\e[31m\"CD\"\
    \e[0m,\e[31m\"C\"\e[0m,\e[31m\"XC\"\e[0m,\e[31m\"L\"\e[0m,\e[31m\"XL\"\e[0m,\e\
    [31m\"X\"\e[0m,\e[31m\"IX\"\e[0m,\e[31m\"V\"\e[0m,\e[31m\"IV\"\e[0m,\e[31m\"I\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010773
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val num = (number / (1000l)) % 100\n        val roman = num.toString.toList.map(num\
    \ => {\n            val mod10 = ((num / 10) % 10)\n            val mod5 = ((num\
    \ / 5) % 10)\n            val mod3 = ((num % 10))\n            val mod1 = ((num\
    \ % 5))\n            val mod2 = num % 10\n            val s = if (mod1 == 0) \"\
    i\" else if (mod1 == 1) \"v\" else if (mod1 == 2) \"x\" else \"\"\n          \
    \  val m = \"M\" * mod1\n            val t = \"C\" * mod2\n            val h =\
    \ \"H\" * mod3\n            val d = \"D\" * mod5\n            val c = \"C\" *\
    \ mod10\n            val ms = if (mod10 == 0) \"m\" else if (mod10 == 1) \"cm\"\
    \ else if (mod10 == 2) \"cd\" else if (mod10 == 3) \"dc\" else \"\"\n        \
    \    val ts = if (mod5 == 0) \"t\" else if (mod5 == 1) \"tc\" else if (mod5 ==\
    \ 2) \"cd\" else if (mod5 == 3) \"d\" else \"\"\n            val hs = if (mod3\
    \ == 0) \"h\" else if (mod3 == 1) \"ch\" else if (mod3 == 2) \"xc\" else if (mod3\
    \ == 3) \"x\" else \"\"\n            val ds = if (mod2 == 0) \"d\" else if (mod2\
    \ == 1) \"dh\" else if (mod2 == 2) \"dx\" else if (mod2 == 3) \"d\" else \"\"\n\
    \            s + m + t + h + d + c + ms + ts + hs\n        }).mkString(\"\")\n\
    \        return roman\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf85vmm6x.scala:37)\n\tat Problem.main(tmpf85vmm6x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var str = \"\"\n        var index = 0\n        var prev = 0\n        while(number\
    \ > 0){\n            val next = number / 1000\n            val remainder = number\
    \ % 1000\n            val temp = (prev*100) + (remainder)\n            prev =\
    \ temp\n            str = temp + str\n            number -= next\n        }\n\
    \        return str.toLowerCase\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgid497dy.scala:22:19\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            prev = temp\n\e[31m\e\
    [31m   |\e[0m                   ^^^^\e[0m\n\e[31m   |\e[0m                   Found:\
    \    (temp : Long)\n\e[31m   |\e[0m                   Required: Int\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgid497dy.scala:24:19 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            number -= next\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // initialize a mutable string builder\n        var builder = new StringBuilder();\n\
    \        // initialize a mutable string array \n        var roman =  Array(\"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\"\
    , \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"\
    XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\",\
    \ \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"\
    , \"L\", \"L\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpga58i4mn.scala:18:1225 ---------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36mroman\e[0m =  Array(\e[31m\"\
    I\"\e[0m, \e[31m\"II\"\e[0m, \e[31m\"III\"\e[0m, \e[31m\"IV\"\e[0m, \e[31m\"V\"\
    \e[0m, \e[31m\"VI\"\e[0m, \e[31m\"VII\"\e[0m, \e[31m\"VIII\"\e[0m, \e[31m\"IX\"\
    \e[0m, \e[31m\"X\"\e[0m, \e[31m\"XI\"\e[0m, \e[31m\"XII\"\e[0m, \e[31m\"XIII\"\
    \e[0m, \e[31m\"XIV\"\e[0m, \e[31m\"XV\"\e[0m, \e[31m\"XVI\"\e[0m, \e[31m\"XVII\"\
    \e[0m, \e[31m\"XVIII\"\e[0m, \e[31m\"XIX\"\e[0m, \e[31m\"XX\"\e[0m, \e[31m\"XXI\"\
    \e[0m, \e[31m\"XXII\"\e[0m, \e[31m\"XXIII\"\e[0m, \e[31m\"XXIV\"\e[0m, \e[31m\"\
    XXV\"\e[0m, \e[31m\"XXVI\"\e[0m, \e[31m\"XXVII\"\e[0m, \e[31m\"XXVIII\"\e[0m,\
    \ \e[31m\"XXIX\"\e[0m, \e[31m\"XXX\"\e[0m, \e[31m\"XXXI\"\e[0m, \e[31m\"XXXII\"\
    \e[0m, \e[31m\"XXXIII\"\e[0m, \e[31m\"XXXIV\"\e[0m, \e[31m\"XXXV\"\e[0m, \e[31m\"\
    XXXVI\"\e[0m, \e[31m\"XXXVII\"\e[0m, \e[31m\"XXXVIII\"\e[0m, \e[31m\"XXXIX\"\e\
    [0m, \e[31m\"XL\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"LI\"\e[0m, \e[31m\"L\"\e[0m,\
    \ \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"\
    L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e\
    [0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e\
    [31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"\
    L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e\
    [0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e\
    [31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"\
    L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e\
    [0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e\
    [31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"\
    L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e\
    [0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e\
    [31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"\
    L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e\
    [0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e\
    [31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"\
    L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e\
    [0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e\
    [31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"\
    L\"\e[0m, \e[31m\"L\"\e[0m, \e[31m\"L\"\e["
  stdout: ''
  timestamp: 1660010778
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var num = 0\n        var roman = \"\"\n\n        while (number > 0) {\n\
    \            val mod = number % 100\n            number /= 100\n            num\
    \ = num * 10 + mod\n        }\n\n        while (num > 0) {\n            val mod\
    \ = num % 10\n            num /= 10\n            roman = roman * mod + chars(mod)\n\
    \        }\n\n        return roman\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpts8dcwx4.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            number /= \e[31m100\e[0m\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not\
    \ a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpts8dcwx4.scala:21:18 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            num = num * \e[31m10\e[0m + mod\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  Found: \
    \   Long\n\e[31m   |\e[0m                  Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpts8dcwx4.scala:27:34 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            roman = roman * mod + chars(mod)\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                               Not found: chars\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val nums = scala.collection.mutable.ListBuffer.empty[String]\n        //\
    \ Iterate through each digit, adding it to a string in reverse, adding to a list\n\
    \        for (i <- number toString reverse collect { case '0' => \"M\"; case '1'\
    \ => \"D\"; case '2' => \"C\"; case '3' => \"L\"; case '4' => \"X\"; case '5'\
    \ => \"V\"; case '6' => \"I\"; case '7' => \"V\"; case '8' => \"X\"; case '9'\
    \ => \"I\" }) {\n            nums.append(i)\n        }\n        // Return string\n\
    \        nums.reverse.mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_fzg9ebf.scala:17:34 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mfor\e[0m (i <- number toString reverse\
    \ collect { \e[33mcase\e[0m \e[31m'0'\e[0m => \e[31m\"M\"\e[0m; \e[33mcase\e[0m\
    \ \e[31m'1'\e[0m => \e[31m\"D\"\e[0m; \e[33mcase\e[0m \e[31m'2'\e[0m => \e[31m\"\
    C\"\e[0m; \e[33mcase\e[0m \e[31m'3'\e[0m => \e[31m\"L\"\e[0m; \e[33mcase\e[0m\
    \ \e[31m'4'\e[0m => \e[31m\"X\"\e[0m; \e[33mcase\e[0m \e[31m'5'\e[0m => \e[31m\"\
    V\"\e[0m; \e[33mcase\e[0m \e[31m'6'\e[0m => \e[31m\"I\"\e[0m; \e[33mcase\e[0m\
    \ \e[31m'7'\e[0m => \e[31m\"V\"\e[0m; \e[33mcase\e[0m \e[31m'8'\e[0m => \e[31m\"\
    X\"\e[0m; \e[33mcase\e[0m \e[31m'9'\e[0m => \e[31m\"I\"\e[0m }) {\n\e[31m\e[31m\
    \   |\e[0m                                  ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                              Not found: reverse\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010776
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = mutable.ListBuffer[String]()\n        for {\n            i <-\
    \ 0 until number\n            count <- math.max(0, math.min(number - i, 12))\n\
    \        } roman.append(romanHead(i) + romanTail(count))\n        roman.foldLeft(\"\
    \")((acc, x) => acc + (x.toChar))\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpexi2uapc.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mroman\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpexi2uapc.scala:17:25 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            i <- \e[31m0\e[0m until number\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \              Found:    (number : Long)\n\e[31m   |\e[0m                    \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpexi2uapc.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            count <- math.max(\e\
    [31m0\e[0m, math.min(number - i, \e[31m12\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                   value foreach is not a member of Long\n3 errors found\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def intToRoman(number: Long): String = {\n            def romanToInt(string\
    \ : String) : Int = {\n                def romanToInt(string : String, i: Int)\
    \ : Int = {\n                    def romanToInt(string : String, i : Int, j :\
    \ Int) : Int = {\n                        if (i >= j) i\n                    \
    \    else romanToInt(string, i+1, j)\n                    }\n                \
    \    if (i == 1) {\n                        i.toInt\n                    } else\
    \ romanToInt(string, 1, 1)\n                }\n                if (string.length\
    \ < 1) 1\n                else {\n                    romanToInt(string, string.length-1,\
    \ 0)\n                }\n            }\n            var roman = \"\"\n       \
    \     while (number > 0) {\n                val digit = number % 100\n       \
    \         roman ++= digitToRoman(digit)\n                number /= 100\n     \
    \       }\n            roman\n        }\n        def digitToRoman(digit: Int):\
    \ String = {\n            if (digit == 0) \"\"\n            else {\n         \
    \       if (digit == 1) \"m\" //singular\n                else if (digit == 2)\
    \ \"cm\" //dual\n                else if (digit == 3) \"dam\" //tridual\n    \
    \            else if (digit == 4) \"x\" //quinary\n                else if (digit\
    \ == 5) \"xx\" //sex\n                else if (digit == 6) \"l\" //double\n  \
    \              else if (digit == 7) \"c\" //triple\n                else if (digit\
    \ == 8) \"dc\" //quint\n                else if (digit == 9) \"cm\" //septic\n\
    \                else \"\"\n            }\n        }\n        var roman = intToRoman(number)\n\
    \        roman = roman.substring(0,roman.length-1)\n        return roman\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpa5xl382e.scala:28:56 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    romanToInt(string, string.length-\e\
    [31m1\e[0m, \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                             \
    \                           ^\e[0m\n\e[31m   |\e[0m too many arguments for \e\
    [33mmethod\e[0m \e[35mromanToInt\e[0m: (string: String, i: Int): Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpa5xl382e.scala:34:22 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                roman ++= digitToRoman(digit)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ ++= is not a member of String\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa5xl382e.scala:34:39\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m                roman ++= digitToRoman(digit)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                       Found:    (digit : Long)\n\e\
    [31m   |\e[0m                                       Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa5xl382e.scala:35:23 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                number /= \e[31m100\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value /=\
    \ is not a member of Long - did you mean number.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var roman = \"\"\n        val numToRoman = (100d -> \"M\", \n          \
    \              1000d -> \"D\", \n                        10000d -> \"C\", \n \
    \                       100000d -> \"L\", \n                        1000000d ->\
    \ \"X\", \n                        1000000000d -> \"V\", \n                  \
    \      100000000000d -> \"I\")\n        while(number > 0) {\n            roman\
    \ += numToRoman(number % 10)\n            number /= 10\n        }\n        roman\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkp_8naey.scala:24:18 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            roman += numToRoman(number % \e[31m10\e[0m)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpkp_8naey.scala:24:32 --------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            roman += numToRoman(number % \e[31m10\e[0m)\n\e\
    [31m\e[31m   |\e[0m                                ^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                Found:    Long\n\e[31m   |\e[0m      \
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpkp_8naey.scala:25:19 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m            number /= \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean number.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010782
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val arr : Array[String] = number match {\n            case n if n < 1000000\
    \ -> {\n                val roman = n.toString.toCharArray.map(c => \n       \
    \             if (c.toInt < 58) c.toString else c.toString + \"m\")\n        \
    \        roman.map(c => c + \"c\").mkString(\"\")\n            }\n           \
    \ case n if n < 1000000000 -> {\n                val roman = n.toString.toCharArray.map(c\
    \ => \n                    if (c.toInt < 58) c.toString else c.toString + \"m\"\
    )\n                roman.map(c => c + \"c\").mkString(\"\")\n            }\n \
    \           case n if n < 1000000000000 -> {\n                val roman = n.toString.toCharArray.map(c\
    \ => \n                    if (c.toInt < 58) c.toString else c.toString + \"m\"\
    )\n                roman.map(c => c + \"c\").mkString(\"\")\n            }\n \
    \           case n if n < 1000000000000000 -> {\n                val roman = n.toString.toCharArray.map(c\
    \ => \n                    if (c.toInt < 58) c.toString else c.toString + \"m\"\
    )\n                roman.map(c => c + \"c\").mkString(\"\")\n            }\n \
    \           case n if n < 1000000000000000000 -> {\n                val roman\
    \ = n.toString.toCharArray.map(c => \n                    if (c.toInt < 58) c.toString\
    \ else c.toString + \"m\")\n                roman.map(c => c + \"c\").mkString(\"\
    \")\n            }\n            case n if n < 1000000000000000000000 -> {\n  \
    \              val roman = n.toString.toCharArray.map(c => \n                \
    \    if (c.toInt < 58) c.toString else c.toString + \"m\")\n                roman.map(c\
    \ => c + \"c\").mkString(\"\")\n            }\n            case n if n < 100000000000000000000000\
    \ -> {\n                val roman = n.toString.toCharArray.map(c => \n       \
    \             if (c.toInt < 58) c.toString else c.toString + \"m\")\n        \
    \        roman.map(c => c + \"c\").mkString(\"\")\n            }\n           \
    \ case n if n < 1000000000000000000000000 -> {\n                val roman = n.toString.toCharArray.map(c\
    \ => \n                    if (c.toInt < 58) c.toString else c.toString + \"m\"\
    )\n                roman.map(c => c + \"c\").mkString(\"\")\n            }\n \
    \           case n if n < 1000000000000000000000000000 -> {\n                val\
    \ roman = n.toString.toChar\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplg63zeuh.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mcase\e[0m n \e[33mif\e[0m n < \e[31m1000000000\e\
    [0m -> {\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m        \
    \    '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplg63zeuh.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mcase\e\
    [0m n \e[33mif\e[0m n < \e[31m1000000000000000\e[0m -> {\n\e[31m\e[31m   |\e[0m\
    \            ^^^^\e[0m\n\e[31m   |\e[0m            '=>' expected, but 'case' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplg63zeuh.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mcase\e[0m n \e[33mif\e[0m n < \e[31m1000000000000000000000\e\
    [0m -> {\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m        \
    \    '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplg63zeuh.scala:51:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m51 |\e[0m            \e[33mcase\e\
    [0m n \e[33mif\e[0m n < \e[31m1000000000000000000000000\e[0m -> {\n\e[31m\e[31m\
    \   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            '=>' expected, but\
    \ 'case' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplg63zeuh.scala:59:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m59 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    '=>' expected, but 'def' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplg63zeuh.scala:77:0 ----------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmplg63zeuh.scala:16:24\
    \ -----------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mcase\e\
    [0m n \e[33mif\e[0m n < \e[31m1000000\e[0m -> {\n\e[31m\e[31m   |\e[0m       \
    \               ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35m<\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e\
    [31m   |\e[0m (x: Long): Boolean\n\e[31m "
  stdout: ''
  timestamp: 1660010783
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanValues = List(\n            new LongList(\"M\", 1000),\n      \
    \      new LongList(\"CM\", 900),\n            new LongList(\"D\", 500),\n   \
    \         new LongList(\"CD\", 400),\n            new LongList(\"C\", 100),\n\
    \            new LongList(\"XC\", 90),\n            new LongList(\"L\", 50),\n\
    \            new LongList(\"XL\", 40),\n            new LongList(\"X\", 10),\n\
    \            new LongList(\"IX\", 9),\n            new LongList(\"V\", 5),\n \
    \           new LongList(\"IV\", 4),\n            new LongList(\"I\", 1)\n   \
    \     )\n        val remainder = number % 1000\n        val quotient = number\
    \ / 1000\n        for (value <- romanValues) {\n            if (value.first ==\
    \ quotient) {\n                return value.last + intToMiniRoman(remainder)\n\
    \            } else if (value.first > quotient && remainder >= value.last) {\n\
    \                return value.first + intToMiniRoman(remainder)\n            }\n\
    \        }\n        throw new IllegalArgumentException(s\"Unknown integer $number\"\
    )\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzsrunt94.scala:16:16 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mnew\e[0m \e[35mLongList\e[0m(\e[31m\"\
    M\"\e[0m, \e[31m1000\e[0m),\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Not found: type LongList\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzsrunt94.scala:17:16 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mnew\e[0m \e[35mLongList\e[0m(\e[31m\"\
    CM\"\e[0m, \e[31m900\e[0m),\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Not found: type LongList\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzsrunt94.scala:18:16 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mnew\e[0m \e[35mLongList\e[0m(\e[31m\"\
    D\"\e[0m, \e[31m500\e[0m),\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Not found: type LongList\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzsrunt94.scala:19:16 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mnew\e[0m \e[35mLongList\e[0m(\e[31m\"\
    CD\"\e[0m, \e[31m400\e[0m),\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Not found: type LongList\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzsrunt94.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mnew\e[0m \e[35mLongList\e[0m(\e[31m\"\
    C\"\e[0m, \e[31m100\e[0m),\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Not found: type LongList\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzsrunt94.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mnew\e[0m \e[35mLongList\e[0m(\e[31m\"\
    XC\"\e[0m, \e[31m90\e[0"
  stdout: ''
  timestamp: 1660010784
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     // First, get the largest numeral and count of digits.\n        val largest\
    \ = math.pow(10, number.toInt)\n        val digits = number % largest\n      \
    \  val numberOfDigits = digits.toInt\n\n        // Second, find the largest integer\
    \ less than or equal to 'largest' that has 'numberOfDigits' digits\n        val\
    \ largestInRange = largest / numberOfDigits\n        val nextLargest = largestInRange\
    \ * numberOfDigits\n        val nextLargestInRange = nextLargest / numberOfDigits\n\
    \        val nextNextLargest = nextLargestInRange * numberOfDigits\n\n       \
    \ // Third, find the first integer greater than or equal to 'largest' that is\
    \ smaller than or equal to 'nextNextLargest'\n        val nextLargestInRangeInRange\
    \ = nextNextLargest / numberOfDigits\n        val firstLargestInRange = nextLargestInRangeInRange\
    \ * numberOfDigits\n\n        // Fourth, find the corresponding numerals for the\
    \ first integer\n        val numerals = (0 until firstLargestInRange).map(i =>\
    \ if (i == 0) \"M\" else if (i == 1) \"D\" else \"C\")\n\n        // Fifth, append\
    \ the string to the numerals string\n        numerals.reverse.mkString + numerals.head\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp40ssxtia.scala:31:32\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mnumerals\e\
    [0m = (\e[31m0\e[0m until firstLargestInRange).map(\e[36mi\e[0m => \e[33mif\e\
    [0m (i == \e[31m0\e[0m) \e[31m\"M\"\e[0m \e[33melse\e[0m \e[33mif\e[0m (i == \e\
    [31m1\e[0m) \e[31m\"D\"\e[0m \e[33melse\e[0m \e[31m\"C\"\e[0m)\n\e[31m\e[31m \
    \  |\e[0m                                ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                Found:    (firstLargestInRange : Double)\n\e\
    [31m   |\e[0m                                Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010783
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if(number < 1l) throw new IllegalArgumentException(\"number must be positive\"\
    )\n        if(number > 1000) throw new IllegalArgumentException(\"number too large\"\
    )\n        def romanDigit(d: Long): String = {\n            if(d == 999l) 999\n\
    \            if(d == 99l) c\n            if(d == 9l) \"x\"\n            else if(d\
    \ == 9000l) c\n            else {\n                if(d == 8l) l\n           \
    \     else if(d == 800l) c\n                else if(d == 80l) l\n            \
    \    else if(d == 7l) i\n                else if(d == 70l) i\n               \
    \ else if(d == 6l) i\n                else if(d == 600l) i\n                else\
    \ if(d == 5l) i\n                else if(d == 500l) i\n                else if(d\
    \ == 4l) i\n                else if(d == 400l) i\n                else if(d ==\
    \ 3l) i\n                else if(d == 300l) i\n                else if(d == 2l)\
    \ i\n                else if(d == 20l) i\n                else if(d == 10l) i\n\
    \                else if(d == 1l) i\n                else if(d == 100l) i\n  \
    \              else if(d == .1d) i\n                else if(d == .10d) i\n   \
    \             else if(d == .05d) i\n                else if(d == .01d) i\n   \
    \             else c\n            }\n        }\n        def romanDigits(d: Long):\
    \ String = {\n            if(d == 999l) 999\n            if(d == 99l) c\n    \
    \        if(d == 9l) \"x\"\n            else if(d == 9000l) c\n            else\
    \ {\n                if(d == 8l) l\n                else if(d == 800l) c\n   \
    \             else if(d == 80l) l\n                else if(d == 7l) i\n      \
    \          else if(d == 70l) i\n                else if(d == 6l) i\n         \
    \       else if(d == 600l) i\n                else if(d == 5l) i\n           \
    \     else if(d == 500l) i\n                else if(d == 4l) i\n             \
    \   else if(d == 400l) i\n                else if(d == 3l) i\n               \
    \ else if(d == 300l) i\n                else if(d == 2l) i\n                else\
    \ if(d == 20l) i\n                else if(d == 10l) i\n                else if(d\
    \ == 1l) i\n                else if(d == 100l) i\n                else if(d ==\
    \ .1d) i\n                else if(d == .10d) i\n                else if(d == .05d)\
    \ i\n                else if(d == .01d) i\n                else c\n          \
    \  }\n        }\n        val r = scala.collection.mutable.ListBuffer.empty[String]\n\
    \        while(number > 0l) {\n            val newDigit = number \n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx5_p06vj.scala:101:0 ---------------------------\e\
    [0m\e[0m\n\e[31m101 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx5_p06vj.scala:19:25\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m(d\
    \ == \e[31m99l\e[0m) c\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\
    \e[31m   |\e[0m                         Not found: c\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpx5_p06vj.scala:21:32 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m(d == \e[31m9000l\e\
    [0m) c\n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m  \
    \ |\e[0m                                Not found: c\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpx5_p06vj.scala:23:28 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mif\e[0m(d == \e[31m8l\e[0m) l\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       Not found: l\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpx5_p06vj.scala:24:35 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m(d == \e[31m800l\e\
    [0m) c\n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m\
    \   |\e[0m                                   Not found: c\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpx5_p06vj.scala:25:34 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m(d == \e\
    [31m80l\e[0m) l\n\e[31m\e[31m   |\e[0m                                  ^\e[0m\n\
    \e[31m   |\e[0m                                  Not found: l\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Foun"
  stdout: ''
  timestamp: 1660010784
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val result = new mutable.ListBuffer[String]()\n        var remainder = number\n\
    \        var power = 0\n        while(number > 0) {\n            var digit = remainder\
    \ % 10\n            remainder = remainder / 10\n            power = power + 1\n\
    \            number -= digit\n            number -= 1\n            if(digit ==\
    \ 0) {\n                result += (power + \"\").reverse\n                power\
    \ = 0\n            }\n        }\n        result.toList.reverse.mkString(\"M\"\
    )\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7x09xm_f.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7x09xm_f.scala:22:19\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            number -= digit\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ -= is not a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp7x09xm_f.scala:23:19 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010784
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numerals = number.toInt/1000 % 10 +\n            (number.toInt/1000\
    \ - numerals).toString.reverse +\n            number.toInt%1000\n        val romans\
    \ = mutable.ArrayBuffer.empty[String]\n        val romanNums = mutable.ArrayBuffer.empty[String]\n\
    \n        // Iterate over each roman numeral. Find the correct roman numeral\n\
    \        // using integer division and remainder.\n        // Then store the roman\
    \ numeral and the integer value for each one\n        // as tuples in a list.\n\
    \        for (i <- 0 until numerals) {\n            romanNums += (numerals % 10).toString.reverse\
    \ +\n                (numerals / 10).toString.reverse +\n                (romans\
    \ ++ romanNums).toList\n            romans = romans +\n                ((numerals\
    \ % 10).toString.reverse +\n                (numerals / 10).toString.reverse +\n\
    \                (romans ++ romanNums).toList)\n            numerals /= 10\n \
    \       }\n        romanNums\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpigfzy1qu.scala:16:33 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            (number.toInt/\e[31m1000\e[0m - numerals).toString.reverse\
    \ +\n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e\
    [0m                                 Recursive \e[33mvalue\e[0m \e[35mnumerals\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpigfzy1qu.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mromans\e[0m = mutable.ArrayBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m \
    \  |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpigfzy1qu.scala:19:24\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mromanNums\e[0m = mutable.ArrayBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpigfzy1qu.scala:29:19 -----------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m            romans = romans +\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\
    \e[31m   |\e[0m            Reassignment to val romans\n\e[31m30 |\e[0m       \
    \         ((numerals % \e[31m10\e[0m).toString.reverse +\n\e[31m31 |\e[0m    \
    \            (numerals / \e[31m10\e[0m).toString.reverse +\n\e[31m32 |\e[0m  \
    \              (romans ++ romanNums).toList)\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     def toRoman (n       : Int) : String  = {\n            val remainder = n\
    \ % 10\n            val digit     = n % 100\n            val suffix    = \"M\"\
    \n            val first     = (remainder % 100) == 0 ? \"C\" : \n            \
    \                    (remainder % 10) == 0 ? \"L\" : \"D\"\n            (if (digit\
    \ <= 4) \n                digit.toString + \"M\"\n            else if (digit ==\
    \ 0) \n                first.toString + suffix\n            else toRoman(digit\
    \ / 10) + first + suffix)\n        }\n\n        if (number < 0 || number > 999)\n\
    \            return \"\"\n        else if (number == 0) \n            return \"\
    0\"\n        else if (number < 10)\n            return number.toString\n     \
    \   else\n            return toRoman(number).toLowerCase()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n \
    \   assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpiloechju.scala:20:60 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                                (remainder % \e[31m10\e\
    [0m) == \e[31m0\e[0m ? \e[31m\"L\"\e[0m : \e[31m\"D\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                                                            ^\e[0m\n\e[31m\
    \   |\e[0m                                 end of statement expected but ':' found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiloechju.scala:20:49 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                                (remainder % \e[31m10\e\
    [0m) == \e[31m0\e[0m ? \e[31m\"L\"\e[0m : \e[31m\"D\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                                                 ^^\e[0m\n\e[31m   |\e[0m \
    \                                                Not found: type ==\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiloechju.scala:19:51 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mfirst\e[0m     = (remainder\
    \ % \e[31m100\e[0m) == \e[31m0\e[0m ? \e[31m\"C\"\e[0m : \n\e[31m\e[31m   |\e\
    [0m                                                 ^^^\e[0m\n\e[31m   |\e[0m\
    \                                          value ? is not a member of Int\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiloechju.scala:35:27 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mreturn\e[0m toRoman(number).toLowerCase()\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                          Found:    (number : Long)\n\e[31m   |\e[0m        \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010785
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     if (number == 0)\n            number\n        else {\n            var i\
    \ = 0\n            var list = new scala.collection.mutable.ListBuffer[String]()\n\
    \            while (i <= number) {\n                val remainder = number % 1000\n\
    \                list += ((remainder / 100) match {\n                    case\
    \ 0 => \"m\"\n                    case 1 => \"b\"\n                    case _\
    \ => \"x\"\n                })\n                number -= remainder\n        \
    \        i += 1\n            }\n            list.toList.reverse.foldLeft(\"\"\
    )((acc, x) => acc + x)\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpukgewkza.scala:16:12\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m            number\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (number\
    \ : Long)\n\e[31m   |\e[0m            Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpukgewkza.scala:27:23 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                number -= remainder\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -= is not\
    \ a member of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010786
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman =\n            (number toString 'm' filter (_ == '1')) +\n   \
    \         (number toString 'm' filter (_ == '3')) +\n            (number toString\
    \ 'm' filter (_ == '5')) +\n            (number toString 'm' filter (_ == '7'))\
    \ +\n            (number toString 'm' filter (_ == '9')) +\n            (number\
    \ toString 'm' filter (_ == '11')) +\n            (number toString 'm' filter\
    \ (_ == '13')) +\n            (number toString 'm' filter (_ == '15')) +\n   \
    \         (number toString 'm' filter (_ == '17')) +\n            (number toString\
    \ 'm' filter (_ == '19')) +\n            (number toString 'm' filter (_ == '21'))\
    \ +\n            (number toString 'm' filter (_ == '23')) +\n            (number\
    \ toString 'm' filter (_ == '25')) +\n            (number toString 'm' filter\
    \ (_ == '27')) +\n            (number toString 'm' filter (_ == '29')) +\n   \
    \         (number toString 'm' filter (_ == '31')) +\n            (number toString\
    \ 'm' filter (_ == '33')) +\n            (number toString 'm' filter (_ == '35'))\
    \ +\n            (number toString 'm' filter (_ == '37')) +\n            (number\
    \ toString 'm' filter (_ == '39')) +\n            (number toString 'm' filter\
    \ (_ == '41')) +\n            (number toString 'm' filter (_ == '43')) +\n   \
    \         (number toString 'm' filter (_ == '45')) +\n            (number toString\
    \ 'm' filter (_ == '47')) +\n            (number toString 'm' filter (_ == '49'))\
    \ +\n            (number toString 'm' filter (_ == '51')) +\n            (number\
    \ toString 'm' filter (_ == '53')) +\n            (number toString 'm' filter\
    \ (_ == '55')) +\n            (number toString 'm' filter (_ == '57')) +\n   \
    \         (number toString 'm' filter (_ == '59')) +\n            (number toString\
    \ 'm' filter (_ == '61')) +\n            (number toString 'm' filter (_ == '63'))\
    \ +\n            (number toString 'm' filter (_ == '65')) +\n            (number\
    \ toString 'm' filter (_ == '67')\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqccwt3oj.scala:21:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            (number toString \e[31m'm'\e[0m filter (_\
    \ == '1\e[31m1\e[0m')) +\n\e[31m\e[31m   |\e[0m                              \
    \                ^\e[0m\n\e[31m   |\e[0m                                     \
    \         unclosed character literal\n\e[31m\e[31m-- Error: /tmp/tmpqccwt3oj.scala:21:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m21 |\e[0m       \
    \     (number toString \e[31m'm'\e[0m filter (_ == '1\e[31m1\e[0m')) +\n\e[31m\e\
    [31m   |\e[0m                                                 ^\e[0m\n\e[31m \
    \  |\e[0m                                              unclosed character literal\n\
    \e[31m\e[31m-- Error: /tmp/tmpqccwt3oj.scala:22:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            (number toString \e[31m'm'\e[0m filter (_\
    \ == '1\e[31m3\e[0m')) +\n\e[31m\e[31m   |\e[0m                              \
    \                ^\e[0m\n\e[31m   |\e[0m                                     \
    \         unclosed character literal\n\e[31m\e[31m-- Error: /tmp/tmpqccwt3oj.scala:22:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \     (number toString \e[31m'm'\e[0m filter (_ == '1\e[31m3\e[0m')) +\n\e[31m\e\
    [31m   |\e[0m                                                 ^\e[0m\n\e[31m \
    \  |\e[0m                                              unclosed character literal\n\
    \e[31m\e[31m-- Error: /tmp/tmpqccwt3oj.scala:23:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            (number toString \e[31m'm'\e[0m filter (_\
    \ == '1\e[31m5\e[0m')) +\n\e[31m\e[31m   |\e[0m                              \
    \                ^\e[0m\n\e[31m   |\e[0m                                     \
    \         unclosed character literal\n\e[31m\e[31m-- Error: /tmp/tmpqccwt3oj.scala:23:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \     (number toString \e[31m'm'\e[0m filter (_ == '1\e[31m5\e[0m')) +\n\e[31m\e\
    [31m   |\e[0m                                                 ^\e[0m\n\e[31m \
    \  |\e[0m                                              unclosed character l"
  stdout: ''
  timestamp: 1660010785
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val numberString = number.toString\n        val reversed = ListBuffer(numberString.reverse)\n\
    \        var result = \"error\"\n\n        for (index <- 0 until reversed.size)\
    \ {\n            val numeral = reversed(index).toInt\n            val miniRoman\
    \ = if(numeral >= 1000) {\n                val miniRomanString = numeral / 1000;\n\
    \                val miniRomanStringReversed = ListBuffer(miniRomanString.reverse)\n\
    \                val numRest = numeral % 1000;\n                val rest = ListBuffer(numRest)\n\
    \                for(numRestLength <- 0 until rest.size) {\n                 \
    \   val restStr = rest(numRestLength).toString\n                    val restStringReversed\
    \ = ListBuffer(restStr.reverse)\n                    miniRomanStringReversed :::\
    \ restStringReversed\n                }\n                miniRomanString ::: rest\n\
    \            } else {\n                val roman = numeral.toString\n        \
    \        roman\n            }\n            val miniRomanStringReversed = ListBuffer(miniRoman.reverse)\n\
    \            result ::: miniRomanStringReversed\n        }\n        result\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphvb8qe8q.scala:23:73 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mval\e[0m \e[36mminiRomanStringReversed\e\
    [0m = ListBuffer(miniRomanString.reverse)\n\e[31m\e[31m   |\e[0m             \
    \                                            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                    value reverse is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphvb8qe8q.scala:29:44\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                    miniRomanStringReversed\
    \ ::: restStringReversed\n\e[31m\e[31m   |\e[0m                              \
    \              ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue ::: is not a\
    \ member of scala.collection.mutable.ListBuffer[String] - did you mean restStringReversed.++:?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphvb8qe8q.scala:31:32 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                miniRomanString ::: rest\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ ::: is not a member of scala.collection.mutable.ListBuffer[Int] - did you mean\
    \ rest.++:?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphvb8qe8q.scala:37:19\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            result ::: miniRomanStringReversed\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue ::: is not a member of scala.collection.mutable.ListBuffer[Nothing]\
    \ - did you mean miniRomanStringReversed.++:?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010787
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = scala.collection.mutable.ArrayBuffer.empty[String]\n       \
    \ val intToRoman = roman.add(\"\")\n        def intToRoman(n: Long, nAccum :String)\
    \ : String = {\n            if (n < 0) intToRoman(-n, nAccum)\n            else\
    \ if (n < 10) return intToRoman(n, nAccum)\n            else if (n % 10 == 0)\
    \ intToRoman(n / 10, nAccum+RomanNumerals(n % 10).toChar)\n            else intToRoman((n\
    \ / 10) % 10, nAccum+RomanNumerals(n % 10).toChar)\n        }\n        number\
    \ match {\n            case n if n > 1000 && n < 10000 => intToRoman(n, \"i\"\
    )\n            case n if n > 10000 && n < 1000000 => intToRoman(n, \"ii\")\n \
    \           case n if n > 1000000 && n < 1000000000 => intToRoman(n, \"iii\")\n\
    \            case n if n > 1000000000 && n < 10000000000 => intToRoman(n, \"iv\"\
    )\n            case n if n > 10000000000 && n < 1000000000000 => intToRoman(n,\
    \ \"v\")\n            case n if n > 1000000000000 && n < 100000000000000 => intToRoman(n,\
    \ \"vi\")\n            case n if n > 100000000000000 && n < 100000000000000000\
    \ => intToRoman(n, \"vii\")\n            case n if n > 100000000000000000 && n\
    \ < 100000000000000000 => intToRoman(n, \"viii\")\n            case n if n > 100000000000000000\
    \ && n < 100000000000000000 => intToRoman(n, \"ix\")\n            case n if n\
    \ > 100000000000000000 && n < 100000000000000000 => intToRoman(n, \"x\")\n   \
    \         case n if n > 100000000000000000 && n < 100000000000000000 => intToRoman(n,\
    \ \"xii\")\n            case n if n > 100000000000000000 && n < 100000000000000000\
    \ => intToRoman(n, \"xiii\")\n            case n if n > 100000000000000000 &&\
    \ n < 100000000000000000 => intToRoman(n, \"xiv\")\n            case n if n >\
    \ 100000000000000000 && n < 100000000000000000 => intToRoman(n, \"xx\")\n    \
    \        case n if n > 100000000000000000 && n < 100000000000000000 => intToRoman(n,\
    \ \"xxi\")\n            case n if n > 100000000000000000 && n < 100000000000000000\
    \ => intToRoman(n, \"xxii\")\n            case n if n > 100000000000000000 &&\
    \ n < 100000000000000000 => int\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxahhsp2l.scala:60:0 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxahhsp2l.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mdef\e[0m\
    \ \e[36mintToRoman\e[0m(\e[36mn\e[0m: \e[35mLong\e[0m, \e[36mnAccum\e[0m :\e[35mString\e\
    [0m) : \e[35mString\e[0m = {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e\
    [0mintToRoman is already defined as \e[33mvalue\e[0m \e[35mintToRoman\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m18 |\e[0m            \e[33mif\e\
    [0m (n < \e[31m0\e[0m) intToRoman(-n, nAccum)\n\e[31m19 |\e[0m            \e[33melse\e\
    [0m \e[33mif\e[0m (n < \e[31m10\e[0m) \e[33mreturn\e[0m intToRoman(n, nAccum)\n\
    \e[31m20 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m (n % \e[31m10\e[0m ==\
    \ \e[31m0\e[0m) intToRoman(n / \e[31m10\e[0m, nAccum+RomanNumerals(n % \e[31m10\e\
    [0m).toChar)\n\e[31m21 |\e[0m            \e[33melse\e[0m intToRoman((n / \e[31m10\e\
    [0m) % \e[31m10\e[0m, nAccum+RomanNumerals(n % \e[31m10\e[0m).toChar)\n\e[31m22\
    \ |\e[0m        }\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxahhsp2l.scala:16:31\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mintToRoman\e[0m = roman.add(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue add is not a member of\
    \ scala.collection.mutable.ArrayBuffer[String]\n\e[31m\e[31m-- Error: /tmp/tmpxahhsp2l.scala:27:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \     \e[33mcase\e[0m n \e[33mif\e[0m n > \e[31m1000000000\e[0m && n < \e[31m10000000000\e\
    [0m => intToRoman(n, \e[31m\"iv\"\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \                             ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                              number too large\n\e[31m\e[31m-- Error: /tmp/tmpxahhsp2l.scala:28:26\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \     \e[33mcase\e[0m n \e[33mif\e[0m n > \e[31m10000000000\e[0m && n < \e[31m10000000000"
  stdout: ''
  timestamp: 1660010787
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanMap: Map[Long, String] = Map(\n            1->\"i\",\n        \
    \    2->\"ii\",\n            3->\"iii\",\n            5->\"v\",\n            6->\"\
    vi\",\n            8->\"vii\",\n            9->\"ix\",\n            10->\"x\"\
    ,\n            12->\"xii\",\n            14->\"xiii\",\n            16->\"xiv\"\
    ,\n            17->\"xvi\",\n            20->\"xx\"\n        )\n        val numberInRoman\
    \ = romanMap.get(number).orElse(throw new RuntimeException(\"Invalid number \"\
    \ + number))\n        numberInRoman.toLowerCase\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbcmzm5n2.scala:16:12\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[31m1\e[0m->\e\
    [31m\"i\"\e[0m,\n\e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            Found:    (\e[1m\e[31mInt\e[0m, String)\n\e[31m   |\e[0m        \
    \    Required: (\e[1m\e[32mLong\e[0m, String)\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpbcmzm5n2.scala:17:12 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[31m2\e[0m->\e[31m\"ii\"\e[0m,\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (\e\
    [1m\e[31mInt\e[0m, String)\n\e[31m   |\e[0m            Required: (\e[1m\e[32mLong\e\
    [0m, String)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbcmzm5n2.scala:18:12\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[31m3\e[0m->\e\
    [31m\"iii\"\e[0m,\n\e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Found:    (\e[1m\e[31mInt\e[0m, String)\n\e[31m   |\e[0m      \
    \      Required: (\e[1m\e[32mLong\e[0m, String)\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpbcmzm5n2.scala:19:12 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[31m5\e[0m->\e[31m\"v\"\e[0m,\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (\e\
    [1m\e[31mInt\e[0m, String)\n\e[31m   |\e[0m            Required: (\e[1m\e[32mLong\e\
    [0m, String)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbcmzm5n2.scala:20:12\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            \e[31m6\e[0m->\e\
    [31m\"vi\"\e[0m,\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Found:    (\e[1m\e[31mInt\e[0m, String)\n\e[31m   |\e[0m      \
    \      Required: (\e[1m\e[32mLong\e[0m, String)\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] "
  stdout: ''
  timestamp: 1660010789
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = scala.collection.mutable.ListBuffer.empty[String]\n        var\
    \ index = 0\n        while (index < number) {\n            roman += scala.math.pow(1000,\
    \ index).toString.toLowerCase\n            index += 1\n        }\n        roman.head\
    \ + (roman.drop(1).reverse.toSeq: _*)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmps70y3zgw.scala:21:51 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        roman.head + (roman.drop(\e[31m1\e[0m).reverse.toSeq:\
    \ \e[35m_*\e[0m)\n\e[31m\e[31m   |\e[0m                                      \
    \             ^\e[0m\n\e[31m   |\e[0m          `_*` can be used only for last\
    \ argument of method application.\n\e[31m   |\e[0m          It is no longer allowed\
    \ in operands of infix operations.\n1 error found\n"
  stdout: ''
  timestamp: 1660010786
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = (1l to 1000l).filter(_ >= number).toList\n        val res =\
    \ roman.map {\n            case (_, i) => if (number >= i) s\"${number} ${roman.indexOf(_)}\"\
    \ else s\"${roman.indexOf(_)}\"\n        }.mkString(\"\").toLower\n        return\
    \ res\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpxno5uk5x.scala:17:38 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m (_, i) => \e[33mif\e[0m (number\
    \ >= i) \e[31ms\"\e[0m${number}\e[31m \e[0m${roman.indexOf(_)}\e[31m\"\e[0m \e\
    [33melse\e[0m \e[31ms\"\e[0m${roman.indexOf(_)}\e[31m\"\e[0m\n\e[31m\e[31m   |\e\
    [0m                               ^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m>=\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float):\
    \ Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\
    \e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m\
    \   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments ((i : Any))\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010786
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val roman = mutable.Buffer.empty[Char]\n        val base = 1000\n      \
    \  while (number > 0) {\n            val value = number % base\n            roman.append(value)\n\
    \            number /= base\n        }\n        roman.foldLeft(\"\")(_ + _ + _)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjikvheh3.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mroman\e[0m = mutable.Buffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpjikvheh3.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            number /= base\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value /= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \   var s = \"\"\n      while (number > 0) {\n        if (number % 1000 > 999)\
    \ {\n          if (number % 1000 < 500) {\n            s += miniRoman(number/1000)\
    \ + \"k\"\n            number %= 1000\n          } else {\n            s += miniRoman(number/100)\
    \ + \"m\"\n            number %= 1000\n          }\n        } else {\n       \
    \   s += miniRoman(number/1000) + \"\"\n          number %= 1000\n        }\n\
    \      }\n      s\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgesj6kq7.scala:19:14 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            s += miniRoman(number/\e[31m1000\e[0m) +\
    \ \e[31m\"k\"\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m\
    \            value += is not a member of String - did you mean String.!=?\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpgesj6kq7.scala:19:17 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            s += miniRoman(number/\e[31m1000\e[0m) +\
    \ \e[31m\"k\"\e[0m\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                 Not found: miniRoman\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpgesj6kq7.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            number %= \e[31m1000\e[0m\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value %= is not\
    \ a member of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpgesj6kq7.scala:22:14 ------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m            s += miniRoman(number/\e[31m100\e[0m) + \e[31m\"m\"\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpgesj6kq7.scala:22:17 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m            s += miniRoman(number/\e[31m100\e[0m) + \e[31m\"m\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                Not found: miniRoman\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpgesj6kq7.scala:23:19 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            number %= \e[31m1000\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value %= is not a member\
    \ of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgesj6kq7.scala:26:12\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m          s += miniRoman(number/\e\
    [31m1000\e[0m) + \e[31m\"\""
  stdout: ''
  timestamp: 1660010789
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \   val numMap = Map(\"M\" -> 1000l, \"D\" -> 500l, \"C\" -> 100l, \"L\" -> 50l,\
    \ \"X\" -> 10l, \"V\" -> 5l, \"I\" -> 1l)\n      var outStr = \"\"\n      var\
    \ cur = number\n      while(cur > 0) {\n        val numStr = numMap.get(cur.floor).toString\n\
    \        outStr += numStr.dropRight(1)\n        cur = cur - numStr.last\n    \
    \  }\n      outStr\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7wa32216.scala:19:36 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mnumStr\e[0m = numMap.get(cur.floor).toString\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m      value floor is not a member of Long.\n\e[31m   |\e[0m      An extension\
    \ method was tried, but could not be fully constructed:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m          doubleWrapper(cur)\n1 error found\n"
  stdout: ''
  timestamp: 1660010787
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var numeral = \"\"\n        var counter = -1\n        var last = 0\n\n \
    \       var romanChars = scala.collection.mutable.Map[Long, String]()\n\n    \
    \    for(i <- 0 to 4) {\n            counter = number.toInt\n            romanChars\
    \ += (counter -> romanNumToChar(i))\n        }\n\n        for(i <- romanChars.keys.toList)\
    \ {\n            val romanNum = i\n            val romanChar = romanChars(i)\n\
    \n            if(romanNum > 0) {\n                if(number % romanNum == 0) {\n\
    \                    numeral += romanChar\n                    number /= romanNum\n\
    \                } else if(number != 0) {\n                    numeral += romanChar\n\
    \                    number = number / romanNum\n                }\n         \
    \   }\n        }\n\n        if(number > 0) {\n            numeral += romanNumToChar(counter)\n\
    \            numeral += romanNumToChar(number.toInt)\n        }\n\n        numeral.toLowerString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4lmukvay.scala:23:38 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            romanChars += (counter -> romanNumToChar(i))\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                      Not found: romanNumToChar\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4lmukvay.scala:33:27\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                    number\
    \ /= romanNum\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m              value /= is not a member of Long - did you mean number.!=?\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp4lmukvay.scala:36:27 -----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    number = number / romanNum\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    Reassignment to val number\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp4lmukvay.scala:42:20 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            numeral += romanNumToChar(counter)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp4lmukvay.scala:42:23 ------------------------\e[0m\e[0m\n\
    \e[31m42 |\e[0m            numeral += romanNumToChar(counter)\n\e[31m\e[31m  \
    \ |\e[0m                       ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \             Not found: romanNumToChar\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp4lmukvay.scala:43:20 ------------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m            numeral += romanNumToChar(number.toInt)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E006] "
  stdout: ''
  timestamp: 1660010789
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val nums = number.toString.toInt\n        val letters = mutable.StringBuilder.newBuilder\n\
    \        \n        for (i <- 0 until nums) {\n            val index = nums - i\
    \ - 1\n            val d = index / 100\n            val c = index % 100\n    \
    \        val l = i.toString.charAt(0).toLowerCase\n\n            val r = if (c\
    \ >= 10) \"M\" else if (c >= 5) \"D\" else \"C\"\n            val v = if (d >=\
    \ 10) { if (c == 0) \"M\" else \"CM\" }\n                    else if (d >= 5)\
    \ \"D\" else \"C\"\n\n            val x = if (d >= 10) \"X\" else if (d >= 5)\
    \ \"L\" else \"C\"\n            letters.append(if (d >= 10) l + r else l + r +\
    \ v + x)\n        }\n        letters.result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0epsvw57.scala:16:22 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mletters\e[0m = mutable.StringBuilder.newBuilder\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp0epsvw57.scala:22:41 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = i.toString.charAt(\e\
    [31m0\e[0m).toLowerCase\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value toLowerCase is not a member of Char\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010789
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     val romanStrings = romanStrings(number)\n        romanStrings.map(x=>x.toLowerCase).mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(intToMiniRoman((19l)).equals((\"\
    xix\")));\n    assert(intToMiniRoman((152l)).equals((\"clii\")));\n    assert(intToMiniRoman((251l)).equals((\"\
    ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"\
    d\")));\n    assert(intToMiniRoman((1l)).equals((\"i\")));\n    assert(intToMiniRoman((4l)).equals((\"\
    iv\")));\n    assert(intToMiniRoman((43l)).equals((\"xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"\
    xc\")));\n    assert(intToMiniRoman((94l)).equals((\"xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"\
    dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"cm\")));\n    assert(intToMiniRoman((994l)).equals((\"\
    cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"m\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyb3j4k1n.scala:15:27 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mromanStrings\e[0m = romanStrings(number)\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35mromanStrings\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010787
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n    // and return it in lowercase.\n    // Restrictions: 1 <= num <=\
    \ 1000\n    // Examples:\n    // >>> intToMiniRoman((19l))\n    // (\"xix\")\n\
    \    // >>> intToMiniRoman((152l))\n    // (\"clii\")\n    // >>> intToMiniRoman((426l))\n\
    \    // (\"cdxxvi\")\n    def intToMiniRoman(number : Long) : String = {\n   \
    \     var result: String = \"\"\n        val digits = scala.collection.mutable.ArrayBuffer(0,\
    \ 4, 9, 13, 27, 40, 51, 60)\n        var i = 1\n        var roman = 0\n      \
    \  while(i <= number) {\n            roman += (number % 10) * i\n            number\
    \ = number / 10\n            i += 1\n        }\n        val romans = scala.collection.mutable.ArrayBuffer(\"\
    \", \"M\", \"MM\", \"MMM\", \"MMMM\", \"MMMMM\", \"MMMMMM\", \"MMMMMMM\", \"MMMMMMMM\"\
    )\n        val length = romans.length\n        var romanLength = 0\n        while(romanLength\
    \ < length) {\n            if(romans[romanLength] == \"\") {\n               \
    \ romanLength += 1\n            } else {\n                break\n            }\n\
    \        }\n        romanLength -= 1\n        while(romanLength > 0) {\n     \
    \       result += romans(romanLength)\n            romanLength -= 1\n        }\n\
    \        while(roman > 0) {\n            if(roman % 1000 == 0) {\n           \
    \     result += \"M\"\n                roman -= 1000\n            } else if(roman\
    \ % 100 == 0) {\n                result += \"D\"\n                roman -= 100\n\
    \            } else if(roman % 10 == 0) {\n                result += \"C\"\n \
    \               roman -= 10\n            } else if(roman == 1) {\n           \
    \     result += \"M\"\n            } else {\n                result += \"M\"\n\
    \            }\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(intToMiniRoman((19l)).equals((\"xix\")));\n    assert(intToMiniRoman((152l)).equals((\"\
    clii\")));\n    assert(intToMiniRoman((251l)).equals((\"ccli\")));\n    assert(intToMiniRoman((426l)).equals((\"\
    cdxxvi\")));\n    assert(intToMiniRoman((500l)).equals((\"d\")));\n    assert(intToMiniRoman((1l)).equals((\"\
    i\")));\n    assert(intToMiniRoman((4l)).equals((\"iv\")));\n    assert(intToMiniRoman((43l)).equals((\"\
    xliii\")));\n    assert(intToMiniRoman((90l)).equals((\"xc\")));\n    assert(intToMiniRoman((94l)).equals((\"\
    xciv\")));\n    assert(intToMiniRoman((532l)).equals((\"dxxxii\")));\n    assert(intToMiniRoman((900l)).equals((\"\
    cm\")));\n    assert(intToMiniRoman((994l)).equals((\"cmxciv\")));\n    assert(intToMiniRoman((1000l)).equals((\"\
    m\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptjfaih0h.scala:20:18 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            roman += (number % \e[31m10\e[0m) * i\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E052] Type\
    \ Error: /tmp/tmptjfaih0h.scala:21:19 -----------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m            number = number / \e[31m10\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val number\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptjfaih0h.scala:28:22\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m(romans[\e\
    [35mromanLength\e[0m] == \e[31m\"\"\e[0m) {\n\e[31m\e[31m   |\e[0m           \
    \           ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ type romanLength\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptjfaih0h.scala:31:16\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010789
