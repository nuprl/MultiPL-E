name: HumanEval_151_double_the_difference
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a list of numbers, return the sum of squares of the numbers\n    //\
  \ in the list that are odd. Ignore numbers that are negative or not integers.\n\
  \    // >>> doubleTheDifference((List[Float](1l.toLong, 3l.toLong, 2l.toLong, 0l.toLong)))\n\
  \    // (10l)\n    // >>> doubleTheDifference((List[Float](-1l.toLong, -2l.toLong,\
  \ 0l.toLong)))\n    // (0l)\n    // >>> doubleTheDifference((List[Float](9l.toLong,\
  \ -2l.toLong)))\n    // (81l)\n    // >>> doubleTheDifference((List[Float](0l.toLong)))\n\
  \    // (0l)\n    // If the input list is empty, return 0.\n    def doubleTheDifference(lst\
  \ : List[Float]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(doubleTheDifference((List[Float]()))\
  \ == (0l));\n    assert(doubleTheDifference((List[Float](5.0f.toFloat, 4.0f.toFloat)))\
  \ == (25l));\n    assert(doubleTheDifference((List[Float](0.1f.toFloat, 0.2f.toFloat,\
  \ 0.3f.toFloat))) == (0l));\n    assert(doubleTheDifference((List[Float](-10.0f.toFloat,\
  \ -20.0f.toFloat, -30.0f.toFloat))) == (0l));\n    assert(doubleTheDifference((List[Float](-1.0f.toFloat,\
  \ -2.0f.toFloat, 8.0f.toFloat))) == (0l));\n    assert(doubleTheDifference((List[Float](0.2f.toFloat,\
  \ 3.0f.toFloat, 5.0f.toFloat))) == (34l));\n    assert(doubleTheDifference((List[Float](-9.0f.toFloat,\
  \ -7.0f.toFloat, -5.0f.toFloat, -3.0f.toFloat, -1.0f.toFloat, 1.0f.toFloat, 3.0f.toFloat,\
  \ 5.0f.toFloat, 7.0f.toFloat, 9.0f.toFloat))) == (165l));\n    }\n\n}\n"
completions: ["        if (lst.isEmpty) 0\n        else lst.filter( x => x % 2 !=\
    \ 0).sum", "      var sum = 0\n      var sumSquare = 0\n      for( i <- lst )\
    \ {\n        if( (i.toLong % 2) != 0 ) {\n          sum += i.toLong\n        \
    \  sumSquare += i * i\n        }\n      }\n      if (lst.size == 0) {\n      \
    \  0\n      } else if (sum > 0) {\n        sum.toLong\n      } else {\n      \
    \  0\n      }", "        lst.foldLeft(0l) { (sum, element) =>\n            if\
    \ ((element % 2) == 1) sum + element\n            else sum\n        }", "    \
    \    if (lst.size == 0) {\n            return 0l\n        }\n        var sum =\
    \ 0l\n        var index = 0l\n        for(i <- 0 until lst.size) {\n         \
    \   sum += (i.toLong * i.toLong)\n            if (lst.apply(i) % 2 == 1l) index\
    \ += 1l\n        }\n        sum", "        lst.foldLeft((0l, 0)){ (acc, item)\
    \ =>\n            val curr = acc.getOrElse(item)\n            val prev = (acc.getOrElse(item)\
    \ + item)\n            acc -> (curr + prev)\n        }._1", "        val n = lst.size\n\
    \        var sum : Long = 0\n        var neg : Boolean = false\n\n        lst.foreach{\n\
    \            f => {\n                val x = if (f < 0.0) -f else f\n\n      \
    \          if (f == 0.0) {\n                    sum = sum + 0.0\n            \
    \    } else if (f > 0) {\n                    sum = sum + x * x\n            \
    \    } else if (f < 0) {\n                    neg = true\n                   \
    \ sum = sum + 0.0\n                } else {\n                    sum = sum + 0.0\n\
    \                }\n            }\n        }\n\n        if (neg) -1 * sum\n  \
    \      else sum", '      lst.filter(x => x.isFloat && !x.isNaN && x.toInt % 2
    == 1).map(_ * _).sum', "        val oddsSquared : mutable.Set[Float] = mutable.Set[Float]()\n\
    \        for(i <- lst if !(i<0 && !i.toInt))\n            oddsSquared += i*i\n\
    \        lst.filterNot(oddsSquared.contains).sum.toLong", "        val map = mutable.Map[Int,\
    \ Float]()\n        lst.foreach{\n            x => {\n                val num\
    \ = (x * (x / 2.0)).toInt\n                if (map.contains(num)) map.update(num,\
    \ x + map.get(num))\n                else map.update(num, x)\n            }\n\
    \        }\n        map.values.sum", "        val oddsSum = lst.filter(_ % 2).toList\n\
    \        val evensSum = lst.filter(_ % 2 != 0).toList\n        oddsSum.sum * oddsSum.sum\
    \ +\n            evensSum.sum * evensSum.sum", "        if (lst.size == 0) {\n\
    \            return 0\n        }\n        val listAsArray = lst.toArray\n    \
    \    var sum = 0\n        for (i <- listAsArray) {\n            sum += Math.pow(i,\
    \ 2)\n        }\n        return sum", "        return lst.filter(i => !i%2l.toLong).foldLeft((0l.toLong))\
    \ {\n            case ((sum, sumSq)) => sum + sumSq\n        }", "        val\
    \ summed = lst.map(x => if (x.toInt % 2 == 1) x * x else 0)\n        val summedAndOdd\
    \ = summed.filter(_ % 2 == 1)\n        summedAndOdd.reduce(_ + _)", "        val\
    \ sum = lst.map(n => if (n % 2 == 0) n.toLong else 0).toSet.sum\n        math.pow(sum,\
    \ 2).toLong", "        if (lst.empty) 0 else lst.foldLeft((0l,0l)) {\n       \
    \     case ((soFar,current),currentElem) =>\n                val currentAsLong\
    \ = currentElem.toLong\n                if (currentAsLong%2 == 1) (soFar+currentAsLong,soFar+currentAsLong)\
    \ else\n                    current\n        }._1", "        // Your code goes\
    \ here\n        var result = 0\n        for(i <- 0 to lst.last){\n           \
    \ if(lst(i).isFinite){\n                result = result + ((lst(i) ^ lst(i + 1))\
    \ * 2)\n            }\n        }\n        result", "        val list = lst.filter(f\
    \ => f.toDouble % 2f.toDouble > 0)\n        if (list.isEmpty)\n            return\
    \ 0\n        list.sum", '        lst.foldLeft(0l) { (acc, x) => if (x % 2 == 1)
    acc + x else acc }', "        val sumOddNumbers = lst.filter { i =>\n        \
    \    i % 2 == 1 // check if i is odd\n        }.foldLeft(0l)((acc, i) => acc +\
    \ (i.toLong * i.toLong))\n        sumOddNumbers", "        val numbers = mutable.ListBuffer.empty[Float]\n\
    \        lst.foreach { number => if (number < 0f.toFloat || number.toInt != number)\
    \ numbers += number.toFloat }\n        if (numbers.isEmpty) 0\n        else numbers.sum.pow(2).floor.toLong",
  "        def sumSquared(lst : List[Float]) : Long = {\n            def isEven(i:\
    \ Int) : Boolean = i % 2 == 0\n            def isOdd(i: Int) : Boolean = !isEven(i)\n\
    \            val evenSquares = lst.filter( isEven(_) )\n            val oddSquares\
    \ = lst.filter( isOdd(_) )\n            evenSquares.sum + evenSquares.sum\n  \
    \      }\n\n        if(lst.isEmpty) 0\n        else sumSquared(lst) * sumSquared(lst)",
  "        def addSquare(a: Float, b: Float) = { Math.pow(a, 2) + Math.pow(b, 2) }\n\
    \        def sumOdds(lst: List[Float], m: Long): Long = {\n            var sum\
    \ = m.toLong\n            var evenSum = m.toLong\n            lst.reverse.foreach\
    \ { x =>\n                if (x % 2 == 0) {\n                    evenSum = evenSum\
    \ + x\n                } else {\n                    sum = sum + addSquare(x,\
    \ sum)\n                }\n            }\n            evenSum\n        }\n\n \
    \       if (lst.size <= 0) 0\n        else sumOdds(lst, lst.sum)", "        val\
    \ sum = 0L\n        for(i <- 0 until lst.size) {\n            val current = lst(i)\n\
    \            if(current < 0f || current % 1f != 0.0f)\n                continue\n\
    \            sum += current * current\n        }\n        return sum", "     \
    \   def square(x : Float) : Long = {\n            val a = x.toLong\n         \
    \   math.pow(a, 2)\n        }\n        val count = lst.count{x => x < 0} + lst.count{x\
    \ => x % 1 != 0}\n        if(lst.isEmpty) 0\n        else if(count == 0) lst.sum\n\
    \        else lst.map{x => x * x}.sum + square(lst.sum)", "        val result:\
    \ mutable.Buffer[Long] = mutable.Buffer[Long]()\n        if (lst.isEmpty) 0\n\
    \        else lst.tail.foldLeft(0l) { (sum, elem) =>\n            if (elem.toInt\
    \ % 2 == 1) sum + (elem * elem)\n            else sum\n        }", "        lst.foldLeft(0l){\
    \ (sum, el) =>\n            if(el % 2 == 1) sum + el\n            else sum\n \
    \       }", "        // TODO: Complete this function\n        var sum = 0\n  \
    \      lst.foreach( i =>\n            if (i != 0f)\n                sum += i *\
    \ i\n        )\n        sum", "        val odd = lst.filter( x => x.toInt % 2\
    \ == 1 ).toList\n        val odd_squares = odd.map( x => x * x ).toList\n    \
    \    val odd_sum : Long = odd_squares.sum\n        val odd_sum_squares : Long\
    \ = odd_sum * odd_sum\n        odd_sum_squares", "        if(lst.size == 0) 0\n\
    \        else lst.foldLeft(0){(acc, i) => if (i % 2 == 1) acc * i + i}", "   \
    \   lst.map{ x =>\n        if (x < 0) {\n          throw new IllegalArgumentException(\"\
    negative number: \" + x)\n        }\n        if (x % 2 == 1) { // even integer\n\
    \          x * x\n        } else {\n          throw new IllegalArgumentException(\"\
    non-even number: \" + x)\n        }\n      }.sum", "        val rdd1 = sc.parallelize(lst)\n\
    \        val rdd2 = rdd1.filter(x => !(x.isNaN && x.isInfinite))\n        val\
    \ rdd3 = rdd2.filter(x => x.toLong % 2 == 1)\n        rdd3.map(x => x.toLong *\
    \ x.toLong).reduce(_ + _)", "        if(lst.nonEmpty)\n            lst.map(x =>\
    \ if (math.abs(x) < 2) x*x else 0).reduceLeft(_+_)\n        else 0", "       \
    \ val l1 = lst.filter(_ % 2 == 0).sum\n        val l2 = lst.filter(_ % 2 != 0).sum\n\
    \        if (l1 == 0l) 0l\n        else if (l2 == 0l) 0l\n        else (l1 + l2)\
    \ / 2l", "        if(lst.isEmpty) 0\n        else sum(lst.filter { x => if (x.toInt\
    \ % 2 == 0) x **2 else 0 } : _*)", "        if (lst.isEmpty) 0\n        else {\n\
    \            val n = (lst.sum * lst.sum).toLong\n            val s = lst.filter\
    \ { x => x.toLong % 2 != 0 }.sum\n            (n - s).toLong\n        }", "  \
    \      val m = lst.map(_ => 1).toSet.toList\n        lst.filter { x => x % 2 ==\
    \ 0 && !x.toInt().isNaN && m.contains(x) }\n                .sum", "        if\
    \ (lst.size > 0) \n            lst.reduceLeft((x,y) => if (y % 2 != 0) x + y else\
    \ x) + doubleTheDifference(lst.tail)\n        else 0", "        def sum(lst: List[Float])\
    \ : Float = lst.toList.foldLeft(0.0f) { case (acc, x) => acc + x }\n        val\
    \ sumDiff = sum(lst) - sum(lst.filter(_ % 2 == 1).toList)\n        if (lst.size\
    \ == 0) 0\n        else sumDiff.toLong", "        var sum : Long = 0l\n      \
    \  for(i <- lst.indices) {\n            val f = lst(i)\n            if(f.toLong\
    \ % 2 != 0) {\n                sum += f\n            }\n        }\n        if(lst.isEmpty)\
    \ {\n            return 0l\n        }\n        return sum", "        val x = lst.filter(x\
    \ => x % 2 == 1)\n        if (x.isEmpty) 0\n        else x.map(x => x * x).sum",
  "        val sum = 0L\n        val odd = mutable.ListBuffer[Float]()\n        for(x\
    \ <- lst) {\n            if(x.toLong % 2 == 1) {\n                odd += x\n \
    \           }\n        }\n        for(x <- odd) {\n            sum += x\n    \
    \    }\n        sum", "        if (lst.nonEmpty)\n            lst.map(x => if\
    \ (x % 2 == 1) (x * x) else if (x < 0) -(-x) else if (x > 0) (x * x) else x).toList.reduce(_\
    \ + _)\n        else\n            return 0", "      require(lst.nonEmpty)\n  \
    \    lst.foldLeft(0l){ (sum, current) => \n        if(current % 2l.toLong == 0)\
    \ sum + current * current else sum\n      }", "        var total = 0L\n      \
    \  lst.foreach(x => {\n            if ((x% 2) == 0) {\n                total =\
    \ total + x\n            }\n        })\n        total", "        def oddEvenSum(lst:\
    \ List[Float]): Long = {\n            val evenSum = lst.filter(_ % 2 == 0).foldLeft(0l)((sum,\
    \ num) => sum + num)\n            val oddSum = lst.filter(_ % 2 != 0).foldLeft(0l)((sum,\
    \ num) => sum + num)\n            oddSum + evenSum\n        }\n        val l =\
    \ lst.size\n        if (l == 0) 0\n        else if (l == 1) oddEvenSum(lst)\n\
    \        else oddEvenSum(lst.reverse)", "        // Create map to keep track of\
    \ whether each number is odd or not.\n        val isOdd : Map[Float, Boolean]\
    \ = lst.map( x => (x, false) ).view.toMap\n\n        // Initialize sum\n     \
    \   var sum = 0f\n\n        // Loop over the input list\n        for ( x <- lst\
    \ ) {\n            // If the number is odd, add it to the sum and set its flag\
    \ to true.\n            if ( isOdd.getOrElse(x, false) ) {\n                sum\
    \ += x\n                isOdd(x) = true\n            }\n        }\n\n        //\
    \ Return sum\n        sum", '        lst.foldLeft(0l)((l, (acc, n) => (if (n %
    2 == 1) acc + (n * n) else acc)))', '        lst.filter(_ % 2 != 0).sum', "  \
    \      if (lst.nonEmpty) lst.filter(x => x.toLong%2 == 1).sum * lst.filter(x =>\
    \ x.toLong%2 == 0).sum\n        else 0", "        var sum = 0\n        lst.foreach\
    \ { x =>\n            if (x % 2 == 1 && !x.toInt == 0) sum += x\n        }\n \
    \       sum", "        def odd(n:  Int) : Boolean = if (n < 0) false else n %\
    \ 2 == 1\n        val total = 0l\n        if (lst.nonEmpty) lst\n        else\
    \ 0l\n            .map(_ => total += _)\n            .filter(odd)\n          \
    \  .sum", "        if (lst.isEmpty) 0\n        else lst.filterNot(_ < 0l).map(x\
    \ => (x * x).filterNot(_ % 2 == 0l).sum).sum", "        if (lst.isEmpty) 0\n \
    \       else {\n            var sum : Float = 0\n            var lastOdd : Float\
    \ = 0\n            var lastOddPos : Int = -1\n            for(x<-lst){\n     \
    \           if (x % 2 != 0 && x % 2 != 1) {\n                    lastOdd = x\n\
    \                    lastOddPos = x\n                }\n                if (x\
    \ % 2 == 1) {\n                    val curSum = sum + x\n                    if\
    \ (curSum % 2 == 1) sum = curSum\n                }\n            }\n         \
    \   sum + (lastOdd - lastOddPos)\n        }", "        val sum = 0.0\n       \
    \ lst.foreach{ x =>\n            if (x < 0f || x % 1f != 0f)\n            {\n\
    \                sum += x\n            }\n        }\n        sum.toLong", "  \
    \      var sum = 0.0\n        lst.foreach( x =>\n                if (x % 2 ==\
    \ 1) sum += x * x\n            )\n        sum", "      def square(x: Float) =\
    \ x * x\n      def sumSquare(xs: List[Float]) : Long = xs.foldLeft(0l)(sumSquare)\n\
    \      def sumEven(xs: List[Float]) : Long = xs.foldLeft(0l)(sumEven)\n      def\
    \ isOdd(x: Float) : Boolean = x % 2 != 0\n      def isEven(x: Float) : Boolean\
    \ = x % 2 == 0\n      def doSum(xs: List[Float]) : Long = {\n        val even\
    \ = sumEven(xs)\n        val odd = sumSquare(xs) - even\n        if (isOdd(odd))\n\
    \          odd + even\n        else\n          even\n      }\n      if (lst.isEmpty)\n\
    \        0\n      else\n        doSum(lst)", "        lst.foldLeft(0l) { (sum,\
    \ current) =>\n            if (current % 2 == 0) {\n                sum += current.toLong\n\
    \            }\n            else {\n                sum\n            }\n     \
    \   }", "        val lst2 = lst.filter(_ % 2 == 0)\n        if (lst2.isEmpty)\
    \ 0\n        else\n            lst.zip(lst2).filter { case (x, y) => x.toLong\
    \ > y.toLong }.map(_._1).sum", "        require(lst.nonEmpty)\n        val ls\
    \ = lst.filter(_ >= 0l).filter(_ < 2l).filter(_ % 2l != 0l).map(_*2l)\n      \
    \  lst.foldLeft(0l)(_ +: _)", "        val nums = lst.filter(_.isFloat)\n    \
    \    if (nums.isEmpty) 0\n        else {\n            var sum = 0\n          \
    \  var i = 0\n            var currentSum = 0\n            var currentNum = 0\n\
    \            for (i <- 0 until nums.length){\n                currentNum = nums(i)\n\
    \                currentSum = currentNum * currentNum\n                if (currentSum\
    \ % 2 == 1)\n                    sum += currentSum\n            }\n          \
    \  sum\n        }", "        var sum : Long = 0\n        var total : Long = 0\n\
    \        lst.foreach{ x =>\n            if(x % 2 != 0){\n                sum +=\
    \ x\n                total += x\n            }\n        }\n        if(total >\
    \ 0){\n            sum *= total\n        }\n        return sum", "        val\
    \ nums = lst.filter(_ < 0f).filter(_ > 0f).filter(_ % 2 != 0f).map(_.toLong)\n\
    \        if (nums.isEmpty) {\n            return 0\n        }\n        val res\
    \ = new mutable.HashSet[Float]()\n        nums.foreach{ x =>\n            if (res.contains(x))\
    \ {\n                res.remove(x)\n            } else {\n                res.add(x)\n\
    \            }\n        }\n        res.toList.map(x => x * x).sum", "        //\
    \ If the list is empty, return 0.\n        if(lst.isEmpty) 0\n        // Get the\
    \ sum of the squares\n        val sumOfSquares = lst.sum{x => x*x}\n        //\
    \ Return the sum of the squares of the odd numbers in the list.\n        // If\
    \ the list is empty, return 0.\n        if(lst.forall(n => n % 2 == 1)) sumOfSquares\
    \ * sumOfSquares\n        // Otherwise, return the sum of squares of the numbers\
    \ that are odd.\n        else lst.filter(n => n % 2 == 1).sum{x => x*x} * lst.filter(n\
    \ => n % 2 == 1).sum{x => x*x}", "        if (lst.size < 2) 0\n        else {\n\
    \            val doubleLst =\n                lst.map(i => if (i % 2 == 0) (i.toLong\
    \ * i) else i.toLong)\n            doubleLst.foldLeft(0l) { (l, e) => (l + e.toLong)\
    \ }\n        }", "        val sum : Long = lst.map(x => (x + x).asInstanceOf[Int]).sum\n\
    \        if (lst.nonEmpty) {\n            val sumOdd = lst.filter(x => x % 2 ==\
    \ 1).sum\n            sum - sumOdd\n        }\n        else {\n            0\n\
    \        }", "        var sum = 0\n        lst.foreach(x => if (isOdd(x)) sum\
    \ += x * x else 0)\n        sum", "        val l = new mutable.ListBuffer[Float]()\n\
    \        for(i <- 0 to lst.size-1 if ! (lst.apply(i).toInt % 2))\n           \
    \ l.append(lst.apply(i))\n        l.toList.map(i => (i*i).toLong).sum", "    \
    \    if (lst.isEmpty) 0L\n        else {\n            var result = 0.0\n     \
    \       for (f <- lst) {\n                val isOdd = f % 2 != 0\n           \
    \     if (isOdd) result += f\n            }\n            result\n        }", " \
    \       val n = lst.head\n        val squareSum = lst.map {\n            x =>\
    \ if (x < 0) 0 else x * x\n        }.sum\n\n        var squaredSum : Long = 0\n\
    \        for (x <- 0 until n) {\n            squaredSum += squareSum\n       \
    \ }\n\n        if (n == 0)\n            return 0\n\n        if (n == 1)\n    \
    \        squaredSum\n        else if (n % 2 == 0)\n            squareSum - squaredSum\
    \ / n\n        else\n            squareSum - squaredSum / n - (squareSum / n -\
    \ squareSum / n) / 2", "      if (lst.isEmpty)\n        return 0.\n      else\
    \ {\n        val n = new mutable.ListBuffer[Float]()\n        for (x <- lst) if\
    \ (x % 2 != 0) n.append(x*x)\n        n.sum\n      }", "        lst match {\n\
    \            case Nil => 0\n            case x :: Nil => 0\n            case x\
    \ :: xs => x + doubleTheDifference(xs)\n        }", "        val m = lst.map(_.toInt).filter(_\
    \ % 2 != 0)\n        val sum = m.sum\n        sum.toLong", "        def square(num\
    \ : Float) : Float = {\n            num*num\n        }\n\n        val numbers\
    \ = lst.map(x => if (x.toLong == 0) 0 else x)\n        val doubles = numbers.map(x\
    \ => if (x == 0) 0 else x*x)\n        val squareSum = doubles.reduce(_ + _)\n\
    \        val doubleSum = numbers.filter(x => x % 2 == 0).map(x => x*x).reduce(_\
    \ + _)\n        squareSum - doubleSum", "        def helper(lst : List[Float],\
    \ acc : Long = 0) : Long = {\n            if(lst.isEmpty) acc\n            else\
    \ {\n                val lastNumber = lst.head\n                lst.tail.foreach\
    \ { number =>\n                    acc += (number * number)\n                }\n\
    \                helper(lst.tail, acc)\n            }\n        }\n        helper(lst)",
  "        var sum = 0\n        val odd = mutable.Set[Float]()\n        lst.foreach(x\
    \ => if (x == 0) return // Ignore negative values\n        if (x < 0) return;\
    \ // Ignore negative values\n        if (x < 0) return; // Ignore negative values\n\
    \        if (x % 2 == 1) odd += x\n        else sum += x\n        val result =\
    \ lst.filterNot(x => x % 2 == 1 && !odd.contains(x))\n        if (result.length\
    \ == 0) 0 else sum * sum.toLong", "        val nums = lst.filter(_ % 2 == 1) //\
    \ Take only odd numbers\n        val sum = 0l\n        for ((n,n2) <- nums.zip(nums.tail))\
    \ sum+=n*n // Sum of pairwise sums\n        if(nums.isEmpty) sum else sum.toLong",
  "        val nums = lst.filter(n => n.toDouble % 1L != 0).toList\n        val sum\
    \ = (0 until nums.size).map(x => nums(x) * nums(x)).sum\n        sum.toLong",
  "        val evens = lst.filter(_%2 == 0)\n        val odd = lst.filter(_%2 != 0)\n\
    \        val result = evens.reduceLeft(_ + _)\n        odd.map(x => if (x == 0)\
    \ 0 else x).sum", "        var i = 0\n        var j = 1\n        var sum = 0\n\
    \        val n = lst.length\n        while (i < n && j < n) {\n            if\
    \ (lst(i) % 2 == 0) {\n                sum += lst(j)\n                i += 1\n\
    \            } else {\n                j += 1\n            }\n        }\n    \
    \    if (i == n) {\n            sum\n        } else {\n            0\n       \
    \ }", "        val list = lst.filter(x => x != 0).toList\n        val sumOfSquares\
    \ = list.map(x => x * x).sum\n        val totalDouble = sumOfSquares * sumOfSquares\n\
    \        val result = (list.filter(x => x % 2 == 1).length * list.filter(x =>\
    \ x % 2 == 0).length).toLong + totalDouble\n        result", "        val ans\
    \ = mutable.ListBuffer.empty[Float]\n        lst.foreach(n => {\n            if\
    \ (n % 2 == 1) ans += n\n        })\n        if (ans.nonEmpty) ans.sum * ans.sum\n\
    \        else 0", "        val even: mutable.HashSet[Float] = mutable.HashSet[Float]()\n\
    \        var sum: Long = 0\n        lst.foreach { elem =>\n            if (elem.toInt\
    \ % 2 == 0) even += elem\n            else sum += elem\n        }\n        val\
    \ nums = even ++ Seq.fill(even.size)((0).toFloat)\n        nums diff lst toSeq\n\
    \            .flatMap(x => x % 2 == 0l && even.toSeq.contains(x).toOption.toSeq\
    \ match {\n                case Some(true) => even.toSeq\n                case\
    \ _          => Seq(x).toSeq\n            })\n            .reduceLeft(_ + _)",
  "        val nums = lst.filter(_ % 2 != 0l)\n        val sum = nums.reduce(_ + _)\n\
    \        sum.toLong", "      if (lst.size == 0)\n        return 0\n\n      val\
    \ res = lst.foldLeft(0l) { case (sum, value) =>\n        val current = value.toLong\n\
    \        if (current % 2 == 1)\n          sum + current\n        else\n      \
    \    sum\n      }\n      res", "        val s = lst.map(x => if (x == 0) 0 else\
    \ x ** 2)\n        val a = lst.map(x => if (x == 0) 0 else x)\n        val b =\
    \ lst.map(x => if (x == 0) 0 else -x)\n        val c = lst.filter(x => x != 0)\n\
    \        val s0 = s.sum\n        val a = a.sum\n        val b = b.sum\n      \
    \  val c = c.sum\n        val f = (s0 + a * b + c) / (a.length * b.length)\n \
    \       f", "        require(!lst.isEmpty)\n        require(!lst.contains(0f))\n\
    \        require(!lst.contains(-0f))\n        require(!lst.contains(1f))\n   \
    \     require(!lst.contains(-1f))\n        lst.foldLeft(0l)((acc,x) => (if (x%2==1)\
    \ acc+x else acc))", "        if (lst.isEmpty) 0\n        else {\n           \
    \ val summands = lst.filter(_ % 2 == 1)\n            val sum = summands.sum\n\
    \            val square = summands.map(x => x * x).sum\n            (sum ^ 2l)\
    \ - (square ^ 2l) \n        }", '        lst.map(i => if (i % 2 == 0) i * i else
    0).sum', "        var sum = 0\n        val odds = mutable.Set.empty[Float]\n \
    \       for (elm <- lst) \n            if (elm.toLong % 2 != 0) \n           \
    \     sum += elm\n                else\n                odds += elm\n        odds\
    \ foreach{ sum +=  _ }\n        if (sum == 0) \n            0\n        else\n\
    \            sum.toLong", "        val r = lst.filter( x => x % 2l.toDouble >\
    \ 0l.toDouble)\n        r.reduce( _ + _ )", "        var sum = 0\n        for(i\
    \ <- 0 until lst.size) {\n            val f = lst(i)\n            if(f < 0 ||\
    \ f.toLong % 2 == 0) {\n                sum += 1\n            }\n        }\n \
    \       sum.toLong", "        if(lst.size == 0)\n            return 0\n      \
    \  val nums = lst.map(_.toLong)\n        val evens = nums.filter(x => x.isEven)\n\
    \        val odds = nums.filter(x => !x.isEven)\n        val total = evens.sum\
    \ + odds.sum\n        return total", "        val odd = mutable.Set[Float]()\n\
    \        var sum = 0\n        for (x <- lst)\n            if (x % 2 == 1)\n  \
    \              sum ++= x * x\n            else {\n                if (!odd.contains(x))\n\
    \                    odd.add(x)\n                else\n                    odd.remove(x)\n\
    \            }\n        if (odd.isEmpty) 0 else {\n            val sum2 = sum\n\
    \            odd.foreach { x => sum2 -= x * x }\n            sum2 * sum2\n   \
    \     }", "        // Your code here.\n        lst.filter(x => math.abs(x) % 2\
    \ == 1).sum", "        val nums = lst.filter(_ % 2L != 0L)\n        if(nums.isEmpty)\
    \ 0L\n        else nums.reduceLeft((x: Float, y: Float) => x + y)", "        def\
    \ f(lst : List[Float]): Long = lst.foldLeft(0l) {\n            case (acc, el)\
    \ =>\n                if (el.isFloat) {\n                    acc + (el.asFloat\
    \ / 2)\n                } else {\n                    acc\n                }\n\
    \        }\n        if (lst.nonEmpty) {\n            f(lst)\n        } else {\n\
    \            0l\n        }", "        val ls = lst.filter(x => x >= 0f && x %\
    \ 1f == 0f).map(_.toLong)\n        if (ls.isEmpty) 0\n        else ls.sum", " \
    \       lst match {\n            case Nil => 0\n            case x :: xs => x.toLong\
    \ match {\n                case x if (x == 0.0) => 0\n                case x if\
    \ (x < 0.0) => x.toLong * x.toLong\n                case x => x.toLong * (x.toLong\
    \ - 1) + x.toLong * x.toLong\n            }\n        }", '        lst.filter(a
    => a % 2 != 0).map(a => Math.pow(2.0,a)).reduce(_+_)', "        if (lst.isEmpty)\
    \ 0\n        else {\n            lst.foldLeft(0l) { (acc, i) =>\n            \
    \    if (i % 2l.toLong == 0) acc + i\n                else acc\n            }\n\
    \        }", "        if (lst.isEmpty) {\n            return 0\n        }\n  \
    \      var total = 0L\n        var count = 0\n        for (x<-lst) {\n       \
    \     if (x % 2 != 0 && x != 0) {\n                total += x\n              \
    \  count += 1\n            }\n        }\n        total += count * count\n    \
    \    return total", '        lst.map( x => Math.pow(Math.abs(x), 2) ).sum', " \
    \       if (lst.isEmpty) 0\n        else (lst.filter(x => x % 2 == 1).map(x =>\
    \ x * x).sum * 2) + (lst.filter(x => x % 2 == 0).map(x => x * x).sum * 2)", " \
    \       val even = lst.filter( x => !( x < 0) && !( x % 2 == 0) )\n        val\
    \ odd = lst.filter( x => !( x < 0) && !( x % 2 == 1) )\n        val sumOfSquares\
    \ = even.map( x => math.pow(x, 2) ).sum + odd.map( x => math.pow(x, 2) ).sum\n\
    \        val sum = even.sum + odd.sum\n        sumOfSquares - (sum * sum)", " \
    \       val sum : Float = 0\n        for (x: Float <- lst) if (x > 0) sum += x\n\
    \        for (x: Float <- lst) if (x > 0) sum += x\n        sum", "        var\
    \ sum = 0\n        lst.foreach( x => if (x.isOdd) sum += x.toLong * x.toLong)\n\
    \        if (sum > 0) sum.toLong else 0", "        val sum = 0\n        for (n:\
    \ Float <- lst) {\n            if (n % 2 == 1) sum += n * n\n        }\n     \
    \   sum.toLong", "        def sumSquared(i: Float) : Long = {\n            val\
    \ sq = i * i\n            if (sq >= Integer.MAX_VALUE) Integer.MAX_VALUE - sq\n\
    \            else sq\n        }\n        val odds = lst.filter(_ % 2 != 0).toList\n\
    \        if (odds.isEmpty) 0\n        else odds.map(sumSquared).reduce(_ + _)",
  "        def sumOdd(a : Int) : Float = {\n            if (a % 2 == 0) 0.0f else\
    \ 1.0f\n        }\n        val doubleList = lst.map( x => sumOdd(x) )\n      \
    \  return sumOdd(doubleList.sum)", '        lst.foldLeft(0l) { (acc, x) => acc
    + x*x }', "        if (lst.size==0)\n            return 0\n        val even =\
    \ lst.filter(x => x%2==0l)\n        val odd = lst.filter(x => x%2==1l)\n     \
    \   even.map(x => x*(2l.toLong)).sum + odd.map(x => x*(2l.toLong)).sum", '        lst.map
    { x => if (x.toLong % 2 == 1) x else 0 }.fold(0L)(_ + _)', "        if (lst.isEmpty)\
    \ 0\n        else {\n            lst.foldLeft(0l)((acc,curr) => acc + (if (curr%2\
    \ == 1) curr*curr else curr))\n        }", "        val result = lst.filter(_\
    \ % 2 == 1).sum\n        if(lst.size == 0) result else lst.sum - result", "  \
    \      if (lst.nonEmpty) {\n            lst.map {x =>\n                if (x.toLong\
    \ % 2 == 1)\n                    x * x\n                else\n               \
    \     0\n            }.sum\n        } else {\n            return 0\n        }",
  "        val numbers = lst.filter(_ >= 0f).map(_.toLong)\n        if(numbers.length\
    \ == 0){\n            return 0l\n        }\n        val result = numbers.foldLeft(0l)\
    \ { (sum, value) => sum + (value * value) }\n        result", "        val doubles\
    \ = lst.filter(x => x % 2 == 0).map(x => x * x)\n        val odd = doubles.filter(x\
    \ => x % 2 == 1).map(x => x / 2).sum\n        return lst.fold(0)(_ + _) - odd",
  "        var sum : Long = 0\n        lst.foreach(x => if (x % 2 == 1l) sum += x^2)\n\
    \        sum", "        if (lst.nonEmpty) {\n            lst.foldLeft(0l) { (sum,\
    \ i) => if (i % 2 == 0) sum + i else sum }\n        } else {\n            return\
    \ 0l\n        }", "        if (lst.forall(x => x < 0) || lst.forall(_.toInt !=\
    \ x.toInt)) 0l\n        else lst.foldLeft(0l) { (s,e) => s + e * e }", "     \
    \   val map = new mutable.HashMap[Float,Long]\n        for (e <- lst) {\n    \
    \        if (e < 0f || e.toInt < 0) {\n                continue\n            }\n\
    \            map.put(e % 1f, map.getOrElse(e % 1f, 0l) + e)\n        }\n     \
    \   map.values.sum", "        if (lst.nonEmpty) {\n            if (lst.length\
    \ == 1) {\n                0\n            } else if (lst.length == 2) {\n    \
    \            lst(1) + lst(1)\n            } else {\n                val evenSum\
    \ = lst(0) * (2l)(lst(1))\n                val oddSum = lst(0)\n             \
    \   (lst(1) + oddSum).map(i => if (i % 2 == 1) evenSum + i else evenSum - i).toLong\n\
    \            }\n        } else {\n            0\n        }", "        if (lst.size\
    \ == 0)\n            return 0L\n        var sum = 0L\n        val odd = lst.filter(x\
    \ => x % 2L != 0L).toList\n        val even = lst.filter(x => x % 2L == 0L).toList\n\
    \        for (x <- odd :: even) {\n            sum += Math.pow(x, 2L)\n      \
    \  }\n        sum", "        val result = new mutable.ListBuffer[Float]()\n  \
    \      for (ln <- lst if ln > 0) result ++= ln * ln\n        if (result.isEmpty)\
    \ return 0\n        result.toList.sum", "        val n = lst.size\n        var\
    \ sum = 0\n        var sumSquares: Long = 0\n        var sumOddsSquare: Long =\
    \ 0\n        var sumOddsSquares: Long = 0\n        var x = 0\n        var y =\
    \ 0\n        for(i <- 0 until n) {\n            x = lst(i)\n            y = x\
    \ + x\n            if (y % 2 == 0) {\n                sumOddsSquares  = sumOddsSquares\
    \ + x\n                sumOddsSquares = sumOddsSquares + x\n            } else\
    \ {\n                sumOddsSquare = sumOddsSquare + x\n            }\n      \
    \      sum = sum + x\n        }\n        if (sum == 0) {\n            return 0\n\
    \        } else if (sum == n) {\n            return sumSquares\n        } else\
    \ {\n            return (sumOddsSquares/sum) - sumOddsSquare/sum\n        }",
  "        lst.foreach(x => if (x > 0) println(\"Calculating: \" + x) else println(\"\
    Ignoring: \" + x))\n        var sum : Long = 0\n        lst.foreach(x => {\n \
    \           if (x % 2 == 1)\n                sum += x\n        })\n        return\
    \ sum", "        if (lst.isEmpty) 0\n        else {\n            val odd = lst.filter(!_.isInstanceOf[java.lang.Integer]).map(n\
    \ => (n*n)).filter(_.toLong % 2 == 1).toList\n            if (odd.isEmpty) 0\n\
    \            else odd.reduceLeft((x, y) => x + y).toLong\n        }", "      \
    \  val result = 0l\n        lst.foreach{\n            f =>\n                if\
    \ (f >= 0f)\n                    result += f\n        }\n        result", '      lst.filter
    { x => x % 2 != 0 }.sum.toLong', "        var sum = 0L\n        val result = mutable.ListBuffer.empty[Float]\n\
    \n        for (number <- lst if number.toLong % 2 == 0) {\n            sum +=\
    \ number\n        }\n\n        result.add((sum).toFloat)\n\n        if (result.size\
    \ == 0) {\n            return 0\n        } else {\n            result.head\n \
    \       }", "        val res = mutable.ListBuffer.empty[Float]\n        lst.foreach{\
    \ a =>\n            if (a > 0) res ::= a\n            else a match {\n       \
    \         case x : Float => res ::= x\n                case x : Long => res ::=\
    \ x\n            }\n        }\n        res.filter(_ %2 != 0).sum", "        val\
    \ squareSum = mutable.MutableList[Float]()\n        var sum = 0L\n        for\
    \ (x <- lst) {\n            if (x % 2 == 1) {\n                sum += x\n    \
    \        }\n            else {\n                squareSum.append(x)\n        \
    \    }\n        }\n        if (squareSum.isEmpty) {\n            return 0\n  \
    \      }\n        else {\n            val result = math.pow((sum), 2)\n      \
    \      squareSum.foreach(result += _)\n            return result\n        }",
  "        val sum = 0L\n        lst.foreach(i => {\n            val n = math.abs(i)\n\
    \            if (i % 2 != 0) {\n                sum += n\n            }\n    \
    \    })\n        sum", "        var sum = 0L\n        for(i <- 0 until lst.size)\
    \ {\n            if(lst(i) > (1l << 63) || lst(i) < -1l || lst(i).asInstanceOf[Float]\
    \ % 1l == 0)\n                continue\n            sum += lst(i).asInstanceOf[Float]\
    \ * lst(i).asInstanceOf[Float]\n        }\n        sum", "        val result =\
    \ 0.0\n        if(lst.forall(_.toDouble % 2 == 0)){\n            result = lst.filter(_\
    \ % 2 == 0).sum\n        }\n        result", "        val doubleList = lst.filter(f\
    \ => f % 2 == 1)\n        val num: Int = 0\n        val squareList = doubleList.map(f\
    \ => math.pow(f.toDouble, 2)).toSeq\n        squareList.forall(s => s % 2 != 0)\n\
    \        if (squareList.isEmpty) 0 else squareList.sum", "        val sum = 0l\n\
    \        for(i <- lst.view.filter(_ % 2 == 0l).sum) sum += i * i\n        sum.toLong",
  "      require(!lst.isEmpty, \"List cannot be empty!\")\n      var squareSum = 0\n\
    \      lst.foreach { x => \n        if (x % 2 != 0) {\n          squareSum +=\
    \ x * x\n        }\n      }\n      return squareSum.toLong", '        lst.for{f
    => if (f < 0) 0l else f}.filter(_ % 2l).foldLeft(0l)(_ + _)', "        var sum\
    \ = 0L\n        for( x <- lst ) {\n            if( x < 0l || x > 1l ) continue\n\
    \            sum += x.toLong\n        }\n        if( sum == 0 ) return 0l\n  \
    \      return sum", "        var sum = 0\n        for(x <- lst) {\n          \
    \  if (x > 0) sum += x * x\n            if (x < 0) sum += x * x\n        }\n \
    \       sum", "        // Initialize a mutable variable to hold sum.\n       \
    \ var sum : Long = 0L\n        // For each element in the input list...\n    \
    \    lst.foreach{element =>\n            // If element is odd, add to sum.\n \
    \           if(element % 2 != 0)\n                sum += element\n        }\n\
    \        // Return sum at the end of the function.\n        sum", "        lst.map\
    \ { x =>\n            val y = x.toInt\n            if (y < 0) 0\n            else\
    \ if (y % 2 == 1) y * y\n            else Double.PositiveInfinity - x\n      \
    \  }.reduce(_ + _)", "        val sum = 0\n        for ((i, f) <- lst.zipWithIndex\
    \ if !(f<0||f.toInt==0)){\n            sum += f * f\n        }\n        sum.toLong",
  "        val map = new mutable.HashMap\n        val n = lst.size\n        for ((i,x)\
    \ => if (x>0l) map.put(i.toLong,x) else map.remove(i.toLong))\n        val res\
    \ = sumSquare(n,map)\n        map.valuesIterator.map(_.toLong).sum", "       \
    \ var sum = 0\n        for (f <- lst) {\n            if (f % 2 == 1 || (f < 0)\
    \ || (f % 1 != 0)) {\n                sum += f\n            }\n        }\n   \
    \     sum * sum", "        val squareSum = lst.foldLeft(0l){(acc, x) => acc +\
    \ math.pow(x - lst.head, 2)}\n        if (lst.size == 0) 0\n        else if (squareSum.lt(0l))\
    \ lst.head.asInstanceOf[Long] else squareSum", "        val sumOfOddSquares =\
    \ lst.filter(x => x % 2 != 0).map(x => x * x).sum\n        sumOfOddSquares match\
    \ {\n            case 0 => 0\n            case _ => sumOfOddSquares\n        }",
  "        var sum = 0\n        lst.foreach(x => sum+=x*x)\n        sum.toLong", '        lst.view.filter(_
    % 2 != 0).toList.reduce(_ + _)', "        if (lst.isEmpty) 0\n        else {\n\
    \            lst.map(x => math.pow(x, 2l)).sum \n        }", "        val sum\
    \ = (lst.filter(_ % 2 != 0).toList.sum).pow(2).asInstanceOf[Long]\n        val\
    \ sum1 = (lst.filter(_ % 2 == 0).toList.sum).pow(2).asInstanceOf[Long]\n     \
    \   if (sum == 0 && sum1 == 0) 0 else sum - sum1", "        val sum = 0\n    \
    \    val oddSum = lst.filter(x => x % 2 == 1l).sum\n        sum += oddSum\n  \
    \      val evenSum = lst.filter(x => x % 2 == 0l).sum\n        sum += evenSum\n\
    \        sum", "        lst match {\n            case Nil => 0\n            case\
    \ h :: t =>\n                val isOdd: List[Boolean] = t.zipWithIndex.collect\
    \ {\n                    case (_, i) if i % 2 == 1 => true\n                 \
    \   case _                           => false\n                }.toList\n    \
    \            val newList = new mutable.ListBuffer[Float]()\n                t.foreach(x\
    \ => if (isOdd(x)) { newList += x; })\n                t.length - newList.size\
    \ match {\n                    case 0 => 0\n                    case _ => t.toLong\
    \ + t.toLong + t.toLong\n                }\n        }", "        if (lst.isEmpty)\
    \ 0\n        else {\n            val odd = lst.filter(f => f % 2 == 1).toList\n\
    \            val even = lst.filter(f => f % 2 == 0).toList\n            val sum\
    \ = even.foldLeft(0L){ (sum, curr) => sum + curr }\n            sum + odd.sum\n\
    \        }", "        var sum = 0l\n        for (a <- lst if !isNegative(a) &&\
    \ !isInteger(a)) {\n            sum += a * a\n        }\n        sum", "     \
    \   val ls = lst filter { x => x.toLong > 0f && x.toLong <= 1L } map { x => x.toLong\
    \ * x }\n        val res = ls.sum\n        if(ls.isEmpty) 0 else res", "     \
    \   if (lst.isEmpty) return 0L\n        var sum = 0L\n        for (v <- lst if\
    \ v.toLong % 2L == 0L) {\n            sum += v\n        }\n        sum", "   \
    \     val ns = new mutable.Queue[Int](lst.length)\n        val d = new mutable.ListBuffer[Float]()\n\
    \        for(i <- 0 until lst.size) {\n            if(lst(i).isOdd) {\n      \
    \          ns += lst(i)\n                d += lst(i).toFloat\n            }\n\
    \        }\n        if(!ns.isEmpty) {\n            val n = ns.pop\n          \
    \  d += n\n        }\n        d.sum.toLong", "        var sum : Long = 0\n   \
    \     for (i <- lst.indices) sum += lst.filter(_ != lst.apply(i)).length * (lst.filter(_\
    \ != lst.apply(i)).sum / lst.filter(_ != lst.apply(i)).size)\n        if (lst.isEmpty)\
    \ 0\n        else sum", "        val r = lst.filter(_ % 2 == 1)\n        var sum\
    \ = 0\n        for (x <- r.iterator) {\n            sum += x\n        }\n    \
    \    return sum.toLong", "        // Add all numbers, squares, odd, to list\n\
    \        val sumOfOddSquares : Long = (0 until lst.size).\n            foldLeft(0l)\
    \ { (sum, idx) => sum + lst(idx) * lst(idx) }\n        // Return sum of squares\
    \ plus all numbers\n        sumOfOddSquares + (lst.size until 0l)", "        if\
    \ (lst.forall(_.isNegative) || lst.forall(_.toString.forall(_.isDigit))) 0\n \
    \       else lst.filterNot(_ < 0).sum * lst.filterNot(_ % 2 == 0).sum", "    \
    \    lst.foldLeft(0l) {\n            case (sum, elm) => if (elm.toLong % 2 ==\
    \ 1)\n                           sum += elm.toLong * elm.toLong\n            \
    \               else sum\n            case _           => 0l\n        }", "  \
    \      if (lst.nonEmpty) {\n            lst.view.filter(_ % 2 == 1).sum\n    \
    \    } else {\n            return 0\n        }", "        def f(lst: mutable.WrappedArray[Float],\
    \ accum: Long): mutable.WrappedArray[Float] = {\n            if(lst.isEmpty) {\n\
    \                return lst\n            }\n            val first: Float = lst(0)\n\
    \            if(first > -Float.MaxValue) lst(0) = -(first + first)\n         \
    \   if(first < -Float.MaxValue) lst(0) = -(first - first)\n            if(first\
    \ < 0) lst(0) = -first\n            if(first == 0) lst(0) = 0\n            f(lst.removeFirst(),\
    \ accum + first * first)\n        }\n        val result = f(lst, 0l)\n       \
    \ if(result.isEmpty) 0\n        else result(0)", "        if(lst.isEmpty) {\n\
    \            return 0\n        }\n        val evenValues = lst.filter(_ % 2 ==\
    \ 0).filter(_ > 0).toList\n        val oddValues = lst.filter(_ % 2 == 1).filter(_\
    \ > 0).toList\n        evenValues match {\n            case Nil => 0l\n      \
    \      case hd::tl => hd.toLong * hd.toLong + doubleTheDifference(tl)\n      \
    \  }", "        // write your code here\n        if(lst.size == 0){\n        \
    \    return 0\n        }\n        var sum = 0\n        var flag = false\n    \
    \    for(x <- lst){\n            if((x%2) == 1){\n                sum = sum +\
    \ x\n                flag = true\n            }\n        }\n        if(!flag){\n\
    \            sum = sum - lst(0) + lst(1)\n        }\n        return sum", "  \
    \      // Sum all the squares of the odd numbers in the list\n        var sum\
    \ = 0\n        for (x <- lst if x % 2 != 0) sum += x * x\n        // Return 0\
    \ if list is empty\n        if(lst.size == 0) 0\n        // Otherwise, return\
    \ sum * sum\n        else sum * sum", "        var ret = 0L\n        var sum =\
    \ 0L\n        var count = 0L\n        var max = 0L\n        for (x <- lst) {\n\
    \            if (x < 0f) continue\n            if (x > 0f) sum <- sum + x\n  \
    \          count = count + 1\n            if (count == max) max <- max\n     \
    \       if (x % 2f == 1f) {\n                ret <- sum + sum\n              \
    \  sum = 0L\n                count = 0L\n            }\n        }\n        if\
    \ (max < 1f) ret <- 0\n        ret", '        lst.foldLeft(0l)((acc, elem) =>
    acc + (elem % 2l) * elem)', "        val newList = lst.filter(_ > 0l)\n      \
    \  val sum = 0l\n        newList.foreach( x => {\n            if (x % 2l != 0l)\
    \ {\n                sum +=  x\n            }\n        })\n        sum", "   \
    \     lst.foldLeft(0l) { (sum, value) =>\n            if (value != 0.0) {\n  \
    \              if (math.abs(value) % 2 == 1) sum + value.toLong\n            \
    \    else sum\n            } else {\n                sum\n            }\n    \
    \    }", "        if(lst.nonEmpty)\n            lst.filter(x => !(x % 1l).isOdd\
    \ && (x % 1l).isZero).map(x => x*x).sum\n        else\n            return 0l",
  "        val list = lst.filter(_ % 2 == 1)\n        if (list.isEmpty) 0\n      \
    \  else list.sum * list.sum", "        lst match {\n            case Nil => 0\n\
    \            case _  => lst.filter(x => x % 2 != 0).sum.toLong\n        }", " \
    \       if (lst.isEmpty) 0\n        else {\n            var result : Long = 0\n\
    \            var index = 0\n            while (index < lst.size) {\n         \
    \       var next = (lst.apply(index * 2 + 1))\n                if (next.toLong\
    \ % 2 == 0) result = result + next.toLong\n                index = index + 1\n\
    \            }\n            result\n        }", "        val numSum = lst.map(x\
    \ => if (x.toLong % 2) == 0 then x + x else x)\n        val sum = numSum.reduce((x,\
    \ y) => x + y)\n        return sum.toLong", "        require(lst.nonEmpty)\n \
    \       lst.filter(x => math.signum(x) % 2 == 1l).sum", '      lst.filter(_ >
    0).sum', "      val odd = lst.filter(f => f % 2l==0l).toSet\n      if (odd.isEmpty)\
    \ 0l else (odd.foldLeft(0l) { (acc, f) => acc + f*f }).toLong", '        lst.filter(_
    % 2 == 1).map(_ * _).sum', '        lst.filter(l => l.toInt % 2 == 1 && !l.toInt.isNaN
    && l.toInt > 0).sum', "        require(!lst.isEmpty)\n        var sum = 0\n  \
    \      lst.foreach(x => \n            if (x % 2 == 0) sum += x*x \n          \
    \  else sum -= x*x )\n        sum", "        if (lst.size < 1) return 0\n    \
    \    val odd = mutable.MutableList[Long]()\n        val even = mutable.MutableList[Long]()\n\
    \        for (f: Float <- lst) {\n            if (f % 2 == 0) {\n            \
    \    even += f\n            } else {\n                odd += f\n            }\n\
    \        }\n        val sumEven = even.foldLeft(0l)((x,y) => x + y)\n        val\
    \ sumOdd = odd.foldLeft(0l)((x,y) => x + y)\n        sumEven - sumOdd", "    \
    \    val list = lst.filter(_ % 2 == 1)\n        list.map(x => x * x).sum", " \
    \       val ns = lst.filterNot(_ < 0)\n        ns.map(_ * _).sum", "        if\
    \ (lst.size == 0)\n            return 0\n        else {\n            var sum:\
    \ Float = 0f\n            var sum2: Float = 0f\n            for (elem <- lst)\
    \ {\n                if (elem.toFloat % 2 != 0)\n                    sum += elem.toFloat\n\
    \                else {\n                    sum2 += elem.toFloat\n          \
    \      }\n            }\n            return sum * sum\n        }", "        val\
    \ nums = lst.filter(_ % 2 == 1)\n        if (nums.isEmpty) 0\n        else nums.sum\
    \ * nums.sum", "        val result = mutable.ListBuffer.empty[Long]\n        lst.filter(x\
    \ => isOdd(x)).foreach(x => result ++= x*x)\n        result.headOption.getOrElse(0)",
  "        val lst2 = lst.filter{x => x < 0} ++ lst.filter{x => x < 2} ++ lst.filter{x\
    \ => x % 2 == 0} \n        val lst3 = lst2.filter{x => x % 2 != 0} \n        if\
    \ (lst3.isEmpty) 0\n        else lst3.foldLeft(0l){(a,b) => a + Math.pow(b, 2)}",
  "        val l = lst.size\n        var sum = 0\n        for (ix <- 0 until l) {\n\
    \            sum += if (lst(ix) % 2l) lst(ix) else 0l\n        }\n        sum",
  "        val l2 = lst.map(_ * _)\n        l2.reduce(_ + _)", "        if (lst.nonEmpty)\
    \ {\n            val x = lst(0)\n            val y = lst.filter(_ % 2 != 0)\n\
    \            return x +  y.foldLeft(x)(_ + _)\n        }\n        else 0", " \
    \     val evens = lst.filter(x => x.toInt % 2 == 0)\n      val odds   = lst.filter(x\
    \ => x.toInt % 2 != 0)\n      evens.sum + odds.sum * 2", "        val sum = 0l\n\
    \        if (lst.nonEmpty) {\n            lst.foreach(x => if (x.toInt % 2 ==\
    \ 1) sum += x * x else if (!x.toInt.toFloat.isNaN) sum += (x - x.toInt).toFloat\
    \ * x.toInt)\n        }\n        if (sum < 0L) sum *= -1\n        sum", "    \
    \    var sum = 0\n        val list = lst.filter(_ % 2 == 1)\n        if(list.isEmpty)\n\
    \            return 0\n        for(i <- list)\n            sum += i\n        return\
    \ sum", "        def sumSquared(x : Float) : Long = { if (x == 0l) 0l else (math.pow(x,\
    \ 2)) }\n        def getOddNumbers(nums : List[Float]) : List[Float] = {\n   \
    \         def odd(x : Float) : Boolean = {\n                if (x < 0l || x >\
    \ 0l) false\n                else {\n                    if (x % 2l != 0l) false\n\
    \                    else {\n                        if (x % 4l != 0l) false\n\
    \                        else true\n                    }\n                }\n\
    \            }\n            def filterOddNums(nums : List[Float]) : List[Float]\
    \ = {\n                if (nums.isEmpty) List[Float]() else nums.filter(x => odd(x))\n\
    \            }\n            filterOddNums(nums).map(x => sumSquared(x)).toList\n\
    \        }\n        val odds = getOddNumbers(lst)\n        val sumOdds = odds.reduceLeft(_\
    \ + _)\n        sumOdds.toLong", "        val odd = lst.filter(_%2==1)\n     \
    \   if(odd.isEmpty) {\n            return 0\n        }\n        else {\n     \
    \       val odd_sum = odd.foldLeft(0l) { (a,b) => a + b}\n            val even\
    \ = lst.filter(_%2==0)\n            val even_sum = even.foldLeft(0l) { (a,b) =>\
    \ a + b}\n            odd_sum - (even_sum * even_sum)\n        }", '        lst.map
    { x => if (x < 0) 0 else (x % 2 == 0) ? x * x : x}.sum']
stop_tokens:
- "\n    }\n"
